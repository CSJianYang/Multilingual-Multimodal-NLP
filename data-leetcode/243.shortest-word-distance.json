[
    {
        "title": "Multiply Strings",
        "question_content": "Given two non-negative integers num1 and num2 represented as strings, return the product of num1 and num2, also represented as a string.\nNote:&nbsp;You must not use any built-in BigInteger library or convert the inputs to integer directly.\n&nbsp;\nExample 1:\nInput: num1 = \"2\", num2 = \"3\"\nOutput: \"6\"\nExample 2:\nInput: num1 = \"123\", num2 = \"456\"\nOutput: \"56088\"\n&nbsp;\nConstraints:\n\n\t1 <= num1.length, num2.length <= 200\n\tnum1 and num2 consist of digits only.\n\tBoth num1 and num2&nbsp;do not contain any leading zero, except the number 0 itself.",
        "solutions": [
            {
                "id": 17605,
                "title": "easiest-java-solution-with-graph-explanation",
                "content": "Remember how we do multiplication? \\n\\nStart from right to left, perform multiplication on every pair of digits, and add them together.  Let's draw the process! From the following draft, we can immediately conclude:\\n\\n     `num1[i] * num2[j]` will be placed at indices `[i + j`, `i + j + 1]` \\n \\n<hr>\\n\\n<a href='https://drscdn.500px.org/photo/130178585/m%3D2048/300d71f784f679d5e70fadda8ad7d68f' target='_blank'><img src='https://drscdn.500px.org/photo/130178585/m%3D2048/300d71f784f679d5e70fadda8ad7d68f' border='0' alt=\"Multiplication\" width=\"100%\"/></a>\\n\\n<hr>\\n\\nHere is my solution. Hope it helps!\\n\\n    public String multiply(String num1, String num2) {\\n        int m = num1.length(), n = num2.length();\\n        int[] pos = new int[m + n];\\n       \\n        for(int i = m - 1; i >= 0; i--) {\\n            for(int j = n - 1; j >= 0; j--) {\\n                int mul = (num1.charAt(i) - '0') * (num2.charAt(j) - '0'); \\n                int p1 = i + j, p2 = i + j + 1;\\n                int sum = mul + pos[p2];\\n\\n                pos[p1] += sum / 10;\\n                pos[p2] = (sum) % 10;\\n            }\\n        }  \\n        \\n        StringBuilder sb = new StringBuilder();\\n        for(int p : pos) if(!(sb.length() == 0 && p == 0)) sb.append(p);\\n        return sb.length() == 0 ? \"0\" : sb.toString();\\n    }\\n\\n\\n  [1]: http://postimg.org/image/tltx29dcx/",
                "solutionTags": [
                    "Java"
                ],
                "code": "Remember how we do multiplication? \\n\\nStart from right to left, perform multiplication on every pair of digits, and add them together.  Let's draw the process! From the following draft, we can immediately conclude:\\n\\n     `num1[i] * num2[j]` will be placed at indices `[i + j`, `i + j + 1]` \\n \\n<hr>\\n\\n<a href='https://drscdn.500px.org/photo/130178585/m%3D2048/300d71f784f679d5e70fadda8ad7d68f' target='_blank'><img src='https://drscdn.500px.org/photo/130178585/m%3D2048/300d71f784f679d5e70fadda8ad7d68f' border='0' alt=\"Multiplication\" width=\"100%\"/></a>\\n\\n<hr>\\n\\nHere is my solution. Hope it helps!\\n\\n    public String multiply(String num1, String num2) {\\n        int m = num1.length(), n = num2.length();\\n        int[] pos = new int[m + n];\\n       \\n        for(int i = m - 1; i >= 0; i--) {\\n            for(int j = n - 1; j >= 0; j--) {\\n                int mul = (num1.charAt(i) - '0') * (num2.charAt(j) - '0'); \\n                int p1 = i + j, p2 = i + j + 1;\\n                int sum = mul + pos[p2];\\n\\n                pos[p1] += sum / 10;\\n                pos[p2] = (sum) % 10;\\n            }\\n        }  \\n        \\n        StringBuilder sb = new StringBuilder();\\n        for(int p : pos) if(!(sb.length() == 0 && p == 0)) sb.append(p);\\n        return sb.length() == 0 ? \"0\" : sb.toString();\\n    }\\n\\n\\n  [1]: http://postimg.org/image/tltx29dcx/",
                "codeTag": "Unknown"
            },
            {
                "id": 17608,
                "title": "ac-solution-in-java-with-explanation",
                "content": "    public class Solution {\\n        public String multiply(String num1, String num2) {\\n            int n1 = num1.length(), n2 = num2.length();\\n            int[] products = new int[n1 + n2];\\n            for (int i = n1 - 1; i >= 0; i--) {\\n                for (int j = n2 - 1; j >= 0; j--) {\\n                    int d1 = num1.charAt(i) - '0';\\n                    int d2 = num2.charAt(j) - '0';\\n                    products[i + j + 1] += d1 * d2;\\n                }\\n            }\\n            int carry = 0;\\n            for (int i = products.length - 1; i >= 0; i--) {\\n                int tmp = (products[i] + carry) % 10;\\n                carry = (products[i] + carry) / 10;\\n                products[i] = tmp;\\n            }\\n            StringBuilder sb = new StringBuilder();\\n            for (int num : products) sb.append(num);\\n            while (sb.length() != 0 && sb.charAt(0) == '0') sb.deleteCharAt(0);\\n            return sb.length() == 0 ? \"0\" : sb.toString();\\n        }\\n    }\\n\\nIf we break it into steps, it will have the following steps. 1. compute products from each pair of digits from num1 and num2. 2. carry each element over. 3. output the solution.\\n\\nThings to note:\\n\\n1. The product of two numbers cannot exceed the sum of the two lengths. (e.g. 99 * 99 cannot be five digit)\\n\\n2.\\n\\n    int d1 = num1.charAt(i) - '0';\\n    int d2 = num2.charAt(j) - '0';\\n    products[i + j + 1] += d1 * d2;",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n        public String multiply(String num1, String num2) {\\n            int n1 = num1.length(), n2 = num2.length();\\n            int[] products = new int[n1 + n2];\\n            for (int i = n1 - 1; i >= 0; i--) {\\n                for (int j = n2 - 1; j >= 0; j--) {\\n                    int d1 = num1.charAt(i) - '0';\\n                    int d2 = num2.charAt(j) - '0';\\n                    products[i + j + 1] += d1 * d2;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 17646,
                "title": "brief-c-solution-using-only-strings-and-without-reversal",
                "content": "This is the standard manual multiplication algorithm. We use two nested for loops, working backward from the end of each input number. We pre-allocate our result and accumulate our partial result in there. One special case to note is when our carry requires us to write to our sum string outside of our for loop.\\n\\nAt the end, we trim any leading zeros, or return 0 if we computed nothing but zeros.\\n\\n    string multiply(string num1, string num2) {\\n        string sum(num1.size() + num2.size(), '0');\\n        \\n        for (int i = num1.size() - 1; 0 <= i; --i) {\\n            int carry = 0;\\n            for (int j = num2.size() - 1; 0 <= j; --j) {\\n                int tmp = (sum[i + j + 1] - '0') + (num1[i] - '0') * (num2[j] - '0') + carry;\\n                sum[i + j + 1] = tmp % 10 + '0';\\n                carry = tmp / 10;\\n            }\\n            sum[i] += carry;\\n        }\\n        \\n        size_t startpos = sum.find_first_not_of(\"0\");\\n        if (string::npos != startpos) {\\n            return sum.substr(startpos);\\n        }\\n        return \"0\";\\n    }",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "This is the standard manual multiplication algorithm. We use two nested for loops, working backward from the end of each input number. We pre-allocate our result and accumulate our partial result in there. One special case to note is when our carry requires us to write to our sum string outside of our for loop.\\n\\nAt the end, we trim any leading zeros, or return 0 if we computed nothing but zeros.\\n\\n    string multiply(string num1, string num2) {\\n        string sum(num1.size() + num2.size(), '0');\\n        \\n        for (int i = num1.size() - 1; 0 <= i; --i) {\\n            int carry = 0;\\n            for (int j = num2.size() - 1; 0 <= j; --j) {\\n                int tmp = (sum[i + j + 1] - '0') + (num1[i] - '0') * (num2[j] - '0') + carry;\\n                sum[i + j + 1] = tmp % 10 + '0';\\n                carry = tmp / 10;\\n            }\\n            sum[i] += carry;\\n        }\\n        \\n        size_t startpos = sum.find_first_not_of(\"0\");\\n        if (string::npos != startpos) {\\n            return sum.substr(startpos);\\n        }\\n        return \"0\";\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1563507,
                "title": "c-simple-easy-and-short-solution-brief-explanation",
                "content": "**Idea:**\\nWe are using regular mathematical vertical multiplication.\\nWe loop from the end of both numbers, multiply the digits one at a time and save the carry in the next cell for the next iteration.\\nThe loop at the end constructs the result string - we skip 0s at the beginning and add the numbers.\\n\\n**Time Complexity:** O(mn)\\n**Space Complexity:** O(n+m)\\n```\\nclass Solution {\\npublic:\\n    string multiply(string num1, string num2) {\\n        if (num1 == \"0\" || num2 == \"0\") return \"0\";\\n        \\n        vector<int> res(num1.size()+num2.size(), 0);\\n        \\n        for (int i = num1.size()-1; i >= 0; i--) {\\n            for (int j = num2.size()-1; j >= 0; j--) {\\n                res[i + j + 1] += (num1[i]-\\'0\\') * (num2[j]-\\'0\\');\\n                res[i + j] += res[i + j + 1] / 10;\\n                res[i + j + 1] %= 10;\\n            }\\n        }\\n        \\n        int i = 0;\\n        string ans = \"\";\\n        while (res[i] == 0) i++;\\n        while (i < res.size()) ans += to_string(res[i++]);\\n        \\n        return ans;\\n    }\\n};\\n```\\n**Like it? please upvote!**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string multiply(string num1, string num2) {\\n        if (num1 == \"0\" || num2 == \"0\") return \"0\";\\n        \\n        vector<int> res(num1.size()+num2.size(), 0);\\n        \\n        for (int i = num1.size()-1; i >= 0; i--) {\\n            for (int j = num2.size()-1; j >= 0; j--) {\\n                res[i + j + 1] += (num1[i]-\\'0\\') * (num2[j]-\\'0\\');\\n                res[i + j] += res[i + j + 1] / 10;\\n                res[i + j + 1] %= 10;\\n            }\\n        }\\n        \\n        int i = 0;\\n        string ans = \"\";\\n        while (res[i] == 0) i++;\\n        while (i < res.size()) ans += to_string(res[i++]);\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 17615,
                "title": "simple-python-solution-18-lines",
                "content": "\\n    def multiply(num1, num2):\\n        product = [0] * (len(num1) + len(num2))\\n        pos = len(product)-1\\n        \\n        for n1 in reversed(num1):\\n            tempPos = pos\\n            for n2 in reversed(num2):\\n                product[tempPos] += int(n1) * int(n2)\\n                product[tempPos-1] += product[tempPos]/10\\n                product[tempPos] %= 10\\n                tempPos -= 1\\n            pos -= 1\\n            \\n        pt = 0\\n        while pt < len(product)-1 and product[pt] == 0:\\n            pt += 1\\n    \\n        return ''.join(map(str, product[pt:]))",
                "solutionTags": [],
                "code": "\\n    def multiply(num1, num2):\\n        product = [0] * (len(num1) + len(num2))\\n        pos = len(product)-1\\n        \\n        for n1 in reversed(num1):\\n            tempPos = pos\\n            for n2 in reversed(num2):\\n                product[tempPos] += int(n1) * int(n2)\\n                product[tempPos-1] += product[tempPos]/10\\n                product[tempPos] %= 10\\n                tempPos -= 1\\n            pos -= 1\\n            \\n        pt = 0\\n        while pt < len(product)-1 and product[pt] == 0:\\n            pt += 1\\n    \\n        return ''.join(map(str, product[pt:]))",
                "codeTag": "Python3"
            },
            {
                "id": 458001,
                "title": "easier-than-the-easiest-java-solution",
                "content": "```\\nclass Solution {\\n\\tpublic String multiply(String num1, String num2) {\\n\\t\\tif (\"0\".equals(num1) || \"0\".equals(num2))\\n\\t\\t\\treturn \"0\";\\n\\n\\t\\tint[] ans = new int[num1.length() + num2.length() - 1];\\n\\n\\t\\tfor (int i = 0; i < num1.length(); i++) {\\n\\t\\t\\tfor (int j = 0; j < num2.length(); j++) {\\n\\t\\t\\t\\tans[i + j] += (num1.charAt(i) - \\'0\\') * (num2.charAt(j) - \\'0\\');\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tfor (int i = ans.length - 1; i > 0; i--) {\\n\\t\\t\\tans[i - 1] += ans[i] / 10;\\n\\t\\t\\tans[i] %= 10;\\n\\t\\t}\\n\\n\\t\\tStringBuilder sb = new StringBuilder();\\n\\t\\tfor (int i : ans) {\\n\\t\\t\\tsb.append(i);\\n\\t\\t}\\n\\n\\t\\treturn sb.toString();\\n\\t}\\n\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n\\tpublic String multiply(String num1, String num2) {\\n\\t\\tif (\"0\".equals(num1) || \"0\".equals(num2))\\n\\t\\t\\treturn \"0\";\\n\\n\\t\\tint[] ans = new int[num1.length() + num2.length() - 1];\\n\\n\\t\\tfor (int i = 0; i < num1.length(); i++) {\\n\\t\\t\\tfor (int j = 0; j < num2.length(); j++) {\\n\\t\\t\\t\\tans[i + j] += (num1.charAt(i) - \\'0\\') * (num2.charAt(j) - \\'0\\');\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tfor (int i = ans.length - 1; i > 0; i--) {\\n\\t\\t\\tans[i - 1] += ans[i] / 10;\\n\\t\\t\\tans[i] %= 10;\\n\\t\\t}\\n\\n\\t\\tStringBuilder sb = new StringBuilder();\\n\\t\\tfor (int i : ans) {\\n\\t\\t\\tsb.append(i);\\n\\t\\t}\\n\\n\\t\\treturn sb.toString();\\n\\t}\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 17726,
                "title": "one-digit-at-a-time",
                "content": "Compute the ones-digit, then the tens-digit, then the hundreds-digit, etc. For example when multiplying 1234 with 5678, the thousands-digit of the product is 4\\\\*5 + 3\\\\*6 + 2\\\\*7 + 1\\\\*8 (plus what got carried from the hundreds-digit).\\n\\n    string multiply(string a, string b) {\\n        if (a==\"0\" || b==\"0\")\\n            return \"0\";\\n        int m = a.size() - 1, n = b.size() - 1, carry = 0;\\n        string product;\\n        for (int i=0; i<=m+n || carry; ++i) {\\n            for (int j=max(0, i-n); j<=min(i, m); ++j)\\n                carry += (a[m-j] - '0') * (b[n-i+j] - '0');\\n            product += carry % 10 + '0';\\n            carry /= 10;\\n        }\\n        reverse(begin(product), end(product));\\n        return product;\\n    }",
                "solutionTags": [
                    "C++"
                ],
                "code": "Compute the ones-digit, then the tens-digit, then the hundreds-digit, etc. For example when multiplying 1234 with 5678, the thousands-digit of the product is 4\\\\*5 + 3\\\\*6 + 2\\\\*7 + 1\\\\*8 (plus what got carried from the hundreds-digit).\\n\\n    string multiply(string a, string b) {\\n        if (a==\"0\" || b==\"0\")\\n            return \"0\";\\n        int m = a.size() - 1, n = b.size() - 1, carry = 0;\\n        string product;\\n        for (int i=0; i<=m+n || carry; ++i) {\\n            for (int j=max(0, i-n); j<=min(i, m); ++j)\\n                carry += (a[m-j] - '0') * (b[n-i+j] - '0');\\n            product += carry % 10 + '0';\\n            carry /= 10;\\n        }\\n        reverse(begin(product), end(product));\\n        return product;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 563504,
                "title": "simple-c-solution-with-comments-94-86-faster-100-memory",
                "content": "```\\nclass Solution {\\npublic:\\n    string multiply(string num1, string num2) {\\n        // handle edge-case where the product is 0\\n        if (num1 == \"0\" || num2 == \"0\") return \"0\";\\n        \\n        // num1.size() + num2.size() == max no. of digits\\n        vector<int> num(num1.size() + num2.size(), 0);\\n        \\n        // build the number by multiplying one digit at the time\\n        for (int i = num1.size() - 1; i >= 0; --i) {\\n            for (int j = num2.size() - 1; j >= 0; --j) {\\n                num[i + j + 1] += (num1[i] - \\'0\\') * (num2[j] - \\'0\\');\\n                num[i + j] += num[i + j + 1] / 10;\\n                num[i + j + 1] %= 10;\\n            }\\n        }\\n        \\n        // skip leading 0\\'s\\n        int i = 0;\\n        while (i < num.size() && num[i] == 0) ++i;\\n        \\n        // transofrm the vector to a string\\n        string res = \"\";\\n        while (i < num.size()) res.push_back(num[i++] + \\'0\\');\\n        \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string multiply(string num1, string num2) {\\n        // handle edge-case where the product is 0\\n        if (num1 == \"0\" || num2 == \"0\") return \"0\";\\n        \\n        // num1.size() + num2.size() == max no. of digits\\n        vector<int> num(num1.size() + num2.size(), 0);\\n        \\n        // build the number by multiplying one digit at the time\\n        for (int i = num1.size() - 1; i >= 0; --i) {\\n            for (int j = num2.size() - 1; j >= 0; --j) {\\n                num[i + j + 1] += (num1[i] - \\'0\\') * (num2[j] - \\'0\\');\\n                num[i + j] += num[i + j + 1] / 10;\\n                num[i + j + 1] %= 10;\\n            }\\n        }\\n        \\n        // skip leading 0\\'s\\n        int i = 0;\\n        while (i < num.size() && num[i] == 0) ++i;\\n        \\n        // transofrm the vector to a string\\n        string res = \"\";\\n        while (i < num.size()) res.push_back(num[i++] + \\'0\\');\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1563541,
                "title": "java-easy-clean-solution-w-detailed-example-basic-math-tc-o-mn-sc-o-m-n",
                "content": "Here, we are using the elementary multiplication method, in which we multiply each pair (one from each number) of digits starting from left to right.\\n\\nProduct of `digit at index i in num1` and `digit at index j in num1` will be saved at indexes `i+j` and `i+j+1` in the result array.\\n```\\nresult[i+j+1] = (nums[i] * nums[j]) % 10\\nresult[i+j] = (nums[i] * nums[j]) / 10\\n```\\n\\nThe result length can be maximum: `length_of_num1 + length_of_num2`\\nFor example if input numbers are 99 & 99. Here both the input numbers have length 2 and are the largest possible numbers of length 2. The result is 9801, which is of length 4.\\n\\n---\\n**Time Complexity:** `O(M*N)` --> We will visit each pair of digits in both numbers.\\n\\n**Space Complexity:** `O(M+N)` --> Needed by temporary array and StringBuilder\\n\\n---\\n**Example**\\n\\n```\\n\\t\\t         1  2  3             (num1)\\n         X       4  5  6             (num2)\\n\\t   ==================\\n\\t\\t            1  8             (3*6)\\n\\t\\t         1  2                (2*6)\\n\\t\\t      0  6                   (1*6)\\n\\t   ------------------\\n\\t\\t         1  5                (3*5)\\n\\t\\t      1  0                   (2*5)\\n\\t\\t   0  5                      (1*5)\\n\\t   ------------------\\n\\t\\t      1  2                   (3*4)\\n\\t\\t   0  8                      (2*4)\\n\\t\\t0  4                         (1*4)\\n\\t   ==================\\n\\t\\t0  5  6  0  8  8             (Result)\\n\\t   ==================\\n```\\n\\n---\\n\\n```java\\nclass Solution {\\n    public String multiply(String num1, String num2) {\\n        // Check for valid input\\n        if (num1 == null || num2 == null) {\\n            throw new IllegalArgumentException(\"Input numbers are invalid\");\\n        }\\n\\n        int m = num1.length();\\n        int n = num2.length();\\n\\n        // Base Conditions\\n        if (m == 0 || n == 0 || \"0\".equals(num1) || \"0\".equals(num2)) {\\n            return \"0\";\\n        }\\n        if (\"1\".equals(num1)) {\\n            return num2;\\n        }\\n        if (\"1\".equals(num2)) {\\n            return num1;\\n        }\\n\\n        // Result can be maximum of length M + N.\\n        // For example 99 * 99 = 9801 (Result is of length 4)\\n        int[] result = new int[m + n];\\n\\n        for (int i = m - 1; i >= 0; i--) {\\n            for (int j = n - 1; j >= 0; j--) {\\n                int product = (num1.charAt(i) - \\'0\\') * (num2.charAt(j) - \\'0\\');\\n                // Adding previous values in result array into this product.\\n                product += result[i + j + 1];\\n\\n                // Adding the new product into the result array\\n                result[i + j + 1] = product % 10;\\n                result[i + j] += product / 10;\\n            }\\n        }\\n\\n        // Generating the result String\\n        StringBuilder sb = new StringBuilder();\\n        for (int r : result) {\\n            // Ignoring leading zeros\\n            if (sb.length() == 0 && r == 0) {\\n                continue;\\n            }\\n            sb.append(r);\\n        }\\n\\n        return sb.toString();\\n    }\\n}\\n```\\n\\n---\\n<ins>Other Similar questions on LeetCode:</ins>\\n- [66. Plus One](https://leetcode.com/problems/plus-one/discuss/1529365/Java-or-TC:-O(N)-or-SC:-O(1)-or-Optimized-Math-Addition-simulation)\\n- [2. Add Two Numbers](https://leetcode.com/problems/add-two-numbers/)\\n- [445. Add Two Numbers II](https://leetcode.com/problems/add-two-numbers-ii/)\\n- [67. Add Binary](https://leetcode.com/problems/add-binary/)\\n- [415. Add Strings](https://leetcode.com/problems/add-strings/)\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nresult[i+j+1] = (nums[i] * nums[j]) % 10\\nresult[i+j] = (nums[i] * nums[j]) / 10\\n```\n```\\n\\t\\t         1  2  3             (num1)\\n         X       4  5  6             (num2)\\n\\t   ==================\\n\\t\\t            1  8             (3*6)\\n\\t\\t         1  2                (2*6)\\n\\t\\t      0  6                   (1*6)\\n\\t   ------------------\\n\\t\\t         1  5                (3*5)\\n\\t\\t      1  0                   (2*5)\\n\\t\\t   0  5                      (1*5)\\n\\t   ------------------\\n\\t\\t      1  2                   (3*4)\\n\\t\\t   0  8                      (2*4)\\n\\t\\t0  4                         (1*4)\\n\\t   ==================\\n\\t\\t0  5  6  0  8  8             (Result)\\n\\t   ==================\\n```\n```java\\nclass Solution {\\n    public String multiply(String num1, String num2) {\\n        // Check for valid input\\n        if (num1 == null || num2 == null) {\\n            throw new IllegalArgumentException(\"Input numbers are invalid\");\\n        }\\n\\n        int m = num1.length();\\n        int n = num2.length();\\n\\n        // Base Conditions\\n        if (m == 0 || n == 0 || \"0\".equals(num1) || \"0\".equals(num2)) {\\n            return \"0\";\\n        }\\n        if (\"1\".equals(num1)) {\\n            return num2;\\n        }\\n        if (\"1\".equals(num2)) {\\n            return num1;\\n        }\\n\\n        // Result can be maximum of length M + N.\\n        // For example 99 * 99 = 9801 (Result is of length 4)\\n        int[] result = new int[m + n];\\n\\n        for (int i = m - 1; i >= 0; i--) {\\n            for (int j = n - 1; j >= 0; j--) {\\n                int product = (num1.charAt(i) - \\'0\\') * (num2.charAt(j) - \\'0\\');\\n                // Adding previous values in result array into this product.\\n                product += result[i + j + 1];\\n\\n                // Adding the new product into the result array\\n                result[i + j + 1] = product % 10;\\n                result[i + j] += product / 10;\\n            }\\n        }\\n\\n        // Generating the result String\\n        StringBuilder sb = new StringBuilder();\\n        for (int r : result) {\\n            // Ignoring leading zeros\\n            if (sb.length() == 0 && r == 0) {\\n                continue;\\n            }\\n            sb.append(r);\\n        }\\n\\n        return sb.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1563536,
                "title": "c-simple-solution-w-explanation-and-images-school-optimized-multiplication",
                "content": "We are given two string numbers and need to return the multiplication result of the two strings.\\n\\n---\\n\\n\\u2714\\uFE0F ***Solution - I (Simple School Multiplication)***\\n\\nWe can perform multiplication of two strings in the same way as we would manually in real life - simple elementary school multiplication. \\n\\n* Take one of the number `n1` and multiply each of its digit with the other number `n2` to get an intermediate result. \\n* The intermediate results are padded with `0` at the end. For eg. - \\n\\t* The intermediate result of last digit of `n1` multiplied with `n2` is padded with zero `0`.\\n\\t* the 2nd last digit of `n1` multiplied with `n2` is padded with one `0` at the end and so on...\\n* Finally, all the intermediate results are added together to get the final output.\\n\\nIn the below solution, instead of storing all the intermediate results as we would on paper and then adding them all at last, we instead add intermediate result at each step. This saves us some space and is a bit concise.\\n\\n1            |  2 | 3 |\\n:-------------------------:|:-------------------------:|:-------------------------:\\n<img src = \"https://assets.leetcode.com/users/images/c7b50723-8147-41c9-9d6a-50b70e5c2e3d_1636255246.4883711.png\" width=\"250\"/>  |  <img src = \"https://assets.leetcode.com/users/images/1e7fdaa6-37f8-4575-b064-394c00a1bd09_1636254928.6435995.png\" width=\"350\"/>  | <img src = \"https://assets.leetcode.com/users/images/7e39f68d-aa65-44fe-b6af-7b3b05737f20_1636254945.682742.png\" width=\"350\"/> | \\n\\n\\n\\n\\n\\nThe below code might look long but is really easy to understand and just simple school multiplication and addition written out into code.\\n\\n```cpp\\nclass Solution {\\npublic:\\n    string multiply(string& A, string& B) {\\n        if(A == \"0\" || B == \"0\") return \"0\";                  // if either is 0, final result will be 0\\n\\t\\tif(size(A) < size(B)) return multiply (B, A);\\n        string ans = \"\";\\n        for(int j = size(B)-1, pad = 0; j >= 0; j--) {\\n            auto res = multiplyDigit(A, B[j], pad++);         // multiply each digit of B with A considering proper padding of 0 at end\\n            ans = addStrings(ans, res);                       // keep adding intermediate result to final result\\n        }\\n        return ans;\\n    }\\n\\t\\n\\t// multiply a string number with a char digit\\n    string multiplyDigit(string& s, char c, int pad) {\\n        int i = size(s)-1, carry = 0, digit1 = c-\\'0\\', digit2, res;\\n\\t\\t// the string is formed in reverse manner & then reversed at end\\n\\t\\t// This is because it\\'s O(1) to push at the end instead of at the start\\n        string ans = string(pad, \\'0\\');\\n        while(i >= 0) {\\n            digit2 = s[i--]-\\'0\\';                    // get digit of num1 to be multiplied with digit1\\n            res = digit1 * digit2 + carry;          // multiplication of digits + carry from previous\\n            carry = res / 10;                       // update carry\\n            ans += res%10+\\'0\\';                      // only consider last digit & add it to result\\n        }\\n        if(carry) ans += carry+\\'0\\';                 // if there\\'s leftover carry at end after multiplying all digits\\n        reverse(begin(ans), end(ans));              // reverse back to get correct result\\n        return ans;\\n    }\\n\\t\\n\\t// adds two string numbers - https://leetcode.com/problems/add-strings/\\n    string addStrings(string& A, string& B) {\\n        if(size(A) < size(B)) return addStrings(B, A);   // we assume A is the bigger string\\n        int i = size(A)-1, j = size(B)-1, carry = 0, digit1, digit2, res;\\n        string ans = \"\";\\n        while(i >= 0) {\\n            digit1 = A[i--]-\\'0\\', digit2 = j >= 0 ? (B[j--]-\\'0\\') : 0;  // get digits from both numbers\\n            res = digit1 + digit2 + carry;               // add both digit and carry from previous\\n            carry = res / 10;                            // update carry\\n            ans += res%10+\\'0\\';                           // only consider last digit & add it to result\\n        }\\n        if(carry) ans += carry+\\'0\\';                      // if there\\'s leftover carry at end after multiplying all digits\\n        reverse(begin(ans), end(ans));                   // We formed in reverse order. Reverse it back to get correct result\\n        return ans;\\n    }\\n};\\n```\\n\\n ***Time Complexity :*** <code><b>O(min(M, N)*(M+N))</b></code>, where `M` is the length of string `A` and `N` is the length of string `B`. \\n \\n Each of the digit of `B` is multiplied with `A`. This takes `O(M*N)` in total. Each time we get an intermediate result of length `M`, `M+1`, `M+2` ... `M+N-1`. The total time required in addition of these intermediate result takes `M+ (M+1) + (M+2) + (M+3) + ... + (M+N-1) = M*N + N*(N-1)/2 \\u2248 O(N*(M+N))`.\\n \\n The overall time complexity comes out to be `O(M*N) + O(N*(M+N)) = O(N*(M+N))`.We ensure that `B` is string of minimum length or return `multiply (B, A);` on line-2. Thus, the final time complexity is `O(min(M, N)*(M+N))`\\n \\n***Space Complexity :*** **`O(M+N)`** We are calculating intermediate results at each step. The length of intermeidate result can go upto `M+N-1 \\u2248 O(M+N)`\\n\\n---\\n\\n\\u2714\\uFE0F ***Solution - II (Optimized Multiplication)***\\n\\nIn the above solution, we were forming intermediate result at each step, padding them with `0`s appropriately and adding it to final answer. This led us to performing additions of all intermediate results at each step having cost of `O(N*(M+N))`.\\n\\nOne thing we can observe is that when we multiply `i`th digit of `A` with `j` digit of `B`, it will always affect `i+j+1`th digit of the answer. You can verify this my performing manual multiplication. Therefore, we instead will initialize out final answer to `size(A) + size(B)`, which is the maximum possible length of our result. Then for each digit of `A`, we multiply it with each digit of `B`. Using the above observation, we don\\'t need to keep adding padded `0`s and add intermediate results of full `M, M+1, ... M+N-1` lengths at each step as done previously. Instead, we can just update the index of `ans` that is affected by multiplication of `i`th and `j`th digit of `A` and `B`.\\n\\nFollowing is the algorithm that we will follow -\\n\\n* Initialize answer of length `M + N`.\\n* Start multiplying each digit of `A` with each digit of `B` starting from the end of both numbers as we would in normal multiplication. \\n* The multiplication of `i`th digit of `A` and `j`th digit of `B` gives a result which affects `i+j+1` index. \\n* Thus, we will multiply both the digits and add the result to `i+j+1`th index in `ans`. If the resultant is greater than `9`, we will only take the ones place and carry over the rest to previous (`i+j`th)  index.\\n* Finally, we can have cases where `ans` may have leading `0` since we initialized it to `M+N` (eg. A=\"3\", B=\"2\"). In such cases, we will just skip the first 0 and return the rest.\\n\\n\\n1            |  2 | 3 |\\n:-------------------------:|:-------------------------:|:-------------------------:\\n<img src = \"https://assets.leetcode.com/users/images/f7304b0e-7a18-4a5e-bea2-1a935ed1c91f_1636255482.9239755.png\" width=\"350\"/>  |  <img src = \"https://assets.leetcode.com/users/images/8d465c8a-1225-42cb-9e17-e31a01b2c5c3_1636255537.993818.png\" width=\"350\"/>  | <img src = \"https://assets.leetcode.com/users/images/ae90fdf0-024c-41dd-b87c-c05b8a25fdc2_1636255543.1006606.png\" width=\"350\"/> | \\n\\n4            |  5 | 6 |\\n:-------------------------:|:-------------------------:|:-------------------------:\\n<img src = \"https://assets.leetcode.com/users/images/3a34d384-075b-40a1-9224-35d8291fc7f0_1636255802.3226962.png\" width=\"350\"/>  |  <img src = \"https://assets.leetcode.com/users/images/cf777e33-f0c0-4ed4-ac14-ecca0b759cb6_1636255802.3267057.png\" width=\"350\"/>  | <img src = \"https://assets.leetcode.com/users/images/3ef4e1d5-163f-4635-be9b-c507b0c5f8dc_1636255802.4146335.png\" width=\"350\"/> | \\n\\n7            |  8 | 9 |\\n:-------------------------:|:-------------------------:|:-------------------------:\\n<img src = \"https://assets.leetcode.com/users/images/0161dedf-fd7c-4387-ab4a-d89c4fa8a1e3_1636264361.7982104.png\" width=\"350\"/>  |  <img src = \"https://assets.leetcode.com/users/images/8ad107f4-8ce3-4c3d-ad32-38a79ffd7151_1636264361.6444206.png\" width=\"350\"/>  | <img src = \"https://assets.leetcode.com/users/images/c9964fea-8026-4e9a-9ef1-fff3a201bb4a_1636264361.7874398.png\" width=\"350\"/> | \\n\\n\\n\\n```cpp\\nclass Solution {\\npublic:\\n    string multiply(string& A, string& B) {\\n        if(A == \"0\" || B == \"0\") return \"0\";\\n        string ans(size(A)+size(B), \\'0\\');\\n        for(int i = size(A)-1; i >= 0; i--) {\\n            for(int j = size(B)-1; j >= 0; j--) {\\n                int res = (ans[i+j+1]-\\'0\\') + (A[i]-\\'0\\') * (B[j]-\\'0\\');\\n                ans[i+j+1] = res%10 + \\'0\\';  // ones place of multiplication result\\n                ans[i+j] += res/10;         // carry over to previous index if result >= 10\\n            }\\n        }\\n        if(ans[0] == \\'0\\') return ans.substr(1);\\n        return ans;\\n    }\\n};\\n```\\n\\n ***Time Complexity :*** <code><b>O(M*N)</b></code>, We can observe that we are only performing `M*N` operations multiplying each digit of `A` with each digit of `B`. Thus, it takes `O(M*N)` time in total.\\n***Space Complexity :*** **`O(1)`** Ignoring the output result. If we consider the output space as well, we have space complexity of `O(M+N)`.\\n\\n---\\n---\\n\\n\\uD83D\\uDCBBIf there are any suggestions / questions / mistakes in my post, comment below \\uD83D\\uDC47 \\n\\n---",
                "solutionTags": [],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    string multiply(string& A, string& B) {\\n        if(A == \"0\" || B == \"0\") return \"0\";                  // if either is 0, final result will be 0\\n\\t\\tif(size(A) < size(B)) return multiply (B, A);\\n        string ans = \"\";\\n        for(int j = size(B)-1, pad = 0; j >= 0; j--) {\\n            auto res = multiplyDigit(A, B[j], pad++);         // multiply each digit of B with A considering proper padding of 0 at end\\n            ans = addStrings(ans, res);                       // keep adding intermediate result to final result\\n        }\\n        return ans;\\n    }\\n\\t\\n\\t// multiply a string number with a char digit\\n    string multiplyDigit(string& s, char c, int pad) {\\n        int i = size(s)-1, carry = 0, digit1 = c-\\'0\\', digit2, res;\\n\\t\\t// the string is formed in reverse manner & then reversed at end\\n\\t\\t// This is because it\\'s O(1) to push at the end instead of at the start\\n        string ans = string(pad, \\'0\\');\\n        while(i >= 0) {\\n            digit2 = s[i--]-\\'0\\';                    // get digit of num1 to be multiplied with digit1\\n            res = digit1 * digit2 + carry;          // multiplication of digits + carry from previous\\n            carry = res / 10;                       // update carry\\n            ans += res%10+\\'0\\';                      // only consider last digit & add it to result\\n        }\\n        if(carry) ans += carry+\\'0\\';                 // if there\\'s leftover carry at end after multiplying all digits\\n        reverse(begin(ans), end(ans));              // reverse back to get correct result\\n        return ans;\\n    }\\n\\t\\n\\t// adds two string numbers - https://leetcode.com/problems/add-strings/\\n    string addStrings(string& A, string& B) {\\n        if(size(A) < size(B)) return addStrings(B, A);   // we assume A is the bigger string\\n        int i = size(A)-1, j = size(B)-1, carry = 0, digit1, digit2, res;\\n        string ans = \"\";\\n        while(i >= 0) {\\n            digit1 = A[i--]-\\'0\\', digit2 = j >= 0 ? (B[j--]-\\'0\\') : 0;  // get digits from both numbers\\n            res = digit1 + digit2 + carry;               // add both digit and carry from previous\\n            carry = res / 10;                            // update carry\\n            ans += res%10+\\'0\\';                           // only consider last digit & add it to result\\n        }\\n        if(carry) ans += carry+\\'0\\';                      // if there\\'s leftover carry at end after multiplying all digits\\n        reverse(begin(ans), end(ans));                   // We formed in reverse order. Reverse it back to get correct result\\n        return ans;\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    string multiply(string& A, string& B) {\\n        if(A == \"0\" || B == \"0\") return \"0\";\\n        string ans(size(A)+size(B), \\'0\\');\\n        for(int i = size(A)-1; i >= 0; i--) {\\n            for(int j = size(B)-1; j >= 0; j--) {\\n                int res = (ans[i+j+1]-\\'0\\') + (A[i]-\\'0\\') * (B[j]-\\'0\\');\\n                ans[i+j+1] = res%10 + \\'0\\';  // ones place of multiplication result\\n                ans[i+j] += res/10;         // carry over to previous index if result >= 10\\n            }\\n        }\\n        if(ans[0] == \\'0\\') return ans.substr(1);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 17746,
                "title": "python-easy-to-understand-solution",
                "content": "```\\nclass Solution(object):\\n    def multiply(self, num1, num2):\\n        res = [0] * (len(num1)+len(num2))\\n        for i in range(len(num1)-1, -1, -1):\\n            carry = 0\\n            for j in range(len(num2)-1, -1, -1):\\n                tmp = (ord(num1[i])-ord(\\'0\\'))*(ord(num2[j])-ord(\\'0\\')) + carry\\n                carry = (res[i+j+1]+tmp) // 10\\n                res[i+j+1] = (res[i+j+1]+tmp) % 10\\n            res[i] += carry\\n        res = \\'\\'.join(map(str, res))\\n        return \\'0\\' if not res.lstrip(\\'0\\') else res.lstrip(\\'0\\')\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def multiply(self, num1, num2):\\n        res = [0] * (len(num1)+len(num2))\\n        for i in range(len(num1)-1, -1, -1):\\n            carry = 0\\n            for j in range(len(num2)-1, -1, -1):\\n                tmp = (ord(num1[i])-ord(\\'0\\'))*(ord(num2[j])-ord(\\'0\\')) + carry\\n                carry = (res[i+j+1]+tmp) // 10\\n                res[i+j+1] = (res[i+j+1]+tmp) % 10\\n            res[i] += carry\\n        res = \\'\\'.join(map(str, res))\\n        return \\'0\\' if not res.lstrip(\\'0\\') else res.lstrip(\\'0\\')\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1122479,
                "title": "java-explained",
                "content": "**Facts You should know:**\\n* Product of two number of length n and m will be atmax of length n+m.\\n  Eg : 9*9 =81 . Its a fact kind of thing needed for this question.\\n  \\n* Product of digit at idx1 and idx2 will have effect only on idx1 + idx2 + 1(digit idx) and idx1 + idx2(remainder). \\n\\n**Boundary Cases:** \\n* If any of num is zero then Product is zero.\\n* if one number is negative or second is Positive [here they have mentioned string consist digit only]\\n  So no need to handle this boundary Case. But in Interview Clarify this from your Interviewer.Else you may get Rejection even after Solving Correctly.\\n\\n**CODE:**\\n```\\n    public String multiply(String num1, String num2) {\\n        //1. Taking care of Boundary Case\\n        if(num1.equals(\"0\") || num2.equals(\"0\")) return \"0\"; \\n\\t\\t\\n\\t\\t//2.at max length of product will be n+m\\n        int[] ans=new int[num1.length() + num2.length()];\\n        \\n        for(int i=num1.length()-1;i>=0;i--){\\n            for(int j=num2.length()-1;j>=0;j--){\\n                \\n             int  valueIdx=i + j +1;\\n             int  remainderIdx=i+ j ;\\n             int product=(num1.charAt(i)-\\'0\\')*(num2.charAt(j)-\\'0\\');\\n                \\n\\t\\t\\t //3.Adding value of remainder if present earlier at valueidx\\t\\n             product+=ans[valueIdx];\\n             \\n\\t\\t\\t //4.digit value\\n             ans[valueIdx]=product%10;\\n\\t\\t\\t \\n\\t\\t\\t //5.Remainder from me \\n             ans[remainderIdx]+=product/10;  \\n                \\n            }\\n       }\\n        \\n        boolean precedingZeros=true;\\n        StringBuilder result=new StringBuilder(\"\");\\n      \\n\\t   //6.As we have made a array of maximum length n*m=n+m So result will be less than or equal to this. in less than case inital values will be zeros . So have to Remove Preceding Zeroes.\\n        for(int i=0;i<ans.length;i++){\\n         int value=ans[i];\\n         if(value!=0) precedingZeros=false;\\n         if(!precedingZeros) result.append(value);\\n     }\\n        \\n        return result.toString();\\n    }\\n```\\n\\n**Complexity :** \\n`Time : O(n*m) and Space: O(n+m)`\\nwhere n:length of num1 and m:length of num2\\n\\nPlease **UPVOTE** if found it helpful:)",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n    public String multiply(String num1, String num2) {\\n        //1. Taking care of Boundary Case\\n        if(num1.equals(\"0\") || num2.equals(\"0\")) return \"0\"; \\n\\t\\t\\n\\t\\t//2.at max length of product will be n+m\\n        int[] ans=new int[num1.length() + num2.length()];\\n        \\n        for(int i=num1.length()-1;i>=0;i--){\\n            for(int j=num2.length()-1;j>=0;j--){\\n                \\n             int  valueIdx=i + j +1;\\n             int  remainderIdx=i+ j ;\\n             int product=(num1.charAt(i)-\\'0\\')*(num2.charAt(j)-\\'0\\');\\n                \\n\\t\\t\\t //3.Adding value of remainder if present earlier at valueidx\\t\\n             product+=ans[valueIdx];\\n             \\n\\t\\t\\t //4.digit value\\n             ans[valueIdx]=product%10;\\n\\t\\t\\t \\n\\t\\t\\t //5.Remainder from me \\n             ans[remainderIdx]+=product/10;  \\n                \\n            }\\n       }\\n        \\n        boolean precedingZeros=true;\\n        StringBuilder result=new StringBuilder(\"\");\\n      \\n\\t   //6.As we have made a array of maximum length n*m=n+m So result will be less than or equal to this. in less than case inital values will be zeros . So have to Remove Preceding Zeroes.\\n        for(int i=0;i<ans.length;i++){\\n         int value=ans[i];\\n         if(value!=0) precedingZeros=false;\\n         if(!precedingZeros) result.append(value);\\n     }\\n        \\n        return result.toString();\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 17769,
                "title": "one-easy-solution-with-c",
                "content": "The key part is to use a vector to store all digits REVERSELY. after the calculation, find the rightmost NON-Zero digits and convert it to a string.\\n\\n\\n    class Solution {\\n    public:\\n        string multiply(string num1, string num2) {\\n            \\n            unsigned int l1=num1.size(),l2=num2.size();\\n            if (l1==0||l2==0) return \"0\";\\n            \\n            vector<int> v(l1+l2,0);\\n     \\n            for (unsigned int i=0;i<l1;i++){\\n                int carry=0;\\n                int n1=(int)(num1[l1-i-1]-'0');//Calculate from rightmost to left\\n                for (unsigned int j=0;j<l2;j++){\\n                    int n2=(num2[l2-j-1]-'0');//Calculate from rightmost to left\\n                    \\n                    int sum=n1*n2+v[i+j]+carry;\\n                    carry=sum/10;\\n                    v[i+j]=sum%10;\\n                }\\n                if (carry>0)\\n                    v[i+l2]+=carry;\\n \\n            }\\n            int start=l1+l2-1;\\n            while(v[start]==0) start--;\\n            if (start==-1) return \"0\";\\n            \\n            string s=\"\";\\n            for (int i=start;i>=0;i--)\\n                s+=(char)(v[i]+'0');\\n            return s;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        string multiply(string num1, string num2) {\\n            \\n            unsigned int l1=num1.size(),l2=num2.size();\\n            if (l1==0||l2==0) return \"0\";\\n            \\n            vector<int> v(l1+l2,0);\\n     \\n            for (unsigned int i=0;i<l1;i++){\\n                int carry=0;\\n                int n1=(int)(num1[l1-i-1]-'0');//Calculate from rightmost to left\\n                for (unsigned int j=0;j<l2;j++){\\n                    int n2=(num2[l2-j-1]-'0');//Calculate from rightmost to left\\n                    \\n                    int sum=n1*n2+v[i+j]+carry;\\n                    carry=sum/10;\\n                    v[i+j]=sum%10;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 1165584,
                "title": "easy-python-solution-without-using-dictionary",
                "content": "```\\nclass Solution:\\n    def multiply(self, num1: str, num2: str) -> str:\\n        if num1 == \\'0\\' or num2 == \\'0\\':\\n            return \\'0\\'\\n        \\n        def decode(num):\\n            ans = 0\\n            for i in num:\\n                ans = ans*10 +(ord(i) - ord(\\'0\\'))\\n            return ans\\n\\n        def encode(s):\\n            news = \\'\\'\\n            while s:\\n                a = s % 10\\n                s = s // 10\\n                news = chr(ord(\\'0\\') + a) + news\\n            return news\\n        \\n        return encode(decode(num1)*decode(num2))\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def multiply(self, num1: str, num2: str) -> str:\\n        if num1 == \\'0\\' or num2 == \\'0\\':\\n            return \\'0\\'\\n        \\n        def decode(num):\\n            ans = 0\\n            for i in num:\\n                ans = ans*10 +(ord(i) - ord(\\'0\\'))\\n            return ans\\n\\n        def encode(s):\\n            news = \\'\\'\\n            while s:\\n                a = s % 10\\n                s = s // 10\\n                news = chr(ord(\\'0\\') + a) + news\\n            return news\\n        \\n        return encode(decode(num1)*decode(num2))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 671503,
                "title": "the-most-voted-java-solution-rewritten-in-javascript-with-graph-explanation",
                "content": "Start from right to left, perform multiplication on every pair of digits, and add them together. Let\\'s draw the process! From the following draft, we can immediately conclude:\\n\\n `num1[i] * num2[j]` will be placed at indices `[i + j`, `i + j + 1]` \\n \\n ![image](https://assets.leetcode.com/users/murzabulatov/image_1591345827.png)\\n\\n \\n\\nHere is JavaScript solution:\\n```\\nvar multiply = function(num1, num2) {\\n    if (num1 === \\'0\\' || num2 === \\'0\\') return \\'0\\'\\n    \\n    const m = num1.length, n = num2.length, res = new Array(m+n).fill(0)\\n    \\n    for (let i=m-1; i>=0; i--) {\\n        for (let j=n-1; j>=0; j--) {\\n            const p1=i+j, p2=i+j+1\\n            let sum = res[p2] + Number(num1[i]) * Number(num2[j])\\n            res[p2] = sum%10\\n            res[p1] += Math.floor(sum/10)\\n        }\\n    }\\n    if (res[0] === 0) res.shift()\\n    return res.join(\\'\\')\\n    \\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar multiply = function(num1, num2) {\\n    if (num1 === \\'0\\' || num2 === \\'0\\') return \\'0\\'\\n    \\n    const m = num1.length, n = num2.length, res = new Array(m+n).fill(0)\\n    \\n    for (let i=m-1; i>=0; i--) {\\n        for (let j=n-1; j>=0; j--) {\\n            const p1=i+j, p2=i+j+1\\n            let sum = res[p2] + Number(num1[i]) * Number(num2[j])\\n            res[p2] = sum%10\\n            res[p1] += Math.floor(sum/10)\\n        }\\n    }\\n    if (res[0] === 0) res.shift()\\n    return res.join(\\'\\')\\n    \\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 17771,
                "title": "very-concise-16-ms-c-solution",
                "content": "See comments inline for explanation.\\n\\n    class Solution {\\n    public:\\n        string multiply(string num1, string num2) {\\n            int i, j;\\n            int m = num1.size(), n = num2.size();\\n            // max (m + n) digits\\n            vector<int> product(m + n, 0);\\n            string result;\\n    \\n            // reverse for ease of calc\\n            reverse(num1.begin(), num1.end());\\n            reverse(num2.begin(), num2.end());\\n    \\n            // digit i * digit j contributes to digit i + j\\n            for (i = 0; i < m; i++) {\\n                for (j = 0; j < n; j++) {\\n                    product[i + j] += (num1[i] - '0') * (num2[j] - '0');\\n                    product[i + j + 1] += product[i + j] / 10;\\n                    product[i + j] %= 10;\\n                }\\n            }\\n    \\n            // remove leading 0; keep last 0 if all 0\\n            for (i = m + n - 1; i > 0 && 0 == product[i]; i--)\\n                ;\\n            \\n            for (; i >= 0; i--)\\n                result += to_string(product[i]);\\n    \\n            return result;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        string multiply(string num1, string num2) {\\n            int i, j;\\n            int m = num1.size(), n = num2.size();\\n            // max (m + n) digits\\n            vector<int> product(m + n, 0);\\n            string result;\\n    \\n            // reverse for ease of calc\\n            reverse(num1.begin(), num1.end());\\n            reverse(num2.begin(), num2.end());\\n    \\n            // digit i * digit j contributes to digit i + j\\n            for (i = 0; i < m; i++) {\\n                for (j = 0; j < n; j++) {\\n                    product[i + j] += (num1[i] - '0') * (num2[j] - '0');\\n                    product[i + j + 1] += product[i + j] / 10;\\n                    product[i + j] %= 10;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 17759,
                "title": "clear-java-solution-without-reversal",
                "content": " \\n\\n    public String multiply(String num1, String num2) {\\n        int len1 = num1.length();\\n        int len2 = num2.length();\\n        int[] product = new int[len1 + len2];\\n        for (int i = len1 - 1; i >= 0; i--) {\\n            for (int j = len2 - 1; j >= 0; j--) {\\n                int index = len1 + len2 - i - j - 2;\\n                product[index] += (num1.charAt(i) - '0') * (num2.charAt(j) - '0');\\n                product[index + 1] += product[index] / 10;\\n                product[index] %= 10;\\n            }\\n        }\\n        StringBuilder stringBuilder = new StringBuilder();\\n        for (int i = product.length - 1; i > 0; i--) {\\n            if (stringBuilder.length() == 0 && product[i] == 0)\\n                continue;\\n            stringBuilder.append(product[i]);\\n        }\\n        stringBuilder.append(product[0]);\\n        return stringBuilder.toString();\\n    }",
                "solutionTags": [],
                "code": " \\n\\n    public String multiply(String num1, String num2) {\\n        int len1 = num1.length();\\n        int len2 = num2.length();\\n        int[] product = new int[len1 + len2];\\n        for (int i = len1 - 1; i >= 0; i--) {\\n            for (int j = len2 - 1; j >= 0; j--) {\\n                int index = len1 + len2 - i - j - 2;\\n                product[index] += (num1.charAt(i) - '0') * (num2.charAt(j) - '0');\\n                product[index + 1] += product[index] / 10;\\n                product[index] %= 10;\\n            }\\n        }\\n        StringBuilder stringBuilder = new StringBuilder();\\n        for (int i = product.length - 1; i > 0; i--) {\\n            if (stringBuilder.length() == 0 && product[i] == 0)\\n                continue;\\n            stringBuilder.append(product[i]);\\n        }\\n        stringBuilder.append(product[0]);\\n        return stringBuilder.toString();\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1241693,
                "title": "multiplication-in-typescript",
                "content": "While doing this solution I realized a very important thing that was, While performing multiplication operation in Typescript for relatively large numbers, the end result is not perfect multiplication. also\\nwhen you try to reverse engineer by dividing the result the result are the same. with my solution you can As a result, you can multiply two 64-digit numbers. The predefined operator gives the correct result, but it loses a lot of precision because the largest integer JavaScript can display is 2\\u2075\\xB3-1 [MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/MAX_SAFE_INTEGER)\\n\\n```\\nconst number1 = 3141592653589793238462643383279502884197169399375105820974944592;\\nconst number2 = 2718281828459045235360287471352662497757247093699959574966967627;\\n```\\n[wiki/Multiplication_algorithm](http://en.wikipedia.org/wiki/Multiplication_algorithm)",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\nconst number1 = 3141592653589793238462643383279502884197169399375105820974944592;\\nconst number2 = 2718281828459045235360287471352662497757247093699959574966967627;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1563690,
                "title": "c-simple-solution-w-explanation-and-images-school-optimized-multiplication",
                "content": "**NOTE:** My **[1st post](https://leetcode.com/problems/multiply-strings/discuss/1563536/C%2B%2B-Simple-Solution-w-Explanation-and-Images-or-School-%2B-Optimized-Multiplication)** was deleted after adding images to it. This re-post with same content seems to work for now but @LeetCode needs to resolve this bug ASAP.\\n\\n---\\n\\nWe are given two string numbers and need to return the multiplication result of the two strings.\\n\\n---\\n\\n\\u2714\\uFE0F ***Solution - I (Simple School Multiplication)***\\n\\nWe can perform multiplication of two strings in the same way as we would manually in real life - simple elementary school multiplication. \\n\\n* Take one of the number `n1` and multiply each of its digit with the other number `n2` to get an intermediate result. \\n* The intermediate results are padded with `0` at the end. For eg. - \\n\\t* The intermediate result of last digit of `n1` multiplied with `n2` is padded with zero `0`.\\n\\t* the 2nd last digit of `n1` multiplied with `n2` is padded with one `0` at the end and so on...\\n* Finally, all the intermediate results are added together to get the final output.\\n\\nIn the below solution, instead of storing all the intermediate results as we would on paper and then adding them all at last, we instead add intermediate result at each step. This saves us some space and is a bit concise.\\n\\n1            |  2 | 3 |\\n:-------------------------:|:-------------------------:|:-------------------------:\\n<img src = \"https://assets.leetcode.com/users/images/c7b50723-8147-41c9-9d6a-50b70e5c2e3d_1636255246.4883711.png\" width=\"250\"/>  |  <img src = \"https://assets.leetcode.com/users/images/1e7fdaa6-37f8-4575-b064-394c00a1bd09_1636254928.6435995.png\" width=\"350\"/>  | <img src = \"https://assets.leetcode.com/users/images/7e39f68d-aa65-44fe-b6af-7b3b05737f20_1636254945.682742.png\" width=\"350\"/> | \\n\\n\\n\\n\\n\\nThe below code might look long but is really easy to understand and just simple school multiplication and addition written out into code.\\n\\n```cpp\\nclass Solution {\\npublic:\\n    string multiply(string& A, string& B) {\\n        if(A == \"0\" || B == \"0\") return \"0\";                  // if either is 0, final result will be 0\\n\\t\\tif(size(A) < size(B)) return multiply (B, A);\\n        string ans = \"\";\\n        for(int j = size(B)-1, pad = 0; j >= 0; j--) {\\n            auto res = multiplyDigit(A, B[j], pad++);         // multiply each digit of B with A considering proper padding of 0 at end\\n            ans = addStrings(ans, res);                       // keep adding intermediate result to final result\\n        }\\n        return ans;\\n    }\\n\\t\\n\\t// multiply a string number with a char digit\\n    string multiplyDigit(string& s, char c, int pad) {\\n        int i = size(s)-1, carry = 0, digit1 = c-\\'0\\', digit2, res;\\n\\t\\t// the string is formed in reverse manner & then reversed at end\\n\\t\\t// This is because it\\'s O(1) to push at the end instead of at the start\\n        string ans = string(pad, \\'0\\');\\n        while(i >= 0) {\\n            digit2 = s[i--]-\\'0\\';                    // get digit of num1 to be multiplied with digit1\\n            res = digit1 * digit2 + carry;          // multiplication of digits + carry from previous\\n            carry = res / 10;                       // update carry\\n            ans += res%10+\\'0\\';                      // only consider last digit & add it to result\\n        }\\n        if(carry) ans += carry+\\'0\\';                 // if there\\'s leftover carry at end after multiplying all digits\\n        reverse(begin(ans), end(ans));              // reverse back to get correct result\\n        return ans;\\n    }\\n\\t\\n\\t// adds two string numbers - https://leetcode.com/problems/add-strings/\\n    string addStrings(string& A, string& B) {\\n        if(size(A) < size(B)) return addStrings(B, A);   // we assume A is the bigger string\\n        int i = size(A)-1, j = size(B)-1, carry = 0, digit1, digit2, res;\\n        string ans = \"\";\\n        while(i >= 0) {\\n            digit1 = A[i--]-\\'0\\', digit2 = j >= 0 ? (B[j--]-\\'0\\') : 0;  // get digits from both numbers\\n            res = digit1 + digit2 + carry;               // add both digit and carry from previous\\n            carry = res / 10;                            // update carry\\n            ans += res%10+\\'0\\';                           // only consider last digit & add it to result\\n        }\\n        if(carry) ans += carry+\\'0\\';                      // if there\\'s leftover carry at end after multiplying all digits\\n        reverse(begin(ans), end(ans));                   // We formed in reverse order. Reverse it back to get correct result\\n        return ans;\\n    }\\n};\\n```\\n\\n ***Time Complexity :*** <code><b>O(min(M, N)*(M+N))</b></code>, where `M` is the length of string `A` and `N` is the length of string `B`. \\n \\n Each of the digit of `B` is multiplied with `A`. This takes `O(M*N)` in total. Each time we get an intermediate result of length `M`, `M+1`, `M+2` ... `M+N-1`. The total time required in addition of these intermediate result takes `M+ (M+1) + (M+2) + (M+3) + ... + (M+N-1) = M*N + N*(N-1)/2 \\u2248 O(N*(M+N))`.\\n \\n The overall time complexity comes out to be `O(M*N) + O(N*(M+N)) = O(N*(M+N))`.We ensure that `B` is string of minimum length or return `multiply (B, A);` on line-2. Thus, the final time complexity is `O(min(M, N)*(M+N))`\\n \\n***Space Complexity :*** **`O(M+N)`** We are calculating intermediate results at each step. The length of intermeidate result can go upto `M+N-1 \\u2248 O(M+N)`\\n\\n---\\n\\n\\u2714\\uFE0F ***Solution - II (Optimized Multiplication)***\\n\\nIn the above solution, we were forming intermediate result at each step, padding them with `0`s appropriately and adding it to final answer. This led us to performing additions of all intermediate results at each step having cost of `O(N*(M+N))`.\\n\\nOne thing we can observe is that when we multiply `i`th digit of `A` with `j` digit of `B`, it will always affect `i+j+1`th digit of the answer. You can verify this my performing manual multiplication. Therefore, we instead will initialize out final answer to `size(A) + size(B)`, which is the maximum possible length of our result. Then for each digit of `A`, we multiply it with each digit of `B`. Using the above observation, we don\\'t need to keep adding padded `0`s and add intermediate results of full `M, M+1, ... M+N-1` lengths at each step as done previously. Instead, we can just update the index of `ans` that is affected by multiplication of `i`th and `j`th digit of `A` and `B`.\\n\\nFollowing is the algorithm that we will follow -\\n\\n* Initialize answer of length `M + N`.\\n* Start multiplying each digit of `A` with each digit of `B` starting from the end of both numbers as we would in normal multiplication. \\n* The multiplication of `i`th digit of `A` and `j`th digit of `B` gives a result which affects `i+j+1` index. \\n* Thus, we will multiply both the digits and add the result to `i+j+1`th index in `ans`. If the resultant is greater than `9`, we will only take the ones place and carry over the rest to previous (`i+j`th)  index.\\n* Finally, we can have cases where `ans` may have leading `0` since we initialized it to `M+N` (eg. A=\"3\", B=\"2\"). In such cases, we will just skip the first 0 and return the rest.\\n\\n\\n1            |  2 | 3 |\\n:-------------------------:|:-------------------------:|:-------------------------:\\n<img src = \"https://assets.leetcode.com/users/images/f7304b0e-7a18-4a5e-bea2-1a935ed1c91f_1636255482.9239755.png\" width=\"350\"/>  |  <img src = \"https://assets.leetcode.com/users/images/8d465c8a-1225-42cb-9e17-e31a01b2c5c3_1636255537.993818.png\" width=\"350\"/>  | <img src = \"https://assets.leetcode.com/users/images/ae90fdf0-024c-41dd-b87c-c05b8a25fdc2_1636255543.1006606.png\" width=\"350\"/> | \\n\\n4            |  5 | 6 |\\n:-------------------------:|:-------------------------:|:-------------------------:\\n<img src = \"https://assets.leetcode.com/users/images/3a34d384-075b-40a1-9224-35d8291fc7f0_1636255802.3226962.png\" width=\"350\"/>  |  <img src = \"https://assets.leetcode.com/users/images/cf777e33-f0c0-4ed4-ac14-ecca0b759cb6_1636255802.3267057.png\" width=\"350\"/>  | <img src = \"https://assets.leetcode.com/users/images/3ef4e1d5-163f-4635-be9b-c507b0c5f8dc_1636255802.4146335.png\" width=\"350\"/> | \\n\\n<img src = \"https://assets.leetcode.com/users/images/5491e7e3-abe3-44d9-b4da-e47e5513a7ff_1636257155.9040334.png\" width=\"1130\" />\\n\\n\\n\\n\\n\\n\\n```cpp\\nclass Solution {\\npublic:\\n    string multiply(string& A, string& B) {\\n        if(A == \"0\" || B == \"0\") return \"0\";\\n        string ans(size(A)+size(B), \\'0\\');\\n        for(int i = size(A)-1; i >= 0; i--) {\\n            for(int j = size(B)-1; j >= 0; j--) {\\n                int res = (ans[i+j+1]-\\'0\\') + (A[i]-\\'0\\') * (B[j]-\\'0\\');\\n                ans[i+j+1] = res%10 + \\'0\\';  // ones place of multiplication result\\n                ans[i+j] += res/10;         // carry over to previous index if result >= 10\\n            }\\n        }\\n        if(ans[0] == \\'0\\') return ans.substr(1);\\n        return ans;\\n    }\\n};\\n```\\n\\n ***Time Complexity :*** <code><b>O(M*N)</b></code>, We can observe that we are only performing `M*N` operations multiplying each digit of `A` with each digit of `B`. Thus, it takes `O(M*N)` time in total.\\n***Space Complexity :*** **`O(1)`** Ignoring the output result. If we consider the output space as well, we have space complexity of `O(M+N)`.\\n\\n---\\n---\\n\\n\\uD83D\\uDCBBIf there are any suggestions / questions / mistakes in my post, comment below \\uD83D\\uDC47 \\n\\n---",
                "solutionTags": [],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    string multiply(string& A, string& B) {\\n        if(A == \"0\" || B == \"0\") return \"0\";                  // if either is 0, final result will be 0\\n\\t\\tif(size(A) < size(B)) return multiply (B, A);\\n        string ans = \"\";\\n        for(int j = size(B)-1, pad = 0; j >= 0; j--) {\\n            auto res = multiplyDigit(A, B[j], pad++);         // multiply each digit of B with A considering proper padding of 0 at end\\n            ans = addStrings(ans, res);                       // keep adding intermediate result to final result\\n        }\\n        return ans;\\n    }\\n\\t\\n\\t// multiply a string number with a char digit\\n    string multiplyDigit(string& s, char c, int pad) {\\n        int i = size(s)-1, carry = 0, digit1 = c-\\'0\\', digit2, res;\\n\\t\\t// the string is formed in reverse manner & then reversed at end\\n\\t\\t// This is because it\\'s O(1) to push at the end instead of at the start\\n        string ans = string(pad, \\'0\\');\\n        while(i >= 0) {\\n            digit2 = s[i--]-\\'0\\';                    // get digit of num1 to be multiplied with digit1\\n            res = digit1 * digit2 + carry;          // multiplication of digits + carry from previous\\n            carry = res / 10;                       // update carry\\n            ans += res%10+\\'0\\';                      // only consider last digit & add it to result\\n        }\\n        if(carry) ans += carry+\\'0\\';                 // if there\\'s leftover carry at end after multiplying all digits\\n        reverse(begin(ans), end(ans));              // reverse back to get correct result\\n        return ans;\\n    }\\n\\t\\n\\t// adds two string numbers - https://leetcode.com/problems/add-strings/\\n    string addStrings(string& A, string& B) {\\n        if(size(A) < size(B)) return addStrings(B, A);   // we assume A is the bigger string\\n        int i = size(A)-1, j = size(B)-1, carry = 0, digit1, digit2, res;\\n        string ans = \"\";\\n        while(i >= 0) {\\n            digit1 = A[i--]-\\'0\\', digit2 = j >= 0 ? (B[j--]-\\'0\\') : 0;  // get digits from both numbers\\n            res = digit1 + digit2 + carry;               // add both digit and carry from previous\\n            carry = res / 10;                            // update carry\\n            ans += res%10+\\'0\\';                           // only consider last digit & add it to result\\n        }\\n        if(carry) ans += carry+\\'0\\';                      // if there\\'s leftover carry at end after multiplying all digits\\n        reverse(begin(ans), end(ans));                   // We formed in reverse order. Reverse it back to get correct result\\n        return ans;\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    string multiply(string& A, string& B) {\\n        if(A == \"0\" || B == \"0\") return \"0\";\\n        string ans(size(A)+size(B), \\'0\\');\\n        for(int i = size(A)-1; i >= 0; i--) {\\n            for(int j = size(B)-1; j >= 0; j--) {\\n                int res = (ans[i+j+1]-\\'0\\') + (A[i]-\\'0\\') * (B[j]-\\'0\\');\\n                ans[i+j+1] = res%10 + \\'0\\';  // ones place of multiplication result\\n                ans[i+j] += res/10;         // carry over to previous index if result >= 10\\n            }\\n        }\\n        if(ans[0] == \\'0\\') return ans.substr(1);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 562036,
                "title": "swift-explanation-detailed-step-by-step",
                "content": "Walking through an example is the best way to understand the methodology and showcases to an interviewer how you came to your solution. Lets take an example such as 12 X 91. Any example is fine as long as it involves using carry. Lets just multiple these two numbers.\\n\\n**Example**\\n```\\n            12 \\n         x  91\\n        -------\\n           182\\n        +  910\\n        -------\\n          1092\\n```\\nWhat observations can we see from the above example? \\n* We padded a 0 after 91 before we added 182\\n* The result has a length of 4 - inputs both had a length of 2 so 2 + 2 = 4 for maximum result length\\n* We can store all of our calculations in a single array since we add the current result with the previous carry\\n* The final result can be stored in a simple array\\n\\n \\nKeeping this in mind, lets do a deeper walkthrough of the above example where we consider the indices we use, result, carry, and how it can play into a single array\\n\\n**Walkthrough**\\n\\n```\\noperation | mult | carry |  i  |  j |  sum      \\n2 x 1         2      0      1     1   [0,0,0,2]\\n2 x 9        18      0      1     0   [0,1,8,2]\\n1 x 1         1      8      0     1   [0,1,9,2]  added result to existing 8 carry\\n1 x 9         9      1      0     0   [0,10,9,2] added result to existing 1 carry\\nremove leading 0s in the sum array\\n```\\n* We store our carry in i+j\\n* We store the result + previousCarry into i+j+1\\n\\n**Pseudocode**\\n```\\nsum = [0,0,0,0] where size of sum is num1.count + num2.count\\nloop backwards nums1 (i)\\n    loop backwards nums2 (j)\\n        let p1 = i + j\\n        let p2 = i + j + 1\\n        let val = n1 * n2 + sum[p2]\\n        sum[p2] = val % 10\\n        sum[p1] += val / 10\\nremove leading 0s\\nconvert sum array to int\\n```\\n\\n**Code**\\n```\\nfunc multiply(_ num1: String, _ num2: String) -> String {\\n\\tvar sum = [Int](repeating: 0, count: num1.count + num2.count)\\n\\tfor (i, n1) in num1.enumerated().reversed() {\\n\\t\\tfor (j, n2) in num2.enumerated().reversed() {\\n\\t\\t\\tguard let digit1 = Int(String(n2)), let digit2 = Int(String(n1)) else { return \"\" }\\n\\t\\t\\tlet p1 = i + j\\n\\t\\t\\tlet p2 = i + j + 1\\n\\t\\t\\tlet mult = digit1 * digit2 + sum[p2] // add in carry from before\\n\\t\\t\\tsum[p2] = mult % 10\\n\\t\\t\\tsum[p1] += mult / 10\\n\\t\\t}\\n\\t}\\n\\twhile let firstSum = sum.first, firstSum == 0 { sum.removeFirst() }\\n\\tlet res = sum.map ({ String($0) }).joined()\\n\\treturn res.count > 0 ? res : \"0\"\\n}\\n```\\n",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\n            12 \\n         x  91\\n        -------\\n           182\\n        +  910\\n        -------\\n          1092\\n```\n```\\noperation | mult | carry |  i  |  j |  sum      \\n2 x 1         2      0      1     1   [0,0,0,2]\\n2 x 9        18      0      1     0   [0,1,8,2]\\n1 x 1         1      8      0     1   [0,1,9,2]  added result to existing 8 carry\\n1 x 9         9      1      0     0   [0,10,9,2] added result to existing 1 carry\\nremove leading 0s in the sum array\\n```\n```\\nsum = [0,0,0,0] where size of sum is num1.count + num2.count\\nloop backwards nums1 (i)\\n    loop backwards nums2 (j)\\n        let p1 = i + j\\n        let p2 = i + j + 1\\n        let val = n1 * n2 + sum[p2]\\n        sum[p2] = val % 10\\n        sum[p1] += val / 10\\nremove leading 0s\\nconvert sum array to int\\n```\n```\\nfunc multiply(_ num1: String, _ num2: String) -> String {\\n\\tvar sum = [Int](repeating: 0, count: num1.count + num2.count)\\n\\tfor (i, n1) in num1.enumerated().reversed() {\\n\\t\\tfor (j, n2) in num2.enumerated().reversed() {\\n\\t\\t\\tguard let digit1 = Int(String(n2)), let digit2 = Int(String(n1)) else { return \"\" }\\n\\t\\t\\tlet p1 = i + j\\n\\t\\t\\tlet p2 = i + j + 1\\n\\t\\t\\tlet mult = digit1 * digit2 + sum[p2] // add in carry from before\\n\\t\\t\\tsum[p2] = mult % 10\\n\\t\\t\\tsum[p1] += mult / 10\\n\\t\\t}\\n\\t}\\n\\twhile let firstSum = sum.first, firstSum == 0 { sum.removeFirst() }\\n\\tlet res = sum.map ({ String($0) }).joined()\\n\\treturn res.count > 0 ? res : \"0\"\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 17731,
                "title": "short-java-ac-solution",
                "content": "        public String multiply(String num1, String num2) {\\n            int[] num = new int[num1.length()+num2.length()];\\n            int len1 = num1.length(), len2 = num2.length();\\n            for(int i=len1-1;i>=0;i--){\\n                for(int j=len2-1;j>=0;j--){\\n                    int temp = (num1.charAt(i)-'0')*(num2.charAt(j)-'0');\\n                    num[i+j] += (temp+num[i+j+1])/10;\\n                    num[i+j+1] = (num[i+j+1]+temp)%10;\\n                }\\n            }\\n            StringBuilder sb = new StringBuilder();\\n            for(int i: num) if(sb.length()>0||i>0)  sb.append(i);\\n            return (sb.length()==0)?\"0\":sb.toString();\\n        }\\nmultiply according to number's position.",
                "solutionTags": [
                    "Java"
                ],
                "code": "        public String multiply(String num1, String num2) {\\n            int[] num = new int[num1.length()+num2.length()];\\n            int len1 = num1.length(), len2 = num2.length();\\n            for(int i=len1-1;i>=0;i--){\\n                for(int j=len2-1;j>=0;j--){\\n                    int temp = (num1.charAt(i)-'0')*(num2.charAt(j)-'0');\\n                    num[i+j] += (temp+num[i+j+1])/10;\\n                    num[i+j+1] = (num[i+j+1]+temp)%10;\\n                }\\n            }\\n            StringBuilder sb = new StringBuilder();\\n            for(int i: num) if(sb.length()>0||i>0)  sb.append(i);\\n            return (sb.length()==0)?\"0\":sb.toString();\\n        }\\nmultiply according to number's position.",
                "codeTag": "Unknown"
            },
            {
                "id": 734767,
                "title": "python3-solution-with-a-detailed-explanation",
                "content": "First! Try to do a simple example (better to be with carry). Let\\'s say you want to do `23*36`. If you break the solution down, it\\'d something like `6*3  + 6*20 + 30*3 + 30*20`, right? which is equivalent to `6*3 + 6*2*10 + 3*10*3 + 2*10*3*10`, correct? You follow the second way of writing it in the code. That\\'s the intuition!\\n\\n\\n```\\nclass Solution(object):\\n    def multiply(self, num1, num2):\\n        \"\"\"\\n        :type num1: str\\n        :type num2: str\\n        :rtype: str\\n        \"\"\"\\n        res = 0 # output\\n        carry1 = 1 # carry1 takes care of num1\\n        \\n        for i in num1[::-1]: # this goes over num1 from right to left as we do normal multiplication, in the above example first 3 and then 2. \\n            carry2 = 1 # takes care of num2\\n            for j in num2[::-1]:  # this goes over num2 from right to left as we do normal multiplication, in the above example first 6 and then 3. \\n                res += int(i)*int(j)*carry1*carry2 # this is each component calculated separately and added to res\\n                carry2 *= 10 # after first iteration (number 6 is covered), it goes to the next number from right, which is 3 here, actually 30, right? That\\'s why it multiplies the carry2 by 10. Similar for carry1. \\n            carry1 *= 10\\n        return str(res)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution(object):\\n    def multiply(self, num1, num2):\\n        \"\"\"\\n        :type num1: str\\n        :type num2: str\\n        :rtype: str\\n        \"\"\"\\n        res = 0 # output\\n        carry1 = 1 # carry1 takes care of num1\\n        \\n        for i in num1[::-1]: # this goes over num1 from right to left as we do normal multiplication, in the above example first 3 and then 2. \\n            carry2 = 1 # takes care of num2\\n            for j in num2[::-1]:  # this goes over num2 from right to left as we do normal multiplication, in the above example first 6 and then 3. \\n                res += int(i)*int(j)*carry1*carry2 # this is each component calculated separately and added to res\\n                carry2 *= 10 # after first iteration (number 6 is covered), it goes to the next number from right, which is 3 here, actually 30, right? That\\'s why it multiplies the carry2 by 10. Similar for carry1. \\n            carry1 *= 10\\n        return str(res)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1563671,
                "title": "python-short-math-solution-explained",
                "content": "It is simulation like multiplication works: you do it digit by digit, and then not to forget about carries. Let us put create `d`: counter where we put all multiplications for given position. Then we traverse through dictionary and evaluate sum, using carry.\\n\\n#### Complexity\\nTime complexity is `O(mn)`, space is `O(m+n)`.\\n\\n#### Code\\n```python\\nclass Solution:\\n    def multiply(self, num1, num2):\\n        m, n = len(num1), len(num2)\\n        d = Counter()\\n        for i in range(m):\\n            for j in range(n):\\n                d[i+j] += int(num1[m-1-i])*int(num2[n-1-j])\\n                \\n        carry, ans = 0, \"\"\\n        for i in range(m+n-1):\\n            carry, digit = divmod(carry + d[i], 10)\\n            ans += str(digit)\\n            \\n        ans = (str(carry) + ans[::-1]).lstrip(\"0\")\\n        return ans if ans != \"\" else \"0\"\\n```\\n\\nIf you have any questoins, feel free to ask. If you like the solution and explanation, please **upvote!**",
                "solutionTags": [
                    "Math"
                ],
                "code": "```python\\nclass Solution:\\n    def multiply(self, num1, num2):\\n        m, n = len(num1), len(num2)\\n        d = Counter()\\n        for i in range(m):\\n            for j in range(n):\\n                d[i+j] += int(num1[m-1-i])*int(num2[n-1-j])\\n                \\n        carry, ans = 0, \"\"\\n        for i in range(m+n-1):\\n            carry, digit = divmod(carry + d[i], 10)\\n            ans += str(digit)\\n            \\n        ans = (str(carry) + ans[::-1]).lstrip(\"0\")\\n        return ans if ans != \"\" else \"0\"\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1563592,
                "title": "c-easy-intuitive-sol-basic-implementation-t-c-o-n-m",
                "content": "Hello everyone, first of all thanks for reading in advance!\\n\\n**My approach:**\\n\\n1. I\\'m going to replicate the algorithm that we all used to multiply two given integers at our schools.\\n\\n2. I\\'ll multiply every digit of a num1 with every other digits of num2 and get an intermediate result.\\n\\n3. Our intermediate result may have some 0s in the right side depending upon the unit place of digit of num1.\\n\\n4. Then we have to add all the intermediate result to get our answer.\\n\\n5. But I will save some space and compute all the intermediate results in one single array as you will see from my code.\\n\\n**Time Complexity:** O(N*M)\\n**Space Complexity:** O(M+N)\\n\\nHere\\'s my code for the approach I mentioned above:\\n\\n```\\nclass Solution {\\npublic:\\n    string multiply(string num1, string num2) {\\n        \\n        string st{};\\n        int n = num1.size(), m = num2.size();\\n        vector<int>val(n+m, 0); // result can have at max n+m values\\n        \\n\\t\\t//multiply every digit of num1 to that of num2\\n        for(int i{n-1}; i>=0; --i){\\n            \\n            for(int j{m-1}; j>=0; --j){\\n                \\n                int mul = (num1[i] - \\'0\\') * (num2[j] - \\'0\\');\\n                int sum = mul + val[i+j+1]; //cur multiplication + prev intermediate result in that index\\n                val[i+j+1] = sum % 10; // taking the unit place part of our sum\\n                val[i+j] += sum / 10; // taking the carry of our sum\\n            }\\n        }\\n        \\n\\t\\t//appending every number except the leading zeros\\n        for(auto &num: val)\\n            if(st.size() || num )\\n                st.append(to_string(num));\\n        \\n\\t\\t//If there were only zeros in val, then result is just 0\\n        if(st.size() == 0) st = \"0\";\\n        return st;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string multiply(string num1, string num2) {\\n        \\n        string st{};\\n        int n = num1.size(), m = num2.size();\\n        vector<int>val(n+m, 0); // result can have at max n+m values\\n        \\n\\t\\t//multiply every digit of num1 to that of num2\\n        for(int i{n-1}; i>=0; --i){\\n            \\n            for(int j{m-1}; j>=0; --j){\\n                \\n                int mul = (num1[i] - \\'0\\') * (num2[j] - \\'0\\');\\n                int sum = mul + val[i+j+1]; //cur multiplication + prev intermediate result in that index\\n                val[i+j+1] = sum % 10; // taking the unit place part of our sum\\n                val[i+j] += sum / 10; // taking the carry of our sum\\n            }\\n        }\\n        \\n\\t\\t//appending every number except the leading zeros\\n        for(auto &num: val)\\n            if(st.size() || num )\\n                st.append(to_string(num));\\n        \\n\\t\\t//If there were only zeros in val, then result is just 0\\n        if(st.size() == 0) st = \"0\";\\n        return st;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 17704,
                "title": "accepted-best-in-c",
                "content": "    //AC - 4ms;\\n    char* multiply(char* num1, char* num2)\\n    {\\n        if(*num1=='0' || *num2=='0') return \"0\";\\n        int len1 = strlen(num1);\\n        int len2 = strlen(num2);\\n        int len = len1+len2;\\n        int *arr = (int*)malloc(sizeof(int)*len); //the number of digits of the result - len is the top;\\n        memset(arr, 0, sizeof(int)*len); //this is critical;\\n        for(int i=len1-1; i > -1; i--)\\n            for(int j=len2-1; j > -1; j--)\\n                arr[i+j+1] += (num1[i]-'0')*(num2[j]-'0'); //collect result of each position;\\n        for(int i=len-1; i > 0; i--) //restore the carry for each position and get the final result;\\n        {\\n            arr[i-1] += arr[i]/10;\\n            arr[i] %= 10;\\n        }\\n        char *s = (char*)malloc(sizeof(char)*(len+1)); //converting the digits result to string;\\n        int index = 0;\\n        int i = 0;\\n        if(arr[i]==0) i++; //in case the zero position has no carry, if it does, ignore it;\\n        while(i < len)\\n            s[index++] = arr[i++]+'0';\\n        s[index] = '\\\\0';\\n        return s;\\n    }",
                "solutionTags": [],
                "code": "    //AC - 4ms;\\n    char* multiply(char* num1, char* num2)\\n    {\\n        if(*num1=='0' || *num2=='0') return \"0\";\\n        int len1 = strlen(num1);\\n        int len2 = strlen(num2);\\n        int len = len1+len2;\\n        int *arr = (int*)malloc(sizeof(int)*len); //the number of digits of the result - len is the top;\\n        memset(arr, 0, sizeof(int)*len); //this is critical;\\n        for(int i=len1-1; i > -1; i--)\\n            for(int j=len2-1; j > -1; j--)\\n                arr[i+j+1] += (num1[i]-'0')*(num2[j]-'0'); //collect result of each position;\\n        for(int i=len-1; i > 0; i--) //restore the carry for each position and get the final result;\\n        {\\n            arr[i-1] += arr[i]/10;\\n            arr[i] %= 10;\\n        }\\n        char *s = (char*)malloc(sizeof(char)*(len+1)); //converting the digits result to string;\\n        int index = 0;\\n        int i = 0;\\n        if(arr[i]==0) i++; //in case the zero position has no carry, if it does, ignore it;\\n        while(i < len)\\n            s[index++] = arr[i++]+'0';\\n        s[index] = '\\\\0';\\n        return s;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1376138,
                "title": "c-simple-easy-and-short-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    string multiply(string num1, string num2) {\\n        if (num1 == \"0\" || num2 == \"0\") return \"0\";\\n        \\n        vector<int> res(num1.size()+num2.size(), 0);\\n        \\n        for (int i = num1.size()-1; i >= 0; i--) {\\n            for (int j = num2.size()-1; j >= 0; j--) {\\n                res[i + j + 1] += (num1[i]-\\'0\\') * (num2[j]-\\'0\\');\\n                res[i + j] += res[i + j + 1] / 10;\\n                res[i + j + 1] %= 10;\\n            }\\n        }\\n        \\n        int i = 0;\\n        string ans = \"\";\\n        while (res[i] == 0) i++;\\n        while (i < res.size()) ans += to_string(res[i++]);\\n        \\n        return ans;\\n    }\\n};\\n```\\n**Like it? please upvote!**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string multiply(string num1, string num2) {\\n        if (num1 == \"0\" || num2 == \"0\") return \"0\";\\n        \\n        vector<int> res(num1.size()+num2.size(), 0);\\n        \\n        for (int i = num1.size()-1; i >= 0; i--) {\\n            for (int j = num2.size()-1; j >= 0; j--) {\\n                res[i + j + 1] += (num1[i]-\\'0\\') * (num2[j]-\\'0\\');\\n                res[i + j] += res[i + j + 1] / 10;\\n                res[i + j + 1] %= 10;\\n            }\\n        }\\n        \\n        int i = 0;\\n        string ans = \"\";\\n        while (res[i] == 0) i++;\\n        while (i < res.size()) ans += to_string(res[i++]);\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1770819,
                "title": "c-easy-simple-code",
                "content": "```\\nclass Solution {\\npublic:\\n    string multiply(string A, string B) {\\n        if(A==\"0\"||B==\"0\"){return \"0\";}\\n        int n = A.length(),m = B.length();\\n        string ans(n+m,\\'0\\');\\n\\n        for(int i=n-1;i>=0;i--){\\n            for(int j=m-1;j>=0;j--){\\n                int num = (A[i] - \\'0\\') * (B[j] - \\'0\\') + ans[i+j+1] - \\'0\\';\\n                ans[i+j+1] = num%10 + \\'0\\';\\n                ans[i+j] += num/10;\\n            }\\n        }\\n        for(int i=0;i<ans.length();i++){\\n            if(ans[i] != \\'0\\'){ return ans.substr(i);}\\n        } \\n        return \"0\";\\n    }\\n};\\n```\\nDo upvote if it helped :)",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string multiply(string A, string B) {\\n        if(A==\"0\"||B==\"0\"){return \"0\";}\\n        int n = A.length(),m = B.length();\\n        string ans(n+m,\\'0\\');\\n\\n        for(int i=n-1;i>=0;i--){\\n            for(int j=m-1;j>=0;j--){\\n                int num = (A[i] - \\'0\\') * (B[j] - \\'0\\') + ans[i+j+1] - \\'0\\';\\n                ans[i+j+1] = num%10 + \\'0\\';\\n                ans[i+j] += num/10;\\n            }\\n        }\\n        for(int i=0;i<ans.length();i++){\\n            if(ans[i] != \\'0\\'){ return ans.substr(i);}\\n        } \\n        return \"0\";\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 17631,
                "title": "a-clean-and-efficient-solution-accepted-as-best-submission-in-c-well-explained",
                "content": "In fact before we truly hack this problem, we might remember other calculations for [linked list][1] and [binary strings][2] and trying to reuse that kind of pattern; but soon we will find out that will cost much energy and time to solve this one: multiply for each digits, move one step for the next digit and then add them, so annoying and tedious.\\n\\nSo we will try another naive one to easily hack this, imitating the multiplication process we human do but convert it a little bit for easier latter work.  The following steps will use 34 * 56 to present the whole process:\\n\\n - first, we multiply the lowest digit 6 with all the first number 34 without any carry just store the numbers: 18, 24 - from left to right respectively (all the carry operations will be handled in the following steps); then the second lowest digit 5 and the result numbers will be 15, 20 from left to right respectively;\\n - second, actually when we human calculate, (15, 20) as a whole will be moved to the left by one digit, right? Why? Because digit 5 is left-er than the digit 6 by one digit; okay, things are now getting clearer now; here we are going to use an array to store the result of each *position* , still ignoring carry here; one thing should be remembered is that the position is determined by the position of the digit in both the first and second number; if you know how the multiplication process, then this will be easy to understand.\\n - third, we are almost there; strings are indexed from left to right, so the smaller the index of the digit the higher its digit base (100, 10, 1 etc) will be; so we will store the results following this fact, from left to right, the unit will be decreasing; as we have discussed in second part, the position will be determined by that of digits in both first and second number so arr[i+j] = (num1[i]-'0')\\\\*(num2[j]-'0') will be a good equation; but the same position might be used to store several results from different pairs of digits multiplication. So `arr[i+j] += (num1[i]-'0')*(num2[j]-'0')` and before we collect the results, we have to initialise all elements of arr to zero; at last arr[i+j+1] should be used instead of arr[i+j], why? we might have a carry at the heading position, right? You will understand it sooner or later after all the specification;\\n - fourth, collecting the result and constructing the result string to return: from the last to the first we get carried by `a[i-1] = a[i]/10; a[i] %= 10;` but the zero position here might be zero for no carry comes around so we should remove it, if it is that case otherwise we just collect it as usual.\\n\\n-------\\n - Space cost O(n)\\n - Time cost O(n)\\n\\n```\\n//AC - 4ms;\\nchar* multiply(char* num1, char* num2){\\n    if(*num1=='0' || *num2=='0') return \"0\";\\n    int len1 = strlen(num1);\\n    int len2 = strlen(num2);\\n    int len = len1+len2;\\n    int *arr = (int*)malloc(sizeof(int)*len); //the number of digits of the result - len is the top;\\n    memset(arr, 0, sizeof(int)*len); //this is critical;\\n    for(int i=len1-1; i > -1; i--)\\n        for(int j=len2-1; j > -1; j--)\\n            arr[i+j+1] += (num1[i]-'0')*(num2[j]-'0'); //collect result of each position;\\n    for(int i=len-1; i > 0; i--) {\\n        arr[i-1] += arr[i]/10;\\n        arr[i] %= 10;\\n    }\\n    char *s = (char*)malloc(sizeof(char)*(len+1)); //converting the digits result to string;\\n    int index = 0;\\n    int i = 0;\\n    if(arr[i]==0) i++; //in case the zero position has no carry, if it does, ignore it;\\n    while(i < len)\\n        s[index++] = arr[i++]+'0';\\n    s[index] = '\\\\0';\\n    return s;\\n}\\n```",
                "solutionTags": [
                    "Iterator"
                ],
                "code": "```\\n//AC - 4ms;\\nchar* multiply(char* num1, char* num2){\\n    if(*num1=='0' || *num2=='0') return \"0\";\\n    int len1 = strlen(num1);\\n    int len2 = strlen(num2);\\n    int len = len1+len2;\\n    int *arr = (int*)malloc(sizeof(int)*len); //the number of digits of the result - len is the top;\\n    memset(arr, 0, sizeof(int)*len); //this is critical;\\n    for(int i=len1-1; i > -1; i--)\\n        for(int j=len2-1; j > -1; j--)\\n            arr[i+j+1] += (num1[i]-'0')*(num2[j]-'0'); //collect result of each position;\\n    for(int i=len-1; i > 0; i--) {\\n        arr[i-1] += arr[i]/10;\\n        arr[i] %= 10;\\n    }\\n    char *s = (char*)malloc(sizeof(char)*(len+1)); //converting the digits result to string;\\n    int index = 0;\\n    int i = 0;\\n    if(arr[i]==0) i++; //in case the zero position has no carry, if it does, ignore it;\\n    while(i < len)\\n        s[index++] = arr[i++]+'0';\\n    s[index] = '\\\\0';\\n    return s;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1663687,
                "title": "solution-swift-multiply-strings",
                "content": "```swift\\nclass Solution {\\n    func multiply(_ num1: String, _ num2: String) -> String {\\n        \\n        var arr = Array(repeating: 0, count: num1.count + num2.count)\\n        var result = \"\"\\n        \\n        for (i1,n1) in num1.reversed().enumerated() where n1.isNumber {\\n            for (i2,n2) in num2.reversed().enumerated() where n2.isNumber {\\n                arr[i1 + i2] += Int(String(n1))! * Int(String(n2))!\\n            }\\n        }\\n        for i in arr.indices {\\n            let n = arr[i]\\n            arr[i] = n % 10\\n            if i < arr.count - 1 { arr[i+1] += (n / 10) }\\n            result = String(arr[i]) + result\\n        }\\n        while !result.isEmpty && result.first == \"0\" {\\n            result.removeFirst()\\n        }\\n        return result.isEmpty ? \"0\" : result\\n    }\\n}\\n```\\n\\n---\\n\\n<p>\\n<details>\\n<summary>\\n<img src=\"https://git.io/JDblm\" height=\"24\">\\n<b>TEST CASES</b>\\n</summary>\\n\\n<p><pre>\\n<b>Result:</b> Executed 2 tests, with 0 failures (0 unexpected) in 0.008 (0.010) seconds\\n</pre></p>\\n\\n```swift\\nimport XCTest\\n\\nclass Tests: XCTestCase {\\n    \\n    private let solution = Solution()\\n    \\n    func test0() {\\n        let value = solution.multiply(\"2\", \"3\")\\n        XCTAssertEqual(value, \"6\")\\n    }\\n    \\n    func test1() {\\n        let value = solution.multiply(\"123\", \"456\")\\n        XCTAssertEqual(value, \"56088\")\\n    }\\n}\\n\\nTests.defaultTestSuite.run()\\n```\\n\\n</details>\\n</p>",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```swift\\nclass Solution {\\n    func multiply(_ num1: String, _ num2: String) -> String {\\n        \\n        var arr = Array(repeating: 0, count: num1.count + num2.count)\\n        var result = \"\"\\n        \\n        for (i1,n1) in num1.reversed().enumerated() where n1.isNumber {\\n            for (i2,n2) in num2.reversed().enumerated() where n2.isNumber {\\n                arr[i1 + i2] += Int(String(n1))! * Int(String(n2))!\\n            }\\n        }\\n        for i in arr.indices {\\n            let n = arr[i]\\n            arr[i] = n % 10\\n            if i < arr.count - 1 { arr[i+1] += (n / 10) }\\n            result = String(arr[i]) + result\\n        }\\n        while !result.isEmpty && result.first == \"0\" {\\n            result.removeFirst()\\n        }\\n        return result.isEmpty ? \"0\" : result\\n    }\\n}\\n```\n```swift\\nimport XCTest\\n\\nclass Tests: XCTestCase {\\n    \\n    private let solution = Solution()\\n    \\n    func test0() {\\n        let value = solution.multiply(\"2\", \"3\")\\n        XCTAssertEqual(value, \"6\")\\n    }\\n    \\n    func test1() {\\n        let value = solution.multiply(\"123\", \"456\")\\n        XCTAssertEqual(value, \"56088\")\\n    }\\n}\\n\\nTests.defaultTestSuite.run()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 17678,
                "title": "c-imeplemetation",
                "content": "C# imeplemetation\\n```\\n        public string Multiply(string num1, string num2)\\n        {\\n            int n1 = num1.Length;\\n            int n2 = num2.Length;\\n            int[] products = new int[n1 + n2];\\n\\n            for (int i = n1 - 1; i >= 0; i--)\\n            {\\n                for (int j = n2 - 1; j >= 0; j--)\\n                {\\n                    int p1 = i + j;\\n                    int p2 = p1 + 1;\\n                    int sum = (num1[i] - '0') * (num2[j] - '0') + products[p2];\\n\\n                    products[p1] += sum / 10;\\n                    products[p2] = sum % 10;\\n                }\\n            }\\n\\n            StringBuilder sb = new StringBuilder();\\n            foreach(int num in products)\\n            {\\n                if (!(sb.Length == 0 && num == 0))\\n                {\\n                    sb.Append(num);\\n                }\\n            }\\n\\n            return sb.Length == 0 ? \"0\" : sb.ToString();\\n        }\\n```",
                "solutionTags": [],
                "code": "```\\n        public string Multiply(string num1, string num2)\\n        {\\n            int n1 = num1.Length;\\n            int n2 = num2.Length;\\n            int[] products = new int[n1 + n2];\\n\\n            for (int i = n1 - 1; i >= 0; i--)\\n            {\\n                for (int j = n2 - 1; j >= 0; j--)\\n                {\\n                    int p1 = i + j;\\n                    int p2 = p1 + 1;\\n                    int sum = (num1[i] - '0') * (num2[j] - '0') + products[p2];\\n\\n                    products[p1] += sum / 10;\\n                    products[p2] = sum % 10;\\n                }\\n            }\\n\\n            StringBuilder sb = new StringBuilder();\\n            foreach(int num in products)\\n            {\\n                if (!(sb.Length == 0 && num == 0))\\n                {\\n                    sb.Append(num);\\n                }\\n            }\\n\\n            return sb.Length == 0 ? \"0\" : sb.ToString();\\n        }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1263988,
                "title": "compute-backwards-99-faster-dp-javascript-complexity-o-n-m",
                "content": "`COMMENTARY:`\\n- Think how would you compute 12*6 on paper?\\n- We start by multiplying the last digits first, right?\\n- We take care of \"carry-overs\" and \"previous values\", right?\\n- For coding that out we will first allocate buckets/indices in an aux array (dp)\\n- We will fill buckets with unit-digits right-to-left\\n- Important point: The correct bucket number for putting the result is the sum of their index number plus 1\\n\\n`CODE:`\\n```\\nconst multiply = function(num1, num2) {\\n    const dp = [...Array(num1.length+num2.length)].fill(0); \\n    for(let i = num1.length-1; i >= 0; i--){\\n      for(let j = num2.length-1; j >= 0; j--){\\n\\t  \\n\\t  //Define\\n\\t\\tconst prevRemainder  = dp[i+j+1] \\n        const product = num1[i]*num2[j]+prevRemainder\\n        const unitsDigit = product%10\\n        const carryOver = Math.floor(product/10)\\n\\t\\t\\t\\n\\t\\t//Update\\n        dp[i+j+1] = unitsDigit;\\n\\t\\tdp[i+j] += carryOver\\n       }\\n    }\\n    \\n    //Delete leading-zeroes\\n    let idx = 0\\n    while(dp[idx] === 0) dp.shift()\\n    if(!dp.length) return \"0\"\\n    return dp.join(\"\") \\n};\\n```\\n![image](https://assets.leetcode.com/users/images/f40724fe-59ea-4b12-88eb-8d648b02b5cc_1623372777.7851412.png)\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nconst multiply = function(num1, num2) {\\n    const dp = [...Array(num1.length+num2.length)].fill(0); \\n    for(let i = num1.length-1; i >= 0; i--){\\n      for(let j = num2.length-1; j >= 0; j--){\\n\\t  \\n\\t  //Define\\n\\t\\tconst prevRemainder  = dp[i+j+1] \\n        const product = num1[i]*num2[j]+prevRemainder\\n        const unitsDigit = product%10\\n        const carryOver = Math.floor(product/10)\\n\\t\\t\\t\\n\\t\\t//Update\\n        dp[i+j+1] = unitsDigit;\\n\\t\\tdp[i+j] += carryOver\\n       }\\n    }\\n    \\n    //Delete leading-zeroes\\n    let idx = 0\\n    while(dp[idx] === 0) dp.shift()\\n    if(!dp.length) return \"0\"\\n    return dp.join(\"\") \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 144297,
                "title": "what-does-directly-convert-the-inputs-to-integer-mean",
                "content": "What exactly does \"directly\" mean?  Unless a solution invovles bit-arithmetic, it will include conversion of characters to ints using something like \\n```\\nintValue = someChar-`0`\\n```\\nThen, the solution will have some integer arithmetic, followed by conversion of ints to corresponding chars.\\n\\nWhere in the agorithm should these conversion happen in order for it to be considered not \"directly\" convert?\\n\\nmany thanks.\\n\\n",
                "solutionTags": [],
                "code": "```\\nintValue = someChar-`0`\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 17723,
                "title": "simple-clear-java-solution",
                "content": "    public class Solution {\\n        public String multiply(String num1, String num2) {\\n            int len1 = num1.length();\\n            int len2 = num2.length();\\n            int len = len1 + len2;\\n            int[] mul = new int[len];\\n            for (int i = len1 - 1; i >= 0; i--) {\\n                int a = num1.charAt(i) - '0';\\n                int k = len2 + i;\\n                for (int j = len2 - 1; j >= 0; j--) {\\n                    int b = num2.charAt(j) - '0';\\n                    int c = mul[k] + a * b;\\n                    mul[k] = c % 10;\\n                    mul[k - 1] = mul[k - 1] + c /10;\\n                    k--;\\n                }\\n            }\\n            int i = 0;\\n            while(mul[i] == 0 && i < len - 1)  i++;\\n            StringBuilder sb = new StringBuilder();\\n            for (; i < len; i++)\\n                sb.append(mul[i]);\\n            return sb.length() == 0 ? \"0\" : sb.toString();\\n        }\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n        public String multiply(String num1, String num2) {\\n            int len1 = num1.length();\\n            int len2 = num2.length();\\n            int len = len1 + len2;\\n            int[] mul = new int[len];\\n            for (int i = len1 - 1; i >= 0; i--) {\\n                int a = num1.charAt(i) - '0';\\n                int k = len2 + i;\\n                for (int j = len2 - 1; j >= 0; j--) {\\n                    int b = num2.charAt(j) - '0';\\n                    int c = mul[k] + a * b;\\n                    mul[k] = c % 10;\\n                    mul[k - 1] = mul[k - 1] + c /10;\\n                    k--;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 1909399,
                "title": "100-fastest-swift-solution",
                "content": "```\\nclass Solution {\\n    func multiply(_ num1: String, _ num2: String) -> String {\\n\\t\\tif (num1 == \"0\" || num2 == \"0\") { return \"0\"}\\n\\t\\tlet list1 = convertString(num1)\\n\\t\\tlet list2 = convertString(num2)\\n\\t\\tvar tmp1 = list1\\n\\t\\tvar tmp2 = list2\\n\\t\\tvar lists: [ListNode?] = []\\n\\t\\tvar index = 0\\n\\n\\t\\twhile tmp1 != nil {\\n\\t\\t\\tvar list: ListNode? = nil\\n\\t\\t\\tvar current = list\\n\\t\\t\\tvar add = 0\\n\\t\\t\\tfor _ in 0..<index {\\n\\t\\t\\t\\tlet node = ListNode(0)\\n\\t\\t\\t\\tif list == nil { list = node }\\n\\t\\t\\t\\tcurrent?.next = node\\n\\t\\t\\t\\tcurrent = node\\n\\t\\t\\t}\\n\\t\\t\\twhile tmp2 != nil {\\n\\t\\t\\t\\tlet val = tmp1!.val * tmp2!.val + add\\n\\t\\t\\t\\tlet node = ListNode(val % 10)\\n\\t\\t\\t\\tadd = val / 10\\n\\t\\t\\t\\tif list == nil { list = node }\\n\\t\\t\\t\\tcurrent?.next = node\\n\\t\\t\\t\\tcurrent = node\\n\\t\\t\\t\\ttmp2 = tmp2?.next\\n\\t\\t\\t}\\n\\t\\t\\tif add > 0 {\\n\\t\\t\\t\\tcurrent?.next = ListNode(add)\\n\\t\\t\\t}\\n\\t\\t\\ttmp1 = tmp1?.next\\n\\t\\t\\ttmp2 = list2\\n\\t\\t\\tlists.append(list)\\n\\t\\t\\tindex += 1\\n\\t\\t}\\n\\t\\tlet res = addLists(lists)\\n        return convertListNode(res)\\n    }\\n\\n\\n\\tfunc convertString(_ num: String) -> ListNode? {\\n\\t\\tvar list: ListNode? = nil\\n\\t\\tvar current = list\\n\\t\\t\\n\\t\\tfor i in num.reversed() {\\n\\t\\t\\tlet node = ListNode(Int(String(i)) ?? 0)\\n\\t\\t\\tif current != nil {\\n\\t\\t\\t\\tcurrent?.next = node\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tlist = node\\n\\t\\t\\t}\\n\\t\\t\\tcurrent = node\\n\\t\\t}\\n\\t\\treturn list\\n\\t}\\n\\n\\n\\tfunc convertListNode(_ list: ListNode?) -> String {\\n\\t\\tvar tmp = list\\n\\t\\tvar string = \"\"\\n\\t\\twhile tmp != nil {\\n\\t\\t\\tstring = \"\\\\(tmp!.val)\\\\(string)\"\\n\\t\\t\\ttmp = tmp!.next;\\n\\t\\t}\\n\\t\\treturn string\\n\\t}\\n\\n\\n\\tfunc addTwoNumbers(_ l1: ListNode?, _ l2: ListNode?) -> ListNode? {\\n        var add = 0\\n        var _l1 = l1\\n        var _l2 = l2\\n        var list: [ListNode] = []\\n        while _l1 != nil || _l2 != nil {\\n            let _l1_val = _l1?.val ?? 0\\n            let _l2_val = _l2?.val ?? 0\\n            let val = _l1_val + _l2_val + add\\n            let num = val % 10\\n            add = val / 10\\n            list.append(ListNode(num))\\n            _l1 = _l1?.next\\n            _l2 = _l2?.next\\n        }\\n        if (add == 1) {\\n            list.append(ListNode(1))\\n        }\\n        var head: ListNode?\\n        for node in list.reversed() {\\n            node.next = head\\n            head = node\\n        }\\n        return head\\n    }\\n\\n\\n\\tfunc addLists(_ lists: [ListNode?]) -> ListNode? {\\n\\t\\tif lists.count == 1 {\\n\\t\\t\\treturn lists[0]\\n\\t\\t} else {\\n\\t\\t\\tvar tmp = lists[0]\\n\\t\\t\\tfor (i, list) in lists.enumerated() {\\n\\t\\t\\t\\tif i > 0 {\\n\\t\\t\\t\\t\\ttmp = addTwoNumbers(tmp, list)\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn tmp\\n\\t\\t}\\n\\t}\\n\\n}\\n\\n```\\n\\nLet me know in comments if you have any doubts. I will be happy to answer.\\n\\nPlease upvote if you found the solution useful.",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func multiply(_ num1: String, _ num2: String) -> String {\\n\\t\\tif (num1 == \"0\" || num2 == \"0\") { return \"0\"}\\n\\t\\tlet list1 = convertString(num1)\\n\\t\\tlet list2 = convertString(num2)\\n\\t\\tvar tmp1 = list1\\n\\t\\tvar tmp2 = list2\\n\\t\\tvar lists: [ListNode?] = []\\n\\t\\tvar index = 0\\n\\n\\t\\twhile tmp1 != nil {\\n\\t\\t\\tvar list: ListNode? = nil\\n\\t\\t\\tvar current = list\\n\\t\\t\\tvar add = 0\\n\\t\\t\\tfor _ in 0..<index {\\n\\t\\t\\t\\tlet node = ListNode(0)\\n\\t\\t\\t\\tif list == nil { list = node }\\n\\t\\t\\t\\tcurrent?.next = node\\n\\t\\t\\t\\tcurrent = node\\n\\t\\t\\t}\\n\\t\\t\\twhile tmp2 != nil {\\n\\t\\t\\t\\tlet val = tmp1!.val * tmp2!.val + add\\n\\t\\t\\t\\tlet node = ListNode(val % 10)\\n\\t\\t\\t\\tadd = val / 10\\n\\t\\t\\t\\tif list == nil { list = node }\\n\\t\\t\\t\\tcurrent?.next = node\\n\\t\\t\\t\\tcurrent = node\\n\\t\\t\\t\\ttmp2 = tmp2?.next\\n\\t\\t\\t}\\n\\t\\t\\tif add > 0 {\\n\\t\\t\\t\\tcurrent?.next = ListNode(add)\\n\\t\\t\\t}\\n\\t\\t\\ttmp1 = tmp1?.next\\n\\t\\t\\ttmp2 = list2\\n\\t\\t\\tlists.append(list)\\n\\t\\t\\tindex += 1\\n\\t\\t}\\n\\t\\tlet res = addLists(lists)\\n        return convertListNode(res)\\n    }\\n\\n\\n\\tfunc convertString(_ num: String) -> ListNode? {\\n\\t\\tvar list: ListNode? = nil\\n\\t\\tvar current = list\\n\\t\\t\\n\\t\\tfor i in num.reversed() {\\n\\t\\t\\tlet node = ListNode(Int(String(i)) ?? 0)\\n\\t\\t\\tif current != nil {\\n\\t\\t\\t\\tcurrent?.next = node\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tlist = node\\n\\t\\t\\t}\\n\\t\\t\\tcurrent = node\\n\\t\\t}\\n\\t\\treturn list\\n\\t}\\n\\n\\n\\tfunc convertListNode(_ list: ListNode?) -> String {\\n\\t\\tvar tmp = list\\n\\t\\tvar string = \"\"\\n\\t\\twhile tmp != nil {\\n\\t\\t\\tstring = \"\\\\(tmp!.val)\\\\(string)\"\\n\\t\\t\\ttmp = tmp!.next;\\n\\t\\t}\\n\\t\\treturn string\\n\\t}\\n\\n\\n\\tfunc addTwoNumbers(_ l1: ListNode?, _ l2: ListNode?) -> ListNode? {\\n        var add = 0\\n        var _l1 = l1\\n        var _l2 = l2\\n        var list: [ListNode] = []\\n        while _l1 != nil || _l2 != nil {\\n            let _l1_val = _l1?.val ?? 0\\n            let _l2_val = _l2?.val ?? 0\\n            let val = _l1_val + _l2_val + add\\n            let num = val % 10\\n            add = val / 10\\n            list.append(ListNode(num))\\n            _l1 = _l1?.next\\n            _l2 = _l2?.next\\n        }\\n        if (add == 1) {\\n            list.append(ListNode(1))\\n        }\\n        var head: ListNode?\\n        for node in list.reversed() {\\n            node.next = head\\n            head = node\\n        }\\n        return head\\n    }\\n\\n\\n\\tfunc addLists(_ lists: [ListNode?]) -> ListNode? {\\n\\t\\tif lists.count == 1 {\\n\\t\\t\\treturn lists[0]\\n\\t\\t} else {\\n\\t\\t\\tvar tmp = lists[0]\\n\\t\\t\\tfor (i, list) in lists.enumerated() {\\n\\t\\t\\t\\tif i > 0 {\\n\\t\\t\\t\\t\\ttmp = addTwoNumbers(tmp, list)\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn tmp\\n\\t\\t}\\n\\t}\\n\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 724898,
                "title": "no-str-int-or-int-str-function-easy-to-understand-python",
                "content": "```\\nclass Solution:\\n    def multiply(self, num1: str, num2: str) -> str:\\n        #edge cases \\n        if len(num1) == 0 or len(num2) == 0:\\n            return \\'0\\'\\n        if num1[0] == \\'0\\' or num2[0] == \\'0\\':\\n            return \\'0\\'\\n        # convert to integer \\n        res1, res2 = 0, 0 \\n        for d in num1:\\n            res1 = res1 * 10 + (ord(d) - ord(\\'0\\'))\\n        for d in num2:\\n            res2 = res2 * 10 + (ord(d) - ord(\\'0\\'))\\n\\n        # get the product result \\n        res = res1 * res2\\n\\n        # convert to string, remember to reverse the result \\n        ans = \\'\\' \\n        while res:\\n            ans = ans +(chr(ord(\\'0\\') + res % 10)) \\n            res //= 10 \\n        return ans[::-1]\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def multiply(self, num1: str, num2: str) -> str:\\n        #edge cases \\n        if len(num1) == 0 or len(num2) == 0:\\n            return \\'0\\'\\n        if num1[0] == \\'0\\' or num2[0] == \\'0\\':\\n            return \\'0\\'\\n        # convert to integer \\n        res1, res2 = 0, 0 \\n        for d in num1:\\n            res1 = res1 * 10 + (ord(d) - ord(\\'0\\'))\\n        for d in num2:\\n            res2 = res2 * 10 + (ord(d) - ord(\\'0\\'))\\n\\n        # get the product result \\n        res = res1 * res2\\n\\n        # convert to string, remember to reverse the result \\n        ans = \\'\\' \\n        while res:\\n            ans = ans +(chr(ord(\\'0\\') + res % 10)) \\n            res //= 10 \\n        return ans[::-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 357917,
                "title": "simple-7-line-python-solution-ascii-values",
                "content": "```\\nclass Solution:\\n    def multiply(self, num1: str, num2: str) -> str:\\n        res1, res2 = 0, 0 \\n        for d in num1:\\n            res1 = res1 * 10 + (ord(d) - ord(\\'0\\'))\\n        for d in num2:\\n            res2 = res2 * 10 + (ord(d) - ord(\\'0\\'))\\n        return str(res1 * res2)\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def multiply(self, num1: str, num2: str) -> str:\\n        res1, res2 = 0, 0 \\n        for d in num1:\\n            res1 = res1 * 10 + (ord(d) - ord(\\'0\\'))\\n        for d in num2:\\n            res2 = res2 * 10 + (ord(d) - ord(\\'0\\'))\\n        return str(res1 * res2)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 17755,
                "title": "share-a-code-with-fft",
                "content": "It's not the fastest. Perhaps the scale of test cases is too small. Whatever, its time complexity is O(nlogn).\\n\\n \\n    string multiply(string num1, string num2) {\\n        \\n        int l1 = num1.size(), l2 = num2.size(); \\n        int d = max(l1, l2) / 5 + 1; \\n        int m = 1; \\n        while (m < d) m <<= 1; \\n        m <<= 1;\\n        \\n        complex *a=new complex[m+1];\\n        complex *b=new complex[m+1];\\n        \\n        memset(a, 0, (m + 1)*sizeof(complex)); \\n        memset(b, 0, (m + 1)*sizeof(complex)); \\n        int la = 0; \\n        for (int i = l1 - 1; i >= 0; i -= 5) { \\n            int tmp = 0; \\n            for (int j = i - 4; j <= i; ++j) { \\n                if (j < 0) continue; \\n                tmp = tmp * 10 + num1[j] - '0'; \\n            } \\n            a[la++] = complex(tmp, 0); \\n        } \\n \\n        int lb = 0; \\n        for (int i = l2 - 1; i >= 0; i -= 5) { \\n            int tmp = 0; \\n            for (int j = i - 4; j <= i; ++j) {\\n                if (j < 0) continue; \\n                tmp = tmp * 10 + num2[j] - '0'; \\n            } \\n            b[lb++] = complex(tmp, 0);\\n        } \\n \\n        int l = max(la, lb);\\n        int n = 1; \\n        while (n < l) n <<= 1; \\n        n <<= 1;\\n        \\n        long long *ans=new long long[n+10];\\n        \\n        fft(a, n, 0); \\n        fft(b, n, 0); \\n        for(int i = 0; i < n; i++) a[i] = a[i] * b[i]; \\n        fft(a, n, 1); \\n \\n        ans[0] = 0; \\n        for (int i = 0; i < n; ++i) { \\n            ans[i+1] = 0; \\n            ans[i] += (long long)(a[i].x + 0.5); \\n            ans[i+1] += ans[i] / 100000; \\n            ans[i] %= 100000; \\n        } \\n        while (ans[n]) {\\n            ans[n+1] = ans[n] / 100000; \\n            ans[n] %= 100000; \\n            ++n; \\n        } \\n        while (n > 1 && ans[n-1] == 0) --n; \\n \\n \\n        stringstream s;\\n        for(int i = n - 1; i >= 0; --i){\\n            s << (int)ans[i];\\n            s << setw(5) << setfill('0');\\n        }\\n        \\n        delete[] a;\\n        delete[] b;\\n        delete[] ans;\\n        return s.str();\\n    }\\n\\n    const double pi = acos(-1.0);\\n    \\n    struct complex { \\n        double x, y; \\n        complex(): x(0), y(0) {} \\n        complex(double _x, double _y): x(_x), y(_y) {} \\n    \\n        friend complex operator +(const complex &a, const complex &b) { \\n            return complex(a.x + b.x, a.y + b.y); \\n        } \\n        friend complex operator -(const complex &a, const complex &b) { \\n            return complex(a.x - b.x, a.y - b.y); \\n        } \\n        friend complex operator *(const complex &a, const complex &b) { \\n            return complex(a.x * b.x - a.y * b.y, a.x * b.y + a.y * b.x); \\n        } \\n        friend complex operator /(const complex &a, const double &b) { \\n            return complex(a.x / b, a.y / b); \\n        }\\n    };\\n    inline complex conj(const complex &a) { \\n        return complex(a.x, -a.y); \\n    }\\n     \\n    void fft(complex *a, int n, bool inv) {\\n        complex *w=new complex[n+1];\\n        int *rv=new int[n+1];\\n        int bits=-1;\\n        int _bit = 0; \\n        for(int i = 0; i < 30; ++i) if (n & 1 << i) _bit = i; \\n        if (_bit != bits) { \\n            bits = _bit; \\n            rv[0] = 0; \\n            rv[1] = 1; \\n            for(int st = 1; st < bits; ++st) { \\n                int k = 1 << st; \\n                for(int i = 0; i < k; ++i) { \\n                    rv[i+(1<<st)] = rv[i] << 1 | 1; \\n                    rv[i] <<= 1; \\n                } \\n            } \\n            for(int i = 0; i < 1 << bits; ++i) \\n                w[i] = complex(cos(2.0 * pi * i / n), sin(2.0 * pi * i / n)); \\n        } \\n        for(int i = 0; i < n; i++) \\n            if (rv[i] <= i) swap(a[i], a[rv[i]]); \\n        for(int d = n >> 1, st = 2; d > 0; d >>= 1, st <<= 1) { \\n            int o = st >> 1; \\n            for (int j = 0; j < o; ++j) { \\n                complex wi = (inv ? conj(w[j*d]) : w[j*d]); \\n                for (int i = j; i < n; i += st) { \\n                    int k = i + o; \\n                    complex u = a[i], v = a[k] * wi; \\n                    a[i] = u + v; \\n                    a[k] = u - v; \\n                } \\n            } \\n        } \\n        if (inv) for(int i = 0; i < n; ++i) a[i] = a[i] / n;\\n        \\n        delete[] w;\\n        delete[] rv;\\n    }",
                "solutionTags": [],
                "code": "It's not the fastest. Perhaps the scale of test cases is too small. Whatever, its time complexity is O(nlogn).\\n\\n \\n    string multiply(string num1, string num2) {\\n        \\n        int l1 = num1.size(), l2 = num2.size(); \\n        int d = max(l1, l2) / 5 + 1; \\n        int m = 1; \\n        while (m < d) m <<= 1; \\n        m <<= 1;\\n        \\n        complex *a=new complex[m+1];\\n        complex *b=new complex[m+1];\\n        \\n        memset(a, 0, (m + 1)*sizeof(complex)); \\n        memset(b, 0, (m + 1)*sizeof(complex)); \\n        int la = 0; \\n        for (int i = l1 - 1; i >= 0; i -= 5) { \\n            int tmp = 0; \\n            for (int j = i - 4; j <= i; ++j) { \\n                if (j < 0) continue; \\n                tmp = tmp * 10 + num1[j] - '0'; \\n            } \\n            a[la++] = complex(tmp, 0); \\n        } \\n \\n        int lb = 0; \\n        for (int i = l2 - 1; i >= 0; i -= 5) { \\n            int tmp = 0; \\n            for (int j = i - 4; j <= i; ++j) {\\n                if (j < 0) continue; \\n                tmp = tmp * 10 + num2[j] - '0'; \\n            } \\n            b[lb++] = complex(tmp, 0);\\n        } \\n \\n        int l = max(la, lb);\\n        int n = 1; \\n        while (n < l) n <<= 1; \\n        n <<= 1;\\n        \\n        long long *ans=new long long[n+10];\\n        \\n        fft(a, n, 0); \\n        fft(b, n, 0); \\n        for(int i = 0; i < n; i++) a[i] = a[i] * b[i]; \\n        fft(a, n, 1); \\n \\n        ans[0] = 0; \\n        for (int i = 0; i < n; ++i) { \\n            ans[i+1] = 0; \\n            ans[i] += (long long)(a[i].x + 0.5); \\n            ans[i+1] += ans[i] / 100000; \\n            ans[i] %= 100000; \\n        } \\n        while (ans[n]) {\\n            ans[n+1] = ans[n] / 100000; \\n            ans[n] %= 100000; \\n            ++n; \\n        } \\n        while (n > 1 && ans[n-1] == 0) --n; \\n \\n \\n        stringstream s;\\n        for(int i = n - 1; i >= 0; --i){\\n            s << (int)ans[i];\\n            s << setw(5) << setfill('0');\\n        }\\n        \\n        delete[] a;\\n        delete[] b;\\n        delete[] ans;\\n        return s.str();\\n    }\\n\\n    const double pi = acos(-1.0);\\n    \\n    struct complex { \\n        double x, y; \\n        complex(): x(0), y(0) {} \\n        complex(double _x, double _y): x(_x), y(_y) {} \\n    \\n        friend complex operator +(const complex &a, const complex &b) { \\n            return complex(a.x + b.x, a.y + b.y); \\n        } \\n        friend complex operator -(const complex &a, const complex &b) { \\n            return complex(a.x - b.x, a.y - b.y); \\n        } \\n        friend complex operator *(const complex &a, const complex &b) { \\n            return complex(a.x * b.x - a.y * b.y, a.x * b.y + a.y * b.x); \\n        } \\n        friend complex operator /(const complex &a, const double &b) { \\n            return complex(a.x / b, a.y / b); \\n        }\\n    };\\n    inline complex conj(const complex &a) { \\n        return complex(a.x, -a.y); \\n    }\\n     \\n    void fft(complex *a, int n, bool inv) {\\n        complex *w=new complex[n+1];\\n        int *rv=new int[n+1];\\n        int bits=-1;\\n        int _bit = 0; \\n        for(int i = 0; i < 30; ++i) if (n & 1 << i) _bit = i; \\n        if (_bit != bits) { \\n            bits = _bit; \\n            rv[0] = 0; \\n            rv[1] = 1; \\n            for(int st = 1; st < bits; ++st) { \\n                int k = 1 << st; \\n                for(int i = 0; i < k; ++i) { \\n                    rv[i+(1<<st)] = rv[i] << 1 | 1; \\n                    rv[i] <<= 1; \\n                } \\n            } \\n            for(int i = 0; i < 1 << bits; ++i) \\n                w[i] = complex(cos(2.0 * pi * i / n), sin(2.0 * pi * i / n)); \\n        } \\n        for(int i = 0; i < n; i++) \\n            if (rv[i] <= i) swap(a[i], a[rv[i]]); \\n        for(int d = n >> 1, st = 2; d > 0; d >>= 1, st <<= 1) { \\n            int o = st >> 1; \\n            for (int j = 0; j < o; ++j) { \\n                complex wi = (inv ? conj(w[j*d]) : w[j*d]); \\n                for (int i = j; i < n; i += st) { \\n                    int k = i + o; \\n                    complex u = a[i], v = a[k] * wi; \\n                    a[i] = u + v; \\n                    a[k] = u - v; \\n                } \\n            } \\n        } \\n        if (inv) for(int i = 0; i < n; ++i) a[i] = a[i] / n;\\n        \\n        delete[] w;\\n        delete[] rv;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1563605,
                "title": "java-python-3-simulation-of-multiplication-w-brief-explanation-analysis-and-similar-problems",
                "content": "Similar Problems -->\\n[2. Add Two Numbers](https://leetcode.com/problems/add-two-numbers/)\\n[8. String to Integer (atoi)](https://leetcode.com/problems/string-to-integer-atoi/)\\n[43. Multiply Strings](https://leetcode.com/problems/multiply-strings/)\\n[66. Plus One](https://leetcode.com/problems/plus-one/)\\n[67. Add Binary](https://leetcode.com/problems/add-binary/)\\n[415. Add Strings](https://leetcode.com/problems/add-strings/)\\n[445. Add Two Numbers I](https://leetcode.com/problems/add-two-numbers-ii/)\\n[537. Complex Number Multiplication](https://leetcode.com/problems/complex-number-multiplication/)\\n[592. Fraction Addition and Subtraction](https://leetcode.com/problems/fraction-addition-and-subtraction/)\\n[640. Solve the Equation](https://leetcode.com/problems/solve-the-equation/)\\n[1041. Robot Bounded In Circle](https://leetcode.com/problems/robot-bounded-in-circle/)\\n[1945. Sum of Digits of String After Convert](https://leetcode.com/problems/sum-of-digits-of-string-after-convert/)\\n\\n----\\n. \\n1. Reversely traverse `num1` and `num2`, for each pair of digits on `ith` and `jth` bits of `num1` and `num2`, perform multiplication operation, which only influence `(i + j)th` and `(i + j + 1)th` bits of the result;\\n2. Accumulate the product of `ith` and `jth` digits of `num1` and `num2` respectively on current result bit; divide the product by `10`, add it to the carry over bit, then do modulous operation, `% 10`, on current result bit; \\n3. Finally, do NOT forget remove leading `0`\\'s, and return `0` if the result are all`0`\\'s.\\n\\n```java\\n    public String multiply(String num1, String num2) {\\n        int m = num1.length();\\n        int n = num2.length();\\n        int[] prod = new int[m + n];\\n        for (int i = m - 1; i >= 0; --i) {\\n            int a = num1.charAt(i) - \\'0\\';\\n            for (int j = n - 1; j >= 0; --j) {\\n                int b = num2.charAt(j) - \\'0\\';\\n                prod[i + j + 1] += a * b;\\n                prod[i + j] += prod[i + j + 1] / 10;\\n                prod[i + j + 1] %= 10;\\n            }\\n        }\\n        StringBuilder sb = new StringBuilder();\\n        for (int p : prod) {\\n            if (sb.length() > 0 || p > 0) {\\n                sb.append(p);\\n            }\\n        }\\n        return sb.length() == 0 ? \"0\" : sb.toString();\\n    }\\n```\\n\\n```python\\n    def multiply(self, num1: str, num2: str) -> str:\\n        m, n = map(len, (num1, num2))\\n        prod = [0] * (m + n)\\n        for i, a in enumerate(reversed(num1)): \\n            for j, b in enumerate(reversed(num2)): \\n                prod[i + j] += int(a) * int(b)\\n                prod[i + j + 1] += prod[i + j] // 10\\n                prod[i + j] %= 10\\n        while len(prod) > 1 and prod[-1] == 0:\\n            prod.pop()\\n        return \\'\\'.join(map(str, prod[:: -1]))\\n```\\n\\n<strong>Analysis</strong>\\nTime: `O(m * n)`, space: `O(m + n)`, where `m = num1.length(), n = num2.length()`.\\n",
                "solutionTags": [],
                "code": "```java\\n    public String multiply(String num1, String num2) {\\n        int m = num1.length();\\n        int n = num2.length();\\n        int[] prod = new int[m + n];\\n        for (int i = m - 1; i >= 0; --i) {\\n            int a = num1.charAt(i) - \\'0\\';\\n            for (int j = n - 1; j >= 0; --j) {\\n                int b = num2.charAt(j) - \\'0\\';\\n                prod[i + j + 1] += a * b;\\n                prod[i + j] += prod[i + j + 1] / 10;\\n                prod[i + j + 1] %= 10;\\n            }\\n        }\\n        StringBuilder sb = new StringBuilder();\\n        for (int p : prod) {\\n            if (sb.length() > 0 || p > 0) {\\n                sb.append(p);\\n            }\\n        }\\n        return sb.length() == 0 ? \"0\" : sb.toString();\\n    }\\n```\n```python\\n    def multiply(self, num1: str, num2: str) -> str:\\n        m, n = map(len, (num1, num2))\\n        prod = [0] * (m + n)\\n        for i, a in enumerate(reversed(num1)): \\n            for j, b in enumerate(reversed(num2)): \\n                prod[i + j] += int(a) * int(b)\\n                prod[i + j + 1] += prod[i + j] // 10\\n                prod[i + j] %= 10\\n        while len(prod) > 1 and prod[-1] == 0:\\n            prod.pop()\\n        return \\'\\'.join(map(str, prod[:: -1]))\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1476451,
                "title": "simple-c-solution-faster-than-95-with-proper-comments-dry-run-beginner-friendly",
                "content": "**Link for Dryrun**\\nhttps://www.linkpicture.com/q/WhatsApp-Image-2021-09-25-at-1.58.33-PM.jpeg\\n\\n```\\nclass Solution {\\npublic:\\n    string multiply(string s1, string s2) {\\n        \\n        if(s1==\"0\" || s2==\"0\") //if any of the two strings is zero then multiplication will be zero\\n            return \"0\";\\n        int n=s1.length();\\n        int m=s2.length();\\n          vector<int> ans(m+n, 0);\\n        \\n        for(int j=m-1;j>=0;j--)\\n        {\\n            for(int i=n-1;i>=0;i--)\\n            {\\n               \\n                 ans[i+j+1]+=(s2[j]-\\'0\\')*(s1[i]-\\'0\\');// doing s2[j]-\\'0\\' to convert char to int\\n                \\n            //Adding the previous number present at ans[i+j+1] with multiplication of two string \\n             //if carry is generated it will be resolved in the below k loop\\n            \\n            }\\n            \\n            //now ans[i] can max contain double digit number(as 9*9 is 81) so now we are taking the carry out and adding it to ans[i-1]\\n            // eg-[81,81,81]----->[8,9,9,1]\\n            for(int k=ans.size()-1;k>0;k--)\\n            {\\n                int num=ans[k];\\n                \\n                ans[k]=num%10; // i and j are starting from end so numbers in ans will be alloted from last \\n                                //digit will be on right( one position ahead) and carry will be on left(one position less)                                                         // so that carry is added in further calculation\\n                \\n                ans[k-1]+=num/10;   //carry at given position\\n            }\\n        }\\n        \\n       int i=0;\\n        while(i<ans.size()&&ans[i]==0) //remove the starting zeroes\\n            i++;\\n        \\n        string res;\\n        while(i<ans.size())  {  //convert vector to string\\n            res+=(ans[i]+\\'0\\');\\n            i++;\\n        }\\n        return res;\\n    }\\n};\\n```\\nplease upvote if you like my solution",
                "solutionTags": [
                    "C++",
                    "C",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string multiply(string s1, string s2) {\\n        \\n        if(s1==\"0\" || s2==\"0\") //if any of the two strings is zero then multiplication will be zero\\n            return \"0\";\\n        int n=s1.length();\\n        int m=s2.length();\\n          vector<int> ans(m+n, 0);\\n        \\n        for(int j=m-1;j>=0;j--)\\n        {\\n            for(int i=n-1;i>=0;i--)\\n            {\\n               \\n                 ans[i+j+1]+=(s2[j]-\\'0\\')*(s1[i]-\\'0\\');// doing s2[j]-\\'0\\' to convert char to int\\n                \\n            //Adding the previous number present at ans[i+j+1] with multiplication of two string \\n             //if carry is generated it will be resolved in the below k loop\\n            \\n            }\\n            \\n            //now ans[i] can max contain double digit number(as 9*9 is 81) so now we are taking the carry out and adding it to ans[i-1]\\n            // eg-[81,81,81]----->[8,9,9,1]\\n            for(int k=ans.size()-1;k>0;k--)\\n            {\\n                int num=ans[k];\\n                \\n                ans[k]=num%10; // i and j are starting from end so numbers in ans will be alloted from last \\n                                //digit will be on right( one position ahead) and carry will be on left(one position less)                                                         // so that carry is added in further calculation\\n                \\n                ans[k-1]+=num/10;   //carry at given position\\n            }\\n        }\\n        \\n       int i=0;\\n        while(i<ans.size()&&ans[i]==0) //remove the starting zeroes\\n            i++;\\n        \\n        string res;\\n        while(i<ans.size())  {  //convert vector to string\\n            res+=(ans[i]+\\'0\\');\\n            i++;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 17729,
                "title": "simple-logic-short-code-c",
                "content": "    class Solution {\\n    public:\\n        string multiply(string num1, string num2) {\\n            int len1=num1.length(), len2=num2.length();\\n            if ( (len1==1 && num1==\"0\") || (len2==1 && num2==\"0\"))\\n                return \"0\";\\n            int *ans = new int[len1+len2], k=0;\\n            memset(ans, 0, (len1+len2)*sizeof(int));\\n            \\n            for (int i=len1-1; i>=0; i--)\\n                for (int j=len2-1; j>=0; j--)\\n                    ans[len1-1-i + len2-1-j] += (num1[i]-'0')*(num2[j]-'0');\\n    \\n            for (int i=0; i<len1+len2-1; i++)\\n                ans[i+1] += ans[i]/10, ans[i] %= 10;\\n                \\n            string ret;\\n            for (int i=len1+len2-1; i>=0; i--)\\n                ret += to_string(ans[i]);\\n            \\n            while (k<ret.length() && ret[k]=='0') k++;\\n            return ret.substr(k, ret.length()-k);\\n                \\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        string multiply(string num1, string num2) {\\n            int len1=num1.length(), len2=num2.length();\\n            if ( (len1==1 && num1==\"0\") || (len2==1 && num2==\"0\"))\\n                return \"0\";\\n            int *ans = new int[len1+len2], k=0;\\n            memset(ans, 0, (len1+len2)*sizeof(int));\\n            \\n            for (int i=len1-1; i>=0; i--)\\n                for (int j=len2-1; j>=0; j--)\\n                    ans[len1-1-i + len2-1-j] += (num1[i]-'0')*(num2[j]-'0');\\n    \\n            for (int i=0; i<len1+len2-1; i++)\\n                ans[i+1] += ans[i]/10, ans[i] %= 10;\\n                \\n            string ret;\\n            for (int i=len1+len2-1; i>=0; i--)\\n                ret += to_string(ans[i]);\\n            \\n            while (k<ret.length() && ret[k]=='0') k++;\\n            return ret.substr(k, ret.length()-k);\\n                \\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3954455,
                "title": "beats-100-explained-c-clean-code-no-built-in-function",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n- It\\'s the generic way for solving these type of problems.\\n- Few questions to ask from interviewer or should observe:\\n  - Can string be negative?\\n  - Can any of the string be zero? (base case)\\n  - The maximum length of strings\\n---------\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- The base case handling (if any of string is zero, simply return zero)\\n- Check whether string are negative or not, store the first characters if negative (firstChar = \\'-\\') \\n- If both negative, initialize both the string as empty string.\\n---\\n**Why we are doing this**?\\n     Beacause we need to return our result as a string, so to store the sign if any of the string is negative the answer should carry the sign \\'-\\' at beginning.\\n\\n---\\n- Now just like we had seen how to multiply linkedLists and arrays, maths are exactly same here.\\n- At last we need to add (s1n + s2n) to the result, for adding the sign of result.\\n\\n# Complexity\\n- Time complexity: O(s1.size()*s2.size())\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(s1.size() + s2.size())\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string multiply(string s1, string s2) {\\n        if (s1 == \"0\" || s2 == \"0\") return \"0\";\\n        string s1n =\"\";\\n        string s2n =\"\";\\n\\n        if(s1[0] == \\'-\\'){\\n            s1n =\"-\"; s1 = s1.substr(1);\\n        }\\n        if(s2[0] == \\'-\\'){\\n            s2n = \"-\"; s2 = s2.substr(1);\\n        }\\n\\n        // if both negative just empty the string\\n        if(s2n == \"-\" && s1n == \"-\") s1n=s2n=\"\";\\n        \\n        int n = s1.size();\\n        int m = s2.size();\\n        string res(n+m,\\'0\\');\\n        \\n        for(int i=n-1; i>=0; i--){\\n            for(int j=m-1; j>=0; j--){                \\n                int num = (s1[i]-\\'0\\') * (s2[j]-\\'0\\') + (res[i+j+1]-\\'0\\'); // res will store carry\\n                res[i+j+1] = num % 10 + \\'0\\';\\n                res[i+j] += num / 10; // carry\\n                \\n            }\\n        }\\n        \\n        int i=0;\\n        while(i < res.size() && res[i] == \\'0\\') i++;\\n        return s1n + s2n + res.substr(i);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string multiply(string s1, string s2) {\\n        if (s1 == \"0\" || s2 == \"0\") return \"0\";\\n        string s1n =\"\";\\n        string s2n =\"\";\\n\\n        if(s1[0] == \\'-\\'){\\n            s1n =\"-\"; s1 = s1.substr(1);\\n        }\\n        if(s2[0] == \\'-\\'){\\n            s2n = \"-\"; s2 = s2.substr(1);\\n        }\\n\\n        // if both negative just empty the string\\n        if(s2n == \"-\" && s1n == \"-\") s1n=s2n=\"\";\\n        \\n        int n = s1.size();\\n        int m = s2.size();\\n        string res(n+m,\\'0\\');\\n        \\n        for(int i=n-1; i>=0; i--){\\n            for(int j=m-1; j>=0; j--){                \\n                int num = (s1[i]-\\'0\\') * (s2[j]-\\'0\\') + (res[i+j+1]-\\'0\\'); // res will store carry\\n                res[i+j+1] = num % 10 + \\'0\\';\\n                res[i+j] += num / 10; // carry\\n                \\n            }\\n        }\\n        \\n        int i=0;\\n        while(i < res.size() && res[i] == \\'0\\') i++;\\n        return s1n + s2n + res.substr(i);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1068979,
                "title": "python-short-solution",
                "content": "Didn\\'t see anyone write this simple solution, so here it is : )\\n``` \\nclass Solution:\\n    def multiply(self, num1: str, num2: str) -> str:\\n        \\n        if num1 == \\'0\\' or num2 == \\'0\\': return \\'0\\'\\n        \\n        #multiply each digit of num1 with the digit of num2 being sent in the arg\\n        def multiply(num1, x):\\n            s=0\\n            for n in num1:\\n                s=s*10 + (ord(n)-ord(\\'0\\'))*(ord(x)-ord(\\'0\\'))\\n            return s\\n        \\n        ans = 0\\n\\t\\t#loop over each digit of num2 and call multiply function\\n        for c in num2:\\n            ans = ans*10 + multiply(num1,c)\\n        return str(ans)\\n\\t\\t",
                "solutionTags": [],
                "code": "Didn\\'t see anyone write this simple solution, so here it is : )\\n``` \\nclass Solution:\\n    def multiply(self, num1: str, num2: str) -> str:\\n        \\n        if num1 == \\'0\\' or num2 == \\'0\\': return \\'0\\'\\n        \\n        #multiply each digit of num1 with the digit of num2 being sent in the arg\\n        def multiply(num1, x):\\n            s=0\\n            for n in num1:\\n                s=s*10 + (ord(n)-ord(\\'0\\'))*(ord(x)-ord(\\'0\\'))\\n            return s\\n        \\n        ans = 0\\n\\t\\t#loop over each digit of num2 and call multiply function\\n        for c in num2:\\n            ans = ans*10 + multiply(num1,c)\\n        return str(ans)\\n\\t\\t",
                "codeTag": "Java"
            },
            {
                "id": 17790,
                "title": "my-c-accepted-solution-with-o-m-n-time",
                "content": "    class Solution {\\n    public:\\n        string multiply(string num1, string num2) {\\n            string res;\\n            int m = num1.length();\\n            int n = num2.length();\\n            int dp[m+n];\\n            memset(dp,0,sizeof(dp));\\n            for ( int i = m-1; i >= 0; i-- ) {\\n                for ( int j = n-1; j >= 0; j-- ) {\\n\\n                    dp[m+n-i-j-2] += (num1[i]-'0')*(num2[j]-'0');\\n                    dp[m+n-i-j-1] += dp[m+n-i-j-2]/10;\\n                    dp[m+n-i-j-2] %= 10;\\n                    \\n                }\\n            }\\n            for ( int i = m+n-1; i >= 0; i-- ) {\\n                if ( dp[i] != 0 ) {\\n                    for ( int j = i; j >= 0; j-- )\\n                        res += (dp[j]+'0');\\n                    return res;\\n                }\\n            }\\n            return \"0\";\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        string multiply(string num1, string num2) {\\n            string res;\\n            int m = num1.length();\\n            int n = num2.length();\\n            int dp[m+n];\\n            memset(dp,0,sizeof(dp));\\n            for ( int i = m-1; i >= 0; i-- ) {\\n                for ( int j = n-1; j >= 0; j-- ) {\\n\\n                    dp[m+n-i-j-2] += (num1[i]-'0')*(num2[j]-'0');\\n                    dp[m+n-i-j-1] += dp[m+n-i-j-2]/10;\\n                    dp[m+n-i-j-2] %= 10;\\n                    \\n                }",
                "codeTag": "Java"
            },
            {
                "id": 3050508,
                "title": "python-not-using-str-or-int",
                "content": "https://leetcode.com/submissions/detail/878047053/  \\nRuntime: **46 ms**, faster than 71.41% of Python3 online submissions for Multiply Strings.   \\nMemory Usage: 13.8 MB, less than 69.53% of Python3 online submissions for Multiply Strings.  \\n```\\nclass Solution:\\n    def multiply(self, num1: str, num2: str) -> str:\\n        d1 = {\\'0\\':0, \\'1\\':1, \\'2\\':2, \\'3\\':3, \\'4\\':4, \\'5\\':5, \\'6\\':6, \\'7\\':7, \\'8\\':8, \\'9\\':9}\\n        d2 = {v:k for k,v in d1.items()}\\n        n1 = sum([d1[c]*(10**i) for i,c in enumerate(num1[::-1])])\\n        n2 = sum([d1[c]*(10**i) for i,c in enumerate(num2[::-1])])\\n        n3, s = n1*n2, \\'\\'\\n        while n3:\\n            s = d2[n3%10] + s\\n            n3 = n3//10\\n        return s if s else \\'0\\'\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def multiply(self, num1: str, num2: str) -> str:\\n        d1 = {\\'0\\':0, \\'1\\':1, \\'2\\':2, \\'3\\':3, \\'4\\':4, \\'5\\':5, \\'6\\':6, \\'7\\':7, \\'8\\':8, \\'9\\':9}\\n        d2 = {v:k for k,v in d1.items()}\\n        n1 = sum([d1[c]*(10**i) for i,c in enumerate(num1[::-1])])\\n        n2 = sum([d1[c]*(10**i) for i,c in enumerate(num2[::-1])])\\n        n3, s = n1*n2, \\'\\'\\n        while n3:\\n            s = d2[n3%10] + s\\n            n3 = n3//10\\n        return s if s else \\'0\\'\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2410553,
                "title": "sutra-rdhva-tiryagbhy-solution-o-length-of-string-2-complexity",
                "content": "**Read About the algorithm here-**\\nhttps://www.upavidhi.com/sutra/urdhva-tiryagbhyam \\n```\\nclass Solution {\\npublic:\\n    void makeLengthEqual(string & a,string &b){\\n        if(a.size()==b.size())\\n            return;\\n        if(a.size()<b.size()){\\n            makeLengthEqual(b,a);\\n            return;\\n        }\\n        while(b.size()!=a.size()){\\n            b=\"0\"+b;\\n        }\\n    }\\n    void removeLeadingZero(string &num){\\n        int n=num.size()-1;\\n        for(int i=0;i<num.size()-1;i++){\\n            if(num[i]!=\\'0\\'){\\n                n=i;\\n                break;\\n            }\\n        }\\n        num=num.substr(n);\\n    }\\n    string multiply(string num1, string num2) {\\n        makeLengthEqual(num1,num2);\\n        int n=num1.size();\\n        int carry=0;\\n        string ans=\"\";\\n        for(int i=n-1;i>=0;i--){\\n            int sum=0;\\n            int k=i;\\n            for(int j=n-1;j>=i;j--){\\n                sum+=(num1[j]-\\'0\\')*(num2[k]-\\'0\\');\\n                k++;\\n            }\\n            sum+=carry;\\n            carry=sum/10;\\n            ans+=(\\'0\\'+(sum%10));\\n        }\\n        for(int i=n-2;i>=0;i--){\\n            int sum=0;\\n            int k=0;\\n            for(int j=i;j>=0;j--){\\n                sum+=(num1[j]-\\'0\\')*(num2[k]-\\'0\\');\\n                k++;\\n            }\\n            sum+=carry;\\n            carry=sum/10;\\n            ans+=(\\'0\\'+(sum%10));\\n        }\\n        if(carry)\\n            ans+=(\\'0\\'+carry);\\n        reverse(ans.begin(),ans.end());\\n        removeLeadingZero(ans);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    void makeLengthEqual(string & a,string &b){\\n        if(a.size()==b.size())\\n            return;\\n        if(a.size()<b.size()){\\n            makeLengthEqual(b,a);\\n            return;\\n        }\\n        while(b.size()!=a.size()){\\n            b=\"0\"+b;\\n        }\\n    }\\n    void removeLeadingZero(string &num){\\n        int n=num.size()-1;\\n        for(int i=0;i<num.size()-1;i++){\\n            if(num[i]!=\\'0\\'){\\n                n=i;\\n                break;\\n            }\\n        }\\n        num=num.substr(n);\\n    }\\n    string multiply(string num1, string num2) {\\n        makeLengthEqual(num1,num2);\\n        int n=num1.size();\\n        int carry=0;\\n        string ans=\"\";\\n        for(int i=n-1;i>=0;i--){\\n            int sum=0;\\n            int k=i;\\n            for(int j=n-1;j>=i;j--){\\n                sum+=(num1[j]-\\'0\\')*(num2[k]-\\'0\\');\\n                k++;\\n            }\\n            sum+=carry;\\n            carry=sum/10;\\n            ans+=(\\'0\\'+(sum%10));\\n        }\\n        for(int i=n-2;i>=0;i--){\\n            int sum=0;\\n            int k=0;\\n            for(int j=i;j>=0;j--){\\n                sum+=(num1[j]-\\'0\\')*(num2[k]-\\'0\\');\\n                k++;\\n            }\\n            sum+=carry;\\n            carry=sum/10;\\n            ans+=(\\'0\\'+(sum%10));\\n        }\\n        if(carry)\\n            ans+=(\\'0\\'+carry);\\n        reverse(ans.begin(),ans.end());\\n        removeLeadingZero(ans);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1664733,
                "title": "c-solution",
                "content": "```\\nchar * multiply(char * num1, char * num2){\\n    if(num1[0]==\\'0\\' || num2[0]==\\'0\\') return \"0\";\\n    int n,m;\\n    n = strlen(num1);\\n    m = strlen(num2);\\n    char* ans = (char*)calloc(n+m+1,sizeof(char));\\n    for(int i=0 ; i<n ; i++){\\n        for(int j=0 ; j<m ; j++){\\n            int k = i+j+1;\\n            int mul = (num1[i]-\\'0\\') * (num2[j]-\\'0\\');\\n            while(mul){\\n                mul += ans[k];\\n                ans[k] = (mul)%10;\\n                mul = mul/10;\\n                k--;\\n            }\\n        }\\n    }\\n    for(int i=0 ; i<m+n ; i++){\\n        ans[i] += \\'0\\';\\n    }\\n    if(ans[0]==\\'0\\') return ans+1;\\n    return ans;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nchar * multiply(char * num1, char * num2){\\n    if(num1[0]==\\'0\\' || num2[0]==\\'0\\') return \"0\";\\n    int n,m;\\n    n = strlen(num1);\\n    m = strlen(num2);\\n    char* ans = (char*)calloc(n+m+1,sizeof(char));\\n    for(int i=0 ; i<n ; i++){\\n        for(int j=0 ; j<m ; j++){\\n            int k = i+j+1;\\n            int mul = (num1[i]-\\'0\\') * (num2[j]-\\'0\\');\\n            while(mul){\\n                mul += ans[k];\\n                ans[k] = (mul)%10;\\n                mul = mul/10;\\n                k--;\\n            }\\n        }\\n    }\\n    for(int i=0 ; i<m+n ; i++){\\n        ans[i] += \\'0\\';\\n    }\\n    if(ans[0]==\\'0\\') return ans+1;\\n    return ans;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1491395,
                "title": "python-solution-without-using-int",
                "content": "```\\nclass Solution:\\n    def multiply(self, num1: str, num2: str) -> str:\\n        ans =0\\n        l1 = len(num1)\\n        l2 = len(num2)\\n        \\n        for i in range(l1):\\n            m = 10**i\\n            for j in range(l2):\\n                ans+=(ord(num1[l1-1-i])-ord(\\'0\\'))*(ord(num2[l2-1-j])-ord(\\'0\\'))*m\\n                m*=10\\n            \\n        return str(ans)\\n",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def multiply(self, num1: str, num2: str) -> str:\\n        ans =0\\n        l1 = len(num1)\\n        l2 = len(num2)\\n        \\n        for i in range(l1):\\n            m = 10**i\\n            for j in range(l2):\\n                ans+=(ord(num1[l1-1-i])-ord(\\'0\\'))*(ord(num2[l2-1-j])-ord(\\'0\\'))*m\\n                m*=10\\n            \\n        return str(ans)\\n",
                "codeTag": "Java"
            },
            {
                "id": 802641,
                "title": "javascript-clean-solution",
                "content": "```javascript\\nvar multiply = function(num1, num2) {\\n    if(!+num1 || !+num2) return \\'0\\'\\n    const prod = Array(num1.length + num2.length).fill(0);\\n    let currIdx = prod.length-1;\\n    \\n    for(let i = num1.length-1; i >= 0; i--) {\\n        let idx = currIdx--;\\n        \\n        for(let j = num2.length-1; j >= 0; j--) {\\n            const res = +num1[i] * +num2[j] + prod[idx];\\n            prod[idx] = res % 10;\\n            prod[--idx] += Math.floor(res / 10);\\n        }\\n    }\\n    return prod.join(\\'\\').replace(/^0+/, \\'\\')\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```javascript\\nvar multiply = function(num1, num2) {\\n    if(!+num1 || !+num2) return \\'0\\'\\n    const prod = Array(num1.length + num2.length).fill(0);\\n    let currIdx = prod.length-1;\\n    \\n    for(let i = num1.length-1; i >= 0; i--) {\\n        let idx = currIdx--;\\n        \\n        for(let j = num2.length-1; j >= 0; j--) {\\n            const res = +num1[i] * +num2[j] + prod[idx];\\n            prod[idx] = res % 10;\\n            prod[--idx] += Math.floor(res / 10);\\n        }\\n    }\\n    return prod.join(\\'\\').replace(/^0+/, \\'\\')\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 17621,
                "title": "super-simple-python-10-lines-of-code",
                "content": "```\\n    def multiply(self, num1, num2):\\n        res = 0\\n        carry1 = 1\\n        for n1 in num1[::-1]:\\n            carry2 = 1\\n            for n2 in num2[::-1]:\\n                res += int(n1)*int(n2)*carry1*carry2\\n                carry2 *= 10\\n            carry1 *= 10\\n        return str(res)\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\n    def multiply(self, num1, num2):\\n        res = 0\\n        carry1 = 1\\n        for n1 in num1[::-1]:\\n            carry2 = 1\\n            for n2 in num2[::-1]:\\n                res += int(n1)*int(n2)*carry1*carry2\\n                carry2 *= 10\\n            carry1 *= 10\\n        return str(res)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2802841,
                "title": "python-simple-python-solution",
                "content": "```\\nclass Solution:\\n    def multiply(self, num1: str, num2: str) -> str:\\n        num = {\\'0\\':0, \\'1\\':1, \\'2\\':2, \\'3\\':3, \\'4\\':4, \\'5\\':5, \\'6\\':6, \\'7\\':7, \\'8\\':8, \\'9\\':9}\\n        r1=0\\n        r2=0\\n        \\n        for i in num1:\\n            r1=10*r1+num[i]\\n        for j in num2:\\n            r2=10*r2+num[j]\\n            \\n        return str(r1*r2)\\n            \\n            \\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def multiply(self, num1: str, num2: str) -> str:\\n        num = {\\'0\\':0, \\'1\\':1, \\'2\\':2, \\'3\\':3, \\'4\\':4, \\'5\\':5, \\'6\\':6, \\'7\\':7, \\'8\\':8, \\'9\\':9}\\n        r1=0\\n        r2=0\\n        \\n        for i in num1:\\n            r1=10*r1+num[i]\\n        for j in num2:\\n            r2=10*r2+num[j]\\n            \\n        return str(r1*r2)\\n            \\n            \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2500556,
                "title": "java-easy-solution-using-biginteger",
                "content": "```\\nimport java.math.*;\\nclass Solution {\\n    public String multiply(String num1, String num2) {       \\n       BigInteger b = new BigInteger(num1);\\n        BigInteger c = new BigInteger(num2);\\n\\n        BigInteger a = b.multiply(c);\\n\\n        String m = a.toString();\\n        return m;\\n    }\\n}\\n```\\n# PLEASE UPVOTE IF IT WAS HELPFULL",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "```\\nimport java.math.*;\\nclass Solution {\\n    public String multiply(String num1, String num2) {       \\n       BigInteger b = new BigInteger(num1);\\n        BigInteger c = new BigInteger(num2);\\n\\n        BigInteger a = b.multiply(c);\\n\\n        String m = a.toString();\\n        return m;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1440027,
                "title": "easy-python-solution-99-97",
                "content": "Runtime: 16 ms, faster than 99.97% of Python3 online submissions for Multiply Strings.\\nMemory Usage: 14.3 MB, less than 56.72% of Python3 online submissions for Multiply Strings.\\n```\\nclass Solution:\\n    def multiply(self, num1: str, num2: str) -> str:\\n        return str(self.strint(num1)*self.strint(num2))\\n    def strint(self,n):\\n        result=0\\n        for i in range(len(n)):\\n            result = result*10 + ord(n[i])-ord(\\'0\\')\\n        return result",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "Runtime: 16 ms, faster than 99.97% of Python3 online submissions for Multiply Strings.\\nMemory Usage: 14.3 MB, less than 56.72% of Python3 online submissions for Multiply Strings.\\n```\\nclass Solution:\\n    def multiply(self, num1: str, num2: str) -> str:\\n        return str(self.strint(num1)*self.strint(num2))\\n    def strint(self,n):\\n        result=0\\n        for i in range(len(n)):\\n            result = result*10 + ord(n[i])-ord(\\'0\\')\\n        return result",
                "codeTag": "Java"
            },
            {
                "id": 1106393,
                "title": "c-simple-solution",
                "content": "\\n```\\nclass Solution {\\n public :\\n     string multiply( string num1, string num2) {\\n         \\n         string finalstring = \"\" ;\\n         int m = num1.size(), n = num2.size();\\n       \\n        vector <int> res(m + n);\\n         \\n         for ( int i = m- 1 ; i >= 0 ;  i--) {\\n             for ( int j = n- 1 ; j >= 0 ; j--) {\\n                 \\n                 int mul = (num1[i]- \\'0\\' ) * (num2[j]-  \\'0\\' );\\n                 \\n                 int p1 = i + j;\\n                 int p2 = i + j + 1 ;\\n                \\n                 int sum = mul + res[p2];\\n                 \\n                 res[p1] += sum/10;   \\n                 res[p2] = sum% 10;   \\n            }\\n        }\\n         \\n        for (int num: res) {\\n            \\n             char ch=num+\\'0\\'; \\n             if((finalstring.empty()==false && num==0) || num!=0){\\n                 finalstring+=ch;   \\n             }\\n              \\n             //if finalstring is empty then we shouldn\\'t add 0 at start  //04 wrong\\n             //But if it is not empty then we can add 0                  //40 right\\n            \\n        }\\n        return finalstring.empty()? \"0\" : finalstring;\\n    }\\n};\\n\\n```\\n\\n<img src=\"https://assets.leetcode.com/users/images/7e5c8e78-66c0-4484-adb6-e43e7051a9c5_1616863454.6051788.jpeg\" width=\"300\">\\n``\\n\\n``\\n\\n<img src=\"https://assets.leetcode.com/users/images/5f3a3bf5-1489-4baa-9942-3805b48d85b7_1616863725.9810803.jpeg\" width=\"300\">\\n\\n\\n\\n",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\n public :\\n     string multiply( string num1, string num2) {\\n         \\n         string finalstring = \"\" ;\\n         int m = num1.size(), n = num2.size();\\n       \\n        vector <int> res(m + n);\\n         \\n         for ( int i = m- 1 ; i >= 0 ;  i--) {\\n             for ( int j = n- 1 ; j >= 0 ; j--) {\\n                 \\n                 int mul = (num1[i]- \\'0\\' ) * (num2[j]-  \\'0\\' );\\n                 \\n                 int p1 = i + j;\\n                 int p2 = i + j + 1 ;\\n                \\n                 int sum = mul + res[p2];\\n                 \\n                 res[p1] += sum/10;   \\n                 res[p2] = sum% 10;   \\n            }\\n        }\\n         \\n        for (int num: res) {\\n            \\n             char ch=num+\\'0\\'; \\n             if((finalstring.empty()==false && num==0) || num!=0){\\n                 finalstring+=ch;   \\n             }\\n              \\n             //if finalstring is empty then we shouldn\\'t add 0 at start  //04 wrong\\n             //But if it is not empty then we can add 0                  //40 right\\n            \\n        }\\n        return finalstring.empty()? \"0\" : finalstring;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 955438,
                "title": "c-using-stl-grade-school-standard-multiplication-algorithm-easy-to-understand-code",
                "content": "Even though this algorithm is not efficient, it is easy to implement. \\nStrangely, it also performed better than 89% of C++ submissions.\\nSample multiplication given below for reference.\\n![image](https://assets.leetcode.com/users/images/f08ff250-b978-4eab-835b-4895485ba299_1606837718.0619273.png)\\n\\n\\n\\n\\n```\\nclass Solution {\\npublic:\\n    string multiply(string num1, string num2)\\n    {\\n        string str_result;\\n        int len_num1 = num1.length(), len_num2 = num2.length(), i, j;\\n        vector<int8_t> result(len_num1 + len_num2, 0);\\n        int i_multipliar, i_carry = 0, i_multiplicand = 0;\\n\\n        for (i = num2.length() - 1; i >= 0; i--)\\n        {\\n            i_multipliar = num2[i] - \\'0\\';\\n            for (j = num1.length() - 1; j >= 0; j--)\\n            {\\n                i_multiplicand = num1[j] - \\'0\\';\\n\\t\\t\\t\\t//compute new product from multipliar, multiplicand and previous partial product\\n                i_carry = i_multiplicand * i_multipliar + i_carry + result[j + i + 1]; \\n                result[j + i + 1] = i_carry % 10;\\n                i_carry = i_carry / 10;\\n            }\\n            if (i_carry > 0)\\n                result[i + j + 1] = i_carry;\\n            i_carry = 0;\\n        }\\n        \\n        while (result[0] == 0 && result.size() > 1)\\n            result.erase(result.begin());\\n\\n        for (i = 0; i < result.size(); i++)\\n        {\\n            str_result += \\'0\\' + result[i];\\n        }\\n        \\n        return str_result;\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string multiply(string num1, string num2)\\n    {\\n        string str_result;\\n        int len_num1 = num1.length(), len_num2 = num2.length(), i, j;\\n        vector<int8_t> result(len_num1 + len_num2, 0);\\n        int i_multipliar, i_carry = 0, i_multiplicand = 0;\\n\\n        for (i = num2.length() - 1; i >= 0; i--)\\n        {\\n            i_multipliar = num2[i] - \\'0\\';\\n            for (j = num1.length() - 1; j >= 0; j--)\\n            {\\n                i_multiplicand = num1[j] - \\'0\\';\\n\\t\\t\\t\\t//compute new product from multipliar, multiplicand and previous partial product\\n                i_carry = i_multiplicand * i_multipliar + i_carry + result[j + i + 1]; \\n                result[j + i + 1] = i_carry % 10;\\n                i_carry = i_carry / 10;\\n            }\\n            if (i_carry > 0)\\n                result[i + j + 1] = i_carry;\\n            i_carry = 0;\\n        }\\n        \\n        while (result[0] == 0 && result.size() > 1)\\n            result.erase(result.begin());\\n\\n        for (i = 0; i < result.size(); i++)\\n        {\\n            str_result += \\'0\\' + result[i];\\n        }\\n        \\n        return str_result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 17709,
                "title": "7ms-java-solution-with-comment",
                "content": "    public String multiply(String num1, String num2) {\\n        char[] str1 = num1.toCharArray();\\n        char[] str2 = num2.toCharArray();\\n        if (str1[0] == '0' || str2[0] == '0') return \"0\";\\n        int[] d = new int[str1.length + str2.length];//digits\\n        for (int j = str2.length - 1; j >= 0; j--){//str2\\n            for (int i = str1.length - 1; i >= 0; i--){//str1\\n                int n = (str1[i] - '0') * (str2[j] - '0');\\n                // for each i,j, its multiplication contributes to d[i + j + 1] and d[i + j]\\n                d[i + j] += n / 10;//carry\\n                d[i + j + 1] += n % 10;//current digit\\n            }\\n        }\\n        for (int i = d.length - 1; i >= 1; i--){\\n            //rearrange the output\\n            d[i - 1] += d[i] / 10;//carry\\n            d[i] = d[i] % 10 + '0';//current digit\\n        }\\n        d[0] += '0';//don't forget the first digit\\n        int start = d[0] == '0'? 1 : 0;\\n        return new String(d, start, d.length - start);\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "    public String multiply(String num1, String num2) {\\n        char[] str1 = num1.toCharArray();\\n        char[] str2 = num2.toCharArray();\\n        if (str1[0] == '0' || str2[0] == '0') return \"0\";\\n        int[] d = new int[str1.length + str2.length];//digits\\n        for (int j = str2.length - 1; j >= 0; j--){//str2\\n            for (int i = str1.length - 1; i >= 0; i--){//str1\\n                int n = (str1[i] - '0') * (str2[j] - '0');\\n                // for each i,j, its multiplication contributes to d[i + j + 1] and d[i + j]\\n                d[i + j] += n / 10;//carry\\n                d[i + j + 1] += n % 10;//current digit\\n            }\\n        }\\n        for (int i = d.length - 1; i >= 1; i--){\\n            //rearrange the output\\n            d[i - 1] += d[i] / 10;//carry\\n            d[i] = d[i] % 10 + '0';//current digit\\n        }\\n        d[0] += '0';//don't forget the first digit\\n        int start = d[0] == '0'? 1 : 0;\\n        return new String(d, start, d.length - start);\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1944468,
                "title": "simple-c-solution-easy-100-runtime",
                "content": "```\\nclass Solution {\\npublic:\\n    string multiply(string num1, string num2) {\\n        if(num1==\"0\"||num2==\"0\"){\\n            return \"0\";\\n        }\\n        vector<int>num(num1.size()+num2.size(),0);\\n        for(int i=num1.size()-1;i>=0;i--){\\n            for(int j=num2.size()-1;j>=0;j--){\\n                num[i+j+1] += (num1[i]-\\'0\\') * (num2[j]-\\'0\\');\\n                num[i+j] += num[i+j+1]/10;\\n                num[i+j+1] %=10;\\n            }\\n        }\\n        \\n        int i=0;\\n        while(i<num.size() && num[i]==0)++i;\\n        string res=\"\";\\n        while(i<num.size()){\\n            res.push_back(num[i] +\\'0\\');\\n            i++;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string multiply(string num1, string num2) {\\n        if(num1==\"0\"||num2==\"0\"){\\n            return \"0\";\\n        }\\n        vector<int>num(num1.size()+num2.size(),0);\\n        for(int i=num1.size()-1;i>=0;i--){\\n            for(int j=num2.size()-1;j>=0;j--){\\n                num[i+j+1] += (num1[i]-\\'0\\') * (num2[j]-\\'0\\');\\n                num[i+j] += num[i+j+1]/10;\\n                num[i+j+1] %=10;\\n            }\\n        }\\n        \\n        int i=0;\\n        while(i<num.size() && num[i]==0)++i;\\n        string res=\"\";\\n        while(i<num.size()){\\n            res.push_back(num[i] +\\'0\\');\\n            i++;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1534921,
                "title": "one-digit-at-a-time-simple-and-intuitive-solution-python-3-o-m-n-time",
                "content": "# Example\\nTo explain the idea of the algorithm, I want to give you an example and go with you through it. Let\\'s get started!\\n\\nLet\\'s imagine that ```num1 = 12``` and ```num2 = 34```. Now let\\'s break down the multiplication process into separated steps:\\n12 * 34 = (10 + 2) * (30 + 4) = (10 * 30 + 10 * 4) + (2 * 30 + 2 * 4) =\\n= ((1 * 3) * 10 + (1 * 4)) * 10 + ((2 * 3) * 10 + (2 * 4)) =\\n= 340 + 68 = 408\\n\\n---\\n\\n# Code\\n```\\nclass Solution:\\n    def multiply(self, num1: str, num2: str) -> str:\\n        totol = 0\\n        for n1 in num1:\\n            totol *= 10\\n            product = 0\\n            for n2 in num2:\\n                product = product * 10 + int(n1) * int(n2)\\n            totol += product\\n        \\n        return str(totol)\\n```\\n\\n---\\n# Complexity\\n**Time Complexity**: ```O(m * n)```\\n**Space Complexity**: ```O(1)```\\n\\n---\\n*If you like the solution and you think it can be helpful to anyone else please upvote. It will help others find the current thread easier and show your appreciation for the work I put in.* \\uD83D\\uDC4D",
                "solutionTags": [
                    "Python3",
                    "Math"
                ],
                "code": "```num1 = 12```\n```num2 = 34```\n```\\nclass Solution:\\n    def multiply(self, num1: str, num2: str) -> str:\\n        totol = 0\\n        for n1 in num1:\\n            totol *= 10\\n            product = 0\\n            for n2 in num2:\\n                product = product * 10 + int(n1) * int(n2)\\n            totol += product\\n        \\n        return str(totol)\\n```\n```O(m * n)```\n```O(1)```",
                "codeTag": "Java"
            },
            {
                "id": 1484348,
                "title": "python-simulate-clean-concise",
                "content": "**Idea**\\n- Just simulate the multiple formualte. \\n![image](https://assets.leetcode.com/users/images/b97aa9be-59fd-4393-8f25-b526ff023c80_1632544461.8781078.png)\\n\\n```python\\nclass Solution:\\n    def multiply(self, num1: str, num2: str) -> str:\\n        if num1 == \"0\" or num2 == \"0\": return \"0\"\\n        m, n = len(num1), len(num2)\\n        carry = 0\\n        product = []\\n        offsetPos = 0\\n        for i in range(n-1, -1, -1):  # nums2[i]\\n            for j in range(m-1, -1, -1):  # nums1[j]\\n                carry += int(num1[j]) * int(num2[i])\\n                pos = m-1-j + offsetPos\\n                if len(product) == pos:\\n                    product.append(carry % 10)\\n                else:\\n                    carry += product[pos]\\n                    product[pos] = carry % 10\\n                carry //= 10\\n            if carry > 0:\\n                product.append(carry)\\n                carry = 0\\n            offsetPos += 1\\n        return \"\".join(map(str, product[::-1]))\\n```\\nComplexity:\\n- Time: `O(M*N)`, where `M <= 200` is length of `num1`, `N <= 200` is length of `num2`.\\n- Space: `O(M + N)`",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def multiply(self, num1: str, num2: str) -> str:\\n        if num1 == \"0\" or num2 == \"0\": return \"0\"\\n        m, n = len(num1), len(num2)\\n        carry = 0\\n        product = []\\n        offsetPos = 0\\n        for i in range(n-1, -1, -1):  # nums2[i]\\n            for j in range(m-1, -1, -1):  # nums1[j]\\n                carry += int(num1[j]) * int(num2[i])\\n                pos = m-1-j + offsetPos\\n                if len(product) == pos:\\n                    product.append(carry % 10)\\n                else:\\n                    carry += product[pos]\\n                    product[pos] = carry % 10\\n                carry //= 10\\n            if carry > 0:\\n                product.append(carry)\\n                carry = 0\\n            offsetPos += 1\\n        return \"\".join(map(str, product[::-1]))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1206132,
                "title": "java-string-3ms-beats-90-t-c-o-len1-len2-s-c-o-len1-len2",
                "content": "\\n    // O(num1.length()*num2.length()) O(1)\\n\\t// String\\n\\tpublic String multiply(String num1, String num2) {\\n\\n\\t\\tif (num1.charAt(0) == \\'0\\' || num2.charAt(0) == \\'0\\')\\n\\t\\t\\treturn \"0\";\\n\\n\\t\\tint len1 = num1.length(), len2 = num2.length();\\n\\t\\tchar[] ans = new char[len1 + len2];\\n\\t\\tArrays.fill(ans, \\'0\\');\\n\\t\\tfor (int i = len1 - 1; i >= 0; i--) {\\n\\t\\t\\tint carry = 0;\\n\\t\\t\\tfor (int j = len2 - 1; j >= 0; j--) {\\n\\t\\t\\t\\tint prod = (num1.charAt(i) - \\'0\\') * (num2.charAt(j) - \\'0\\') + carry + (ans[i + j + 1] - \\'0\\');\\n\\t\\t\\t\\tint last = prod % 10;\\n\\t\\t\\t\\tans[i + j + 1] = (char) (last + \\'0\\');\\n\\t\\t\\t\\tcarry = prod / 10;\\n\\t\\t\\t}\\n\\t\\t\\tif (carry != 0)\\n\\t\\t\\t\\tans[i] = (char) (carry + \\'0\\');\\n\\t\\t}\\n\\n\\t\\tString res = new String(ans);\\n\\t\\tif (res.charAt(0) != \\'0\\')\\n\\t\\t\\treturn res;\\n\\t\\treturn res.substring(1);\\n\\t}",
                "solutionTags": [],
                "code": "\\n    // O(num1.length()*num2.length()) O(1)\\n\\t// String\\n\\tpublic String multiply(String num1, String num2) {\\n\\n\\t\\tif (num1.charAt(0) == \\'0\\' || num2.charAt(0) == \\'0\\')\\n\\t\\t\\treturn \"0\";\\n\\n\\t\\tint len1 = num1.length(), len2 = num2.length();\\n\\t\\tchar[] ans = new char[len1 + len2];\\n\\t\\tArrays.fill(ans, \\'0\\');\\n\\t\\tfor (int i = len1 - 1; i >= 0; i--) {\\n\\t\\t\\tint carry = 0;\\n\\t\\t\\tfor (int j = len2 - 1; j >= 0; j--) {\\n\\t\\t\\t\\tint prod = (num1.charAt(i) - \\'0\\') * (num2.charAt(j) - \\'0\\') + carry + (ans[i + j + 1] - \\'0\\');\\n\\t\\t\\t\\tint last = prod % 10;\\n\\t\\t\\t\\tans[i + j + 1] = (char) (last + \\'0\\');\\n\\t\\t\\t\\tcarry = prod / 10;\\n\\t\\t\\t}\\n\\t\\t\\tif (carry != 0)\\n\\t\\t\\t\\tans[i] = (char) (carry + \\'0\\');\\n\\t\\t}\\n\\n\\t\\tString res = new String(ans);\\n\\t\\tif (res.charAt(0) != \\'0\\')\\n\\t\\t\\treturn res;\\n\\t\\treturn res.substring(1);\\n\\t}",
                "codeTag": "Unknown"
            },
            {
                "id": 1152717,
                "title": "java-simple-solution",
                "content": "```java\\nclass Solution {\\n    public String multiply(String num1, String num2) {\\n        int len1 = num1.length(), len2 = num2.length();\\n        int[] prod = new int [len1 + len2];\\n        int currIdx = prod.length-1;\\n\\n        for(int i = len1-1; i >= 0; i--) {\\n            int idx = currIdx--;\\n\\n            for(int j = len2-1; j >= 0; j--) {\\n                int a = num1.charAt(i) - \\'0\\';\\n                int b = num2.charAt(j) - \\'0\\';\\n                int res = a * b + prod[idx];\\n                prod[idx] = res % 10;\\n                prod[--idx] += res / 10;\\n            }\\n        }\\n        \\n        StringBuilder sb = new StringBuilder();\\n        \\n        for(int num : prod) {\\n            if(num == 0 && sb.length() == 0) continue;\\n            sb.append(num);\\n        }\\n        if(sb.length() == 0) return \"0\";\\n        return sb.toString();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```java\\nclass Solution {\\n    public String multiply(String num1, String num2) {\\n        int len1 = num1.length(), len2 = num2.length();\\n        int[] prod = new int [len1 + len2];\\n        int currIdx = prod.length-1;\\n\\n        for(int i = len1-1; i >= 0; i--) {\\n            int idx = currIdx--;\\n\\n            for(int j = len2-1; j >= 0; j--) {\\n                int a = num1.charAt(i) - \\'0\\';\\n                int b = num2.charAt(j) - \\'0\\';\\n                int res = a * b + prod[idx];\\n                prod[idx] = res % 10;\\n                prod[--idx] += res / 10;\\n            }\\n        }\\n        \\n        StringBuilder sb = new StringBuilder();\\n        \\n        for(int num : prod) {\\n            if(num == 0 && sb.length() == 0) continue;\\n            sb.append(num);\\n        }\\n        if(sb.length() == 0) return \"0\";\\n        return sb.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1035182,
                "title": "java-o-n-m-3ms",
                "content": "```\\n// time: O(n * m)\\n// space O(n + m);\\nclass Solution {\\n    public String multiply(String num1, String num2) {\\n        if (num1.charAt(0) == \\'0\\' || num2.charAt(0) == \\'0\\') {\\n            return \"0\";\\n        }\\n        \\n        int len1 = num1.length();\\n        int len2 = num2.length();\\n        int[] memo = new int[len1 + len2];\\n\\t\\t// will fill from the right to left.\\n        int k = len1 + len2 - 1;\\n        for (int i = len1 - 1; i >= 0; i--) {\\n            int index = k;\\n            \\n            for (int j = len2 - 1; j >= 0; j--) {\\n                int a = num1.charAt(i) - \\'0\\';\\n                int b = num2.charAt(j) - \\'0\\';\\n                \\n                int c = a * b + memo[index];\\n                memo[index] = c % 10;\\n                if (index - 1 >= 0) {\\n                    memo[index - 1] += c / 10;\\n                }\\n                \\n                index -= 1;\\n            }\\n            k -= 1;\\n        }\\n\\n        // remove leading 0s\\n        int i = 0;\\n        while (memo[i] == 0) i += 1;\\n        \\n        StringBuilder sb = new StringBuilder();\\n        for (; i < len1 + len2; i++) {\\n            sb.append(memo[i]);\\n        }\\n        \\n        return sb.toString();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n// time: O(n * m)\\n// space O(n + m);\\nclass Solution {\\n    public String multiply(String num1, String num2) {\\n        if (num1.charAt(0) == \\'0\\' || num2.charAt(0) == \\'0\\') {\\n            return \"0\";\\n        }\\n        \\n        int len1 = num1.length();\\n        int len2 = num2.length();\\n        int[] memo = new int[len1 + len2];\\n\\t\\t// will fill from the right to left.\\n        int k = len1 + len2 - 1;\\n        for (int i = len1 - 1; i >= 0; i--) {\\n            int index = k;\\n            \\n            for (int j = len2 - 1; j >= 0; j--) {\\n                int a = num1.charAt(i) - \\'0\\';\\n                int b = num2.charAt(j) - \\'0\\';\\n                \\n                int c = a * b + memo[index];\\n                memo[index] = c % 10;\\n                if (index - 1 >= 0) {\\n                    memo[index - 1] += c / 10;\\n                }\\n                \\n                index -= 1;\\n            }\\n            k -= 1;\\n        }\\n\\n        // remove leading 0s\\n        int i = 0;\\n        while (memo[i] == 0) i += 1;\\n        \\n        StringBuilder sb = new StringBuilder();\\n        for (; i < len1 + len2; i++) {\\n            sb.append(memo[i]);\\n        }\\n        \\n        return sb.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 762851,
                "title": "java-simple-solution",
                "content": "```\\nclass Solution {\\n    public String multiply(String num1, String num2) {\\n        if (num1.equals(\"0\") || num2.equals(\"0\"))\\n            return \"0\";\\n        int size1 = num1.length(), size2 = num2.length();\\n        int[] res = new int[size1 + size2];\\n        for (int i = size1 - 1; i >= 0; --i){\\n            int x = Character.getNumericValue(num1.charAt(i));\\n            for (int j = size2 - 1; j >= 0; --j){\\n                int y = Character.getNumericValue(num2.charAt(j));\\n                int pos1 = i + j + 1;\\n                int pos2 = i + j;\\n                int prod = x * y;\\n                res[pos1] += prod % 10;\\n                res[pos2] += prod / 10;\\n            }\\n        }\\n        StringBuilder sb = new StringBuilder();\\n        for (int i = size1 + size2 - 1; i >= 0; --i){\\n            if (i == 0 && res[i] == 0)\\n                continue;\\n            sb.append(res[i] % 10);\\n            if (res[i] >= 10){\\n                res[i-1] += res[i] / 10;\\n            }\\n        }\\n        return sb.reverse().toString();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String multiply(String num1, String num2) {\\n        if (num1.equals(\"0\") || num2.equals(\"0\"))\\n            return \"0\";\\n        int size1 = num1.length(), size2 = num2.length();\\n        int[] res = new int[size1 + size2];\\n        for (int i = size1 - 1; i >= 0; --i){\\n            int x = Character.getNumericValue(num1.charAt(i));\\n            for (int j = size2 - 1; j >= 0; --j){\\n                int y = Character.getNumericValue(num2.charAt(j));\\n                int pos1 = i + j + 1;\\n                int pos2 = i + j;\\n                int prod = x * y;\\n                res[pos1] += prod % 10;\\n                res[pos2] += prod / 10;\\n            }\\n        }\\n        StringBuilder sb = new StringBuilder();\\n        for (int i = size1 + size2 - 1; i >= 0; --i){\\n            if (i == 0 && res[i] == 0)\\n                continue;\\n            sb.append(res[i] % 10);\\n            if (res[i] >= 10){\\n                res[i-1] += res[i] / 10;\\n            }\\n        }\\n        return sb.reverse().toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 283442,
                "title": "java-clean-solution",
                "content": "```\\n        public String multiply(String num1, String num2) {\\n            if (num1 == null || num1.isEmpty() || num2 == null || num2.isEmpty()) return \"\";\\n            int l1 = num1.length(), l2 = num2.length();\\n            int[] ret = new int[l1 + l2];\\n            for (int i = l1 - 1; i >= 0; --i) {\\n                for (int j = l2 - 1; j >= 0; --j) {\\n                    ret[i + j + 1] += (num1.charAt(i) - \\'0\\') * (num2.charAt(j) - \\'0\\');\\n                }\\n            }\\n            for (int i = ret.length - 1; i > 0; --i) {\\n                ret[i - 1] += ret[i] / 10;\\n                ret[i] %= 10;\\n            }\\n            StringBuilder sb = new StringBuilder();\\n            for (int i = 0; i < ret.length; ++i) {\\n                if (sb.length() == 0 && ret[i] == 0) continue;\\n                sb.append(ret[i]);\\n            }\\n            return sb.length() == 0 ? \"0\" : sb.toString();\\n        }\\n```",
                "solutionTags": [],
                "code": "```\\n        public String multiply(String num1, String num2) {\\n            if (num1 == null || num1.isEmpty() || num2 == null || num2.isEmpty()) return \"\";\\n            int l1 = num1.length(), l2 = num2.length();\\n            int[] ret = new int[l1 + l2];\\n            for (int i = l1 - 1; i >= 0; --i) {\\n                for (int j = l2 - 1; j >= 0; --j) {\\n                    ret[i + j + 1] += (num1.charAt(i) - \\'0\\') * (num2.charAt(j) - \\'0\\');\\n                }\\n            }\\n            for (int i = ret.length - 1; i > 0; --i) {\\n                ret[i - 1] += ret[i] / 10;\\n                ret[i] %= 10;\\n            }\\n            StringBuilder sb = new StringBuilder();\\n            for (int i = 0; i < ret.length; ++i) {\\n                if (sb.length() == 0 && ret[i] == 0) continue;\\n                sb.append(ret[i]);\\n            }\\n            return sb.length() == 0 ? \"0\" : sb.toString();\\n        }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 241287,
                "title": "rust-0ms-solution",
                "content": "```\\nimpl Solution {\\n    pub fn multiply(num1: String, num2: String) -> String {\\n        \\n        let mut ans = vec![0; num1.len() + num2.len()];\\n        for (i, ch1) in num1.chars().rev().peekable().enumerate() {\\n            for (j, ch2) in num2.chars().rev().peekable().enumerate() {\\n                let a = ch1.to_digit(10).unwrap();\\n                let b = ch2.to_digit(10).unwrap();\\n                \\n                let lo = (a * b + ans[i + j]) % 10;\\n                let hi = (a * b + ans[i + j]) / 10;\\n                ans[i + j] = lo;\\n                ans[i + j + 1] += hi;\\n            }\\n        }\\n        while ans.len() > 1 && ans.last() == Some(&0) {\\n            ans.pop();\\n        }\\n        ans.into_iter()\\n            .rev()\\n            .map(|s| s.to_string())\\n            .collect::<String>()\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nimpl Solution {\\n    pub fn multiply(num1: String, num2: String) -> String {\\n        \\n        let mut ans = vec![0; num1.len() + num2.len()];\\n        for (i, ch1) in num1.chars().rev().peekable().enumerate() {\\n            for (j, ch2) in num2.chars().rev().peekable().enumerate() {\\n                let a = ch1.to_digit(10).unwrap();\\n                let b = ch2.to_digit(10).unwrap();\\n                \\n                let lo = (a * b + ans[i + j]) % 10;\\n                let hi = (a * b + ans[i + j]) / 10;\\n                ans[i + j] = lo;\\n                ans[i + j + 1] += hi;\\n            }\\n        }\\n        while ans.len() > 1 && ans.last() == Some(&0) {\\n            ans.pop();\\n        }\\n        ans.into_iter()\\n            .rev()\\n            .map(|s| s.to_string())\\n            .collect::<String>()\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 17626,
                "title": "java-implementation-of-the-karatsuba-algorithm-o-n-1-585",
                "content": "This solution does not rely on BigInteger or any other fancy stuff. Just plain single-digit operations. Anything higher was computed directly on Strings.\\nThe Karatsuba algorithm is a divide an conquer algorithm that only makes 3 recursive multiplications and 4 additions. More efficient than grade school multiplication. Please note that I did a lot of string allocations which caused great overhead; this should be easily refactorable.\\n\\n    public class Karatsuba {\\n    \\n      public String multiply(String num1, String num2) {\\n        if (num1 == null || num2 == null)\\n          return null;\\n        if (\"\".equals(num1) || \"\".equals(num2))\\n          return \"\";\\n        if (num1.length() == 1 || num2.length() == 1)\\n          return singleMultiply(num2, num1);\\n    \\n        // Balance input with padded zeros.\\n        int len = Math.max(num1.length(), num2.length());\\n        StringBuilder sb1 = new StringBuilder(num1);\\n        StringBuilder sb2 = new StringBuilder(num2);\\n        for (int a = sb1.length(); a < len; a++) sb1.insert(0, '0');\\n        for (int a = sb2.length(); a < len; a++) sb2.insert(0, '0');\\n        num1 = sb1.toString();\\n        num2 = sb2.toString();\\n    \\n        // Karatsuba algorithm.\\n        String[] fComp = split(num1), sComp = split(num2);\\n        String a = fComp[0], b = fComp[1];\\n        String c = sComp[0], d = sComp[1];\\n        // Three recursive multiplications.\\n        String a_c = multiply(a, c);\\n        String b_d = multiply(b, d);\\n        String ab_cd = multiply(add(a, b), add(c, d));\\n        String e = subtract(subtract(ab_cd, b_d), a_c);\\n        return add(add(pad(a_c, (len >> 1) << 1), pad(e, len >> 1)), b_d);\\n      }\\n    \\n      private String trim(StringBuilder sb) {\\n        while (sb.length() > 1 && sb.charAt(0) == '0')\\n          sb.deleteCharAt(0);\\n        return sb.toString();\\n      }\\n    \\n      // Split in halves. If odd length first half > second.\\n      private String[] split(String s) {\\n        int m = s.length() >> 1;\\n        m = (s.length() & 1) == 1 ? m + 1 : m;\\n        return new String[]{s.substring(0, m), s.substring(m)};\\n      }\\n    \\n      // Multiply an arbitrary string with a single-digit string.\\n      private String singleMultiply(String num1, String num2) {\\n        if (\"0\".equals(num1) || \"0\".equals(num2)) return \"0\";\\n        if (\"1\".equals(num1)) return num2;\\n        if (\"1\".equals(num2)) return num1;\\n    \\n        String a, b;\\n        if (num1.length() == 1) {\\n          a = num2;\\n          b = num1;\\n        } else {\\n          a = num1;\\n          b = num2;\\n        }\\n    \\n        StringBuilder sb = new StringBuilder();\\n        int c = 0, s = b.charAt(0) - '0';\\n        // Grade school multiplication.\\n        for (int i = a.length() - 1; i >= 0; i--) {\\n          int f = a.charAt(i) - '0';\\n          sb.insert(0, ((f * s) + c) % 10);\\n          c = ((f * s) + c) / 10;\\n        }\\n    \\n        if (c > 0)  sb.insert(0, c);\\n        return trim(sb);\\n      }\\n    \\n      private String add(String num1, String num2) {\\n        String a, b;\\n        if (num1.length() >= num2.length()) {\\n          a = num1;\\n          b = num2;\\n        } else {\\n          a = num2;\\n          b = num1;\\n        }\\n    \\n        StringBuilder sb = new StringBuilder();\\n        int c = 0, diff = a.length() - b.length();\\n        // Grade school addition.\\n        for (int i = a.length() - 1; i >= 0; i--) {\\n          int f = a.charAt(i) - '0';\\n          int s = i - diff < 0 ? 0 : b.charAt(i - diff) - '0';\\n          sb.insert(0, (f + c + s) % 10);\\n          c = (f + c + s) / 10;\\n        }\\n    \\n        if (c > 0) sb.insert(0, c);\\n        return trim(sb);\\n      }\\n    \\n      private String subtract(String num1, String num2) {\\n        String a = null, b = null;\\n    \\n        // Ensure that the first operand >= the second.\\n        if (num1.length() > num2.length()) {\\n          a = num1;\\n          b = num2;\\n        } else if (num1.length() < num2.length()) {\\n          a = num2;\\n          b = num1;\\n        } else {\\n          // Digit size is equal, compare each corresponding digits.\\n          for (int i = 0; i < num1.length(); i++) {\\n            if (num1.charAt(i) - '0' > num2.charAt(i) - '0') {\\n              a = num1;\\n              b = num2;\\n              break;\\n            } else if (num2.charAt(i) - '0' > num1.charAt(i) - '0') {\\n              a = num2;\\n              b = num1;\\n              break;\\n            }\\n          }\\n          if (a == null) return \"0\"; // Num1 equals num2.\\n        }\\n    \\n        StringBuilder sb = new StringBuilder();\\n        int c = 0, diff = a.length() - b.length();\\n        // Grade school subtraction.\\n        for (int i = a.length() - 1; i >= 0; i--) {\\n          int f = a.charAt(i) - '0';\\n          int s = i - diff < 0 ? 0 : b.charAt(i - diff) - '0';\\n          int p = f - c - s;\\n          if (p < 0) {\\n            p += 10;\\n            c = 1;\\n          } else {\\n            c = 0;\\n          }\\n          sb.insert(0, p);\\n        }\\n    \\n        return trim(sb);\\n      }\\n    \\n      private String pad(String num, int zeros) {\\n        StringBuilder sb = new StringBuilder(num);\\n        for (int a = 0; a < zeros; a++) sb.append('0');\\n        return sb.toString();\\n      }\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "This solution does not rely on BigInteger or any other fancy stuff. Just plain single-digit operations. Anything higher was computed directly on Strings.\\nThe Karatsuba algorithm is a divide an conquer algorithm that only makes 3 recursive multiplications and 4 additions. More efficient than grade school multiplication. Please note that I did a lot of string allocations which caused great overhead; this should be easily refactorable.\\n\\n    public class Karatsuba {\\n    \\n      public String multiply(String num1, String num2) {\\n        if (num1 == null || num2 == null)\\n          return null;\\n        if (\"\".equals(num1) || \"\".equals(num2))\\n          return \"\";\\n        if (num1.length() == 1 || num2.length() == 1)\\n          return singleMultiply(num2, num1);\\n    \\n        // Balance input with padded zeros.\\n        int len = Math.max(num1.length(), num2.length());\\n        StringBuilder sb1 = new StringBuilder(num1);\\n        StringBuilder sb2 = new StringBuilder(num2);\\n        for (int a = sb1.length(); a < len; a++) sb1.insert(0, '0');\\n        for (int a = sb2.length(); a < len; a++) sb2.insert(0, '0');\\n        num1 = sb1.toString();\\n        num2 = sb2.toString();\\n    \\n        // Karatsuba algorithm.\\n        String[] fComp = split(num1), sComp = split(num2);\\n        String a = fComp[0], b = fComp[1];\\n        String c = sComp[0], d = sComp[1];\\n        // Three recursive multiplications.\\n        String a_c = multiply(a, c);\\n        String b_d = multiply(b, d);\\n        String ab_cd = multiply(add(a, b), add(c, d));\\n        String e = subtract(subtract(ab_cd, b_d), a_c);\\n        return add(add(pad(a_c, (len >> 1) << 1), pad(e, len >> 1)), b_d);\\n      }\\n    \\n      private String trim(StringBuilder sb) {\\n        while (sb.length() > 1 && sb.charAt(0) == '0')\\n          sb.deleteCharAt(0);\\n        return sb.toString();\\n      }\\n    \\n      // Split in halves. If odd length first half > second.\\n      private String[] split(String s) {\\n        int m = s.length() >> 1;\\n        m = (s.length() & 1) == 1 ? m + 1 : m;\\n        return new String[]{s.substring(0, m), s.substring(m)};\\n      }\\n    \\n      // Multiply an arbitrary string with a single-digit string.\\n      private String singleMultiply(String num1, String num2) {\\n        if (\"0\".equals(num1) || \"0\".equals(num2)) return \"0\";\\n        if (\"1\".equals(num1)) return num2;\\n        if (\"1\".equals(num2)) return num1;\\n    \\n        String a, b;\\n        if (num1.length() == 1) {\\n          a = num2;\\n          b = num1;\\n        } else {\\n          a = num1;\\n          b = num2;\\n        }\\n    \\n        StringBuilder sb = new StringBuilder();\\n        int c = 0, s = b.charAt(0) - '0';\\n        // Grade school multiplication.\\n        for (int i = a.length() - 1; i >= 0; i--) {\\n          int f = a.charAt(i) - '0';\\n          sb.insert(0, ((f * s) + c) % 10);\\n          c = ((f * s) + c) / 10;\\n        }\\n    \\n        if (c > 0)  sb.insert(0, c);\\n        return trim(sb);\\n      }\\n    \\n      private String add(String num1, String num2) {\\n        String a, b;\\n        if (num1.length() >= num2.length()) {\\n          a = num1;\\n          b = num2;\\n        } else {\\n          a = num2;\\n          b = num1;\\n        }\\n    \\n        StringBuilder sb = new StringBuilder();\\n        int c = 0, diff = a.length() - b.length();\\n        // Grade school addition.\\n        for (int i = a.length() - 1; i >= 0; i--) {\\n          int f = a.charAt(i) - '0';\\n          int s = i - diff < 0 ? 0 : b.charAt(i - diff) - '0';\\n          sb.insert(0, (f + c + s) % 10);\\n          c = (f + c + s) / 10;\\n        }\\n    \\n        if (c > 0) sb.insert(0, c);\\n        return trim(sb);\\n      }\\n    \\n      private String subtract(String num1, String num2) {\\n        String a = null, b = null;\\n    \\n        // Ensure that the first operand >= the second.\\n        if (num1.length() > num2.length()) {\\n          a = num1;\\n          b = num2;\\n        } else if (num1.length() < num2.length()) {\\n          a = num2;\\n          b = num1;\\n        } else {\\n          // Digit size is equal, compare each corresponding digits.\\n          for (int i = 0; i < num1.length(); i++) {\\n            if (num1.charAt(i) - '0' > num2.charAt(i) - '0') {\\n              a = num1;\\n              b = num2;\\n              break;\\n            } else if (num2.charAt(i) - '0' > num1.charAt(i) - '0') {\\n              a = num2;\\n              b = num1;\\n              break;\\n            }\\n          }\\n          if (a == null) return \"0\"; // Num1 equals num2.\\n        }\\n    \\n        StringBuilder sb = new StringBuilder();\\n        int c = 0, diff = a.length() - b.length();\\n        // Grade school subtraction.\\n        for (int i = a.length() - 1; i >= 0; i--) {\\n          int f = a.charAt(i) - '0';\\n          int s = i - diff < 0 ? 0 : b.charAt(i - diff) - '0';\\n          int p = f - c - s;\\n          if (p < 0) {\\n            p += 10;\\n            c = 1;\\n          } else {\\n            c = 0;\\n          }\\n          sb.insert(0, p);\\n        }\\n    \\n        return trim(sb);\\n      }\\n    \\n      private String pad(String num, int zeros) {\\n        StringBuilder sb = new StringBuilder(num);\\n        for (int a = 0; a < zeros; a++) sb.append('0');\\n        return sb.toString();\\n      }\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 17737,
                "title": "simplified-c-solution-o-n-n-m-13-lines",
                "content": "    class Solution {\\n    public:\\n        string multiply(string num1, string num2) {\\n            int l1 = num1.length(), l2=num2.length(),carry = 0;;\\n            if(num1==\"0\" || num2==\"0\") return \"0\";\\n            reverse(num1.begin(), num1.end());\\n            reverse(num2.begin(), num2.end());\\n            string res(l1+l2,0);\\n            for(int len=1; len<=l1+l2; ++len){\\n                for(int i=0; i<len&&i<l1; ++i){\\n                    if(len-i-1 <l2) carry += (num1[i]-'0')*(num2[len-i-1]-'0');\\n                }\\n                res[len-1]=(carry%10)+'0';\\n                carry /= 10;\\n            }\\n            if(res[res.length()-1]=='0') res.pop_back();\\n            reverse(res.begin(), res.end());\\n            return res;\\n        }\\n    };",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n    public:\\n        string multiply(string num1, string num2) {\\n            int l1 = num1.length(), l2=num2.length(),carry = 0;;\\n            if(num1==\"0\" || num2==\"0\") return \"0\";\\n            reverse(num1.begin(), num1.end());\\n            reverse(num2.begin(), num2.end());\\n            string res(l1+l2,0);\\n            for(int len=1; len<=l1+l2; ++len){\\n                for(int i=0; i<len&&i<l1; ++i){\\n                    if(len-i-1 <l2) carry += (num1[i]-'0')*(num2[len-i-1]-'0');\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 3720582,
                "title": "python3-beats-10",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def multiply(self, num1: str, num2: str) -> str:\\n        l1=len(num1)\\n        l2=len(num2)\\n\\n        if (l2>l1):   # taking smaller string as nums2\\n            num1,num2=num2,num1\\n\\n        l1=len(num1)\\n        l2=len(num2)\\n\\n        res=[0]*(l1+l2)\\n        res_pointer=len(res)-1\\n        res_pointer_count=0\\n\\n        carry=0\\n\\n        j=l2-1\\n\\n        while j>-1:\\n            res_pointer=len(res)-1-res_pointer_count\\n            for i in range((l1)-1,-1,-1):\\n                temp1 = int(num1[i])\\n                temp2 = int(num2[j])\\n\\n                inplace = (temp1*temp2)%10\\n                carry= (temp1*temp2)//10\\n\\n                res[res_pointer]+=inplace\\n                res[res_pointer-1]+=carry\\n\\n                if res[res_pointer]>9:\\n                    inplace = res[res_pointer]%10\\n                    carry= res[res_pointer]//10\\n                    res[res_pointer]=inplace\\n                    res[res_pointer-1]+=carry\\n\\n                res_pointer-=1\\n\\n            res_pointer_count+=1\\n            j-=1\\n\\n        ans=\"\"\\n        for i in res:\\n            ans=ans+str(i)\\n        return str(int(ans))\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def multiply(self, num1: str, num2: str) -> str:\\n        l1=len(num1)\\n        l2=len(num2)\\n\\n        if (l2>l1):   # taking smaller string as nums2\\n            num1,num2=num2,num1\\n\\n        l1=len(num1)\\n        l2=len(num2)\\n\\n        res=[0]*(l1+l2)\\n        res_pointer=len(res)-1\\n        res_pointer_count=0\\n\\n        carry=0\\n\\n        j=l2-1\\n\\n        while j>-1:\\n            res_pointer=len(res)-1-res_pointer_count\\n            for i in range((l1)-1,-1,-1):\\n                temp1 = int(num1[i])\\n                temp2 = int(num2[j])\\n\\n                inplace = (temp1*temp2)%10\\n                carry= (temp1*temp2)//10\\n\\n                res[res_pointer]+=inplace\\n                res[res_pointer-1]+=carry\\n\\n                if res[res_pointer]>9:\\n                    inplace = res[res_pointer]%10\\n                    carry= res[res_pointer]//10\\n                    res[res_pointer]=inplace\\n                    res[res_pointer-1]+=carry\\n\\n                res_pointer-=1\\n\\n            res_pointer_count+=1\\n            j-=1\\n\\n        ans=\"\"\\n        for i in res:\\n            ans=ans+str(i)\\n        return str(int(ans))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3559601,
                "title": "very-easy-to-understand-must-see-easy-pointer-approach-beats-99-9-easy-and-reliable-code-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n  O(n^2)\\n\\n- Space complexity:\\n   O(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string multiply(string num1, string num2) {\\n        int n = num1.length();\\n        int m = num2.length();\\n        string ans = \"\"; \\n        vector<int> res(n+m+1,0);\\n        int k = res.size()-1;\\n        int p = k;\\n        int carry = 0;\\n        for(int i = m-1 ; i>=0 ; i--)\\n        {\\n            for(int j = n-1 ; j>=0 ; j--)\\n            {\\n                int val = (num1[j]-\\'0\\')*(num2[i]-\\'0\\') + carry + res[k];\\n                // cout<<val<<endl;\\n                if(val>=10)\\n                {\\n                    int t = val%10;\\n                    carry = val/10;\\n                    res[k] = t;\\n                    k--;\\n                }\\n                else{\\n                    res[k] = val ; carry = 0;\\n                    k--;\\n                }\\n            }\\n            res[k] = carry ; carry = 0 ; p-- ; k = p;\\n        }\\n        int i = 0;\\n        while(res[i]==0 && i<res.size()-1) i++;\\n        for( ; i<res.size();i++)\\n        {\\n            ans+=to_string(res[i]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string multiply(string num1, string num2) {\\n        int n = num1.length();\\n        int m = num2.length();\\n        string ans = \"\"; \\n        vector<int> res(n+m+1,0);\\n        int k = res.size()-1;\\n        int p = k;\\n        int carry = 0;\\n        for(int i = m-1 ; i>=0 ; i--)\\n        {\\n            for(int j = n-1 ; j>=0 ; j--)\\n            {\\n                int val = (num1[j]-\\'0\\')*(num2[i]-\\'0\\') + carry + res[k];\\n                // cout<<val<<endl;\\n                if(val>=10)\\n                {\\n                    int t = val%10;\\n                    carry = val/10;\\n                    res[k] = t;\\n                    k--;\\n                }\\n                else{\\n                    res[k] = val ; carry = 0;\\n                    k--;\\n                }\\n            }\\n            res[k] = carry ; carry = 0 ; p-- ; k = p;\\n        }\\n        int i = 0;\\n        while(res[i]==0 && i<res.size()-1) i++;\\n        for( ; i<res.size();i++)\\n        {\\n            ans+=to_string(res[i]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3121650,
                "title": "one-line-code-in-java",
                "content": "Just one line of code in java\\n```\\nclass Solution {\\n    public static String multiply(String num1, String num2) {\\n        return String.valueOf((new java.math.BigInteger(num1)).multiply(new java.math.BigInteger(num2)));\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public static String multiply(String num1, String num2) {\\n        return String.valueOf((new java.math.BigInteger(num1)).multiply(new java.math.BigInteger(num2)));\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2424307,
                "title": "easy-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    void reverse(string &res)\\n    {\\n        int n=res.size();\\n        int i=0,j=n-1;\\n        while(i<j)\\n        {\\n            swap(res[i],res[j]);\\n            i++;j--;\\n        }\\n    }\\n    string helpmul(string s,int a)\\n    {\\n        int n=s.length();\\n        string res=\"\";\\n        int c=0;\\n        for(int i=n-1;i>=0;i--)\\n        {\\n            int x=(s[i]-\\'0\\')*a + c;\\n            res+=to_string(x%10);\\n            c=x/10;\\n        }\\n        if(c)\\n            res+=to_string(c);\\n        \\n        reverse(res);\\n        return res;\\n    }\\n    string add(string s1,string s2)\\n    {\\n        if(s1.length()<s2.length())\\n            swap(s1,s2);\\n        \\n        int n=s1.length();\\n        int m=s2.length();\\n        int c=0;\\n        string res=\"\";\\n        int i=n-1,j=m-1;\\n        while(i>=0)\\n        {\\n            int x=(s1[i]-\\'0\\')+(j>=0?(s2[j]-\\'0\\'):0)+c;\\n            res+=to_string(x%10);\\n            c=x/10;\\n            i--;j--;\\n        }\\n        if(c)\\n            res+=to_string(c);\\n        \\n        reverse(res);\\n        return res;\\n    }\\n    \\n    string multiply(string num1, string num2) {\\n        int n=num1.length(),m=num2.length();\\n        string zero=\"\";\\n        if(num1==\"0\" || num2==\"0\")\\n            return \"0\";\\n        string ans=\"\";\\n        for(int i=m-1;i>=0;i--)\\n        {\\n            int a=num2[i]-\\'0\\';\\n            string curr=helpmul(num1,a);\\n            curr+=zero;\\n            zero+=\\'0\\';\\n            ans=add(ans,curr);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void reverse(string &res)\\n    {\\n        int n=res.size();\\n        int i=0,j=n-1;\\n        while(i<j)\\n        {\\n            swap(res[i],res[j]);\\n            i++;j--;\\n        }\\n    }\\n    string helpmul(string s,int a)\\n    {\\n        int n=s.length();\\n        string res=\"\";\\n        int c=0;\\n        for(int i=n-1;i>=0;i--)\\n        {\\n            int x=(s[i]-\\'0\\')*a + c;\\n            res+=to_string(x%10);\\n            c=x/10;\\n        }\\n        if(c)\\n            res+=to_string(c);\\n        \\n        reverse(res);\\n        return res;\\n    }\\n    string add(string s1,string s2)\\n    {\\n        if(s1.length()<s2.length())\\n            swap(s1,s2);\\n        \\n        int n=s1.length();\\n        int m=s2.length();\\n        int c=0;\\n        string res=\"\";\\n        int i=n-1,j=m-1;\\n        while(i>=0)\\n        {\\n            int x=(s1[i]-\\'0\\')+(j>=0?(s2[j]-\\'0\\'):0)+c;\\n            res+=to_string(x%10);\\n            c=x/10;\\n            i--;j--;\\n        }\\n        if(c)\\n            res+=to_string(c);\\n        \\n        reverse(res);\\n        return res;\\n    }\\n    \\n    string multiply(string num1, string num2) {\\n        int n=num1.length(),m=num2.length();\\n        string zero=\"\";\\n        if(num1==\"0\" || num2==\"0\")\\n            return \"0\";\\n        string ans=\"\";\\n        for(int i=m-1;i>=0;i--)\\n        {\\n            int a=num2[i]-\\'0\\';\\n            string curr=helpmul(num1,a);\\n            curr+=zero;\\n            zero+=\\'0\\';\\n            ans=add(ans,curr);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2102516,
                "title": "fastest-python-solution",
                "content": "```py\\nclass Solution:\\n    @staticmethod\\n    def str2int(s: str) -> int:\\n        values = \"0\", \"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\"\\n        buffer = 0\\n        for char in s:\\n            buffer *= 10\\n            buffer += values.index(char)\\n        return buffer\\n    def multiply(self, num1: str, num2: str) -> str:\\n        return str(self.str2int(num1) * self.str2int(num2))\\n```\\nFor some reason my str2int function is faster than the built in int constructor\\n95%",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```py\\nclass Solution:\\n    @staticmethod\\n    def str2int(s: str) -> int:\\n        values = \"0\", \"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\"\\n        buffer = 0\\n        for char in s:\\n            buffer *= 10\\n            buffer += values.index(char)\\n        return buffer\\n    def multiply(self, num1: str, num2: str) -> str:\\n        return str(self.str2int(num1) * self.str2int(num2))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2053278,
                "title": "math-geek-fast-fourier-transform-and-number-theoretic-transform",
                "content": "\\n\\n***By Long Luo***\\n\\n# FFT\\n\\nFFT:\\n\\n[Implementation of FFT algorithm](http://www.longluo.me/blog/2022/04/02/FFT/)\\n[FFT Optimizations](http://www.longluo.me/blog/2022/04/29/FFT-optimization/)\\n\\n## Recursion\\n\\n```cpp\\nclass Solution {\\npublic:\\n    const double PI = acos(-1.0);  // PI = arccos(-1)\\n\\n    struct Complex {\\n        double re, im;\\n\\n        Complex(double _re = 0.0, double _im = 0.0) {\\n            re = _re;\\n            im = _im;\\n        }\\n\\n        inline void real(const double &re) {\\n            this->re = re;\\n        }\\n\\n        inline double real() {\\n            return re;\\n        }\\n\\n        inline void imag(const double &im) {\\n            this->im = im;\\n        }\\n\\n        inline double imag() {\\n            return im;\\n        }\\n\\n        inline Complex operator-(const Complex &other) const {\\n            return Complex(re - other.re, im - other.im);\\n        }\\n\\n        inline Complex operator+(const Complex &other) const {\\n            return Complex(re + other.re, im + other.im);\\n        }\\n\\n        inline Complex operator*(const Complex &other) const {\\n            return Complex(re * other.re - im * other.im, re * other.im + im * other.re);\\n        }\\n\\n        inline void operator/(const double &div) {\\n            re /= div;\\n            im /= div;\\n        }\\n\\n        inline void operator*=(const Complex &other) {\\n            *this = Complex(re * other.re - im * other.im, re * other.im + im * other.re);\\n        }\\n\\n        inline void operator+=(const Complex &other) {\\n            this->re += other.re;\\n            this->im += other.im;\\n        }\\n\\n        inline Complex conjugate() {\\n            return Complex(re, -im);\\n        }\\n    };\\n\\n    vector<Complex> FFT(vector<Complex> &a, bool invert) {\\n        int n = a.size();\\n\\n        if (n == 1) {\\n            return a;\\n        }\\n\\n        vector<Complex> Pe(n / 2), Po(n / 2);\\n\\n        for (int i = 0; 2 * i < n; i++) {\\n            Pe[i] = a[2 * i];\\n            Po[i] = a[2 * i + 1];\\n        }\\n\\n        vector<Complex> ye = FFT(Pe, invert);\\n        vector<Complex> yo = FFT(Po, invert);\\n\\n        // Combine\\n        vector<Complex> y(n);\\n\\n        // Root of Units\\n        double ang = 2 * PI / n * (invert ? -1 : 1);\\n        Complex wn(cos(ang), sin(ang)); \\n        Complex w(1, 0);  \\n\\n        for (int i = 0; i < n / 2; i++) {\\n            y[i] = ye[i] + w * yo[i]; \\n            y[i + n / 2] = ye[i] - w * yo[i];\\n            w = w * wn; \\n        }\\n\\n        return y;  \\n    }\\n\\n    string multiply(string num1, string num2) {\\n        if (num1 == \"0\" || num2 == \"0\") {\\n            return \"0\";\\n        }\\n\\n        int len1 = num1.size();\\n        int len2 = num2.size();\\n\\n        int n = 1;\\n        while (n < len1 + len2) {\\n            n = n << 1;\\n        }\\n\\n        vector<Complex> a(n);\\n        vector<Complex> b(n);\\n\\n        for (int i = len1 - 1; i >= 0; i--) {\\n            a[i] = Complex(num1[len1 - 1 - i] - \\'0\\', 0);\\n        }\\n\\n        for (int i = len2 - 1; i >= 0; i--) {\\n            b[i] = Complex(num2[len2 - 1 - i] - \\'0\\', 0);\\n        }\\n\\n        a = FFT(a, false);\\n        b = FFT(b, false);\\n\\n        for (int i = 0; i < n; i++) {\\n            a[i] = a[i] * b[i];\\n        }\\n\\n        a = FFT(a, true);\\n\\n        string ans;\\n        int carry = 0;\\n        for (int i = 0; i < n; i++) {\\n            int sum = round(round(a[i].re) / n) + carry;\\n            carry = sum / 10;\\n            ans += sum % 10 + \\'0\\';\\n        }\\n\\n        if (carry > 0) {\\n            ans += carry % 10 + \\'0\\';\\n        }\\n\\n        int idx = ans.size() - 1;\\n        while (ans[idx] == \\'0\\' && idx > 0) {\\n            idx--;\\n        }\\n\\n        ans = ans.substr(0, idx + 1);\\n        reverse(ans.begin(), ans.end());\\n        return ans;\\n    }\\n}\\n```\\n\\n## Iteration\\n\\n```cpp\\nclass Solution {\\npublic:\\n    const double PI = acos(-1.0);    // PI = arccos(-1)\\n\\n    struct Complex {\\n        double re, im;\\n\\n        Complex(double _re = 0.0, double _im = 0.0) {\\n            re = _re;\\n            im = _im;\\n        }\\n\\n        inline void real(const double &re) {\\n            this->re = re;\\n        }\\n\\n        inline double real() {\\n            return re;\\n        }\\n\\n        inline void imag(const double &im) {\\n            this->im = im;\\n        }\\n\\n        inline double imag() {\\n            return im;\\n        }\\n\\n        inline Complex operator-(const Complex &other) const {\\n            return Complex(re - other.re, im - other.im);\\n        }\\n\\n        inline Complex operator+(const Complex &other) const {\\n            return Complex(re + other.re, im + other.im);\\n        }\\n\\n        inline Complex operator*(const Complex &other) const {\\n            return Complex(re * other.re - im * other.im, re * other.im + im * other.re);\\n        }\\n\\n        inline void operator/(const double &div) {\\n            re /= div;\\n            im /= div;\\n        }\\n\\n        inline void operator+=(const Complex &other) {\\n            this->re += other.re;\\n            this->im += other.im;\\n        }\\n\\n        inline void operator-=(const Complex &other) {\\n            this->re -= other.re;\\n            this->im -= other.im;\\n        }\\n\\n        inline void operator*=(const Complex &other) {\\n            *this = Complex(re * other.re - im * other.im, re * other.im + im * other.re);\\n        }\\n\\n        inline Complex conjugate() {\\n            return Complex(re, -im);\\n        }\\n    };\\n\\n    static const int N = 256;\\n\\n    Complex omega[N];\\n    Complex invert[N];\\n\\n    int rev[N];\\n\\n    void init(int n) {\\n        rev[0] = 0;\\n\\n        for (int i = 0; i < n; i++) {\\n            double ang = 2 * PI * i / n;\\n            omega[i] = Complex(cos(ang), sin(ang));\\n            invert[i] = omega[i].conjugate();\\n\\n            if (i > 0) {\\n                rev[i] = rev[i >> 1] >> 1;\\n                if (i & 1) {\\n                    rev[i] |= n >> 1;\\n                }\\n            }\\n        }\\n    }\\n\\n    void FFT(vector<Complex> &a, Complex *omega) {\\n        int n = a.size();\\n\\n        if (n == 1) {\\n            return;\\n        }\\n\\n        for (int i = 0; i < n; ++i) {\\n            if (i < rev[i]) {\\n                swap(a[i], a[rev[i]]);\\n            }\\n        }\\n\\n        for (int len = 2; len <= n; len *= 2) {\\n            for (int i = 0; i < n; i += len) {\\n                for (int j = 0; j < len / 2; j++) {\\n                    Complex u = a[i + j];\\n                    Complex v = omega[j * n / len] * a[i + j + len / 2];\\n                    a[i + j] = u + v;\\n                    a[i + j + len / 2] = u - v;\\n                }\\n            }\\n        }\\n    }\\n\\n    string multiply(string num1, string num2) {\\n        if (num1 == \"0\" || num2 == \"0\") {\\n            return \"0\";\\n        }\\n\\n        int len1 = num1.size();\\n        int len2 = num2.size();\\n\\n        int n = 1;\\n        while (n < len1 + len2) {\\n            n = n << 1;\\n        }\\n\\n        vector<Complex> a(n);\\n        vector<Complex> b(n);\\n\\n        for (int i = len1 - 1; i >= 0; i--) {\\n            a[i].real((num1[len1 - 1 - i] - \\'0\\'));\\n        }\\n\\n        for (int i = len2 - 1; i >= 0; i--) {\\n            b[i].real((num2[len2 - 1 - i] - \\'0\\'));\\n        }\\n\\n        init(n);\\n\\n        FFT(a, omega);\\n        FFT(b, omega);\\n\\n        for (int i = 0; i < n; i++) {\\n            a[i] = a[i] * b[i];\\n        }\\n\\n        FFT(a, invert);\\n\\n        string ans;\\n        int carry = 0;\\n        for (int i = 0; i < n; i++) {\\n            int sum = round(round(a[i].real()) / n) + carry;\\n            carry = sum / 10;\\n            ans += sum % 10 + \\'0\\';\\n        }\\n\\n        if (carry > 0) {\\n            ans += carry % 10 + \\'0\\';\\n        }\\n\\n        int idx = n - 1;\\n        while (ans[idx] == \\'0\\' && idx > 0) {\\n            idx--;\\n        }\\n\\n        ans = ans.substr(0, idx + 1);\\n        reverse(ans.begin(), ans.end());\\n        return ans;\\n    }\\n}\\n```\\n\\n## Analysis\\n\\n- **Time Complexity**: `O((m+n)log(m+n))`.\\n- **Space Complexity**: `O(m+n)`.\\n\\n# Number Theoretic Transform\\n\\nNTT : [\\u5FEB\\u901F\\u6570\\u8BBA\\u53D8\\u6362(Number Theoretic Transform)](http://www.longluo.me/blog/2022/05/01/Number-Theoretic-Transform/) \\u3002\\n\\n## Recursion\\n\\n```cpp\\nclass Solution {\\n\\npublic:\\n    const long long G = 3;\\n    const long long G_INV = 332748118;\\n    const long long MOD = 998244353;\\n\\n    vector<int> rev;\\n\\n    long long quickPower(long long a, long long b) {\\n        long long res = 1;\\n\\n        while (b > 0) {\\n            if (b & 1) {\\n                res = (res * a) % MOD;\\n            }\\n\\n            a = (a * a) % MOD;\\n            b >>= 1;\\n        }\\n\\n        return res % MOD;\\n    }\\n\\n    void ntt(vector<long long> &a, bool invert) {\\n        int n = a.size();\\n\\n        if (n == 1) {\\n            return;\\n        }\\n\\n        vector<long long> Pe(n / 2), Po(n / 2);\\n\\n        for (int i = 0; 2 * i < n; i++) {\\n            Pe[i] = a[2 * i];\\n            Po[i] = a[2 * i + 1];\\n        }\\n\\n        ntt(Pe, invert);\\n        ntt(Po, invert);\\n\\n        long long wn = quickPower(invert ? G_INV : G, (MOD - 1) / n);\\n        long long w = 1;\\n\\n        for (int i = 0; i < n / 2; i++) {\\n            a[i] = Pe[i] + w * Po[i] % MOD;\\n            a[i] = (a[i] % MOD + MOD) % MOD;\\n            a[i + n / 2] = Pe[i] - w * Po[i] % MOD;\\n            a[i + n / 2] = (a[i + n / 2] % MOD + MOD) % MOD;\\n            w = w * wn % MOD;\\n        }\\n    }\\n\\n    string multiply(string num1, string num2) {\\n        if (num1 == \"0\" || num2 == \"0\") {\\n            return \"0\";\\n        }\\n\\n        int len1 = num1.size();\\n        int len2 = num2.size();\\n\\n        int n = 1;\\n\\n        while (n < (len1 + len2)) {\\n            n = n << 1;\\n        }\\n\\n        vector<long long> a(n, 0), b(n, 0);\\n\\n        for (int i = 0; i < len1; ++i) {\\n            a[i] = num1[len1 - 1 - i] - \\'0\\';\\n        }\\n\\n        for (int i = 0; i < len2; ++i) {\\n            b[i] = num2[len2 - 1 - i] - \\'0\\';\\n        }\\n\\n        ntt(a, false);\\n        ntt(b, false);\\n\\n        for (int i = 0; i < n; i++) {\\n            a[i] = (a[i] * b[i]) % MOD;\\n        }\\n\\n        ntt(a, true);\\n\\n        string res;\\n        long long carry = 0;\\n        long long inver = quickPower(n, MOD - 2);\\n\\n        for (int i = 0; i < n; i++) {\\n            a[i] = a[i] * inver % MOD;\\n        }\\n\\n        for (int i = 0; i < n; i++) {\\n            long long sum = a[i] + carry;\\n            res += sum % 10 + \\'0\\';\\n            carry = sum / 10;\\n        }\\n\\n        while (carry) {\\n            res += carry % 10 + \\'0\\';\\n            carry /= 10;\\n        }\\n\\n        int idx = n - 1;\\n        while (idx >= 0 && res[idx] == \\'0\\') {\\n            idx--;\\n        }\\n\\n        res = res.substr(0, idx + 1);\\n        reverse(res.begin(), res.end());\\n        return res;\\n    }\\n}\\n```\\n\\n## Iteration\\n\\n```cpp\\nclass Solution {\\n    static const long long MOD = 998244353;\\n    static const long long G = 3;\\n    static const int G_INV = 332748118;\\n    vector<int> rev;\\n\\npublic:\\n    long long quickPower(long long a, long long b) {\\n        long long res = 1;\\n\\n        while (b > 0) {\\n            if (b & 1) {\\n                res = (res * a) % MOD;\\n            }\\n\\n            a = (a * a) % MOD;\\n            b >>= 1;\\n        }\\n\\n        return res % MOD;\\n    }\\n\\n    void ntt(vector<long long> &a, bool invert = false) {\\n        int n = a.size();\\n\\n        for (int i = 0; i < n; i++) {\\n            if (i < rev[i]) {\\n                swap(a[i], a[rev[i]]);\\n            }\\n        }\\n\\n        for (int len = 2; len <= n; len <<= 1) {\\n            long long wlen = quickPower(invert ? G_INV : G, (MOD - 1) / len);\\n\\n            for (int i = 0; i < n; i += len) {\\n                long long w = 1;\\n                for (int j = 0; j < len / 2; j++) {\\n                    long long u = a[i + j];\\n                    long long v = (w * a[i + j + len / 2]) % MOD;\\n                    a[i + j] = (u + v) % MOD;\\n                    a[i + j + len / 2] = (MOD + u - v) % MOD;\\n                    w = (w * wlen) % MOD;\\n                }\\n            }\\n        }\\n\\n        if (invert) {\\n            long long inver = quickPower(n, MOD - 2);\\n            for (int i = 0; i < n; i++) {\\n                a[i] = (long long) a[i] * inver % MOD;\\n            }\\n        }\\n    }\\n\\n    string multiply(string num1, string num2) {\\n        if (num1 == \"0\" || num2 == \"0\") {\\n            return \"0\";\\n        }\\n\\n        int len1 = num1.size();\\n        int len2 = num2.size();\\n\\n        int n = 1;\\n        int bit = 1;\\n\\n        while ((n <<= 1) < (len1 + len2)) {\\n            ++bit;\\n        }\\n\\n        rev.resize(n);\\n        for (int i = 0; i < n; i++) {\\n            rev[i] = (rev[i >> 1] >> 1) | ((i & 1) << (bit - 1));\\n        }\\n\\n        vector<long long> a(n, 0), b(n, 0);\\n\\n        for (int i = 0; i < len1; ++i) {\\n            a[i] = num1[len1 - 1 - i] - \\'0\\';\\n        }\\n\\n        for (int i = 0; i < len2; ++i) {\\n            b[i] = num2[len2 - 1 - i] - \\'0\\';\\n        }\\n\\n        ntt(a);\\n        ntt(b);\\n\\n        for (int i = 0; i < n; i++) {\\n            a[i] = (a[i] * b[i]) % MOD;\\n        }\\n\\n        ntt(a, true);\\n\\n        string res;\\n        long long carry = 0;\\n        for (int i = 0; i < len1 + len2 - 1; ++i) {\\n            long long curr = a[i] + carry;\\n            res += curr % 10 + \\'0\\';\\n            carry = curr / 10;\\n        }\\n\\n        while (carry) {\\n            res += carry % 10 + \\'0\\';\\n            carry /= 10;\\n        }\\n\\n        reverse(res.begin(), res.end());\\n        return res;\\n    }\\n}\\n```\\n\\n## Analysis\\n\\n- **Time Complexity**: `O((m+n)log(m+n))`.\\n- **Space Complexity**: `O(m+n)`.\\n\\n----------\\n\\nAll suggestions are welcome. \\nIf you have any query or suggestion please comment below.\\nPlease upvote\\uD83D\\uDC4D if you like\\uD83D\\uDC97 it. Thank you:-)\\n\\nExplore More [Leetcode Solutions](http://www.longluo.me/blog/2020/12/09/Leetcode-Solutions/). \\uD83D\\uDE09\\uD83D\\uDE03\\uD83D\\uDC97\\n\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Math",
                    "String",
                    "Simulation"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    const double PI = acos(-1.0);  // PI = arccos(-1)\\n\\n    struct Complex {\\n        double re, im;\\n\\n        Complex(double _re = 0.0, double _im = 0.0) {\\n            re = _re;\\n            im = _im;\\n        }\\n\\n        inline void real(const double &re) {\\n            this->re = re;\\n        }\\n\\n        inline double real() {\\n            return re;\\n        }\\n\\n        inline void imag(const double &im) {\\n            this->im = im;\\n        }\\n\\n        inline double imag() {\\n            return im;\\n        }\\n\\n        inline Complex operator-(const Complex &other) const {\\n            return Complex(re - other.re, im - other.im);\\n        }\\n\\n        inline Complex operator+(const Complex &other) const {\\n            return Complex(re + other.re, im + other.im);\\n        }\\n\\n        inline Complex operator*(const Complex &other) const {\\n            return Complex(re * other.re - im * other.im, re * other.im + im * other.re);\\n        }\\n\\n        inline void operator/(const double &div) {\\n            re /= div;\\n            im /= div;\\n        }\\n\\n        inline void operator*=(const Complex &other) {\\n            *this = Complex(re * other.re - im * other.im, re * other.im + im * other.re);\\n        }\\n\\n        inline void operator+=(const Complex &other) {\\n            this->re += other.re;\\n            this->im += other.im;\\n        }\\n\\n        inline Complex conjugate() {\\n            return Complex(re, -im);\\n        }\\n    };\\n\\n    vector<Complex> FFT(vector<Complex> &a, bool invert) {\\n        int n = a.size();\\n\\n        if (n == 1) {\\n            return a;\\n        }\\n\\n        vector<Complex> Pe(n / 2), Po(n / 2);\\n\\n        for (int i = 0; 2 * i < n; i++) {\\n            Pe[i] = a[2 * i];\\n            Po[i] = a[2 * i + 1];\\n        }\\n\\n        vector<Complex> ye = FFT(Pe, invert);\\n        vector<Complex> yo = FFT(Po, invert);\\n\\n        // Combine\\n        vector<Complex> y(n);\\n\\n        // Root of Units\\n        double ang = 2 * PI / n * (invert ? -1 : 1);\\n        Complex wn(cos(ang), sin(ang)); \\n        Complex w(1, 0);  \\n\\n        for (int i = 0; i < n / 2; i++) {\\n            y[i] = ye[i] + w * yo[i]; \\n            y[i + n / 2] = ye[i] - w * yo[i];\\n            w = w * wn; \\n        }\\n\\n        return y;  \\n    }\\n\\n    string multiply(string num1, string num2) {\\n        if (num1 == \"0\" || num2 == \"0\") {\\n            return \"0\";\\n        }\\n\\n        int len1 = num1.size();\\n        int len2 = num2.size();\\n\\n        int n = 1;\\n        while (n < len1 + len2) {\\n            n = n << 1;\\n        }\\n\\n        vector<Complex> a(n);\\n        vector<Complex> b(n);\\n\\n        for (int i = len1 - 1; i >= 0; i--) {\\n            a[i] = Complex(num1[len1 - 1 - i] - \\'0\\', 0);\\n        }\\n\\n        for (int i = len2 - 1; i >= 0; i--) {\\n            b[i] = Complex(num2[len2 - 1 - i] - \\'0\\', 0);\\n        }\\n\\n        a = FFT(a, false);\\n        b = FFT(b, false);\\n\\n        for (int i = 0; i < n; i++) {\\n            a[i] = a[i] * b[i];\\n        }\\n\\n        a = FFT(a, true);\\n\\n        string ans;\\n        int carry = 0;\\n        for (int i = 0; i < n; i++) {\\n            int sum = round(round(a[i].re) / n) + carry;\\n            carry = sum / 10;\\n            ans += sum % 10 + \\'0\\';\\n        }\\n\\n        if (carry > 0) {\\n            ans += carry % 10 + \\'0\\';\\n        }\\n\\n        int idx = ans.size() - 1;\\n        while (ans[idx] == \\'0\\' && idx > 0) {\\n            idx--;\\n        }\\n\\n        ans = ans.substr(0, idx + 1);\\n        reverse(ans.begin(), ans.end());\\n        return ans;\\n    }\\n}\\n```\n```cpp\\nclass Solution {\\npublic:\\n    const double PI = acos(-1.0);    // PI = arccos(-1)\\n\\n    struct Complex {\\n        double re, im;\\n\\n        Complex(double _re = 0.0, double _im = 0.0) {\\n            re = _re;\\n            im = _im;\\n        }\\n\\n        inline void real(const double &re) {\\n            this->re = re;\\n        }\\n\\n        inline double real() {\\n            return re;\\n        }\\n\\n        inline void imag(const double &im) {\\n            this->im = im;\\n        }\\n\\n        inline double imag() {\\n            return im;\\n        }\\n\\n        inline Complex operator-(const Complex &other) const {\\n            return Complex(re - other.re, im - other.im);\\n        }\\n\\n        inline Complex operator+(const Complex &other) const {\\n            return Complex(re + other.re, im + other.im);\\n        }\\n\\n        inline Complex operator*(const Complex &other) const {\\n            return Complex(re * other.re - im * other.im, re * other.im + im * other.re);\\n        }\\n\\n        inline void operator/(const double &div) {\\n            re /= div;\\n            im /= div;\\n        }\\n\\n        inline void operator+=(const Complex &other) {\\n            this->re += other.re;\\n            this->im += other.im;\\n        }\\n\\n        inline void operator-=(const Complex &other) {\\n            this->re -= other.re;\\n            this->im -= other.im;\\n        }\\n\\n        inline void operator*=(const Complex &other) {\\n            *this = Complex(re * other.re - im * other.im, re * other.im + im * other.re);\\n        }\\n\\n        inline Complex conjugate() {\\n            return Complex(re, -im);\\n        }\\n    };\\n\\n    static const int N = 256;\\n\\n    Complex omega[N];\\n    Complex invert[N];\\n\\n    int rev[N];\\n\\n    void init(int n) {\\n        rev[0] = 0;\\n\\n        for (int i = 0; i < n; i++) {\\n            double ang = 2 * PI * i / n;\\n            omega[i] = Complex(cos(ang), sin(ang));\\n            invert[i] = omega[i].conjugate();\\n\\n            if (i > 0) {\\n                rev[i] = rev[i >> 1] >> 1;\\n                if (i & 1) {\\n                    rev[i] |= n >> 1;\\n                }\\n            }\\n        }\\n    }\\n\\n    void FFT(vector<Complex> &a, Complex *omega) {\\n        int n = a.size();\\n\\n        if (n == 1) {\\n            return;\\n        }\\n\\n        for (int i = 0; i < n; ++i) {\\n            if (i < rev[i]) {\\n                swap(a[i], a[rev[i]]);\\n            }\\n        }\\n\\n        for (int len = 2; len <= n; len *= 2) {\\n            for (int i = 0; i < n; i += len) {\\n                for (int j = 0; j < len / 2; j++) {\\n                    Complex u = a[i + j];\\n                    Complex v = omega[j * n / len] * a[i + j + len / 2];\\n                    a[i + j] = u + v;\\n                    a[i + j + len / 2] = u - v;\\n                }\\n            }\\n        }\\n    }\\n\\n    string multiply(string num1, string num2) {\\n        if (num1 == \"0\" || num2 == \"0\") {\\n            return \"0\";\\n        }\\n\\n        int len1 = num1.size();\\n        int len2 = num2.size();\\n\\n        int n = 1;\\n        while (n < len1 + len2) {\\n            n = n << 1;\\n        }\\n\\n        vector<Complex> a(n);\\n        vector<Complex> b(n);\\n\\n        for (int i = len1 - 1; i >= 0; i--) {\\n            a[i].real((num1[len1 - 1 - i] - \\'0\\'));\\n        }\\n\\n        for (int i = len2 - 1; i >= 0; i--) {\\n            b[i].real((num2[len2 - 1 - i] - \\'0\\'));\\n        }\\n\\n        init(n);\\n\\n        FFT(a, omega);\\n        FFT(b, omega);\\n\\n        for (int i = 0; i < n; i++) {\\n            a[i] = a[i] * b[i];\\n        }\\n\\n        FFT(a, invert);\\n\\n        string ans;\\n        int carry = 0;\\n        for (int i = 0; i < n; i++) {\\n            int sum = round(round(a[i].real()) / n) + carry;\\n            carry = sum / 10;\\n            ans += sum % 10 + \\'0\\';\\n        }\\n\\n        if (carry > 0) {\\n            ans += carry % 10 + \\'0\\';\\n        }\\n\\n        int idx = n - 1;\\n        while (ans[idx] == \\'0\\' && idx > 0) {\\n            idx--;\\n        }\\n\\n        ans = ans.substr(0, idx + 1);\\n        reverse(ans.begin(), ans.end());\\n        return ans;\\n    }\\n}\\n```\n```cpp\\nclass Solution {\\n\\npublic:\\n    const long long G = 3;\\n    const long long G_INV = 332748118;\\n    const long long MOD = 998244353;\\n\\n    vector<int> rev;\\n\\n    long long quickPower(long long a, long long b) {\\n        long long res = 1;\\n\\n        while (b > 0) {\\n            if (b & 1) {\\n                res = (res * a) % MOD;\\n            }\\n\\n            a = (a * a) % MOD;\\n            b >>= 1;\\n        }\\n\\n        return res % MOD;\\n    }\\n\\n    void ntt(vector<long long> &a, bool invert) {\\n        int n = a.size();\\n\\n        if (n == 1) {\\n            return;\\n        }\\n\\n        vector<long long> Pe(n / 2), Po(n / 2);\\n\\n        for (int i = 0; 2 * i < n; i++) {\\n            Pe[i] = a[2 * i];\\n            Po[i] = a[2 * i + 1];\\n        }\\n\\n        ntt(Pe, invert);\\n        ntt(Po, invert);\\n\\n        long long wn = quickPower(invert ? G_INV : G, (MOD - 1) / n);\\n        long long w = 1;\\n\\n        for (int i = 0; i < n / 2; i++) {\\n            a[i] = Pe[i] + w * Po[i] % MOD;\\n            a[i] = (a[i] % MOD + MOD) % MOD;\\n            a[i + n / 2] = Pe[i] - w * Po[i] % MOD;\\n            a[i + n / 2] = (a[i + n / 2] % MOD + MOD) % MOD;\\n            w = w * wn % MOD;\\n        }\\n    }\\n\\n    string multiply(string num1, string num2) {\\n        if (num1 == \"0\" || num2 == \"0\") {\\n            return \"0\";\\n        }\\n\\n        int len1 = num1.size();\\n        int len2 = num2.size();\\n\\n        int n = 1;\\n\\n        while (n < (len1 + len2)) {\\n            n = n << 1;\\n        }\\n\\n        vector<long long> a(n, 0), b(n, 0);\\n\\n        for (int i = 0; i < len1; ++i) {\\n            a[i] = num1[len1 - 1 - i] - \\'0\\';\\n        }\\n\\n        for (int i = 0; i < len2; ++i) {\\n            b[i] = num2[len2 - 1 - i] - \\'0\\';\\n        }\\n\\n        ntt(a, false);\\n        ntt(b, false);\\n\\n        for (int i = 0; i < n; i++) {\\n            a[i] = (a[i] * b[i]) % MOD;\\n        }\\n\\n        ntt(a, true);\\n\\n        string res;\\n        long long carry = 0;\\n        long long inver = quickPower(n, MOD - 2);\\n\\n        for (int i = 0; i < n; i++) {\\n            a[i] = a[i] * inver % MOD;\\n        }\\n\\n        for (int i = 0; i < n; i++) {\\n            long long sum = a[i] + carry;\\n            res += sum % 10 + \\'0\\';\\n            carry = sum / 10;\\n        }\\n\\n        while (carry) {\\n            res += carry % 10 + \\'0\\';\\n            carry /= 10;\\n        }\\n\\n        int idx = n - 1;\\n        while (idx >= 0 && res[idx] == \\'0\\') {\\n            idx--;\\n        }\\n\\n        res = res.substr(0, idx + 1);\\n        reverse(res.begin(), res.end());\\n        return res;\\n    }\\n}\\n```\n```cpp\\nclass Solution {\\n    static const long long MOD = 998244353;\\n    static const long long G = 3;\\n    static const int G_INV = 332748118;\\n    vector<int> rev;\\n\\npublic:\\n    long long quickPower(long long a, long long b) {\\n        long long res = 1;\\n\\n        while (b > 0) {\\n            if (b & 1) {\\n                res = (res * a) % MOD;\\n            }\\n\\n            a = (a * a) % MOD;\\n            b >>= 1;\\n        }\\n\\n        return res % MOD;\\n    }\\n\\n    void ntt(vector<long long> &a, bool invert = false) {\\n        int n = a.size();\\n\\n        for (int i = 0; i < n; i++) {\\n            if (i < rev[i]) {\\n                swap(a[i], a[rev[i]]);\\n            }\\n        }\\n\\n        for (int len = 2; len <= n; len <<= 1) {\\n            long long wlen = quickPower(invert ? G_INV : G, (MOD - 1) / len);\\n\\n            for (int i = 0; i < n; i += len) {\\n                long long w = 1;\\n                for (int j = 0; j < len / 2; j++) {\\n                    long long u = a[i + j];\\n                    long long v = (w * a[i + j + len / 2]) % MOD;\\n                    a[i + j] = (u + v) % MOD;\\n                    a[i + j + len / 2] = (MOD + u - v) % MOD;\\n                    w = (w * wlen) % MOD;\\n                }\\n            }\\n        }\\n\\n        if (invert) {\\n            long long inver = quickPower(n, MOD - 2);\\n            for (int i = 0; i < n; i++) {\\n                a[i] = (long long) a[i] * inver % MOD;\\n            }\\n        }\\n    }\\n\\n    string multiply(string num1, string num2) {\\n        if (num1 == \"0\" || num2 == \"0\") {\\n            return \"0\";\\n        }\\n\\n        int len1 = num1.size();\\n        int len2 = num2.size();\\n\\n        int n = 1;\\n        int bit = 1;\\n\\n        while ((n <<= 1) < (len1 + len2)) {\\n            ++bit;\\n        }\\n\\n        rev.resize(n);\\n        for (int i = 0; i < n; i++) {\\n            rev[i] = (rev[i >> 1] >> 1) | ((i & 1) << (bit - 1));\\n        }\\n\\n        vector<long long> a(n, 0), b(n, 0);\\n\\n        for (int i = 0; i < len1; ++i) {\\n            a[i] = num1[len1 - 1 - i] - \\'0\\';\\n        }\\n\\n        for (int i = 0; i < len2; ++i) {\\n            b[i] = num2[len2 - 1 - i] - \\'0\\';\\n        }\\n\\n        ntt(a);\\n        ntt(b);\\n\\n        for (int i = 0; i < n; i++) {\\n            a[i] = (a[i] * b[i]) % MOD;\\n        }\\n\\n        ntt(a, true);\\n\\n        string res;\\n        long long carry = 0;\\n        for (int i = 0; i < len1 + len2 - 1; ++i) {\\n            long long curr = a[i] + carry;\\n            res += curr % 10 + \\'0\\';\\n            carry = curr / 10;\\n        }\\n\\n        while (carry) {\\n            res += carry % 10 + \\'0\\';\\n            carry /= 10;\\n        }\\n\\n        reverse(res.begin(), res.end());\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1564420,
                "title": "python-o-nm",
                "content": "```\\nclass Solution(object):\\n    def multiply(self, num1, num2):\\n        \"\"\"\\n        :type num1: str\\n        :type num2: str\\n        :rtype: str\\n        \"\"\"\\n        result = 0;\\n        \\n        m1 = 1;\\n        i = len(num1) -1\\n        while i >= 0:\\n            j = len(num2) -1\\n            m2 = 1\\n            while j >= 0:\\n                result += int(num1[i]) * m1 * int(num2[j]) * m2\\n                m2 *= 10\\n                j-=1\\n            m1 *= 10\\n            i-=1\\n        return str(result)",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def multiply(self, num1, num2):\\n        \"\"\"\\n        :type num1: str\\n        :type num2: str\\n        :rtype: str\\n        \"\"\"\\n        result = 0;\\n        \\n        m1 = 1;\\n        i = len(num1) -1\\n        while i >= 0:\\n            j = len(num2) -1\\n            m2 = 1\\n            while j >= 0:\\n                result += int(num1[i]) * m1 * int(num2[j]) * m2\\n                m2 *= 10\\n                j-=1\\n            m1 *= 10\\n            i-=1\\n        return str(result)",
                "codeTag": "Java"
            },
            {
                "id": 1564288,
                "title": "simple-easy-to-understand",
                "content": "**Key Points:-**\\n* When either of the string is Zero, return \"0\".\\n* We would be multiplying every character of smaller length string with bigger length string to reduce runtime complexity.\\n* reverse both of the strings for multiplication\\n* pick up a single character, multiply this value with string s2 and add the obtained result to answer.\\n**Time Complexity:- O(nm)\\nSpace Complexity:- O(n+m)**\\n\\n```\\nclass Solution {\\npublic:\\n    void add(string& ans,string s,int index){\\n        if(ans.empty()){\\n            ans = s;\\n            return;\\n        }\\n        string curr = \"\";\\n        int carry = 0;\\n        for(int i=0;;i++){\\n            if(i<index){\\n                curr.push_back(ans[i]);\\n                continue;\\n            }\\n            if(i>=ans.length() and i-index>=s.length())\\n                break;\\n            int a = (i>=ans.length())?0:ans[i]-\\'0\\';\\n            int b = (i-index>=s.length())?0:s[i-index]-\\'0\\';\\n            int rem = (a+b+carry)%10;\\n            carry = (a+b+carry)/10;\\n            curr.push_back(\\'0\\'+rem);\\n        }\\n        while(carry){\\n            curr.push_back(\\'0\\'+carry%10);\\n            carry/=10;\\n        }\\n        ans = curr;\\n    }\\n    string multiply(string s1, string s2) {\\n        if(s1.length()>s2.length())\\n            return multiply(s2,s1);\\n        if(s1==\"0\" or s2==\"0\")\\n            return \"0\";\\n        int n = s1.length(),m = s2.length();\\n        string ans = \"\";\\n        reverse(s1.begin(),s1.end());\\n        reverse(s2.begin(),s2.end());\\n        for(int i=0;i<n;i++){\\n            string s = \"\";\\n            int a = s1[i] - \\'0\\',carry = 0;\\n            for(int j=0;j<m;j++){\\n                int b = s2[j] - \\'0\\';\\n                int curr = a*b + carry;\\n                s.push_back(\\'0\\'+curr%10);\\n                carry = curr/10;\\n            }\\n            while(carry){\\n                s.push_back(\\'0\\'+carry%10);\\n                carry/=10;\\n            }\\n            add(ans,s,i);\\n        }\\n        reverse(ans.begin(),ans.end());\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    void add(string& ans,string s,int index){\\n        if(ans.empty()){\\n            ans = s;\\n            return;\\n        }\\n        string curr = \"\";\\n        int carry = 0;\\n        for(int i=0;;i++){\\n            if(i<index){\\n                curr.push_back(ans[i]);\\n                continue;\\n            }\\n            if(i>=ans.length() and i-index>=s.length())\\n                break;\\n            int a = (i>=ans.length())?0:ans[i]-\\'0\\';\\n            int b = (i-index>=s.length())?0:s[i-index]-\\'0\\';\\n            int rem = (a+b+carry)%10;\\n            carry = (a+b+carry)/10;\\n            curr.push_back(\\'0\\'+rem);\\n        }\\n        while(carry){\\n            curr.push_back(\\'0\\'+carry%10);\\n            carry/=10;\\n        }\\n        ans = curr;\\n    }\\n    string multiply(string s1, string s2) {\\n        if(s1.length()>s2.length())\\n            return multiply(s2,s1);\\n        if(s1==\"0\" or s2==\"0\")\\n            return \"0\";\\n        int n = s1.length(),m = s2.length();\\n        string ans = \"\";\\n        reverse(s1.begin(),s1.end());\\n        reverse(s2.begin(),s2.end());\\n        for(int i=0;i<n;i++){\\n            string s = \"\";\\n            int a = s1[i] - \\'0\\',carry = 0;\\n            for(int j=0;j<m;j++){\\n                int b = s2[j] - \\'0\\';\\n                int curr = a*b + carry;\\n                s.push_back(\\'0\\'+curr%10);\\n                carry = curr/10;\\n            }\\n            while(carry){\\n                s.push_back(\\'0\\'+carry%10);\\n                carry/=10;\\n            }\\n            add(ans,s,i);\\n        }\\n        reverse(ans.begin(),ans.end());\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1490263,
                "title": "c-easy-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    string multiply(string num1, string num2) {\\n        int m = num1.size();\\n        int n = num2.size();\\n        \\n        vector<int> ans((m+n),0);\\n        \\n        for(int i = m-1; i>=0; i--){\\n            for(int j = n-1; j>=0; j--){\\n                int num = (num1[i] - \\'0\\') * (num2[j] - \\'0\\');\\n                int sum = ans[i + j + 1] + num;\\n                ans[i + j] += sum/10;\\n                ans[i + j + 1] = sum%10;\\n            }\\n        }\\n        \\n        string s = \"\";\\n        for(int i=0; i<(m+n); i++){\\n            if(s.length() != 0 || ans[i] != 0){\\n                s += (ans[i] + \\'0\\');\\n            }\\n        }\\n        \\n        if(s.length() == 0){\\n            return \"0\";\\n        }\\n        return s;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string multiply(string num1, string num2) {\\n        int m = num1.size();\\n        int n = num2.size();\\n        \\n        vector<int> ans((m+n),0);\\n        \\n        for(int i = m-1; i>=0; i--){\\n            for(int j = n-1; j>=0; j--){\\n                int num = (num1[i] - \\'0\\') * (num2[j] - \\'0\\');\\n                int sum = ans[i + j + 1] + num;\\n                ans[i + j] += sum/10;\\n                ans[i + j + 1] = sum%10;\\n            }\\n        }\\n        \\n        string s = \"\";\\n        for(int i=0; i<(m+n); i++){\\n            if(s.length() != 0 || ans[i] != 0){\\n                s += (ans[i] + \\'0\\');\\n            }\\n        }\\n        \\n        if(s.length() == 0){\\n            return \"0\";\\n        }\\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1391871,
                "title": "python-solution-that-actually-addresses-the-question",
                "content": "I noticed multiple of the python \\'best\\' answer efectively do: `return str(int(n1)*int(n2))`. This is of course faster to compute, but does not answer the question.\\n\\nThis is what I believe the question asks, for in place manipulation. I also made more readable by reversing the chars to move the carry forward. This does not meaninfully affect the overral time complexity since the reverse operation is O(n)\\n\\n**Time Complexity**: O(n1) + O(n2) + O(n1*n2) + O(n2+n1) -> O(n1*n2)\\n**Space Complexity**: O(n1+n2)\\n\\n\\n```\\nclass Solution:\\n    def multiply(self, n2: str, n1: str) -> str:\\n        n1 = [ord(x)-ord(\\'0\\') for x in n1]\\n        n2 = [ord(x)-ord(\\'0\\') for x in n2]\\n        n1.reverse()\\n        n2.reverse()\\n        l1 = len(n1)\\n        l2 = len(n2)\\n        n = [0] * (l1+l2)\\n        carry = 0\\n        for i in range(l1):\\n            for j in range(l2):\\n                sum = (n1[i] * n2[j]) + n[j+i] + carry\\n                n[j+i] = sum % 10\\n                carry = sum // 10\\n            n[l2+i] += carry\\n            carry=0\\n        \\n        while len(n) > 1 and n[-1] == 0:\\n            n.pop()\\n        \\n        n.reverse()\\n        n = [str(x) for x in n]\\n        return \\'\\'.join(n)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def multiply(self, n2: str, n1: str) -> str:\\n        n1 = [ord(x)-ord(\\'0\\') for x in n1]\\n        n2 = [ord(x)-ord(\\'0\\') for x in n2]\\n        n1.reverse()\\n        n2.reverse()\\n        l1 = len(n1)\\n        l2 = len(n2)\\n        n = [0] * (l1+l2)\\n        carry = 0\\n        for i in range(l1):\\n            for j in range(l2):\\n                sum = (n1[i] * n2[j]) + n[j+i] + carry\\n                n[j+i] = sum % 10\\n                carry = sum // 10\\n            n[l2+i] += carry\\n            carry=0\\n        \\n        while len(n) > 1 and n[-1] == 0:\\n            n.pop()\\n        \\n        n.reverse()\\n        n = [str(x) for x in n]\\n        return \\'\\'.join(n)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 757296,
                "title": "clean-c-solution",
                "content": "```\\nstring multiply(string A, string B) {\\n\\tint l1 = A.size(), l2 = B.size();\\n\\tstring ans(l1+l2,\\'0\\');\\n\\tfor(int i=l1-1; i>=0; i--){\\n\\t\\tfor(int j=l2-1; j>=0; j--){\\n\\t\\t\\tint temp = (A[i]-\\'0\\')*(B[j]-\\'0\\') + (ans[i+j+1] - \\'0\\');\\n\\t\\t\\tans[i+j+1] = temp % 10 + \\'0\\';\\n\\t\\t\\tans[i+j] += temp/10;\\n\\t\\t}\\n  }\\n  for(int i=0; i<l1+l2; i++){\\n\\tif(ans[i] != \\'0\\') // To avoid leading zeroes\\n\\t  return ans.substr(i);\\n  }\\n  return \"0\";\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nstring multiply(string A, string B) {\\n\\tint l1 = A.size(), l2 = B.size();\\n\\tstring ans(l1+l2,\\'0\\');\\n\\tfor(int i=l1-1; i>=0; i--){\\n\\t\\tfor(int j=l2-1; j>=0; j--){\\n\\t\\t\\tint temp = (A[i]-\\'0\\')*(B[j]-\\'0\\') + (ans[i+j+1] - \\'0\\');\\n\\t\\t\\tans[i+j+1] = temp % 10 + \\'0\\';\\n\\t\\t\\tans[i+j] += temp/10;\\n\\t\\t}\\n  }\\n  for(int i=0; i<l1+l2; i++){\\n\\tif(ans[i] != \\'0\\') // To avoid leading zeroes\\n\\t  return ans.substr(i);\\n  }\\n  return \"0\";\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 715653,
                "title": "go-golang-clean-solution",
                "content": ">Runtime: 0 ms, faster than 100.00% of Go online submissions for Multiply Strings.\\nMemory Usage: 2.2 MB, less than 95.83% of Go online submissions for Multiply Strings.\\n\\n```go\\nfunc multiply(num1 string, num2 string) string {\\n    if num1 == \"0\" || num2 == \"0\" { return \"0\" }\\n    ans := make([]byte, len(num1) + len(num2))\\n    for i := range ans { ans[i] = \\'0\\' }\\n    for i := len(num1) - 1; i >= 0; i-- {\\n        for j := len(num2) - 1; j >= 0; j-- {\\n            product := (num1[i] - \\'0\\') * (num2[j] - \\'0\\')\\n            tmp := ans[i + j + 1] - \\'0\\' + product\\n            ans[i + j + 1] = tmp % 10 + \\'0\\'\\n            ans[i + j] = (ans[i + j] - \\'0\\' + tmp / 10) + \\'0\\'\\n        }\\n    }\\n    if ans[0] == \\'0\\' { return string(ans[1:]) }\\n    return string(ans)\\n}\\n```",
                "solutionTags": [],
                "code": "```go\\nfunc multiply(num1 string, num2 string) string {\\n    if num1 == \"0\" || num2 == \"0\" { return \"0\" }\\n    ans := make([]byte, len(num1) + len(num2))\\n    for i := range ans { ans[i] = \\'0\\' }\\n    for i := len(num1) - 1; i >= 0; i-- {\\n        for j := len(num2) - 1; j >= 0; j-- {\\n            product := (num1[i] - \\'0\\') * (num2[j] - \\'0\\')\\n            tmp := ans[i + j + 1] - \\'0\\' + product\\n            ans[i + j + 1] = tmp % 10 + \\'0\\'\\n            ans[i + j] = (ans[i + j] - \\'0\\' + tmp / 10) + \\'0\\'\\n        }\\n    }\\n    if ans[0] == \\'0\\' { return string(ans[1:]) }\\n    return string(ans)\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 529103,
                "title": "golang-solution",
                "content": "```\\nfunc multiply(num1 string, num2 string) string {\\n\\tif num1 == \"0\" || num2 == \"0\" {\\n\\t\\treturn \"0\"\\n\\t}\\n\\tl1, l2 := len(num1), len(num2)\\n\\tres := make([]byte, l1+l2)\\n\\tfor i := l1 - 1; i >= 0; i-- {\\n\\t\\tfor j := l2 - 1; j >= 0; j-- {\\n\\t\\t\\tval := (num1[i] - \\'0\\') * (num2[j] - \\'0\\')\\n\\t\\t\\tres[i+j+1] += val\\n\\t\\t\\tif res[i+j+1] >= 10 {\\n\\t\\t\\t\\tres[i+j] += (res[i+j+1] / 10)\\n\\t\\t\\t\\tres[i+j+1] %= 10\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\tif res[0] == 0 {\\n\\t\\tres = res[1:]\\n\\t}\\n\\tfor i := range res {\\n\\t\\tres[i] += \\'0\\'\\n\\t}\\n\\treturn string(res)\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc multiply(num1 string, num2 string) string {\\n\\tif num1 == \"0\" || num2 == \"0\" {\\n\\t\\treturn \"0\"\\n\\t}\\n\\tl1, l2 := len(num1), len(num2)\\n\\tres := make([]byte, l1+l2)\\n\\tfor i := l1 - 1; i >= 0; i-- {\\n\\t\\tfor j := l2 - 1; j >= 0; j-- {\\n\\t\\t\\tval := (num1[i] - \\'0\\') * (num2[j] - \\'0\\')\\n\\t\\t\\tres[i+j+1] += val\\n\\t\\t\\tif res[i+j+1] >= 10 {\\n\\t\\t\\t\\tres[i+j] += (res[i+j+1] / 10)\\n\\t\\t\\t\\tres[i+j+1] %= 10\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\tif res[0] == 0 {\\n\\t\\tres = res[1:]\\n\\t}\\n\\tfor i := range res {\\n\\t\\tres[i] += \\'0\\'\\n\\t}\\n\\treturn string(res)\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 512848,
                "title": "so-this-question-description-seems-quite-misleading",
                "content": "So at first glance this question seems quite difficult since the requirements state:\\n\\n*You must not use any built-in BigInteger library or convert the inputs to integer directly.*\\n\\nNow at first I though this was going to require some clever bit manipulation using the binary representations of the numbers to solve. \\n\\nThen I read the Discuss and it seems almost everyone just casts either the entire input (which seems illegal) or casts partials of the input (which seems legal with the description given, but cheesy) using some clever iteration.\\n\\nBut if this is really the intended way to solve this question then why can\\'t we just lamely iterate over each digit of the input, cast it and then simply multiply it. Once you do that though it seems like this question is simply asking if we know how to multiply using simple arthimetic.\\n\\n```\\nnum1arr = [int(x) for x in num1.split()]\\nnum2arr = [int(x) for x in num2.split()]\\n\\nnum1int = 0\\nfor i, digit in enumerate(reversed(num1arr)):\\n\\tnum1int += digit * max(1, 10*i)\\n\\nnum2int = 0\\nfor i, digit in enumerate(reversed(num2arr)):\\n\\tnum2int += digit * max(1, 10*i)\\n\\nreturn str(num1int*num2int)\\n```\\n\\nI think this question would really benefit from having a more clearly defined set of requirements.\\n(Unless part of this excercise is actually figuring out that reading the fineprint can matter)",
                "solutionTags": [],
                "code": "```\\nnum1arr = [int(x) for x in num1.split()]\\nnum2arr = [int(x) for x in num2.split()]\\n\\nnum1int = 0\\nfor i, digit in enumerate(reversed(num1arr)):\\n\\tnum1int += digit * max(1, 10*i)\\n\\nnum2int = 0\\nfor i, digit in enumerate(reversed(num2arr)):\\n\\tnum2int += digit * max(1, 10*i)\\n\\nreturn str(num1int*num2int)\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 449394,
                "title": "neat-commented-c-implementation-of-long-multiplication-beats-94-runtime-100-memory",
                "content": "```\\n/*321* 654\\n---------\\n837\\n 886   \\n  065*/\\nstring multiply(string num1, string num2) \\n{\\n\\t// corner case.\\n\\tif (num1 [0] == \\'0\\' || num2 [0] == \\'0\\')    \\n\\t\\treturn \"0\";\\n\\n\\t// reverse() and hence simplified out_idx computation is the \\n\\t// difference between 8ms and 4ms.\\n\\treverse (num1.begin (), num1.end ());\\n\\treverse (num2.begin (), num2.end ());\\n\\n\\t// ret will be populated during push_back() in a reverse fashion.\\n\\tstring ret;\\n\\tint carry = 0;\\n\\n\\t// for each digit in num1,\\n\\tfor (int i = 0; i < num1.size (); i++)\\n\\t{\\n\\t\\t// and in num2\\n\\t\\tfor (int j = 0; j < num2.size (); j++)\\n\\t\\t{\\n\\t\\t\\t// multiply and add carry.\\n\\t\\t\\tint out = to_dig (num1[i]) * to_dig (num2[j]) + carry;\\n\\n\\t\\t\\t// i -> number of places that will be skipped for each intermediate multiple in long multiplication.\\n\\t\\t\\t// j -> target iterator as we walk through each digit in num2.\\n\\t\\t\\tint out_idx = i+j;\\n\\n\\t\\t\\t// if there is a partial result for this place, add out to that place.\\n\\t\\t\\tif (out_idx < ret.length ())\\n\\t\\t\\t{\\n\\t\\t\\t\\tout += to_dig (ret [out_idx]);\\n\\t\\t\\t\\tret [out_idx] = to_char (out % 10);\\n\\t\\t\\t}\\n\\n\\t\\t\\t// else push new digit for that place.\\n\\t\\t\\telse\\n\\t\\t\\t\\tret.push_back (to_char (out % 10));\\n\\n\\t\\t\\t// save the first digit as carry.\\n\\t\\t\\tcarry = out / 10;\\n\\t\\t}\\n\\n\\t\\t// if there is a last carry for this intermediate multiple, push it too.\\n\\t\\t// reset it so that it doesnt get taken in twice.\\n\\t\\tif (carry)\\n\\t\\t{\\n\\t\\t\\tret.push_back (to_char (carry));\\n\\t\\t\\tcarry = 0;\\n\\t\\t}\\n\\t}\\n\\n\\t// reverse as explained before and get out.\\n\\treverse (ret.begin (), ret.end ());\\n\\treturn ret;\\n}\\n\\nint to_dig (char c) { return c - \\'0\\'; }\\nint to_char (int n) { return n + \\'0\\'; }\\n```",
                "solutionTags": [],
                "code": "```\\n/*321* 654\\n---------\\n837\\n 886   \\n  065*/\\nstring multiply(string num1, string num2) \\n{\\n\\t// corner case.\\n\\tif (num1 [0] == \\'0\\' || num2 [0] == \\'0\\')    \\n\\t\\treturn \"0\";\\n\\n\\t// reverse() and hence simplified out_idx computation is the \\n\\t// difference between 8ms and 4ms.\\n\\treverse (num1.begin (), num1.end ());\\n\\treverse (num2.begin (), num2.end ());\\n\\n\\t// ret will be populated during push_back() in a reverse fashion.\\n\\tstring ret;\\n\\tint carry = 0;\\n\\n\\t// for each digit in num1,\\n\\tfor (int i = 0; i < num1.size (); i++)\\n\\t{\\n\\t\\t// and in num2\\n\\t\\tfor (int j = 0; j < num2.size (); j++)\\n\\t\\t{\\n\\t\\t\\t// multiply and add carry.\\n\\t\\t\\tint out = to_dig (num1[i]) * to_dig (num2[j]) + carry;\\n\\n\\t\\t\\t// i -> number of places that will be skipped for each intermediate multiple in long multiplication.\\n\\t\\t\\t// j -> target iterator as we walk through each digit in num2.\\n\\t\\t\\tint out_idx = i+j;\\n\\n\\t\\t\\t// if there is a partial result for this place, add out to that place.\\n\\t\\t\\tif (out_idx < ret.length ())\\n\\t\\t\\t{\\n\\t\\t\\t\\tout += to_dig (ret [out_idx]);\\n\\t\\t\\t\\tret [out_idx] = to_char (out % 10);\\n\\t\\t\\t}\\n\\n\\t\\t\\t// else push new digit for that place.\\n\\t\\t\\telse\\n\\t\\t\\t\\tret.push_back (to_char (out % 10));\\n\\n\\t\\t\\t// save the first digit as carry.\\n\\t\\t\\tcarry = out / 10;\\n\\t\\t}\\n\\n\\t\\t// if there is a last carry for this intermediate multiple, push it too.\\n\\t\\t// reset it so that it doesnt get taken in twice.\\n\\t\\tif (carry)\\n\\t\\t{\\n\\t\\t\\tret.push_back (to_char (carry));\\n\\t\\t\\tcarry = 0;\\n\\t\\t}\\n\\t}\\n\\n\\t// reverse as explained before and get out.\\n\\treverse (ret.begin (), ret.end ());\\n\\treturn ret;\\n}\\n\\nint to_dig (char c) { return c - \\'0\\'; }\\nint to_char (int n) { return n + \\'0\\'; }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 402664,
                "title": "javascript-with-description",
                "content": "\\nhttp://jeffe.cs.illinois.edu/teaching/algorithms/book/00-intro.pdf\\n\\n![image](https://assets.leetcode.com/users/sergiypavlichenko/image_1570816388.png)\\n\\n```\\nvar multiply = function (num1, num2) {\\n    let z = [];\\n    let hold = 0;\\n    let totalLength = num1.length + num2.length;\\n\\n    if (num1 === \\'0\\' || num2 === \\'0\\') {\\n        return \\'0\\';\\n    }\\n\\n    if (num1 === \\'1\\' || num2 === \\'1\\') {\\n        return num1 === \\'1\\'\\n            ? num2\\n            : num1;\\n    }\\n\\n    num1 = num1.split(\\'\\').reverse();\\n    num2 = num2.split(\\'\\').reverse();\\n\\n    for (let k = 0; k < totalLength; k++) {\\n        for (let i = 0; i < num1.length; i++) {\\n            let j = k - i;\\n\\n            if (num2[j]) {\\n                hold = hold + (num1[i] * num2[j]);\\n            }\\n\\n        }\\n\\n        if(k === totalLength -1 && hold === 0){\\n            continue;\\n        }\\n\\n        z[k] = hold % 10;\\n        hold = Math.trunc(hold / 10);\\n    }\\n\\n    return z.reverse().join(\\'\\');\\n};\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar multiply = function (num1, num2) {\\n    let z = [];\\n    let hold = 0;\\n    let totalLength = num1.length + num2.length;\\n\\n    if (num1 === \\'0\\' || num2 === \\'0\\') {\\n        return \\'0\\';\\n    }\\n\\n    if (num1 === \\'1\\' || num2 === \\'1\\') {\\n        return num1 === \\'1\\'\\n            ? num2\\n            : num1;\\n    }\\n\\n    num1 = num1.split(\\'\\').reverse();\\n    num2 = num2.split(\\'\\').reverse();\\n\\n    for (let k = 0; k < totalLength; k++) {\\n        for (let i = 0; i < num1.length; i++) {\\n            let j = k - i;\\n\\n            if (num2[j]) {\\n                hold = hold + (num1[i] * num2[j]);\\n            }\\n\\n        }\\n\\n        if(k === totalLength -1 && hold === 0){\\n            continue;\\n        }\\n\\n        z[k] = hold % 10;\\n        hold = Math.trunc(hold / 10);\\n    }\\n\\n    return z.reverse().join(\\'\\');\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 389802,
                "title": "java-solution",
                "content": "```\\n// Time: O(n*m)\\n// Space: O(n+m)\\n\\nclass Solution {\\n    public String multiply(String num1, String num2) {\\n        int[] res = new int[num1.length() + num2.length()];\\n        for (int i = num1.length() - 1; i >= 0; i--) {\\n            for (int j = num2.length() - 1; j >= 0; j--) {\\n                int product = (num1.charAt(i) - \\'0\\') * (num2.charAt(j) - \\'0\\');\\n                int sum = product + res[i+j+1];\\n                res[i+j+1] = sum%10;\\n                res[i+j] += sum/10;\\n            }\\n        }\\n        StringBuilder sb = new StringBuilder();\\n        for (int digit : res) {\\n            if(!(digit==0 && sb.length()==0)) {\\n                sb.append(digit);\\n            }\\n        }\\n        return sb.length()==0? \"0\": sb.toString();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n// Time: O(n*m)\\n// Space: O(n+m)\\n\\nclass Solution {\\n    public String multiply(String num1, String num2) {\\n        int[] res = new int[num1.length() + num2.length()];\\n        for (int i = num1.length() - 1; i >= 0; i--) {\\n            for (int j = num2.length() - 1; j >= 0; j--) {\\n                int product = (num1.charAt(i) - \\'0\\') * (num2.charAt(j) - \\'0\\');\\n                int sum = product + res[i+j+1];\\n                res[i+j+1] = sum%10;\\n                res[i+j] += sum/10;\\n            }\\n        }\\n        StringBuilder sb = new StringBuilder();\\n        for (int digit : res) {\\n            if(!(digit==0 && sb.length()==0)) {\\n                sb.append(digit);\\n            }\\n        }\\n        return sb.length()==0? \"0\": sb.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 376236,
                "title": "4ms-java-solution-beat-100-on-memory-use",
                "content": "```\\npublic String multiply(String num1, String num2) {    \\n\\t\\t// save time for any multiply with 0\\n\\t\\tif (num1.equals(\"0\") || num2.equals(\"0\")) return \"0\";\\n\\t\\t\\n\\t\\tint m = num1.length(), n = num2.length();\\n        int[] pos = new int[m + n];\\n        \\n        for (int j = n-1; j >= 0; j--) {\\n            for (int i = m-1; i >= 0; i--) {\\n            \\tint sum = (num1.charAt(i) - \\'0\\') * (num2.charAt(j) - \\'0\\') + pos[i+j+1];\\n            \\tpos[i+j+1] = sum % 10;   // update each position\\n            \\tpos[i+j] += sum / 10;   // overflow goes to previous position\\n            }\\n        }       \\n\\n        StringBuilder ans = new StringBuilder();\\n        if (pos[0] != 0) ans.append(pos[0]);\\n        for (int i = 1; i < m + n; i++)  \\n        \\tans.append(pos[i]);\\n        \\n        return ans.toString();\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic String multiply(String num1, String num2) {    \\n\\t\\t// save time for any multiply with 0\\n\\t\\tif (num1.equals(\"0\") || num2.equals(\"0\")) return \"0\";\\n\\t\\t\\n\\t\\tint m = num1.length(), n = num2.length();\\n        int[] pos = new int[m + n];\\n        \\n        for (int j = n-1; j >= 0; j--) {\\n            for (int i = m-1; i >= 0; i--) {\\n            \\tint sum = (num1.charAt(i) - \\'0\\') * (num2.charAt(j) - \\'0\\') + pos[i+j+1];\\n            \\tpos[i+j+1] = sum % 10;   // update each position\\n            \\tpos[i+j] += sum / 10;   // overflow goes to previous position\\n            }\\n        }       \\n\\n        StringBuilder ans = new StringBuilder();\\n        if (pos[0] != 0) ans.append(pos[0]);\\n        for (int i = 1; i < m + n; i++)  \\n        \\tans.append(pos[i]);\\n        \\n        return ans.toString();\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 303612,
                "title": "karatsuba-algorithm",
                "content": "```\\nclass Solution {\\n    public String multiply(String num1, String num2) {\\n        \\n        // rendering to actual numbers for multiplication\\n        String type = \"unequal\";\\n        \\n        int l1 = num1.length();\\n        int l2 = num2.length();\\n        String feed = addstartzeros(num1, num2);\\n        if(l1<l2) num1 = feed;\\n        if(l1>l2) num2 = feed;\\n        \\n       String ans = dudejustmultiply(num1, num2);  \\n      \\n       //if(type==\"unequal\") {\\n           while(ans.charAt(0)==\\'0\\' && ans.length()>1){\\n               ans = ans.substring(1);\\n           } \\n       \\n        return ans;\\n        \\n    }\\n    \\n  \\n    public String dudejustmultiply(String num1, String num2){\\n        \\n        if(num1.length()==1 || num2.length()==1) {  // incase other number in string is greater than max integer value\\n            String max=num1;\\n            String min=num2;\\n            \\n            if(num1.length() ==1) {max = num2; min = num1;}\\n            String sum = \"0\";\\n            for(int i=0;i<Integer.parseInt(min);i++){\\n                sum = addnum(sum,max);\\n            }\\n            // System.out.println(sum);\\n            return sum;\\n        }\\n\\n        \\n        String num1l = num1.substring(0,num1.length()/2);\\n        String num1r = num1.substring(num1.length()/2,num1.length());\\n        \\n        int l1 = num1l.length();\\n        int r1 = num1r.length();\\n        \\n        \\n        String num2l = num2.substring(0,num2.length()/2);\\n        String num2r = num2.substring(num2.length()/2,num2.length());\\n        \\n        int l2 = num2l.length();\\n        int r2 = num2r.length();\\n        \\n\\n        if(l1!=l2) {\\n            String s = addstartzeros(num1l, num2l);\\n            if(l1<l2) num1l = s;\\n            else num2l = s;\\n        } \\n        String p = dudejustmultiply(num1l , num2l);\\n        \\n        if(r1!=r2) {\\n            String sd = addstartzeros(num1r, num2r);\\n            if(r1<r2) num1r = sd;\\n            else num2r = sd;\\n        } \\n        String r = dudejustmultiply(num1r,num2r);\\n        \\n        // for subtraction\\n        String add1 = addnum(num1l,num1r);\\n        String add2 = addnum(num2l,num2r);\\n        int lad1 = add1.length();\\n        int lad2 = add2.length();\\n        if(lad1!=lad2) {\\n            String slad = addstartzeros(add1, add2);\\n            if(lad1<lad2) add1 = slad;\\n            else add2 = slad;\\n        }\\n            \\n        String q = subtract(dudejustmultiply(add1 , add2) , addnum(p,r));\\n        \\n        int l = num1.length();\\n        \\n        if(l%2 != 0) {int k = l/2; \\n                      return addnum(addendzeros(p, 2*(k+1)) , addnum(addendzeros(q,(k + 1)) , r) );\\n                     }\\n        \\n        return addnum(addendzeros(p,l) , addnum(addendzeros(q,l/2) , r));\\n    }\\n    \\n    \\n    public String addendzeros(String a , int num){\\n        for(int i=0;i<num;i++){\\n            a = a + \"0\";\\n        }\\n        return a;\\n    }\\n\\n    public String addnum(String a, String b){\\n        int carry=0;\\n        int la = a.length();\\n        int lb = b.length();\\n        String t = addstartzeros(a,b);\\n        if(la<lb) a = t;\\n        if(lb<la) b = t;\\n        String ans=\"\";\\n        for(int i=a.length()-1;i>=0;i--){\\n            int dummy = carry + Character.getNumericValue(a.charAt(i)) + Character.getNumericValue(b.charAt(i));\\n            if(dummy >= 10) carry = 1; \\n            else carry=0;\\n            ans = String.valueOf(dummy%10) + ans;\\n            \\n        }\\n        if(carry!=0) ans = String.valueOf(carry) + ans;\\n        return ans;\\n    }\\n    \\n    public String subtract(String a, String b){\\n        \\n        int la = a.length();\\n        int lb = b.length();\\n        String dum = addstartzeros(a,b);\\n        if(la<lb) a = dum;\\n        if(lb<la) b = dum;\\n        String ans=\"\";\\n        int i;\\n        int carry=0;\\n        boolean exchange=false;\\n        if(Character.getNumericValue(a.charAt(0))<Character.getNumericValue(b.charAt(0))) {String temp=b;b=a;a=temp;exchange=true;}\\n        \\n        for(i=a.length()-1;i>=0;i--){\\n            \\n            int aint = Character.getNumericValue(a.charAt(i));\\n            int bint = Character.getNumericValue(b.charAt(i));\\n            aint = carry + aint;\\n            if(aint < bint) {\\n                ans  = String.valueOf(10+aint-bint) + ans; \\n                carry = -1;\\n            }\\n            else {\\n                ans = String.valueOf(aint-bint) + ans; \\n                carry=0;\\n            }\\n        }\\n        \\n        if(exchange==true) ans = \"-\" + ans;\\n        return ans;\\n    }\\n    \\n    public String addstartzeros(String a, String b){\\n        \\n        \\n        int l1 = a.length();\\n        int l2 = b.length();\\n        int num =  Math.abs(l1-l2);\\n\\n        if(l1>l2){\\n            \\n            for(int i=0;i<num;i++){\\n                b = \"0\" + b;\\n            }\\n            return b;\\n        }\\n        \\n        else{\\n             \\n            for(int i=0;i<num;i++){\\n                a = \"0\" + a;\\n            }\\n             return a;\\n        }\\n\\n       \\n    }\\n    \\n}\\n        \\n        \\n        \\n        \\n        \\n        \\n        \\n        \\n        \\n        \\n        \\n        \\n        \\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public String multiply(String num1, String num2) {\\n        \\n        // rendering to actual numbers for multiplication\\n        String type = \"unequal\";\\n        \\n        int l1 = num1.length();\\n        int l2 = num2.length();\\n        String feed = addstartzeros(num1, num2);\\n        if(l1<l2) num1 = feed;\\n        if(l1>l2) num2 = feed;\\n        \\n       String ans = dudejustmultiply(num1, num2);  \\n      \\n       //if(type==\"unequal\") {\\n           while(ans.charAt(0)==\\'0\\' && ans.length()>1){\\n               ans = ans.substring(1);\\n           } \\n       \\n        return ans;\\n        \\n    }\\n    \\n  \\n    public String dudejustmultiply(String num1, String num2){\\n        \\n        if(num1.length()==1 || num2.length()==1) {  // incase other number in string is greater than max integer value\\n            String max=num1;\\n            String min=num2;\\n            \\n            if(num1.length() ==1) {max = num2; min = num1;}\\n            String sum = \"0\";\\n            for(int i=0;i<Integer.parseInt(min);i++){\\n                sum = addnum(sum,max);\\n            }\\n            // System.out.println(sum);\\n            return sum;\\n        }\\n\\n        \\n        String num1l = num1.substring(0,num1.length()/2);\\n        String num1r = num1.substring(num1.length()/2,num1.length());\\n        \\n        int l1 = num1l.length();\\n        int r1 = num1r.length();\\n        \\n        \\n        String num2l = num2.substring(0,num2.length()/2);\\n        String num2r = num2.substring(num2.length()/2,num2.length());\\n        \\n        int l2 = num2l.length();\\n        int r2 = num2r.length();\\n        \\n\\n        if(l1!=l2) {\\n            String s = addstartzeros(num1l, num2l);\\n            if(l1<l2) num1l = s;\\n            else num2l = s;\\n        } \\n        String p = dudejustmultiply(num1l , num2l);\\n        \\n        if(r1!=r2) {\\n            String sd = addstartzeros(num1r, num2r);\\n            if(r1<r2) num1r = sd;\\n            else num2r = sd;\\n        } \\n        String r = dudejustmultiply(num1r,num2r);\\n        \\n        // for subtraction\\n        String add1 = addnum(num1l,num1r);\\n        String add2 = addnum(num2l,num2r);\\n        int lad1 = add1.length();\\n        int lad2 = add2.length();\\n        if(lad1!=lad2) {\\n            String slad = addstartzeros(add1, add2);\\n            if(lad1<lad2) add1 = slad;\\n            else add2 = slad;\\n        }\\n            \\n        String q = subtract(dudejustmultiply(add1 , add2) , addnum(p,r));\\n        \\n        int l = num1.length();\\n        \\n        if(l%2 != 0) {int k = l/2; \\n                      return addnum(addendzeros(p, 2*(k+1)) , addnum(addendzeros(q,(k + 1)) , r) );\\n                     }\\n        \\n        return addnum(addendzeros(p,l) , addnum(addendzeros(q,l/2) , r));\\n    }\\n    \\n    \\n    public String addendzeros(String a , int num){\\n        for(int i=0;i<num;i++){\\n            a = a + \"0\";\\n        }\\n        return a;\\n    }\\n\\n    public String addnum(String a, String b){\\n        int carry=0;\\n        int la = a.length();\\n        int lb = b.length();\\n        String t = addstartzeros(a,b);\\n        if(la<lb) a = t;\\n        if(lb<la) b = t;\\n        String ans=\"\";\\n        for(int i=a.length()-1;i>=0;i--){\\n            int dummy = carry + Character.getNumericValue(a.charAt(i)) + Character.getNumericValue(b.charAt(i));\\n            if(dummy >= 10) carry = 1; \\n            else carry=0;\\n            ans = String.valueOf(dummy%10) + ans;\\n            \\n        }\\n        if(carry!=0) ans = String.valueOf(carry) + ans;\\n        return ans;\\n    }\\n    \\n    public String subtract(String a, String b){\\n        \\n        int la = a.length();\\n        int lb = b.length();\\n        String dum = addstartzeros(a,b);\\n        if(la<lb) a = dum;\\n        if(lb<la) b = dum;\\n        String ans=\"\";\\n        int i;\\n        int carry=0;\\n        boolean exchange=false;\\n        if(Character.getNumericValue(a.charAt(0))<Character.getNumericValue(b.charAt(0))) {String temp=b;b=a;a=temp;exchange=true;}\\n        \\n        for(i=a.length()-1;i>=0;i--){\\n            \\n            int aint = Character.getNumericValue(a.charAt(i));\\n            int bint = Character.getNumericValue(b.charAt(i));\\n            aint = carry + aint;\\n            if(aint < bint) {\\n                ans  = String.valueOf(10+aint-bint) + ans; \\n                carry = -1;\\n            }\\n            else {\\n                ans = String.valueOf(aint-bint) + ans; \\n                carry=0;\\n            }\\n        }\\n        \\n        if(exchange==true) ans = \"-\" + ans;\\n        return ans;\\n    }\\n    \\n    public String addstartzeros(String a, String b){\\n        \\n        \\n        int l1 = a.length();\\n        int l2 = b.length();\\n        int num =  Math.abs(l1-l2);\\n\\n        if(l1>l2){\\n            \\n            for(int i=0;i<num;i++){\\n                b = \"0\" + b;\\n            }\\n            return b;\\n        }\\n        \\n        else{\\n             \\n            for(int i=0;i<num;i++){\\n                a = \"0\" + a;\\n            }\\n             return a;\\n        }\\n\\n       \\n    }\\n    \\n}\\n        \\n        \\n        \\n        \\n        \\n        \\n        \\n        \\n        \\n        \\n        \\n        \\n        \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 242546,
                "title": "my-c-8ms-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    string multiply(string num1, string num2) {\\n        string zero = \"0\";\\n        if(num1 == zero || num2 == zero)\\n            return zero;\\n        string mul = \"\";\\n        int size1 = num1.size(), size2 = num2.size(), c = 0;\\n        vector<int> count(size1 + size2 - 1, 0);\\n        for(int i = 0; i < size1; i ++)\\n            for(int j = 0; j < size2; j ++)\\n                count[i + j] += (num1[i] - \\'0\\') * (num2[j] - \\'0\\');\\n        \\n        for(auto i = count.rbegin(); i != count.rend(); i ++){\\n            int tmp = *i + c;\\n            mul.insert(mul.begin(), tmp % 10 + \\'0\\');\\n            c = tmp / 10;\\n        }\\n        if(c)\\n            mul.insert(mul.begin(), c + \\'0\\');\\n        return mul;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string multiply(string num1, string num2) {\\n        string zero = \"0\";\\n        if(num1 == zero || num2 == zero)\\n            return zero;\\n        string mul = \"\";\\n        int size1 = num1.size(), size2 = num2.size(), c = 0;\\n        vector<int> count(size1 + size2 - 1, 0);\\n        for(int i = 0; i < size1; i ++)\\n            for(int j = 0; j < size2; j ++)\\n                count[i + j] += (num1[i] - \\'0\\') * (num2[j] - \\'0\\');\\n        \\n        for(auto i = count.rbegin(); i != count.rend(); i ++){\\n            int tmp = *i + c;\\n            mul.insert(mul.begin(), tmp % 10 + \\'0\\');\\n            c = tmp / 10;\\n        }\\n        if(c)\\n            mul.insert(mul.begin(), c + \\'0\\');\\n        return mul;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 17694,
                "title": "3ms-java-solution-beats-100",
                "content": "    public class Solution {\\n        public String multiply(String num1, String num2) {\\n            int m=num1.length(), n=num2.length(), zero=0;\\n            int[] a = new int[m], c = new int[m+n];\\n            for(int i=0,k=m; i<m; i++) a[--k]=num1.charAt(i)-'0';  // reverse the first number\\n            for(int i=n-1; i>=0; i--)\\n                add(c,a,num2.charAt(i)-'0',zero++);    // multiply each digits of num2 to num1\\n            carry(c);            // handle all carry operation together\\n            int i=m+n;\\n            while(i>0 && c[--i]==0);  // find the highest digit\\n            i++;\\n            StringBuilder ret = new StringBuilder(i);\\n            while(i>0) ret.append((char)(c[--i]+'0'));\\n            return ret.toString();\\n        }\\n        void carry(int[] a){\\n            int i;\\n            for(int k=0,d=0; k<a.length; k++){\\n                i=a[k]+d;\\n                a[k]=i%10;\\n                d=i/10;\\n            }\\n        }\\n        void add(int[] c, int[] a, int b, int zero){\\n            for(int i=zero,j=0; j<a.length; j++,i++)\\n                c[i]+=a[j]*b;\\n        }\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n        public String multiply(String num1, String num2) {\\n            int m=num1.length(), n=num2.length(), zero=0;\\n            int[] a = new int[m], c = new int[m+n];\\n            for(int i=0,k=m; i<m; i++) a[--k]=num1.charAt(i)-'0';  // reverse the first number\\n            for(int i=n-1; i>=0; i--)\\n                add(c,a,num2.charAt(i)-'0',zero++);    // multiply each digits of num2 to num1\\n            carry(c);            // handle all carry operation together\\n            int i=m+n;\\n            while(i>0 && c[--i]==0);  // find the highest digit\\n            i++;\\n            StringBuilder ret = new StringBuilder(i);\\n            while(i>0) ret.append((char)(c[--i]+'0'));\\n            return ret.toString();\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3855507,
                "title": "c-using-base-1e9-to-multiply-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThis code implements a multiplication operation for large numbers represented as strings. It converts the strings to vectors of integers, where each integer represents a chunk of 9 digits. The multiplication is performed on these vector representations, and the result is converted back to a string. The code uses long long data type to handle intermediate results during the multiplication process, ensuring accurate results for large numbers.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    const int base = 1e9;\\n    vector<int> convert(string& num){\\n        int len = num.size();\\n        int sz = (len - 1) / 9 + 1; // Calculate the size of the ans vector\\n        vector<int> ans(sz, 0);\\n        int idx = 0, tenPow = 1;\\n        for (int i = len-1; i>= 0; i--){\\n            ans[idx] += tenPow*(num[i]-\\'0\\');\\n            tenPow *= 10;\\n            if (tenPow == base){\\n                idx++;\\n                tenPow = 1;\\n            }\\n        }\\n        return ans;\\n    }\\n\\n    vector<int> mult(vector<int>& x, vector<int>& y){\\n        int x_len = x.size(), y_len = y.size();\\n        int len = x_len + y_len;\\n        vector<int> z(len);\\n        long long carry = 0; // Change to long long\\n        for (int i = 0; i < len; i++){\\n            long long sum = carry;\\n            int j0 = min(y_len, i + 1);\\n            for (int j = max(0, i-x_len+1); j < j0; j++){\\n                sum += (long long)x[i-j] * y[j];\\n            }\\n            auto d=lldiv(sum , base);\\n            carry = d.quot;\\n            z[i] = d.rem;\\n        }\\n        if (z.size() > 1 && z.back() == 0) z.pop_back(); // Remove trailing zeros.\\n        return z;\\n    }\\n\\n    string to_str(vector<int> z){\\n        int sz = z.size();\\n        string ans = to_string(z[sz - 1]);\\n        for (int i = sz - 2; i >= 0; i--){\\n            string tmp = to_string(z[i]);\\n            int l = tmp.size();\\n            tmp = string(9 - l, \\'0\\') + tmp;\\n            ans += tmp;\\n        }\\n        return ans;\\n    }\\n\\n    string multiply(string num1, string num2) {\\n        vector<int> x = convert(num1);\\n        vector<int> y = convert(num2);\\n        vector<int> z = mult(x, y);\\n        return to_str(z);\\n    }\\n};\\n\\n```\\n# Code with Explanation in comments\\n```\\nclass Solution {\\npublic:\\n    const int base = 1e9; // Base to represent chunks of 9 digits\\n\\n    vector<int> convert(string& num){\\n        int len = num.size();\\n        int sz = (len - 1) / 9 + 1; // Calculate the size of the ans vector to store chunks of 9 digits\\n        vector<int> ans(sz, 0); // Initialize the ans vector with zeros\\n        int idx = 0, tenPow = 1; // Initialize index and a variable for powers of 10\\n        for (int i = len - 1; i >= 0; i--){\\n            ans[idx] += tenPow * (num[i] - \\'0\\'); // Convert the character to integer and add it to the appropriate chunk\\n            tenPow *= 10; // Increase the power of 10 for the next iteration\\n            if (tenPow == base){ // If the current chunk is full (i.e., reached base)\\n                idx++; // Move to the next chunk\\n                tenPow = 1; // Reset the power of 10\\n            }\\n        }\\n        return ans;\\n    }\\n\\n    vector<int> mult(vector<int>& x, vector<int>& y){\\n        int x_len = x.size(), y_len = y.size();\\n        int len = x_len + y_len; // Calculate the length of the resulting vector after multiplication\\n        vector<int> z(len); // Initialize the resulting vector with zeros\\n        long long carry = 0; // Use long long to handle large intermediate results\\n        for (int i = 0; i < len; i++){\\n            long long sum = carry; // Initialize the sum with the carry from the previous iteration\\n            int j0 = min(y_len, i + 1); // Define the bound of the inner loop\\n            for (int j = max(0, i - x_len + 1); j < j0; j++){ // Iterate through appropriate elements of x and y vectors\\n                sum += (long long)x[i - j] * y[j]; // Multiply corresponding elements and add to the sum\\n            }\\n            auto d = lldiv(sum, base); // Perform a long division of sum by base to get quotient and remainder\\n            carry = d.quot; // Set the carry for the next iteration\\n            z[i] = d.rem; // Store the remainder in the resulting vector\\n        }\\n        if (z.size() > 1 && z.back() == 0) z.pop_back(); // Remove trailing zeros from the resulting vector\\n        return z;\\n    }\\n\\n    string to_str(vector<int> z){\\n        int sz = z.size();\\n        string ans = to_string(z[sz - 1]); // Initialize the answer with the most significant chunk\\n        for (int i = sz - 2; i >= 0; i--){\\n            string tmp = to_string(z[i]); // Convert the current chunk to string\\n            int l = tmp.size();\\n            tmp = string(9 - l, \\'0\\') + tmp; // Add leading zeros to non-most significant chunks\\n            ans += tmp; // Concatenate the current chunk to the answer\\n        }\\n        return ans;\\n    }\\n\\n    string multiply(string num1, string num2) {\\n        vector<int> x = convert(num1); // Convert the first number to vector representation\\n        vector<int> y = convert(num2); // Convert the second number to vector representation\\n        vector<int> z = mult(x, y); // Multiply the two vectors\\n        return to_str(z); // Convert the resulting vector back to string representation\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Math",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    const int base = 1e9;\\n    vector<int> convert(string& num){\\n        int len = num.size();\\n        int sz = (len - 1) / 9 + 1; // Calculate the size of the ans vector\\n        vector<int> ans(sz, 0);\\n        int idx = 0, tenPow = 1;\\n        for (int i = len-1; i>= 0; i--){\\n            ans[idx] += tenPow*(num[i]-\\'0\\');\\n            tenPow *= 10;\\n            if (tenPow == base){\\n                idx++;\\n                tenPow = 1;\\n            }\\n        }\\n        return ans;\\n    }\\n\\n    vector<int> mult(vector<int>& x, vector<int>& y){\\n        int x_len = x.size(), y_len = y.size();\\n        int len = x_len + y_len;\\n        vector<int> z(len);\\n        long long carry = 0; // Change to long long\\n        for (int i = 0; i < len; i++){\\n            long long sum = carry;\\n            int j0 = min(y_len, i + 1);\\n            for (int j = max(0, i-x_len+1); j < j0; j++){\\n                sum += (long long)x[i-j] * y[j];\\n            }\\n            auto d=lldiv(sum , base);\\n            carry = d.quot;\\n            z[i] = d.rem;\\n        }\\n        if (z.size() > 1 && z.back() == 0) z.pop_back(); // Remove trailing zeros.\\n        return z;\\n    }\\n\\n    string to_str(vector<int> z){\\n        int sz = z.size();\\n        string ans = to_string(z[sz - 1]);\\n        for (int i = sz - 2; i >= 0; i--){\\n            string tmp = to_string(z[i]);\\n            int l = tmp.size();\\n            tmp = string(9 - l, \\'0\\') + tmp;\\n            ans += tmp;\\n        }\\n        return ans;\\n    }\\n\\n    string multiply(string num1, string num2) {\\n        vector<int> x = convert(num1);\\n        vector<int> y = convert(num2);\\n        vector<int> z = mult(x, y);\\n        return to_str(z);\\n    }\\n};\\n\\n```\n```\\nclass Solution {\\npublic:\\n    const int base = 1e9; // Base to represent chunks of 9 digits\\n\\n    vector<int> convert(string& num){\\n        int len = num.size();\\n        int sz = (len - 1) / 9 + 1; // Calculate the size of the ans vector to store chunks of 9 digits\\n        vector<int> ans(sz, 0); // Initialize the ans vector with zeros\\n        int idx = 0, tenPow = 1; // Initialize index and a variable for powers of 10\\n        for (int i = len - 1; i >= 0; i--){\\n            ans[idx] += tenPow * (num[i] - \\'0\\'); // Convert the character to integer and add it to the appropriate chunk\\n            tenPow *= 10; // Increase the power of 10 for the next iteration\\n            if (tenPow == base){ // If the current chunk is full (i.e., reached base)\\n                idx++; // Move to the next chunk\\n                tenPow = 1; // Reset the power of 10\\n            }\\n        }\\n        return ans;\\n    }\\n\\n    vector<int> mult(vector<int>& x, vector<int>& y){\\n        int x_len = x.size(), y_len = y.size();\\n        int len = x_len + y_len; // Calculate the length of the resulting vector after multiplication\\n        vector<int> z(len); // Initialize the resulting vector with zeros\\n        long long carry = 0; // Use long long to handle large intermediate results\\n        for (int i = 0; i < len; i++){\\n            long long sum = carry; // Initialize the sum with the carry from the previous iteration\\n            int j0 = min(y_len, i + 1); // Define the bound of the inner loop\\n            for (int j = max(0, i - x_len + 1); j < j0; j++){ // Iterate through appropriate elements of x and y vectors\\n                sum += (long long)x[i - j] * y[j]; // Multiply corresponding elements and add to the sum\\n            }\\n            auto d = lldiv(sum, base); // Perform a long division of sum by base to get quotient and remainder\\n            carry = d.quot; // Set the carry for the next iteration\\n            z[i] = d.rem; // Store the remainder in the resulting vector\\n        }\\n        if (z.size() > 1 && z.back() == 0) z.pop_back(); // Remove trailing zeros from the resulting vector\\n        return z;\\n    }\\n\\n    string to_str(vector<int> z){\\n        int sz = z.size();\\n        string ans = to_string(z[sz - 1]); // Initialize the answer with the most significant chunk\\n        for (int i = sz - 2; i >= 0; i--){\\n            string tmp = to_string(z[i]); // Convert the current chunk to string\\n            int l = tmp.size();\\n            tmp = string(9 - l, \\'0\\') + tmp; // Add leading zeros to non-most significant chunks\\n            ans += tmp; // Concatenate the current chunk to the answer\\n        }\\n        return ans;\\n    }\\n\\n    string multiply(string num1, string num2) {\\n        vector<int> x = convert(num1); // Convert the first number to vector representation\\n        vector<int> y = convert(num2); // Convert the second number to vector representation\\n        vector<int> z = mult(x, y); // Multiply the two vectors\\n        return to_str(z); // Convert the resulting vector back to string representation\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3771576,
                "title": "python-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution(object):\\n    def multiply(self, num1, num2):\\n        return(str(eval(num1+\"*\"+num2)))\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def multiply(self, num1, num2):\\n        return(str(eval(num1+\"*\"+num2)))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3113862,
                "title": "python3-beats-96-57-one-liner-beginner-solution",
                "content": "# Code\\n```\\nclass Solution:\\n    def multiply(self, num1: str, num2: str) -> str:\\n        return str(int(num1)*int(num2))\\n```\\n# Please do upvote if you like the solution.",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def multiply(self, num1: str, num2: str) -> str:\\n        return str(int(num1)*int(num2))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3053994,
                "title": "python3-multiply-strings-with-graph-explanation",
                "content": "# Approach\\nIt\\'s the process of multiplying two integers:\\n![image.png](https://assets.leetcode.com/users/images/cffd288b-2cb8-49d0-94a5-76cec5bec3f5_1673775934.4892273.png)\\n\\nAs we can see, each time we will multiply a bit of integer with the bit of another integer, and in the last step, we will add up all multiply results and get the final results.\\n\\nThe tricky part is to find out the relation between nums index and result index. In fact, if we try to draw an example, we can easily find that if we multiple nums1[i] with nums2[j], the multiply result of the two integers will be put into res[i+j] and res[i+j+1].\\nTherefore, we can use two pointers to traverse the two nums list and assign the multiply results to the result list.\\n![image.png](https://assets.leetcode.com/users/images/072ca36f-1dd3-4fb8-9ad3-47aba6d5f18b_1673775956.7915914.png)\\n\\n\\n# Complexity\\n- Time complexity: O(m * n), where m=len(nums1) and n=len(nums2)\\n\\n- Space complexity: O(m + n), where m=len(nums1) and n=len(nums2)\\n\\n# Code\\n```Python3 []\\nclass Solution:\\n    def multiply(self, num1: str, num2: str) -> str:\\n        # Method: Multiply strings by each single character\\n        # Time: O(m * n). Space: O(m+n)\\n        if num1 == \\'0\\' or num2 == \\'0\\':\\n            return \\'0\\'\\n        m, n = len(num1), len(num2)\\n        res = [0] * (m+n)\\n        for i in range(m-1, -1, -1):\\n            for j in range(n-1, -1, -1):\\n                p1, p2 = i+j, i+j+1\\n                cur_mul = int(num1[i]) * int(num2[j])\\n                cur_sum = cur_mul + res[p2]\\n                res[p2] = cur_sum % 10\\n                res[p1] += cur_sum // 10\\n        # Ignore the prefix zero\\n        index = 0\\n        while index <= len(res)-1 and res[index] == 0:\\n            index += 1\\n        return \\'\\'.join(str(num) for num in res[index:])\\n```",
                "solutionTags": [
                    "Python3",
                    "Two Pointers"
                ],
                "code": "```Python3 []\\nclass Solution:\\n    def multiply(self, num1: str, num2: str) -> str:\\n        # Method: Multiply strings by each single character\\n        # Time: O(m * n). Space: O(m+n)\\n        if num1 == \\'0\\' or num2 == \\'0\\':\\n            return \\'0\\'\\n        m, n = len(num1), len(num2)\\n        res = [0] * (m+n)\\n        for i in range(m-1, -1, -1):\\n            for j in range(n-1, -1, -1):\\n                p1, p2 = i+j, i+j+1\\n                cur_mul = int(num1[i]) * int(num2[j])\\n                cur_sum = cur_mul + res[p2]\\n                res[p2] = cur_sum % 10\\n                res[p1] += cur_sum // 10\\n        # Ignore the prefix zero\\n        index = 0\\n        while index <= len(res)-1 and res[index] == 0:\\n            index += 1\\n        return \\'\\'.join(str(num) for num in res[index:])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2682789,
                "title": "simple-java-solution",
                "content": "```\\n public String multiply(String num1, String num2) {\\n\\t\\tint[] ans = new int[num1.length() + num2.length()];\\n\\t\\tfor (int i = num1.length() - 1; i >= 0; i--) {\\n\\t\\t\\tfor (int j = num2.length() - 1; j >= 0; j--) {\\n\\t\\t\\t\\tans[i + j + 1] += (num1.charAt(i) - \\'0\\') * (num2.charAt(j) - \\'0\\');\\n\\t\\t\\t\\tans[i + j] += ans[i + j + 1] / 10;\\n\\t\\t\\t\\tans[i + j + 1] = ans[i + j + 1] % 10;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tint i = 0;\\n\\t\\twhile (i < ans.length && ans[i] == 0) {\\n\\t\\t\\ti++;\\n\\t\\t}\\n        StringBuilder sb = new StringBuilder();\\n\\t\\twhile (i < ans.length) {\\n\\t\\t\\tsb.append(ans[i]);\\n\\t\\t\\ti++;\\n\\t\\t}\\n\\t\\treturn sb.length() == 0 ? \"0\" : sb.toString();\\n\\t}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n public String multiply(String num1, String num2) {\\n\\t\\tint[] ans = new int[num1.length() + num2.length()];\\n\\t\\tfor (int i = num1.length() - 1; i >= 0; i--) {\\n\\t\\t\\tfor (int j = num2.length() - 1; j >= 0; j--) {\\n\\t\\t\\t\\tans[i + j + 1] += (num1.charAt(i) - \\'0\\') * (num2.charAt(j) - \\'0\\');\\n\\t\\t\\t\\tans[i + j] += ans[i + j + 1] / 10;\\n\\t\\t\\t\\tans[i + j + 1] = ans[i + j + 1] % 10;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tint i = 0;\\n\\t\\twhile (i < ans.length && ans[i] == 0) {\\n\\t\\t\\ti++;\\n\\t\\t}\\n        StringBuilder sb = new StringBuilder();\\n\\t\\twhile (i < ans.length) {\\n\\t\\t\\tsb.append(ans[i]);\\n\\t\\t\\ti++;\\n\\t\\t}\\n\\t\\treturn sb.length() == 0 ? \"0\" : sb.toString();\\n\\t}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2395586,
                "title": "java-beat-85-solution",
                "content": "1. Need to know that  n1[i] * n2[j] need to be put into res[i+j] and res[i+j+1] based on observation\\n2. Need to add with previous calculated result, and consider carrier.\\n```\\n    public String multiply(String num1, String num2) {\\n        int m = num1.length(), n = num2.length();\\n        int[] res = new int[m + n];\\n        \\n        //calculate from low to high\\n        for(int i = m - 1; i >= 0; i--){\\n            for(int j = n - 1; j >= 0; j--) {\\n                //p2 is the lower position\\n                //n1[i] * n2[j] need to be put into res[i+j] and res[i+j+1]\\n                int hi = i + j, lo = i + j + 1;\\n                //new value should be added into cooresponding position of previous computation\\n                int mul = getDigit(num1, i) * getDigit(num2, j) + res[lo];\\n                res[hi] += mul / 10;\\n                res[lo] = mul % 10;\\n            }\\n        }\\n        //deal with leading 0s\\n        int i = 0;\\n        while(i < m + n && res[i] == 0) {\\n            i++;\\n        }\\n        \\n        StringBuilder sb = new StringBuilder();\\n        for(; i < m + n; i++) {\\n            sb.append(res[i]);\\n        }\\n        return sb.length() == 0 ? \"0\" : sb.toString();\\n    }\\n    \\n    private int getDigit(String s, int i) {\\n        return s.charAt(i) - \\'0\\';\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "```\\n    public String multiply(String num1, String num2) {\\n        int m = num1.length(), n = num2.length();\\n        int[] res = new int[m + n];\\n        \\n        //calculate from low to high\\n        for(int i = m - 1; i >= 0; i--){\\n            for(int j = n - 1; j >= 0; j--) {\\n                //p2 is the lower position\\n                //n1[i] * n2[j] need to be put into res[i+j] and res[i+j+1]\\n                int hi = i + j, lo = i + j + 1;\\n                //new value should be added into cooresponding position of previous computation\\n                int mul = getDigit(num1, i) * getDigit(num2, j) + res[lo];\\n                res[hi] += mul / 10;\\n                res[lo] = mul % 10;\\n            }\\n        }\\n        //deal with leading 0s\\n        int i = 0;\\n        while(i < m + n && res[i] == 0) {\\n            i++;\\n        }\\n        \\n        StringBuilder sb = new StringBuilder();\\n        for(; i < m + n; i++) {\\n            sb.append(res[i]);\\n        }\\n        return sb.length() == 0 ? \"0\" : sb.toString();\\n    }\\n    \\n    private int getDigit(String s, int i) {\\n        return s.charAt(i) - \\'0\\';\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2379573,
                "title": "c-solution-comments-2ms-fast-than-97",
                "content": "```\\nclass Solution {\\npublic:\\n    string multiply(string num1, string num2) {\\n        if (num1 == \"0\" || num2 == \"0\") {\\n            return \"0\";\\n        }\\n        \\n        // Reverse num1 and num2.\\n        reverse(num1.begin(), num1.end());\\n        reverse(num2.begin(), num2.end());\\n        \\n        // Initialize answer as a string of zeros of length N.\\n        int N = num1.size() + num2.size();\\n        string answer(N, \\'0\\');\\n        \\n        for (int place2 = 0; place2 < num2.size(); place2++) {\\n            int digit2 = num2[place2] - \\'0\\';\\n            \\n            // For each digit in num2 multiply the digit by all digits in num1.\\n            for (int place1 = 0; place1 < num1.size(); place1++) {\\n                int digit1 = num1[place1] - \\'0\\';\\n                \\n                // The number of zeros from multiplying to digits depends on the \\n                // place of digit2 in num2 and the place of the digit1 in num1.\\n                int numZeros = place1 + place2;\\n                \\n                // The digit currently at position numZeros in the answer string\\n                // is carried over and summed with the current result.\\n                int carry = answer[numZeros] - \\'0\\';\\n                int multiplication = digit1 * digit2 + carry;\\n                \\n                // Set the ones place of the multiplication result.\\n                answer[numZeros] = (multiplication % 10) + \\'0\\';\\n                \\n                // Carry the tens place of the multiplication result by \\n                // adding it to the next position in the answer array.\\n                answer[numZeros + 1] += (multiplication / 10);\\n            }\\n        }\\n        \\n        if (answer.back() == \\'0\\') {\\n            answer.pop_back();\\n        }\\n        reverse(answer.begin(), answer.end());\\n        return answer;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string multiply(string num1, string num2) {\\n        if (num1 == \"0\" || num2 == \"0\") {\\n            return \"0\";\\n        }\\n        \\n        // Reverse num1 and num2.\\n        reverse(num1.begin(), num1.end());\\n        reverse(num2.begin(), num2.end());\\n        \\n        // Initialize answer as a string of zeros of length N.\\n        int N = num1.size() + num2.size();\\n        string answer(N, \\'0\\');\\n        \\n        for (int place2 = 0; place2 < num2.size(); place2++) {\\n            int digit2 = num2[place2] - \\'0\\';\\n            \\n            // For each digit in num2 multiply the digit by all digits in num1.\\n            for (int place1 = 0; place1 < num1.size(); place1++) {\\n                int digit1 = num1[place1] - \\'0\\';\\n                \\n                // The number of zeros from multiplying to digits depends on the \\n                // place of digit2 in num2 and the place of the digit1 in num1.\\n                int numZeros = place1 + place2;\\n                \\n                // The digit currently at position numZeros in the answer string\\n                // is carried over and summed with the current result.\\n                int carry = answer[numZeros] - \\'0\\';\\n                int multiplication = digit1 * digit2 + carry;\\n                \\n                // Set the ones place of the multiplication result.\\n                answer[numZeros] = (multiplication % 10) + \\'0\\';\\n                \\n                // Carry the tens place of the multiplication result by \\n                // adding it to the next position in the answer array.\\n                answer[numZeros + 1] += (multiplication / 10);\\n            }\\n        }\\n        \\n        if (answer.back() == \\'0\\') {\\n            answer.pop_back();\\n        }\\n        reverse(answer.begin(), answer.end());\\n        return answer;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2284595,
                "title": "my-clean-javascript-solution",
                "content": "```\\nfunction multiply(a, b) {\\n    // any zero\\n    if ([a, b].includes(`0`)) {\\n        return `0`\\n    }\\n\\n    // get length of a, b\\n    const [lenA, lenB] = [a.length, b.length]\\n\\n    // set nums for calculate\\n    let nums = Array(lenA + lenB).fill(0), index = nums.length - 1\\n\\n    // reverse loop from a\\n    for (let i = lenA - 1; i >= 0; i--) {\\n        let key = index--\\n\\n        // reverse loop from b\\n        for (let j = lenB - 1; j >= 0; j--) {\\n            const v = +a[i] * +b[j] + nums[key]\\n\\n            // current\\n            nums[key] = v % 10\\n            // carry\\n            nums[--key] += Math.floor(v / 10)\\n        }\\n    }\\n\\n    // remove `0` noneed\\n    return nums.join(\\'\\').replace(/^0+/, \\'\\')\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nfunction multiply(a, b) {\\n    // any zero\\n    if ([a, b].includes(`0`)) {\\n        return `0`\\n    }\\n\\n    // get length of a, b\\n    const [lenA, lenB] = [a.length, b.length]\\n\\n    // set nums for calculate\\n    let nums = Array(lenA + lenB).fill(0), index = nums.length - 1\\n\\n    // reverse loop from a\\n    for (let i = lenA - 1; i >= 0; i--) {\\n        let key = index--\\n\\n        // reverse loop from b\\n        for (let j = lenB - 1; j >= 0; j--) {\\n            const v = +a[i] * +b[j] + nums[key]\\n\\n            // current\\n            nums[key] = v % 10\\n            // carry\\n            nums[--key] += Math.floor(v / 10)\\n        }\\n    }\\n\\n    // remove `0` noneed\\n    return nums.join(\\'\\').replace(/^0+/, \\'\\')\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2278024,
                "title": "multiply-strings-c-easy-to-understand-explanation-with-comments",
                "content": "```\\nstring multiply(string num1, string num2) {\\n        // handle edge-case where the product is 0\\n        if (num1 == \"0\" || num2 == \"0\") return \"0\";\\n        \\n        // num1.size() + num2.size() == max no. of digits\\n        vector<int> num(num1.size() + num2.size(), 0);\\n        \\n        // build the number by multiplying one digit at the time\\n        for (int i = num1.size() - 1; i >= 0; --i) {\\n            for (int j = num2.size() - 1; j >= 0; --j) {\\n                num[i + j + 1] += (num1[i] - \\'0\\') * (num2[j] - \\'0\\');\\n                num[i + j] += num[i + j + 1] / 10;\\n                num[i + j + 1] %= 10;\\n            }\\n        }\\n        \\n        // skip leading 0\\'s\\n        int i = 0;\\n        while (i < num.size() && num[i] == 0) ++i;\\n        \\n        // transofrm the vector to a string\\n        string res = \"\";\\n        while (i < num.size()) res.push_back(num[i++] + \\'0\\');\\n        \\n        return res;\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nstring multiply(string num1, string num2) {\\n        // handle edge-case where the product is 0\\n        if (num1 == \"0\" || num2 == \"0\") return \"0\";\\n        \\n        // num1.size() + num2.size() == max no. of digits\\n        vector<int> num(num1.size() + num2.size(), 0);\\n        \\n        // build the number by multiplying one digit at the time\\n        for (int i = num1.size() - 1; i >= 0; --i) {\\n            for (int j = num2.size() - 1; j >= 0; --j) {\\n                num[i + j + 1] += (num1[i] - \\'0\\') * (num2[j] - \\'0\\');\\n                num[i + j] += num[i + j + 1] / 10;\\n                num[i + j + 1] %= 10;\\n            }\\n        }\\n        \\n        // skip leading 0\\'s\\n        int i = 0;\\n        while (i < num.size() && num[i] == 0) ++i;\\n        \\n        // transofrm the vector to a string\\n        string res = \"\";\\n        while (i < num.size()) res.push_back(num[i++] + \\'0\\');\\n        \\n        return res;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1990835,
                "title": "java-c-python-javascript-kotlin-swift-o-n-time-beats-99-97-memory-speed-0ms-april-2022",
                "content": "***Hello it would be my pleasure to introduce myself Darian.***\\n\\n***Java***\\n```\\npublic String multiply(String num1, String num2) {\\n    int m = num1.length(), n = num2.length();\\n    int[] pos = new int[m + n];\\n   \\n    for(int i = m - 1; i >= 0; i--) {\\n        for(int j = n - 1; j >= 0; j--) {\\n            int mul = (num1.charAt(i) - \\'0\\') * (num2.charAt(j) - \\'0\\'); \\n            int p1 = i + j, p2 = i + j + 1;\\n            int sum = mul + pos[p2];\\n\\n            pos[p1] += sum / 10;\\n            pos[p2] = (sum) % 10;\\n        }\\n    }  \\n    \\n    StringBuilder sb = new StringBuilder();\\n    for(int p : pos) if(!(sb.length() == 0 && p == 0)) sb.append(p);\\n    return sb.length() == 0 ? \"0\" : sb.toString();\\n}\\n```\\n\\n***C++***\\n```\\nclass Solution {\\npublic:\\n    string multiply(string num1, string num2) {\\n        // handle edge-case where the product is 0\\n        if (num1 == \"0\" || num2 == \"0\") return \"0\";\\n        \\n        // num1.size() + num2.size() == max no. of digits\\n        vector<int> num(num1.size() + num2.size(), 0);\\n        \\n        // build the number by multiplying one digit at the time\\n        for (int i = num1.size() - 1; i >= 0; --i) {\\n            for (int j = num2.size() - 1; j >= 0; --j) {\\n                num[i + j + 1] += (num1[i] - \\'0\\') * (num2[j] - \\'0\\');\\n                num[i + j] += num[i + j + 1] / 10;\\n                num[i + j + 1] %= 10;\\n            }\\n        }\\n        \\n        // skip leading 0\\'s\\n        int i = 0;\\n        while (i < num.size() && num[i] == 0) ++i;\\n        \\n        // transofrm the vector to a string\\n        string res = \"\";\\n        while (i < num.size()) res.push_back(num[i++] + \\'0\\');\\n        \\n        return res;\\n    }\\n};\\n```\\n\\n***Python***\\n```\\nclass Solution:\\n    def multiply(self, num1: str, num2: str) -> str:\\n        return str(self.strint(num1)*self.strint(num2))\\n    def strint(self,n):\\n        result=0\\n        for i in range(len(n)):\\n            result = result*10 + ord(n[i])-ord(\\'0\\')\\n        return result\\n```\\n\\n***JavaScript***\\n```\\nconst multiply = function(num1, num2) {\\n    const dp = [...Array(num1.length+num2.length)].fill(0); \\n    for(let i = num1.length-1; i >= 0; i--){\\n      for(let j = num2.length-1; j >= 0; j--){\\n\\t  \\n\\t  //Define\\n\\t\\tconst prevRemainder  = dp[i+j+1] \\n        const product = num1[i]*num2[j]+prevRemainder\\n        const unitsDigit = product%10\\n        const carryOver = Math.floor(product/10)\\n\\t\\t\\t\\n\\t\\t//Update\\n        dp[i+j+1] = unitsDigit;\\n\\t\\tdp[i+j] += carryOver\\n       }\\n    }\\n    \\n    //Delete leading-zeroes\\n    let idx = 0\\n    while(dp[idx] === 0) dp.shift()\\n    if(!dp.length) return \"0\"\\n    return dp.join(\"\") \\n};\\n```\\n\\n***Kotlin***\\n```\\nfun multiply(num1: String, num2: String): String {\\n    if (num1 == \"0\" || num2 == \"0\") return \"0\"\\n    \\n    val num1 = StringBuilder(num1).reversed().toString()\\n    val num2 = StringBuilder(num2).reversed().toString()\\n    val len1 = num1.length; val len2 = num2.length\\n    \\n    val sums = IntArray(len1 + len2)\\n    \\n    for (i in 0..len1 - 1) {\\n        val a = num1[i] - \\'0\\'\\n        for (j in 0..len2 - 1) {\\n            val b = num2[j] - \\'0\\'\\n            sums[i + j] += a * b\\n        }\\n    }\\n\\n    val res = StringBuilder()\\n    var carry = 0\\n    \\n    for (sum in sums) {\\n        val num = (sum + carry) % 10\\n        carry = (sum + carry) / 10\\n        res.append(num)\\n    }\\n\\n    if (res.last() == \\'0\\') res.deleteCharAt(res.length - 1)\\n    return res.reversed().toString()\\n}\\n```\\n\\n***Swift***\\n```\\nclass Solution {\\n    func multiply(_ num1: String, _ num2: String) -> String {\\n\\t\\tif (num1 == \"0\" || num2 == \"0\") { return \"0\"}\\n\\t\\tlet list1 = convertString(num1)\\n\\t\\tlet list2 = convertString(num2)\\n\\t\\tvar tmp1 = list1\\n\\t\\tvar tmp2 = list2\\n\\t\\tvar lists: [ListNode?] = []\\n\\t\\tvar index = 0\\n\\n\\t\\twhile tmp1 != nil {\\n\\t\\t\\tvar list: ListNode? = nil\\n\\t\\t\\tvar current = list\\n\\t\\t\\tvar add = 0\\n\\t\\t\\tfor _ in 0..<index {\\n\\t\\t\\t\\tlet node = ListNode(0)\\n\\t\\t\\t\\tif list == nil { list = node }\\n\\t\\t\\t\\tcurrent?.next = node\\n\\t\\t\\t\\tcurrent = node\\n\\t\\t\\t}\\n\\t\\t\\twhile tmp2 != nil {\\n\\t\\t\\t\\tlet val = tmp1!.val * tmp2!.val + add\\n\\t\\t\\t\\tlet node = ListNode(val % 10)\\n\\t\\t\\t\\tadd = val / 10\\n\\t\\t\\t\\tif list == nil { list = node }\\n\\t\\t\\t\\tcurrent?.next = node\\n\\t\\t\\t\\tcurrent = node\\n\\t\\t\\t\\ttmp2 = tmp2?.next\\n\\t\\t\\t}\\n\\t\\t\\tif add > 0 {\\n\\t\\t\\t\\tcurrent?.next = ListNode(add)\\n\\t\\t\\t}\\n\\t\\t\\ttmp1 = tmp1?.next\\n\\t\\t\\ttmp2 = list2\\n\\t\\t\\tlists.append(list)\\n\\t\\t\\tindex += 1\\n\\t\\t}\\n\\t\\tlet res = addLists(lists)\\n        return convertListNode(res)\\n    }\\n\\n\\n\\tfunc convertString(_ num: String) -> ListNode? {\\n\\t\\tvar list: ListNode? = nil\\n\\t\\tvar current = list\\n\\t\\t\\n\\t\\tfor i in num.reversed() {\\n\\t\\t\\tlet node = ListNode(Int(String(i)) ?? 0)\\n\\t\\t\\tif current != nil {\\n\\t\\t\\t\\tcurrent?.next = node\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tlist = node\\n\\t\\t\\t}\\n\\t\\t\\tcurrent = node\\n\\t\\t}\\n\\t\\treturn list\\n\\t}\\n\\n\\n\\tfunc convertListNode(_ list: ListNode?) -> String {\\n\\t\\tvar tmp = list\\n\\t\\tvar string = \"\"\\n\\t\\twhile tmp != nil {\\n\\t\\t\\tstring = \"\\\\(tmp!.val)\\\\(string)\"\\n\\t\\t\\ttmp = tmp!.next;\\n\\t\\t}\\n\\t\\treturn string\\n\\t}\\n\\n\\n\\tfunc addTwoNumbers(_ l1: ListNode?, _ l2: ListNode?) -> ListNode? {\\n        var add = 0\\n        var _l1 = l1\\n        var _l2 = l2\\n        var list: [ListNode] = []\\n        while _l1 != nil || _l2 != nil {\\n            let _l1_val = _l1?.val ?? 0\\n            let _l2_val = _l2?.val ?? 0\\n            let val = _l1_val + _l2_val + add\\n            let num = val % 10\\n            add = val / 10\\n            list.append(ListNode(num))\\n            _l1 = _l1?.next\\n            _l2 = _l2?.next\\n        }\\n        if (add == 1) {\\n            list.append(ListNode(1))\\n        }\\n        var head: ListNode?\\n        for node in list.reversed() {\\n            node.next = head\\n            head = node\\n        }\\n        return head\\n    }\\n\\n\\n\\tfunc addLists(_ lists: [ListNode?]) -> ListNode? {\\n\\t\\tif lists.count == 1 {\\n\\t\\t\\treturn lists[0]\\n\\t\\t} else {\\n\\t\\t\\tvar tmp = lists[0]\\n\\t\\t\\tfor (i, list) in lists.enumerated() {\\n\\t\\t\\t\\tif i > 0 {\\n\\t\\t\\t\\t\\ttmp = addTwoNumbers(tmp, list)\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn tmp\\n\\t\\t}\\n\\t}\\n\\n}\\n```\\n\\n***Consider upvote if useful! Hopefully it can be used in your advantage!***\\n***Take care brother, peace, love!***\\n***\"Open your eyes.\"***",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Python3",
                    "C",
                    "JavaScript",
                    "Swift",
                    "Kotlin"
                ],
                "code": "```\\npublic String multiply(String num1, String num2) {\\n    int m = num1.length(), n = num2.length();\\n    int[] pos = new int[m + n];\\n   \\n    for(int i = m - 1; i >= 0; i--) {\\n        for(int j = n - 1; j >= 0; j--) {\\n            int mul = (num1.charAt(i) - \\'0\\') * (num2.charAt(j) - \\'0\\'); \\n            int p1 = i + j, p2 = i + j + 1;\\n            int sum = mul + pos[p2];\\n\\n            pos[p1] += sum / 10;\\n            pos[p2] = (sum) % 10;\\n        }\\n    }  \\n    \\n    StringBuilder sb = new StringBuilder();\\n    for(int p : pos) if(!(sb.length() == 0 && p == 0)) sb.append(p);\\n    return sb.length() == 0 ? \"0\" : sb.toString();\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    string multiply(string num1, string num2) {\\n        // handle edge-case where the product is 0\\n        if (num1 == \"0\" || num2 == \"0\") return \"0\";\\n        \\n        // num1.size() + num2.size() == max no. of digits\\n        vector<int> num(num1.size() + num2.size(), 0);\\n        \\n        // build the number by multiplying one digit at the time\\n        for (int i = num1.size() - 1; i >= 0; --i) {\\n            for (int j = num2.size() - 1; j >= 0; --j) {\\n                num[i + j + 1] += (num1[i] - \\'0\\') * (num2[j] - \\'0\\');\\n                num[i + j] += num[i + j + 1] / 10;\\n                num[i + j + 1] %= 10;\\n            }\\n        }\\n        \\n        // skip leading 0\\'s\\n        int i = 0;\\n        while (i < num.size() && num[i] == 0) ++i;\\n        \\n        // transofrm the vector to a string\\n        string res = \"\";\\n        while (i < num.size()) res.push_back(num[i++] + \\'0\\');\\n        \\n        return res;\\n    }\\n};\\n```\n```\\nclass Solution:\\n    def multiply(self, num1: str, num2: str) -> str:\\n        return str(self.strint(num1)*self.strint(num2))\\n    def strint(self,n):\\n        result=0\\n        for i in range(len(n)):\\n            result = result*10 + ord(n[i])-ord(\\'0\\')\\n        return result\\n```\n```\\nconst multiply = function(num1, num2) {\\n    const dp = [...Array(num1.length+num2.length)].fill(0); \\n    for(let i = num1.length-1; i >= 0; i--){\\n      for(let j = num2.length-1; j >= 0; j--){\\n\\t  \\n\\t  //Define\\n\\t\\tconst prevRemainder  = dp[i+j+1] \\n        const product = num1[i]*num2[j]+prevRemainder\\n        const unitsDigit = product%10\\n        const carryOver = Math.floor(product/10)\\n\\t\\t\\t\\n\\t\\t//Update\\n        dp[i+j+1] = unitsDigit;\\n\\t\\tdp[i+j] += carryOver\\n       }\\n    }\\n    \\n    //Delete leading-zeroes\\n    let idx = 0\\n    while(dp[idx] === 0) dp.shift()\\n    if(!dp.length) return \"0\"\\n    return dp.join(\"\") \\n};\\n```\n```\\nfun multiply(num1: String, num2: String): String {\\n    if (num1 == \"0\" || num2 == \"0\") return \"0\"\\n    \\n    val num1 = StringBuilder(num1).reversed().toString()\\n    val num2 = StringBuilder(num2).reversed().toString()\\n    val len1 = num1.length; val len2 = num2.length\\n    \\n    val sums = IntArray(len1 + len2)\\n    \\n    for (i in 0..len1 - 1) {\\n        val a = num1[i] - \\'0\\'\\n        for (j in 0..len2 - 1) {\\n            val b = num2[j] - \\'0\\'\\n            sums[i + j] += a * b\\n        }\\n    }\\n\\n    val res = StringBuilder()\\n    var carry = 0\\n    \\n    for (sum in sums) {\\n        val num = (sum + carry) % 10\\n        carry = (sum + carry) / 10\\n        res.append(num)\\n    }\\n\\n    if (res.last() == \\'0\\') res.deleteCharAt(res.length - 1)\\n    return res.reversed().toString()\\n}\\n```\n```\\nclass Solution {\\n    func multiply(_ num1: String, _ num2: String) -> String {\\n\\t\\tif (num1 == \"0\" || num2 == \"0\") { return \"0\"}\\n\\t\\tlet list1 = convertString(num1)\\n\\t\\tlet list2 = convertString(num2)\\n\\t\\tvar tmp1 = list1\\n\\t\\tvar tmp2 = list2\\n\\t\\tvar lists: [ListNode?] = []\\n\\t\\tvar index = 0\\n\\n\\t\\twhile tmp1 != nil {\\n\\t\\t\\tvar list: ListNode? = nil\\n\\t\\t\\tvar current = list\\n\\t\\t\\tvar add = 0\\n\\t\\t\\tfor _ in 0..<index {\\n\\t\\t\\t\\tlet node = ListNode(0)\\n\\t\\t\\t\\tif list == nil { list = node }\\n\\t\\t\\t\\tcurrent?.next = node\\n\\t\\t\\t\\tcurrent = node\\n\\t\\t\\t}\\n\\t\\t\\twhile tmp2 != nil {\\n\\t\\t\\t\\tlet val = tmp1!.val * tmp2!.val + add\\n\\t\\t\\t\\tlet node = ListNode(val % 10)\\n\\t\\t\\t\\tadd = val / 10\\n\\t\\t\\t\\tif list == nil { list = node }\\n\\t\\t\\t\\tcurrent?.next = node\\n\\t\\t\\t\\tcurrent = node\\n\\t\\t\\t\\ttmp2 = tmp2?.next\\n\\t\\t\\t}\\n\\t\\t\\tif add > 0 {\\n\\t\\t\\t\\tcurrent?.next = ListNode(add)\\n\\t\\t\\t}\\n\\t\\t\\ttmp1 = tmp1?.next\\n\\t\\t\\ttmp2 = list2\\n\\t\\t\\tlists.append(list)\\n\\t\\t\\tindex += 1\\n\\t\\t}\\n\\t\\tlet res = addLists(lists)\\n        return convertListNode(res)\\n    }\\n\\n\\n\\tfunc convertString(_ num: String) -> ListNode? {\\n\\t\\tvar list: ListNode? = nil\\n\\t\\tvar current = list\\n\\t\\t\\n\\t\\tfor i in num.reversed() {\\n\\t\\t\\tlet node = ListNode(Int(String(i)) ?? 0)\\n\\t\\t\\tif current != nil {\\n\\t\\t\\t\\tcurrent?.next = node\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tlist = node\\n\\t\\t\\t}\\n\\t\\t\\tcurrent = node\\n\\t\\t}\\n\\t\\treturn list\\n\\t}\\n\\n\\n\\tfunc convertListNode(_ list: ListNode?) -> String {\\n\\t\\tvar tmp = list\\n\\t\\tvar string = \"\"\\n\\t\\twhile tmp != nil {\\n\\t\\t\\tstring = \"\\\\(tmp!.val)\\\\(string)\"\\n\\t\\t\\ttmp = tmp!.next;\\n\\t\\t}\\n\\t\\treturn string\\n\\t}\\n\\n\\n\\tfunc addTwoNumbers(_ l1: ListNode?, _ l2: ListNode?) -> ListNode? {\\n        var add = 0\\n        var _l1 = l1\\n        var _l2 = l2\\n        var list: [ListNode] = []\\n        while _l1 != nil || _l2 != nil {\\n            let _l1_val = _l1?.val ?? 0\\n            let _l2_val = _l2?.val ?? 0\\n            let val = _l1_val + _l2_val + add\\n            let num = val % 10\\n            add = val / 10\\n            list.append(ListNode(num))\\n            _l1 = _l1?.next\\n            _l2 = _l2?.next\\n        }\\n        if (add == 1) {\\n            list.append(ListNode(1))\\n        }\\n        var head: ListNode?\\n        for node in list.reversed() {\\n            node.next = head\\n            head = node\\n        }\\n        return head\\n    }\\n\\n\\n\\tfunc addLists(_ lists: [ListNode?]) -> ListNode? {\\n\\t\\tif lists.count == 1 {\\n\\t\\t\\treturn lists[0]\\n\\t\\t} else {\\n\\t\\t\\tvar tmp = lists[0]\\n\\t\\t\\tfor (i, list) in lists.enumerated() {\\n\\t\\t\\t\\tif i > 0 {\\n\\t\\t\\t\\t\\ttmp = addTwoNumbers(tmp, list)\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn tmp\\n\\t\\t}\\n\\t}\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1761103,
                "title": "java-back-to-basics-solution-easy-short-solution",
                "content": "![image](https://assets.leetcode.com/users/images/57255fb6-0e66-45ca-b5a5-83d9d71fca66_1644510835.8835142.jpeg)\\n*Pic Credits:* [@yavinci](https://leetcode.com/yavinci/)\\n\\n```\\nclass Solution {\\n    public String multiply(String nums1, String nums2) {\\n        if(nums1.equals(\"0\") || nums2.equals(\"0\")) return \"0\";\\n        if(nums1.equals(\"1\")) return nums2;\\n        if(nums2.equals(\"1\")) return nums1;\\n        \\n        int arr[]=new int[nums1.length()+nums2.length()];\\n        \\n        for(int i=nums1.length()-1;i>=0;i--){\\n            for(int j=nums2.length()-1;j>=0;j--){\\n                int prod=(nums1.charAt(i)-\\'0\\')*(nums2.charAt(j)-\\'0\\');\\n                prod+=arr[i+j+1];\\n                \\n                arr[i+j+1]=prod%10;\\n                arr[i+j]+=prod/10;\\n            }\\n        }\\n        \\n        StringBuilder ans=new StringBuilder();\\n        for(int i=0;i<arr.length;i++){\\n            if(ans.length()==0 && arr[i]==0) continue;\\n            ans.append(arr[i]);\\n        }\\n        return ans.toString();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public String multiply(String nums1, String nums2) {\\n        if(nums1.equals(\"0\") || nums2.equals(\"0\")) return \"0\";\\n        if(nums1.equals(\"1\")) return nums2;\\n        if(nums2.equals(\"1\")) return nums1;\\n        \\n        int arr[]=new int[nums1.length()+nums2.length()];\\n        \\n        for(int i=nums1.length()-1;i>=0;i--){\\n            for(int j=nums2.length()-1;j>=0;j--){\\n                int prod=(nums1.charAt(i)-\\'0\\')*(nums2.charAt(j)-\\'0\\');\\n                prod+=arr[i+j+1];\\n                \\n                arr[i+j+1]=prod%10;\\n                arr[i+j]+=prod/10;\\n            }\\n        }\\n        \\n        StringBuilder ans=new StringBuilder();\\n        for(int i=0;i<arr.length;i++){\\n            if(ans.length()==0 && arr[i]==0) continue;\\n            ans.append(arr[i]);\\n        }\\n        return ans.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1729136,
                "title": "c-simple-and-clean-8-lines-of-code",
                "content": "```\\nclass Solution {\\npublic:\\n    string multiply(string A, string B) {\\n        int n = A.length(),m = B.length();\\n        string res(n+m,\\'0\\');\\n\\n        for(int i=n-1;i>=0;i--){\\n            for(int j=m-1;j>=0;j--){\\n                int num = (A[i] - \\'0\\') * (B[j] - \\'0\\') + res[i+j+1] - \\'0\\';\\n                res[i+j+1] = num%10 + \\'0\\';\\n                res[i+j] += num/10;\\n            }\\n        }\\n        // cout<<res;\\n        for(int i=0;i<res.length();i++) if(res[i] != \\'0\\') return res.substr(i);\\n        return \"0\";\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string multiply(string A, string B) {\\n        int n = A.length(),m = B.length();\\n        string res(n+m,\\'0\\');\\n\\n        for(int i=n-1;i>=0;i--){\\n            for(int j=m-1;j>=0;j--){\\n                int num = (A[i] - \\'0\\') * (B[j] - \\'0\\') + res[i+j+1] - \\'0\\';\\n                res[i+j+1] = num%10 + \\'0\\';\\n                res[i+j] += num/10;\\n            }\\n        }\\n        // cout<<res;\\n        for(int i=0;i<res.length();i++) if(res[i] != \\'0\\') return res.substr(i);\\n        return \"0\";\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1684318,
                "title": "python-easy-solution",
                "content": "```\\nclass Solution:\\n    def multiply(self, num1: str, num2: str) -> str:\\n        s1 =0\\n        for i in num1:\\n            s1 = s1*10 + (ord(i) - 48) \\n        s2 =0\\n        for i in num2:\\n            s2 = s2*10 + (ord(i) - 48)    \\n            \\n        return str(s1*s2)\\n    \\n#     ord() Return Value\\n\\n# The ord() function returns an integer representing the Unicode character.\\n# Example: How ord() works in Python?\\n\\n# print(ord(\\'5\\'))    # 53\\n# print(ord(\\'A\\'))    # 65\\n# print(ord(\\'$\\'))    # 36\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def multiply(self, num1: str, num2: str) -> str:\\n        s1 =0\\n        for i in num1:\\n            s1 = s1*10 + (ord(i) - 48) \\n        s2 =0\\n        for i in num2:\\n            s2 = s2*10 + (ord(i) - 48)    \\n            \\n        return str(s1*s2)\\n    \\n#     ord() Return Value\\n\\n# The ord() function returns an integer representing the Unicode character.\\n# Example: How ord() works in Python?\\n\\n# print(ord(\\'5\\'))    # 53\\n# print(ord(\\'A\\'))    # 65\\n# print(ord(\\'$\\'))    # 36\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1682144,
                "title": "100-runtime-c-solution-with-pure-intuition",
                "content": "```\\nclass Solution {\\npublic:\\n    string multiply(string num1, string num2) {\\n        int m = num1.size();\\n        int n = num2.size();\\n        string s(m+n,\\'0\\');\\n        int counter = 0;\\n        for(int i=m-1; i>=0; i--)\\n        {\\n            int idx = m+n-1-counter;\\n            int carry = 0;\\n            int multiplier = num1[i]-\\'0\\';\\n            for(int j=n-1; j>=0; j--)\\n            {\\n                int sum = (num2[j]-\\'0\\')*multiplier+carry+s[idx]-\\'0\\';\\n                carry = sum/10;\\n                s[idx] = (char)(sum%10+\\'0\\');\\n                idx--;\\n            }\\n            while(carry>0)\\n            {\\n                int sum = s[idx]-\\'0\\'+carry;\\n                carry = sum/10;\\n                s[idx] = (char)(sum%10+\\'0\\');\\n                idx--;\\n            }\\n            counter++;\\n        }\\n        int zero = 0;\\n        while(zero<m+n && s[zero]==\\'0\\')\\n            zero++;\\n        if(zero==m+n)\\n            return \"0\";\\n        return string(s.begin()+zero,s.end());\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    string multiply(string num1, string num2) {\\n        int m = num1.size();\\n        int n = num2.size();\\n        string s(m+n,\\'0\\');\\n        int counter = 0;\\n        for(int i=m-1; i>=0; i--)\\n        {\\n            int idx = m+n-1-counter;\\n            int carry = 0;\\n            int multiplier = num1[i]-\\'0\\';\\n            for(int j=n-1; j>=0; j--)\\n            {\\n                int sum = (num2[j]-\\'0\\')*multiplier+carry+s[idx]-\\'0\\';\\n                carry = sum/10;\\n                s[idx] = (char)(sum%10+\\'0\\');\\n                idx--;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1680843,
                "title": "java-fft",
                "content": "```\\nclass Solution {\\n    int rev[];\\n    int tot;\\n    public String multiply(String s, String t) {\\n        if((s.length() == 1 && Integer.parseInt(s) == 0) || (t.length() == 1 && Integer.parseInt(t) == 0)) {\\n            return \"0\";\\n        }\\n        \\n        int n  = s.length() - 1;\\n        int m   = t.length() - 1;\\n\\n        int N = 1000;\\n        Complex A[] = new Complex[N];\\n        Complex B[] = new Complex[N];\\n        rev = new int[N];\\n        Arrays.setAll(A, e->new Complex(0,0));\\n        Arrays.setAll(B, e->new Complex(0,0));\\n\\n        for(int i = 0; i <= n; i++){\\n            A[i].x = s.charAt(n - i) - \\'0\\';\\n        }\\n\\n        for(int i = 0; i <= m; i++){\\n            B[i].x = t.charAt(m - i) - \\'0\\';\\n        }\\n        int bit = 0;\\n        while ((1 << bit) < n + m + 1) bit ++;\\n        tot = 1 << bit;\\n\\n        for (int i = 0; i < tot; i ++) {\\n            rev[i] = (rev[i >> 1] >> 1) | ((i & 1) << (bit - 1));\\n        }\\n\\n        fft(A,1);\\n        fft(B,1);\\n        for(int i = 0; i < tot; i++) {\\n            A[i].mul1(B[i]);\\n        }\\n        fft(A, -1);\\n\\n        StringBuilder str = new StringBuilder();\\n        int add = 0;\\n        for(int i = 0; i <= n + m || add != 0; i++){\\n            int x = ((int)(A[i].x / tot + 0.5));\\n            int d = (add + x) % 10;\\n            str.append(d+\"\");\\n            add = (add + x) / 10;\\n        }\\n        return str.reverse().toString();\\n    }\\n    \\n    public void fft(Complex a[], int inv){\\n        for (int i = 0; i < tot; i ++ ){\\n            if (i < rev[i]) {\\n                swap(a, i, rev[i]);\\n            }\\n        }\\n        for (int mid = 1; mid < tot; mid <<= 1) {\\n            Complex w1 = new Complex(Math.cos(Math.PI / mid), Math.sin(Math.PI / mid) * inv);\\n            for (int i = 0; i < tot; i += mid * 2) {\\n                Complex wk = new Complex(1, 0);\\n                for (int j = 0; j < mid; j ++, wk = wk.mul(w1)) {\\n                    Complex x = a[i + j], y = wk.mul(a[i + j + mid]);\\n                    a[i + j] = x.add(y);\\n                    a[i + j + mid] = x.sub(y);\\n                }\\n            }\\n        }\\n    }\\n\\n    public void swap(Complex A[], int i, int j){\\n        Complex t = A[i];\\n        A[i] = A[j];\\n        A[j] = t;\\n    }\\n    \\n    class Complex{\\n        double x = 0.0;\\n        double y = 0.0;\\n\\n        public Complex(double x, double y){\\n            this.x = x;\\n            this.y = y;\\n        }\\n\\n        public Complex add(Complex other){\\n            return new Complex(this.x + other.x, this.y + other.y);\\n        }\\n\\n        public Complex sub(Complex other){\\n            return new Complex(this.x - other.x, this.y - other.y);\\n        }\\n\\n        public Complex mul(Complex other){\\n            return new Complex(this.x * other.x - this.y * other.y, this.x * other.y + this.y * other.x);\\n        }\\n\\n        public void mul1(Complex other){\\n            double xx = this.x * other.x - this.y * other.y;\\n            double yy = this.x * other.y + this.y * other.x;\\n            this. x = xx;\\n            this. y = yy;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    int rev[];\\n    int tot;\\n    public String multiply(String s, String t) {\\n        if((s.length() == 1 && Integer.parseInt(s) == 0) || (t.length() == 1 && Integer.parseInt(t) == 0)) {\\n            return \"0\";\\n        }\\n        \\n        int n  = s.length() - 1;\\n        int m   = t.length() - 1;\\n\\n        int N = 1000;\\n        Complex A[] = new Complex[N];\\n        Complex B[] = new Complex[N];\\n        rev = new int[N];\\n        Arrays.setAll(A, e->new Complex(0,0));\\n        Arrays.setAll(B, e->new Complex(0,0));\\n\\n        for(int i = 0; i <= n; i++){\\n            A[i].x = s.charAt(n - i) - \\'0\\';\\n        }\\n\\n        for(int i = 0; i <= m; i++){\\n            B[i].x = t.charAt(m - i) - \\'0\\';\\n        }\\n        int bit = 0;\\n        while ((1 << bit) < n + m + 1) bit ++;\\n        tot = 1 << bit;\\n\\n        for (int i = 0; i < tot; i ++) {\\n            rev[i] = (rev[i >> 1] >> 1) | ((i & 1) << (bit - 1));\\n        }\\n\\n        fft(A,1);\\n        fft(B,1);\\n        for(int i = 0; i < tot; i++) {\\n            A[i].mul1(B[i]);\\n        }\\n        fft(A, -1);\\n\\n        StringBuilder str = new StringBuilder();\\n        int add = 0;\\n        for(int i = 0; i <= n + m || add != 0; i++){\\n            int x = ((int)(A[i].x / tot + 0.5));\\n            int d = (add + x) % 10;\\n            str.append(d+\"\");\\n            add = (add + x) / 10;\\n        }\\n        return str.reverse().toString();\\n    }\\n    \\n    public void fft(Complex a[], int inv){\\n        for (int i = 0; i < tot; i ++ ){\\n            if (i < rev[i]) {\\n                swap(a, i, rev[i]);\\n            }\\n        }\\n        for (int mid = 1; mid < tot; mid <<= 1) {\\n            Complex w1 = new Complex(Math.cos(Math.PI / mid), Math.sin(Math.PI / mid) * inv);\\n            for (int i = 0; i < tot; i += mid * 2) {\\n                Complex wk = new Complex(1, 0);\\n                for (int j = 0; j < mid; j ++, wk = wk.mul(w1)) {\\n                    Complex x = a[i + j], y = wk.mul(a[i + j + mid]);\\n                    a[i + j] = x.add(y);\\n                    a[i + j + mid] = x.sub(y);\\n                }\\n            }\\n        }\\n    }\\n\\n    public void swap(Complex A[], int i, int j){\\n        Complex t = A[i];\\n        A[i] = A[j];\\n        A[j] = t;\\n    }\\n    \\n    class Complex{\\n        double x = 0.0;\\n        double y = 0.0;\\n\\n        public Complex(double x, double y){\\n            this.x = x;\\n            this.y = y;\\n        }\\n\\n        public Complex add(Complex other){\\n            return new Complex(this.x + other.x, this.y + other.y);\\n        }\\n\\n        public Complex sub(Complex other){\\n            return new Complex(this.x - other.x, this.y - other.y);\\n        }\\n\\n        public Complex mul(Complex other){\\n            return new Complex(this.x * other.x - this.y * other.y, this.x * other.y + this.y * other.x);\\n        }\\n\\n        public void mul1(Complex other){\\n            double xx = this.x * other.x - this.y * other.y;\\n            double yy = this.x * other.y + this.y * other.x;\\n            this. x = xx;\\n            this. y = yy;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1564549,
                "title": "python-o-mn-solution",
                "content": "**Python :**\\n\\n```\\ndef multiply(self, num1: str, num2: str) -> str:\\n\\tif num1 == \\'0\\' or num2 == \\'0\\':\\n\\t\\treturn \\'0\\'\\n\\n\\tres = [0] * (len(num1) + len(num2))\\n\\n\\tfor i in range(len(num1) - 1, -1, -1):\\n\\t\\tfor j in range(len(num2) - 1, -1, -1):\\n\\t\\t\\tres[i + j + 1] += int(num1[i]) * int(num2[j])\\n\\t\\t\\tres[i + j] += res[i + j + 1] // 10\\n\\t\\t\\tres[i + j + 1] %= 10\\n\\n\\ti = 0\\n\\n\\twhile res[i] == 0:\\n\\t\\ti += 1\\n\\n\\treturn \"\".join(map(str,res[i:]))\\n```\\n\\n**Like it ? please upvote !**",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\ndef multiply(self, num1: str, num2: str) -> str:\\n\\tif num1 == \\'0\\' or num2 == \\'0\\':\\n\\t\\treturn \\'0\\'\\n\\n\\tres = [0] * (len(num1) + len(num2))\\n\\n\\tfor i in range(len(num1) - 1, -1, -1):\\n\\t\\tfor j in range(len(num2) - 1, -1, -1):\\n\\t\\t\\tres[i + j + 1] += int(num1[i]) * int(num2[j])\\n\\t\\t\\tres[i + j] += res[i + j + 1] // 10\\n\\t\\t\\tres[i + j + 1] %= 10\\n\\n\\ti = 0\\n\\n\\twhile res[i] == 0:\\n\\t\\ti += 1\\n\\n\\treturn \"\".join(map(str,res[i:]))\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1563945,
                "title": "simple-c-solution-with-12ms-runtime",
                "content": "\\'\\'\\'\\nstring multiply(string num1, string num2) {\\nint i, j;\\nint m = num1.size(), n = num2.size();\\n\\n    vector<int> product(m + n, 0);\\n    string result;\\n\\n    \\n    reverse(num1.begin(), num1.end());\\n    reverse(num2.begin(), num2.end());\\n\\n   \\n    for (i = 0; i < m; i++) {\\n        for (j = 0; j < n; j++) {\\n            product[i + j] += (num1[i] - \\'0\\') * (num2[j] - \\'0\\');\\n            product[i + j + 1] += product[i + j] / 10;\\n            product[i + j] %= 10;\\n        }\\n    }\\n\\n    for (i = m + n - 1; i > 0 && 0 == product[i]; i--)\\n        ;\\n    \\n    for (; i >= 0; i--)\\n        result += to_string(product[i]);\\n\\nreturn result;\\n}\\n\\'\\'\\'",
                "solutionTags": [],
                "code": "\\'\\'\\'\\nstring multiply(string num1, string num2) {\\nint i, j;\\nint m = num1.size(), n = num2.size();\\n\\n    vector<int> product(m + n, 0);\\n    string result;\\n\\n    \\n    reverse(num1.begin(), num1.end());\\n    reverse(num2.begin(), num2.end());\\n\\n   \\n    for (i = 0; i < m; i++) {\\n        for (j = 0; j < n; j++) {\\n            product[i + j] += (num1[i] - \\'0\\') * (num2[j] - \\'0\\');\\n            product[i + j + 1] += product[i + j] / 10;\\n            product[i + j] %= 10;\\n        }\\n    }\\n\\n    for (i = m + n - 1; i > 0 && 0 == product[i]; i--)\\n        ;\\n    \\n    for (; i >= 0; i--)\\n        result += to_string(product[i]);\\n\\nreturn result;\\n}\\n\\'\\'\\'",
                "codeTag": "Unknown"
            },
            {
                "id": 1446314,
                "title": "javascript-old-school-method",
                "content": "```\\n/*\\nhttps://leetcode.com/problems/multiply-strings/submissions/\\n*/\\nvar multiply = function(num1, num2) {\\n    a = num1.split(\\'\\').reverse();\\n    b = num2.split(\\'\\').reverse();\\n\\n    // result \\n    let res = [];\\n    for(let i = 0; i < b.length; i++) {\\n        for(let j = 0; j < a.length; j++) {\\n            let d = parseInt(b[i]) * parseInt(a[j]) + (res[j + i] || 0);\\n            \\n            // value of single digit\\n            let r =  d      % 10;\\n            // carry over\\n            let c = (d - r) / 10;\\n\\n            res[j + i] =  r;\\n\\n            // add remaining carry over in next position\\n            if (c) \\n                res[j + i + 1] = (res[i + j + 1] || 0) + c;\\n        }            \\n    }\\n    \\n    // fix situation when prefix of res == 0000... \\n    return res.reverse().join(\\'\\').replace(/^0*/, \\'\\') || \\'0\\'\\n}\\n    \\n```",
                "solutionTags": [],
                "code": "```\\n/*\\nhttps://leetcode.com/problems/multiply-strings/submissions/\\n*/\\nvar multiply = function(num1, num2) {\\n    a = num1.split(\\'\\').reverse();\\n    b = num2.split(\\'\\').reverse();\\n\\n    // result \\n    let res = [];\\n    for(let i = 0; i < b.length; i++) {\\n        for(let j = 0; j < a.length; j++) {\\n            let d = parseInt(b[i]) * parseInt(a[j]) + (res[j + i] || 0);\\n            \\n            // value of single digit\\n            let r =  d      % 10;\\n            // carry over\\n            let c = (d - r) / 10;\\n\\n            res[j + i] =  r;\\n\\n            // add remaining carry over in next position\\n            if (c) \\n                res[j + i + 1] = (res[i + j + 1] || 0) + c;\\n        }            \\n    }\\n    \\n    // fix situation when prefix of res == 0000... \\n    return res.reverse().join(\\'\\').replace(/^0*/, \\'\\') || \\'0\\'\\n}\\n    \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1391220,
                "title": "c-simulating-primary-school-multiplication",
                "content": "```\\n/*\\nThis is just a simulation of multiplication we used to do during primary school.\\nThis same technique is used to find factorial of large numbers as well.\\nLink (Factorial Of Large Numbers) : https://github.com/MAZHARMIK/Interview_DS_Algo/blob/master/Arrays/Factorials%20of%20large%20numbers.cpp\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t 1  2  3\\n\\t\\t\\t\\t\\t\\t\\t\\t 1  2  1\\n\\t\\t\\t\\t\\t\\t\\t\\t -------\\n\\t\\t\\t\\t\\t\\t\\t    1   2   3\\n\\t\\t\\t\\t\\t\\t\\t  2\\t4\\t6   x\\n\\t\\t\\t\\t\\t\\t  1   2 3    x  x  (I call this symbol as cross. Notice how cross is increasing)\\n\\t\\t\\t\\t    \\t-----------------\\n\\t\\t\\t       Ans:\\t  1  4  8   8  3\\n\\n*/\\n\\n\\nclass Solution {\\npublic:\\n    string temp;\\n\\t//This function just does the multiplication of a digit of num1 with whole num2\\n    void multiplyNum(int& num, vector<int>& result, int& size, int cross) {\\n        int carry = 0;\\n\\n        for(int i = temp.length()-1; i >= 0; i--) {\\n            int p            = (num*(temp[i]-\\'0\\')) + carry + result[cross];\\n            result[cross++]  = p%10;\\n            carry            = p/10;\\n        }\\n        \\n        while(carry) {\\n            result[cross++] = carry%10;\\n            carry          /= 10;\\n        }\\n        \\n        size = cross;\\n    }\\n    \\n    string multiply(string num1, string num2) {\\n        if(num1 == \"0\" || num2 == \"0\")\\n            return \"0\";\\n        int m = num1.length();\\n        int n = num2.length();\\n        //I will always choose to multiply smaller number to a larger number\\n        if(m > n) {\\n            return multiply(num2, num1);\\n        }\\n        \\n        vector<int> result(100000, 0);\\n        temp = num2;\\n        int size = 0;\\n        \\n        int cross = 0;\\n        for(int i = m-1; i>=0; i--) {\\n            int num = num1[i]-\\'0\\';\\n            multiplyNum(num, result, size, cross);\\n            cross++; //increasing cross position\\n        }\\n        \\n        string ans = \"\";\\n        for(int i = size-1; i>=0; i--)\\n            ans.push_back(result[i]+\\'0\\');\\n        \\n        return ans;\\n    }\\n};\\n```\\n\\n\\n```\\n//Approach-2 (Better version of above approach)\\nclass Solution {\\npublic:\\n    string multiply(string num1, string num2) {\\n        int sign = 1;\\n        \\n        if (num1[0] == \\'-\\') {\\n            sign *= -1;\\n            num1 = num1.substr(1);\\n        }\\n    \\n        if (num2[0] == \\'-\\') {\\n                sign *= -1;\\n                num2 = num2.substr(1);\\n        }\\n    \\n        int n1 = num1.size();\\n        int n2 = num2.size();\\n        if (n1 == 0 || n2 == 0) return \"0\";\\n    \\n        vector<int> result(n1 + n2, 0);\\n    \\n        int i_n1 = 0; \\n        int i_n2 = 0; \\n    \\n        for (int i=n1-1; i>=0; i--) {\\n            int carry = 0;\\n            int n1 = num1[i] - \\'0\\';\\n    \\n            i_n2 = 0; \\n            \\n            for (int j=n2-1; j>=0; j--) {\\n            \\n                int n2 = num2[j] - \\'0\\';\\n    \\n                int sum = n1*n2 + result[i_n1 + i_n2] + carry;\\n    \\n                carry = sum/10;\\n    \\n                result[i_n1 + i_n2] = sum % 10;\\n    \\n                i_n2++;\\n            }\\n    \\n            if (carry > 0)\\n                result[i_n1 + i_n2] += carry;\\n    \\n            i_n1++;\\n        }\\n    \\n        int i = result.size() - 1;\\n        while (i>=0 && result[i] == 0) i--;\\n    \\n        if (i == -1)\\n            return \"0\";\\n    \\n        string s = \"\";\\n        while (i >= 0) {\\n            s.push_back(result[i]+\\'0\\');\\n            i--;\\n        }\\n            \\n        if (sign == -1)\\n            return \"-\"+s;\\n    \\n        return s;\\n    \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/*\\nThis is just a simulation of multiplication we used to do during primary school.\\nThis same technique is used to find factorial of large numbers as well.\\nLink (Factorial Of Large Numbers) : https://github.com/MAZHARMIK/Interview_DS_Algo/blob/master/Arrays/Factorials%20of%20large%20numbers.cpp\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t 1  2  3\\n\\t\\t\\t\\t\\t\\t\\t\\t 1  2  1\\n\\t\\t\\t\\t\\t\\t\\t\\t -------\\n\\t\\t\\t\\t\\t\\t\\t    1   2   3\\n\\t\\t\\t\\t\\t\\t\\t  2\\t4\\t6   x\\n\\t\\t\\t\\t\\t\\t  1   2 3    x  x  (I call this symbol as cross. Notice how cross is increasing)\\n\\t\\t\\t\\t    \\t-----------------\\n\\t\\t\\t       Ans:\\t  1  4  8   8  3\\n\\n*/\\n\\n\\nclass Solution {\\npublic:\\n    string temp;\\n\\t//This function just does the multiplication of a digit of num1 with whole num2\\n    void multiplyNum(int& num, vector<int>& result, int& size, int cross) {\\n        int carry = 0;\\n\\n        for(int i = temp.length()-1; i >= 0; i--) {\\n            int p            = (num*(temp[i]-\\'0\\')) + carry + result[cross];\\n            result[cross++]  = p%10;\\n            carry            = p/10;\\n        }\\n        \\n        while(carry) {\\n            result[cross++] = carry%10;\\n            carry          /= 10;\\n        }\\n        \\n        size = cross;\\n    }\\n    \\n    string multiply(string num1, string num2) {\\n        if(num1 == \"0\" || num2 == \"0\")\\n            return \"0\";\\n        int m = num1.length();\\n        int n = num2.length();\\n        //I will always choose to multiply smaller number to a larger number\\n        if(m > n) {\\n            return multiply(num2, num1);\\n        }\\n        \\n        vector<int> result(100000, 0);\\n        temp = num2;\\n        int size = 0;\\n        \\n        int cross = 0;\\n        for(int i = m-1; i>=0; i--) {\\n            int num = num1[i]-\\'0\\';\\n            multiplyNum(num, result, size, cross);\\n            cross++; //increasing cross position\\n        }\\n        \\n        string ans = \"\";\\n        for(int i = size-1; i>=0; i--)\\n            ans.push_back(result[i]+\\'0\\');\\n        \\n        return ans;\\n    }\\n};\\n```\n```\\n//Approach-2 (Better version of above approach)\\nclass Solution {\\npublic:\\n    string multiply(string num1, string num2) {\\n        int sign = 1;\\n        \\n        if (num1[0] == \\'-\\') {\\n            sign *= -1;\\n            num1 = num1.substr(1);\\n        }\\n    \\n        if (num2[0] == \\'-\\') {\\n                sign *= -1;\\n                num2 = num2.substr(1);\\n        }\\n    \\n        int n1 = num1.size();\\n        int n2 = num2.size();\\n        if (n1 == 0 || n2 == 0) return \"0\";\\n    \\n        vector<int> result(n1 + n2, 0);\\n    \\n        int i_n1 = 0; \\n        int i_n2 = 0; \\n    \\n        for (int i=n1-1; i>=0; i--) {\\n            int carry = 0;\\n            int n1 = num1[i] - \\'0\\';\\n    \\n            i_n2 = 0; \\n            \\n            for (int j=n2-1; j>=0; j--) {\\n            \\n                int n2 = num2[j] - \\'0\\';\\n    \\n                int sum = n1*n2 + result[i_n1 + i_n2] + carry;\\n    \\n                carry = sum/10;\\n    \\n                result[i_n1 + i_n2] = sum % 10;\\n    \\n                i_n2++;\\n            }\\n    \\n            if (carry > 0)\\n                result[i_n1 + i_n2] += carry;\\n    \\n            i_n1++;\\n        }\\n    \\n        int i = result.size() - 1;\\n        while (i>=0 && result[i] == 0) i--;\\n    \\n        if (i == -1)\\n            return \"0\";\\n    \\n        string s = \"\";\\n        while (i >= 0) {\\n            s.push_back(result[i]+\\'0\\');\\n            i--;\\n        }\\n            \\n        if (sign == -1)\\n            return \"-\"+s;\\n    \\n        return s;\\n    \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1282638,
                "title": "100-faster-and-easy-to-understand",
                "content": "Go to the basic how u do multiplication!\\n\\n```\\n\\nclass Solution {\\npublic:\\n    string multiply(string num1, string num2) {\\n\\tint n = nums1.size();\\n\\tint m = nums2.size();\\n\\t\\n    string sum(n + m, \\'0\\');\\n    \\n    for(int i = n - 1; i >= 0; i--) \\n    {\\n        int carr = 0;\\n        \\n        for (int j = m - 1; j >= 0; j--)\\n        {\\n            int tmp = (sum[i + j + 1] - \\'0\\') + (num1[i] - \\'0\\') * (num2[j] - \\'0\\') + carr;\\n            sum[i + j + 1] = tmp % 10 + \\'0\\';\\n            carr = tmp / 10;\\n        }\\n        \\n        sum[i] += carr;\\n    }\\n    \\n        int j =0;\\n        \\n    while(sum[j]==\\'0\\')\\n        j++;\\n        \\n    if (j!=-1 && j<(n + m) )\\n    {\\n        return sum.substr(j);\\n    }\\n        \\n    return \"0\";\\n        \\n    }\\n};\\n\\n```",
                "solutionTags": [],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    string multiply(string num1, string num2) {\\n\\tint n = nums1.size();\\n\\tint m = nums2.size();\\n\\t\\n    string sum(n + m, \\'0\\');\\n    \\n    for(int i = n - 1; i >= 0; i--) \\n    {\\n        int carr = 0;\\n        \\n        for (int j = m - 1; j >= 0; j--)\\n        {\\n            int tmp = (sum[i + j + 1] - \\'0\\') + (num1[i] - \\'0\\') * (num2[j] - \\'0\\') + carr;\\n            sum[i + j + 1] = tmp % 10 + \\'0\\';\\n            carr = tmp / 10;\\n        }\\n        \\n        sum[i] += carr;\\n    }\\n    \\n        int j =0;\\n        \\n    while(sum[j]==\\'0\\')\\n        j++;\\n        \\n    if (j!=-1 && j<(n + m) )\\n    {\\n        return sum.substr(j);\\n    }\\n        \\n    return \"0\";\\n        \\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1222116,
                "title": "java-solution-with-comments",
                "content": "At this moment it beats 99% of other solutions.\\n\\n```\\nclass Solution {\\n    public String multiply(String num1, String num2) {\\n        //anything multiplied by zero is zero\\n        if(num1.equals(\"0\") || num2.equals(\"0\")) return \"0\";\\n        //if we multiply x * y where xL is number of digits x has and yL is number of digits that y has, the result will have max of xL + yL digits\\n        int[] digits = new int[num1.length() + num2.length()];\\n        \\n        for(int i = num1.length() - 1; i >= 0; i--){\\n            int n1 = num1.charAt(i) -\\'0\\';\\n            for(int j = num2.length() - 1; j >= 0; j--){\\n                int n2 = num2.charAt(j) - \\'0\\';\\n                digits[i + j + 1] += n1 * n2;\\n            }\\n        }\\n        \\n        //fix carry over\\n        int carryOver = 0;\\n        for(int i = digits.length - 1; i >= 0; i--){\\n            int curValue = digits[i] + carryOver;            \\n            if(curValue >= 10){\\n                carryOver = curValue / 10;\\n                digits[i] = curValue % 10;\\n            }            \\n            else{\\n                digits[i] = curValue;\\n                carryOver = 0;\\n            }\\n        }\\n        \\n        //turn array into string, first find first non zero index to avoid leading zeros at the begining of string\\n        int firstNonZeroIdx = 0;\\n        while(digits[firstNonZeroIdx] == 0) firstNonZeroIdx++;\\n        \\n        StringBuilder sb = new StringBuilder();\\n        for(int i = firstNonZeroIdx; i < digits.length; i++) sb.append(digits[i]);\\n        \\n        return sb.toString();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public String multiply(String num1, String num2) {\\n        //anything multiplied by zero is zero\\n        if(num1.equals(\"0\") || num2.equals(\"0\")) return \"0\";\\n        //if we multiply x * y where xL is number of digits x has and yL is number of digits that y has, the result will have max of xL + yL digits\\n        int[] digits = new int[num1.length() + num2.length()];\\n        \\n        for(int i = num1.length() - 1; i >= 0; i--){\\n            int n1 = num1.charAt(i) -\\'0\\';\\n            for(int j = num2.length() - 1; j >= 0; j--){\\n                int n2 = num2.charAt(j) - \\'0\\';\\n                digits[i + j + 1] += n1 * n2;\\n            }\\n        }\\n        \\n        //fix carry over\\n        int carryOver = 0;\\n        for(int i = digits.length - 1; i >= 0; i--){\\n            int curValue = digits[i] + carryOver;            \\n            if(curValue >= 10){\\n                carryOver = curValue / 10;\\n                digits[i] = curValue % 10;\\n            }            \\n            else{\\n                digits[i] = curValue;\\n                carryOver = 0;\\n            }\\n        }\\n        \\n        //turn array into string, first find first non zero index to avoid leading zeros at the begining of string\\n        int firstNonZeroIdx = 0;\\n        while(digits[firstNonZeroIdx] == 0) firstNonZeroIdx++;\\n        \\n        StringBuilder sb = new StringBuilder();\\n        for(int i = firstNonZeroIdx; i < digits.length; i++) sb.append(digits[i]);\\n        \\n        return sb.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1098413,
                "title": "simple-few-lines-code-using-ascii-value-with-full-explanation",
                "content": "The logic is simple here we will use the ascii value \\n       \\n\\t    Success\\n        Details \\n        Runtime: 32 ms, faster than 92.76% of Python3 online submissions for Multiply Strings.\\n        Memory Usage: 14.3 MB, less than 30.94% of Python3 online submissions for Multiply Strings.\\n        s1 = 0\\n        for i in num1:\\n            s1 = s1*10 + (ord(i) - 48)  #ord() function returns the number representing the unicode code of a specified character. and the reason we deducted 48 beacuse ascii value of 2 is 50 so if we won\\'t deduct 48 which is the ascii value of 0 it will return 50 and yes you may try this with any no.\\n            \\n         # similary we will do for s2    \\n        s2 = 0\\n        for i in num2:\\n            s2 = s2*10 + (ord(i) - 48)\\n            \\n      # and just return the value      \\n        return (str(s1 * s2))  \\n\\t\\t#I hope things are clear now but still if you have any query comment down I will reply asap\\n\\t\\t\\n**UPVOTE IF YOU FIND IT HELPFUL**",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "The logic is simple here we will use the ascii value \\n       \\n\\t    Success\\n        Details \\n        Runtime: 32 ms, faster than 92.76% of Python3 online submissions for Multiply Strings.\\n        Memory Usage: 14.3 MB, less than 30.94% of Python3 online submissions for Multiply Strings.\\n        s1 = 0\\n        for i in num1:\\n            s1 = s1*10 + (ord(i) - 48)  #ord() function returns the number representing the unicode code of a specified character. and the reason we deducted 48 beacuse ascii value of 2 is 50 so if we won\\'t deduct 48 which is the ascii value of 0 it will return 50 and yes you may try this with any no.\\n            \\n         # similary we will do for s2    \\n        s2 = 0\\n        for i in num2:\\n            s2 = s2*10 + (ord(i) - 48)\\n            \\n      # and just return the value      \\n        return (str(s1 * s2))  \\n\\t\\t#I hope things are clear now but still if you have any query comment down I will reply asap\\n\\t\\t\\n**UPVOTE IF YOU FIND IT HELPFUL**",
                "codeTag": "Unknown"
            },
            {
                "id": 924533,
                "title": "c-0ms-faster-than-100-of-submissions",
                "content": "```\\nclass Solution {\\npublic:\\n    string multiply(string num1, string num2) {\\n        if(num1==\"0\" || num2==\"0\")\\n            return \"0\";\\n        int n1 = num1.size();\\n        int n2 = num2.size();\\n        string arr(n1+n2,\\'0\\');\\n        int carry = 0;\\n        int sum = 0;\\n        for(int i=n2-1;i>=0;i--)\\n        {\\n            carry = 0;\\n            for(int j=n1-1;j>=0;j--)\\n            {\\n                // cout<<(num1[j]-\\'0\\')*(num2[i]-\\'0\\')+carry+(arr[i+j+1]-\\'0\\')<<endl;\\n                \\n               sum = (num1[j]-\\'0\\')*(num2[i]-\\'0\\') + carry + (arr[i+j+1]-\\'0\\');\\n                // cout<<sum<<\" \";\\n                int val = sum%10;\\n                \\n                arr[i+j+1] = val+\\'0\\';\\n                carry = sum/10;\\n            }\\n            arr[i]+=carry;\\n\\n            \\n        }int pos=0;\\n        while(arr[pos]==\\'0\\')\\n        {\\n            pos++;\\n        }\\n            return arr.substr(pos);  \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string multiply(string num1, string num2) {\\n        if(num1==\"0\" || num2==\"0\")\\n            return \"0\";\\n        int n1 = num1.size();\\n        int n2 = num2.size();\\n        string arr(n1+n2,\\'0\\');\\n        int carry = 0;\\n        int sum = 0;\\n        for(int i=n2-1;i>=0;i--)\\n        {\\n            carry = 0;\\n            for(int j=n1-1;j>=0;j--)\\n            {\\n                // cout<<(num1[j]-\\'0\\')*(num2[i]-\\'0\\')+carry+(arr[i+j+1]-\\'0\\')<<endl;\\n                \\n               sum = (num1[j]-\\'0\\')*(num2[i]-\\'0\\') + carry + (arr[i+j+1]-\\'0\\');\\n                // cout<<sum<<\" \";\\n                int val = sum%10;\\n                \\n                arr[i+j+1] = val+\\'0\\';\\n                carry = sum/10;\\n            }\\n            arr[i]+=carry;\\n\\n            \\n        }int pos=0;\\n        while(arr[pos]==\\'0\\')\\n        {\\n            pos++;\\n        }\\n            return arr.substr(pos);  \\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 675622,
                "title": "simple-python-solution-using-dictionaries",
                "content": "```\\nclass Solution:\\n    def multiply(self, num1: str, num2: str) -> str:\\n        dict = {\"0\": 0,\"1\":1 ,\"2\":2 ,\"3\": 3,\"4\": 4,\"5\":5 ,\"6\": 6,\"7\": 7,\"8\":8,\"9\":9 }\\n        xlen = len(num1)\\n        ylen = len(num2)\\n        x =y =0\\n        for i,n in enumerate(num1):\\n            x += (10**(xlen - (i+1)) * dict[n])\\n        for i,n in enumerate(num2):\\n            y += (10**(ylen - (i+1)) * dict[n])\\n        return str(x * y)",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "class Solution:\\n    def multiply(self, num1: str, num2: str) -> str:\\n        dict = {\"0\": 0,\"1\":1 ,\"2\":2 ,\"3\": 3,\"4\": 4,\"5\":5 ,\"6\": 6,\"7\": 7,\"8\":8,\"9\":9 }",
                "codeTag": "Java"
            },
            {
                "id": 573860,
                "title": "c-easy-short-100-sc-95-tc",
                "content": "Using @ChiangKaiShrek solution\\n\\n```\\nclass Solution {\\npublic:\\n    string multiply(string num1, string num2) {\\n        string sum(num1.size() + num2.size(),\\'0\\');\\n        if(num1 == \"0\" || num2 == \"0\")return \"0\";\\n        for(int i = num1.size() - 1;i>=0;i--) {\\n            int carry = 0;\\n            for(int j = num2.size() - 1;j>=0;j--) {\\n                int temp = (sum[i+j + 1] - \\'0\\') + (num1[i] - \\'0\\') * (num2[j] - \\'0\\') + carry;\\n                carry = temp/10;\\n                sum[i + j + 1] = temp%10 + \\'0\\';\\n            }\\n            sum[i] += carry ;\\n        }\\n        int pos = 0;\\n        while(sum[pos] ==\\'0\\'){\\n            pos++;\\n        }\\n        return sum.substr(pos);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string multiply(string num1, string num2) {\\n        string sum(num1.size() + num2.size(),\\'0\\');\\n        if(num1 == \"0\" || num2 == \"0\")return \"0\";\\n        for(int i = num1.size() - 1;i>=0;i--) {\\n            int carry = 0;\\n            for(int j = num2.size() - 1;j>=0;j--) {\\n                int temp = (sum[i+j + 1] - \\'0\\') + (num1[i] - \\'0\\') * (num2[j] - \\'0\\') + carry;\\n                carry = temp/10;\\n                sum[i + j + 1] = temp%10 + \\'0\\';\\n            }\\n            sum[i] += carry ;\\n        }\\n        int pos = 0;\\n        while(sum[pos] ==\\'0\\'){\\n            pos++;\\n        }\\n        return sum.substr(pos);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 510501,
                "title": "c-solution-less-lines-of-code",
                "content": "```\\nclass Solution {\\npublic:\\nstring multiply(string num1, string num2) {\\n  \\n    string res(num1.size() + num2.size(), \\'0\\');\\n  \\n    for (int i = num1.size() - 1; i >= 0; i--) {\\n        for (int j = num2.size() - 1; j >= 0; j--) {\\n            int prod =  (num1[i] - \\'0\\') * (num2[j] - \\'0\\') +  (res[i + j + 1] - \\'0\\');\\n            res[i+j+1] = (prod % 10) + \\'0\\';\\n            res[i+j] = ((prod /10) + (res[i + j] - \\'0\\')) + \\'0\\';\\n        }\\n  }\\n  //remove the trailing zeros\\n  int it = res.find_first_not_of(\"0\");\\n  return ( it < 0  ? \"0\" : res.substr(it) );\\n}\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nstring multiply(string num1, string num2) {\\n  \\n    string res(num1.size() + num2.size(), \\'0\\');\\n  \\n    for (int i = num1.size() - 1; i >= 0; i--) {\\n        for (int j = num2.size() - 1; j >= 0; j--) {\\n            int prod =  (num1[i] - \\'0\\') * (num2[j] - \\'0\\') +  (res[i + j + 1] - \\'0\\');\\n            res[i+j+1] = (prod % 10) + \\'0\\';\\n            res[i+j] = ((prod /10) + (res[i + j] - \\'0\\')) + \\'0\\';\\n        }\\n  }\\n  //remove the trailing zeros\\n  int it = res.find_first_not_of(\"0\");\\n  return ( it < 0  ? \"0\" : res.substr(it) );\\n}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 490515,
                "title": "java-3ms",
                "content": "//Runtime: 3 ms, faster than 96.51% of Java online submissions for Multiply Strings.\\n//Memory Usage: 38.6 MB, less than 16.67% of Java online submissions for Multiply Strings.\\n\\n```\\nclass Solution {\\n    public String multiply(String num1, String num2) {\\n     \\n        if(num1.equals(\"0\") || num2.equals(\"0\")) return \"0\";\\n        \\n        int  len1 = num1.length();\\n        int  len2 = num2.length();\\n        int  len = len1+len2-1;\\n        int [] lc = new int[len];\\n        int carry=0;\\n\\t\\tStringBuilder result = new StringBuilder(len+1); \\n        \\n        for(int i=len1-1; i>=0; i--)\\n        {\\n            for(int j=len2-1; j>=0; j--)\\n            {\\n                int x = num1.charAt(i) - \\'0\\';\\n                int y = num2.charAt(j) - \\'0\\';\\n                lc[i+j] += x * y;\\n            }\\n         }\\n        \\n        for(int i=(len-1); i>=0; i--)\\n        {\\n            lc[i] += carry;\\n            result.insert(0,lc[i]%10);\\n            carry = lc[i]/10;\\n        }\\n          \\n        if(carry>0) result.insert(0,carry);\\n        \\n        return result.toString(); \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public String multiply(String num1, String num2) {\\n     \\n        if(num1.equals(\"0\") || num2.equals(\"0\")) return \"0\";\\n        \\n        int  len1 = num1.length();\\n        int  len2 = num2.length();\\n        int  len = len1+len2-1;\\n        int [] lc = new int[len];\\n        int carry=0;\\n\\t\\tStringBuilder result = new StringBuilder(len+1); \\n        \\n        for(int i=len1-1; i>=0; i--)\\n        {\\n            for(int j=len2-1; j>=0; j--)\\n            {\\n                int x = num1.charAt(i) - \\'0\\';\\n                int y = num2.charAt(j) - \\'0\\';\\n                lc[i+j] += x * y;\\n            }\\n         }\\n        \\n        for(int i=(len-1); i>=0; i--)\\n        {\\n            lc[i] += carry;\\n            result.insert(0,lc[i]%10);\\n            carry = lc[i]/10;\\n        }\\n          \\n        if(carry>0) result.insert(0,carry);\\n        \\n        return result.toString(); \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 303929,
                "title": "swift-matrix-solution-simulate-by-hand-multiply-with-swift-tricks",
                "content": "```\\nclass Solution {\\n    func multiply(_ num1: String, _ num2: String) -> String {\\n        \\n        //Figure out smaller and larger string...\\n        var smallString = num1, largeString = num2\\n        if smallString.count > largeString.count { smallString = num2; largeString = num1 }\\n        \\n        //We work with ints, not with characters.\\n        var small = smallString.compactMap { Int(String($0)) }\\n        var large = largeString.compactMap { Int(String($0)) }\\n        \\n        if small.count <= 0 { return \"0\" }\\n        if large.count <= 0 { return \"0\" }\\n        \\n        //Build the matrix which will store our \"rows\" a la \"by hand\" multiplication...\\n        var length = small.count + large.count + 1\\n        var workout = [[Int]](repeating: [Int](repeating: 0, count: length), count: small.count)\\n        \\n        var i = small.count - 1\\n        var shift = 0\\n        \\n        //Multiply number by number and store in matrix.\\n        while i >= 0 {\\n            var val1 = small[i]\\n            var carry = 0\\n            var j = large.count - 1\\n            var paste = length - (1 + shift)\\n            while j >= 0 {\\n                var val2 = large[j]\\n                var num = val1 * val2 + carry\\n                workout[i][paste] = num % 10\\n                carry = num / 10\\n                j -= 1\\n                paste -= 1\\n            }\\n            while carry > 0 {\\n                workout[i][paste] = carry % 10\\n                carry /= 10\\n                paste -= 1   \\n            }\\n            shift += 1\\n            i -= 1\\n        }\\n        \\n        var j = length - 1\\n        \\n        \\n        var res = [Int](repeating: 0, count: length)\\n        \\n        //Add the lines of our workout together.\\n        var carry: Int = 0\\n        while j >= 0 {\\n            var sum: Int = carry\\n            i = 0\\n            while i < small.count {\\n                sum += workout[i][j]\\n                i += 1\\n            }\\n            res[j] = sum % 10\\n            carry = sum / 10\\n            j -= 1\\n        }\\n        \\n        //Skip the dangling zeroes...\\n        var zeroIndex = 0\\n        while zeroIndex < length && res[zeroIndex] == 0 { zeroIndex += 1 }\\n        if zeroIndex == length { zeroIndex = length - 1 }\\n        res = Array(res[zeroIndex...])\\n        \\n        //Use swift magic to quickly derive a string from this array..!\\n        return res.map { String($0) }.joined()\\n    }\\n}\\n```\\n\\nThere must be more compact ways to write this code. This is just what I could muster up. It took a sad amount of time before the solution actually was working.",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    func multiply(_ num1: String, _ num2: String) -> String {\\n        \\n        //Figure out smaller and larger string...\\n        var smallString = num1, largeString = num2\\n        if smallString.count > largeString.count { smallString = num2; largeString = num1 }\\n        \\n        //We work with ints, not with characters.\\n        var small = smallString.compactMap { Int(String($0)) }\\n        var large = largeString.compactMap { Int(String($0)) }\\n        \\n        if small.count <= 0 { return \"0\" }\\n        if large.count <= 0 { return \"0\" }\\n        \\n        //Build the matrix which will store our \"rows\" a la \"by hand\" multiplication...\\n        var length = small.count + large.count + 1\\n        var workout = [[Int]](repeating: [Int](repeating: 0, count: length), count: small.count)\\n        \\n        var i = small.count - 1\\n        var shift = 0\\n        \\n        //Multiply number by number and store in matrix.\\n        while i >= 0 {\\n            var val1 = small[i]\\n            var carry = 0\\n            var j = large.count - 1\\n            var paste = length - (1 + shift)\\n            while j >= 0 {\\n                var val2 = large[j]\\n                var num = val1 * val2 + carry\\n                workout[i][paste] = num % 10\\n                carry = num / 10\\n                j -= 1\\n                paste -= 1\\n            }\\n            while carry > 0 {\\n                workout[i][paste] = carry % 10\\n                carry /= 10\\n                paste -= 1   \\n            }\\n            shift += 1\\n            i -= 1\\n        }\\n        \\n        var j = length - 1\\n        \\n        \\n        var res = [Int](repeating: 0, count: length)\\n        \\n        //Add the lines of our workout together.\\n        var carry: Int = 0\\n        while j >= 0 {\\n            var sum: Int = carry\\n            i = 0\\n            while i < small.count {\\n                sum += workout[i][j]\\n                i += 1\\n            }\\n            res[j] = sum % 10\\n            carry = sum / 10\\n            j -= 1\\n        }\\n        \\n        //Skip the dangling zeroes...\\n        var zeroIndex = 0\\n        while zeroIndex < length && res[zeroIndex] == 0 { zeroIndex += 1 }\\n        if zeroIndex == length { zeroIndex = length - 1 }\\n        res = Array(res[zeroIndex...])\\n        \\n        //Use swift magic to quickly derive a string from this array..!\\n        return res.map { String($0) }.joined()\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 253437,
                "title": "simple-javascript-solution",
                "content": "```\\n/**\\n * @param {string} num1\\n * @param {string} num2\\n * @return {string}\\n */\\nvar multiply = function(num1, num2) {\\n    if (num1 == \\'0\\' || num2 == \\'0\\') { return \\'0\\'; }\\n\\n    let product = new Array(num1.length + num2.length);\\n    product.fill(0);\\n    let pos = product.length - 1;\\n\\n    for (let i = num1.length - 1; i >= 0; i--) {\\n        let tempPos = pos;\\n        for (let j = num2.length - 1; j >= 0; j--) {\\n            product[tempPos] += parseInt(num1.charAt(i)) * parseInt(num2.charAt(j));\\n            product[tempPos-1] += Math.floor(product[tempPos] / 10); // carry\\n            product[tempPos] %= 10;\\n            tempPos -= 1;\\n        }\\n        pos -= 1;\\n    }\\n\\n    return product.join(\"\").replace(/^0+/, \"\");\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * @param {string} num1\\n * @param {string} num2\\n * @return {string}\\n */\\nvar multiply = function(num1, num2) {\\n    if (num1 == \\'0\\' || num2 == \\'0\\') { return \\'0\\'; }\\n\\n    let product = new Array(num1.length + num2.length);\\n    product.fill(0);\\n    let pos = product.length - 1;\\n\\n    for (let i = num1.length - 1; i >= 0; i--) {\\n        let tempPos = pos;\\n        for (let j = num2.length - 1; j >= 0; j--) {\\n            product[tempPos] += parseInt(num1.charAt(i)) * parseInt(num2.charAt(j));\\n            product[tempPos-1] += Math.floor(product[tempPos] / 10); // carry\\n            product[tempPos] %= 10;\\n            tempPos -= 1;\\n        }\\n        pos -= 1;\\n    }\\n\\n    return product.join(\"\").replace(/^0+/, \"\");\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 166630,
                "title": "c-solution-easy-to-understand-with-less-lines-beats-100",
                "content": "```\\nclass Solution {\\npublic:\\nstring multiply(string num1, string num2) {\\n  string res(num1.size() + num2.size(), \\'0\\');\\n  for (int i = num1.size() - 1; i >= 0; i--) {\\n    for (int j = num2.size() - 1; j >= 0; j--) {\\n        int prod =  (num1[i] - \\'0\\') * (num2[j] - \\'0\\') +  (res[i + j + 1] - \\'0\\');\\n        res[i+j+1] = (prod % 10) + \\'0\\';\\n        res[i+j] = ((prod /10) + (res[i + j] - \\'0\\')) + \\'0\\';\\n    }\\n  }\\n  //remove the trailing zeros\\n  int it = res.find_first_not_of(\"0\");\\n  return ( it < 0  ? \"0\" : res.substr(it) );\\n}\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\nstring multiply(string num1, string num2) {\\n  string res(num1.size() + num2.size(), \\'0\\');\\n  for (int i = num1.size() - 1; i >= 0; i--) {\\n    for (int j = num2.size() - 1; j >= 0; j--) {\\n        int prod =  (num1[i] - \\'0\\') * (num2[j] - \\'0\\') +  (res[i + j + 1] - \\'0\\');\\n        res[i+j+1] = (prod % 10) + \\'0\\';\\n        res[i+j] = ((prod /10) + (res[i + j] - \\'0\\')) + \\'0\\';\\n    }\\n  }\\n  //remove the trailing zeros\\n  int it = res.find_first_not_of(\"0\");\\n  return ( it < 0  ? \"0\" : res.substr(it) );\\n}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 161964,
                "title": "javascript-solution",
                "content": "```\\nvar multiply = function(num1, num2) {\\n    if(num1== 0 || num2==0){\\n        return \"0\";\\n    }\\n    var sum = [];\\n    for(i = 0; i < num1.length; i++){\\n        for(j = 0; j < num2.length; j++){\\n            if(sum[i+j] == undefined){\\n                sum[i+j] =num1[i]*num2[j];\\n            }else{\\n                sum[i+j] += num1[i]*num2[j];\\n            }\\n        }\\n    }\\n    \\n    sum.reverse();\\n    for(let i = 0; i< sum.length; i++){\\n        if(sum[i] > 9){          \\n            if(sum[i+1] == undefined){\\n                sum[i+1] = Math.floor(sum[i] / 10);\\n            }else{\\n                sum[i+1] += Math.floor(sum[i] / 10);\\n            }\\n           sum[i] = sum[i] % 10; \\n        }\\n    }\\n    return sum.reverse().join(\"\");\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar multiply = function(num1, num2) {\\n    if(num1== 0 || num2==0){\\n        return \"0\";\\n    }\\n    var sum = [];\\n    for(i = 0; i < num1.length; i++){\\n        for(j = 0; j < num2.length; j++){\\n            if(sum[i+j] == undefined){\\n                sum[i+j] =num1[i]*num2[j];\\n            }else{\\n                sum[i+j] += num1[i]*num2[j];\\n            }\\n        }\\n    }\\n    \\n    sum.reverse();\\n    for(let i = 0; i< sum.length; i++){\\n        if(sum[i] > 9){          \\n            if(sum[i+1] == undefined){\\n                sum[i+1] = Math.floor(sum[i] / 10);\\n            }else{\\n                sum[i+1] += Math.floor(sum[i] / 10);\\n            }\\n           sum[i] = sum[i] % 10; \\n        }\\n    }\\n    return sum.reverse().join(\"\");\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 17675,
                "title": "14-line-python-solution-handwritten-approach-simulation",
                "content": "```\\nclass Solution(object):\\n    def multiply(self, num1, num2):\\n        \"\"\"\\n        :type num1: str\\n        :type num2: str\\n        :rtype: str\\n        \"\"\"\\n        num1 = [int(i) for i in num1][::-1]\\n        num2 = [int(i) for i in num2][::-1]\\n        len1, len2 = len(num1), len(num2)\\n        ans = [0 for _ in xrange(len1 + len2)]\\n        for i in xrange(len1):\\n            for j in xrange(len2):\\n                ans[i + j] += num1[i] * num2[j]\\n        for i in xrange(len(ans) - 1):\\n            ans[i + 1] += ans[i] / 10\\n            ans[i] %= 10\\n        for i in xrange(len(ans) - 1, -1, -1):\\n            if ans[i] != 0:\\n                return ''.join([str(i) for i in reversed(ans[:i + 1])])\\n        return '0'\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def multiply(self, num1, num2):\\n        \"\"\"\\n        :type num1: str\\n        :type num2: str\\n        :rtype: str\\n        \"\"\"\\n        num1 = [int(i) for i in num1][::-1]\\n        num2 = [int(i) for i in num2][::-1]\\n        len1, len2 = len(num1), len(num2)\\n        ans = [0 for _ in xrange(len1 + len2)]\\n        for i in xrange(len1):\\n            for j in xrange(len2):\\n                ans[i + j] += num1[i] * num2[j]\\n        for i in xrange(len(ans) - 1):\\n            ans[i + 1] += ans[i] / 10\\n            ans[i] %= 10\\n        for i in xrange(len(ans) - 1, -1, -1):\\n            if ans[i] != 0:\\n                return ''.join([str(i) for i in reversed(ans[:i + 1])])\\n        return '0'\\n```",
                "codeTag": "Java"
            },
            {
                "id": 17712,
                "title": "o-1-memory-java-9ms-solution",
                "content": "    public String multiply(String num1, String num2) {\\n        StringBuilder sb = new StringBuilder();\\n        int m = num1.length(), n = num2.length(), carry = 0;\\n        \\n        if (num1.charAt(0) == '0' || num2.charAt(0) == '0') return \"0\";\\n        \\n        for (int k = 0; k < m+n-1; k++) {\\n            for (int i = Math.max(0,k-n+1); i < Math.min(m,k+1); i++) {\\n                int j = k-i;\\n                carry += (num1.charAt(m-i-1)-'0')*(num2.charAt(n-j-1)-'0');\\n            }\\n            sb.append(carry%10);\\n            carry = carry/10;\\n        }\\n        if (carry > 0) sb.append(carry);\\n        return sb.reverse().toString();\\n    }",
                "solutionTags": [],
                "code": "    public String multiply(String num1, String num2) {\\n        StringBuilder sb = new StringBuilder();\\n        int m = num1.length(), n = num2.length(), carry = 0;\\n        \\n        if (num1.charAt(0) == '0' || num2.charAt(0) == '0') return \"0\";\\n        \\n        for (int k = 0; k < m+n-1; k++) {\\n            for (int i = Math.max(0,k-n+1); i < Math.min(m,k+1); i++) {\\n                int j = k-i;\\n                carry += (num1.charAt(m-i-1)-'0')*(num2.charAt(n-j-1)-'0');\\n            }\\n            sb.append(carry%10);\\n            carry = carry/10;\\n        }\\n        if (carry > 0) sb.append(carry);\\n        return sb.reverse().toString();\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 17740,
                "title": "8ms-simple-c-solution",
                "content": "    int m = num1.length();\\n            int n = num2.length();\\n            vector<int> results;\\n            for(int i=0; i < m+n; i++){\\n                results.push_back(0);\\n            }\\n            \\n            for(int i=0; i<m;i++){\\n                int v1=num1[m-1-i] -'0';\\n                for(int j=0; j <n; j++){\\n                    int v2 = num2[n-1-j] -'0';\\n                    results[i+j] += v1 * v2;\\n                }\\n            }\\n    \\n    \\t\\tint carry =0;\\n    \\t\\tfor(int i=0; i < m+n; i++){\\n    \\t\\t\\tint value = results[i] + carry;\\n    \\t\\t\\tresults[i] = value % 10;\\n    \\t\\t\\tcarry = value/10;\\n    \\t\\t}\\n    \\t\\t\\n    \\t\\tstring re=\"\";\\n    \\t\\tbool findNoZero = false;\\n    \\t\\tfor(int i= m+n-1; i >=0; i--){\\n    \\t\\t\\tif(findNoZero){\\n    \\t\\t\\t\\tre += (results[i] + '0');\\n    \\t\\t\\t}else{\\n    \\t\\t\\t\\tif(results[i] != 0){\\n    \\t\\t\\t\\t\\tfindNoZero = true;\\n    \\t\\t\\t\\t\\tre += (results[i] + '0');\\n    \\t\\t\\t\\t}\\n    \\t\\t\\t}\\n    \\t\\t}\\n    \\n    \\t\\tif(re == \"\")\\n    \\t\\t\\tre = \"0\";\\n    \\t\\treturn re;",
                "solutionTags": [],
                "code": "    int m = num1.length();\\n            int n = num2.length();\\n            vector<int> results;\\n            for(int i=0; i < m+n; i++){\\n                results.push_back(0);\\n            }\\n            \\n            for(int i=0; i<m;i++){\\n                int v1=num1[m-1-i] -'0';\\n                for(int j=0; j <n; j++){\\n                    int v2 = num2[n-1-j] -'0';\\n                    results[i+j] += v1 * v2;\\n                }\\n            }\\n    \\n    \\t\\tint carry =0;\\n    \\t\\tfor(int i=0; i < m+n; i++){\\n    \\t\\t\\tint value = results[i] + carry;\\n    \\t\\t\\tresults[i] = value % 10;\\n    \\t\\t\\tcarry = value/10;\\n    \\t\\t}\\n    \\t\\t\\n    \\t\\tstring re=\"\";\\n    \\t\\tbool findNoZero = false;\\n    \\t\\tfor(int i= m+n-1; i >=0; i--){\\n    \\t\\t\\tif(findNoZero){\\n    \\t\\t\\t\\tre += (results[i] + '0');\\n    \\t\\t\\t}else{\\n    \\t\\t\\t\\tif(results[i] != 0){\\n    \\t\\t\\t\\t\\tfindNoZero = true;\\n    \\t\\t\\t\\t\\tre += (results[i] + '0');\\n    \\t\\t\\t\\t}\\n    \\t\\t\\t}\\n    \\t\\t}\\n    \\n    \\t\\tif(re == \"\")\\n    \\t\\t\\tre = \"0\";\\n    \\t\\treturn re;",
                "codeTag": "Unknown"
            },
            {
                "id": 4055989,
                "title": "an-easy-approach-no-stress-just-observe-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n**O ( n * m )**\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string multiply(string num1, string num2) {\\n        int a = num1.size();\\n        int b = num2.size();\\n        \\n        // create a string value that is include the result\\n        string res(a+b, \\'0\\');\\n\\n        // multiply values with each other by running for loop\\n        // substracting \\'0\\' from string char number makes it integer\\n        for(int i=a-1; i>=0; i--) {\\n            for(int j=b-1; j>=0; j--) {\\n                int di = (num1[i] - \\'0\\') * (num2[j] - \\'0\\') + (res[i+j+1]-\\'0\\');\\n                res[i+j+1] = di % 10 + \\'0\\';\\n                res[i+j] += di/10;\\n            }\\n        }\\n\\n        // check if there is it start with zero\\n\\n        for(int i=0; i<res.size(); i++) {\\n            if(res[i]!=\\'0\\') return res.substr(i);\\n        }\\n        return \"0\";\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string multiply(string num1, string num2) {\\n        int a = num1.size();\\n        int b = num2.size();\\n        \\n        // create a string value that is include the result\\n        string res(a+b, \\'0\\');\\n\\n        // multiply values with each other by running for loop\\n        // substracting \\'0\\' from string char number makes it integer\\n        for(int i=a-1; i>=0; i--) {\\n            for(int j=b-1; j>=0; j--) {\\n                int di = (num1[i] - \\'0\\') * (num2[j] - \\'0\\') + (res[i+j+1]-\\'0\\');\\n                res[i+j+1] = di % 10 + \\'0\\';\\n                res[i+j] += di/10;\\n            }\\n        }\\n\\n        // check if there is it start with zero\\n\\n        for(int i=0; i<res.size(); i++) {\\n            if(res[i]!=\\'0\\') return res.substr(i);\\n        }\\n        return \"0\";\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3809236,
                "title": "simply-easy-solution-100",
                "content": "\\nimport java.math.BigInteger;\\nclass Solution {\\n    public String multiply(String num1, String num2) {\\n        BigInteger a=new BigInteger(num1);\\n        BigInteger b=new BigInteger(num2);\\n        BigInteger mul=a.multiply(b);\\n        //BigInteger mul=a*b;\\n        String c=String.valueOf(mul);\\n        return c;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public String multiply(String num1, String num2) {\\n        BigInteger a=new BigInteger(num1);\\n        BigInteger b=new BigInteger(num2);\\n        BigInteger mul=a.multiply(b);\\n        //BigInteger mul=a*b;\\n        String c=String.valueOf(mul);\\n        return c;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 3333711,
                "title": "multiply-strings",
                "content": "# Intuition\\nconvert the input string into an integer without using inbuilt functions, and multiply the converted input \\n\\n# Approach\\nCreate a dictionary to map each of the numbers in the string to an integer.\\nRead the input string in reverse order, read each of the value, get the coresponding integer from the dictionary and multiply it with its position in the reversed string times 10.\\nEx:- Original input \\'123\\'\\n     reversed Input \\'321\\' \\n    3*(10 times position of 3 in the input which is 0, 10 times 0 is 1)+\\n    2*(10 ** position of 2 in the input which is 1, 10 times 1 is 10)+\\n    1 *(10 ** position of 1 in the input which is 2)\\n    sum of the converted input is 123 \\n\\n# Complexity\\n- Time complexity:\\nWe need to read the entire input string once.\\n4* o(n)  = o(n)\\n\\n# Space complexity:\\no(n)\\n\\n# Code\\n```\\nclass Solution:\\n    def multiply(self, num1: str, num2: str) -> str:\\n\\n        x = {}\\n        for i in range(0,10):\\n            x[str(i)] = i\\n        i1 = []\\n        i2 = []\\n        mul = 10\\n        for i,j in enumerate(num1[::-1]):\\n            i1.append(x[j] * (mul**i))\\n        for i,j in enumerate(num2[::-1]):\\n            i2.append(x[j] * (mul**i)) \\n        return (str(sum(i1)*sum(i2))) \\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def multiply(self, num1: str, num2: str) -> str:\\n\\n        x = {}\\n        for i in range(0,10):\\n            x[str(i)] = i\\n        i1 = []\\n        i2 = []\\n        mul = 10\\n        for i,j in enumerate(num1[::-1]):\\n            i1.append(x[j] * (mul**i))\\n        for i,j in enumerate(num2[::-1]):\\n            i2.append(x[j] * (mul**i)) \\n        return (str(sum(i1)*sum(i2))) \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3159323,
                "title": "simple-solution-c-easy-to-understand-multiply-two-strings",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nFirst Multiply Digits one by one and then do sum of two strings \\n\\n# Complexity\\n- Time complexity:O(n*m)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# C\\n```\\nclass Solution {\\npublic:\\n    //function for addition of two strings\\nstring sumstr(string s1,string s2){\\n       string ans = \"\";\\n       int L1 = s1.length()-1,L2 = s2.length()-1;\\n       int prev_carry = 0;\\n       while(L1>=0||L2>=0){\\n           int curr_sum = 0;\\n           if(L1>=0){\\n            curr_sum += s1[L1--]-\\'0\\';\\n           }\\n           if(L2>=0){\\n               curr_sum += s2[L2--]-\\'0\\';\\n           }\\n           curr_sum += prev_carry;\\n           ans.push_back(curr_sum%10+\\'0\\');\\n           prev_carry = curr_sum/10;\\n       }\\n       if(prev_carry>0){\\n           ans.push_back(prev_carry+\\'0\\');\\n       }\\n       reverse(ans.begin(),ans.end());\\n    return ans;\\n   }\\n\\n//function for multiplication\\n    string multiply(string num1, string num2) {\\n       int l1 = num1.length(),l2 = num2.length();\\n       if(l1==1){\\n           if(num1[0]==\\'0\\')\\n           return \"0\";\\n           \\n       }\\n       if(l2==1){\\n           if(num2[0]==\\'0\\')\\n           return \"0\";\\n       }\\n       string final_str = \"\";\\n       int cnt = 0;\\n       for(int i=l1-1;i>=0;i--){\\n           string temp = \"\";\\n           int l_cnt = cnt;\\n           while(l_cnt>0){\\n              temp.push_back(\\'0\\');\\n              l_cnt--;\\n           }\\n\\t\\t   cnt++;\\n           int carry = 0;\\n           for(int j = l2-1;j>=0;j--){\\n               int mltply = (num2[j]-\\'0\\')*(num1[i]-\\'0\\')+carry;\\n               temp.push_back((mltply%10)+\\'0\\');\\n                carry = mltply/10;\\n           }\\n           if(carry>0){\\n               temp.push_back(carry+\\'0\\');\\n           }\\n           reverse(temp.begin(),temp.end());\\n           final_str = sumstr(final_str,temp);\\n       }\\n        return final_str;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    //function for addition of two strings\\nstring sumstr(string s1,string s2){\\n       string ans = \"\";\\n       int L1 = s1.length()-1,L2 = s2.length()-1;\\n       int prev_carry = 0;\\n       while(L1>=0||L2>=0){\\n           int curr_sum = 0;\\n           if(L1>=0){\\n            curr_sum += s1[L1--]-\\'0\\';\\n           }\\n           if(L2>=0){\\n               curr_sum += s2[L2--]-\\'0\\';\\n           }\\n           curr_sum += prev_carry;\\n           ans.push_back(curr_sum%10+\\'0\\');\\n           prev_carry = curr_sum/10;\\n       }\\n       if(prev_carry>0){\\n           ans.push_back(prev_carry+\\'0\\');\\n       }\\n       reverse(ans.begin(),ans.end());\\n    return ans;\\n   }\\n\\n//function for multiplication\\n    string multiply(string num1, string num2) {\\n       int l1 = num1.length(),l2 = num2.length();\\n       if(l1==1){\\n           if(num1[0]==\\'0\\')\\n           return \"0\";\\n           \\n       }\\n       if(l2==1){\\n           if(num2[0]==\\'0\\')\\n           return \"0\";\\n       }\\n       string final_str = \"\";\\n       int cnt = 0;\\n       for(int i=l1-1;i>=0;i--){\\n           string temp = \"\";\\n           int l_cnt = cnt;\\n           while(l_cnt>0){\\n              temp.push_back(\\'0\\');\\n              l_cnt--;\\n           }\\n\\t\\t   cnt++;\\n           int carry = 0;\\n           for(int j = l2-1;j>=0;j--){\\n               int mltply = (num2[j]-\\'0\\')*(num1[i]-\\'0\\')+carry;\\n               temp.push_back((mltply%10)+\\'0\\');\\n                carry = mltply/10;\\n           }\\n           if(carry>0){\\n               temp.push_back(carry+\\'0\\');\\n           }\\n           reverse(temp.begin(),temp.end());\\n           final_str = sumstr(final_str,temp);\\n       }\\n        return final_str;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3158538,
                "title": "multiply-strings-python3",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def multiply(self, num1: str, num2: str) -> str:\\n        m, n = len(num1), len(num2)\\n        pos = [0] * (m + n)\\n        for i in range(m - 1, -1, -1):\\n            for j in range(n - 1, -1, -1):\\n                mul = (ord(num1[i]) - ord(\\'0\\')) * (ord(num2[j]) - ord(\\'0\\'))\\n                p1, p2 = i + j, i + j + 1\\n                sum = mul + pos[p2]\\n                pos[p1] += sum // 10\\n                pos[p2] = sum % 10\\n        res = \"\"\\n        for p in pos:\\n            if not (len(res) == 0 and p == 0):\\n                res += str(p)\\n        return res if len(res) != 0 else \"0\"\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def multiply(self, num1: str, num2: str) -> str:\\n        m, n = len(num1), len(num2)\\n        pos = [0] * (m + n)\\n        for i in range(m - 1, -1, -1):\\n            for j in range(n - 1, -1, -1):\\n                mul = (ord(num1[i]) - ord(\\'0\\')) * (ord(num2[j]) - ord(\\'0\\'))\\n                p1, p2 = i + j, i + j + 1\\n                sum = mul + pos[p2]\\n                pos[p1] += sum // 10\\n                pos[p2] = sum % 10\\n        res = \"\"\\n        for p in pos:\\n            if not (len(res) == 0 and p == 0):\\n                res += str(p)\\n        return res if len(res) != 0 else \"0\"\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3133787,
                "title": "python3-code",
                "content": "# Code\\n```\\nclass Solution:\\n    def multiply(self, num1: str, num2: str) -> str:\\n        return str(int(num1) * int(num2))\\n```\\n\\n![image.png](https://assets.leetcode.com/users/images/c0a6e42f-0e5b-45d1-9342-b3f4da3f1615_1675379962.274941.png)",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def multiply(self, num1: str, num2: str) -> str:\\n        return str(int(num1) * int(num2))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3044006,
                "title": "no-built-in-function-very-easy-understandable-solution-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nimport java.math.BigInteger;\\nclass Solution {\\n    public String multiply(String num1, String num2) {\\n\\n        if(num1.equals(\"0\") || num2.equals(\"0\")) return \"0\";\\n\\n        int l1=num1.length();\\n        int l2=num2.length();\\n\\n        int a[]=new int[l1+l2];\\n\\n        int i=l2-1;\\n        int pf=0;\\n\\n        while(i>=0){\\n            int ival=num2.charAt(i)-\\'0\\';\\n            i--;\\n\\n            int j=l1-1;\\n            int k=a.length-1-pf;\\n            int carry=0;\\n\\n            while(carry!=0 || j>=0){\\n                int jval=j>=0 ? num1.charAt(j)-\\'0\\':0;\\n               \\n                j--;\\n\\n                int product=ival*jval+carry+a[k];\\n                \\n                a[k]=product%10;\\n                carry=product/10;\\n                k--;    \\n\\n            }\\n            pf++;\\n        }\\n\\n        //for removing leading zero\\n        String ans=\"\";\\n        boolean flag=false;\\n\\n        for(int e:a){\\n            if(e==0 && flag==false){\\n                continue;\\n            }\\n            else{\\n                flag=true;\\n                ans+=e;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nimport java.math.BigInteger;\\nclass Solution {\\n    public String multiply(String num1, String num2) {\\n\\n        if(num1.equals(\"0\") || num2.equals(\"0\")) return \"0\";\\n\\n        int l1=num1.length();\\n        int l2=num2.length();\\n\\n        int a[]=new int[l1+l2];\\n\\n        int i=l2-1;\\n        int pf=0;\\n\\n        while(i>=0){\\n            int ival=num2.charAt(i)-\\'0\\';\\n            i--;\\n\\n            int j=l1-1;\\n            int k=a.length-1-pf;\\n            int carry=0;\\n\\n            while(carry!=0 || j>=0){\\n                int jval=j>=0 ? num1.charAt(j)-\\'0\\':0;\\n               \\n                j--;\\n\\n                int product=ival*jval+carry+a[k];\\n                \\n                a[k]=product%10;\\n                carry=product/10;\\n                k--;    \\n\\n            }\\n            pf++;\\n        }\\n\\n        //for removing leading zero\\n        String ans=\"\";\\n        boolean flag=false;\\n\\n        for(int e:a){\\n            if(e==0 && flag==false){\\n                continue;\\n            }\\n            else{\\n                flag=true;\\n                ans+=e;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3035980,
                "title": "c-brute-force-easy-approach",
                "content": "Here is my c++ code for this problem.\\n\\n# Complexity\\n- Time complexity:$$O(n^2)$$\\n\\n- Space complexity:$$O(n)$$\\n\\n# Code\\n```\\n#include<bits/stdc++.h>\\nclass Solution {\\npublic:\\n    string multiply(string num1, string num2) {\\n        string final=\"\";\\n        vector<string>s;\\n        for(int i=num1.size()-1; i>=0; i--){\\n            string ans=\"\";\\n            int carry=0;\\n            for(int j=num2.size()-1; j>=0; j--){\\n                int num=(num1[i]-\\'0\\')*(num2[j]-\\'0\\')+carry;\\n                ans+=to_string(num%10);\\n                carry=num/10;\\n            }\\n            if(carry){ans+=to_string(carry);}\\n            int l=num1.size()-i-1;\\n            while(l){\\n                ans.insert(ans.begin(), \\'0\\');\\n                l--;\\n            }\\n            reverse(ans.begin(), ans.end());\\n            s.push_back(ans);\\n        }\\n        if(s.size()==1){\\n            if(count(s[0].begin(), s[0].end(), \\'0\\')==s[0].size()){return \"0\";}\\n            return s[0];\\n        }\\n        for(int i=0; i<s.size(); i++){\\n            cout<<s[i]<<endl;\\n        }\\n        for(int i=0; i<s.size()-1; i++){\\n            string s1=s[i], s2=s[i+1];\\n            reverse(s1.begin(), s1.end());\\n            reverse(s2.begin(), s2.end());\\n            int carry=0;\\n            string fi=\"\";\\n            if(s1.size()>s2.size()){\\n                for(int j=0; j<s2.size(); j++){\\n                    int num=(s1[j]-\\'0\\')+(s2[j]-\\'0\\')+carry;\\n                    carry=num/10;\\n                    fi+=to_string(num%10);\\n                }\\n                for(int j=s2.size(); j<s1.size(); j++){\\n                    int num=(s1[j]-\\'0\\')+carry;\\n                    carry=num/10;\\n                    fi+=to_string(num%10);\\n                }\\n                if(carry){\\n                    fi+=to_string(carry);\\n                }\\n                reverse(fi.begin(), fi.end());\\n            }\\n            else{\\n                cout<<\"here\"<<endl;\\n                for(int j=0; j<s1.size(); j++){\\n                    int num=(s1[j]-\\'0\\')+(s2[j]-\\'0\\')+carry;\\n                    carry=num/10;\\n                    fi+=to_string(num%10);\\n                }\\n                cout<<fi<<endl;\\n                for(int j=s1.size(); j<s2.size(); j++){\\n                    int num=(s2[j]-\\'0\\')+carry;\\n                    carry=num/10;\\n                    fi+=to_string(num%10);\\n                }\\n                if(carry){\\n                    fi+=to_string(carry);\\n                }\\n                reverse(fi.begin(), fi.end());\\n            }\\n            cout<<s[i]<<\" \"<<s[i+1]<<\" \"<<fi<<endl;\\n            final=fi;\\n            s[i+1]=fi;\\n        }\\n        cout<<final<<\" \"<<count(final.begin(), final.end(), \\'0\\')<<\" \"<<final.size()<<endl;\\n        if(count(final.begin(), final.end(), \\'0\\')==final.size()){return \"0\";}\\n        return final;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math",
                    "String",
                    "Simulation"
                ],
                "code": "```\\n#include<bits/stdc++.h>\\nclass Solution {\\npublic:\\n    string multiply(string num1, string num2) {\\n        string final=\"\";\\n        vector<string>s;\\n        for(int i=num1.size()-1; i>=0; i--){\\n            string ans=\"\";\\n            int carry=0;\\n            for(int j=num2.size()-1; j>=0; j--){\\n                int num=(num1[i]-\\'0\\')*(num2[j]-\\'0\\')+carry;\\n                ans+=to_string(num%10);\\n                carry=num/10;\\n            }\\n            if(carry){ans+=to_string(carry);}\\n            int l=num1.size()-i-1;\\n            while(l){\\n                ans.insert(ans.begin(), \\'0\\');\\n                l--;\\n            }\\n            reverse(ans.begin(), ans.end());\\n            s.push_back(ans);\\n        }\\n        if(s.size()==1){\\n            if(count(s[0].begin(), s[0].end(), \\'0\\')==s[0].size()){return \"0\";}\\n            return s[0];\\n        }\\n        for(int i=0; i<s.size(); i++){\\n            cout<<s[i]<<endl;\\n        }\\n        for(int i=0; i<s.size()-1; i++){\\n            string s1=s[i], s2=s[i+1];\\n            reverse(s1.begin(), s1.end());\\n            reverse(s2.begin(), s2.end());\\n            int carry=0;\\n            string fi=\"\";\\n            if(s1.size()>s2.size()){\\n                for(int j=0; j<s2.size(); j++){\\n                    int num=(s1[j]-\\'0\\')+(s2[j]-\\'0\\')+carry;\\n                    carry=num/10;\\n                    fi+=to_string(num%10);\\n                }\\n                for(int j=s2.size(); j<s1.size(); j++){\\n                    int num=(s1[j]-\\'0\\')+carry;\\n                    carry=num/10;\\n                    fi+=to_string(num%10);\\n                }\\n                if(carry){\\n                    fi+=to_string(carry);\\n                }\\n                reverse(fi.begin(), fi.end());\\n            }\\n            else{\\n                cout<<\"here\"<<endl;\\n                for(int j=0; j<s1.size(); j++){\\n                    int num=(s1[j]-\\'0\\')+(s2[j]-\\'0\\')+carry;\\n                    carry=num/10;\\n                    fi+=to_string(num%10);\\n                }\\n                cout<<fi<<endl;\\n                for(int j=s1.size(); j<s2.size(); j++){\\n                    int num=(s2[j]-\\'0\\')+carry;\\n                    carry=num/10;\\n                    fi+=to_string(num%10);\\n                }\\n                if(carry){\\n                    fi+=to_string(carry);\\n                }\\n                reverse(fi.begin(), fi.end());\\n            }\\n            cout<<s[i]<<\" \"<<s[i+1]<<\" \"<<fi<<endl;\\n            final=fi;\\n            s[i+1]=fi;\\n        }\\n        cout<<final<<\" \"<<count(final.begin(), final.end(), \\'0\\')<<\" \"<<final.size()<<endl;\\n        if(count(final.begin(), final.end(), \\'0\\')==final.size()){return \"0\";}\\n        return final;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2860686,
                "title": "c-easy-and-simple-solution",
                "content": "***Guy\\'s if you find this solution helpful \\uD83D\\uDE0A, PLEASE do UPVOTE. By doing that it motivate\\'s me to create more better post like this \\u270D\\uFE0F***\\n```\\nclass Solution {\\npublic:\\n    string multiply(string num1, string num2) {\\n        int len1=num1.length();\\n        int len2=num2.length();\\n        int max_len=len1+len2;\\n        int i=len2-1;\\n        vector<int>result(max_len,0);\\n        int pf=0;\\n        while(i>=0){\\n            int j=len1-1;\\n            int ival=num2[i]-\\'0\\';\\n            int carry=0;\\n            int k=result.size()-1-pf;\\n            while(j>=0 || carry!=0){\\n                int jval=j>=0?num1[j]-\\'0\\':0;\\n                int product=ival*jval+carry+result[k];\\n                result[k]=product%10;\\n                carry=product/10;\\n                k--;\\n                j--;\\n            }\\n            pf++;\\n            i--;\\n        }\\n        string ans=\"\";\\n         i=0;\\n        while(i<result.size() && result[i]==0) i++;\\n        while(i<result.size()){\\n            ans+=result[i]+\\'0\\';\\n            i++;\\n        }\\n        if(ans.length()==0) ans+=\\'0\\';\\n        return ans;\\n    }\\n};\\n```\\n***Guy\\'s if you find this solution helpful \\uD83D\\uDE0A, PLEASE do UPVOTE. By doing that it motivate\\'s me to create more better post like this \\u270D\\uFE0F***",
                "solutionTags": [
                    "C++",
                    "C",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string multiply(string num1, string num2) {\\n        int len1=num1.length();\\n        int len2=num2.length();\\n        int max_len=len1+len2;\\n        int i=len2-1;\\n        vector<int>result(max_len,0);\\n        int pf=0;\\n        while(i>=0){\\n            int j=len1-1;\\n            int ival=num2[i]-\\'0\\';\\n            int carry=0;\\n            int k=result.size()-1-pf;\\n            while(j>=0 || carry!=0){\\n                int jval=j>=0?num1[j]-\\'0\\':0;\\n                int product=ival*jval+carry+result[k];\\n                result[k]=product%10;\\n                carry=product/10;\\n                k--;\\n                j--;\\n            }\\n            pf++;\\n            i--;\\n        }\\n        string ans=\"\";\\n         i=0;\\n        while(i<result.size() && result[i]==0) i++;\\n        while(i<result.size()){\\n            ans+=result[i]+\\'0\\';\\n            i++;\\n        }\\n        if(ans.length()==0) ans+=\\'0\\';\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2375741,
                "title": "python-1-line-solution",
                "content": "```\\nclass Solution:\\n    def multiply(self, num1: str, num2: str) -> str:\\n        return str(eval(num1+\"*\"+num2))\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def multiply(self, num1: str, num2: str) -> str:\\n        return str(eval(num1+\"*\"+num2))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2353198,
                "title": "c-with-explanation",
                "content": "[Question Link](https://leetcode.com/problems/multiply-strings/discuss/2353198/C%2B%2B-with-explanation)\\n\\n**Explanation**\\nS1 - Use 2 nested for loops, start from the end of both number. We will calculate our parital result in there.\\nS2 - Skip leading `0` , if present\\nS3 - Convert vector to the string\\n\\n<hr>\\n\\n\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tstring multiply(string nums1, string nums2) {\\n\\t\\t\\tif(nums1 == \"0\" || nums2 == \"0\")\\n\\t\\t\\t\\treturn \"0\";\\n            \\n\\t\\t\\tint n = nums1.size();\\n\\t\\t\\tint m = nums2.size();\\n\\t\\t\\t// n + m = max size of pdts.\\n\\t\\t\\tvector<int> v(n+m, 0); \\n        \\n\\t\\t\\t// making the number by multiplying one digit at a time.\\n\\t\\t\\tfor(int i=n-1; i>=0; i--){\\n\\t\\t\\t\\tfor(int j=m-1; j>=0; j--){\\n\\t\\t\\t\\t\\tv[i+j+1] += (nums1[i] - \\'0\\') * (nums2[j] - \\'0\\');\\n\\t\\t\\t\\t\\tv[i+j] += v[i+j+1] / 10;\\n\\t\\t\\t\\t\\tv[i+j+1] %= 10;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n        \\n\\t\\t\\t// skip leading zero\\n\\t\\t\\tint i = 0;\\n\\t\\t\\twhile(i < v.size() && v[i] == 0)\\n\\t\\t\\t\\ti++;\\n        \\n\\t\\t\\t// converting vector to a string \\n\\t\\t\\tstring ans;\\n\\t\\t\\twhile(i < v.size()){\\n\\t\\t\\t\\tans.push_back(v[i] + \\'0\\');\\n\\t\\t\\t\\ti++;\\n\\t\\t\\t}\\n            \\n\\t\\t\\treturn ans;\\n\\t\\t}\\n\\t};\\n\\t\\n\\t",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tstring multiply(string nums1, string nums2) {\\n\\t\\t\\tif(nums1 == \"0\" || nums2 == \"0\")\\n\\t\\t\\t\\treturn \"0\";\\n            \\n\\t\\t\\tint n = nums1.size();\\n\\t\\t\\tint m = nums2.size();\\n\\t\\t\\t// n + m = max size of pdts.\\n\\t\\t\\tvector<int> v(n+m, 0); \\n        \\n\\t\\t\\t// making the number by multiplying one digit at a time.\\n\\t\\t\\tfor(int i=n-1; i>=0; i--){\\n\\t\\t\\t\\tfor(int j=m-1; j>=0; j--){\\n\\t\\t\\t\\t\\tv[i+j+1] += (nums1[i] - \\'0\\') * (nums2[j] - \\'0\\');\\n\\t\\t\\t\\t\\tv[i+j] += v[i+j+1] / 10;\\n\\t\\t\\t\\t\\tv[i+j+1] %= 10;\\n\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2352109,
                "title": "string-c",
                "content": "```\\n string multiply(string num1, string num2) {\\n        int n=num2.length()+num1.length();\\n        int t=num2.length();\\n        vector<vector<int>>ans(num2.length(), vector<int>(n, 0));\\n        string s=\"\";\\n        int j=0;\\n        while(j<num2.length())\\n        {\\n            int m=t-j;\\n            int l=ans[j].size()-m;\\n            int carry=0;\\n            int temp=num2[j]-\\'0\\';\\n            for(int i=num1.length()-1;i>=0;i--)\\n            {\\n                int temp1=num1[i]-\\'0\\';\\n                temp1=temp1*temp + carry;\\n                ans[j][l]=temp1%10;\\n                carry=temp1/10;\\n                l--;\\n            }\\n            if(carry!=0)\\n            {\\n                ans[j][l]=carry;\\n            }\\n            j++;\\n            \\n        }\\n        int carry=0;\\n        for(int i=ans[0].size()-1;i>=0;i--)\\n        {\\n            int temp=0;\\n            for(int j=0;j<ans.size();j++)\\n            {\\n                temp+=ans[j][i];\\n            }\\n            temp+=carry;\\n            s=to_string(temp%10)+s;\\n            carry=temp/10;\\n        }\\n        while(s[0]==\\'0\\')\\n        {\\n            s.erase(0,1);\\n        }\\n        if(s.length()==0)\\n        {\\n            return \"0\";\\n        }\\n        return s;\\n        \\n    }\\n\\n```",
                "solutionTags": [
                    "String"
                ],
                "code": "```\\n string multiply(string num1, string num2) {\\n        int n=num2.length()+num1.length();\\n        int t=num2.length();\\n        vector<vector<int>>ans(num2.length(), vector<int>(n, 0));\\n        string s=\"\";\\n        int j=0;\\n        while(j<num2.length())\\n        {\\n            int m=t-j;\\n            int l=ans[j].size()-m;\\n            int carry=0;\\n            int temp=num2[j]-\\'0\\';\\n            for(int i=num1.length()-1;i>=0;i--)\\n            {\\n                int temp1=num1[i]-\\'0\\';\\n                temp1=temp1*temp + carry;\\n                ans[j][l]=temp1%10;\\n                carry=temp1/10;\\n                l--;\\n            }\\n            if(carry!=0)\\n            {\\n                ans[j][l]=carry;\\n            }\\n            j++;\\n            \\n        }\\n        int carry=0;\\n        for(int i=ans[0].size()-1;i>=0;i--)\\n        {\\n            int temp=0;\\n            for(int j=0;j<ans.size();j++)\\n            {\\n                temp+=ans[j][i];\\n            }\\n            temp+=carry;\\n            s=to_string(temp%10)+s;\\n            carry=temp/10;\\n        }\\n        while(s[0]==\\'0\\')\\n        {\\n            s.erase(0,1);\\n        }\\n        if(s.length()==0)\\n        {\\n            return \"0\";\\n        }\\n        return s;\\n        \\n    }\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2334732,
                "title": "python-karatsuba-commented-and-readable-with-intuitive-explanation-of-algorithm-o-n-log2-3",
                "content": "**Disclaimer:**\\n\\n[Karatsuba](https://en.wikipedia.org/wiki/Karatsuba_algorithm) is comparatively slower than elementary multiplication if the numbers are not sufficiently large. Karatsuba scales much better than elementary multiplication as we increase number of digits. Leetcode\\'s own implementation caps test cases at 200 digits. Karatsuba can handle significantly more than that.\\n\\nAverage case, elementary multiplication is `O(n^2)` while karatsuba is `O(n^log2(3)) \\u2248 O(n^1.59)`.\\n\\nMy implementation is probably not optimal, however it is somewhat explainable. It also has a **VERY STRICT** interpretation of the \"*must not ... convert the inputs to integer directly*\" note. Since karatsuba is a recursive divide-and-conquer algorithm, any input or sub-input is subjected to this rule. As a result, the implementation always keep the input as a `str`.\\n\\nBecause of this limitation, we even implement custom `add()` and `subtract()` functions which is probably overkill. In a real interview, there is no way I can come up with this on the spot. Anyways, enjoy! :)\\n\\n\\n**Solution:**\\n```\\nclass Solution:\\n    \"\"\"\\n    This is an implementation of the Karatsuba multiplication algorithm.\\n    Let\\'s compare elementary vs. Karatsuba multiplication with the\\n    following example:\\n\\t\\n         12\\n       x 34\\n       ----\\n        408\\n\\t\\t\\n    Elementary multiplication would result in us calculating\\n\\t\\n        2*4 + 1*4*10^1 + 2*3*10^1 + 1*3*10^2 = 408\\n        ---   ===        ===        ---\\n\\t\\t\\n    There are four multiplications (underlined) or 2^2 or O(n^2).\\n    Karatsuba multiplication (https://en.wikipedia.org/wiki/Karatsuba_algorithm)\\n    would result in us calculating first:\\n\\t\\n        1*3 = 3 and 2*4 = 8\\n\\t\\t\\n    Then we calculate:\\n\\t\\n        (1+2)(3+4) = 21\\n\\t\\t\\n    Then we calculate:\\n\\t\\n        (1+2)(3+4) - 1*3 - 2*4 = 10\\n\\t\\t\\n    Then we sum everything up with their correct base:\\n\\t\\n        3*10^2 + 10*10^1 + 8 = 408\\n\\t\\t\\n    So far, we\\'ve performed only three multiplications.\\n    We can always pad zeroes for the correct base.\\n    The reason why this works is because of (1+2)(3+4):\\n\\t\\n        (1+2)(3+4) = 2*4 + 1*4 + 2*3 + 1*3\\n                     ---   =========   ---\\n\\t\\t\\t\\t\\t \\n    1. Notice that these multiplications matches our elementary approach\\n    2. Notice that 1*4 and 2*3 shares the same base (10^1) in our elementary approach\\n\\n    Instead of calculating 1*4 and 2*3 directly, we can reuse 1*3 and 2*4 and\\n    make one more multiplication (1+2)(3+4):\\n\\t\\n        (1+2)(3+4) - 2*4 - 1*3 = 1*4 + 2*3\\n\\t\\t\\n    The above can be used to recursively build up multiplication between two integers.\\n    One way we can simplify our implementation is to left pad the shorter number with zeroes\\n    so that both numbers are of the same string length.\\n    \\n    The given the following:\\n    \\n         ab\\n       x cd\\n       \\n    And n == len(ab) == len(cd)\\n    \\n    The recurrance formula is:\\n    \\n        karatsuba(ab, cd) = 10^n*ac + 10^(n/2)*karatsuba(a+b, c+d) - ac - bd\\n        \\n    It has a runtime complexity of O(n^log2(3)).\\n\\t\\n    Resources:\\n    - https://youtu.be/JCbZayFr9RE\\n    - https://youtu.be/cCKOl5li6YM\\n    \"\"\"\\n    @cache\\n    def multiply(self, num1: str, num2: str) -> str:\\n        if num1 == \"0\" or num2 == \"0\":\\n            return \"0\"\\n        elif num1 == \"1\":\\n            return num2\\n        elif num2 == \"1\": \\n            return num1\\n        \\n        num1, num2 = self.padLeft(num1, num2)\\n\\n        if len(num1) == 1 and len(num2) == 1:\\n            # This is the only time we multiply\\n            return str(self.getDigit(num1) * self.getDigit(num2))\\n\\n        mid = len(num1) // 2\\n\\n        # Assume numbers are 1234, 5678\\n        # a = 12, b = 34\\n        # c = 56, d = 78\\n        a = num1[:len(num1) - mid]\\n        b = num1[len(num1) - mid:]\\n        c = num2[:len(num2) - mid]\\n        d = num2[len(num2) - mid:]\\n\\n        ac = self.multiply(a, c)\\n        bd = self.multiply(b, d)\\n\\n        # (a+b)(c+d) - ac - bd = ad + bc\\n        ad_bc = self.subtract(\\n            self.subtract(\\n                self.multiply(\\n                    self.add(a, b),\\n                    self.add(c, d)), ac), bd)\\n\\n        # pad the numbers with appropriate zeroes to the right\\n        ac = self.padRight(ac, mid + mid) # 10**2n\\n        ad_bc = self.padRight(ad_bc, mid) # 10**n\\n        \\n        # sum up all the terms for desired product\\n        res = self.add(self.add(ac, ad_bc), bd)\\n        \\n        if len(res) == 1:\\n            return res\\n        \\n        # remove unnecessary zeroes to the left\\n        while len(res) and res[0] == \"0\":\\n            res = res[1:]\\n        \\n        return res\\n    \\n\\n    def padLeft(self, x: str, y: str) -> (str, str):\\n        # left pad the shorter number with zeroes\\n        # until both are the same length\\n        while len(x) < len(y):\\n            x = \"0\" + x\\n        while len(y) < len(x):\\n            y = \"0\" + y\\n        return x, y\\n    \\n    \\n    def padRight(self, num: str, n: int) -> str:\\n        if num != \"0\":\\n            for i in range(n):\\n                num += \"0\"\\n        return num\\n\\n\\n    def add(self, x: str, y: str) -> str:\\n        x, y = self.padLeft(x, y)\\n        res = \"\"\\n        carry = 0\\n        for i in range(len(x) - 1, -1, -1):\\n            s = self.getDigit(x[i]) + self.getDigit(y[i]) + carry\\n            c = s % 10\\n            carry = 0 if s == c else 1\\n            res = str(c) + res\\n        if carry:\\n            res = \"1\" + res\\n        return res\\n\\n\\n    def subtract(self, larger: str, smaller: str) -> str:\\n        # we can always assume that we are subtracting the smaller number\\n        # from the larger number\\n        larger, smaller = self.padLeft(larger, smaller)\\n        res = \"\"\\n        borrow = 0\\n        for i in range(len(larger) - 1, -1, -1):\\n            c = self.getDigit(larger[i]) - self.getDigit(smaller[i]) - borrow\\n            borrow = 0\\n            if c >= 0:\\n                res = str(c) + res\\n            else:\\n                c += 10\\n                res = str(c) + res\\n                borrow = 1\\n        return res\\n        \\n    \\n    def getDigit(self, n: str) -> int:\\n        return ord(n) - ord(\"0\")\\n```",
                "solutionTags": [
                    "Math"
                ],
                "code": "```\\nclass Solution:\\n    \"\"\"\\n    This is an implementation of the Karatsuba multiplication algorithm.\\n    Let\\'s compare elementary vs. Karatsuba multiplication with the\\n    following example:\\n\\t\\n         12\\n       x 34\\n       ----\\n        408\\n\\t\\t\\n    Elementary multiplication would result in us calculating\\n\\t\\n        2*4 + 1*4*10^1 + 2*3*10^1 + 1*3*10^2 = 408\\n        ---   ===        ===        ---\\n\\t\\t\\n    There are four multiplications (underlined) or 2^2 or O(n^2).\\n    Karatsuba multiplication (https://en.wikipedia.org/wiki/Karatsuba_algorithm)\\n    would result in us calculating first:\\n\\t\\n        1*3 = 3 and 2*4 = 8\\n\\t\\t\\n    Then we calculate:\\n\\t\\n        (1+2)(3+4) = 21\\n\\t\\t\\n    Then we calculate:\\n\\t\\n        (1+2)(3+4) - 1*3 - 2*4 = 10\\n\\t\\t\\n    Then we sum everything up with their correct base:\\n\\t\\n        3*10^2 + 10*10^1 + 8 = 408\\n\\t\\t\\n    So far, we\\'ve performed only three multiplications.\\n    We can always pad zeroes for the correct base.\\n    The reason why this works is because of (1+2)(3+4):\\n\\t\\n        (1+2)(3+4) = 2*4 + 1*4 + 2*3 + 1*3\\n                     ---   =========   ---\\n\\t\\t\\t\\t\\t \\n    1. Notice that these multiplications matches our elementary approach\\n    2. Notice that 1*4 and 2*3 shares the same base (10^1) in our elementary approach\\n\\n    Instead of calculating 1*4 and 2*3 directly, we can reuse 1*3 and 2*4 and\\n    make one more multiplication (1+2)(3+4):\\n\\t\\n        (1+2)(3+4) - 2*4 - 1*3 = 1*4 + 2*3\\n\\t\\t\\n    The above can be used to recursively build up multiplication between two integers.\\n    One way we can simplify our implementation is to left pad the shorter number with zeroes\\n    so that both numbers are of the same string length.\\n    \\n    The given the following:\\n    \\n         ab\\n       x cd\\n       \\n    And n == len(ab) == len(cd)\\n    \\n    The recurrance formula is:\\n    \\n        karatsuba(ab, cd) = 10^n*ac + 10^(n/2)*karatsuba(a+b, c+d) - ac - bd\\n        \\n    It has a runtime complexity of O(n^log2(3)).\\n\\t\\n    Resources:\\n    - https://youtu.be/JCbZayFr9RE\\n    - https://youtu.be/cCKOl5li6YM\\n    \"\"\"\\n    @cache\\n    def multiply(self, num1: str, num2: str) -> str:\\n        if num1 == \"0\" or num2 == \"0\":\\n            return \"0\"\\n        elif num1 == \"1\":\\n            return num2\\n        elif num2 == \"1\": \\n            return num1\\n        \\n        num1, num2 = self.padLeft(num1, num2)\\n\\n        if len(num1) == 1 and len(num2) == 1:\\n            # This is the only time we multiply\\n            return str(self.getDigit(num1) * self.getDigit(num2))\\n\\n        mid = len(num1) // 2\\n\\n        # Assume numbers are 1234, 5678\\n        # a = 12, b = 34\\n        # c = 56, d = 78\\n        a = num1[:len(num1) - mid]\\n        b = num1[len(num1) - mid:]\\n        c = num2[:len(num2) - mid]\\n        d = num2[len(num2) - mid:]\\n\\n        ac = self.multiply(a, c)\\n        bd = self.multiply(b, d)\\n\\n        # (a+b)(c+d) - ac - bd = ad + bc\\n        ad_bc = self.subtract(\\n            self.subtract(\\n                self.multiply(\\n                    self.add(a, b),\\n                    self.add(c, d)), ac), bd)\\n\\n        # pad the numbers with appropriate zeroes to the right\\n        ac = self.padRight(ac, mid + mid) # 10**2n\\n        ad_bc = self.padRight(ad_bc, mid) # 10**n\\n        \\n        # sum up all the terms for desired product\\n        res = self.add(self.add(ac, ad_bc), bd)\\n        \\n        if len(res) == 1:\\n            return res\\n        \\n        # remove unnecessary zeroes to the left\\n        while len(res) and res[0] == \"0\":\\n            res = res[1:]\\n        \\n        return res\\n    \\n\\n    def padLeft(self, x: str, y: str) -> (str, str):\\n        # left pad the shorter number with zeroes\\n        # until both are the same length\\n        while len(x) < len(y):\\n            x = \"0\" + x\\n        while len(y) < len(x):\\n            y = \"0\" + y\\n        return x, y\\n    \\n    \\n    def padRight(self, num: str, n: int) -> str:\\n        if num != \"0\":\\n            for i in range(n):\\n                num += \"0\"\\n        return num\\n\\n\\n    def add(self, x: str, y: str) -> str:\\n        x, y = self.padLeft(x, y)\\n        res = \"\"\\n        carry = 0\\n        for i in range(len(x) - 1, -1, -1):\\n            s = self.getDigit(x[i]) + self.getDigit(y[i]) + carry\\n            c = s % 10\\n            carry = 0 if s == c else 1\\n            res = str(c) + res\\n        if carry:\\n            res = \"1\" + res\\n        return res\\n\\n\\n    def subtract(self, larger: str, smaller: str) -> str:\\n        # we can always assume that we are subtracting the smaller number\\n        # from the larger number\\n        larger, smaller = self.padLeft(larger, smaller)\\n        res = \"\"\\n        borrow = 0\\n        for i in range(len(larger) - 1, -1, -1):\\n            c = self.getDigit(larger[i]) - self.getDigit(smaller[i]) - borrow\\n            borrow = 0\\n            if c >= 0:\\n                res = str(c) + res\\n            else:\\n                c += 10\\n                res = str(c) + res\\n                borrow = 1\\n        return res\\n        \\n    \\n    def getDigit(self, n: str) -> int:\\n        return ord(n) - ord(\"0\")\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2270731,
                "title": "c-easy-simple-solution-multiply-strings",
                "content": "class Solution {\\npublic:    \\n    string multiply(string num1, string num2) {\\n        std::string res = \"\";\\n\\n        auto len1 = num1.length();\\n        auto len2 = num2.length();\\n\\n        for (size_t i = 0; i < len1 + len2; i ++ )\\n        {\\n            res.append(\"0\");    \\n        }\\n\\n        auto pos = 0;\\n        while (pos < len1 + len2 - 1) {\\n            for (size_t i1 = 0; i1 < len1; i1++ ) {\\n                int i2 = pos - i1;\\n                if ( i2 < 0 ) {\\n                    break;\\n                }\\n                if ( i2 >= len2 ) {\\n                    continue;\\n                }\\n                else {\\n                    int current = int(res[len1 + len2 - 1 - pos] - \\'0\\') + int(num1[len1 - 1 - i1] - \\'0\\') * int(num2[len2 - 1 - i2] - \\'0\\');\\n                    res[len1 + len2 - 1 - pos] = char(\\'0\\' + current % 10);\\n                    auto rest = (int(res[len1 + len2 - 1 - pos - 1] - \\'0\\') + current / 10) / 10;\\n                    res[len1 + len2 - 1 - pos - 1] = char(\\'0\\' + (int(res[len1 + len2 - 1 - pos - 1] - \\'0\\') + current / 10) % 10);\\n                    if (rest > 0 ) {\\n                        for (size_t i = pos + 2; i < len1 + len2; i ++ ) {\\n                            current = int(res[len1 + len2 - 1 - i] - \\'0\\') + rest;\\n                            res[len1 + len2 - 1 - i] = char(\\'0\\' + current % 10);\\n                            rest = current / 10;\\n                            if ( rest == 0 ) {\\n                                break;\\n                            }\\n                        }\\n                    }\\n                }                    \\n            }\\n            pos ++; \\n        }\\n        int start_position = len1 + len2 - 1;\\n        for (size_t i = 0; i < len1 + len2 - 1; i ++ ) {\\n            if (res[i] != \\'0\\') {\\n                start_position = i;\\n                break;\\n            }\\n        }\\n        res = res.substr(start_position);\\n\\n        return res;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C",
                    "String"
                ],
                "code": "class Solution {\\npublic:    \\n    string multiply(string num1, string num2) {\\n        std::string res = \"\";\\n\\n        auto len1 = num1.length();\\n        auto len2 = num2.length();\\n\\n        for (size_t i = 0; i < len1 + len2; i ++ )\\n        {\\n            res.append(\"0\");    \\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2148576,
                "title": "fastest-solution-without-int-and-str-50ms",
                "content": "```\\nclass Solution:\\n    def multiply(self, num1: str, num2: str) -> str:\\n        ndict = {\\'1\\':1,\\n                \\'2\\':2,\\n                \\'3\\':3,\\n                \\'4\\':4,\\n                \\'5\\':5,\\n                \\'6\\':6,\\n                \\'7\\':7,\\n                \\'8\\':8,\\n                \\'9\\':9,\\n                \\'0\\':0}\\n        res1 = 0\\n        res2 = 0 \\n        for i in num1:\\n            res1 = res1*10 + ndict[i]\\n        for i in num2:\\n            res2 = res2*10 + ndict[i]\\n        res = res1 * res2\\n        rem = res\\n        if rem == 0: return \\'0\\' \\n        sres = \\'\\'\\n        while res != 0:\\n            for u,v in zip(ndict.keys() , ndict.values()):\\n                d = res%10\\n                if v == d :\\n                    sres+=u\\n                    break\\n\\n            res = res//10\\n\\n        return sres[::-1]\\n\\t\\t```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def multiply(self, num1: str, num2: str) -> str:\\n        ndict = {\\'1\\':1,\\n                \\'2\\':2,\\n                \\'3\\':3,\\n                \\'4\\':4,\\n                \\'5\\':5,\\n                \\'6\\':6,\\n                \\'7\\':7,\\n                \\'8\\':8,\\n                \\'9\\':9,\\n                \\'0\\':0}\\n        res1 = 0\\n        res2 = 0 \\n        for i in num1:\\n            res1 = res1*10 + ndict[i]\\n        for i in num2:\\n            res2 = res2*10 + ndict[i]\\n        res = res1 * res2\\n        rem = res\\n        if rem == 0: return \\'0\\' \\n        sres = \\'\\'\\n        while res != 0:\\n            for u,v in zip(ndict.keys() , ndict.values()):\\n                d = res%10\\n                if v == d :\\n                    sres+=u\\n                    break\\n\\n            res = res//10\\n\\n        return sres[::-1]\\n\\t\\t```",
                "codeTag": "Java"
            },
            {
                "id": 2102241,
                "title": "wrote-karatsuba-algorithm-cause-everyone-cheated",
                "content": "I feel stupid, I wrote the optimal solution but then thought there was a better one because of the speed distribution. So I spent an hour imlpementing a recursive Karatsuba algorithm, thinking that the inputs must be huge for testing, like 1k+. \\n\\nTurns out everyone didn\\'t read the restrictions and just did (Python):\\n```\\n\\treturn str(int(num1)*int(num2)) \\n```\\nWell, at least I know the Karatsuba algorithm by heart now lol.",
                "solutionTags": [],
                "code": "```\\n\\treturn str(int(num1)*int(num2)) \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1910217,
                "title": "simple-one-liner-python-solution",
                "content": "\\n```\\nclass Solution:\\n    def multiply(self, num1: str, num2: str) -> str:\\n        return str(eval(f\"{num1}*{num2}\"))\\n```\\nSolution using ```eval() ``` method.\\nEval() method takes string composed of integer and arithmetic operators, and return its solution as integer.\\nFor example:\\n```\\nstring = \"10*2+5\"\\nans = eval(string)\\nprint(ans)\\n```\\nAbove code will result in 205.",
                "solutionTags": [
                    "Python",
                    "Math",
                    "String"
                ],
                "code": "```\\nclass Solution:\\n    def multiply(self, num1: str, num2: str) -> str:\\n        return str(eval(f\"{num1}*{num2}\"))\\n```\n```eval() ```\n```\\nstring = \"10*2+5\"\\nans = eval(string)\\nprint(ans)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1859274,
                "title": "swift-9ms-100",
                "content": "```\\nfunc multiply(_ num1: String, _ num2: String) -> String {\\n        var digits = [Int](repeating: 0, count: num1.count + num2.count)\\n        let num1 = Array(num1).map({ Int(String($0))! })\\n        let num2 = Array(num2).map({ Int(String($0))! })\\n\\n        for i in stride(from: num1.count - 1, to: -1, by: -1) {\\n          for j in stride(from: num2.count - 1, to: -1, by: -1) {\\n            let p = num1[i] * num2[j]\\n            let p1 = i + j, p2 = i + j + 1\\n            let sum = p + digits[p2]\\n            digits[p1] += sum / 10, digits[p2] = sum % 10\\n          }\\n        }\\n        // need to make sure digits is not empty arry\\n        while digits.first == 0 && digits.count > 1 {\\n            digits.removeFirst()\\n        }\\n    \\n        return digits.map({ String($0) }).joined()\\n    }",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nfunc multiply(_ num1: String, _ num2: String) -> String {\\n        var digits = [Int](repeating: 0, count: num1.count + num2.count)\\n        let num1 = Array(num1).map({ Int(String($0))! })\\n        let num2 = Array(num2).map({ Int(String($0))! })\\n\\n        for i in stride(from: num1.count - 1, to: -1, by: -1) {\\n          for j in stride(from: num2.count - 1, to: -1, by: -1) {\\n            let p = num1[i] * num2[j]\\n            let p1 = i + j, p2 = i + j + 1\\n            let sum = p + digits[p2]\\n            digits[p1] += sum / 10, digits[p2] = sum % 10\\n          }\\n        }\\n        // need to make sure digits is not empty arry\\n        while digits.first == 0 && digits.count > 1 {\\n            digits.removeFirst()\\n        }\\n    \\n        return digits.map({ String($0) }).joined()\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1822744,
                "title": "python-solution",
                "content": "Here\\'s my solution:\\n```\\n# Runtime: 88 ms, faster than 56.24% of Python3 online submissions for Multiply Strings.\\n# Memory Usage: 13.9 MB, less than 87.15% of Python3 online submissions for Multiply Strings.\\nclass Solution:\\n    def multiply(self, num1, num2):\\n        result, mult1 = 0, 1\\n        digits = {str(i):i for i in range(10)}\\n        for i in num1[::-1]:\\n            mult2 = 1\\n            for j in num2[::-1]:\\n                result += digits[i]*digits[j]*mult1*mult2\\n                mult2 *= 10\\n            mult1 *= 10\\n        return str(result)\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\n# Runtime: 88 ms, faster than 56.24% of Python3 online submissions for Multiply Strings.\\n# Memory Usage: 13.9 MB, less than 87.15% of Python3 online submissions for Multiply Strings.\\nclass Solution:\\n    def multiply(self, num1, num2):\\n        result, mult1 = 0, 1\\n        digits = {str(i):i for i in range(10)}\\n        for i in num1[::-1]:\\n            mult2 = 1\\n            for j in num2[::-1]:\\n                result += digits[i]*digits[j]*mult1*mult2\\n                mult2 *= 10\\n            mult1 *= 10\\n        return str(result)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1668198,
                "title": "c-easy-to-understand-mathemetics",
                "content": "```\\nclass Solution {\\npublic:\\n    string multiply(string num1, string num2) {\\n\\t\\n        if(num1==\"0\" || num2==\"0\") return \"0\";\\n        \\n        vector<int>res(num1.size()+num2.size(),0);\\n        for(int i=num1.size()-1;i>=0;i--)\\n        {\\n            for(int j=num2.size()-1;j>=0;j--)\\n            {\\n                res[i+j+1]+ =(num1[i]-\\'0\\')*(num2[j]-\\'0\\');\\n                res[i+j]+ =res[i+j+1]/10;\\n                res[i+j+1]% =10;\\n            }\\n        }\\n        \\n        string temp=\"\";\\n        int k=0;\\n        \\n        while(res[k]==0) k++;\\n        while(k<res.size())\\n            temp+=to_string(res[k++]);\\n        \\n        return temp;\\n    }\\n};",
                "solutionTags": [
                    "Math"
                ],
                "code": "class Solution {\\npublic:\\n    string multiply(string num1, string num2) {\\n\\t\\n        if(num1==\"0\" || num2==\"0\") return \"0\";\\n        \\n        vector<int>res(num1.size()+num2.size(),0);\\n        for(int i=num1.size()-1;i>=0;i--)\\n        {\\n            for(int j=num2.size()-1;j>=0;j--)\\n            {\\n                res[i+j+1]+ =(num1[i]-\\'0\\')*(num2[j]-\\'0\\');\\n                res[i+j]+ =res[i+j+1]/10;\\n                res[i+j+1]% =10;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1564313,
                "title": "two-simple-c-solution",
                "content": "Simple C++ solutions\\n\\n**Without reversal of strings**\\n```\\nclass Solution {\\npublic:\\n    string multiply(string num1, string num2) {\\n        if(num1 == \"0\" || num2 ==\"0\" ) return \"0\";\\n        int n1 = num1.size(), n2 = num2.size(), n = n1+n2;\\n        string ans(n, \\'0\\');\\n        for(int p2 = n2-1; p2 >= 0; p2--){\\n            int d2 = num2[p2] - \\'0\\';\\n            for(int p1 = n1-1; p1 >= 0; p1--){\\n                int d1 = num1[p1] - \\'0\\', p = p1 + p2 + 1, c = ans[p] - \\'0\\', m = d1 * d2 + c;\\n                ans[p] = (m % 10) + \\'0\\';\\n                ans[p-1] += (m / 10);\\n            }\\n        }\\n        if(ans.front() == \\'0\\') ans.erase(ans.begin());\\n        return ans;\\n    }\\n};\\n```\\n**with Reversal of strings**\\n```\\nclass Solution {\\npublic:\\n    string multiply(string num1, string num2) {\\n        if(num1 == \"0\" || num2 ==\"0\" ) return \"0\";\\n        int n1 = num1.size(), n2 = num2.size(); int n = n1+n2;\\n        string ans(n, \\'0\\');\\n        reverse(num1.begin(), num1.end());\\n        reverse(num2.begin(), num2.end());\\n        for(int p2 = 0; p2 < n2; p2++){\\n            int d2 = num2[p2] - \\'0\\';\\n            for(int p1 = 0; p1 < n1; p1++){\\n                int d1 = num1[p1] - \\'0\\';\\n                int p = p1 + p2; int c = ans[p] - \\'0\\'; int m = d1 * d2 + c;\\n                ans[p] = (m % 10) + \\'0\\';\\n                ans[p+1] += (m / 10);\\n            }\\n        }\\n        if(ans.back() == \\'0\\') ans.pop_back();\\n        reverse(ans.begin(), ans.end());\\n        return ans;\\n    }\\n};\\n```\\n**please upvote if u like**",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string multiply(string num1, string num2) {\\n        if(num1 == \"0\" || num2 ==\"0\" ) return \"0\";\\n        int n1 = num1.size(), n2 = num2.size(), n = n1+n2;\\n        string ans(n, \\'0\\');\\n        for(int p2 = n2-1; p2 >= 0; p2--){\\n            int d2 = num2[p2] - \\'0\\';\\n            for(int p1 = n1-1; p1 >= 0; p1--){\\n                int d1 = num1[p1] - \\'0\\', p = p1 + p2 + 1, c = ans[p] - \\'0\\', m = d1 * d2 + c;\\n                ans[p] = (m % 10) + \\'0\\';\\n                ans[p-1] += (m / 10);\\n            }\\n        }\\n        if(ans.front() == \\'0\\') ans.erase(ans.begin());\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    string multiply(string num1, string num2) {\\n        if(num1 == \"0\" || num2 ==\"0\" ) return \"0\";\\n        int n1 = num1.size(), n2 = num2.size(); int n = n1+n2;\\n        string ans(n, \\'0\\');\\n        reverse(num1.begin(), num1.end());\\n        reverse(num2.begin(), num2.end());\\n        for(int p2 = 0; p2 < n2; p2++){\\n            int d2 = num2[p2] - \\'0\\';\\n            for(int p1 = 0; p1 < n1; p1++){\\n                int d1 = num1[p1] - \\'0\\';\\n                int p = p1 + p2; int c = ans[p] - \\'0\\'; int m = d1 * d2 + c;\\n                ans[p] = (m % 10) + \\'0\\';\\n                ans[p+1] += (m / 10);\\n            }\\n        }\\n        if(ans.back() == \\'0\\') ans.pop_back();\\n        reverse(ans.begin(), ans.end());\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1564072,
                "title": "multiply-strings-java-solutions-day-7",
                "content": "\\n//Method 1\\nclass Solution {\\n    public String multiply(String num1, String num2) {\\n        if (num1.equals(\"0\") || num2.equals(\"0\")) {\\n            return \"0\";\\n        }\\n        \\n        StringBuilder firstNumber = new StringBuilder(num1);\\n        StringBuilder secondNumber = new StringBuilder(num2);\\n        \\n        // Reverse both the numbers.\\n        firstNumber.reverse();\\n        secondNumber.reverse();\\n        \\n       \\n        int N = firstNumber.length() + secondNumber.length();\\n        StringBuilder answer = new StringBuilder();\\n        for (int i = 0; i < N; ++i) {\\n            answer.append(0);\\n        }\\n        \\n        for (int place2 = 0; place2 < secondNumber.length(); place2++) {\\n            int digit2 = secondNumber.charAt(place2) - \\'0\\';\\n           \\n            for (int place1 = 0; place1 < firstNumber.length(); place1++) {\\n                int digit1 = firstNumber.charAt(place1) - \\'0\\';\\n                \\n                \\n                int currentPos = place1 + place2;\\n                \\n                \\n                int carry = answer.charAt(currentPos) - \\'0\\';\\n                int multiplication = digit1 * digit2 + carry;\\n                \\n                \\n                answer.setCharAt(currentPos, (char)(multiplication % 10 + \\'0\\'));\\n                \\n                \\n                int value = (answer.charAt(currentPos + 1) - \\'0\\') + multiplication / 10;\\n                answer.setCharAt(currentPos + 1, (char)(value + \\'0\\'));\\n            }\\n        }\\n        \\n      \\n        if (answer.charAt(answer.length() - 1) == \\'0\\') {\\n            answer.deleteCharAt(answer.length() - 1);\\n        }\\n        \\n        answer.reverse();\\n        return answer.toString();\\n    }\\n}\\n\\n\\n//Method 2\\n/*\\n\\nclass Solution {\\n   public String multiply(String num1, String num2) {        \\n       if(num1.charAt(0) == \\'0\\' || num2.charAt(0) == \\'0\\')\\n           return \"0\";\\n       \\n       int len1 = num1.length();\\n       int len2 = num2.length();\\n       int[] arr = new int[len1+len2-1];\\n       for(int i = 0; i < len1; i++){\\n           for(int j = 0; j < len2; j++){\\n               int x1 = num1.charAt(i) - \\'0\\';\\n               int x2 = num2.charAt(j) - \\'0\\';\\n               arr[i+j] += x1*x2;\\n           }\\n       }\\n                           \\n       int carry = 0;\\n       StringBuilder sb = new StringBuilder();\\n       for(int k = arr.length - 1; k >= 0; k--){\\n           int x = carry+arr[k];\\n           sb.append(x%10);\\n           carry = x/10;\\n       }\\n       if(carry > 0){\\n           sb.append(carry);\\n       }\\n       \\n       return sb.reverse().toString();\\n   }\\n}\\n*/",
                "solutionTags": [],
                "code": "class Solution {\\n    public String multiply(String num1, String num2) {\\n        if (num1.equals(\"0\") || num2.equals(\"0\")) {\\n            return \"0\";\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1563649,
                "title": "rust-parsing-string",
                "content": "Solution - [github](https://github.com/An7One/leetcode-solutions-rust-an7one/tree/main/src/leetcode/lvl4/lc0043)\\n\\n<b>Problem List</b>\\n#ParsingString - [github](https://github.com/An7One/leetcode-problems-by-tag-an7one/blob/main/txt/by_data_structure/string/by_topic/parsing_string.txt)\\n\\n```\\n/// https://leetcode.com/problems/multiply-strings/\\n/// Time Complexity:    O(`len1` + `len2`)\\n/// Space Complexity:   O(`len1` + `len2`)\\n/// Referenec:\\n/// https://leetcode.com/problems/multiply-strings/discuss/241287/Rust-0ms-solution\\nimpl Solution {\\n    pub fn multiply(num1: String, num2: String) -> String {\\n        let len1 = num1.len();\\n        let len2 = num2.len();\\n        let digits = {\\n            let mut digits = vec![0; len1 + len2];\\n            for (idx1, ch1) in num1.chars().rev().enumerate() {\\n                for (idx2, ch2) in num2.chars().rev().enumerate() {\\n                    let n1 = ch1 as i32 - \\'0\\' as i32;\\n                    let n2 = ch2 as i32 - \\'0\\' as i32;\\n                    let res = n1 * n2 + digits[idx1 + idx2];\\n                    digits[idx1 + idx2] = res % 10;\\n                    digits[idx1 + idx2 + 1] += res / 10;\\n                }\\n            }       \\n            while digits.len() > 1 && digits.last() == Some(&0){\\n                digits.pop();\\n            }\\n            digits\\n        };\\n        digits.into_iter().rev().map(|d| d.to_string()).collect::<String>()\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\n/// https://leetcode.com/problems/multiply-strings/\\n/// Time Complexity:    O(`len1` + `len2`)\\n/// Space Complexity:   O(`len1` + `len2`)\\n/// Referenec:\\n/// https://leetcode.com/problems/multiply-strings/discuss/241287/Rust-0ms-solution\\nimpl Solution {\\n    pub fn multiply(num1: String, num2: String) -> String {\\n        let len1 = num1.len();\\n        let len2 = num2.len();\\n        let digits = {\\n            let mut digits = vec![0; len1 + len2];\\n            for (idx1, ch1) in num1.chars().rev().enumerate() {\\n                for (idx2, ch2) in num2.chars().rev().enumerate() {\\n                    let n1 = ch1 as i32 - \\'0\\' as i32;\\n                    let n2 = ch2 as i32 - \\'0\\' as i32;\\n                    let res = n1 * n2 + digits[idx1 + idx2];\\n                    digits[idx1 + idx2] = res % 10;\\n                    digits[idx1 + idx2 + 1] += res / 10;\\n                }\\n            }       \\n            while digits.len() > 1 && digits.last() == Some(&0){\\n                digits.pop();\\n            }\\n            digits\\n        };\\n        digits.into_iter().rev().map(|d| d.to_string()).collect::<String>()\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1380397,
                "title": "simple-java-solution",
                "content": "import java.math.*;\\nclass Solution {\\n\\n    public String multiply(String n1, String n2) {\\n        BigInteger nm=new BigInteger(n1);\\n        BigInteger kk=new BigInteger(n2);\\n        nm=nm.multiply(kk);\\n        return nm.toString();\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n\\n    public String multiply(String n1, String n2) {\\n        BigInteger nm=new BigInteger(n1);\\n        BigInteger kk=new BigInteger(n2);\\n        nm=nm.multiply(kk);\\n        return nm.toString();\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1302061,
                "title": "4ms-java-solution",
                "content": "\\n```\\nclass Solution {\\n    public String multiply(String num1, String num2) {\\n        int l1 = num1.length();\\n        int l2 = num2.length();\\n        int[] multiply = new int[l1+l2];\\n        int previousCarry = 0;\\n        int j=0;\\n        for(int i=l1-1; i>=0; i--) {\\n            for(j=l2-1; j>=0; j--) {\\n                // Multiplication of current 2 digits\\n                int mul = (num1.charAt(i) - \\'0\\') * (num2.charAt(j) - \\'0\\');\\n                \\n                int temp = mul%10;\\n                \\n                // Get the carry to forward to next multiplication\\n                int currentCarry = mul/10;\\n                \\n                // Add to current sum at i+j+1 with temp + previous value at [i+j+1] + any previous carry\\n                int latestValue = multiply[i+j+1] + temp + previousCarry;\\n                \\n                // If this value is greater than 10\\n                multiply[i+j+1] = latestValue % 10;\\n                \\n                // Add it to currentCarry to add in the next iteration\\n                currentCarry +=  (latestValue/10);\\n                previousCarry = currentCarry;\\n            }\\n            \\n            // Front most digit\\n            multiply[i+j+1] += previousCarry;\\n            previousCarry = 0;\\n\\n        }\\n        StringBuilder sb = new StringBuilder();\\n        \\n        for(int i=0; i<multiply.length; i++) {\\n            if(!(sb.length() == 0 && multiply[i] == 0 )) sb.append(multiply[i]);\\n        }\\n        return (sb.toString().length() == 0 ? \"0\" : sb.toString());\\n    }\\n}\\n\\n/*\\n\\n\\n        1   2   3\\n      * 4   5   6\\n      -------------\\n    0  0   7   3   8\\n  + 0  6   1   5   0  \\n  + 4  9   2   0   0    \\n  -------------------\\n    5  6   0   8   8\\n\\n*/\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public String multiply(String num1, String num2) {\\n        int l1 = num1.length();\\n        int l2 = num2.length();\\n        int[] multiply = new int[l1+l2];\\n        int previousCarry = 0;\\n        int j=0;\\n        for(int i=l1-1; i>=0; i--) {\\n            for(j=l2-1; j>=0; j--) {\\n                // Multiplication of current 2 digits\\n                int mul = (num1.charAt(i) - \\'0\\') * (num2.charAt(j) - \\'0\\');\\n                \\n                int temp = mul%10;\\n                \\n                // Get the carry to forward to next multiplication\\n                int currentCarry = mul/10;\\n                \\n                // Add to current sum at i+j+1 with temp + previous value at [i+j+1] + any previous carry\\n                int latestValue = multiply[i+j+1] + temp + previousCarry;\\n                \\n                // If this value is greater than 10\\n                multiply[i+j+1] = latestValue % 10;\\n                \\n                // Add it to currentCarry to add in the next iteration\\n                currentCarry +=  (latestValue/10);\\n                previousCarry = currentCarry;\\n            }\\n            \\n            // Front most digit\\n            multiply[i+j+1] += previousCarry;\\n            previousCarry = 0;\\n\\n        }\\n        StringBuilder sb = new StringBuilder();\\n        \\n        for(int i=0; i<multiply.length; i++) {\\n            if(!(sb.length() == 0 && multiply[i] == 0 )) sb.append(multiply[i]);\\n        }\\n        return (sb.toString().length() == 0 ? \"0\" : sb.toString());\\n    }\\n}\\n\\n/*\\n\\n\\n        1   2   3\\n      * 4   5   6\\n      -------------\\n    0  0   7   3   8\\n  + 0  6   1   5   0  \\n  + 4  9   2   0   0    \\n  -------------------\\n    5  6   0   8   8\\n\\n*/\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1208875,
                "title": "c-0ms-100-faster-very-simple",
                "content": "```\\nclass Solution {\\npublic:\\n    string multiply(string num1, string num2) {\\n        if (num1 == \"0\" || num2 == \"0\") {\\n            return \"0\";\\n        }\\n        string s(num1.size() + num2.size(), 0);\\n        for (int i = num1.size() - 1; i >= 0; i--) {\\n            for (int j = num2.size() - 1; j >= 0; j--) {\\n                int n = (num1[i] - \\'0\\') * (num2[j] - \\'0\\') + s[i + j + 1];\\n                s[i + j + 1] = n % 10;\\n                s[i + j] += n / 10;\\n            }\\n        }\\n        for (int i = 0; i < s.size(); i++) {\\n            s[i] += \\'0\\';\\n        }\\n        if (s[0] == \\'0\\') {\\n            return s.substr(1);\\n        }\\n        return s;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string multiply(string num1, string num2) {\\n        if (num1 == \"0\" || num2 == \"0\") {\\n            return \"0\";\\n        }\\n        string s(num1.size() + num2.size(), 0);\\n        for (int i = num1.size() - 1; i >= 0; i--) {\\n            for (int j = num2.size() - 1; j >= 0; j--) {\\n                int n = (num1[i] - \\'0\\') * (num2[j] - \\'0\\') + s[i + j + 1];\\n                s[i + j + 1] = n % 10;\\n                s[i + j] += n / 10;\\n            }\\n        }\\n        for (int i = 0; i < s.size(); i++) {\\n            s[i] += \\'0\\';\\n        }\\n        if (s[0] == \\'0\\') {\\n            return s.substr(1);\\n        }\\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1132347,
                "title": "easy-solution-in-c-o-m-n",
                "content": "```\\nclass Solution {\\npublic:\\n    string multiply(string num1, string num2) {\\n        string sum(num1.size() + num2.size(), \\'0\\');\\n        for(int i=num1.size()-1; i>=0; i--) {\\n            int carry = 0;\\n            for(int j=num2.size()-1; j>=0; j--) {\\n                int tmp = (sum[i+j+1] - \\'0\\') + (num1[i] - \\'0\\') * (num2[j] - \\'0\\') + carry;\\n                sum[i+j+1] = (tmp % 10) + \\'0\\';\\n                carry = tmp / 10; \\n            }\\n            sum[i] += carry;\\n        }\\n        \\n        // Remove leading zeros\\n        for(int i=0; i<sum.size(); i++)\\n        {\\n            if (sum[i] != \\'0\\')\\n                return sum.substr(i);\\n        }\\n        return \"0\";\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string multiply(string num1, string num2) {\\n        string sum(num1.size() + num2.size(), \\'0\\');\\n        for(int i=num1.size()-1; i>=0; i--) {\\n            int carry = 0;\\n            for(int j=num2.size()-1; j>=0; j--) {\\n                int tmp = (sum[i+j+1] - \\'0\\') + (num1[i] - \\'0\\') * (num2[j] - \\'0\\') + carry;\\n                sum[i+j+1] = (tmp % 10) + \\'0\\';\\n                carry = tmp / 10; \\n            }\\n            sum[i] += carry;\\n        }\\n        \\n        // Remove leading zeros\\n        for(int i=0; i<sum.size(); i++)\\n        {\\n            if (sum[i] != \\'0\\')\\n                return sum.substr(i);\\n        }\\n        return \"0\";\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1048161,
                "title": "c-13-line-best-and-clean-solution",
                "content": "```\\n\\n    string multiply(string A , string B ) {\\n        \\n        int M = A.size() ; \\n        int N = B.size() ;\\n        \\n        string res( M+N , \\'0\\' );\\n        \\n        for( int i = M-1 ; i >= 0 ; i-- )\\n        for( int j = N-1 ; j >= 0 ; j-- )\\n        {\\n            int a = A[i] - \\'0\\' ;\\n            int b = B[j] - \\'0\\' ;\\n            \\n            int cnt = ( res[i+j+1] - \\'0\\' ) + (a*b);\\n            \\n            res[i+j+1] = (cnt%10) + \\'0\\' ; \\n            res[i+j] += cnt/10 ; \\n            \\n        }\\n        \\n        for( int i = 0 ; i < res.size() ; i++ )\\n        if( res[i] != \\'0\\' ) return res.substr(i);\\n        \\n        return \"0\";\\n        \\n    }\\n\\ninspired by this post -- https://www.tutorialspoint.com/multiply-strings-in-cplusplus\\n\\n\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n\\n    string multiply(string A , string B ) {\\n        \\n        int M = A.size() ; \\n        int N = B.size() ;\\n        \\n        string res( M+N , \\'0\\' );\\n        \\n        for( int i = M-1 ; i >= 0 ; i-- )\\n        for( int j = N-1 ; j >= 0 ; j-- )\\n        {\\n            int a = A[i] - \\'0\\' ;\\n            int b = B[j] - \\'0\\' ;\\n            \\n            int cnt = ( res[i+j+1] - \\'0\\' ) + (a*b);\\n            \\n            res[i+j+1] = (cnt%10) + \\'0\\' ; \\n            res[i+j] += cnt/10 ; \\n            \\n        }\\n        \\n        for( int i = 0 ; i < res.size() ; i++ )\\n        if( res[i] != \\'0\\' ) return res.substr(i);\\n        \\n        return \"0\";\\n        \\n    }\\n\\ninspired by this post -- https://www.tutorialspoint.com/multiply-strings-in-cplusplus\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1005658,
                "title": "simple-multiplication-o-n-m-java-3ms-90-faster",
                "content": "```\\nclass Solution {\\n    \\n    public String multiply(String s, String t) {\\n        \\n        if(s == null || t == null)\\n            return null;\\n        \\n        if(s.equals(\"0\") || t.equals(\"0\"))\\n            return \"0\";\\n\\n        int n = s.length();\\n        int m = t.length();\\n        int[] result = new int[n + m];\\n\\n        for(int i=m-1 ; i>=0 ; i--) {\\n\\n            int a = t.charAt(i) - \\'0\\';\\n            for(int j=n-1 ; j>=0 ; j--) {\\n\\n                int b = s.charAt(j) - \\'0\\';\\n                int multiple = a * b;\\n\\n                int pos1 = i + j + 1;\\n                int pos2 = i + j;\\n\\n                result[pos1] += multiple % 10;\\n                result[pos2] += multiple / 10;\\n            }\\n        }\\n\\n        StringBuilder builder = new StringBuilder();\\n        int carry = 0;\\n        for(int i=result.length-1 ; i>=0 ; i--) {\\n\\n            int value = result[i] + carry;\\n            carry = value / 10;\\n            result[i] = value % 10;\\n\\n            if(i > 0 || result[i] != 0)\\n                builder.append(result[i]);\\n        }\\n        \\n        return builder.reverse().toString();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    \\n    public String multiply(String s, String t) {\\n        \\n        if(s == null || t == null)\\n            return null;\\n        \\n        if(s.equals(\"0\") || t.equals(\"0\"))\\n            return \"0\";\\n\\n        int n = s.length();\\n        int m = t.length();\\n        int[] result = new int[n + m];\\n\\n        for(int i=m-1 ; i>=0 ; i--) {\\n\\n            int a = t.charAt(i) - \\'0\\';\\n            for(int j=n-1 ; j>=0 ; j--) {\\n\\n                int b = s.charAt(j) - \\'0\\';\\n                int multiple = a * b;\\n\\n                int pos1 = i + j + 1;\\n                int pos2 = i + j;\\n\\n                result[pos1] += multiple % 10;\\n                result[pos2] += multiple / 10;\\n            }\\n        }\\n\\n        StringBuilder builder = new StringBuilder();\\n        int carry = 0;\\n        for(int i=result.length-1 ; i>=0 ; i--) {\\n\\n            int value = result[i] + carry;\\n            carry = value / 10;\\n            result[i] = value % 10;\\n\\n            if(i > 0 || result[i] != 0)\\n                builder.append(result[i]);\\n        }\\n        \\n        return builder.reverse().toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1572175,
                "content": [
                    {
                        "username": "bcronrath",
                        "content": "Honestly I don\\'t understand why these type of questions exist.  They should be removed, or leetcode should at least build in a way to have validation rules such as checking that variables aren\\'t converted to integers.  Look at all the top runtime submissions for this one, literally they are one line where they just convert the strings to integers and multiply them, it\\'s a joke."
                    },
                    {
                        "username": "Husoski",
                        "content": "[@Moonbeam8773](/Moonbeam8773) \\nIt\\'s not vague at all.  The goal is clearly to write the multiplication code yourself.  It\\'s just grade-school arithmetic, after all.  "
                    },
                    {
                        "username": "RedLeader",
                        "content": "Agreed, questions like this are pretty terrible and hacky in nature.  "
                    },
                    {
                        "username": "Moonbeam8773",
                        "content": "It says not to directly convert to int. Does that mean that if I wrote my own int converter I can do that? Or is the purpose of this question to generate a sum of the multiplication of each digit with 10^n padded behind? In that case, can I cast to int and multiply that single digit? Or am I supposed to create a matrix of single digit multiplication results and use that as a hashmap lookup?\\n\\nThis question is so vague it\\'s dumb."
                    },
                    {
                        "username": "neolancer",
                        "content": "This is a good question BUT the submission test cases must ensure that BigNumber-like conversion will not suffice. Otherwise proper solutions, like linked-list etc., will be disappointingly left in the tail"
                    },
                    {
                        "username": "kzo",
                        "content": "[@user3571Rr](/user3571Rr) Doesn\\'t work in Python with it\\'s unlimited precision"
                    },
                    {
                        "username": "spicedNoodle",
                        "content": "[@user3571Rr](/user3571Rr) uint64 can handle super log numbers in most langs. in the TS version i just used BigInt and thats it. i agree with this guys. this is a \"medium\" question. how in the hell is this medium?\\n\\ndont get me wrong, i see your point and i also agree with you. Basic understanding of dataTypes is super important. but medium? this should be a beginner / easy question. Any CS major in his first or second semester should be able to solve this given a few minutes. "
                    },
                    {
                        "username": "robotburrito",
                        "content": "In the real world if you didn\\'t write that 1 line that beats 98% of all other submissions when given this problem you\\'d probably be fired lol."
                    },
                    {
                        "username": "user3571Rr",
                        "content": "Not quite - some of the tests use seriously long number sequences, meaning that none of the conversion to Integer, Long, BigInteger or BigDecimal would actually work because of overflow.\\nIt seems to me that the only way is to carry out multiplications one at a time (as we one was doing it by hand), organise them in columns and produce text from the result, in sequence, while also taking care of rollover values."
                    },
                    {
                        "username": "juicebox2",
                        "content": "Pretty silly question. I feel it teaches devs to try to find complex solutions to simple problems. Why wouldn\\'t we leverage the basic functionality of a language and convert the strings to integer?\\n"
                    },
                    {
                        "username": "Husoski",
                        "content": "More to the point, *someone* has to write code for things like Python unlimited integers or the java.math.BigInteger class.  This is a real programming problem, solved by real programmers, and is more likely to come up in a career (imho) than finding the longest palindrome in a string of a million characters.\\nI\\'m retired, though...old-school with lots of embedded assembly and C...so maybe I\\'m biased by the fact that I\\'ve had to write software multiplication (particularly in assembly) more than once for embedded 8-bit systems."
                    },
                    {
                        "username": "Shikhar_Codes_",
                        "content": "Correct bruh!!"
                    },
                    {
                        "username": "tri_jal",
                        "content": "Listen listen, the reason why they give such questions is to check your problem solving ability. It is not about finding the complex solution, it\\'s about thinking out of the box :)"
                    },
                    {
                        "username": "joshuamahadevan1",
                        "content": "there could be situations where the number can\\'t fit in 64-bit space.. or whatever u decide to use.. numbers expressed  in binary will overflow at some point, and its good to know different ways of processing the same."
                    },
                    {
                        "username": "Krrabs",
                        "content": "For those saying, _why is it a medium? or it should be marked as easy._\n\nIn the question they specifically asked not to use `BigInt` or **convert** the input number **directly.**\n\nThat means in your solution there should never be an instance of `Integer/BigInt` having full value of inputs `num1` and `num2`.\n\nNo one is stopping you from doing that and solving your solution. But then, leaving comments like _\"this is an easy question\"_ you are only making a fool out of yourself."
                    },
                    {
                        "username": "Nakashima",
                        "content": "Do I need to consider the number that is between 0 and 1?"
                    },
                    {
                        "username": "QuazarGuy",
                        "content": "This type of question should be removed so interviewers don\\'t see it and think it\\'s a good question. Implement a tedious and detailed already built-in function that\\'s highly prone to error. I will reject a job if this type of question is asked. Test me on algorithms, not my ability to detect potential off-by-one errors."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for November, Day 7.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/multiply-strings/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Elementary Math\n\n  \n**Approach 2:** Elementary math using less intermediate space\n\n  \n**Approach 3:** Sum the products from all pairs of digits\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "sri_datta",
                        "content": "how does this have so many likes?"
                    },
                    {
                        "username": "nop_nop",
                        "content": "Consider \"123\" and \"456\"\\nMultiply \"6\"(of 456) with \"3\"(of 123) and keep track of this total sum, for next \"6\"(of 456)  with \"2\"(of 123) , but here we need to multiply the product by 10^1 as we do need to account for \"2\"(123) being in tens place and similarly we do it for everything and keep adding the sum.\\n![image](https://assets.leetcode.com/users/nop_nop/image_1547686032.png)\\n\\nBelow is the code:\\n![image](https://assets.leetcode.com/users/nop_nop/image_1547686217.png)\\n"
                    },
                    {
                        "username": "srivastavasameer2002",
                        "content": "what is variable type of total_sum? "
                    },
                    {
                        "username": "healqq",
                        "content": "good explanation, but code doesn\\'t follow the order of the image (as far as I can tell). As you\\'ll get 3 * 6 (i = 0, j = 0) => 3 * 5 (i = 0; j = 1) => 3*4 (i = 0; j = 2) and so on. Doesn\\'t change the result of course, but maybe makes sense to swap the loops around"
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "`n1 = ord(n1) - ord(\\'0\\')` why use ordinals?"
                    },
                    {
                        "username": "Raviteja525",
                        "content": "return str(eval(num1+\\'*\\'+num2))"
                    },
                    {
                        "username": "Sanjeet-Kumar",
                        "content": "![alt text](image url)![0_1497347622870_string.jpg](/assets/uploads/files/1497347627240-string-resized.jpg) \\nGuys As i have found most difficulties to understand the problem.Here From the above picture we can see that the product of ith and jth number will be stroed in position i+j and i+j+1, \\ni.e., res[i+j] is used to store the carry value and res[i+j+1] is used to rightmost digit of the sum.\\n![0_1497347660069_Screenshot (99).png](/assets/uploads/files/1497347665657-screenshot-99.png) \\nI hope it will help you."
                    }
                ]
            },
            {
                "id": 1671331,
                "content": [
                    {
                        "username": "bcronrath",
                        "content": "Honestly I don\\'t understand why these type of questions exist.  They should be removed, or leetcode should at least build in a way to have validation rules such as checking that variables aren\\'t converted to integers.  Look at all the top runtime submissions for this one, literally they are one line where they just convert the strings to integers and multiply them, it\\'s a joke."
                    },
                    {
                        "username": "Husoski",
                        "content": "[@Moonbeam8773](/Moonbeam8773) \\nIt\\'s not vague at all.  The goal is clearly to write the multiplication code yourself.  It\\'s just grade-school arithmetic, after all.  "
                    },
                    {
                        "username": "RedLeader",
                        "content": "Agreed, questions like this are pretty terrible and hacky in nature.  "
                    },
                    {
                        "username": "Moonbeam8773",
                        "content": "It says not to directly convert to int. Does that mean that if I wrote my own int converter I can do that? Or is the purpose of this question to generate a sum of the multiplication of each digit with 10^n padded behind? In that case, can I cast to int and multiply that single digit? Or am I supposed to create a matrix of single digit multiplication results and use that as a hashmap lookup?\\n\\nThis question is so vague it\\'s dumb."
                    },
                    {
                        "username": "neolancer",
                        "content": "This is a good question BUT the submission test cases must ensure that BigNumber-like conversion will not suffice. Otherwise proper solutions, like linked-list etc., will be disappointingly left in the tail"
                    },
                    {
                        "username": "kzo",
                        "content": "[@user3571Rr](/user3571Rr) Doesn\\'t work in Python with it\\'s unlimited precision"
                    },
                    {
                        "username": "spicedNoodle",
                        "content": "[@user3571Rr](/user3571Rr) uint64 can handle super log numbers in most langs. in the TS version i just used BigInt and thats it. i agree with this guys. this is a \"medium\" question. how in the hell is this medium?\\n\\ndont get me wrong, i see your point and i also agree with you. Basic understanding of dataTypes is super important. but medium? this should be a beginner / easy question. Any CS major in his first or second semester should be able to solve this given a few minutes. "
                    },
                    {
                        "username": "robotburrito",
                        "content": "In the real world if you didn\\'t write that 1 line that beats 98% of all other submissions when given this problem you\\'d probably be fired lol."
                    },
                    {
                        "username": "user3571Rr",
                        "content": "Not quite - some of the tests use seriously long number sequences, meaning that none of the conversion to Integer, Long, BigInteger or BigDecimal would actually work because of overflow.\\nIt seems to me that the only way is to carry out multiplications one at a time (as we one was doing it by hand), organise them in columns and produce text from the result, in sequence, while also taking care of rollover values."
                    },
                    {
                        "username": "juicebox2",
                        "content": "Pretty silly question. I feel it teaches devs to try to find complex solutions to simple problems. Why wouldn\\'t we leverage the basic functionality of a language and convert the strings to integer?\\n"
                    },
                    {
                        "username": "Husoski",
                        "content": "More to the point, *someone* has to write code for things like Python unlimited integers or the java.math.BigInteger class.  This is a real programming problem, solved by real programmers, and is more likely to come up in a career (imho) than finding the longest palindrome in a string of a million characters.\\nI\\'m retired, though...old-school with lots of embedded assembly and C...so maybe I\\'m biased by the fact that I\\'ve had to write software multiplication (particularly in assembly) more than once for embedded 8-bit systems."
                    },
                    {
                        "username": "Shikhar_Codes_",
                        "content": "Correct bruh!!"
                    },
                    {
                        "username": "tri_jal",
                        "content": "Listen listen, the reason why they give such questions is to check your problem solving ability. It is not about finding the complex solution, it\\'s about thinking out of the box :)"
                    },
                    {
                        "username": "joshuamahadevan1",
                        "content": "there could be situations where the number can\\'t fit in 64-bit space.. or whatever u decide to use.. numbers expressed  in binary will overflow at some point, and its good to know different ways of processing the same."
                    },
                    {
                        "username": "Krrabs",
                        "content": "For those saying, _why is it a medium? or it should be marked as easy._\n\nIn the question they specifically asked not to use `BigInt` or **convert** the input number **directly.**\n\nThat means in your solution there should never be an instance of `Integer/BigInt` having full value of inputs `num1` and `num2`.\n\nNo one is stopping you from doing that and solving your solution. But then, leaving comments like _\"this is an easy question\"_ you are only making a fool out of yourself."
                    },
                    {
                        "username": "Nakashima",
                        "content": "Do I need to consider the number that is between 0 and 1?"
                    },
                    {
                        "username": "QuazarGuy",
                        "content": "This type of question should be removed so interviewers don\\'t see it and think it\\'s a good question. Implement a tedious and detailed already built-in function that\\'s highly prone to error. I will reject a job if this type of question is asked. Test me on algorithms, not my ability to detect potential off-by-one errors."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for November, Day 7.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/multiply-strings/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Elementary Math\n\n  \n**Approach 2:** Elementary math using less intermediate space\n\n  \n**Approach 3:** Sum the products from all pairs of digits\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "sri_datta",
                        "content": "how does this have so many likes?"
                    },
                    {
                        "username": "nop_nop",
                        "content": "Consider \"123\" and \"456\"\\nMultiply \"6\"(of 456) with \"3\"(of 123) and keep track of this total sum, for next \"6\"(of 456)  with \"2\"(of 123) , but here we need to multiply the product by 10^1 as we do need to account for \"2\"(123) being in tens place and similarly we do it for everything and keep adding the sum.\\n![image](https://assets.leetcode.com/users/nop_nop/image_1547686032.png)\\n\\nBelow is the code:\\n![image](https://assets.leetcode.com/users/nop_nop/image_1547686217.png)\\n"
                    },
                    {
                        "username": "srivastavasameer2002",
                        "content": "what is variable type of total_sum? "
                    },
                    {
                        "username": "healqq",
                        "content": "good explanation, but code doesn\\'t follow the order of the image (as far as I can tell). As you\\'ll get 3 * 6 (i = 0, j = 0) => 3 * 5 (i = 0; j = 1) => 3*4 (i = 0; j = 2) and so on. Doesn\\'t change the result of course, but maybe makes sense to swap the loops around"
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "`n1 = ord(n1) - ord(\\'0\\')` why use ordinals?"
                    },
                    {
                        "username": "Raviteja525",
                        "content": "return str(eval(num1+\\'*\\'+num2))"
                    },
                    {
                        "username": "Sanjeet-Kumar",
                        "content": "![alt text](image url)![0_1497347622870_string.jpg](/assets/uploads/files/1497347627240-string-resized.jpg) \\nGuys As i have found most difficulties to understand the problem.Here From the above picture we can see that the product of ith and jth number will be stroed in position i+j and i+j+1, \\ni.e., res[i+j] is used to store the carry value and res[i+j+1] is used to rightmost digit of the sum.\\n![0_1497347660069_Screenshot (99).png](/assets/uploads/files/1497347665657-screenshot-99.png) \\nI hope it will help you."
                    }
                ]
            },
            {
                "id": 1869576,
                "content": [
                    {
                        "username": "bcronrath",
                        "content": "Honestly I don\\'t understand why these type of questions exist.  They should be removed, or leetcode should at least build in a way to have validation rules such as checking that variables aren\\'t converted to integers.  Look at all the top runtime submissions for this one, literally they are one line where they just convert the strings to integers and multiply them, it\\'s a joke."
                    },
                    {
                        "username": "Husoski",
                        "content": "[@Moonbeam8773](/Moonbeam8773) \\nIt\\'s not vague at all.  The goal is clearly to write the multiplication code yourself.  It\\'s just grade-school arithmetic, after all.  "
                    },
                    {
                        "username": "RedLeader",
                        "content": "Agreed, questions like this are pretty terrible and hacky in nature.  "
                    },
                    {
                        "username": "Moonbeam8773",
                        "content": "It says not to directly convert to int. Does that mean that if I wrote my own int converter I can do that? Or is the purpose of this question to generate a sum of the multiplication of each digit with 10^n padded behind? In that case, can I cast to int and multiply that single digit? Or am I supposed to create a matrix of single digit multiplication results and use that as a hashmap lookup?\\n\\nThis question is so vague it\\'s dumb."
                    },
                    {
                        "username": "neolancer",
                        "content": "This is a good question BUT the submission test cases must ensure that BigNumber-like conversion will not suffice. Otherwise proper solutions, like linked-list etc., will be disappointingly left in the tail"
                    },
                    {
                        "username": "kzo",
                        "content": "[@user3571Rr](/user3571Rr) Doesn\\'t work in Python with it\\'s unlimited precision"
                    },
                    {
                        "username": "spicedNoodle",
                        "content": "[@user3571Rr](/user3571Rr) uint64 can handle super log numbers in most langs. in the TS version i just used BigInt and thats it. i agree with this guys. this is a \"medium\" question. how in the hell is this medium?\\n\\ndont get me wrong, i see your point and i also agree with you. Basic understanding of dataTypes is super important. but medium? this should be a beginner / easy question. Any CS major in his first or second semester should be able to solve this given a few minutes. "
                    },
                    {
                        "username": "robotburrito",
                        "content": "In the real world if you didn\\'t write that 1 line that beats 98% of all other submissions when given this problem you\\'d probably be fired lol."
                    },
                    {
                        "username": "user3571Rr",
                        "content": "Not quite - some of the tests use seriously long number sequences, meaning that none of the conversion to Integer, Long, BigInteger or BigDecimal would actually work because of overflow.\\nIt seems to me that the only way is to carry out multiplications one at a time (as we one was doing it by hand), organise them in columns and produce text from the result, in sequence, while also taking care of rollover values."
                    },
                    {
                        "username": "juicebox2",
                        "content": "Pretty silly question. I feel it teaches devs to try to find complex solutions to simple problems. Why wouldn\\'t we leverage the basic functionality of a language and convert the strings to integer?\\n"
                    },
                    {
                        "username": "Husoski",
                        "content": "More to the point, *someone* has to write code for things like Python unlimited integers or the java.math.BigInteger class.  This is a real programming problem, solved by real programmers, and is more likely to come up in a career (imho) than finding the longest palindrome in a string of a million characters.\\nI\\'m retired, though...old-school with lots of embedded assembly and C...so maybe I\\'m biased by the fact that I\\'ve had to write software multiplication (particularly in assembly) more than once for embedded 8-bit systems."
                    },
                    {
                        "username": "Shikhar_Codes_",
                        "content": "Correct bruh!!"
                    },
                    {
                        "username": "tri_jal",
                        "content": "Listen listen, the reason why they give such questions is to check your problem solving ability. It is not about finding the complex solution, it\\'s about thinking out of the box :)"
                    },
                    {
                        "username": "joshuamahadevan1",
                        "content": "there could be situations where the number can\\'t fit in 64-bit space.. or whatever u decide to use.. numbers expressed  in binary will overflow at some point, and its good to know different ways of processing the same."
                    },
                    {
                        "username": "Krrabs",
                        "content": "For those saying, _why is it a medium? or it should be marked as easy._\n\nIn the question they specifically asked not to use `BigInt` or **convert** the input number **directly.**\n\nThat means in your solution there should never be an instance of `Integer/BigInt` having full value of inputs `num1` and `num2`.\n\nNo one is stopping you from doing that and solving your solution. But then, leaving comments like _\"this is an easy question\"_ you are only making a fool out of yourself."
                    },
                    {
                        "username": "Nakashima",
                        "content": "Do I need to consider the number that is between 0 and 1?"
                    },
                    {
                        "username": "QuazarGuy",
                        "content": "This type of question should be removed so interviewers don\\'t see it and think it\\'s a good question. Implement a tedious and detailed already built-in function that\\'s highly prone to error. I will reject a job if this type of question is asked. Test me on algorithms, not my ability to detect potential off-by-one errors."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for November, Day 7.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/multiply-strings/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Elementary Math\n\n  \n**Approach 2:** Elementary math using less intermediate space\n\n  \n**Approach 3:** Sum the products from all pairs of digits\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "sri_datta",
                        "content": "how does this have so many likes?"
                    },
                    {
                        "username": "nop_nop",
                        "content": "Consider \"123\" and \"456\"\\nMultiply \"6\"(of 456) with \"3\"(of 123) and keep track of this total sum, for next \"6\"(of 456)  with \"2\"(of 123) , but here we need to multiply the product by 10^1 as we do need to account for \"2\"(123) being in tens place and similarly we do it for everything and keep adding the sum.\\n![image](https://assets.leetcode.com/users/nop_nop/image_1547686032.png)\\n\\nBelow is the code:\\n![image](https://assets.leetcode.com/users/nop_nop/image_1547686217.png)\\n"
                    },
                    {
                        "username": "srivastavasameer2002",
                        "content": "what is variable type of total_sum? "
                    },
                    {
                        "username": "healqq",
                        "content": "good explanation, but code doesn\\'t follow the order of the image (as far as I can tell). As you\\'ll get 3 * 6 (i = 0, j = 0) => 3 * 5 (i = 0; j = 1) => 3*4 (i = 0; j = 2) and so on. Doesn\\'t change the result of course, but maybe makes sense to swap the loops around"
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "`n1 = ord(n1) - ord(\\'0\\')` why use ordinals?"
                    },
                    {
                        "username": "Raviteja525",
                        "content": "return str(eval(num1+\\'*\\'+num2))"
                    },
                    {
                        "username": "Sanjeet-Kumar",
                        "content": "![alt text](image url)![0_1497347622870_string.jpg](/assets/uploads/files/1497347627240-string-resized.jpg) \\nGuys As i have found most difficulties to understand the problem.Here From the above picture we can see that the product of ith and jth number will be stroed in position i+j and i+j+1, \\ni.e., res[i+j] is used to store the carry value and res[i+j+1] is used to rightmost digit of the sum.\\n![0_1497347660069_Screenshot (99).png](/assets/uploads/files/1497347665657-screenshot-99.png) \\nI hope it will help you."
                    }
                ]
            },
            {
                "id": 1565737,
                "content": [
                    {
                        "username": "bcronrath",
                        "content": "Honestly I don\\'t understand why these type of questions exist.  They should be removed, or leetcode should at least build in a way to have validation rules such as checking that variables aren\\'t converted to integers.  Look at all the top runtime submissions for this one, literally they are one line where they just convert the strings to integers and multiply them, it\\'s a joke."
                    },
                    {
                        "username": "Husoski",
                        "content": "[@Moonbeam8773](/Moonbeam8773) \\nIt\\'s not vague at all.  The goal is clearly to write the multiplication code yourself.  It\\'s just grade-school arithmetic, after all.  "
                    },
                    {
                        "username": "RedLeader",
                        "content": "Agreed, questions like this are pretty terrible and hacky in nature.  "
                    },
                    {
                        "username": "Moonbeam8773",
                        "content": "It says not to directly convert to int. Does that mean that if I wrote my own int converter I can do that? Or is the purpose of this question to generate a sum of the multiplication of each digit with 10^n padded behind? In that case, can I cast to int and multiply that single digit? Or am I supposed to create a matrix of single digit multiplication results and use that as a hashmap lookup?\\n\\nThis question is so vague it\\'s dumb."
                    },
                    {
                        "username": "neolancer",
                        "content": "This is a good question BUT the submission test cases must ensure that BigNumber-like conversion will not suffice. Otherwise proper solutions, like linked-list etc., will be disappointingly left in the tail"
                    },
                    {
                        "username": "kzo",
                        "content": "[@user3571Rr](/user3571Rr) Doesn\\'t work in Python with it\\'s unlimited precision"
                    },
                    {
                        "username": "spicedNoodle",
                        "content": "[@user3571Rr](/user3571Rr) uint64 can handle super log numbers in most langs. in the TS version i just used BigInt and thats it. i agree with this guys. this is a \"medium\" question. how in the hell is this medium?\\n\\ndont get me wrong, i see your point and i also agree with you. Basic understanding of dataTypes is super important. but medium? this should be a beginner / easy question. Any CS major in his first or second semester should be able to solve this given a few minutes. "
                    },
                    {
                        "username": "robotburrito",
                        "content": "In the real world if you didn\\'t write that 1 line that beats 98% of all other submissions when given this problem you\\'d probably be fired lol."
                    },
                    {
                        "username": "user3571Rr",
                        "content": "Not quite - some of the tests use seriously long number sequences, meaning that none of the conversion to Integer, Long, BigInteger or BigDecimal would actually work because of overflow.\\nIt seems to me that the only way is to carry out multiplications one at a time (as we one was doing it by hand), organise them in columns and produce text from the result, in sequence, while also taking care of rollover values."
                    },
                    {
                        "username": "juicebox2",
                        "content": "Pretty silly question. I feel it teaches devs to try to find complex solutions to simple problems. Why wouldn\\'t we leverage the basic functionality of a language and convert the strings to integer?\\n"
                    },
                    {
                        "username": "Husoski",
                        "content": "More to the point, *someone* has to write code for things like Python unlimited integers or the java.math.BigInteger class.  This is a real programming problem, solved by real programmers, and is more likely to come up in a career (imho) than finding the longest palindrome in a string of a million characters.\\nI\\'m retired, though...old-school with lots of embedded assembly and C...so maybe I\\'m biased by the fact that I\\'ve had to write software multiplication (particularly in assembly) more than once for embedded 8-bit systems."
                    },
                    {
                        "username": "Shikhar_Codes_",
                        "content": "Correct bruh!!"
                    },
                    {
                        "username": "tri_jal",
                        "content": "Listen listen, the reason why they give such questions is to check your problem solving ability. It is not about finding the complex solution, it\\'s about thinking out of the box :)"
                    },
                    {
                        "username": "joshuamahadevan1",
                        "content": "there could be situations where the number can\\'t fit in 64-bit space.. or whatever u decide to use.. numbers expressed  in binary will overflow at some point, and its good to know different ways of processing the same."
                    },
                    {
                        "username": "Krrabs",
                        "content": "For those saying, _why is it a medium? or it should be marked as easy._\n\nIn the question they specifically asked not to use `BigInt` or **convert** the input number **directly.**\n\nThat means in your solution there should never be an instance of `Integer/BigInt` having full value of inputs `num1` and `num2`.\n\nNo one is stopping you from doing that and solving your solution. But then, leaving comments like _\"this is an easy question\"_ you are only making a fool out of yourself."
                    },
                    {
                        "username": "Nakashima",
                        "content": "Do I need to consider the number that is between 0 and 1?"
                    },
                    {
                        "username": "QuazarGuy",
                        "content": "This type of question should be removed so interviewers don\\'t see it and think it\\'s a good question. Implement a tedious and detailed already built-in function that\\'s highly prone to error. I will reject a job if this type of question is asked. Test me on algorithms, not my ability to detect potential off-by-one errors."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for November, Day 7.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/multiply-strings/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Elementary Math\n\n  \n**Approach 2:** Elementary math using less intermediate space\n\n  \n**Approach 3:** Sum the products from all pairs of digits\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "sri_datta",
                        "content": "how does this have so many likes?"
                    },
                    {
                        "username": "nop_nop",
                        "content": "Consider \"123\" and \"456\"\\nMultiply \"6\"(of 456) with \"3\"(of 123) and keep track of this total sum, for next \"6\"(of 456)  with \"2\"(of 123) , but here we need to multiply the product by 10^1 as we do need to account for \"2\"(123) being in tens place and similarly we do it for everything and keep adding the sum.\\n![image](https://assets.leetcode.com/users/nop_nop/image_1547686032.png)\\n\\nBelow is the code:\\n![image](https://assets.leetcode.com/users/nop_nop/image_1547686217.png)\\n"
                    },
                    {
                        "username": "srivastavasameer2002",
                        "content": "what is variable type of total_sum? "
                    },
                    {
                        "username": "healqq",
                        "content": "good explanation, but code doesn\\'t follow the order of the image (as far as I can tell). As you\\'ll get 3 * 6 (i = 0, j = 0) => 3 * 5 (i = 0; j = 1) => 3*4 (i = 0; j = 2) and so on. Doesn\\'t change the result of course, but maybe makes sense to swap the loops around"
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "`n1 = ord(n1) - ord(\\'0\\')` why use ordinals?"
                    },
                    {
                        "username": "Raviteja525",
                        "content": "return str(eval(num1+\\'*\\'+num2))"
                    },
                    {
                        "username": "Sanjeet-Kumar",
                        "content": "![alt text](image url)![0_1497347622870_string.jpg](/assets/uploads/files/1497347627240-string-resized.jpg) \\nGuys As i have found most difficulties to understand the problem.Here From the above picture we can see that the product of ith and jth number will be stroed in position i+j and i+j+1, \\ni.e., res[i+j] is used to store the carry value and res[i+j+1] is used to rightmost digit of the sum.\\n![0_1497347660069_Screenshot (99).png](/assets/uploads/files/1497347665657-screenshot-99.png) \\nI hope it will help you."
                    }
                ]
            },
            {
                "id": 1756571,
                "content": [
                    {
                        "username": "bcronrath",
                        "content": "Honestly I don\\'t understand why these type of questions exist.  They should be removed, or leetcode should at least build in a way to have validation rules such as checking that variables aren\\'t converted to integers.  Look at all the top runtime submissions for this one, literally they are one line where they just convert the strings to integers and multiply them, it\\'s a joke."
                    },
                    {
                        "username": "Husoski",
                        "content": "[@Moonbeam8773](/Moonbeam8773) \\nIt\\'s not vague at all.  The goal is clearly to write the multiplication code yourself.  It\\'s just grade-school arithmetic, after all.  "
                    },
                    {
                        "username": "RedLeader",
                        "content": "Agreed, questions like this are pretty terrible and hacky in nature.  "
                    },
                    {
                        "username": "Moonbeam8773",
                        "content": "It says not to directly convert to int. Does that mean that if I wrote my own int converter I can do that? Or is the purpose of this question to generate a sum of the multiplication of each digit with 10^n padded behind? In that case, can I cast to int and multiply that single digit? Or am I supposed to create a matrix of single digit multiplication results and use that as a hashmap lookup?\\n\\nThis question is so vague it\\'s dumb."
                    },
                    {
                        "username": "neolancer",
                        "content": "This is a good question BUT the submission test cases must ensure that BigNumber-like conversion will not suffice. Otherwise proper solutions, like linked-list etc., will be disappointingly left in the tail"
                    },
                    {
                        "username": "kzo",
                        "content": "[@user3571Rr](/user3571Rr) Doesn\\'t work in Python with it\\'s unlimited precision"
                    },
                    {
                        "username": "spicedNoodle",
                        "content": "[@user3571Rr](/user3571Rr) uint64 can handle super log numbers in most langs. in the TS version i just used BigInt and thats it. i agree with this guys. this is a \"medium\" question. how in the hell is this medium?\\n\\ndont get me wrong, i see your point and i also agree with you. Basic understanding of dataTypes is super important. but medium? this should be a beginner / easy question. Any CS major in his first or second semester should be able to solve this given a few minutes. "
                    },
                    {
                        "username": "robotburrito",
                        "content": "In the real world if you didn\\'t write that 1 line that beats 98% of all other submissions when given this problem you\\'d probably be fired lol."
                    },
                    {
                        "username": "user3571Rr",
                        "content": "Not quite - some of the tests use seriously long number sequences, meaning that none of the conversion to Integer, Long, BigInteger or BigDecimal would actually work because of overflow.\\nIt seems to me that the only way is to carry out multiplications one at a time (as we one was doing it by hand), organise them in columns and produce text from the result, in sequence, while also taking care of rollover values."
                    },
                    {
                        "username": "juicebox2",
                        "content": "Pretty silly question. I feel it teaches devs to try to find complex solutions to simple problems. Why wouldn\\'t we leverage the basic functionality of a language and convert the strings to integer?\\n"
                    },
                    {
                        "username": "Husoski",
                        "content": "More to the point, *someone* has to write code for things like Python unlimited integers or the java.math.BigInteger class.  This is a real programming problem, solved by real programmers, and is more likely to come up in a career (imho) than finding the longest palindrome in a string of a million characters.\\nI\\'m retired, though...old-school with lots of embedded assembly and C...so maybe I\\'m biased by the fact that I\\'ve had to write software multiplication (particularly in assembly) more than once for embedded 8-bit systems."
                    },
                    {
                        "username": "Shikhar_Codes_",
                        "content": "Correct bruh!!"
                    },
                    {
                        "username": "tri_jal",
                        "content": "Listen listen, the reason why they give such questions is to check your problem solving ability. It is not about finding the complex solution, it\\'s about thinking out of the box :)"
                    },
                    {
                        "username": "joshuamahadevan1",
                        "content": "there could be situations where the number can\\'t fit in 64-bit space.. or whatever u decide to use.. numbers expressed  in binary will overflow at some point, and its good to know different ways of processing the same."
                    },
                    {
                        "username": "Krrabs",
                        "content": "For those saying, _why is it a medium? or it should be marked as easy._\n\nIn the question they specifically asked not to use `BigInt` or **convert** the input number **directly.**\n\nThat means in your solution there should never be an instance of `Integer/BigInt` having full value of inputs `num1` and `num2`.\n\nNo one is stopping you from doing that and solving your solution. But then, leaving comments like _\"this is an easy question\"_ you are only making a fool out of yourself."
                    },
                    {
                        "username": "Nakashima",
                        "content": "Do I need to consider the number that is between 0 and 1?"
                    },
                    {
                        "username": "QuazarGuy",
                        "content": "This type of question should be removed so interviewers don\\'t see it and think it\\'s a good question. Implement a tedious and detailed already built-in function that\\'s highly prone to error. I will reject a job if this type of question is asked. Test me on algorithms, not my ability to detect potential off-by-one errors."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for November, Day 7.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/multiply-strings/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Elementary Math\n\n  \n**Approach 2:** Elementary math using less intermediate space\n\n  \n**Approach 3:** Sum the products from all pairs of digits\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "sri_datta",
                        "content": "how does this have so many likes?"
                    },
                    {
                        "username": "nop_nop",
                        "content": "Consider \"123\" and \"456\"\\nMultiply \"6\"(of 456) with \"3\"(of 123) and keep track of this total sum, for next \"6\"(of 456)  with \"2\"(of 123) , but here we need to multiply the product by 10^1 as we do need to account for \"2\"(123) being in tens place and similarly we do it for everything and keep adding the sum.\\n![image](https://assets.leetcode.com/users/nop_nop/image_1547686032.png)\\n\\nBelow is the code:\\n![image](https://assets.leetcode.com/users/nop_nop/image_1547686217.png)\\n"
                    },
                    {
                        "username": "srivastavasameer2002",
                        "content": "what is variable type of total_sum? "
                    },
                    {
                        "username": "healqq",
                        "content": "good explanation, but code doesn\\'t follow the order of the image (as far as I can tell). As you\\'ll get 3 * 6 (i = 0, j = 0) => 3 * 5 (i = 0; j = 1) => 3*4 (i = 0; j = 2) and so on. Doesn\\'t change the result of course, but maybe makes sense to swap the loops around"
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "`n1 = ord(n1) - ord(\\'0\\')` why use ordinals?"
                    },
                    {
                        "username": "Raviteja525",
                        "content": "return str(eval(num1+\\'*\\'+num2))"
                    },
                    {
                        "username": "Sanjeet-Kumar",
                        "content": "![alt text](image url)![0_1497347622870_string.jpg](/assets/uploads/files/1497347627240-string-resized.jpg) \\nGuys As i have found most difficulties to understand the problem.Here From the above picture we can see that the product of ith and jth number will be stroed in position i+j and i+j+1, \\ni.e., res[i+j] is used to store the carry value and res[i+j+1] is used to rightmost digit of the sum.\\n![0_1497347660069_Screenshot (99).png](/assets/uploads/files/1497347665657-screenshot-99.png) \\nI hope it will help you."
                    }
                ]
            },
            {
                "id": 1565177,
                "content": [
                    {
                        "username": "bcronrath",
                        "content": "Honestly I don\\'t understand why these type of questions exist.  They should be removed, or leetcode should at least build in a way to have validation rules such as checking that variables aren\\'t converted to integers.  Look at all the top runtime submissions for this one, literally they are one line where they just convert the strings to integers and multiply them, it\\'s a joke."
                    },
                    {
                        "username": "Husoski",
                        "content": "[@Moonbeam8773](/Moonbeam8773) \\nIt\\'s not vague at all.  The goal is clearly to write the multiplication code yourself.  It\\'s just grade-school arithmetic, after all.  "
                    },
                    {
                        "username": "RedLeader",
                        "content": "Agreed, questions like this are pretty terrible and hacky in nature.  "
                    },
                    {
                        "username": "Moonbeam8773",
                        "content": "It says not to directly convert to int. Does that mean that if I wrote my own int converter I can do that? Or is the purpose of this question to generate a sum of the multiplication of each digit with 10^n padded behind? In that case, can I cast to int and multiply that single digit? Or am I supposed to create a matrix of single digit multiplication results and use that as a hashmap lookup?\\n\\nThis question is so vague it\\'s dumb."
                    },
                    {
                        "username": "neolancer",
                        "content": "This is a good question BUT the submission test cases must ensure that BigNumber-like conversion will not suffice. Otherwise proper solutions, like linked-list etc., will be disappointingly left in the tail"
                    },
                    {
                        "username": "kzo",
                        "content": "[@user3571Rr](/user3571Rr) Doesn\\'t work in Python with it\\'s unlimited precision"
                    },
                    {
                        "username": "spicedNoodle",
                        "content": "[@user3571Rr](/user3571Rr) uint64 can handle super log numbers in most langs. in the TS version i just used BigInt and thats it. i agree with this guys. this is a \"medium\" question. how in the hell is this medium?\\n\\ndont get me wrong, i see your point and i also agree with you. Basic understanding of dataTypes is super important. but medium? this should be a beginner / easy question. Any CS major in his first or second semester should be able to solve this given a few minutes. "
                    },
                    {
                        "username": "robotburrito",
                        "content": "In the real world if you didn\\'t write that 1 line that beats 98% of all other submissions when given this problem you\\'d probably be fired lol."
                    },
                    {
                        "username": "user3571Rr",
                        "content": "Not quite - some of the tests use seriously long number sequences, meaning that none of the conversion to Integer, Long, BigInteger or BigDecimal would actually work because of overflow.\\nIt seems to me that the only way is to carry out multiplications one at a time (as we one was doing it by hand), organise them in columns and produce text from the result, in sequence, while also taking care of rollover values."
                    },
                    {
                        "username": "juicebox2",
                        "content": "Pretty silly question. I feel it teaches devs to try to find complex solutions to simple problems. Why wouldn\\'t we leverage the basic functionality of a language and convert the strings to integer?\\n"
                    },
                    {
                        "username": "Husoski",
                        "content": "More to the point, *someone* has to write code for things like Python unlimited integers or the java.math.BigInteger class.  This is a real programming problem, solved by real programmers, and is more likely to come up in a career (imho) than finding the longest palindrome in a string of a million characters.\\nI\\'m retired, though...old-school with lots of embedded assembly and C...so maybe I\\'m biased by the fact that I\\'ve had to write software multiplication (particularly in assembly) more than once for embedded 8-bit systems."
                    },
                    {
                        "username": "Shikhar_Codes_",
                        "content": "Correct bruh!!"
                    },
                    {
                        "username": "tri_jal",
                        "content": "Listen listen, the reason why they give such questions is to check your problem solving ability. It is not about finding the complex solution, it\\'s about thinking out of the box :)"
                    },
                    {
                        "username": "joshuamahadevan1",
                        "content": "there could be situations where the number can\\'t fit in 64-bit space.. or whatever u decide to use.. numbers expressed  in binary will overflow at some point, and its good to know different ways of processing the same."
                    },
                    {
                        "username": "Krrabs",
                        "content": "For those saying, _why is it a medium? or it should be marked as easy._\n\nIn the question they specifically asked not to use `BigInt` or **convert** the input number **directly.**\n\nThat means in your solution there should never be an instance of `Integer/BigInt` having full value of inputs `num1` and `num2`.\n\nNo one is stopping you from doing that and solving your solution. But then, leaving comments like _\"this is an easy question\"_ you are only making a fool out of yourself."
                    },
                    {
                        "username": "Nakashima",
                        "content": "Do I need to consider the number that is between 0 and 1?"
                    },
                    {
                        "username": "QuazarGuy",
                        "content": "This type of question should be removed so interviewers don\\'t see it and think it\\'s a good question. Implement a tedious and detailed already built-in function that\\'s highly prone to error. I will reject a job if this type of question is asked. Test me on algorithms, not my ability to detect potential off-by-one errors."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for November, Day 7.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/multiply-strings/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Elementary Math\n\n  \n**Approach 2:** Elementary math using less intermediate space\n\n  \n**Approach 3:** Sum the products from all pairs of digits\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "sri_datta",
                        "content": "how does this have so many likes?"
                    },
                    {
                        "username": "nop_nop",
                        "content": "Consider \"123\" and \"456\"\\nMultiply \"6\"(of 456) with \"3\"(of 123) and keep track of this total sum, for next \"6\"(of 456)  with \"2\"(of 123) , but here we need to multiply the product by 10^1 as we do need to account for \"2\"(123) being in tens place and similarly we do it for everything and keep adding the sum.\\n![image](https://assets.leetcode.com/users/nop_nop/image_1547686032.png)\\n\\nBelow is the code:\\n![image](https://assets.leetcode.com/users/nop_nop/image_1547686217.png)\\n"
                    },
                    {
                        "username": "srivastavasameer2002",
                        "content": "what is variable type of total_sum? "
                    },
                    {
                        "username": "healqq",
                        "content": "good explanation, but code doesn\\'t follow the order of the image (as far as I can tell). As you\\'ll get 3 * 6 (i = 0, j = 0) => 3 * 5 (i = 0; j = 1) => 3*4 (i = 0; j = 2) and so on. Doesn\\'t change the result of course, but maybe makes sense to swap the loops around"
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "`n1 = ord(n1) - ord(\\'0\\')` why use ordinals?"
                    },
                    {
                        "username": "Raviteja525",
                        "content": "return str(eval(num1+\\'*\\'+num2))"
                    },
                    {
                        "username": "Sanjeet-Kumar",
                        "content": "![alt text](image url)![0_1497347622870_string.jpg](/assets/uploads/files/1497347627240-string-resized.jpg) \\nGuys As i have found most difficulties to understand the problem.Here From the above picture we can see that the product of ith and jth number will be stroed in position i+j and i+j+1, \\ni.e., res[i+j] is used to store the carry value and res[i+j+1] is used to rightmost digit of the sum.\\n![0_1497347660069_Screenshot (99).png](/assets/uploads/files/1497347665657-screenshot-99.png) \\nI hope it will help you."
                    }
                ]
            },
            {
                "id": 1789479,
                "content": [
                    {
                        "username": "bcronrath",
                        "content": "Honestly I don\\'t understand why these type of questions exist.  They should be removed, or leetcode should at least build in a way to have validation rules such as checking that variables aren\\'t converted to integers.  Look at all the top runtime submissions for this one, literally they are one line where they just convert the strings to integers and multiply them, it\\'s a joke."
                    },
                    {
                        "username": "Husoski",
                        "content": "[@Moonbeam8773](/Moonbeam8773) \\nIt\\'s not vague at all.  The goal is clearly to write the multiplication code yourself.  It\\'s just grade-school arithmetic, after all.  "
                    },
                    {
                        "username": "RedLeader",
                        "content": "Agreed, questions like this are pretty terrible and hacky in nature.  "
                    },
                    {
                        "username": "Moonbeam8773",
                        "content": "It says not to directly convert to int. Does that mean that if I wrote my own int converter I can do that? Or is the purpose of this question to generate a sum of the multiplication of each digit with 10^n padded behind? In that case, can I cast to int and multiply that single digit? Or am I supposed to create a matrix of single digit multiplication results and use that as a hashmap lookup?\\n\\nThis question is so vague it\\'s dumb."
                    },
                    {
                        "username": "neolancer",
                        "content": "This is a good question BUT the submission test cases must ensure that BigNumber-like conversion will not suffice. Otherwise proper solutions, like linked-list etc., will be disappointingly left in the tail"
                    },
                    {
                        "username": "kzo",
                        "content": "[@user3571Rr](/user3571Rr) Doesn\\'t work in Python with it\\'s unlimited precision"
                    },
                    {
                        "username": "spicedNoodle",
                        "content": "[@user3571Rr](/user3571Rr) uint64 can handle super log numbers in most langs. in the TS version i just used BigInt and thats it. i agree with this guys. this is a \"medium\" question. how in the hell is this medium?\\n\\ndont get me wrong, i see your point and i also agree with you. Basic understanding of dataTypes is super important. but medium? this should be a beginner / easy question. Any CS major in his first or second semester should be able to solve this given a few minutes. "
                    },
                    {
                        "username": "robotburrito",
                        "content": "In the real world if you didn\\'t write that 1 line that beats 98% of all other submissions when given this problem you\\'d probably be fired lol."
                    },
                    {
                        "username": "user3571Rr",
                        "content": "Not quite - some of the tests use seriously long number sequences, meaning that none of the conversion to Integer, Long, BigInteger or BigDecimal would actually work because of overflow.\\nIt seems to me that the only way is to carry out multiplications one at a time (as we one was doing it by hand), organise them in columns and produce text from the result, in sequence, while also taking care of rollover values."
                    },
                    {
                        "username": "juicebox2",
                        "content": "Pretty silly question. I feel it teaches devs to try to find complex solutions to simple problems. Why wouldn\\'t we leverage the basic functionality of a language and convert the strings to integer?\\n"
                    },
                    {
                        "username": "Husoski",
                        "content": "More to the point, *someone* has to write code for things like Python unlimited integers or the java.math.BigInteger class.  This is a real programming problem, solved by real programmers, and is more likely to come up in a career (imho) than finding the longest palindrome in a string of a million characters.\\nI\\'m retired, though...old-school with lots of embedded assembly and C...so maybe I\\'m biased by the fact that I\\'ve had to write software multiplication (particularly in assembly) more than once for embedded 8-bit systems."
                    },
                    {
                        "username": "Shikhar_Codes_",
                        "content": "Correct bruh!!"
                    },
                    {
                        "username": "tri_jal",
                        "content": "Listen listen, the reason why they give such questions is to check your problem solving ability. It is not about finding the complex solution, it\\'s about thinking out of the box :)"
                    },
                    {
                        "username": "joshuamahadevan1",
                        "content": "there could be situations where the number can\\'t fit in 64-bit space.. or whatever u decide to use.. numbers expressed  in binary will overflow at some point, and its good to know different ways of processing the same."
                    },
                    {
                        "username": "Krrabs",
                        "content": "For those saying, _why is it a medium? or it should be marked as easy._\n\nIn the question they specifically asked not to use `BigInt` or **convert** the input number **directly.**\n\nThat means in your solution there should never be an instance of `Integer/BigInt` having full value of inputs `num1` and `num2`.\n\nNo one is stopping you from doing that and solving your solution. But then, leaving comments like _\"this is an easy question\"_ you are only making a fool out of yourself."
                    },
                    {
                        "username": "Nakashima",
                        "content": "Do I need to consider the number that is between 0 and 1?"
                    },
                    {
                        "username": "QuazarGuy",
                        "content": "This type of question should be removed so interviewers don\\'t see it and think it\\'s a good question. Implement a tedious and detailed already built-in function that\\'s highly prone to error. I will reject a job if this type of question is asked. Test me on algorithms, not my ability to detect potential off-by-one errors."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for November, Day 7.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/multiply-strings/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Elementary Math\n\n  \n**Approach 2:** Elementary math using less intermediate space\n\n  \n**Approach 3:** Sum the products from all pairs of digits\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "sri_datta",
                        "content": "how does this have so many likes?"
                    },
                    {
                        "username": "nop_nop",
                        "content": "Consider \"123\" and \"456\"\\nMultiply \"6\"(of 456) with \"3\"(of 123) and keep track of this total sum, for next \"6\"(of 456)  with \"2\"(of 123) , but here we need to multiply the product by 10^1 as we do need to account for \"2\"(123) being in tens place and similarly we do it for everything and keep adding the sum.\\n![image](https://assets.leetcode.com/users/nop_nop/image_1547686032.png)\\n\\nBelow is the code:\\n![image](https://assets.leetcode.com/users/nop_nop/image_1547686217.png)\\n"
                    },
                    {
                        "username": "srivastavasameer2002",
                        "content": "what is variable type of total_sum? "
                    },
                    {
                        "username": "healqq",
                        "content": "good explanation, but code doesn\\'t follow the order of the image (as far as I can tell). As you\\'ll get 3 * 6 (i = 0, j = 0) => 3 * 5 (i = 0; j = 1) => 3*4 (i = 0; j = 2) and so on. Doesn\\'t change the result of course, but maybe makes sense to swap the loops around"
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "`n1 = ord(n1) - ord(\\'0\\')` why use ordinals?"
                    },
                    {
                        "username": "Raviteja525",
                        "content": "return str(eval(num1+\\'*\\'+num2))"
                    },
                    {
                        "username": "Sanjeet-Kumar",
                        "content": "![alt text](image url)![0_1497347622870_string.jpg](/assets/uploads/files/1497347627240-string-resized.jpg) \\nGuys As i have found most difficulties to understand the problem.Here From the above picture we can see that the product of ith and jth number will be stroed in position i+j and i+j+1, \\ni.e., res[i+j] is used to store the carry value and res[i+j+1] is used to rightmost digit of the sum.\\n![0_1497347660069_Screenshot (99).png](/assets/uploads/files/1497347665657-screenshot-99.png) \\nI hope it will help you."
                    }
                ]
            },
            {
                "id": 1572392,
                "content": [
                    {
                        "username": "bcronrath",
                        "content": "Honestly I don\\'t understand why these type of questions exist.  They should be removed, or leetcode should at least build in a way to have validation rules such as checking that variables aren\\'t converted to integers.  Look at all the top runtime submissions for this one, literally they are one line where they just convert the strings to integers and multiply them, it\\'s a joke."
                    },
                    {
                        "username": "Husoski",
                        "content": "[@Moonbeam8773](/Moonbeam8773) \\nIt\\'s not vague at all.  The goal is clearly to write the multiplication code yourself.  It\\'s just grade-school arithmetic, after all.  "
                    },
                    {
                        "username": "RedLeader",
                        "content": "Agreed, questions like this are pretty terrible and hacky in nature.  "
                    },
                    {
                        "username": "Moonbeam8773",
                        "content": "It says not to directly convert to int. Does that mean that if I wrote my own int converter I can do that? Or is the purpose of this question to generate a sum of the multiplication of each digit with 10^n padded behind? In that case, can I cast to int and multiply that single digit? Or am I supposed to create a matrix of single digit multiplication results and use that as a hashmap lookup?\\n\\nThis question is so vague it\\'s dumb."
                    },
                    {
                        "username": "neolancer",
                        "content": "This is a good question BUT the submission test cases must ensure that BigNumber-like conversion will not suffice. Otherwise proper solutions, like linked-list etc., will be disappointingly left in the tail"
                    },
                    {
                        "username": "kzo",
                        "content": "[@user3571Rr](/user3571Rr) Doesn\\'t work in Python with it\\'s unlimited precision"
                    },
                    {
                        "username": "spicedNoodle",
                        "content": "[@user3571Rr](/user3571Rr) uint64 can handle super log numbers in most langs. in the TS version i just used BigInt and thats it. i agree with this guys. this is a \"medium\" question. how in the hell is this medium?\\n\\ndont get me wrong, i see your point and i also agree with you. Basic understanding of dataTypes is super important. but medium? this should be a beginner / easy question. Any CS major in his first or second semester should be able to solve this given a few minutes. "
                    },
                    {
                        "username": "robotburrito",
                        "content": "In the real world if you didn\\'t write that 1 line that beats 98% of all other submissions when given this problem you\\'d probably be fired lol."
                    },
                    {
                        "username": "user3571Rr",
                        "content": "Not quite - some of the tests use seriously long number sequences, meaning that none of the conversion to Integer, Long, BigInteger or BigDecimal would actually work because of overflow.\\nIt seems to me that the only way is to carry out multiplications one at a time (as we one was doing it by hand), organise them in columns and produce text from the result, in sequence, while also taking care of rollover values."
                    },
                    {
                        "username": "juicebox2",
                        "content": "Pretty silly question. I feel it teaches devs to try to find complex solutions to simple problems. Why wouldn\\'t we leverage the basic functionality of a language and convert the strings to integer?\\n"
                    },
                    {
                        "username": "Husoski",
                        "content": "More to the point, *someone* has to write code for things like Python unlimited integers or the java.math.BigInteger class.  This is a real programming problem, solved by real programmers, and is more likely to come up in a career (imho) than finding the longest palindrome in a string of a million characters.\\nI\\'m retired, though...old-school with lots of embedded assembly and C...so maybe I\\'m biased by the fact that I\\'ve had to write software multiplication (particularly in assembly) more than once for embedded 8-bit systems."
                    },
                    {
                        "username": "Shikhar_Codes_",
                        "content": "Correct bruh!!"
                    },
                    {
                        "username": "tri_jal",
                        "content": "Listen listen, the reason why they give such questions is to check your problem solving ability. It is not about finding the complex solution, it\\'s about thinking out of the box :)"
                    },
                    {
                        "username": "joshuamahadevan1",
                        "content": "there could be situations where the number can\\'t fit in 64-bit space.. or whatever u decide to use.. numbers expressed  in binary will overflow at some point, and its good to know different ways of processing the same."
                    },
                    {
                        "username": "Krrabs",
                        "content": "For those saying, _why is it a medium? or it should be marked as easy._\n\nIn the question they specifically asked not to use `BigInt` or **convert** the input number **directly.**\n\nThat means in your solution there should never be an instance of `Integer/BigInt` having full value of inputs `num1` and `num2`.\n\nNo one is stopping you from doing that and solving your solution. But then, leaving comments like _\"this is an easy question\"_ you are only making a fool out of yourself."
                    },
                    {
                        "username": "Nakashima",
                        "content": "Do I need to consider the number that is between 0 and 1?"
                    },
                    {
                        "username": "QuazarGuy",
                        "content": "This type of question should be removed so interviewers don\\'t see it and think it\\'s a good question. Implement a tedious and detailed already built-in function that\\'s highly prone to error. I will reject a job if this type of question is asked. Test me on algorithms, not my ability to detect potential off-by-one errors."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for November, Day 7.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/multiply-strings/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Elementary Math\n\n  \n**Approach 2:** Elementary math using less intermediate space\n\n  \n**Approach 3:** Sum the products from all pairs of digits\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "sri_datta",
                        "content": "how does this have so many likes?"
                    },
                    {
                        "username": "nop_nop",
                        "content": "Consider \"123\" and \"456\"\\nMultiply \"6\"(of 456) with \"3\"(of 123) and keep track of this total sum, for next \"6\"(of 456)  with \"2\"(of 123) , but here we need to multiply the product by 10^1 as we do need to account for \"2\"(123) being in tens place and similarly we do it for everything and keep adding the sum.\\n![image](https://assets.leetcode.com/users/nop_nop/image_1547686032.png)\\n\\nBelow is the code:\\n![image](https://assets.leetcode.com/users/nop_nop/image_1547686217.png)\\n"
                    },
                    {
                        "username": "srivastavasameer2002",
                        "content": "what is variable type of total_sum? "
                    },
                    {
                        "username": "healqq",
                        "content": "good explanation, but code doesn\\'t follow the order of the image (as far as I can tell). As you\\'ll get 3 * 6 (i = 0, j = 0) => 3 * 5 (i = 0; j = 1) => 3*4 (i = 0; j = 2) and so on. Doesn\\'t change the result of course, but maybe makes sense to swap the loops around"
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "`n1 = ord(n1) - ord(\\'0\\')` why use ordinals?"
                    },
                    {
                        "username": "Raviteja525",
                        "content": "return str(eval(num1+\\'*\\'+num2))"
                    },
                    {
                        "username": "Sanjeet-Kumar",
                        "content": "![alt text](image url)![0_1497347622870_string.jpg](/assets/uploads/files/1497347627240-string-resized.jpg) \\nGuys As i have found most difficulties to understand the problem.Here From the above picture we can see that the product of ith and jth number will be stroed in position i+j and i+j+1, \\ni.e., res[i+j] is used to store the carry value and res[i+j+1] is used to rightmost digit of the sum.\\n![0_1497347660069_Screenshot (99).png](/assets/uploads/files/1497347665657-screenshot-99.png) \\nI hope it will help you."
                    }
                ]
            },
            {
                "id": 1576603,
                "content": [
                    {
                        "username": "bcronrath",
                        "content": "Honestly I don\\'t understand why these type of questions exist.  They should be removed, or leetcode should at least build in a way to have validation rules such as checking that variables aren\\'t converted to integers.  Look at all the top runtime submissions for this one, literally they are one line where they just convert the strings to integers and multiply them, it\\'s a joke."
                    },
                    {
                        "username": "Husoski",
                        "content": "[@Moonbeam8773](/Moonbeam8773) \\nIt\\'s not vague at all.  The goal is clearly to write the multiplication code yourself.  It\\'s just grade-school arithmetic, after all.  "
                    },
                    {
                        "username": "RedLeader",
                        "content": "Agreed, questions like this are pretty terrible and hacky in nature.  "
                    },
                    {
                        "username": "Moonbeam8773",
                        "content": "It says not to directly convert to int. Does that mean that if I wrote my own int converter I can do that? Or is the purpose of this question to generate a sum of the multiplication of each digit with 10^n padded behind? In that case, can I cast to int and multiply that single digit? Or am I supposed to create a matrix of single digit multiplication results and use that as a hashmap lookup?\\n\\nThis question is so vague it\\'s dumb."
                    },
                    {
                        "username": "neolancer",
                        "content": "This is a good question BUT the submission test cases must ensure that BigNumber-like conversion will not suffice. Otherwise proper solutions, like linked-list etc., will be disappointingly left in the tail"
                    },
                    {
                        "username": "kzo",
                        "content": "[@user3571Rr](/user3571Rr) Doesn\\'t work in Python with it\\'s unlimited precision"
                    },
                    {
                        "username": "spicedNoodle",
                        "content": "[@user3571Rr](/user3571Rr) uint64 can handle super log numbers in most langs. in the TS version i just used BigInt and thats it. i agree with this guys. this is a \"medium\" question. how in the hell is this medium?\\n\\ndont get me wrong, i see your point and i also agree with you. Basic understanding of dataTypes is super important. but medium? this should be a beginner / easy question. Any CS major in his first or second semester should be able to solve this given a few minutes. "
                    },
                    {
                        "username": "robotburrito",
                        "content": "In the real world if you didn\\'t write that 1 line that beats 98% of all other submissions when given this problem you\\'d probably be fired lol."
                    },
                    {
                        "username": "user3571Rr",
                        "content": "Not quite - some of the tests use seriously long number sequences, meaning that none of the conversion to Integer, Long, BigInteger or BigDecimal would actually work because of overflow.\\nIt seems to me that the only way is to carry out multiplications one at a time (as we one was doing it by hand), organise them in columns and produce text from the result, in sequence, while also taking care of rollover values."
                    },
                    {
                        "username": "juicebox2",
                        "content": "Pretty silly question. I feel it teaches devs to try to find complex solutions to simple problems. Why wouldn\\'t we leverage the basic functionality of a language and convert the strings to integer?\\n"
                    },
                    {
                        "username": "Husoski",
                        "content": "More to the point, *someone* has to write code for things like Python unlimited integers or the java.math.BigInteger class.  This is a real programming problem, solved by real programmers, and is more likely to come up in a career (imho) than finding the longest palindrome in a string of a million characters.\\nI\\'m retired, though...old-school with lots of embedded assembly and C...so maybe I\\'m biased by the fact that I\\'ve had to write software multiplication (particularly in assembly) more than once for embedded 8-bit systems."
                    },
                    {
                        "username": "Shikhar_Codes_",
                        "content": "Correct bruh!!"
                    },
                    {
                        "username": "tri_jal",
                        "content": "Listen listen, the reason why they give such questions is to check your problem solving ability. It is not about finding the complex solution, it\\'s about thinking out of the box :)"
                    },
                    {
                        "username": "joshuamahadevan1",
                        "content": "there could be situations where the number can\\'t fit in 64-bit space.. or whatever u decide to use.. numbers expressed  in binary will overflow at some point, and its good to know different ways of processing the same."
                    },
                    {
                        "username": "Krrabs",
                        "content": "For those saying, _why is it a medium? or it should be marked as easy._\n\nIn the question they specifically asked not to use `BigInt` or **convert** the input number **directly.**\n\nThat means in your solution there should never be an instance of `Integer/BigInt` having full value of inputs `num1` and `num2`.\n\nNo one is stopping you from doing that and solving your solution. But then, leaving comments like _\"this is an easy question\"_ you are only making a fool out of yourself."
                    },
                    {
                        "username": "Nakashima",
                        "content": "Do I need to consider the number that is between 0 and 1?"
                    },
                    {
                        "username": "QuazarGuy",
                        "content": "This type of question should be removed so interviewers don\\'t see it and think it\\'s a good question. Implement a tedious and detailed already built-in function that\\'s highly prone to error. I will reject a job if this type of question is asked. Test me on algorithms, not my ability to detect potential off-by-one errors."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for November, Day 7.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/multiply-strings/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Elementary Math\n\n  \n**Approach 2:** Elementary math using less intermediate space\n\n  \n**Approach 3:** Sum the products from all pairs of digits\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "sri_datta",
                        "content": "how does this have so many likes?"
                    },
                    {
                        "username": "nop_nop",
                        "content": "Consider \"123\" and \"456\"\\nMultiply \"6\"(of 456) with \"3\"(of 123) and keep track of this total sum, for next \"6\"(of 456)  with \"2\"(of 123) , but here we need to multiply the product by 10^1 as we do need to account for \"2\"(123) being in tens place and similarly we do it for everything and keep adding the sum.\\n![image](https://assets.leetcode.com/users/nop_nop/image_1547686032.png)\\n\\nBelow is the code:\\n![image](https://assets.leetcode.com/users/nop_nop/image_1547686217.png)\\n"
                    },
                    {
                        "username": "srivastavasameer2002",
                        "content": "what is variable type of total_sum? "
                    },
                    {
                        "username": "healqq",
                        "content": "good explanation, but code doesn\\'t follow the order of the image (as far as I can tell). As you\\'ll get 3 * 6 (i = 0, j = 0) => 3 * 5 (i = 0; j = 1) => 3*4 (i = 0; j = 2) and so on. Doesn\\'t change the result of course, but maybe makes sense to swap the loops around"
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "`n1 = ord(n1) - ord(\\'0\\')` why use ordinals?"
                    },
                    {
                        "username": "Raviteja525",
                        "content": "return str(eval(num1+\\'*\\'+num2))"
                    },
                    {
                        "username": "Sanjeet-Kumar",
                        "content": "![alt text](image url)![0_1497347622870_string.jpg](/assets/uploads/files/1497347627240-string-resized.jpg) \\nGuys As i have found most difficulties to understand the problem.Here From the above picture we can see that the product of ith and jth number will be stroed in position i+j and i+j+1, \\ni.e., res[i+j] is used to store the carry value and res[i+j+1] is used to rightmost digit of the sum.\\n![0_1497347660069_Screenshot (99).png](/assets/uploads/files/1497347665657-screenshot-99.png) \\nI hope it will help you."
                    }
                ]
            },
            {
                "id": 1566740,
                "content": [
                    {
                        "username": "bcronrath",
                        "content": "Honestly I don\\'t understand why these type of questions exist.  They should be removed, or leetcode should at least build in a way to have validation rules such as checking that variables aren\\'t converted to integers.  Look at all the top runtime submissions for this one, literally they are one line where they just convert the strings to integers and multiply them, it\\'s a joke."
                    },
                    {
                        "username": "Husoski",
                        "content": "[@Moonbeam8773](/Moonbeam8773) \\nIt\\'s not vague at all.  The goal is clearly to write the multiplication code yourself.  It\\'s just grade-school arithmetic, after all.  "
                    },
                    {
                        "username": "RedLeader",
                        "content": "Agreed, questions like this are pretty terrible and hacky in nature.  "
                    },
                    {
                        "username": "Moonbeam8773",
                        "content": "It says not to directly convert to int. Does that mean that if I wrote my own int converter I can do that? Or is the purpose of this question to generate a sum of the multiplication of each digit with 10^n padded behind? In that case, can I cast to int and multiply that single digit? Or am I supposed to create a matrix of single digit multiplication results and use that as a hashmap lookup?\\n\\nThis question is so vague it\\'s dumb."
                    },
                    {
                        "username": "neolancer",
                        "content": "This is a good question BUT the submission test cases must ensure that BigNumber-like conversion will not suffice. Otherwise proper solutions, like linked-list etc., will be disappointingly left in the tail"
                    },
                    {
                        "username": "kzo",
                        "content": "[@user3571Rr](/user3571Rr) Doesn\\'t work in Python with it\\'s unlimited precision"
                    },
                    {
                        "username": "spicedNoodle",
                        "content": "[@user3571Rr](/user3571Rr) uint64 can handle super log numbers in most langs. in the TS version i just used BigInt and thats it. i agree with this guys. this is a \"medium\" question. how in the hell is this medium?\\n\\ndont get me wrong, i see your point and i also agree with you. Basic understanding of dataTypes is super important. but medium? this should be a beginner / easy question. Any CS major in his first or second semester should be able to solve this given a few minutes. "
                    },
                    {
                        "username": "robotburrito",
                        "content": "In the real world if you didn\\'t write that 1 line that beats 98% of all other submissions when given this problem you\\'d probably be fired lol."
                    },
                    {
                        "username": "user3571Rr",
                        "content": "Not quite - some of the tests use seriously long number sequences, meaning that none of the conversion to Integer, Long, BigInteger or BigDecimal would actually work because of overflow.\\nIt seems to me that the only way is to carry out multiplications one at a time (as we one was doing it by hand), organise them in columns and produce text from the result, in sequence, while also taking care of rollover values."
                    },
                    {
                        "username": "juicebox2",
                        "content": "Pretty silly question. I feel it teaches devs to try to find complex solutions to simple problems. Why wouldn\\'t we leverage the basic functionality of a language and convert the strings to integer?\\n"
                    },
                    {
                        "username": "Husoski",
                        "content": "More to the point, *someone* has to write code for things like Python unlimited integers or the java.math.BigInteger class.  This is a real programming problem, solved by real programmers, and is more likely to come up in a career (imho) than finding the longest palindrome in a string of a million characters.\\nI\\'m retired, though...old-school with lots of embedded assembly and C...so maybe I\\'m biased by the fact that I\\'ve had to write software multiplication (particularly in assembly) more than once for embedded 8-bit systems."
                    },
                    {
                        "username": "Shikhar_Codes_",
                        "content": "Correct bruh!!"
                    },
                    {
                        "username": "tri_jal",
                        "content": "Listen listen, the reason why they give such questions is to check your problem solving ability. It is not about finding the complex solution, it\\'s about thinking out of the box :)"
                    },
                    {
                        "username": "joshuamahadevan1",
                        "content": "there could be situations where the number can\\'t fit in 64-bit space.. or whatever u decide to use.. numbers expressed  in binary will overflow at some point, and its good to know different ways of processing the same."
                    },
                    {
                        "username": "Krrabs",
                        "content": "For those saying, _why is it a medium? or it should be marked as easy._\n\nIn the question they specifically asked not to use `BigInt` or **convert** the input number **directly.**\n\nThat means in your solution there should never be an instance of `Integer/BigInt` having full value of inputs `num1` and `num2`.\n\nNo one is stopping you from doing that and solving your solution. But then, leaving comments like _\"this is an easy question\"_ you are only making a fool out of yourself."
                    },
                    {
                        "username": "Nakashima",
                        "content": "Do I need to consider the number that is between 0 and 1?"
                    },
                    {
                        "username": "QuazarGuy",
                        "content": "This type of question should be removed so interviewers don\\'t see it and think it\\'s a good question. Implement a tedious and detailed already built-in function that\\'s highly prone to error. I will reject a job if this type of question is asked. Test me on algorithms, not my ability to detect potential off-by-one errors."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for November, Day 7.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/multiply-strings/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Elementary Math\n\n  \n**Approach 2:** Elementary math using less intermediate space\n\n  \n**Approach 3:** Sum the products from all pairs of digits\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "sri_datta",
                        "content": "how does this have so many likes?"
                    },
                    {
                        "username": "nop_nop",
                        "content": "Consider \"123\" and \"456\"\\nMultiply \"6\"(of 456) with \"3\"(of 123) and keep track of this total sum, for next \"6\"(of 456)  with \"2\"(of 123) , but here we need to multiply the product by 10^1 as we do need to account for \"2\"(123) being in tens place and similarly we do it for everything and keep adding the sum.\\n![image](https://assets.leetcode.com/users/nop_nop/image_1547686032.png)\\n\\nBelow is the code:\\n![image](https://assets.leetcode.com/users/nop_nop/image_1547686217.png)\\n"
                    },
                    {
                        "username": "srivastavasameer2002",
                        "content": "what is variable type of total_sum? "
                    },
                    {
                        "username": "healqq",
                        "content": "good explanation, but code doesn\\'t follow the order of the image (as far as I can tell). As you\\'ll get 3 * 6 (i = 0, j = 0) => 3 * 5 (i = 0; j = 1) => 3*4 (i = 0; j = 2) and so on. Doesn\\'t change the result of course, but maybe makes sense to swap the loops around"
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "`n1 = ord(n1) - ord(\\'0\\')` why use ordinals?"
                    },
                    {
                        "username": "Raviteja525",
                        "content": "return str(eval(num1+\\'*\\'+num2))"
                    },
                    {
                        "username": "Sanjeet-Kumar",
                        "content": "![alt text](image url)![0_1497347622870_string.jpg](/assets/uploads/files/1497347627240-string-resized.jpg) \\nGuys As i have found most difficulties to understand the problem.Here From the above picture we can see that the product of ith and jth number will be stroed in position i+j and i+j+1, \\ni.e., res[i+j] is used to store the carry value and res[i+j+1] is used to rightmost digit of the sum.\\n![0_1497347660069_Screenshot (99).png](/assets/uploads/files/1497347665657-screenshot-99.png) \\nI hope it will help you."
                    }
                ]
            },
            {
                "id": 1572175,
                "content": [
                    {
                        "username": "bcronrath",
                        "content": "Honestly I don\\'t understand why these type of questions exist.  They should be removed, or leetcode should at least build in a way to have validation rules such as checking that variables aren\\'t converted to integers.  Look at all the top runtime submissions for this one, literally they are one line where they just convert the strings to integers and multiply them, it\\'s a joke."
                    },
                    {
                        "username": "Husoski",
                        "content": "[@Moonbeam8773](/Moonbeam8773) \\nIt\\'s not vague at all.  The goal is clearly to write the multiplication code yourself.  It\\'s just grade-school arithmetic, after all.  "
                    },
                    {
                        "username": "RedLeader",
                        "content": "Agreed, questions like this are pretty terrible and hacky in nature.  "
                    },
                    {
                        "username": "Moonbeam8773",
                        "content": "It says not to directly convert to int. Does that mean that if I wrote my own int converter I can do that? Or is the purpose of this question to generate a sum of the multiplication of each digit with 10^n padded behind? In that case, can I cast to int and multiply that single digit? Or am I supposed to create a matrix of single digit multiplication results and use that as a hashmap lookup?\\n\\nThis question is so vague it\\'s dumb."
                    },
                    {
                        "username": "neolancer",
                        "content": "This is a good question BUT the submission test cases must ensure that BigNumber-like conversion will not suffice. Otherwise proper solutions, like linked-list etc., will be disappointingly left in the tail"
                    },
                    {
                        "username": "kzo",
                        "content": "[@user3571Rr](/user3571Rr) Doesn\\'t work in Python with it\\'s unlimited precision"
                    },
                    {
                        "username": "spicedNoodle",
                        "content": "[@user3571Rr](/user3571Rr) uint64 can handle super log numbers in most langs. in the TS version i just used BigInt and thats it. i agree with this guys. this is a \"medium\" question. how in the hell is this medium?\\n\\ndont get me wrong, i see your point and i also agree with you. Basic understanding of dataTypes is super important. but medium? this should be a beginner / easy question. Any CS major in his first or second semester should be able to solve this given a few minutes. "
                    },
                    {
                        "username": "robotburrito",
                        "content": "In the real world if you didn\\'t write that 1 line that beats 98% of all other submissions when given this problem you\\'d probably be fired lol."
                    },
                    {
                        "username": "user3571Rr",
                        "content": "Not quite - some of the tests use seriously long number sequences, meaning that none of the conversion to Integer, Long, BigInteger or BigDecimal would actually work because of overflow.\\nIt seems to me that the only way is to carry out multiplications one at a time (as we one was doing it by hand), organise them in columns and produce text from the result, in sequence, while also taking care of rollover values."
                    },
                    {
                        "username": "juicebox2",
                        "content": "Pretty silly question. I feel it teaches devs to try to find complex solutions to simple problems. Why wouldn\\'t we leverage the basic functionality of a language and convert the strings to integer?\\n"
                    },
                    {
                        "username": "Husoski",
                        "content": "More to the point, *someone* has to write code for things like Python unlimited integers or the java.math.BigInteger class.  This is a real programming problem, solved by real programmers, and is more likely to come up in a career (imho) than finding the longest palindrome in a string of a million characters.\\nI\\'m retired, though...old-school with lots of embedded assembly and C...so maybe I\\'m biased by the fact that I\\'ve had to write software multiplication (particularly in assembly) more than once for embedded 8-bit systems."
                    },
                    {
                        "username": "Shikhar_Codes_",
                        "content": "Correct bruh!!"
                    },
                    {
                        "username": "tri_jal",
                        "content": "Listen listen, the reason why they give such questions is to check your problem solving ability. It is not about finding the complex solution, it\\'s about thinking out of the box :)"
                    },
                    {
                        "username": "joshuamahadevan1",
                        "content": "there could be situations where the number can\\'t fit in 64-bit space.. or whatever u decide to use.. numbers expressed  in binary will overflow at some point, and its good to know different ways of processing the same."
                    },
                    {
                        "username": "Krrabs",
                        "content": "For those saying, _why is it a medium? or it should be marked as easy._\n\nIn the question they specifically asked not to use `BigInt` or **convert** the input number **directly.**\n\nThat means in your solution there should never be an instance of `Integer/BigInt` having full value of inputs `num1` and `num2`.\n\nNo one is stopping you from doing that and solving your solution. But then, leaving comments like _\"this is an easy question\"_ you are only making a fool out of yourself."
                    },
                    {
                        "username": "Nakashima",
                        "content": "Do I need to consider the number that is between 0 and 1?"
                    },
                    {
                        "username": "QuazarGuy",
                        "content": "This type of question should be removed so interviewers don\\'t see it and think it\\'s a good question. Implement a tedious and detailed already built-in function that\\'s highly prone to error. I will reject a job if this type of question is asked. Test me on algorithms, not my ability to detect potential off-by-one errors."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for November, Day 7.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/multiply-strings/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Elementary Math\n\n  \n**Approach 2:** Elementary math using less intermediate space\n\n  \n**Approach 3:** Sum the products from all pairs of digits\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "sri_datta",
                        "content": "how does this have so many likes?"
                    },
                    {
                        "username": "nop_nop",
                        "content": "Consider \"123\" and \"456\"\\nMultiply \"6\"(of 456) with \"3\"(of 123) and keep track of this total sum, for next \"6\"(of 456)  with \"2\"(of 123) , but here we need to multiply the product by 10^1 as we do need to account for \"2\"(123) being in tens place and similarly we do it for everything and keep adding the sum.\\n![image](https://assets.leetcode.com/users/nop_nop/image_1547686032.png)\\n\\nBelow is the code:\\n![image](https://assets.leetcode.com/users/nop_nop/image_1547686217.png)\\n"
                    },
                    {
                        "username": "srivastavasameer2002",
                        "content": "what is variable type of total_sum? "
                    },
                    {
                        "username": "healqq",
                        "content": "good explanation, but code doesn\\'t follow the order of the image (as far as I can tell). As you\\'ll get 3 * 6 (i = 0, j = 0) => 3 * 5 (i = 0; j = 1) => 3*4 (i = 0; j = 2) and so on. Doesn\\'t change the result of course, but maybe makes sense to swap the loops around"
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "`n1 = ord(n1) - ord(\\'0\\')` why use ordinals?"
                    },
                    {
                        "username": "Raviteja525",
                        "content": "return str(eval(num1+\\'*\\'+num2))"
                    },
                    {
                        "username": "Sanjeet-Kumar",
                        "content": "![alt text](image url)![0_1497347622870_string.jpg](/assets/uploads/files/1497347627240-string-resized.jpg) \\nGuys As i have found most difficulties to understand the problem.Here From the above picture we can see that the product of ith and jth number will be stroed in position i+j and i+j+1, \\ni.e., res[i+j] is used to store the carry value and res[i+j+1] is used to rightmost digit of the sum.\\n![0_1497347660069_Screenshot (99).png](/assets/uploads/files/1497347665657-screenshot-99.png) \\nI hope it will help you."
                    }
                ]
            },
            {
                "id": 1671331,
                "content": [
                    {
                        "username": "bcronrath",
                        "content": "Honestly I don\\'t understand why these type of questions exist.  They should be removed, or leetcode should at least build in a way to have validation rules such as checking that variables aren\\'t converted to integers.  Look at all the top runtime submissions for this one, literally they are one line where they just convert the strings to integers and multiply them, it\\'s a joke."
                    },
                    {
                        "username": "Husoski",
                        "content": "[@Moonbeam8773](/Moonbeam8773) \\nIt\\'s not vague at all.  The goal is clearly to write the multiplication code yourself.  It\\'s just grade-school arithmetic, after all.  "
                    },
                    {
                        "username": "RedLeader",
                        "content": "Agreed, questions like this are pretty terrible and hacky in nature.  "
                    },
                    {
                        "username": "Moonbeam8773",
                        "content": "It says not to directly convert to int. Does that mean that if I wrote my own int converter I can do that? Or is the purpose of this question to generate a sum of the multiplication of each digit with 10^n padded behind? In that case, can I cast to int and multiply that single digit? Or am I supposed to create a matrix of single digit multiplication results and use that as a hashmap lookup?\\n\\nThis question is so vague it\\'s dumb."
                    },
                    {
                        "username": "neolancer",
                        "content": "This is a good question BUT the submission test cases must ensure that BigNumber-like conversion will not suffice. Otherwise proper solutions, like linked-list etc., will be disappointingly left in the tail"
                    },
                    {
                        "username": "kzo",
                        "content": "[@user3571Rr](/user3571Rr) Doesn\\'t work in Python with it\\'s unlimited precision"
                    },
                    {
                        "username": "spicedNoodle",
                        "content": "[@user3571Rr](/user3571Rr) uint64 can handle super log numbers in most langs. in the TS version i just used BigInt and thats it. i agree with this guys. this is a \"medium\" question. how in the hell is this medium?\\n\\ndont get me wrong, i see your point and i also agree with you. Basic understanding of dataTypes is super important. but medium? this should be a beginner / easy question. Any CS major in his first or second semester should be able to solve this given a few minutes. "
                    },
                    {
                        "username": "robotburrito",
                        "content": "In the real world if you didn\\'t write that 1 line that beats 98% of all other submissions when given this problem you\\'d probably be fired lol."
                    },
                    {
                        "username": "user3571Rr",
                        "content": "Not quite - some of the tests use seriously long number sequences, meaning that none of the conversion to Integer, Long, BigInteger or BigDecimal would actually work because of overflow.\\nIt seems to me that the only way is to carry out multiplications one at a time (as we one was doing it by hand), organise them in columns and produce text from the result, in sequence, while also taking care of rollover values."
                    },
                    {
                        "username": "juicebox2",
                        "content": "Pretty silly question. I feel it teaches devs to try to find complex solutions to simple problems. Why wouldn\\'t we leverage the basic functionality of a language and convert the strings to integer?\\n"
                    },
                    {
                        "username": "Husoski",
                        "content": "More to the point, *someone* has to write code for things like Python unlimited integers or the java.math.BigInteger class.  This is a real programming problem, solved by real programmers, and is more likely to come up in a career (imho) than finding the longest palindrome in a string of a million characters.\\nI\\'m retired, though...old-school with lots of embedded assembly and C...so maybe I\\'m biased by the fact that I\\'ve had to write software multiplication (particularly in assembly) more than once for embedded 8-bit systems."
                    },
                    {
                        "username": "Shikhar_Codes_",
                        "content": "Correct bruh!!"
                    },
                    {
                        "username": "tri_jal",
                        "content": "Listen listen, the reason why they give such questions is to check your problem solving ability. It is not about finding the complex solution, it\\'s about thinking out of the box :)"
                    },
                    {
                        "username": "joshuamahadevan1",
                        "content": "there could be situations where the number can\\'t fit in 64-bit space.. or whatever u decide to use.. numbers expressed  in binary will overflow at some point, and its good to know different ways of processing the same."
                    },
                    {
                        "username": "Krrabs",
                        "content": "For those saying, _why is it a medium? or it should be marked as easy._\n\nIn the question they specifically asked not to use `BigInt` or **convert** the input number **directly.**\n\nThat means in your solution there should never be an instance of `Integer/BigInt` having full value of inputs `num1` and `num2`.\n\nNo one is stopping you from doing that and solving your solution. But then, leaving comments like _\"this is an easy question\"_ you are only making a fool out of yourself."
                    },
                    {
                        "username": "Nakashima",
                        "content": "Do I need to consider the number that is between 0 and 1?"
                    },
                    {
                        "username": "QuazarGuy",
                        "content": "This type of question should be removed so interviewers don\\'t see it and think it\\'s a good question. Implement a tedious and detailed already built-in function that\\'s highly prone to error. I will reject a job if this type of question is asked. Test me on algorithms, not my ability to detect potential off-by-one errors."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for November, Day 7.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/multiply-strings/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Elementary Math\n\n  \n**Approach 2:** Elementary math using less intermediate space\n\n  \n**Approach 3:** Sum the products from all pairs of digits\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "sri_datta",
                        "content": "how does this have so many likes?"
                    },
                    {
                        "username": "nop_nop",
                        "content": "Consider \"123\" and \"456\"\\nMultiply \"6\"(of 456) with \"3\"(of 123) and keep track of this total sum, for next \"6\"(of 456)  with \"2\"(of 123) , but here we need to multiply the product by 10^1 as we do need to account for \"2\"(123) being in tens place and similarly we do it for everything and keep adding the sum.\\n![image](https://assets.leetcode.com/users/nop_nop/image_1547686032.png)\\n\\nBelow is the code:\\n![image](https://assets.leetcode.com/users/nop_nop/image_1547686217.png)\\n"
                    },
                    {
                        "username": "srivastavasameer2002",
                        "content": "what is variable type of total_sum? "
                    },
                    {
                        "username": "healqq",
                        "content": "good explanation, but code doesn\\'t follow the order of the image (as far as I can tell). As you\\'ll get 3 * 6 (i = 0, j = 0) => 3 * 5 (i = 0; j = 1) => 3*4 (i = 0; j = 2) and so on. Doesn\\'t change the result of course, but maybe makes sense to swap the loops around"
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "`n1 = ord(n1) - ord(\\'0\\')` why use ordinals?"
                    },
                    {
                        "username": "Raviteja525",
                        "content": "return str(eval(num1+\\'*\\'+num2))"
                    },
                    {
                        "username": "Sanjeet-Kumar",
                        "content": "![alt text](image url)![0_1497347622870_string.jpg](/assets/uploads/files/1497347627240-string-resized.jpg) \\nGuys As i have found most difficulties to understand the problem.Here From the above picture we can see that the product of ith and jth number will be stroed in position i+j and i+j+1, \\ni.e., res[i+j] is used to store the carry value and res[i+j+1] is used to rightmost digit of the sum.\\n![0_1497347660069_Screenshot (99).png](/assets/uploads/files/1497347665657-screenshot-99.png) \\nI hope it will help you."
                    }
                ]
            },
            {
                "id": 1869576,
                "content": [
                    {
                        "username": "bcronrath",
                        "content": "Honestly I don\\'t understand why these type of questions exist.  They should be removed, or leetcode should at least build in a way to have validation rules such as checking that variables aren\\'t converted to integers.  Look at all the top runtime submissions for this one, literally they are one line where they just convert the strings to integers and multiply them, it\\'s a joke."
                    },
                    {
                        "username": "Husoski",
                        "content": "[@Moonbeam8773](/Moonbeam8773) \\nIt\\'s not vague at all.  The goal is clearly to write the multiplication code yourself.  It\\'s just grade-school arithmetic, after all.  "
                    },
                    {
                        "username": "RedLeader",
                        "content": "Agreed, questions like this are pretty terrible and hacky in nature.  "
                    },
                    {
                        "username": "Moonbeam8773",
                        "content": "It says not to directly convert to int. Does that mean that if I wrote my own int converter I can do that? Or is the purpose of this question to generate a sum of the multiplication of each digit with 10^n padded behind? In that case, can I cast to int and multiply that single digit? Or am I supposed to create a matrix of single digit multiplication results and use that as a hashmap lookup?\\n\\nThis question is so vague it\\'s dumb."
                    },
                    {
                        "username": "neolancer",
                        "content": "This is a good question BUT the submission test cases must ensure that BigNumber-like conversion will not suffice. Otherwise proper solutions, like linked-list etc., will be disappointingly left in the tail"
                    },
                    {
                        "username": "kzo",
                        "content": "[@user3571Rr](/user3571Rr) Doesn\\'t work in Python with it\\'s unlimited precision"
                    },
                    {
                        "username": "spicedNoodle",
                        "content": "[@user3571Rr](/user3571Rr) uint64 can handle super log numbers in most langs. in the TS version i just used BigInt and thats it. i agree with this guys. this is a \"medium\" question. how in the hell is this medium?\\n\\ndont get me wrong, i see your point and i also agree with you. Basic understanding of dataTypes is super important. but medium? this should be a beginner / easy question. Any CS major in his first or second semester should be able to solve this given a few minutes. "
                    },
                    {
                        "username": "robotburrito",
                        "content": "In the real world if you didn\\'t write that 1 line that beats 98% of all other submissions when given this problem you\\'d probably be fired lol."
                    },
                    {
                        "username": "user3571Rr",
                        "content": "Not quite - some of the tests use seriously long number sequences, meaning that none of the conversion to Integer, Long, BigInteger or BigDecimal would actually work because of overflow.\\nIt seems to me that the only way is to carry out multiplications one at a time (as we one was doing it by hand), organise them in columns and produce text from the result, in sequence, while also taking care of rollover values."
                    },
                    {
                        "username": "juicebox2",
                        "content": "Pretty silly question. I feel it teaches devs to try to find complex solutions to simple problems. Why wouldn\\'t we leverage the basic functionality of a language and convert the strings to integer?\\n"
                    },
                    {
                        "username": "Husoski",
                        "content": "More to the point, *someone* has to write code for things like Python unlimited integers or the java.math.BigInteger class.  This is a real programming problem, solved by real programmers, and is more likely to come up in a career (imho) than finding the longest palindrome in a string of a million characters.\\nI\\'m retired, though...old-school with lots of embedded assembly and C...so maybe I\\'m biased by the fact that I\\'ve had to write software multiplication (particularly in assembly) more than once for embedded 8-bit systems."
                    },
                    {
                        "username": "Shikhar_Codes_",
                        "content": "Correct bruh!!"
                    },
                    {
                        "username": "tri_jal",
                        "content": "Listen listen, the reason why they give such questions is to check your problem solving ability. It is not about finding the complex solution, it\\'s about thinking out of the box :)"
                    },
                    {
                        "username": "joshuamahadevan1",
                        "content": "there could be situations where the number can\\'t fit in 64-bit space.. or whatever u decide to use.. numbers expressed  in binary will overflow at some point, and its good to know different ways of processing the same."
                    },
                    {
                        "username": "Krrabs",
                        "content": "For those saying, _why is it a medium? or it should be marked as easy._\n\nIn the question they specifically asked not to use `BigInt` or **convert** the input number **directly.**\n\nThat means in your solution there should never be an instance of `Integer/BigInt` having full value of inputs `num1` and `num2`.\n\nNo one is stopping you from doing that and solving your solution. But then, leaving comments like _\"this is an easy question\"_ you are only making a fool out of yourself."
                    },
                    {
                        "username": "Nakashima",
                        "content": "Do I need to consider the number that is between 0 and 1?"
                    },
                    {
                        "username": "QuazarGuy",
                        "content": "This type of question should be removed so interviewers don\\'t see it and think it\\'s a good question. Implement a tedious and detailed already built-in function that\\'s highly prone to error. I will reject a job if this type of question is asked. Test me on algorithms, not my ability to detect potential off-by-one errors."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for November, Day 7.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/multiply-strings/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Elementary Math\n\n  \n**Approach 2:** Elementary math using less intermediate space\n\n  \n**Approach 3:** Sum the products from all pairs of digits\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "sri_datta",
                        "content": "how does this have so many likes?"
                    },
                    {
                        "username": "nop_nop",
                        "content": "Consider \"123\" and \"456\"\\nMultiply \"6\"(of 456) with \"3\"(of 123) and keep track of this total sum, for next \"6\"(of 456)  with \"2\"(of 123) , but here we need to multiply the product by 10^1 as we do need to account for \"2\"(123) being in tens place and similarly we do it for everything and keep adding the sum.\\n![image](https://assets.leetcode.com/users/nop_nop/image_1547686032.png)\\n\\nBelow is the code:\\n![image](https://assets.leetcode.com/users/nop_nop/image_1547686217.png)\\n"
                    },
                    {
                        "username": "srivastavasameer2002",
                        "content": "what is variable type of total_sum? "
                    },
                    {
                        "username": "healqq",
                        "content": "good explanation, but code doesn\\'t follow the order of the image (as far as I can tell). As you\\'ll get 3 * 6 (i = 0, j = 0) => 3 * 5 (i = 0; j = 1) => 3*4 (i = 0; j = 2) and so on. Doesn\\'t change the result of course, but maybe makes sense to swap the loops around"
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "`n1 = ord(n1) - ord(\\'0\\')` why use ordinals?"
                    },
                    {
                        "username": "Raviteja525",
                        "content": "return str(eval(num1+\\'*\\'+num2))"
                    },
                    {
                        "username": "Sanjeet-Kumar",
                        "content": "![alt text](image url)![0_1497347622870_string.jpg](/assets/uploads/files/1497347627240-string-resized.jpg) \\nGuys As i have found most difficulties to understand the problem.Here From the above picture we can see that the product of ith and jth number will be stroed in position i+j and i+j+1, \\ni.e., res[i+j] is used to store the carry value and res[i+j+1] is used to rightmost digit of the sum.\\n![0_1497347660069_Screenshot (99).png](/assets/uploads/files/1497347665657-screenshot-99.png) \\nI hope it will help you."
                    }
                ]
            },
            {
                "id": 1565737,
                "content": [
                    {
                        "username": "bcronrath",
                        "content": "Honestly I don\\'t understand why these type of questions exist.  They should be removed, or leetcode should at least build in a way to have validation rules such as checking that variables aren\\'t converted to integers.  Look at all the top runtime submissions for this one, literally they are one line where they just convert the strings to integers and multiply them, it\\'s a joke."
                    },
                    {
                        "username": "Husoski",
                        "content": "[@Moonbeam8773](/Moonbeam8773) \\nIt\\'s not vague at all.  The goal is clearly to write the multiplication code yourself.  It\\'s just grade-school arithmetic, after all.  "
                    },
                    {
                        "username": "RedLeader",
                        "content": "Agreed, questions like this are pretty terrible and hacky in nature.  "
                    },
                    {
                        "username": "Moonbeam8773",
                        "content": "It says not to directly convert to int. Does that mean that if I wrote my own int converter I can do that? Or is the purpose of this question to generate a sum of the multiplication of each digit with 10^n padded behind? In that case, can I cast to int and multiply that single digit? Or am I supposed to create a matrix of single digit multiplication results and use that as a hashmap lookup?\\n\\nThis question is so vague it\\'s dumb."
                    },
                    {
                        "username": "neolancer",
                        "content": "This is a good question BUT the submission test cases must ensure that BigNumber-like conversion will not suffice. Otherwise proper solutions, like linked-list etc., will be disappointingly left in the tail"
                    },
                    {
                        "username": "kzo",
                        "content": "[@user3571Rr](/user3571Rr) Doesn\\'t work in Python with it\\'s unlimited precision"
                    },
                    {
                        "username": "spicedNoodle",
                        "content": "[@user3571Rr](/user3571Rr) uint64 can handle super log numbers in most langs. in the TS version i just used BigInt and thats it. i agree with this guys. this is a \"medium\" question. how in the hell is this medium?\\n\\ndont get me wrong, i see your point and i also agree with you. Basic understanding of dataTypes is super important. but medium? this should be a beginner / easy question. Any CS major in his first or second semester should be able to solve this given a few minutes. "
                    },
                    {
                        "username": "robotburrito",
                        "content": "In the real world if you didn\\'t write that 1 line that beats 98% of all other submissions when given this problem you\\'d probably be fired lol."
                    },
                    {
                        "username": "user3571Rr",
                        "content": "Not quite - some of the tests use seriously long number sequences, meaning that none of the conversion to Integer, Long, BigInteger or BigDecimal would actually work because of overflow.\\nIt seems to me that the only way is to carry out multiplications one at a time (as we one was doing it by hand), organise them in columns and produce text from the result, in sequence, while also taking care of rollover values."
                    },
                    {
                        "username": "juicebox2",
                        "content": "Pretty silly question. I feel it teaches devs to try to find complex solutions to simple problems. Why wouldn\\'t we leverage the basic functionality of a language and convert the strings to integer?\\n"
                    },
                    {
                        "username": "Husoski",
                        "content": "More to the point, *someone* has to write code for things like Python unlimited integers or the java.math.BigInteger class.  This is a real programming problem, solved by real programmers, and is more likely to come up in a career (imho) than finding the longest palindrome in a string of a million characters.\\nI\\'m retired, though...old-school with lots of embedded assembly and C...so maybe I\\'m biased by the fact that I\\'ve had to write software multiplication (particularly in assembly) more than once for embedded 8-bit systems."
                    },
                    {
                        "username": "Shikhar_Codes_",
                        "content": "Correct bruh!!"
                    },
                    {
                        "username": "tri_jal",
                        "content": "Listen listen, the reason why they give such questions is to check your problem solving ability. It is not about finding the complex solution, it\\'s about thinking out of the box :)"
                    },
                    {
                        "username": "joshuamahadevan1",
                        "content": "there could be situations where the number can\\'t fit in 64-bit space.. or whatever u decide to use.. numbers expressed  in binary will overflow at some point, and its good to know different ways of processing the same."
                    },
                    {
                        "username": "Krrabs",
                        "content": "For those saying, _why is it a medium? or it should be marked as easy._\n\nIn the question they specifically asked not to use `BigInt` or **convert** the input number **directly.**\n\nThat means in your solution there should never be an instance of `Integer/BigInt` having full value of inputs `num1` and `num2`.\n\nNo one is stopping you from doing that and solving your solution. But then, leaving comments like _\"this is an easy question\"_ you are only making a fool out of yourself."
                    },
                    {
                        "username": "Nakashima",
                        "content": "Do I need to consider the number that is between 0 and 1?"
                    },
                    {
                        "username": "QuazarGuy",
                        "content": "This type of question should be removed so interviewers don\\'t see it and think it\\'s a good question. Implement a tedious and detailed already built-in function that\\'s highly prone to error. I will reject a job if this type of question is asked. Test me on algorithms, not my ability to detect potential off-by-one errors."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for November, Day 7.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/multiply-strings/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Elementary Math\n\n  \n**Approach 2:** Elementary math using less intermediate space\n\n  \n**Approach 3:** Sum the products from all pairs of digits\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "sri_datta",
                        "content": "how does this have so many likes?"
                    },
                    {
                        "username": "nop_nop",
                        "content": "Consider \"123\" and \"456\"\\nMultiply \"6\"(of 456) with \"3\"(of 123) and keep track of this total sum, for next \"6\"(of 456)  with \"2\"(of 123) , but here we need to multiply the product by 10^1 as we do need to account for \"2\"(123) being in tens place and similarly we do it for everything and keep adding the sum.\\n![image](https://assets.leetcode.com/users/nop_nop/image_1547686032.png)\\n\\nBelow is the code:\\n![image](https://assets.leetcode.com/users/nop_nop/image_1547686217.png)\\n"
                    },
                    {
                        "username": "srivastavasameer2002",
                        "content": "what is variable type of total_sum? "
                    },
                    {
                        "username": "healqq",
                        "content": "good explanation, but code doesn\\'t follow the order of the image (as far as I can tell). As you\\'ll get 3 * 6 (i = 0, j = 0) => 3 * 5 (i = 0; j = 1) => 3*4 (i = 0; j = 2) and so on. Doesn\\'t change the result of course, but maybe makes sense to swap the loops around"
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "`n1 = ord(n1) - ord(\\'0\\')` why use ordinals?"
                    },
                    {
                        "username": "Raviteja525",
                        "content": "return str(eval(num1+\\'*\\'+num2))"
                    },
                    {
                        "username": "Sanjeet-Kumar",
                        "content": "![alt text](image url)![0_1497347622870_string.jpg](/assets/uploads/files/1497347627240-string-resized.jpg) \\nGuys As i have found most difficulties to understand the problem.Here From the above picture we can see that the product of ith and jth number will be stroed in position i+j and i+j+1, \\ni.e., res[i+j] is used to store the carry value and res[i+j+1] is used to rightmost digit of the sum.\\n![0_1497347660069_Screenshot (99).png](/assets/uploads/files/1497347665657-screenshot-99.png) \\nI hope it will help you."
                    }
                ]
            },
            {
                "id": 1756571,
                "content": [
                    {
                        "username": "bcronrath",
                        "content": "Honestly I don\\'t understand why these type of questions exist.  They should be removed, or leetcode should at least build in a way to have validation rules such as checking that variables aren\\'t converted to integers.  Look at all the top runtime submissions for this one, literally they are one line where they just convert the strings to integers and multiply them, it\\'s a joke."
                    },
                    {
                        "username": "Husoski",
                        "content": "[@Moonbeam8773](/Moonbeam8773) \\nIt\\'s not vague at all.  The goal is clearly to write the multiplication code yourself.  It\\'s just grade-school arithmetic, after all.  "
                    },
                    {
                        "username": "RedLeader",
                        "content": "Agreed, questions like this are pretty terrible and hacky in nature.  "
                    },
                    {
                        "username": "Moonbeam8773",
                        "content": "It says not to directly convert to int. Does that mean that if I wrote my own int converter I can do that? Or is the purpose of this question to generate a sum of the multiplication of each digit with 10^n padded behind? In that case, can I cast to int and multiply that single digit? Or am I supposed to create a matrix of single digit multiplication results and use that as a hashmap lookup?\\n\\nThis question is so vague it\\'s dumb."
                    },
                    {
                        "username": "neolancer",
                        "content": "This is a good question BUT the submission test cases must ensure that BigNumber-like conversion will not suffice. Otherwise proper solutions, like linked-list etc., will be disappointingly left in the tail"
                    },
                    {
                        "username": "kzo",
                        "content": "[@user3571Rr](/user3571Rr) Doesn\\'t work in Python with it\\'s unlimited precision"
                    },
                    {
                        "username": "spicedNoodle",
                        "content": "[@user3571Rr](/user3571Rr) uint64 can handle super log numbers in most langs. in the TS version i just used BigInt and thats it. i agree with this guys. this is a \"medium\" question. how in the hell is this medium?\\n\\ndont get me wrong, i see your point and i also agree with you. Basic understanding of dataTypes is super important. but medium? this should be a beginner / easy question. Any CS major in his first or second semester should be able to solve this given a few minutes. "
                    },
                    {
                        "username": "robotburrito",
                        "content": "In the real world if you didn\\'t write that 1 line that beats 98% of all other submissions when given this problem you\\'d probably be fired lol."
                    },
                    {
                        "username": "user3571Rr",
                        "content": "Not quite - some of the tests use seriously long number sequences, meaning that none of the conversion to Integer, Long, BigInteger or BigDecimal would actually work because of overflow.\\nIt seems to me that the only way is to carry out multiplications one at a time (as we one was doing it by hand), organise them in columns and produce text from the result, in sequence, while also taking care of rollover values."
                    },
                    {
                        "username": "juicebox2",
                        "content": "Pretty silly question. I feel it teaches devs to try to find complex solutions to simple problems. Why wouldn\\'t we leverage the basic functionality of a language and convert the strings to integer?\\n"
                    },
                    {
                        "username": "Husoski",
                        "content": "More to the point, *someone* has to write code for things like Python unlimited integers or the java.math.BigInteger class.  This is a real programming problem, solved by real programmers, and is more likely to come up in a career (imho) than finding the longest palindrome in a string of a million characters.\\nI\\'m retired, though...old-school with lots of embedded assembly and C...so maybe I\\'m biased by the fact that I\\'ve had to write software multiplication (particularly in assembly) more than once for embedded 8-bit systems."
                    },
                    {
                        "username": "Shikhar_Codes_",
                        "content": "Correct bruh!!"
                    },
                    {
                        "username": "tri_jal",
                        "content": "Listen listen, the reason why they give such questions is to check your problem solving ability. It is not about finding the complex solution, it\\'s about thinking out of the box :)"
                    },
                    {
                        "username": "joshuamahadevan1",
                        "content": "there could be situations where the number can\\'t fit in 64-bit space.. or whatever u decide to use.. numbers expressed  in binary will overflow at some point, and its good to know different ways of processing the same."
                    },
                    {
                        "username": "Krrabs",
                        "content": "For those saying, _why is it a medium? or it should be marked as easy._\n\nIn the question they specifically asked not to use `BigInt` or **convert** the input number **directly.**\n\nThat means in your solution there should never be an instance of `Integer/BigInt` having full value of inputs `num1` and `num2`.\n\nNo one is stopping you from doing that and solving your solution. But then, leaving comments like _\"this is an easy question\"_ you are only making a fool out of yourself."
                    },
                    {
                        "username": "Nakashima",
                        "content": "Do I need to consider the number that is between 0 and 1?"
                    },
                    {
                        "username": "QuazarGuy",
                        "content": "This type of question should be removed so interviewers don\\'t see it and think it\\'s a good question. Implement a tedious and detailed already built-in function that\\'s highly prone to error. I will reject a job if this type of question is asked. Test me on algorithms, not my ability to detect potential off-by-one errors."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for November, Day 7.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/multiply-strings/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Elementary Math\n\n  \n**Approach 2:** Elementary math using less intermediate space\n\n  \n**Approach 3:** Sum the products from all pairs of digits\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "sri_datta",
                        "content": "how does this have so many likes?"
                    },
                    {
                        "username": "nop_nop",
                        "content": "Consider \"123\" and \"456\"\\nMultiply \"6\"(of 456) with \"3\"(of 123) and keep track of this total sum, for next \"6\"(of 456)  with \"2\"(of 123) , but here we need to multiply the product by 10^1 as we do need to account for \"2\"(123) being in tens place and similarly we do it for everything and keep adding the sum.\\n![image](https://assets.leetcode.com/users/nop_nop/image_1547686032.png)\\n\\nBelow is the code:\\n![image](https://assets.leetcode.com/users/nop_nop/image_1547686217.png)\\n"
                    },
                    {
                        "username": "srivastavasameer2002",
                        "content": "what is variable type of total_sum? "
                    },
                    {
                        "username": "healqq",
                        "content": "good explanation, but code doesn\\'t follow the order of the image (as far as I can tell). As you\\'ll get 3 * 6 (i = 0, j = 0) => 3 * 5 (i = 0; j = 1) => 3*4 (i = 0; j = 2) and so on. Doesn\\'t change the result of course, but maybe makes sense to swap the loops around"
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "`n1 = ord(n1) - ord(\\'0\\')` why use ordinals?"
                    },
                    {
                        "username": "Raviteja525",
                        "content": "return str(eval(num1+\\'*\\'+num2))"
                    },
                    {
                        "username": "Sanjeet-Kumar",
                        "content": "![alt text](image url)![0_1497347622870_string.jpg](/assets/uploads/files/1497347627240-string-resized.jpg) \\nGuys As i have found most difficulties to understand the problem.Here From the above picture we can see that the product of ith and jth number will be stroed in position i+j and i+j+1, \\ni.e., res[i+j] is used to store the carry value and res[i+j+1] is used to rightmost digit of the sum.\\n![0_1497347660069_Screenshot (99).png](/assets/uploads/files/1497347665657-screenshot-99.png) \\nI hope it will help you."
                    }
                ]
            },
            {
                "id": 1565177,
                "content": [
                    {
                        "username": "bcronrath",
                        "content": "Honestly I don\\'t understand why these type of questions exist.  They should be removed, or leetcode should at least build in a way to have validation rules such as checking that variables aren\\'t converted to integers.  Look at all the top runtime submissions for this one, literally they are one line where they just convert the strings to integers and multiply them, it\\'s a joke."
                    },
                    {
                        "username": "Husoski",
                        "content": "[@Moonbeam8773](/Moonbeam8773) \\nIt\\'s not vague at all.  The goal is clearly to write the multiplication code yourself.  It\\'s just grade-school arithmetic, after all.  "
                    },
                    {
                        "username": "RedLeader",
                        "content": "Agreed, questions like this are pretty terrible and hacky in nature.  "
                    },
                    {
                        "username": "Moonbeam8773",
                        "content": "It says not to directly convert to int. Does that mean that if I wrote my own int converter I can do that? Or is the purpose of this question to generate a sum of the multiplication of each digit with 10^n padded behind? In that case, can I cast to int and multiply that single digit? Or am I supposed to create a matrix of single digit multiplication results and use that as a hashmap lookup?\\n\\nThis question is so vague it\\'s dumb."
                    },
                    {
                        "username": "neolancer",
                        "content": "This is a good question BUT the submission test cases must ensure that BigNumber-like conversion will not suffice. Otherwise proper solutions, like linked-list etc., will be disappointingly left in the tail"
                    },
                    {
                        "username": "kzo",
                        "content": "[@user3571Rr](/user3571Rr) Doesn\\'t work in Python with it\\'s unlimited precision"
                    },
                    {
                        "username": "spicedNoodle",
                        "content": "[@user3571Rr](/user3571Rr) uint64 can handle super log numbers in most langs. in the TS version i just used BigInt and thats it. i agree with this guys. this is a \"medium\" question. how in the hell is this medium?\\n\\ndont get me wrong, i see your point and i also agree with you. Basic understanding of dataTypes is super important. but medium? this should be a beginner / easy question. Any CS major in his first or second semester should be able to solve this given a few minutes. "
                    },
                    {
                        "username": "robotburrito",
                        "content": "In the real world if you didn\\'t write that 1 line that beats 98% of all other submissions when given this problem you\\'d probably be fired lol."
                    },
                    {
                        "username": "user3571Rr",
                        "content": "Not quite - some of the tests use seriously long number sequences, meaning that none of the conversion to Integer, Long, BigInteger or BigDecimal would actually work because of overflow.\\nIt seems to me that the only way is to carry out multiplications one at a time (as we one was doing it by hand), organise them in columns and produce text from the result, in sequence, while also taking care of rollover values."
                    },
                    {
                        "username": "juicebox2",
                        "content": "Pretty silly question. I feel it teaches devs to try to find complex solutions to simple problems. Why wouldn\\'t we leverage the basic functionality of a language and convert the strings to integer?\\n"
                    },
                    {
                        "username": "Husoski",
                        "content": "More to the point, *someone* has to write code for things like Python unlimited integers or the java.math.BigInteger class.  This is a real programming problem, solved by real programmers, and is more likely to come up in a career (imho) than finding the longest palindrome in a string of a million characters.\\nI\\'m retired, though...old-school with lots of embedded assembly and C...so maybe I\\'m biased by the fact that I\\'ve had to write software multiplication (particularly in assembly) more than once for embedded 8-bit systems."
                    },
                    {
                        "username": "Shikhar_Codes_",
                        "content": "Correct bruh!!"
                    },
                    {
                        "username": "tri_jal",
                        "content": "Listen listen, the reason why they give such questions is to check your problem solving ability. It is not about finding the complex solution, it\\'s about thinking out of the box :)"
                    },
                    {
                        "username": "joshuamahadevan1",
                        "content": "there could be situations where the number can\\'t fit in 64-bit space.. or whatever u decide to use.. numbers expressed  in binary will overflow at some point, and its good to know different ways of processing the same."
                    },
                    {
                        "username": "Krrabs",
                        "content": "For those saying, _why is it a medium? or it should be marked as easy._\n\nIn the question they specifically asked not to use `BigInt` or **convert** the input number **directly.**\n\nThat means in your solution there should never be an instance of `Integer/BigInt` having full value of inputs `num1` and `num2`.\n\nNo one is stopping you from doing that and solving your solution. But then, leaving comments like _\"this is an easy question\"_ you are only making a fool out of yourself."
                    },
                    {
                        "username": "Nakashima",
                        "content": "Do I need to consider the number that is between 0 and 1?"
                    },
                    {
                        "username": "QuazarGuy",
                        "content": "This type of question should be removed so interviewers don\\'t see it and think it\\'s a good question. Implement a tedious and detailed already built-in function that\\'s highly prone to error. I will reject a job if this type of question is asked. Test me on algorithms, not my ability to detect potential off-by-one errors."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for November, Day 7.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/multiply-strings/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Elementary Math\n\n  \n**Approach 2:** Elementary math using less intermediate space\n\n  \n**Approach 3:** Sum the products from all pairs of digits\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "sri_datta",
                        "content": "how does this have so many likes?"
                    },
                    {
                        "username": "nop_nop",
                        "content": "Consider \"123\" and \"456\"\\nMultiply \"6\"(of 456) with \"3\"(of 123) and keep track of this total sum, for next \"6\"(of 456)  with \"2\"(of 123) , but here we need to multiply the product by 10^1 as we do need to account for \"2\"(123) being in tens place and similarly we do it for everything and keep adding the sum.\\n![image](https://assets.leetcode.com/users/nop_nop/image_1547686032.png)\\n\\nBelow is the code:\\n![image](https://assets.leetcode.com/users/nop_nop/image_1547686217.png)\\n"
                    },
                    {
                        "username": "srivastavasameer2002",
                        "content": "what is variable type of total_sum? "
                    },
                    {
                        "username": "healqq",
                        "content": "good explanation, but code doesn\\'t follow the order of the image (as far as I can tell). As you\\'ll get 3 * 6 (i = 0, j = 0) => 3 * 5 (i = 0; j = 1) => 3*4 (i = 0; j = 2) and so on. Doesn\\'t change the result of course, but maybe makes sense to swap the loops around"
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "`n1 = ord(n1) - ord(\\'0\\')` why use ordinals?"
                    },
                    {
                        "username": "Raviteja525",
                        "content": "return str(eval(num1+\\'*\\'+num2))"
                    },
                    {
                        "username": "Sanjeet-Kumar",
                        "content": "![alt text](image url)![0_1497347622870_string.jpg](/assets/uploads/files/1497347627240-string-resized.jpg) \\nGuys As i have found most difficulties to understand the problem.Here From the above picture we can see that the product of ith and jth number will be stroed in position i+j and i+j+1, \\ni.e., res[i+j] is used to store the carry value and res[i+j+1] is used to rightmost digit of the sum.\\n![0_1497347660069_Screenshot (99).png](/assets/uploads/files/1497347665657-screenshot-99.png) \\nI hope it will help you."
                    }
                ]
            },
            {
                "id": 1789479,
                "content": [
                    {
                        "username": "bcronrath",
                        "content": "Honestly I don\\'t understand why these type of questions exist.  They should be removed, or leetcode should at least build in a way to have validation rules such as checking that variables aren\\'t converted to integers.  Look at all the top runtime submissions for this one, literally they are one line where they just convert the strings to integers and multiply them, it\\'s a joke."
                    },
                    {
                        "username": "Husoski",
                        "content": "[@Moonbeam8773](/Moonbeam8773) \\nIt\\'s not vague at all.  The goal is clearly to write the multiplication code yourself.  It\\'s just grade-school arithmetic, after all.  "
                    },
                    {
                        "username": "RedLeader",
                        "content": "Agreed, questions like this are pretty terrible and hacky in nature.  "
                    },
                    {
                        "username": "Moonbeam8773",
                        "content": "It says not to directly convert to int. Does that mean that if I wrote my own int converter I can do that? Or is the purpose of this question to generate a sum of the multiplication of each digit with 10^n padded behind? In that case, can I cast to int and multiply that single digit? Or am I supposed to create a matrix of single digit multiplication results and use that as a hashmap lookup?\\n\\nThis question is so vague it\\'s dumb."
                    },
                    {
                        "username": "neolancer",
                        "content": "This is a good question BUT the submission test cases must ensure that BigNumber-like conversion will not suffice. Otherwise proper solutions, like linked-list etc., will be disappointingly left in the tail"
                    },
                    {
                        "username": "kzo",
                        "content": "[@user3571Rr](/user3571Rr) Doesn\\'t work in Python with it\\'s unlimited precision"
                    },
                    {
                        "username": "spicedNoodle",
                        "content": "[@user3571Rr](/user3571Rr) uint64 can handle super log numbers in most langs. in the TS version i just used BigInt and thats it. i agree with this guys. this is a \"medium\" question. how in the hell is this medium?\\n\\ndont get me wrong, i see your point and i also agree with you. Basic understanding of dataTypes is super important. but medium? this should be a beginner / easy question. Any CS major in his first or second semester should be able to solve this given a few minutes. "
                    },
                    {
                        "username": "robotburrito",
                        "content": "In the real world if you didn\\'t write that 1 line that beats 98% of all other submissions when given this problem you\\'d probably be fired lol."
                    },
                    {
                        "username": "user3571Rr",
                        "content": "Not quite - some of the tests use seriously long number sequences, meaning that none of the conversion to Integer, Long, BigInteger or BigDecimal would actually work because of overflow.\\nIt seems to me that the only way is to carry out multiplications one at a time (as we one was doing it by hand), organise them in columns and produce text from the result, in sequence, while also taking care of rollover values."
                    },
                    {
                        "username": "juicebox2",
                        "content": "Pretty silly question. I feel it teaches devs to try to find complex solutions to simple problems. Why wouldn\\'t we leverage the basic functionality of a language and convert the strings to integer?\\n"
                    },
                    {
                        "username": "Husoski",
                        "content": "More to the point, *someone* has to write code for things like Python unlimited integers or the java.math.BigInteger class.  This is a real programming problem, solved by real programmers, and is more likely to come up in a career (imho) than finding the longest palindrome in a string of a million characters.\\nI\\'m retired, though...old-school with lots of embedded assembly and C...so maybe I\\'m biased by the fact that I\\'ve had to write software multiplication (particularly in assembly) more than once for embedded 8-bit systems."
                    },
                    {
                        "username": "Shikhar_Codes_",
                        "content": "Correct bruh!!"
                    },
                    {
                        "username": "tri_jal",
                        "content": "Listen listen, the reason why they give such questions is to check your problem solving ability. It is not about finding the complex solution, it\\'s about thinking out of the box :)"
                    },
                    {
                        "username": "joshuamahadevan1",
                        "content": "there could be situations where the number can\\'t fit in 64-bit space.. or whatever u decide to use.. numbers expressed  in binary will overflow at some point, and its good to know different ways of processing the same."
                    },
                    {
                        "username": "Krrabs",
                        "content": "For those saying, _why is it a medium? or it should be marked as easy._\n\nIn the question they specifically asked not to use `BigInt` or **convert** the input number **directly.**\n\nThat means in your solution there should never be an instance of `Integer/BigInt` having full value of inputs `num1` and `num2`.\n\nNo one is stopping you from doing that and solving your solution. But then, leaving comments like _\"this is an easy question\"_ you are only making a fool out of yourself."
                    },
                    {
                        "username": "Nakashima",
                        "content": "Do I need to consider the number that is between 0 and 1?"
                    },
                    {
                        "username": "QuazarGuy",
                        "content": "This type of question should be removed so interviewers don\\'t see it and think it\\'s a good question. Implement a tedious and detailed already built-in function that\\'s highly prone to error. I will reject a job if this type of question is asked. Test me on algorithms, not my ability to detect potential off-by-one errors."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for November, Day 7.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/multiply-strings/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Elementary Math\n\n  \n**Approach 2:** Elementary math using less intermediate space\n\n  \n**Approach 3:** Sum the products from all pairs of digits\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "sri_datta",
                        "content": "how does this have so many likes?"
                    },
                    {
                        "username": "nop_nop",
                        "content": "Consider \"123\" and \"456\"\\nMultiply \"6\"(of 456) with \"3\"(of 123) and keep track of this total sum, for next \"6\"(of 456)  with \"2\"(of 123) , but here we need to multiply the product by 10^1 as we do need to account for \"2\"(123) being in tens place and similarly we do it for everything and keep adding the sum.\\n![image](https://assets.leetcode.com/users/nop_nop/image_1547686032.png)\\n\\nBelow is the code:\\n![image](https://assets.leetcode.com/users/nop_nop/image_1547686217.png)\\n"
                    },
                    {
                        "username": "srivastavasameer2002",
                        "content": "what is variable type of total_sum? "
                    },
                    {
                        "username": "healqq",
                        "content": "good explanation, but code doesn\\'t follow the order of the image (as far as I can tell). As you\\'ll get 3 * 6 (i = 0, j = 0) => 3 * 5 (i = 0; j = 1) => 3*4 (i = 0; j = 2) and so on. Doesn\\'t change the result of course, but maybe makes sense to swap the loops around"
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "`n1 = ord(n1) - ord(\\'0\\')` why use ordinals?"
                    },
                    {
                        "username": "Raviteja525",
                        "content": "return str(eval(num1+\\'*\\'+num2))"
                    },
                    {
                        "username": "Sanjeet-Kumar",
                        "content": "![alt text](image url)![0_1497347622870_string.jpg](/assets/uploads/files/1497347627240-string-resized.jpg) \\nGuys As i have found most difficulties to understand the problem.Here From the above picture we can see that the product of ith and jth number will be stroed in position i+j and i+j+1, \\ni.e., res[i+j] is used to store the carry value and res[i+j+1] is used to rightmost digit of the sum.\\n![0_1497347660069_Screenshot (99).png](/assets/uploads/files/1497347665657-screenshot-99.png) \\nI hope it will help you."
                    }
                ]
            },
            {
                "id": 1572392,
                "content": [
                    {
                        "username": "bcronrath",
                        "content": "Honestly I don\\'t understand why these type of questions exist.  They should be removed, or leetcode should at least build in a way to have validation rules such as checking that variables aren\\'t converted to integers.  Look at all the top runtime submissions for this one, literally they are one line where they just convert the strings to integers and multiply them, it\\'s a joke."
                    },
                    {
                        "username": "Husoski",
                        "content": "[@Moonbeam8773](/Moonbeam8773) \\nIt\\'s not vague at all.  The goal is clearly to write the multiplication code yourself.  It\\'s just grade-school arithmetic, after all.  "
                    },
                    {
                        "username": "RedLeader",
                        "content": "Agreed, questions like this are pretty terrible and hacky in nature.  "
                    },
                    {
                        "username": "Moonbeam8773",
                        "content": "It says not to directly convert to int. Does that mean that if I wrote my own int converter I can do that? Or is the purpose of this question to generate a sum of the multiplication of each digit with 10^n padded behind? In that case, can I cast to int and multiply that single digit? Or am I supposed to create a matrix of single digit multiplication results and use that as a hashmap lookup?\\n\\nThis question is so vague it\\'s dumb."
                    },
                    {
                        "username": "neolancer",
                        "content": "This is a good question BUT the submission test cases must ensure that BigNumber-like conversion will not suffice. Otherwise proper solutions, like linked-list etc., will be disappointingly left in the tail"
                    },
                    {
                        "username": "kzo",
                        "content": "[@user3571Rr](/user3571Rr) Doesn\\'t work in Python with it\\'s unlimited precision"
                    },
                    {
                        "username": "spicedNoodle",
                        "content": "[@user3571Rr](/user3571Rr) uint64 can handle super log numbers in most langs. in the TS version i just used BigInt and thats it. i agree with this guys. this is a \"medium\" question. how in the hell is this medium?\\n\\ndont get me wrong, i see your point and i also agree with you. Basic understanding of dataTypes is super important. but medium? this should be a beginner / easy question. Any CS major in his first or second semester should be able to solve this given a few minutes. "
                    },
                    {
                        "username": "robotburrito",
                        "content": "In the real world if you didn\\'t write that 1 line that beats 98% of all other submissions when given this problem you\\'d probably be fired lol."
                    },
                    {
                        "username": "user3571Rr",
                        "content": "Not quite - some of the tests use seriously long number sequences, meaning that none of the conversion to Integer, Long, BigInteger or BigDecimal would actually work because of overflow.\\nIt seems to me that the only way is to carry out multiplications one at a time (as we one was doing it by hand), organise them in columns and produce text from the result, in sequence, while also taking care of rollover values."
                    },
                    {
                        "username": "juicebox2",
                        "content": "Pretty silly question. I feel it teaches devs to try to find complex solutions to simple problems. Why wouldn\\'t we leverage the basic functionality of a language and convert the strings to integer?\\n"
                    },
                    {
                        "username": "Husoski",
                        "content": "More to the point, *someone* has to write code for things like Python unlimited integers or the java.math.BigInteger class.  This is a real programming problem, solved by real programmers, and is more likely to come up in a career (imho) than finding the longest palindrome in a string of a million characters.\\nI\\'m retired, though...old-school with lots of embedded assembly and C...so maybe I\\'m biased by the fact that I\\'ve had to write software multiplication (particularly in assembly) more than once for embedded 8-bit systems."
                    },
                    {
                        "username": "Shikhar_Codes_",
                        "content": "Correct bruh!!"
                    },
                    {
                        "username": "tri_jal",
                        "content": "Listen listen, the reason why they give such questions is to check your problem solving ability. It is not about finding the complex solution, it\\'s about thinking out of the box :)"
                    },
                    {
                        "username": "joshuamahadevan1",
                        "content": "there could be situations where the number can\\'t fit in 64-bit space.. or whatever u decide to use.. numbers expressed  in binary will overflow at some point, and its good to know different ways of processing the same."
                    },
                    {
                        "username": "Krrabs",
                        "content": "For those saying, _why is it a medium? or it should be marked as easy._\n\nIn the question they specifically asked not to use `BigInt` or **convert** the input number **directly.**\n\nThat means in your solution there should never be an instance of `Integer/BigInt` having full value of inputs `num1` and `num2`.\n\nNo one is stopping you from doing that and solving your solution. But then, leaving comments like _\"this is an easy question\"_ you are only making a fool out of yourself."
                    },
                    {
                        "username": "Nakashima",
                        "content": "Do I need to consider the number that is between 0 and 1?"
                    },
                    {
                        "username": "QuazarGuy",
                        "content": "This type of question should be removed so interviewers don\\'t see it and think it\\'s a good question. Implement a tedious and detailed already built-in function that\\'s highly prone to error. I will reject a job if this type of question is asked. Test me on algorithms, not my ability to detect potential off-by-one errors."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for November, Day 7.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/multiply-strings/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Elementary Math\n\n  \n**Approach 2:** Elementary math using less intermediate space\n\n  \n**Approach 3:** Sum the products from all pairs of digits\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "sri_datta",
                        "content": "how does this have so many likes?"
                    },
                    {
                        "username": "nop_nop",
                        "content": "Consider \"123\" and \"456\"\\nMultiply \"6\"(of 456) with \"3\"(of 123) and keep track of this total sum, for next \"6\"(of 456)  with \"2\"(of 123) , but here we need to multiply the product by 10^1 as we do need to account for \"2\"(123) being in tens place and similarly we do it for everything and keep adding the sum.\\n![image](https://assets.leetcode.com/users/nop_nop/image_1547686032.png)\\n\\nBelow is the code:\\n![image](https://assets.leetcode.com/users/nop_nop/image_1547686217.png)\\n"
                    },
                    {
                        "username": "srivastavasameer2002",
                        "content": "what is variable type of total_sum? "
                    },
                    {
                        "username": "healqq",
                        "content": "good explanation, but code doesn\\'t follow the order of the image (as far as I can tell). As you\\'ll get 3 * 6 (i = 0, j = 0) => 3 * 5 (i = 0; j = 1) => 3*4 (i = 0; j = 2) and so on. Doesn\\'t change the result of course, but maybe makes sense to swap the loops around"
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "`n1 = ord(n1) - ord(\\'0\\')` why use ordinals?"
                    },
                    {
                        "username": "Raviteja525",
                        "content": "return str(eval(num1+\\'*\\'+num2))"
                    },
                    {
                        "username": "Sanjeet-Kumar",
                        "content": "![alt text](image url)![0_1497347622870_string.jpg](/assets/uploads/files/1497347627240-string-resized.jpg) \\nGuys As i have found most difficulties to understand the problem.Here From the above picture we can see that the product of ith and jth number will be stroed in position i+j and i+j+1, \\ni.e., res[i+j] is used to store the carry value and res[i+j+1] is used to rightmost digit of the sum.\\n![0_1497347660069_Screenshot (99).png](/assets/uploads/files/1497347665657-screenshot-99.png) \\nI hope it will help you."
                    }
                ]
            },
            {
                "id": 1576603,
                "content": [
                    {
                        "username": "bcronrath",
                        "content": "Honestly I don\\'t understand why these type of questions exist.  They should be removed, or leetcode should at least build in a way to have validation rules such as checking that variables aren\\'t converted to integers.  Look at all the top runtime submissions for this one, literally they are one line where they just convert the strings to integers and multiply them, it\\'s a joke."
                    },
                    {
                        "username": "Husoski",
                        "content": "[@Moonbeam8773](/Moonbeam8773) \\nIt\\'s not vague at all.  The goal is clearly to write the multiplication code yourself.  It\\'s just grade-school arithmetic, after all.  "
                    },
                    {
                        "username": "RedLeader",
                        "content": "Agreed, questions like this are pretty terrible and hacky in nature.  "
                    },
                    {
                        "username": "Moonbeam8773",
                        "content": "It says not to directly convert to int. Does that mean that if I wrote my own int converter I can do that? Or is the purpose of this question to generate a sum of the multiplication of each digit with 10^n padded behind? In that case, can I cast to int and multiply that single digit? Or am I supposed to create a matrix of single digit multiplication results and use that as a hashmap lookup?\\n\\nThis question is so vague it\\'s dumb."
                    },
                    {
                        "username": "neolancer",
                        "content": "This is a good question BUT the submission test cases must ensure that BigNumber-like conversion will not suffice. Otherwise proper solutions, like linked-list etc., will be disappointingly left in the tail"
                    },
                    {
                        "username": "kzo",
                        "content": "[@user3571Rr](/user3571Rr) Doesn\\'t work in Python with it\\'s unlimited precision"
                    },
                    {
                        "username": "spicedNoodle",
                        "content": "[@user3571Rr](/user3571Rr) uint64 can handle super log numbers in most langs. in the TS version i just used BigInt and thats it. i agree with this guys. this is a \"medium\" question. how in the hell is this medium?\\n\\ndont get me wrong, i see your point and i also agree with you. Basic understanding of dataTypes is super important. but medium? this should be a beginner / easy question. Any CS major in his first or second semester should be able to solve this given a few minutes. "
                    },
                    {
                        "username": "robotburrito",
                        "content": "In the real world if you didn\\'t write that 1 line that beats 98% of all other submissions when given this problem you\\'d probably be fired lol."
                    },
                    {
                        "username": "user3571Rr",
                        "content": "Not quite - some of the tests use seriously long number sequences, meaning that none of the conversion to Integer, Long, BigInteger or BigDecimal would actually work because of overflow.\\nIt seems to me that the only way is to carry out multiplications one at a time (as we one was doing it by hand), organise them in columns and produce text from the result, in sequence, while also taking care of rollover values."
                    },
                    {
                        "username": "juicebox2",
                        "content": "Pretty silly question. I feel it teaches devs to try to find complex solutions to simple problems. Why wouldn\\'t we leverage the basic functionality of a language and convert the strings to integer?\\n"
                    },
                    {
                        "username": "Husoski",
                        "content": "More to the point, *someone* has to write code for things like Python unlimited integers or the java.math.BigInteger class.  This is a real programming problem, solved by real programmers, and is more likely to come up in a career (imho) than finding the longest palindrome in a string of a million characters.\\nI\\'m retired, though...old-school with lots of embedded assembly and C...so maybe I\\'m biased by the fact that I\\'ve had to write software multiplication (particularly in assembly) more than once for embedded 8-bit systems."
                    },
                    {
                        "username": "Shikhar_Codes_",
                        "content": "Correct bruh!!"
                    },
                    {
                        "username": "tri_jal",
                        "content": "Listen listen, the reason why they give such questions is to check your problem solving ability. It is not about finding the complex solution, it\\'s about thinking out of the box :)"
                    },
                    {
                        "username": "joshuamahadevan1",
                        "content": "there could be situations where the number can\\'t fit in 64-bit space.. or whatever u decide to use.. numbers expressed  in binary will overflow at some point, and its good to know different ways of processing the same."
                    },
                    {
                        "username": "Krrabs",
                        "content": "For those saying, _why is it a medium? or it should be marked as easy._\n\nIn the question they specifically asked not to use `BigInt` or **convert** the input number **directly.**\n\nThat means in your solution there should never be an instance of `Integer/BigInt` having full value of inputs `num1` and `num2`.\n\nNo one is stopping you from doing that and solving your solution. But then, leaving comments like _\"this is an easy question\"_ you are only making a fool out of yourself."
                    },
                    {
                        "username": "Nakashima",
                        "content": "Do I need to consider the number that is between 0 and 1?"
                    },
                    {
                        "username": "QuazarGuy",
                        "content": "This type of question should be removed so interviewers don\\'t see it and think it\\'s a good question. Implement a tedious and detailed already built-in function that\\'s highly prone to error. I will reject a job if this type of question is asked. Test me on algorithms, not my ability to detect potential off-by-one errors."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for November, Day 7.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/multiply-strings/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Elementary Math\n\n  \n**Approach 2:** Elementary math using less intermediate space\n\n  \n**Approach 3:** Sum the products from all pairs of digits\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "sri_datta",
                        "content": "how does this have so many likes?"
                    },
                    {
                        "username": "nop_nop",
                        "content": "Consider \"123\" and \"456\"\\nMultiply \"6\"(of 456) with \"3\"(of 123) and keep track of this total sum, for next \"6\"(of 456)  with \"2\"(of 123) , but here we need to multiply the product by 10^1 as we do need to account for \"2\"(123) being in tens place and similarly we do it for everything and keep adding the sum.\\n![image](https://assets.leetcode.com/users/nop_nop/image_1547686032.png)\\n\\nBelow is the code:\\n![image](https://assets.leetcode.com/users/nop_nop/image_1547686217.png)\\n"
                    },
                    {
                        "username": "srivastavasameer2002",
                        "content": "what is variable type of total_sum? "
                    },
                    {
                        "username": "healqq",
                        "content": "good explanation, but code doesn\\'t follow the order of the image (as far as I can tell). As you\\'ll get 3 * 6 (i = 0, j = 0) => 3 * 5 (i = 0; j = 1) => 3*4 (i = 0; j = 2) and so on. Doesn\\'t change the result of course, but maybe makes sense to swap the loops around"
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "`n1 = ord(n1) - ord(\\'0\\')` why use ordinals?"
                    },
                    {
                        "username": "Raviteja525",
                        "content": "return str(eval(num1+\\'*\\'+num2))"
                    },
                    {
                        "username": "Sanjeet-Kumar",
                        "content": "![alt text](image url)![0_1497347622870_string.jpg](/assets/uploads/files/1497347627240-string-resized.jpg) \\nGuys As i have found most difficulties to understand the problem.Here From the above picture we can see that the product of ith and jth number will be stroed in position i+j and i+j+1, \\ni.e., res[i+j] is used to store the carry value and res[i+j+1] is used to rightmost digit of the sum.\\n![0_1497347660069_Screenshot (99).png](/assets/uploads/files/1497347665657-screenshot-99.png) \\nI hope it will help you."
                    }
                ]
            },
            {
                "id": 1566740,
                "content": [
                    {
                        "username": "bcronrath",
                        "content": "Honestly I don\\'t understand why these type of questions exist.  They should be removed, or leetcode should at least build in a way to have validation rules such as checking that variables aren\\'t converted to integers.  Look at all the top runtime submissions for this one, literally they are one line where they just convert the strings to integers and multiply them, it\\'s a joke."
                    },
                    {
                        "username": "Husoski",
                        "content": "[@Moonbeam8773](/Moonbeam8773) \\nIt\\'s not vague at all.  The goal is clearly to write the multiplication code yourself.  It\\'s just grade-school arithmetic, after all.  "
                    },
                    {
                        "username": "RedLeader",
                        "content": "Agreed, questions like this are pretty terrible and hacky in nature.  "
                    },
                    {
                        "username": "Moonbeam8773",
                        "content": "It says not to directly convert to int. Does that mean that if I wrote my own int converter I can do that? Or is the purpose of this question to generate a sum of the multiplication of each digit with 10^n padded behind? In that case, can I cast to int and multiply that single digit? Or am I supposed to create a matrix of single digit multiplication results and use that as a hashmap lookup?\\n\\nThis question is so vague it\\'s dumb."
                    },
                    {
                        "username": "neolancer",
                        "content": "This is a good question BUT the submission test cases must ensure that BigNumber-like conversion will not suffice. Otherwise proper solutions, like linked-list etc., will be disappointingly left in the tail"
                    },
                    {
                        "username": "kzo",
                        "content": "[@user3571Rr](/user3571Rr) Doesn\\'t work in Python with it\\'s unlimited precision"
                    },
                    {
                        "username": "spicedNoodle",
                        "content": "[@user3571Rr](/user3571Rr) uint64 can handle super log numbers in most langs. in the TS version i just used BigInt and thats it. i agree with this guys. this is a \"medium\" question. how in the hell is this medium?\\n\\ndont get me wrong, i see your point and i also agree with you. Basic understanding of dataTypes is super important. but medium? this should be a beginner / easy question. Any CS major in his first or second semester should be able to solve this given a few minutes. "
                    },
                    {
                        "username": "robotburrito",
                        "content": "In the real world if you didn\\'t write that 1 line that beats 98% of all other submissions when given this problem you\\'d probably be fired lol."
                    },
                    {
                        "username": "user3571Rr",
                        "content": "Not quite - some of the tests use seriously long number sequences, meaning that none of the conversion to Integer, Long, BigInteger or BigDecimal would actually work because of overflow.\\nIt seems to me that the only way is to carry out multiplications one at a time (as we one was doing it by hand), organise them in columns and produce text from the result, in sequence, while also taking care of rollover values."
                    },
                    {
                        "username": "juicebox2",
                        "content": "Pretty silly question. I feel it teaches devs to try to find complex solutions to simple problems. Why wouldn\\'t we leverage the basic functionality of a language and convert the strings to integer?\\n"
                    },
                    {
                        "username": "Husoski",
                        "content": "More to the point, *someone* has to write code for things like Python unlimited integers or the java.math.BigInteger class.  This is a real programming problem, solved by real programmers, and is more likely to come up in a career (imho) than finding the longest palindrome in a string of a million characters.\\nI\\'m retired, though...old-school with lots of embedded assembly and C...so maybe I\\'m biased by the fact that I\\'ve had to write software multiplication (particularly in assembly) more than once for embedded 8-bit systems."
                    },
                    {
                        "username": "Shikhar_Codes_",
                        "content": "Correct bruh!!"
                    },
                    {
                        "username": "tri_jal",
                        "content": "Listen listen, the reason why they give such questions is to check your problem solving ability. It is not about finding the complex solution, it\\'s about thinking out of the box :)"
                    },
                    {
                        "username": "joshuamahadevan1",
                        "content": "there could be situations where the number can\\'t fit in 64-bit space.. or whatever u decide to use.. numbers expressed  in binary will overflow at some point, and its good to know different ways of processing the same."
                    },
                    {
                        "username": "Krrabs",
                        "content": "For those saying, _why is it a medium? or it should be marked as easy._\n\nIn the question they specifically asked not to use `BigInt` or **convert** the input number **directly.**\n\nThat means in your solution there should never be an instance of `Integer/BigInt` having full value of inputs `num1` and `num2`.\n\nNo one is stopping you from doing that and solving your solution. But then, leaving comments like _\"this is an easy question\"_ you are only making a fool out of yourself."
                    },
                    {
                        "username": "Nakashima",
                        "content": "Do I need to consider the number that is between 0 and 1?"
                    },
                    {
                        "username": "QuazarGuy",
                        "content": "This type of question should be removed so interviewers don\\'t see it and think it\\'s a good question. Implement a tedious and detailed already built-in function that\\'s highly prone to error. I will reject a job if this type of question is asked. Test me on algorithms, not my ability to detect potential off-by-one errors."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for November, Day 7.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/multiply-strings/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Elementary Math\n\n  \n**Approach 2:** Elementary math using less intermediate space\n\n  \n**Approach 3:** Sum the products from all pairs of digits\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "sri_datta",
                        "content": "how does this have so many likes?"
                    },
                    {
                        "username": "nop_nop",
                        "content": "Consider \"123\" and \"456\"\\nMultiply \"6\"(of 456) with \"3\"(of 123) and keep track of this total sum, for next \"6\"(of 456)  with \"2\"(of 123) , but here we need to multiply the product by 10^1 as we do need to account for \"2\"(123) being in tens place and similarly we do it for everything and keep adding the sum.\\n![image](https://assets.leetcode.com/users/nop_nop/image_1547686032.png)\\n\\nBelow is the code:\\n![image](https://assets.leetcode.com/users/nop_nop/image_1547686217.png)\\n"
                    },
                    {
                        "username": "srivastavasameer2002",
                        "content": "what is variable type of total_sum? "
                    },
                    {
                        "username": "healqq",
                        "content": "good explanation, but code doesn\\'t follow the order of the image (as far as I can tell). As you\\'ll get 3 * 6 (i = 0, j = 0) => 3 * 5 (i = 0; j = 1) => 3*4 (i = 0; j = 2) and so on. Doesn\\'t change the result of course, but maybe makes sense to swap the loops around"
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "`n1 = ord(n1) - ord(\\'0\\')` why use ordinals?"
                    },
                    {
                        "username": "Raviteja525",
                        "content": "return str(eval(num1+\\'*\\'+num2))"
                    },
                    {
                        "username": "Sanjeet-Kumar",
                        "content": "![alt text](image url)![0_1497347622870_string.jpg](/assets/uploads/files/1497347627240-string-resized.jpg) \\nGuys As i have found most difficulties to understand the problem.Here From the above picture we can see that the product of ith and jth number will be stroed in position i+j and i+j+1, \\ni.e., res[i+j] is used to store the carry value and res[i+j+1] is used to rightmost digit of the sum.\\n![0_1497347660069_Screenshot (99).png](/assets/uploads/files/1497347665657-screenshot-99.png) \\nI hope it will help you."
                    }
                ]
            },
            {
                "id": 1568007,
                "content": [
                    {
                        "username": "akashgupta29",
                        "content": "If the two given strings are sparse strings. Then which data structure would be perfect for this problem ?"
                    },
                    {
                        "username": "ProfNandaa",
                        "content": "I think this _problem_ is wrongly categorized as `medium`. Should be `easy`."
                    },
                    {
                        "username": "yabbadabbadoo123",
                        "content": "Not if you want to solve it the way the creator intended."
                    },
                    {
                        "username": "raisfeldori",
                        "content": "wtf, the code says num1 and num2 cannot go above 200, but after submiting i failed at:\nnum1 = \"123456789\"\nnum2 = \"987654321\"\nexpected = \"121932631112635269\"\n\ni am very lucky that this can be solved by just incresing the i32 to an i64, but if this was any higher then i would've failed and had to completly redesign my algorithm to work for numbers over 2 ^ 64 - 1.\n\nedit: this happend, i submited the same thiing but failed at:\nnum1 = \"498828660196\"\nnum2 = \"840477629533\"\nexpected = \"419254329864656431168468\"\n\nat this point i need to use u128, because even u64 is too small for the numbers they use, at some point, i'm just expecting to find here \"9999999999999999999999999999999999999999999999999\" even though THE QUESTION SAYS NUM1 AND NUM2 CAN'T GO ABOVE 200!!!!!!!\n\nedit: I FUCKING SAID IT, I AM SO FUCKING PISSED, I AM USING u128 AND EVEN THAT ISN'T ENOUGH AT THIS POINT, FUCK THIS,  EVEN u128 iS TOO LITTLE, I\"M JUST GONNA MAKE AN EDGECASE FOR THAT NUMBER AND THAT's IT"
                    },
                    {
                        "username": "Husoski",
                        "content": "Read the problem statement.  The second paragraph says, \"Note: You must not use any built-in BigInteger library or convert the inputs to integer directly.\"\\n\\nAlso, the Constraints stay that the *lengths* of num1 and num2 are 200 or less, not their values.  "
                    },
                    {
                        "username": "Ashnu_B",
                        "content": "This should be marked as hard due to tricky implementation"
                    },
                    {
                        "username": "gamersulwood2900",
                        "content": "num1 = \"123456789\"\\nnum2 = \"987654321\"\\nOutput = \"121932631112635260\"\\nExpected = \"121932631112635269\"\\nseriously, LeetCode? How am i supposed to code a program that is able to formulate an answer bigger than the 64 bit integer limit?"
                    },
                    {
                        "username": "garvitagrawal_02",
                        "content": "that\\'s why string format is used"
                    },
                    {
                        "username": "f-kravchenko",
                        "content": "nice question. have learned the FFT"
                    },
                    {
                        "username": "Husoski",
                        "content": "Thumbs up for that!  I know the theory behind it, but never have written code for FFT multiplication.  Did you generate your own sines and cosines, or use sin() and/or cos() from the math library? "
                    },
                    {
                        "username": "ShashidharAngadi",
                        "content": "Do not try to solve this by converting to int mechanism \\uD83E\\uDD26\\u200D\\u2642\\uFE0F\\uD83E\\uDD26\\u200D\\u2642\\uFE0F. Read the constraints carefully."
                    },
                    {
                        "username": "antonpinchuk",
                        "content": "You can do like machine does, convert into binary then use bit shift.\\nI was lazy, my solution is like common, but I just put digits into reversed list of int\\'s."
                    },
                    {
                        "username": "hungrypanda",
                        "content": "Is this an arbitrary number?\\nWould you think about this problem differently if the max length was different or not given?"
                    },
                    {
                        "username": "Vidushak",
                        "content": "I am using Java as my coding language. I didn't see anyone running into this problem though.\\n\\nInput: \"0\", \"0\"\\nOutput: \"0\"\\nExpected: \"0\"\\n\\nIncase has any idea?"
                    }
                ]
            },
            {
                "id": 1572332,
                "content": [
                    {
                        "username": "akashgupta29",
                        "content": "If the two given strings are sparse strings. Then which data structure would be perfect for this problem ?"
                    },
                    {
                        "username": "ProfNandaa",
                        "content": "I think this _problem_ is wrongly categorized as `medium`. Should be `easy`."
                    },
                    {
                        "username": "yabbadabbadoo123",
                        "content": "Not if you want to solve it the way the creator intended."
                    },
                    {
                        "username": "raisfeldori",
                        "content": "wtf, the code says num1 and num2 cannot go above 200, but after submiting i failed at:\nnum1 = \"123456789\"\nnum2 = \"987654321\"\nexpected = \"121932631112635269\"\n\ni am very lucky that this can be solved by just incresing the i32 to an i64, but if this was any higher then i would've failed and had to completly redesign my algorithm to work for numbers over 2 ^ 64 - 1.\n\nedit: this happend, i submited the same thiing but failed at:\nnum1 = \"498828660196\"\nnum2 = \"840477629533\"\nexpected = \"419254329864656431168468\"\n\nat this point i need to use u128, because even u64 is too small for the numbers they use, at some point, i'm just expecting to find here \"9999999999999999999999999999999999999999999999999\" even though THE QUESTION SAYS NUM1 AND NUM2 CAN'T GO ABOVE 200!!!!!!!\n\nedit: I FUCKING SAID IT, I AM SO FUCKING PISSED, I AM USING u128 AND EVEN THAT ISN'T ENOUGH AT THIS POINT, FUCK THIS,  EVEN u128 iS TOO LITTLE, I\"M JUST GONNA MAKE AN EDGECASE FOR THAT NUMBER AND THAT's IT"
                    },
                    {
                        "username": "Husoski",
                        "content": "Read the problem statement.  The second paragraph says, \"Note: You must not use any built-in BigInteger library or convert the inputs to integer directly.\"\\n\\nAlso, the Constraints stay that the *lengths* of num1 and num2 are 200 or less, not their values.  "
                    },
                    {
                        "username": "Ashnu_B",
                        "content": "This should be marked as hard due to tricky implementation"
                    },
                    {
                        "username": "gamersulwood2900",
                        "content": "num1 = \"123456789\"\\nnum2 = \"987654321\"\\nOutput = \"121932631112635260\"\\nExpected = \"121932631112635269\"\\nseriously, LeetCode? How am i supposed to code a program that is able to formulate an answer bigger than the 64 bit integer limit?"
                    },
                    {
                        "username": "garvitagrawal_02",
                        "content": "that\\'s why string format is used"
                    },
                    {
                        "username": "f-kravchenko",
                        "content": "nice question. have learned the FFT"
                    },
                    {
                        "username": "Husoski",
                        "content": "Thumbs up for that!  I know the theory behind it, but never have written code for FFT multiplication.  Did you generate your own sines and cosines, or use sin() and/or cos() from the math library? "
                    },
                    {
                        "username": "ShashidharAngadi",
                        "content": "Do not try to solve this by converting to int mechanism \\uD83E\\uDD26\\u200D\\u2642\\uFE0F\\uD83E\\uDD26\\u200D\\u2642\\uFE0F. Read the constraints carefully."
                    },
                    {
                        "username": "antonpinchuk",
                        "content": "You can do like machine does, convert into binary then use bit shift.\\nI was lazy, my solution is like common, but I just put digits into reversed list of int\\'s."
                    },
                    {
                        "username": "hungrypanda",
                        "content": "Is this an arbitrary number?\\nWould you think about this problem differently if the max length was different or not given?"
                    },
                    {
                        "username": "Vidushak",
                        "content": "I am using Java as my coding language. I didn't see anyone running into this problem though.\\n\\nInput: \"0\", \"0\"\\nOutput: \"0\"\\nExpected: \"0\"\\n\\nIncase has any idea?"
                    }
                ]
            },
            {
                "id": 1957338,
                "content": [
                    {
                        "username": "akashgupta29",
                        "content": "If the two given strings are sparse strings. Then which data structure would be perfect for this problem ?"
                    },
                    {
                        "username": "ProfNandaa",
                        "content": "I think this _problem_ is wrongly categorized as `medium`. Should be `easy`."
                    },
                    {
                        "username": "yabbadabbadoo123",
                        "content": "Not if you want to solve it the way the creator intended."
                    },
                    {
                        "username": "raisfeldori",
                        "content": "wtf, the code says num1 and num2 cannot go above 200, but after submiting i failed at:\nnum1 = \"123456789\"\nnum2 = \"987654321\"\nexpected = \"121932631112635269\"\n\ni am very lucky that this can be solved by just incresing the i32 to an i64, but if this was any higher then i would've failed and had to completly redesign my algorithm to work for numbers over 2 ^ 64 - 1.\n\nedit: this happend, i submited the same thiing but failed at:\nnum1 = \"498828660196\"\nnum2 = \"840477629533\"\nexpected = \"419254329864656431168468\"\n\nat this point i need to use u128, because even u64 is too small for the numbers they use, at some point, i'm just expecting to find here \"9999999999999999999999999999999999999999999999999\" even though THE QUESTION SAYS NUM1 AND NUM2 CAN'T GO ABOVE 200!!!!!!!\n\nedit: I FUCKING SAID IT, I AM SO FUCKING PISSED, I AM USING u128 AND EVEN THAT ISN'T ENOUGH AT THIS POINT, FUCK THIS,  EVEN u128 iS TOO LITTLE, I\"M JUST GONNA MAKE AN EDGECASE FOR THAT NUMBER AND THAT's IT"
                    },
                    {
                        "username": "Husoski",
                        "content": "Read the problem statement.  The second paragraph says, \"Note: You must not use any built-in BigInteger library or convert the inputs to integer directly.\"\\n\\nAlso, the Constraints stay that the *lengths* of num1 and num2 are 200 or less, not their values.  "
                    },
                    {
                        "username": "Ashnu_B",
                        "content": "This should be marked as hard due to tricky implementation"
                    },
                    {
                        "username": "gamersulwood2900",
                        "content": "num1 = \"123456789\"\\nnum2 = \"987654321\"\\nOutput = \"121932631112635260\"\\nExpected = \"121932631112635269\"\\nseriously, LeetCode? How am i supposed to code a program that is able to formulate an answer bigger than the 64 bit integer limit?"
                    },
                    {
                        "username": "garvitagrawal_02",
                        "content": "that\\'s why string format is used"
                    },
                    {
                        "username": "f-kravchenko",
                        "content": "nice question. have learned the FFT"
                    },
                    {
                        "username": "Husoski",
                        "content": "Thumbs up for that!  I know the theory behind it, but never have written code for FFT multiplication.  Did you generate your own sines and cosines, or use sin() and/or cos() from the math library? "
                    },
                    {
                        "username": "ShashidharAngadi",
                        "content": "Do not try to solve this by converting to int mechanism \\uD83E\\uDD26\\u200D\\u2642\\uFE0F\\uD83E\\uDD26\\u200D\\u2642\\uFE0F. Read the constraints carefully."
                    },
                    {
                        "username": "antonpinchuk",
                        "content": "You can do like machine does, convert into binary then use bit shift.\\nI was lazy, my solution is like common, but I just put digits into reversed list of int\\'s."
                    },
                    {
                        "username": "hungrypanda",
                        "content": "Is this an arbitrary number?\\nWould you think about this problem differently if the max length was different or not given?"
                    },
                    {
                        "username": "Vidushak",
                        "content": "I am using Java as my coding language. I didn't see anyone running into this problem though.\\n\\nInput: \"0\", \"0\"\\nOutput: \"0\"\\nExpected: \"0\"\\n\\nIncase has any idea?"
                    }
                ]
            },
            {
                "id": 2033192,
                "content": [
                    {
                        "username": "akashgupta29",
                        "content": "If the two given strings are sparse strings. Then which data structure would be perfect for this problem ?"
                    },
                    {
                        "username": "ProfNandaa",
                        "content": "I think this _problem_ is wrongly categorized as `medium`. Should be `easy`."
                    },
                    {
                        "username": "yabbadabbadoo123",
                        "content": "Not if you want to solve it the way the creator intended."
                    },
                    {
                        "username": "raisfeldori",
                        "content": "wtf, the code says num1 and num2 cannot go above 200, but after submiting i failed at:\nnum1 = \"123456789\"\nnum2 = \"987654321\"\nexpected = \"121932631112635269\"\n\ni am very lucky that this can be solved by just incresing the i32 to an i64, but if this was any higher then i would've failed and had to completly redesign my algorithm to work for numbers over 2 ^ 64 - 1.\n\nedit: this happend, i submited the same thiing but failed at:\nnum1 = \"498828660196\"\nnum2 = \"840477629533\"\nexpected = \"419254329864656431168468\"\n\nat this point i need to use u128, because even u64 is too small for the numbers they use, at some point, i'm just expecting to find here \"9999999999999999999999999999999999999999999999999\" even though THE QUESTION SAYS NUM1 AND NUM2 CAN'T GO ABOVE 200!!!!!!!\n\nedit: I FUCKING SAID IT, I AM SO FUCKING PISSED, I AM USING u128 AND EVEN THAT ISN'T ENOUGH AT THIS POINT, FUCK THIS,  EVEN u128 iS TOO LITTLE, I\"M JUST GONNA MAKE AN EDGECASE FOR THAT NUMBER AND THAT's IT"
                    },
                    {
                        "username": "Husoski",
                        "content": "Read the problem statement.  The second paragraph says, \"Note: You must not use any built-in BigInteger library or convert the inputs to integer directly.\"\\n\\nAlso, the Constraints stay that the *lengths* of num1 and num2 are 200 or less, not their values.  "
                    },
                    {
                        "username": "Ashnu_B",
                        "content": "This should be marked as hard due to tricky implementation"
                    },
                    {
                        "username": "gamersulwood2900",
                        "content": "num1 = \"123456789\"\\nnum2 = \"987654321\"\\nOutput = \"121932631112635260\"\\nExpected = \"121932631112635269\"\\nseriously, LeetCode? How am i supposed to code a program that is able to formulate an answer bigger than the 64 bit integer limit?"
                    },
                    {
                        "username": "garvitagrawal_02",
                        "content": "that\\'s why string format is used"
                    },
                    {
                        "username": "f-kravchenko",
                        "content": "nice question. have learned the FFT"
                    },
                    {
                        "username": "Husoski",
                        "content": "Thumbs up for that!  I know the theory behind it, but never have written code for FFT multiplication.  Did you generate your own sines and cosines, or use sin() and/or cos() from the math library? "
                    },
                    {
                        "username": "ShashidharAngadi",
                        "content": "Do not try to solve this by converting to int mechanism \\uD83E\\uDD26\\u200D\\u2642\\uFE0F\\uD83E\\uDD26\\u200D\\u2642\\uFE0F. Read the constraints carefully."
                    },
                    {
                        "username": "antonpinchuk",
                        "content": "You can do like machine does, convert into binary then use bit shift.\\nI was lazy, my solution is like common, but I just put digits into reversed list of int\\'s."
                    },
                    {
                        "username": "hungrypanda",
                        "content": "Is this an arbitrary number?\\nWould you think about this problem differently if the max length was different or not given?"
                    },
                    {
                        "username": "Vidushak",
                        "content": "I am using Java as my coding language. I didn't see anyone running into this problem though.\\n\\nInput: \"0\", \"0\"\\nOutput: \"0\"\\nExpected: \"0\"\\n\\nIncase has any idea?"
                    }
                ]
            },
            {
                "id": 1933181,
                "content": [
                    {
                        "username": "akashgupta29",
                        "content": "If the two given strings are sparse strings. Then which data structure would be perfect for this problem ?"
                    },
                    {
                        "username": "ProfNandaa",
                        "content": "I think this _problem_ is wrongly categorized as `medium`. Should be `easy`."
                    },
                    {
                        "username": "yabbadabbadoo123",
                        "content": "Not if you want to solve it the way the creator intended."
                    },
                    {
                        "username": "raisfeldori",
                        "content": "wtf, the code says num1 and num2 cannot go above 200, but after submiting i failed at:\nnum1 = \"123456789\"\nnum2 = \"987654321\"\nexpected = \"121932631112635269\"\n\ni am very lucky that this can be solved by just incresing the i32 to an i64, but if this was any higher then i would've failed and had to completly redesign my algorithm to work for numbers over 2 ^ 64 - 1.\n\nedit: this happend, i submited the same thiing but failed at:\nnum1 = \"498828660196\"\nnum2 = \"840477629533\"\nexpected = \"419254329864656431168468\"\n\nat this point i need to use u128, because even u64 is too small for the numbers they use, at some point, i'm just expecting to find here \"9999999999999999999999999999999999999999999999999\" even though THE QUESTION SAYS NUM1 AND NUM2 CAN'T GO ABOVE 200!!!!!!!\n\nedit: I FUCKING SAID IT, I AM SO FUCKING PISSED, I AM USING u128 AND EVEN THAT ISN'T ENOUGH AT THIS POINT, FUCK THIS,  EVEN u128 iS TOO LITTLE, I\"M JUST GONNA MAKE AN EDGECASE FOR THAT NUMBER AND THAT's IT"
                    },
                    {
                        "username": "Husoski",
                        "content": "Read the problem statement.  The second paragraph says, \"Note: You must not use any built-in BigInteger library or convert the inputs to integer directly.\"\\n\\nAlso, the Constraints stay that the *lengths* of num1 and num2 are 200 or less, not their values.  "
                    },
                    {
                        "username": "Ashnu_B",
                        "content": "This should be marked as hard due to tricky implementation"
                    },
                    {
                        "username": "gamersulwood2900",
                        "content": "num1 = \"123456789\"\\nnum2 = \"987654321\"\\nOutput = \"121932631112635260\"\\nExpected = \"121932631112635269\"\\nseriously, LeetCode? How am i supposed to code a program that is able to formulate an answer bigger than the 64 bit integer limit?"
                    },
                    {
                        "username": "garvitagrawal_02",
                        "content": "that\\'s why string format is used"
                    },
                    {
                        "username": "f-kravchenko",
                        "content": "nice question. have learned the FFT"
                    },
                    {
                        "username": "Husoski",
                        "content": "Thumbs up for that!  I know the theory behind it, but never have written code for FFT multiplication.  Did you generate your own sines and cosines, or use sin() and/or cos() from the math library? "
                    },
                    {
                        "username": "ShashidharAngadi",
                        "content": "Do not try to solve this by converting to int mechanism \\uD83E\\uDD26\\u200D\\u2642\\uFE0F\\uD83E\\uDD26\\u200D\\u2642\\uFE0F. Read the constraints carefully."
                    },
                    {
                        "username": "antonpinchuk",
                        "content": "You can do like machine does, convert into binary then use bit shift.\\nI was lazy, my solution is like common, but I just put digits into reversed list of int\\'s."
                    },
                    {
                        "username": "hungrypanda",
                        "content": "Is this an arbitrary number?\\nWould you think about this problem differently if the max length was different or not given?"
                    },
                    {
                        "username": "Vidushak",
                        "content": "I am using Java as my coding language. I didn't see anyone running into this problem though.\\n\\nInput: \"0\", \"0\"\\nOutput: \"0\"\\nExpected: \"0\"\\n\\nIncase has any idea?"
                    }
                ]
            },
            {
                "id": 1831974,
                "content": [
                    {
                        "username": "akashgupta29",
                        "content": "If the two given strings are sparse strings. Then which data structure would be perfect for this problem ?"
                    },
                    {
                        "username": "ProfNandaa",
                        "content": "I think this _problem_ is wrongly categorized as `medium`. Should be `easy`."
                    },
                    {
                        "username": "yabbadabbadoo123",
                        "content": "Not if you want to solve it the way the creator intended."
                    },
                    {
                        "username": "raisfeldori",
                        "content": "wtf, the code says num1 and num2 cannot go above 200, but after submiting i failed at:\nnum1 = \"123456789\"\nnum2 = \"987654321\"\nexpected = \"121932631112635269\"\n\ni am very lucky that this can be solved by just incresing the i32 to an i64, but if this was any higher then i would've failed and had to completly redesign my algorithm to work for numbers over 2 ^ 64 - 1.\n\nedit: this happend, i submited the same thiing but failed at:\nnum1 = \"498828660196\"\nnum2 = \"840477629533\"\nexpected = \"419254329864656431168468\"\n\nat this point i need to use u128, because even u64 is too small for the numbers they use, at some point, i'm just expecting to find here \"9999999999999999999999999999999999999999999999999\" even though THE QUESTION SAYS NUM1 AND NUM2 CAN'T GO ABOVE 200!!!!!!!\n\nedit: I FUCKING SAID IT, I AM SO FUCKING PISSED, I AM USING u128 AND EVEN THAT ISN'T ENOUGH AT THIS POINT, FUCK THIS,  EVEN u128 iS TOO LITTLE, I\"M JUST GONNA MAKE AN EDGECASE FOR THAT NUMBER AND THAT's IT"
                    },
                    {
                        "username": "Husoski",
                        "content": "Read the problem statement.  The second paragraph says, \"Note: You must not use any built-in BigInteger library or convert the inputs to integer directly.\"\\n\\nAlso, the Constraints stay that the *lengths* of num1 and num2 are 200 or less, not their values.  "
                    },
                    {
                        "username": "Ashnu_B",
                        "content": "This should be marked as hard due to tricky implementation"
                    },
                    {
                        "username": "gamersulwood2900",
                        "content": "num1 = \"123456789\"\\nnum2 = \"987654321\"\\nOutput = \"121932631112635260\"\\nExpected = \"121932631112635269\"\\nseriously, LeetCode? How am i supposed to code a program that is able to formulate an answer bigger than the 64 bit integer limit?"
                    },
                    {
                        "username": "garvitagrawal_02",
                        "content": "that\\'s why string format is used"
                    },
                    {
                        "username": "f-kravchenko",
                        "content": "nice question. have learned the FFT"
                    },
                    {
                        "username": "Husoski",
                        "content": "Thumbs up for that!  I know the theory behind it, but never have written code for FFT multiplication.  Did you generate your own sines and cosines, or use sin() and/or cos() from the math library? "
                    },
                    {
                        "username": "ShashidharAngadi",
                        "content": "Do not try to solve this by converting to int mechanism \\uD83E\\uDD26\\u200D\\u2642\\uFE0F\\uD83E\\uDD26\\u200D\\u2642\\uFE0F. Read the constraints carefully."
                    },
                    {
                        "username": "antonpinchuk",
                        "content": "You can do like machine does, convert into binary then use bit shift.\\nI was lazy, my solution is like common, but I just put digits into reversed list of int\\'s."
                    },
                    {
                        "username": "hungrypanda",
                        "content": "Is this an arbitrary number?\\nWould you think about this problem differently if the max length was different or not given?"
                    },
                    {
                        "username": "Vidushak",
                        "content": "I am using Java as my coding language. I didn't see anyone running into this problem though.\\n\\nInput: \"0\", \"0\"\\nOutput: \"0\"\\nExpected: \"0\"\\n\\nIncase has any idea?"
                    }
                ]
            },
            {
                "id": 1757936,
                "content": [
                    {
                        "username": "akashgupta29",
                        "content": "If the two given strings are sparse strings. Then which data structure would be perfect for this problem ?"
                    },
                    {
                        "username": "ProfNandaa",
                        "content": "I think this _problem_ is wrongly categorized as `medium`. Should be `easy`."
                    },
                    {
                        "username": "yabbadabbadoo123",
                        "content": "Not if you want to solve it the way the creator intended."
                    },
                    {
                        "username": "raisfeldori",
                        "content": "wtf, the code says num1 and num2 cannot go above 200, but after submiting i failed at:\nnum1 = \"123456789\"\nnum2 = \"987654321\"\nexpected = \"121932631112635269\"\n\ni am very lucky that this can be solved by just incresing the i32 to an i64, but if this was any higher then i would've failed and had to completly redesign my algorithm to work for numbers over 2 ^ 64 - 1.\n\nedit: this happend, i submited the same thiing but failed at:\nnum1 = \"498828660196\"\nnum2 = \"840477629533\"\nexpected = \"419254329864656431168468\"\n\nat this point i need to use u128, because even u64 is too small for the numbers they use, at some point, i'm just expecting to find here \"9999999999999999999999999999999999999999999999999\" even though THE QUESTION SAYS NUM1 AND NUM2 CAN'T GO ABOVE 200!!!!!!!\n\nedit: I FUCKING SAID IT, I AM SO FUCKING PISSED, I AM USING u128 AND EVEN THAT ISN'T ENOUGH AT THIS POINT, FUCK THIS,  EVEN u128 iS TOO LITTLE, I\"M JUST GONNA MAKE AN EDGECASE FOR THAT NUMBER AND THAT's IT"
                    },
                    {
                        "username": "Husoski",
                        "content": "Read the problem statement.  The second paragraph says, \"Note: You must not use any built-in BigInteger library or convert the inputs to integer directly.\"\\n\\nAlso, the Constraints stay that the *lengths* of num1 and num2 are 200 or less, not their values.  "
                    },
                    {
                        "username": "Ashnu_B",
                        "content": "This should be marked as hard due to tricky implementation"
                    },
                    {
                        "username": "gamersulwood2900",
                        "content": "num1 = \"123456789\"\\nnum2 = \"987654321\"\\nOutput = \"121932631112635260\"\\nExpected = \"121932631112635269\"\\nseriously, LeetCode? How am i supposed to code a program that is able to formulate an answer bigger than the 64 bit integer limit?"
                    },
                    {
                        "username": "garvitagrawal_02",
                        "content": "that\\'s why string format is used"
                    },
                    {
                        "username": "f-kravchenko",
                        "content": "nice question. have learned the FFT"
                    },
                    {
                        "username": "Husoski",
                        "content": "Thumbs up for that!  I know the theory behind it, but never have written code for FFT multiplication.  Did you generate your own sines and cosines, or use sin() and/or cos() from the math library? "
                    },
                    {
                        "username": "ShashidharAngadi",
                        "content": "Do not try to solve this by converting to int mechanism \\uD83E\\uDD26\\u200D\\u2642\\uFE0F\\uD83E\\uDD26\\u200D\\u2642\\uFE0F. Read the constraints carefully."
                    },
                    {
                        "username": "antonpinchuk",
                        "content": "You can do like machine does, convert into binary then use bit shift.\\nI was lazy, my solution is like common, but I just put digits into reversed list of int\\'s."
                    },
                    {
                        "username": "hungrypanda",
                        "content": "Is this an arbitrary number?\\nWould you think about this problem differently if the max length was different or not given?"
                    },
                    {
                        "username": "Vidushak",
                        "content": "I am using Java as my coding language. I didn't see anyone running into this problem though.\\n\\nInput: \"0\", \"0\"\\nOutput: \"0\"\\nExpected: \"0\"\\n\\nIncase has any idea?"
                    }
                ]
            },
            {
                "id": 1692419,
                "content": [
                    {
                        "username": "akashgupta29",
                        "content": "If the two given strings are sparse strings. Then which data structure would be perfect for this problem ?"
                    },
                    {
                        "username": "ProfNandaa",
                        "content": "I think this _problem_ is wrongly categorized as `medium`. Should be `easy`."
                    },
                    {
                        "username": "yabbadabbadoo123",
                        "content": "Not if you want to solve it the way the creator intended."
                    },
                    {
                        "username": "raisfeldori",
                        "content": "wtf, the code says num1 and num2 cannot go above 200, but after submiting i failed at:\nnum1 = \"123456789\"\nnum2 = \"987654321\"\nexpected = \"121932631112635269\"\n\ni am very lucky that this can be solved by just incresing the i32 to an i64, but if this was any higher then i would've failed and had to completly redesign my algorithm to work for numbers over 2 ^ 64 - 1.\n\nedit: this happend, i submited the same thiing but failed at:\nnum1 = \"498828660196\"\nnum2 = \"840477629533\"\nexpected = \"419254329864656431168468\"\n\nat this point i need to use u128, because even u64 is too small for the numbers they use, at some point, i'm just expecting to find here \"9999999999999999999999999999999999999999999999999\" even though THE QUESTION SAYS NUM1 AND NUM2 CAN'T GO ABOVE 200!!!!!!!\n\nedit: I FUCKING SAID IT, I AM SO FUCKING PISSED, I AM USING u128 AND EVEN THAT ISN'T ENOUGH AT THIS POINT, FUCK THIS,  EVEN u128 iS TOO LITTLE, I\"M JUST GONNA MAKE AN EDGECASE FOR THAT NUMBER AND THAT's IT"
                    },
                    {
                        "username": "Husoski",
                        "content": "Read the problem statement.  The second paragraph says, \"Note: You must not use any built-in BigInteger library or convert the inputs to integer directly.\"\\n\\nAlso, the Constraints stay that the *lengths* of num1 and num2 are 200 or less, not their values.  "
                    },
                    {
                        "username": "Ashnu_B",
                        "content": "This should be marked as hard due to tricky implementation"
                    },
                    {
                        "username": "gamersulwood2900",
                        "content": "num1 = \"123456789\"\\nnum2 = \"987654321\"\\nOutput = \"121932631112635260\"\\nExpected = \"121932631112635269\"\\nseriously, LeetCode? How am i supposed to code a program that is able to formulate an answer bigger than the 64 bit integer limit?"
                    },
                    {
                        "username": "garvitagrawal_02",
                        "content": "that\\'s why string format is used"
                    },
                    {
                        "username": "f-kravchenko",
                        "content": "nice question. have learned the FFT"
                    },
                    {
                        "username": "Husoski",
                        "content": "Thumbs up for that!  I know the theory behind it, but never have written code for FFT multiplication.  Did you generate your own sines and cosines, or use sin() and/or cos() from the math library? "
                    },
                    {
                        "username": "ShashidharAngadi",
                        "content": "Do not try to solve this by converting to int mechanism \\uD83E\\uDD26\\u200D\\u2642\\uFE0F\\uD83E\\uDD26\\u200D\\u2642\\uFE0F. Read the constraints carefully."
                    },
                    {
                        "username": "antonpinchuk",
                        "content": "You can do like machine does, convert into binary then use bit shift.\\nI was lazy, my solution is like common, but I just put digits into reversed list of int\\'s."
                    },
                    {
                        "username": "hungrypanda",
                        "content": "Is this an arbitrary number?\\nWould you think about this problem differently if the max length was different or not given?"
                    },
                    {
                        "username": "Vidushak",
                        "content": "I am using Java as my coding language. I didn't see anyone running into this problem though.\\n\\nInput: \"0\", \"0\"\\nOutput: \"0\"\\nExpected: \"0\"\\n\\nIncase has any idea?"
                    }
                ]
            },
            {
                "id": 1573470,
                "content": [
                    {
                        "username": "akashgupta29",
                        "content": "If the two given strings are sparse strings. Then which data structure would be perfect for this problem ?"
                    },
                    {
                        "username": "ProfNandaa",
                        "content": "I think this _problem_ is wrongly categorized as `medium`. Should be `easy`."
                    },
                    {
                        "username": "yabbadabbadoo123",
                        "content": "Not if you want to solve it the way the creator intended."
                    },
                    {
                        "username": "raisfeldori",
                        "content": "wtf, the code says num1 and num2 cannot go above 200, but after submiting i failed at:\nnum1 = \"123456789\"\nnum2 = \"987654321\"\nexpected = \"121932631112635269\"\n\ni am very lucky that this can be solved by just incresing the i32 to an i64, but if this was any higher then i would've failed and had to completly redesign my algorithm to work for numbers over 2 ^ 64 - 1.\n\nedit: this happend, i submited the same thiing but failed at:\nnum1 = \"498828660196\"\nnum2 = \"840477629533\"\nexpected = \"419254329864656431168468\"\n\nat this point i need to use u128, because even u64 is too small for the numbers they use, at some point, i'm just expecting to find here \"9999999999999999999999999999999999999999999999999\" even though THE QUESTION SAYS NUM1 AND NUM2 CAN'T GO ABOVE 200!!!!!!!\n\nedit: I FUCKING SAID IT, I AM SO FUCKING PISSED, I AM USING u128 AND EVEN THAT ISN'T ENOUGH AT THIS POINT, FUCK THIS,  EVEN u128 iS TOO LITTLE, I\"M JUST GONNA MAKE AN EDGECASE FOR THAT NUMBER AND THAT's IT"
                    },
                    {
                        "username": "Husoski",
                        "content": "Read the problem statement.  The second paragraph says, \"Note: You must not use any built-in BigInteger library or convert the inputs to integer directly.\"\\n\\nAlso, the Constraints stay that the *lengths* of num1 and num2 are 200 or less, not their values.  "
                    },
                    {
                        "username": "Ashnu_B",
                        "content": "This should be marked as hard due to tricky implementation"
                    },
                    {
                        "username": "gamersulwood2900",
                        "content": "num1 = \"123456789\"\\nnum2 = \"987654321\"\\nOutput = \"121932631112635260\"\\nExpected = \"121932631112635269\"\\nseriously, LeetCode? How am i supposed to code a program that is able to formulate an answer bigger than the 64 bit integer limit?"
                    },
                    {
                        "username": "garvitagrawal_02",
                        "content": "that\\'s why string format is used"
                    },
                    {
                        "username": "f-kravchenko",
                        "content": "nice question. have learned the FFT"
                    },
                    {
                        "username": "Husoski",
                        "content": "Thumbs up for that!  I know the theory behind it, but never have written code for FFT multiplication.  Did you generate your own sines and cosines, or use sin() and/or cos() from the math library? "
                    },
                    {
                        "username": "ShashidharAngadi",
                        "content": "Do not try to solve this by converting to int mechanism \\uD83E\\uDD26\\u200D\\u2642\\uFE0F\\uD83E\\uDD26\\u200D\\u2642\\uFE0F. Read the constraints carefully."
                    },
                    {
                        "username": "antonpinchuk",
                        "content": "You can do like machine does, convert into binary then use bit shift.\\nI was lazy, my solution is like common, but I just put digits into reversed list of int\\'s."
                    },
                    {
                        "username": "hungrypanda",
                        "content": "Is this an arbitrary number?\\nWould you think about this problem differently if the max length was different or not given?"
                    },
                    {
                        "username": "Vidushak",
                        "content": "I am using Java as my coding language. I didn't see anyone running into this problem though.\\n\\nInput: \"0\", \"0\"\\nOutput: \"0\"\\nExpected: \"0\"\\n\\nIncase has any idea?"
                    }
                ]
            },
            {
                "id": 1571106,
                "content": [
                    {
                        "username": "akashgupta29",
                        "content": "If the two given strings are sparse strings. Then which data structure would be perfect for this problem ?"
                    },
                    {
                        "username": "ProfNandaa",
                        "content": "I think this _problem_ is wrongly categorized as `medium`. Should be `easy`."
                    },
                    {
                        "username": "yabbadabbadoo123",
                        "content": "Not if you want to solve it the way the creator intended."
                    },
                    {
                        "username": "raisfeldori",
                        "content": "wtf, the code says num1 and num2 cannot go above 200, but after submiting i failed at:\nnum1 = \"123456789\"\nnum2 = \"987654321\"\nexpected = \"121932631112635269\"\n\ni am very lucky that this can be solved by just incresing the i32 to an i64, but if this was any higher then i would've failed and had to completly redesign my algorithm to work for numbers over 2 ^ 64 - 1.\n\nedit: this happend, i submited the same thiing but failed at:\nnum1 = \"498828660196\"\nnum2 = \"840477629533\"\nexpected = \"419254329864656431168468\"\n\nat this point i need to use u128, because even u64 is too small for the numbers they use, at some point, i'm just expecting to find here \"9999999999999999999999999999999999999999999999999\" even though THE QUESTION SAYS NUM1 AND NUM2 CAN'T GO ABOVE 200!!!!!!!\n\nedit: I FUCKING SAID IT, I AM SO FUCKING PISSED, I AM USING u128 AND EVEN THAT ISN'T ENOUGH AT THIS POINT, FUCK THIS,  EVEN u128 iS TOO LITTLE, I\"M JUST GONNA MAKE AN EDGECASE FOR THAT NUMBER AND THAT's IT"
                    },
                    {
                        "username": "Husoski",
                        "content": "Read the problem statement.  The second paragraph says, \"Note: You must not use any built-in BigInteger library or convert the inputs to integer directly.\"\\n\\nAlso, the Constraints stay that the *lengths* of num1 and num2 are 200 or less, not their values.  "
                    },
                    {
                        "username": "Ashnu_B",
                        "content": "This should be marked as hard due to tricky implementation"
                    },
                    {
                        "username": "gamersulwood2900",
                        "content": "num1 = \"123456789\"\\nnum2 = \"987654321\"\\nOutput = \"121932631112635260\"\\nExpected = \"121932631112635269\"\\nseriously, LeetCode? How am i supposed to code a program that is able to formulate an answer bigger than the 64 bit integer limit?"
                    },
                    {
                        "username": "garvitagrawal_02",
                        "content": "that\\'s why string format is used"
                    },
                    {
                        "username": "f-kravchenko",
                        "content": "nice question. have learned the FFT"
                    },
                    {
                        "username": "Husoski",
                        "content": "Thumbs up for that!  I know the theory behind it, but never have written code for FFT multiplication.  Did you generate your own sines and cosines, or use sin() and/or cos() from the math library? "
                    },
                    {
                        "username": "ShashidharAngadi",
                        "content": "Do not try to solve this by converting to int mechanism \\uD83E\\uDD26\\u200D\\u2642\\uFE0F\\uD83E\\uDD26\\u200D\\u2642\\uFE0F. Read the constraints carefully."
                    },
                    {
                        "username": "antonpinchuk",
                        "content": "You can do like machine does, convert into binary then use bit shift.\\nI was lazy, my solution is like common, but I just put digits into reversed list of int\\'s."
                    },
                    {
                        "username": "hungrypanda",
                        "content": "Is this an arbitrary number?\\nWould you think about this problem differently if the max length was different or not given?"
                    },
                    {
                        "username": "Vidushak",
                        "content": "I am using Java as my coding language. I didn't see anyone running into this problem though.\\n\\nInput: \"0\", \"0\"\\nOutput: \"0\"\\nExpected: \"0\"\\n\\nIncase has any idea?"
                    }
                ]
            },
            {
                "id": 1831882,
                "content": [
                    {
                        "username": "AdeebHaider",
                        "content": "Useless and dumb question"
                    },
                    {
                        "username": "vik24k",
                        "content": "This MUST be a joke. This is not even a easy question, it\\'s a BASIC one. How can this question be marked as medium difficulty? \\n"
                    },
                    {
                        "username": "average_leetcoder",
                        "content": "[@KershKersh](/KershKersh) loool"
                    },
                    {
                        "username": "KershKersh",
                        "content": "It\\'s called reading the second sentence."
                    },
                    {
                        "username": "SahilNikam",
                        "content": "Unlike other solutions I solved it like we used to do multiplication on paper, multiplying individual with all of num1 and maintaining carry. It took me around 4-5 hours to come up with proper solution but I can't believe that I solved it with this method.  \nIt's very satisfying that you imagine some solution and you work on it and after try and try finally you get the perfect solution. although I wrote 132 lines  of code but I'm glad that solved it and it beats 51%  java solutions."
                    },
                    {
                        "username": "Otter9483",
                        "content": "Why?"
                    },
                    {
                        "username": "KedarKK1",
                        "content": "Corruption and dishonesty are the silent thieves of trust and integrity, leaving behind a trail of broken faith. Because of some cheaters out time-complexity becomes bad"
                    },
                    {
                        "username": "neizod",
                        "content": "what aspect of this problem help me be a better interviewee (or even being a better programmer)? the standard big-int lib is already good and handle every edge cases. why re-invent the fucking wheel???"
                    },
                    {
                        "username": "TasneemAyham",
                        "content": "How the hell is my only problem with this the ZERO?? \\nI have an if condition set at the start of my program...\\nif(num1 == \"0\" || num2 == \"0\") return \"0\";\\nBut it failed when the test case was \"0\" and \"9133\". I tried entering other values like \"9333\" and it also failed. I don\\'t know what\\'s wrong. May anyone please help???"
                    },
                    {
                        "username": "Shashwat_728",
                        "content": "Are num1 and num2 always of the same size?"
                    },
                    {
                        "username": "otmanewahdani",
                        "content": "this is really a great a question but there should be a mechanism by which to check the submissions that don\\'t follow the rules. i.e. using int() to convert the numbers"
                    },
                    {
                        "username": "Weildcard",
                        "content": "This problem statement is so vague.  I thought it meant to break the strings down to digits, convert the digits, assemble the numbers, multiply them, and convert the product to a string digit by digit.  Using mod 10, etc.  Which doesn\\'t DIRECTLY convert the inputs to ints, so it follows the directions.  But no.\\n\\nThe right way to write the problem description would be to say something like:\\n\\nYou are not allowed to use the multiplication operator anywhere in your solution.  You can only make use of the functions \\'multiply_chars(a, b)\\' and \\'add_chars(a, b)\\' each of which accepts two characters (or two one-character strings depending on your programming language) and returns a two-character string (or maybe tuple of chars?) as the result."
                    }
                ]
            },
            {
                "id": 1738328,
                "content": [
                    {
                        "username": "AdeebHaider",
                        "content": "Useless and dumb question"
                    },
                    {
                        "username": "vik24k",
                        "content": "This MUST be a joke. This is not even a easy question, it\\'s a BASIC one. How can this question be marked as medium difficulty? \\n"
                    },
                    {
                        "username": "average_leetcoder",
                        "content": "[@KershKersh](/KershKersh) loool"
                    },
                    {
                        "username": "KershKersh",
                        "content": "It\\'s called reading the second sentence."
                    },
                    {
                        "username": "SahilNikam",
                        "content": "Unlike other solutions I solved it like we used to do multiplication on paper, multiplying individual with all of num1 and maintaining carry. It took me around 4-5 hours to come up with proper solution but I can't believe that I solved it with this method.  \nIt's very satisfying that you imagine some solution and you work on it and after try and try finally you get the perfect solution. although I wrote 132 lines  of code but I'm glad that solved it and it beats 51%  java solutions."
                    },
                    {
                        "username": "Otter9483",
                        "content": "Why?"
                    },
                    {
                        "username": "KedarKK1",
                        "content": "Corruption and dishonesty are the silent thieves of trust and integrity, leaving behind a trail of broken faith. Because of some cheaters out time-complexity becomes bad"
                    },
                    {
                        "username": "neizod",
                        "content": "what aspect of this problem help me be a better interviewee (or even being a better programmer)? the standard big-int lib is already good and handle every edge cases. why re-invent the fucking wheel???"
                    },
                    {
                        "username": "TasneemAyham",
                        "content": "How the hell is my only problem with this the ZERO?? \\nI have an if condition set at the start of my program...\\nif(num1 == \"0\" || num2 == \"0\") return \"0\";\\nBut it failed when the test case was \"0\" and \"9133\". I tried entering other values like \"9333\" and it also failed. I don\\'t know what\\'s wrong. May anyone please help???"
                    },
                    {
                        "username": "Shashwat_728",
                        "content": "Are num1 and num2 always of the same size?"
                    },
                    {
                        "username": "otmanewahdani",
                        "content": "this is really a great a question but there should be a mechanism by which to check the submissions that don\\'t follow the rules. i.e. using int() to convert the numbers"
                    },
                    {
                        "username": "Weildcard",
                        "content": "This problem statement is so vague.  I thought it meant to break the strings down to digits, convert the digits, assemble the numbers, multiply them, and convert the product to a string digit by digit.  Using mod 10, etc.  Which doesn\\'t DIRECTLY convert the inputs to ints, so it follows the directions.  But no.\\n\\nThe right way to write the problem description would be to say something like:\\n\\nYou are not allowed to use the multiplication operator anywhere in your solution.  You can only make use of the functions \\'multiply_chars(a, b)\\' and \\'add_chars(a, b)\\' each of which accepts two characters (or two one-character strings depending on your programming language) and returns a two-character string (or maybe tuple of chars?) as the result."
                    }
                ]
            },
            {
                "id": 2058986,
                "content": [
                    {
                        "username": "AdeebHaider",
                        "content": "Useless and dumb question"
                    },
                    {
                        "username": "vik24k",
                        "content": "This MUST be a joke. This is not even a easy question, it\\'s a BASIC one. How can this question be marked as medium difficulty? \\n"
                    },
                    {
                        "username": "average_leetcoder",
                        "content": "[@KershKersh](/KershKersh) loool"
                    },
                    {
                        "username": "KershKersh",
                        "content": "It\\'s called reading the second sentence."
                    },
                    {
                        "username": "SahilNikam",
                        "content": "Unlike other solutions I solved it like we used to do multiplication on paper, multiplying individual with all of num1 and maintaining carry. It took me around 4-5 hours to come up with proper solution but I can't believe that I solved it with this method.  \nIt's very satisfying that you imagine some solution and you work on it and after try and try finally you get the perfect solution. although I wrote 132 lines  of code but I'm glad that solved it and it beats 51%  java solutions."
                    },
                    {
                        "username": "Otter9483",
                        "content": "Why?"
                    },
                    {
                        "username": "KedarKK1",
                        "content": "Corruption and dishonesty are the silent thieves of trust and integrity, leaving behind a trail of broken faith. Because of some cheaters out time-complexity becomes bad"
                    },
                    {
                        "username": "neizod",
                        "content": "what aspect of this problem help me be a better interviewee (or even being a better programmer)? the standard big-int lib is already good and handle every edge cases. why re-invent the fucking wheel???"
                    },
                    {
                        "username": "TasneemAyham",
                        "content": "How the hell is my only problem with this the ZERO?? \\nI have an if condition set at the start of my program...\\nif(num1 == \"0\" || num2 == \"0\") return \"0\";\\nBut it failed when the test case was \"0\" and \"9133\". I tried entering other values like \"9333\" and it also failed. I don\\'t know what\\'s wrong. May anyone please help???"
                    },
                    {
                        "username": "Shashwat_728",
                        "content": "Are num1 and num2 always of the same size?"
                    },
                    {
                        "username": "otmanewahdani",
                        "content": "this is really a great a question but there should be a mechanism by which to check the submissions that don\\'t follow the rules. i.e. using int() to convert the numbers"
                    },
                    {
                        "username": "Weildcard",
                        "content": "This problem statement is so vague.  I thought it meant to break the strings down to digits, convert the digits, assemble the numbers, multiply them, and convert the product to a string digit by digit.  Using mod 10, etc.  Which doesn\\'t DIRECTLY convert the inputs to ints, so it follows the directions.  But no.\\n\\nThe right way to write the problem description would be to say something like:\\n\\nYou are not allowed to use the multiplication operator anywhere in your solution.  You can only make use of the functions \\'multiply_chars(a, b)\\' and \\'add_chars(a, b)\\' each of which accepts two characters (or two one-character strings depending on your programming language) and returns a two-character string (or maybe tuple of chars?) as the result."
                    }
                ]
            },
            {
                "id": 2045747,
                "content": [
                    {
                        "username": "AdeebHaider",
                        "content": "Useless and dumb question"
                    },
                    {
                        "username": "vik24k",
                        "content": "This MUST be a joke. This is not even a easy question, it\\'s a BASIC one. How can this question be marked as medium difficulty? \\n"
                    },
                    {
                        "username": "average_leetcoder",
                        "content": "[@KershKersh](/KershKersh) loool"
                    },
                    {
                        "username": "KershKersh",
                        "content": "It\\'s called reading the second sentence."
                    },
                    {
                        "username": "SahilNikam",
                        "content": "Unlike other solutions I solved it like we used to do multiplication on paper, multiplying individual with all of num1 and maintaining carry. It took me around 4-5 hours to come up with proper solution but I can't believe that I solved it with this method.  \nIt's very satisfying that you imagine some solution and you work on it and after try and try finally you get the perfect solution. although I wrote 132 lines  of code but I'm glad that solved it and it beats 51%  java solutions."
                    },
                    {
                        "username": "Otter9483",
                        "content": "Why?"
                    },
                    {
                        "username": "KedarKK1",
                        "content": "Corruption and dishonesty are the silent thieves of trust and integrity, leaving behind a trail of broken faith. Because of some cheaters out time-complexity becomes bad"
                    },
                    {
                        "username": "neizod",
                        "content": "what aspect of this problem help me be a better interviewee (or even being a better programmer)? the standard big-int lib is already good and handle every edge cases. why re-invent the fucking wheel???"
                    },
                    {
                        "username": "TasneemAyham",
                        "content": "How the hell is my only problem with this the ZERO?? \\nI have an if condition set at the start of my program...\\nif(num1 == \"0\" || num2 == \"0\") return \"0\";\\nBut it failed when the test case was \"0\" and \"9133\". I tried entering other values like \"9333\" and it also failed. I don\\'t know what\\'s wrong. May anyone please help???"
                    },
                    {
                        "username": "Shashwat_728",
                        "content": "Are num1 and num2 always of the same size?"
                    },
                    {
                        "username": "otmanewahdani",
                        "content": "this is really a great a question but there should be a mechanism by which to check the submissions that don\\'t follow the rules. i.e. using int() to convert the numbers"
                    },
                    {
                        "username": "Weildcard",
                        "content": "This problem statement is so vague.  I thought it meant to break the strings down to digits, convert the digits, assemble the numbers, multiply them, and convert the product to a string digit by digit.  Using mod 10, etc.  Which doesn\\'t DIRECTLY convert the inputs to ints, so it follows the directions.  But no.\\n\\nThe right way to write the problem description would be to say something like:\\n\\nYou are not allowed to use the multiplication operator anywhere in your solution.  You can only make use of the functions \\'multiply_chars(a, b)\\' and \\'add_chars(a, b)\\' each of which accepts two characters (or two one-character strings depending on your programming language) and returns a two-character string (or maybe tuple of chars?) as the result."
                    }
                ]
            },
            {
                "id": 2039158,
                "content": [
                    {
                        "username": "AdeebHaider",
                        "content": "Useless and dumb question"
                    },
                    {
                        "username": "vik24k",
                        "content": "This MUST be a joke. This is not even a easy question, it\\'s a BASIC one. How can this question be marked as medium difficulty? \\n"
                    },
                    {
                        "username": "average_leetcoder",
                        "content": "[@KershKersh](/KershKersh) loool"
                    },
                    {
                        "username": "KershKersh",
                        "content": "It\\'s called reading the second sentence."
                    },
                    {
                        "username": "SahilNikam",
                        "content": "Unlike other solutions I solved it like we used to do multiplication on paper, multiplying individual with all of num1 and maintaining carry. It took me around 4-5 hours to come up with proper solution but I can't believe that I solved it with this method.  \nIt's very satisfying that you imagine some solution and you work on it and after try and try finally you get the perfect solution. although I wrote 132 lines  of code but I'm glad that solved it and it beats 51%  java solutions."
                    },
                    {
                        "username": "Otter9483",
                        "content": "Why?"
                    },
                    {
                        "username": "KedarKK1",
                        "content": "Corruption and dishonesty are the silent thieves of trust and integrity, leaving behind a trail of broken faith. Because of some cheaters out time-complexity becomes bad"
                    },
                    {
                        "username": "neizod",
                        "content": "what aspect of this problem help me be a better interviewee (or even being a better programmer)? the standard big-int lib is already good and handle every edge cases. why re-invent the fucking wheel???"
                    },
                    {
                        "username": "TasneemAyham",
                        "content": "How the hell is my only problem with this the ZERO?? \\nI have an if condition set at the start of my program...\\nif(num1 == \"0\" || num2 == \"0\") return \"0\";\\nBut it failed when the test case was \"0\" and \"9133\". I tried entering other values like \"9333\" and it also failed. I don\\'t know what\\'s wrong. May anyone please help???"
                    },
                    {
                        "username": "Shashwat_728",
                        "content": "Are num1 and num2 always of the same size?"
                    },
                    {
                        "username": "otmanewahdani",
                        "content": "this is really a great a question but there should be a mechanism by which to check the submissions that don\\'t follow the rules. i.e. using int() to convert the numbers"
                    },
                    {
                        "username": "Weildcard",
                        "content": "This problem statement is so vague.  I thought it meant to break the strings down to digits, convert the digits, assemble the numbers, multiply them, and convert the product to a string digit by digit.  Using mod 10, etc.  Which doesn\\'t DIRECTLY convert the inputs to ints, so it follows the directions.  But no.\\n\\nThe right way to write the problem description would be to say something like:\\n\\nYou are not allowed to use the multiplication operator anywhere in your solution.  You can only make use of the functions \\'multiply_chars(a, b)\\' and \\'add_chars(a, b)\\' each of which accepts two characters (or two one-character strings depending on your programming language) and returns a two-character string (or maybe tuple of chars?) as the result."
                    }
                ]
            },
            {
                "id": 2037276,
                "content": [
                    {
                        "username": "AdeebHaider",
                        "content": "Useless and dumb question"
                    },
                    {
                        "username": "vik24k",
                        "content": "This MUST be a joke. This is not even a easy question, it\\'s a BASIC one. How can this question be marked as medium difficulty? \\n"
                    },
                    {
                        "username": "average_leetcoder",
                        "content": "[@KershKersh](/KershKersh) loool"
                    },
                    {
                        "username": "KershKersh",
                        "content": "It\\'s called reading the second sentence."
                    },
                    {
                        "username": "SahilNikam",
                        "content": "Unlike other solutions I solved it like we used to do multiplication on paper, multiplying individual with all of num1 and maintaining carry. It took me around 4-5 hours to come up with proper solution but I can't believe that I solved it with this method.  \nIt's very satisfying that you imagine some solution and you work on it and after try and try finally you get the perfect solution. although I wrote 132 lines  of code but I'm glad that solved it and it beats 51%  java solutions."
                    },
                    {
                        "username": "Otter9483",
                        "content": "Why?"
                    },
                    {
                        "username": "KedarKK1",
                        "content": "Corruption and dishonesty are the silent thieves of trust and integrity, leaving behind a trail of broken faith. Because of some cheaters out time-complexity becomes bad"
                    },
                    {
                        "username": "neizod",
                        "content": "what aspect of this problem help me be a better interviewee (or even being a better programmer)? the standard big-int lib is already good and handle every edge cases. why re-invent the fucking wheel???"
                    },
                    {
                        "username": "TasneemAyham",
                        "content": "How the hell is my only problem with this the ZERO?? \\nI have an if condition set at the start of my program...\\nif(num1 == \"0\" || num2 == \"0\") return \"0\";\\nBut it failed when the test case was \"0\" and \"9133\". I tried entering other values like \"9333\" and it also failed. I don\\'t know what\\'s wrong. May anyone please help???"
                    },
                    {
                        "username": "Shashwat_728",
                        "content": "Are num1 and num2 always of the same size?"
                    },
                    {
                        "username": "otmanewahdani",
                        "content": "this is really a great a question but there should be a mechanism by which to check the submissions that don\\'t follow the rules. i.e. using int() to convert the numbers"
                    },
                    {
                        "username": "Weildcard",
                        "content": "This problem statement is so vague.  I thought it meant to break the strings down to digits, convert the digits, assemble the numbers, multiply them, and convert the product to a string digit by digit.  Using mod 10, etc.  Which doesn\\'t DIRECTLY convert the inputs to ints, so it follows the directions.  But no.\\n\\nThe right way to write the problem description would be to say something like:\\n\\nYou are not allowed to use the multiplication operator anywhere in your solution.  You can only make use of the functions \\'multiply_chars(a, b)\\' and \\'add_chars(a, b)\\' each of which accepts two characters (or two one-character strings depending on your programming language) and returns a two-character string (or maybe tuple of chars?) as the result."
                    }
                ]
            },
            {
                "id": 2034772,
                "content": [
                    {
                        "username": "AdeebHaider",
                        "content": "Useless and dumb question"
                    },
                    {
                        "username": "vik24k",
                        "content": "This MUST be a joke. This is not even a easy question, it\\'s a BASIC one. How can this question be marked as medium difficulty? \\n"
                    },
                    {
                        "username": "average_leetcoder",
                        "content": "[@KershKersh](/KershKersh) loool"
                    },
                    {
                        "username": "KershKersh",
                        "content": "It\\'s called reading the second sentence."
                    },
                    {
                        "username": "SahilNikam",
                        "content": "Unlike other solutions I solved it like we used to do multiplication on paper, multiplying individual with all of num1 and maintaining carry. It took me around 4-5 hours to come up with proper solution but I can't believe that I solved it with this method.  \nIt's very satisfying that you imagine some solution and you work on it and after try and try finally you get the perfect solution. although I wrote 132 lines  of code but I'm glad that solved it and it beats 51%  java solutions."
                    },
                    {
                        "username": "Otter9483",
                        "content": "Why?"
                    },
                    {
                        "username": "KedarKK1",
                        "content": "Corruption and dishonesty are the silent thieves of trust and integrity, leaving behind a trail of broken faith. Because of some cheaters out time-complexity becomes bad"
                    },
                    {
                        "username": "neizod",
                        "content": "what aspect of this problem help me be a better interviewee (or even being a better programmer)? the standard big-int lib is already good and handle every edge cases. why re-invent the fucking wheel???"
                    },
                    {
                        "username": "TasneemAyham",
                        "content": "How the hell is my only problem with this the ZERO?? \\nI have an if condition set at the start of my program...\\nif(num1 == \"0\" || num2 == \"0\") return \"0\";\\nBut it failed when the test case was \"0\" and \"9133\". I tried entering other values like \"9333\" and it also failed. I don\\'t know what\\'s wrong. May anyone please help???"
                    },
                    {
                        "username": "Shashwat_728",
                        "content": "Are num1 and num2 always of the same size?"
                    },
                    {
                        "username": "otmanewahdani",
                        "content": "this is really a great a question but there should be a mechanism by which to check the submissions that don\\'t follow the rules. i.e. using int() to convert the numbers"
                    },
                    {
                        "username": "Weildcard",
                        "content": "This problem statement is so vague.  I thought it meant to break the strings down to digits, convert the digits, assemble the numbers, multiply them, and convert the product to a string digit by digit.  Using mod 10, etc.  Which doesn\\'t DIRECTLY convert the inputs to ints, so it follows the directions.  But no.\\n\\nThe right way to write the problem description would be to say something like:\\n\\nYou are not allowed to use the multiplication operator anywhere in your solution.  You can only make use of the functions \\'multiply_chars(a, b)\\' and \\'add_chars(a, b)\\' each of which accepts two characters (or two one-character strings depending on your programming language) and returns a two-character string (or maybe tuple of chars?) as the result."
                    }
                ]
            },
            {
                "id": 2013564,
                "content": [
                    {
                        "username": "AdeebHaider",
                        "content": "Useless and dumb question"
                    },
                    {
                        "username": "vik24k",
                        "content": "This MUST be a joke. This is not even a easy question, it\\'s a BASIC one. How can this question be marked as medium difficulty? \\n"
                    },
                    {
                        "username": "average_leetcoder",
                        "content": "[@KershKersh](/KershKersh) loool"
                    },
                    {
                        "username": "KershKersh",
                        "content": "It\\'s called reading the second sentence."
                    },
                    {
                        "username": "SahilNikam",
                        "content": "Unlike other solutions I solved it like we used to do multiplication on paper, multiplying individual with all of num1 and maintaining carry. It took me around 4-5 hours to come up with proper solution but I can't believe that I solved it with this method.  \nIt's very satisfying that you imagine some solution and you work on it and after try and try finally you get the perfect solution. although I wrote 132 lines  of code but I'm glad that solved it and it beats 51%  java solutions."
                    },
                    {
                        "username": "Otter9483",
                        "content": "Why?"
                    },
                    {
                        "username": "KedarKK1",
                        "content": "Corruption and dishonesty are the silent thieves of trust and integrity, leaving behind a trail of broken faith. Because of some cheaters out time-complexity becomes bad"
                    },
                    {
                        "username": "neizod",
                        "content": "what aspect of this problem help me be a better interviewee (or even being a better programmer)? the standard big-int lib is already good and handle every edge cases. why re-invent the fucking wheel???"
                    },
                    {
                        "username": "TasneemAyham",
                        "content": "How the hell is my only problem with this the ZERO?? \\nI have an if condition set at the start of my program...\\nif(num1 == \"0\" || num2 == \"0\") return \"0\";\\nBut it failed when the test case was \"0\" and \"9133\". I tried entering other values like \"9333\" and it also failed. I don\\'t know what\\'s wrong. May anyone please help???"
                    },
                    {
                        "username": "Shashwat_728",
                        "content": "Are num1 and num2 always of the same size?"
                    },
                    {
                        "username": "otmanewahdani",
                        "content": "this is really a great a question but there should be a mechanism by which to check the submissions that don\\'t follow the rules. i.e. using int() to convert the numbers"
                    },
                    {
                        "username": "Weildcard",
                        "content": "This problem statement is so vague.  I thought it meant to break the strings down to digits, convert the digits, assemble the numbers, multiply them, and convert the product to a string digit by digit.  Using mod 10, etc.  Which doesn\\'t DIRECTLY convert the inputs to ints, so it follows the directions.  But no.\\n\\nThe right way to write the problem description would be to say something like:\\n\\nYou are not allowed to use the multiplication operator anywhere in your solution.  You can only make use of the functions \\'multiply_chars(a, b)\\' and \\'add_chars(a, b)\\' each of which accepts two characters (or two one-character strings depending on your programming language) and returns a two-character string (or maybe tuple of chars?) as the result."
                    }
                ]
            },
            {
                "id": 1987852,
                "content": [
                    {
                        "username": "AdeebHaider",
                        "content": "Useless and dumb question"
                    },
                    {
                        "username": "vik24k",
                        "content": "This MUST be a joke. This is not even a easy question, it\\'s a BASIC one. How can this question be marked as medium difficulty? \\n"
                    },
                    {
                        "username": "average_leetcoder",
                        "content": "[@KershKersh](/KershKersh) loool"
                    },
                    {
                        "username": "KershKersh",
                        "content": "It\\'s called reading the second sentence."
                    },
                    {
                        "username": "SahilNikam",
                        "content": "Unlike other solutions I solved it like we used to do multiplication on paper, multiplying individual with all of num1 and maintaining carry. It took me around 4-5 hours to come up with proper solution but I can't believe that I solved it with this method.  \nIt's very satisfying that you imagine some solution and you work on it and after try and try finally you get the perfect solution. although I wrote 132 lines  of code but I'm glad that solved it and it beats 51%  java solutions."
                    },
                    {
                        "username": "Otter9483",
                        "content": "Why?"
                    },
                    {
                        "username": "KedarKK1",
                        "content": "Corruption and dishonesty are the silent thieves of trust and integrity, leaving behind a trail of broken faith. Because of some cheaters out time-complexity becomes bad"
                    },
                    {
                        "username": "neizod",
                        "content": "what aspect of this problem help me be a better interviewee (or even being a better programmer)? the standard big-int lib is already good and handle every edge cases. why re-invent the fucking wheel???"
                    },
                    {
                        "username": "TasneemAyham",
                        "content": "How the hell is my only problem with this the ZERO?? \\nI have an if condition set at the start of my program...\\nif(num1 == \"0\" || num2 == \"0\") return \"0\";\\nBut it failed when the test case was \"0\" and \"9133\". I tried entering other values like \"9333\" and it also failed. I don\\'t know what\\'s wrong. May anyone please help???"
                    },
                    {
                        "username": "Shashwat_728",
                        "content": "Are num1 and num2 always of the same size?"
                    },
                    {
                        "username": "otmanewahdani",
                        "content": "this is really a great a question but there should be a mechanism by which to check the submissions that don\\'t follow the rules. i.e. using int() to convert the numbers"
                    },
                    {
                        "username": "Weildcard",
                        "content": "This problem statement is so vague.  I thought it meant to break the strings down to digits, convert the digits, assemble the numbers, multiply them, and convert the product to a string digit by digit.  Using mod 10, etc.  Which doesn\\'t DIRECTLY convert the inputs to ints, so it follows the directions.  But no.\\n\\nThe right way to write the problem description would be to say something like:\\n\\nYou are not allowed to use the multiplication operator anywhere in your solution.  You can only make use of the functions \\'multiply_chars(a, b)\\' and \\'add_chars(a, b)\\' each of which accepts two characters (or two one-character strings depending on your programming language) and returns a two-character string (or maybe tuple of chars?) as the result."
                    }
                ]
            },
            {
                "id": 1979380,
                "content": [
                    {
                        "username": "AdeebHaider",
                        "content": "Useless and dumb question"
                    },
                    {
                        "username": "vik24k",
                        "content": "This MUST be a joke. This is not even a easy question, it\\'s a BASIC one. How can this question be marked as medium difficulty? \\n"
                    },
                    {
                        "username": "average_leetcoder",
                        "content": "[@KershKersh](/KershKersh) loool"
                    },
                    {
                        "username": "KershKersh",
                        "content": "It\\'s called reading the second sentence."
                    },
                    {
                        "username": "SahilNikam",
                        "content": "Unlike other solutions I solved it like we used to do multiplication on paper, multiplying individual with all of num1 and maintaining carry. It took me around 4-5 hours to come up with proper solution but I can't believe that I solved it with this method.  \nIt's very satisfying that you imagine some solution and you work on it and after try and try finally you get the perfect solution. although I wrote 132 lines  of code but I'm glad that solved it and it beats 51%  java solutions."
                    },
                    {
                        "username": "Otter9483",
                        "content": "Why?"
                    },
                    {
                        "username": "KedarKK1",
                        "content": "Corruption and dishonesty are the silent thieves of trust and integrity, leaving behind a trail of broken faith. Because of some cheaters out time-complexity becomes bad"
                    },
                    {
                        "username": "neizod",
                        "content": "what aspect of this problem help me be a better interviewee (or even being a better programmer)? the standard big-int lib is already good and handle every edge cases. why re-invent the fucking wheel???"
                    },
                    {
                        "username": "TasneemAyham",
                        "content": "How the hell is my only problem with this the ZERO?? \\nI have an if condition set at the start of my program...\\nif(num1 == \"0\" || num2 == \"0\") return \"0\";\\nBut it failed when the test case was \"0\" and \"9133\". I tried entering other values like \"9333\" and it also failed. I don\\'t know what\\'s wrong. May anyone please help???"
                    },
                    {
                        "username": "Shashwat_728",
                        "content": "Are num1 and num2 always of the same size?"
                    },
                    {
                        "username": "otmanewahdani",
                        "content": "this is really a great a question but there should be a mechanism by which to check the submissions that don\\'t follow the rules. i.e. using int() to convert the numbers"
                    },
                    {
                        "username": "Weildcard",
                        "content": "This problem statement is so vague.  I thought it meant to break the strings down to digits, convert the digits, assemble the numbers, multiply them, and convert the product to a string digit by digit.  Using mod 10, etc.  Which doesn\\'t DIRECTLY convert the inputs to ints, so it follows the directions.  But no.\\n\\nThe right way to write the problem description would be to say something like:\\n\\nYou are not allowed to use the multiplication operator anywhere in your solution.  You can only make use of the functions \\'multiply_chars(a, b)\\' and \\'add_chars(a, b)\\' each of which accepts two characters (or two one-character strings depending on your programming language) and returns a two-character string (or maybe tuple of chars?) as the result."
                    }
                ]
            },
            {
                "id": 1967223,
                "content": [
                    {
                        "username": "a_andreasian",
                        "content": "I managed to make the string - integers and calculate, but don't know how to make it a string. \n\nLol, I asked chatgpt to give a hint, except for sending the solution, and it got stuck! \n\nOr it runs a for-loop over an integer, or it says \"I'm sorry\" and uses \"\".join to use some mapping, over and over again. Then for-looping the int then again uses .join. \nIt doesn't even understand, if you were able to use join, you can use it to return the answer, instead of mapping some lambda function. \n\nYes, I'm a beginner, I study Python for 4 months, but that \"competitor of google\" is gonna make me \"lose my job\" in the future, oh hold my beer!\n\n"
                    },
                    {
                        "username": "Husoski",
                        "content": "`result = ''.join('0123456789'[digit] for digit in number)`\n...assuming that `number` is a list of integer digits in left-to-right order.  If you build the list in least-significant-first order, then reverse it with `result = result[::-1]`.  If you need to remove leading zeroes, then something like:\n`result = result.lstrip('0') or '0'`\n...where the `or 0` part is a tricky way to convert an empty result (the string was all zeroes) into a single '0'."
                    },
                    {
                        "username": "myahsine_2024",
                        "content": "Can someone tell me why this doesn\\'t work with bigger inputs? small numbers work fine. I also tried int.\\n        long num_1 = 0;\\n        long num_2 = 0;\\n        int len = num1.length()-1;\\n        int len2 = num2.length() - 1;\\n        for(int i = 0; i < num1.length(); i++){\\n            long mult = (long) Math.pow(10, len);\\n            num_1 += (num1.charAt(i) - \\'0\\') * mult;  \\n            len--;\\n        }\\n        for(int i = 0; i < num2.length(); i++){\\n            long mult = (long) Math.pow(10, len2);\\n            num_2 += (num2.charAt(i) - \\'0\\') * mult;\\n            len2--;\\n        }\\n        StringBuilder sb = new StringBuilder();\\n        sb.append(num_1*num_2);\\n\\n        return sb.toString();"
                    },
                    {
                        "username": "myahsine_2024",
                        "content": "[@Husoski](/Husoski) Great point thank you!"
                    },
                    {
                        "username": "Husoski",
                        "content": "I haven\\'t looked at all of the code, but one thing that obviously wrong is `Math.pow(10, len)`.  Math.pow() produces a double result, that that only has about 52 bits of precision.  Since `len` can be around 200 and each base 10 digit takes about 3.3 bits, that\\'s a 660 bit number.  The low 200 bits are all 0, so you\\'d need floating point with 660-220 = 440 bits of precision.  Double won\\'t work; and the 660 bit result won\\'t fit in a 64-bit long either."
                    },
                    {
                        "username": "eduard92",
                        "content": "worked on the 12th submission, I did my part\n\nI think in interview is good to discuss this one but the implementation is annoying and the only thing it tests is your attention to details.\nDiscussing the strategy to come to a result and some pseudo code should be enough. Like if the interviewer pulls random test cases after each implementation, that interview will last 3 hours."
                    },
                    {
                        "username": "eduard92",
                        "content": "My reaction to following sentence \"You must not use any built-in BigInteger library\" braaah, \"Acceptance Rate 39.3%\" okay.\n\nOn the good side, I am gonna learn a new way, on the bad side.. gonna spend 20 minutes reading the Editorial, probably I am gonna solve it just like I solved Binary Sum problem, need to carry a carry all over the place, if it works like this, it should be an easy problem then."
                    },
                    {
                        "username": "CalCreate",
                        "content": "Does anyone feel like this question kind of resembles Dynamic Programming in a way? "
                    },
                    {
                        "username": "AyushThakur-7",
                        "content": "In this question, we cannot use ASCII table?\\n"
                    },
                    {
                        "username": "tony7000",
                        "content": "\"You must not use any built-in BigInteger library or convert the inputs to integer directly\".\\n\\nWell, I just did. Thank you. "
                    },
                    {
                        "username": "itzRAYY",
                        "content": "import java.math.BigInteger;\\nclass Solution {\\n    public String multiply(String num1, String num2) {\\n        BigInteger n1 = new BigInteger(num1);\\n        BigInteger n2 = new BigInteger(num2);\\n        n2 = n1.multiply(n2);\\n        return \"\"+n2;\\n    }\\n}"
                    },
                    {
                        "username": "fedupwith060708",
                        "content": "class Solution {\\npublic:\\n    string multiply(string num1, string num2) {\\n        return ToString(ToInt(num1) * ToInt(num2));\\n    }\\n\\n    string ToString(uint64_t n)\\n    {\\n        if(n == 0) return string(\"0\");\\n\\n        string res = \"\";\\n        int size = 0;\\n        \\n        for(int i = 0; pow(10, i) <= n; ++i) ++size;\\n\\n        for(int i = size - 1; i >= 0; --i)\\n        {\\n            uint64_t digit = (uint64_t)(n / pow(10, i)) % 10;\\n            res += (char)digit+\\'0\\';\\n        }\\n\\n        \\n        return res;\\n    }\\n    \\n    uint64_t ToInt(string s)\\n    {\\n        uint64_t sum = 0;\\n        for(int i = s.size()-1; i >= 0; --i)\\n        {\\n            sum += (uint64_t)(s[s.size() - i - 1 ] - \\'0\\') * pow(10, i);\\n        }\\n\\n        return sum;\\n    }\\n};\\n\\nwhy does my solution fail in bigger numbers? \\nI\\'m stuck in 123456789*987654321\\n\\nit gives 121932631112635264 instead of 121932631112635269"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 what about solving this question with python"
                    }
                ]
            },
            {
                "id": 1960517,
                "content": [
                    {
                        "username": "a_andreasian",
                        "content": "I managed to make the string - integers and calculate, but don't know how to make it a string. \n\nLol, I asked chatgpt to give a hint, except for sending the solution, and it got stuck! \n\nOr it runs a for-loop over an integer, or it says \"I'm sorry\" and uses \"\".join to use some mapping, over and over again. Then for-looping the int then again uses .join. \nIt doesn't even understand, if you were able to use join, you can use it to return the answer, instead of mapping some lambda function. \n\nYes, I'm a beginner, I study Python for 4 months, but that \"competitor of google\" is gonna make me \"lose my job\" in the future, oh hold my beer!\n\n"
                    },
                    {
                        "username": "Husoski",
                        "content": "`result = ''.join('0123456789'[digit] for digit in number)`\n...assuming that `number` is a list of integer digits in left-to-right order.  If you build the list in least-significant-first order, then reverse it with `result = result[::-1]`.  If you need to remove leading zeroes, then something like:\n`result = result.lstrip('0') or '0'`\n...where the `or 0` part is a tricky way to convert an empty result (the string was all zeroes) into a single '0'."
                    },
                    {
                        "username": "myahsine_2024",
                        "content": "Can someone tell me why this doesn\\'t work with bigger inputs? small numbers work fine. I also tried int.\\n        long num_1 = 0;\\n        long num_2 = 0;\\n        int len = num1.length()-1;\\n        int len2 = num2.length() - 1;\\n        for(int i = 0; i < num1.length(); i++){\\n            long mult = (long) Math.pow(10, len);\\n            num_1 += (num1.charAt(i) - \\'0\\') * mult;  \\n            len--;\\n        }\\n        for(int i = 0; i < num2.length(); i++){\\n            long mult = (long) Math.pow(10, len2);\\n            num_2 += (num2.charAt(i) - \\'0\\') * mult;\\n            len2--;\\n        }\\n        StringBuilder sb = new StringBuilder();\\n        sb.append(num_1*num_2);\\n\\n        return sb.toString();"
                    },
                    {
                        "username": "myahsine_2024",
                        "content": "[@Husoski](/Husoski) Great point thank you!"
                    },
                    {
                        "username": "Husoski",
                        "content": "I haven\\'t looked at all of the code, but one thing that obviously wrong is `Math.pow(10, len)`.  Math.pow() produces a double result, that that only has about 52 bits of precision.  Since `len` can be around 200 and each base 10 digit takes about 3.3 bits, that\\'s a 660 bit number.  The low 200 bits are all 0, so you\\'d need floating point with 660-220 = 440 bits of precision.  Double won\\'t work; and the 660 bit result won\\'t fit in a 64-bit long either."
                    },
                    {
                        "username": "eduard92",
                        "content": "worked on the 12th submission, I did my part\n\nI think in interview is good to discuss this one but the implementation is annoying and the only thing it tests is your attention to details.\nDiscussing the strategy to come to a result and some pseudo code should be enough. Like if the interviewer pulls random test cases after each implementation, that interview will last 3 hours."
                    },
                    {
                        "username": "eduard92",
                        "content": "My reaction to following sentence \"You must not use any built-in BigInteger library\" braaah, \"Acceptance Rate 39.3%\" okay.\n\nOn the good side, I am gonna learn a new way, on the bad side.. gonna spend 20 minutes reading the Editorial, probably I am gonna solve it just like I solved Binary Sum problem, need to carry a carry all over the place, if it works like this, it should be an easy problem then."
                    },
                    {
                        "username": "CalCreate",
                        "content": "Does anyone feel like this question kind of resembles Dynamic Programming in a way? "
                    },
                    {
                        "username": "AyushThakur-7",
                        "content": "In this question, we cannot use ASCII table?\\n"
                    },
                    {
                        "username": "tony7000",
                        "content": "\"You must not use any built-in BigInteger library or convert the inputs to integer directly\".\\n\\nWell, I just did. Thank you. "
                    },
                    {
                        "username": "itzRAYY",
                        "content": "import java.math.BigInteger;\\nclass Solution {\\n    public String multiply(String num1, String num2) {\\n        BigInteger n1 = new BigInteger(num1);\\n        BigInteger n2 = new BigInteger(num2);\\n        n2 = n1.multiply(n2);\\n        return \"\"+n2;\\n    }\\n}"
                    },
                    {
                        "username": "fedupwith060708",
                        "content": "class Solution {\\npublic:\\n    string multiply(string num1, string num2) {\\n        return ToString(ToInt(num1) * ToInt(num2));\\n    }\\n\\n    string ToString(uint64_t n)\\n    {\\n        if(n == 0) return string(\"0\");\\n\\n        string res = \"\";\\n        int size = 0;\\n        \\n        for(int i = 0; pow(10, i) <= n; ++i) ++size;\\n\\n        for(int i = size - 1; i >= 0; --i)\\n        {\\n            uint64_t digit = (uint64_t)(n / pow(10, i)) % 10;\\n            res += (char)digit+\\'0\\';\\n        }\\n\\n        \\n        return res;\\n    }\\n    \\n    uint64_t ToInt(string s)\\n    {\\n        uint64_t sum = 0;\\n        for(int i = s.size()-1; i >= 0; --i)\\n        {\\n            sum += (uint64_t)(s[s.size() - i - 1 ] - \\'0\\') * pow(10, i);\\n        }\\n\\n        return sum;\\n    }\\n};\\n\\nwhy does my solution fail in bigger numbers? \\nI\\'m stuck in 123456789*987654321\\n\\nit gives 121932631112635264 instead of 121932631112635269"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 what about solving this question with python"
                    }
                ]
            },
            {
                "id": 1955247,
                "content": [
                    {
                        "username": "a_andreasian",
                        "content": "I managed to make the string - integers and calculate, but don't know how to make it a string. \n\nLol, I asked chatgpt to give a hint, except for sending the solution, and it got stuck! \n\nOr it runs a for-loop over an integer, or it says \"I'm sorry\" and uses \"\".join to use some mapping, over and over again. Then for-looping the int then again uses .join. \nIt doesn't even understand, if you were able to use join, you can use it to return the answer, instead of mapping some lambda function. \n\nYes, I'm a beginner, I study Python for 4 months, but that \"competitor of google\" is gonna make me \"lose my job\" in the future, oh hold my beer!\n\n"
                    },
                    {
                        "username": "Husoski",
                        "content": "`result = ''.join('0123456789'[digit] for digit in number)`\n...assuming that `number` is a list of integer digits in left-to-right order.  If you build the list in least-significant-first order, then reverse it with `result = result[::-1]`.  If you need to remove leading zeroes, then something like:\n`result = result.lstrip('0') or '0'`\n...where the `or 0` part is a tricky way to convert an empty result (the string was all zeroes) into a single '0'."
                    },
                    {
                        "username": "myahsine_2024",
                        "content": "Can someone tell me why this doesn\\'t work with bigger inputs? small numbers work fine. I also tried int.\\n        long num_1 = 0;\\n        long num_2 = 0;\\n        int len = num1.length()-1;\\n        int len2 = num2.length() - 1;\\n        for(int i = 0; i < num1.length(); i++){\\n            long mult = (long) Math.pow(10, len);\\n            num_1 += (num1.charAt(i) - \\'0\\') * mult;  \\n            len--;\\n        }\\n        for(int i = 0; i < num2.length(); i++){\\n            long mult = (long) Math.pow(10, len2);\\n            num_2 += (num2.charAt(i) - \\'0\\') * mult;\\n            len2--;\\n        }\\n        StringBuilder sb = new StringBuilder();\\n        sb.append(num_1*num_2);\\n\\n        return sb.toString();"
                    },
                    {
                        "username": "myahsine_2024",
                        "content": "[@Husoski](/Husoski) Great point thank you!"
                    },
                    {
                        "username": "Husoski",
                        "content": "I haven\\'t looked at all of the code, but one thing that obviously wrong is `Math.pow(10, len)`.  Math.pow() produces a double result, that that only has about 52 bits of precision.  Since `len` can be around 200 and each base 10 digit takes about 3.3 bits, that\\'s a 660 bit number.  The low 200 bits are all 0, so you\\'d need floating point with 660-220 = 440 bits of precision.  Double won\\'t work; and the 660 bit result won\\'t fit in a 64-bit long either."
                    },
                    {
                        "username": "eduard92",
                        "content": "worked on the 12th submission, I did my part\n\nI think in interview is good to discuss this one but the implementation is annoying and the only thing it tests is your attention to details.\nDiscussing the strategy to come to a result and some pseudo code should be enough. Like if the interviewer pulls random test cases after each implementation, that interview will last 3 hours."
                    },
                    {
                        "username": "eduard92",
                        "content": "My reaction to following sentence \"You must not use any built-in BigInteger library\" braaah, \"Acceptance Rate 39.3%\" okay.\n\nOn the good side, I am gonna learn a new way, on the bad side.. gonna spend 20 minutes reading the Editorial, probably I am gonna solve it just like I solved Binary Sum problem, need to carry a carry all over the place, if it works like this, it should be an easy problem then."
                    },
                    {
                        "username": "CalCreate",
                        "content": "Does anyone feel like this question kind of resembles Dynamic Programming in a way? "
                    },
                    {
                        "username": "AyushThakur-7",
                        "content": "In this question, we cannot use ASCII table?\\n"
                    },
                    {
                        "username": "tony7000",
                        "content": "\"You must not use any built-in BigInteger library or convert the inputs to integer directly\".\\n\\nWell, I just did. Thank you. "
                    },
                    {
                        "username": "itzRAYY",
                        "content": "import java.math.BigInteger;\\nclass Solution {\\n    public String multiply(String num1, String num2) {\\n        BigInteger n1 = new BigInteger(num1);\\n        BigInteger n2 = new BigInteger(num2);\\n        n2 = n1.multiply(n2);\\n        return \"\"+n2;\\n    }\\n}"
                    },
                    {
                        "username": "fedupwith060708",
                        "content": "class Solution {\\npublic:\\n    string multiply(string num1, string num2) {\\n        return ToString(ToInt(num1) * ToInt(num2));\\n    }\\n\\n    string ToString(uint64_t n)\\n    {\\n        if(n == 0) return string(\"0\");\\n\\n        string res = \"\";\\n        int size = 0;\\n        \\n        for(int i = 0; pow(10, i) <= n; ++i) ++size;\\n\\n        for(int i = size - 1; i >= 0; --i)\\n        {\\n            uint64_t digit = (uint64_t)(n / pow(10, i)) % 10;\\n            res += (char)digit+\\'0\\';\\n        }\\n\\n        \\n        return res;\\n    }\\n    \\n    uint64_t ToInt(string s)\\n    {\\n        uint64_t sum = 0;\\n        for(int i = s.size()-1; i >= 0; --i)\\n        {\\n            sum += (uint64_t)(s[s.size() - i - 1 ] - \\'0\\') * pow(10, i);\\n        }\\n\\n        return sum;\\n    }\\n};\\n\\nwhy does my solution fail in bigger numbers? \\nI\\'m stuck in 123456789*987654321\\n\\nit gives 121932631112635264 instead of 121932631112635269"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 what about solving this question with python"
                    }
                ]
            },
            {
                "id": 1952055,
                "content": [
                    {
                        "username": "a_andreasian",
                        "content": "I managed to make the string - integers and calculate, but don't know how to make it a string. \n\nLol, I asked chatgpt to give a hint, except for sending the solution, and it got stuck! \n\nOr it runs a for-loop over an integer, or it says \"I'm sorry\" and uses \"\".join to use some mapping, over and over again. Then for-looping the int then again uses .join. \nIt doesn't even understand, if you were able to use join, you can use it to return the answer, instead of mapping some lambda function. \n\nYes, I'm a beginner, I study Python for 4 months, but that \"competitor of google\" is gonna make me \"lose my job\" in the future, oh hold my beer!\n\n"
                    },
                    {
                        "username": "Husoski",
                        "content": "`result = ''.join('0123456789'[digit] for digit in number)`\n...assuming that `number` is a list of integer digits in left-to-right order.  If you build the list in least-significant-first order, then reverse it with `result = result[::-1]`.  If you need to remove leading zeroes, then something like:\n`result = result.lstrip('0') or '0'`\n...where the `or 0` part is a tricky way to convert an empty result (the string was all zeroes) into a single '0'."
                    },
                    {
                        "username": "myahsine_2024",
                        "content": "Can someone tell me why this doesn\\'t work with bigger inputs? small numbers work fine. I also tried int.\\n        long num_1 = 0;\\n        long num_2 = 0;\\n        int len = num1.length()-1;\\n        int len2 = num2.length() - 1;\\n        for(int i = 0; i < num1.length(); i++){\\n            long mult = (long) Math.pow(10, len);\\n            num_1 += (num1.charAt(i) - \\'0\\') * mult;  \\n            len--;\\n        }\\n        for(int i = 0; i < num2.length(); i++){\\n            long mult = (long) Math.pow(10, len2);\\n            num_2 += (num2.charAt(i) - \\'0\\') * mult;\\n            len2--;\\n        }\\n        StringBuilder sb = new StringBuilder();\\n        sb.append(num_1*num_2);\\n\\n        return sb.toString();"
                    },
                    {
                        "username": "myahsine_2024",
                        "content": "[@Husoski](/Husoski) Great point thank you!"
                    },
                    {
                        "username": "Husoski",
                        "content": "I haven\\'t looked at all of the code, but one thing that obviously wrong is `Math.pow(10, len)`.  Math.pow() produces a double result, that that only has about 52 bits of precision.  Since `len` can be around 200 and each base 10 digit takes about 3.3 bits, that\\'s a 660 bit number.  The low 200 bits are all 0, so you\\'d need floating point with 660-220 = 440 bits of precision.  Double won\\'t work; and the 660 bit result won\\'t fit in a 64-bit long either."
                    },
                    {
                        "username": "eduard92",
                        "content": "worked on the 12th submission, I did my part\n\nI think in interview is good to discuss this one but the implementation is annoying and the only thing it tests is your attention to details.\nDiscussing the strategy to come to a result and some pseudo code should be enough. Like if the interviewer pulls random test cases after each implementation, that interview will last 3 hours."
                    },
                    {
                        "username": "eduard92",
                        "content": "My reaction to following sentence \"You must not use any built-in BigInteger library\" braaah, \"Acceptance Rate 39.3%\" okay.\n\nOn the good side, I am gonna learn a new way, on the bad side.. gonna spend 20 minutes reading the Editorial, probably I am gonna solve it just like I solved Binary Sum problem, need to carry a carry all over the place, if it works like this, it should be an easy problem then."
                    },
                    {
                        "username": "CalCreate",
                        "content": "Does anyone feel like this question kind of resembles Dynamic Programming in a way? "
                    },
                    {
                        "username": "AyushThakur-7",
                        "content": "In this question, we cannot use ASCII table?\\n"
                    },
                    {
                        "username": "tony7000",
                        "content": "\"You must not use any built-in BigInteger library or convert the inputs to integer directly\".\\n\\nWell, I just did. Thank you. "
                    },
                    {
                        "username": "itzRAYY",
                        "content": "import java.math.BigInteger;\\nclass Solution {\\n    public String multiply(String num1, String num2) {\\n        BigInteger n1 = new BigInteger(num1);\\n        BigInteger n2 = new BigInteger(num2);\\n        n2 = n1.multiply(n2);\\n        return \"\"+n2;\\n    }\\n}"
                    },
                    {
                        "username": "fedupwith060708",
                        "content": "class Solution {\\npublic:\\n    string multiply(string num1, string num2) {\\n        return ToString(ToInt(num1) * ToInt(num2));\\n    }\\n\\n    string ToString(uint64_t n)\\n    {\\n        if(n == 0) return string(\"0\");\\n\\n        string res = \"\";\\n        int size = 0;\\n        \\n        for(int i = 0; pow(10, i) <= n; ++i) ++size;\\n\\n        for(int i = size - 1; i >= 0; --i)\\n        {\\n            uint64_t digit = (uint64_t)(n / pow(10, i)) % 10;\\n            res += (char)digit+\\'0\\';\\n        }\\n\\n        \\n        return res;\\n    }\\n    \\n    uint64_t ToInt(string s)\\n    {\\n        uint64_t sum = 0;\\n        for(int i = s.size()-1; i >= 0; --i)\\n        {\\n            sum += (uint64_t)(s[s.size() - i - 1 ] - \\'0\\') * pow(10, i);\\n        }\\n\\n        return sum;\\n    }\\n};\\n\\nwhy does my solution fail in bigger numbers? \\nI\\'m stuck in 123456789*987654321\\n\\nit gives 121932631112635264 instead of 121932631112635269"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 what about solving this question with python"
                    }
                ]
            },
            {
                "id": 1928253,
                "content": [
                    {
                        "username": "a_andreasian",
                        "content": "I managed to make the string - integers and calculate, but don't know how to make it a string. \n\nLol, I asked chatgpt to give a hint, except for sending the solution, and it got stuck! \n\nOr it runs a for-loop over an integer, or it says \"I'm sorry\" and uses \"\".join to use some mapping, over and over again. Then for-looping the int then again uses .join. \nIt doesn't even understand, if you were able to use join, you can use it to return the answer, instead of mapping some lambda function. \n\nYes, I'm a beginner, I study Python for 4 months, but that \"competitor of google\" is gonna make me \"lose my job\" in the future, oh hold my beer!\n\n"
                    },
                    {
                        "username": "Husoski",
                        "content": "`result = ''.join('0123456789'[digit] for digit in number)`\n...assuming that `number` is a list of integer digits in left-to-right order.  If you build the list in least-significant-first order, then reverse it with `result = result[::-1]`.  If you need to remove leading zeroes, then something like:\n`result = result.lstrip('0') or '0'`\n...where the `or 0` part is a tricky way to convert an empty result (the string was all zeroes) into a single '0'."
                    },
                    {
                        "username": "myahsine_2024",
                        "content": "Can someone tell me why this doesn\\'t work with bigger inputs? small numbers work fine. I also tried int.\\n        long num_1 = 0;\\n        long num_2 = 0;\\n        int len = num1.length()-1;\\n        int len2 = num2.length() - 1;\\n        for(int i = 0; i < num1.length(); i++){\\n            long mult = (long) Math.pow(10, len);\\n            num_1 += (num1.charAt(i) - \\'0\\') * mult;  \\n            len--;\\n        }\\n        for(int i = 0; i < num2.length(); i++){\\n            long mult = (long) Math.pow(10, len2);\\n            num_2 += (num2.charAt(i) - \\'0\\') * mult;\\n            len2--;\\n        }\\n        StringBuilder sb = new StringBuilder();\\n        sb.append(num_1*num_2);\\n\\n        return sb.toString();"
                    },
                    {
                        "username": "myahsine_2024",
                        "content": "[@Husoski](/Husoski) Great point thank you!"
                    },
                    {
                        "username": "Husoski",
                        "content": "I haven\\'t looked at all of the code, but one thing that obviously wrong is `Math.pow(10, len)`.  Math.pow() produces a double result, that that only has about 52 bits of precision.  Since `len` can be around 200 and each base 10 digit takes about 3.3 bits, that\\'s a 660 bit number.  The low 200 bits are all 0, so you\\'d need floating point with 660-220 = 440 bits of precision.  Double won\\'t work; and the 660 bit result won\\'t fit in a 64-bit long either."
                    },
                    {
                        "username": "eduard92",
                        "content": "worked on the 12th submission, I did my part\n\nI think in interview is good to discuss this one but the implementation is annoying and the only thing it tests is your attention to details.\nDiscussing the strategy to come to a result and some pseudo code should be enough. Like if the interviewer pulls random test cases after each implementation, that interview will last 3 hours."
                    },
                    {
                        "username": "eduard92",
                        "content": "My reaction to following sentence \"You must not use any built-in BigInteger library\" braaah, \"Acceptance Rate 39.3%\" okay.\n\nOn the good side, I am gonna learn a new way, on the bad side.. gonna spend 20 minutes reading the Editorial, probably I am gonna solve it just like I solved Binary Sum problem, need to carry a carry all over the place, if it works like this, it should be an easy problem then."
                    },
                    {
                        "username": "CalCreate",
                        "content": "Does anyone feel like this question kind of resembles Dynamic Programming in a way? "
                    },
                    {
                        "username": "AyushThakur-7",
                        "content": "In this question, we cannot use ASCII table?\\n"
                    },
                    {
                        "username": "tony7000",
                        "content": "\"You must not use any built-in BigInteger library or convert the inputs to integer directly\".\\n\\nWell, I just did. Thank you. "
                    },
                    {
                        "username": "itzRAYY",
                        "content": "import java.math.BigInteger;\\nclass Solution {\\n    public String multiply(String num1, String num2) {\\n        BigInteger n1 = new BigInteger(num1);\\n        BigInteger n2 = new BigInteger(num2);\\n        n2 = n1.multiply(n2);\\n        return \"\"+n2;\\n    }\\n}"
                    },
                    {
                        "username": "fedupwith060708",
                        "content": "class Solution {\\npublic:\\n    string multiply(string num1, string num2) {\\n        return ToString(ToInt(num1) * ToInt(num2));\\n    }\\n\\n    string ToString(uint64_t n)\\n    {\\n        if(n == 0) return string(\"0\");\\n\\n        string res = \"\";\\n        int size = 0;\\n        \\n        for(int i = 0; pow(10, i) <= n; ++i) ++size;\\n\\n        for(int i = size - 1; i >= 0; --i)\\n        {\\n            uint64_t digit = (uint64_t)(n / pow(10, i)) % 10;\\n            res += (char)digit+\\'0\\';\\n        }\\n\\n        \\n        return res;\\n    }\\n    \\n    uint64_t ToInt(string s)\\n    {\\n        uint64_t sum = 0;\\n        for(int i = s.size()-1; i >= 0; --i)\\n        {\\n            sum += (uint64_t)(s[s.size() - i - 1 ] - \\'0\\') * pow(10, i);\\n        }\\n\\n        return sum;\\n    }\\n};\\n\\nwhy does my solution fail in bigger numbers? \\nI\\'m stuck in 123456789*987654321\\n\\nit gives 121932631112635264 instead of 121932631112635269"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 what about solving this question with python"
                    }
                ]
            },
            {
                "id": 1918078,
                "content": [
                    {
                        "username": "a_andreasian",
                        "content": "I managed to make the string - integers and calculate, but don't know how to make it a string. \n\nLol, I asked chatgpt to give a hint, except for sending the solution, and it got stuck! \n\nOr it runs a for-loop over an integer, or it says \"I'm sorry\" and uses \"\".join to use some mapping, over and over again. Then for-looping the int then again uses .join. \nIt doesn't even understand, if you were able to use join, you can use it to return the answer, instead of mapping some lambda function. \n\nYes, I'm a beginner, I study Python for 4 months, but that \"competitor of google\" is gonna make me \"lose my job\" in the future, oh hold my beer!\n\n"
                    },
                    {
                        "username": "Husoski",
                        "content": "`result = ''.join('0123456789'[digit] for digit in number)`\n...assuming that `number` is a list of integer digits in left-to-right order.  If you build the list in least-significant-first order, then reverse it with `result = result[::-1]`.  If you need to remove leading zeroes, then something like:\n`result = result.lstrip('0') or '0'`\n...where the `or 0` part is a tricky way to convert an empty result (the string was all zeroes) into a single '0'."
                    },
                    {
                        "username": "myahsine_2024",
                        "content": "Can someone tell me why this doesn\\'t work with bigger inputs? small numbers work fine. I also tried int.\\n        long num_1 = 0;\\n        long num_2 = 0;\\n        int len = num1.length()-1;\\n        int len2 = num2.length() - 1;\\n        for(int i = 0; i < num1.length(); i++){\\n            long mult = (long) Math.pow(10, len);\\n            num_1 += (num1.charAt(i) - \\'0\\') * mult;  \\n            len--;\\n        }\\n        for(int i = 0; i < num2.length(); i++){\\n            long mult = (long) Math.pow(10, len2);\\n            num_2 += (num2.charAt(i) - \\'0\\') * mult;\\n            len2--;\\n        }\\n        StringBuilder sb = new StringBuilder();\\n        sb.append(num_1*num_2);\\n\\n        return sb.toString();"
                    },
                    {
                        "username": "myahsine_2024",
                        "content": "[@Husoski](/Husoski) Great point thank you!"
                    },
                    {
                        "username": "Husoski",
                        "content": "I haven\\'t looked at all of the code, but one thing that obviously wrong is `Math.pow(10, len)`.  Math.pow() produces a double result, that that only has about 52 bits of precision.  Since `len` can be around 200 and each base 10 digit takes about 3.3 bits, that\\'s a 660 bit number.  The low 200 bits are all 0, so you\\'d need floating point with 660-220 = 440 bits of precision.  Double won\\'t work; and the 660 bit result won\\'t fit in a 64-bit long either."
                    },
                    {
                        "username": "eduard92",
                        "content": "worked on the 12th submission, I did my part\n\nI think in interview is good to discuss this one but the implementation is annoying and the only thing it tests is your attention to details.\nDiscussing the strategy to come to a result and some pseudo code should be enough. Like if the interviewer pulls random test cases after each implementation, that interview will last 3 hours."
                    },
                    {
                        "username": "eduard92",
                        "content": "My reaction to following sentence \"You must not use any built-in BigInteger library\" braaah, \"Acceptance Rate 39.3%\" okay.\n\nOn the good side, I am gonna learn a new way, on the bad side.. gonna spend 20 minutes reading the Editorial, probably I am gonna solve it just like I solved Binary Sum problem, need to carry a carry all over the place, if it works like this, it should be an easy problem then."
                    },
                    {
                        "username": "CalCreate",
                        "content": "Does anyone feel like this question kind of resembles Dynamic Programming in a way? "
                    },
                    {
                        "username": "AyushThakur-7",
                        "content": "In this question, we cannot use ASCII table?\\n"
                    },
                    {
                        "username": "tony7000",
                        "content": "\"You must not use any built-in BigInteger library or convert the inputs to integer directly\".\\n\\nWell, I just did. Thank you. "
                    },
                    {
                        "username": "itzRAYY",
                        "content": "import java.math.BigInteger;\\nclass Solution {\\n    public String multiply(String num1, String num2) {\\n        BigInteger n1 = new BigInteger(num1);\\n        BigInteger n2 = new BigInteger(num2);\\n        n2 = n1.multiply(n2);\\n        return \"\"+n2;\\n    }\\n}"
                    },
                    {
                        "username": "fedupwith060708",
                        "content": "class Solution {\\npublic:\\n    string multiply(string num1, string num2) {\\n        return ToString(ToInt(num1) * ToInt(num2));\\n    }\\n\\n    string ToString(uint64_t n)\\n    {\\n        if(n == 0) return string(\"0\");\\n\\n        string res = \"\";\\n        int size = 0;\\n        \\n        for(int i = 0; pow(10, i) <= n; ++i) ++size;\\n\\n        for(int i = size - 1; i >= 0; --i)\\n        {\\n            uint64_t digit = (uint64_t)(n / pow(10, i)) % 10;\\n            res += (char)digit+\\'0\\';\\n        }\\n\\n        \\n        return res;\\n    }\\n    \\n    uint64_t ToInt(string s)\\n    {\\n        uint64_t sum = 0;\\n        for(int i = s.size()-1; i >= 0; --i)\\n        {\\n            sum += (uint64_t)(s[s.size() - i - 1 ] - \\'0\\') * pow(10, i);\\n        }\\n\\n        return sum;\\n    }\\n};\\n\\nwhy does my solution fail in bigger numbers? \\nI\\'m stuck in 123456789*987654321\\n\\nit gives 121932631112635264 instead of 121932631112635269"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 what about solving this question with python"
                    }
                ]
            },
            {
                "id": 1915560,
                "content": [
                    {
                        "username": "a_andreasian",
                        "content": "I managed to make the string - integers and calculate, but don't know how to make it a string. \n\nLol, I asked chatgpt to give a hint, except for sending the solution, and it got stuck! \n\nOr it runs a for-loop over an integer, or it says \"I'm sorry\" and uses \"\".join to use some mapping, over and over again. Then for-looping the int then again uses .join. \nIt doesn't even understand, if you were able to use join, you can use it to return the answer, instead of mapping some lambda function. \n\nYes, I'm a beginner, I study Python for 4 months, but that \"competitor of google\" is gonna make me \"lose my job\" in the future, oh hold my beer!\n\n"
                    },
                    {
                        "username": "Husoski",
                        "content": "`result = ''.join('0123456789'[digit] for digit in number)`\n...assuming that `number` is a list of integer digits in left-to-right order.  If you build the list in least-significant-first order, then reverse it with `result = result[::-1]`.  If you need to remove leading zeroes, then something like:\n`result = result.lstrip('0') or '0'`\n...where the `or 0` part is a tricky way to convert an empty result (the string was all zeroes) into a single '0'."
                    },
                    {
                        "username": "myahsine_2024",
                        "content": "Can someone tell me why this doesn\\'t work with bigger inputs? small numbers work fine. I also tried int.\\n        long num_1 = 0;\\n        long num_2 = 0;\\n        int len = num1.length()-1;\\n        int len2 = num2.length() - 1;\\n        for(int i = 0; i < num1.length(); i++){\\n            long mult = (long) Math.pow(10, len);\\n            num_1 += (num1.charAt(i) - \\'0\\') * mult;  \\n            len--;\\n        }\\n        for(int i = 0; i < num2.length(); i++){\\n            long mult = (long) Math.pow(10, len2);\\n            num_2 += (num2.charAt(i) - \\'0\\') * mult;\\n            len2--;\\n        }\\n        StringBuilder sb = new StringBuilder();\\n        sb.append(num_1*num_2);\\n\\n        return sb.toString();"
                    },
                    {
                        "username": "myahsine_2024",
                        "content": "[@Husoski](/Husoski) Great point thank you!"
                    },
                    {
                        "username": "Husoski",
                        "content": "I haven\\'t looked at all of the code, but one thing that obviously wrong is `Math.pow(10, len)`.  Math.pow() produces a double result, that that only has about 52 bits of precision.  Since `len` can be around 200 and each base 10 digit takes about 3.3 bits, that\\'s a 660 bit number.  The low 200 bits are all 0, so you\\'d need floating point with 660-220 = 440 bits of precision.  Double won\\'t work; and the 660 bit result won\\'t fit in a 64-bit long either."
                    },
                    {
                        "username": "eduard92",
                        "content": "worked on the 12th submission, I did my part\n\nI think in interview is good to discuss this one but the implementation is annoying and the only thing it tests is your attention to details.\nDiscussing the strategy to come to a result and some pseudo code should be enough. Like if the interviewer pulls random test cases after each implementation, that interview will last 3 hours."
                    },
                    {
                        "username": "eduard92",
                        "content": "My reaction to following sentence \"You must not use any built-in BigInteger library\" braaah, \"Acceptance Rate 39.3%\" okay.\n\nOn the good side, I am gonna learn a new way, on the bad side.. gonna spend 20 minutes reading the Editorial, probably I am gonna solve it just like I solved Binary Sum problem, need to carry a carry all over the place, if it works like this, it should be an easy problem then."
                    },
                    {
                        "username": "CalCreate",
                        "content": "Does anyone feel like this question kind of resembles Dynamic Programming in a way? "
                    },
                    {
                        "username": "AyushThakur-7",
                        "content": "In this question, we cannot use ASCII table?\\n"
                    },
                    {
                        "username": "tony7000",
                        "content": "\"You must not use any built-in BigInteger library or convert the inputs to integer directly\".\\n\\nWell, I just did. Thank you. "
                    },
                    {
                        "username": "itzRAYY",
                        "content": "import java.math.BigInteger;\\nclass Solution {\\n    public String multiply(String num1, String num2) {\\n        BigInteger n1 = new BigInteger(num1);\\n        BigInteger n2 = new BigInteger(num2);\\n        n2 = n1.multiply(n2);\\n        return \"\"+n2;\\n    }\\n}"
                    },
                    {
                        "username": "fedupwith060708",
                        "content": "class Solution {\\npublic:\\n    string multiply(string num1, string num2) {\\n        return ToString(ToInt(num1) * ToInt(num2));\\n    }\\n\\n    string ToString(uint64_t n)\\n    {\\n        if(n == 0) return string(\"0\");\\n\\n        string res = \"\";\\n        int size = 0;\\n        \\n        for(int i = 0; pow(10, i) <= n; ++i) ++size;\\n\\n        for(int i = size - 1; i >= 0; --i)\\n        {\\n            uint64_t digit = (uint64_t)(n / pow(10, i)) % 10;\\n            res += (char)digit+\\'0\\';\\n        }\\n\\n        \\n        return res;\\n    }\\n    \\n    uint64_t ToInt(string s)\\n    {\\n        uint64_t sum = 0;\\n        for(int i = s.size()-1; i >= 0; --i)\\n        {\\n            sum += (uint64_t)(s[s.size() - i - 1 ] - \\'0\\') * pow(10, i);\\n        }\\n\\n        return sum;\\n    }\\n};\\n\\nwhy does my solution fail in bigger numbers? \\nI\\'m stuck in 123456789*987654321\\n\\nit gives 121932631112635264 instead of 121932631112635269"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 what about solving this question with python"
                    }
                ]
            },
            {
                "id": 1905123,
                "content": [
                    {
                        "username": "a_andreasian",
                        "content": "I managed to make the string - integers and calculate, but don't know how to make it a string. \n\nLol, I asked chatgpt to give a hint, except for sending the solution, and it got stuck! \n\nOr it runs a for-loop over an integer, or it says \"I'm sorry\" and uses \"\".join to use some mapping, over and over again. Then for-looping the int then again uses .join. \nIt doesn't even understand, if you were able to use join, you can use it to return the answer, instead of mapping some lambda function. \n\nYes, I'm a beginner, I study Python for 4 months, but that \"competitor of google\" is gonna make me \"lose my job\" in the future, oh hold my beer!\n\n"
                    },
                    {
                        "username": "Husoski",
                        "content": "`result = ''.join('0123456789'[digit] for digit in number)`\n...assuming that `number` is a list of integer digits in left-to-right order.  If you build the list in least-significant-first order, then reverse it with `result = result[::-1]`.  If you need to remove leading zeroes, then something like:\n`result = result.lstrip('0') or '0'`\n...where the `or 0` part is a tricky way to convert an empty result (the string was all zeroes) into a single '0'."
                    },
                    {
                        "username": "myahsine_2024",
                        "content": "Can someone tell me why this doesn\\'t work with bigger inputs? small numbers work fine. I also tried int.\\n        long num_1 = 0;\\n        long num_2 = 0;\\n        int len = num1.length()-1;\\n        int len2 = num2.length() - 1;\\n        for(int i = 0; i < num1.length(); i++){\\n            long mult = (long) Math.pow(10, len);\\n            num_1 += (num1.charAt(i) - \\'0\\') * mult;  \\n            len--;\\n        }\\n        for(int i = 0; i < num2.length(); i++){\\n            long mult = (long) Math.pow(10, len2);\\n            num_2 += (num2.charAt(i) - \\'0\\') * mult;\\n            len2--;\\n        }\\n        StringBuilder sb = new StringBuilder();\\n        sb.append(num_1*num_2);\\n\\n        return sb.toString();"
                    },
                    {
                        "username": "myahsine_2024",
                        "content": "[@Husoski](/Husoski) Great point thank you!"
                    },
                    {
                        "username": "Husoski",
                        "content": "I haven\\'t looked at all of the code, but one thing that obviously wrong is `Math.pow(10, len)`.  Math.pow() produces a double result, that that only has about 52 bits of precision.  Since `len` can be around 200 and each base 10 digit takes about 3.3 bits, that\\'s a 660 bit number.  The low 200 bits are all 0, so you\\'d need floating point with 660-220 = 440 bits of precision.  Double won\\'t work; and the 660 bit result won\\'t fit in a 64-bit long either."
                    },
                    {
                        "username": "eduard92",
                        "content": "worked on the 12th submission, I did my part\n\nI think in interview is good to discuss this one but the implementation is annoying and the only thing it tests is your attention to details.\nDiscussing the strategy to come to a result and some pseudo code should be enough. Like if the interviewer pulls random test cases after each implementation, that interview will last 3 hours."
                    },
                    {
                        "username": "eduard92",
                        "content": "My reaction to following sentence \"You must not use any built-in BigInteger library\" braaah, \"Acceptance Rate 39.3%\" okay.\n\nOn the good side, I am gonna learn a new way, on the bad side.. gonna spend 20 minutes reading the Editorial, probably I am gonna solve it just like I solved Binary Sum problem, need to carry a carry all over the place, if it works like this, it should be an easy problem then."
                    },
                    {
                        "username": "CalCreate",
                        "content": "Does anyone feel like this question kind of resembles Dynamic Programming in a way? "
                    },
                    {
                        "username": "AyushThakur-7",
                        "content": "In this question, we cannot use ASCII table?\\n"
                    },
                    {
                        "username": "tony7000",
                        "content": "\"You must not use any built-in BigInteger library or convert the inputs to integer directly\".\\n\\nWell, I just did. Thank you. "
                    },
                    {
                        "username": "itzRAYY",
                        "content": "import java.math.BigInteger;\\nclass Solution {\\n    public String multiply(String num1, String num2) {\\n        BigInteger n1 = new BigInteger(num1);\\n        BigInteger n2 = new BigInteger(num2);\\n        n2 = n1.multiply(n2);\\n        return \"\"+n2;\\n    }\\n}"
                    },
                    {
                        "username": "fedupwith060708",
                        "content": "class Solution {\\npublic:\\n    string multiply(string num1, string num2) {\\n        return ToString(ToInt(num1) * ToInt(num2));\\n    }\\n\\n    string ToString(uint64_t n)\\n    {\\n        if(n == 0) return string(\"0\");\\n\\n        string res = \"\";\\n        int size = 0;\\n        \\n        for(int i = 0; pow(10, i) <= n; ++i) ++size;\\n\\n        for(int i = size - 1; i >= 0; --i)\\n        {\\n            uint64_t digit = (uint64_t)(n / pow(10, i)) % 10;\\n            res += (char)digit+\\'0\\';\\n        }\\n\\n        \\n        return res;\\n    }\\n    \\n    uint64_t ToInt(string s)\\n    {\\n        uint64_t sum = 0;\\n        for(int i = s.size()-1; i >= 0; --i)\\n        {\\n            sum += (uint64_t)(s[s.size() - i - 1 ] - \\'0\\') * pow(10, i);\\n        }\\n\\n        return sum;\\n    }\\n};\\n\\nwhy does my solution fail in bigger numbers? \\nI\\'m stuck in 123456789*987654321\\n\\nit gives 121932631112635264 instead of 121932631112635269"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 what about solving this question with python"
                    }
                ]
            },
            {
                "id": 1900062,
                "content": [
                    {
                        "username": "a_andreasian",
                        "content": "I managed to make the string - integers and calculate, but don't know how to make it a string. \n\nLol, I asked chatgpt to give a hint, except for sending the solution, and it got stuck! \n\nOr it runs a for-loop over an integer, or it says \"I'm sorry\" and uses \"\".join to use some mapping, over and over again. Then for-looping the int then again uses .join. \nIt doesn't even understand, if you were able to use join, you can use it to return the answer, instead of mapping some lambda function. \n\nYes, I'm a beginner, I study Python for 4 months, but that \"competitor of google\" is gonna make me \"lose my job\" in the future, oh hold my beer!\n\n"
                    },
                    {
                        "username": "Husoski",
                        "content": "`result = ''.join('0123456789'[digit] for digit in number)`\n...assuming that `number` is a list of integer digits in left-to-right order.  If you build the list in least-significant-first order, then reverse it with `result = result[::-1]`.  If you need to remove leading zeroes, then something like:\n`result = result.lstrip('0') or '0'`\n...where the `or 0` part is a tricky way to convert an empty result (the string was all zeroes) into a single '0'."
                    },
                    {
                        "username": "myahsine_2024",
                        "content": "Can someone tell me why this doesn\\'t work with bigger inputs? small numbers work fine. I also tried int.\\n        long num_1 = 0;\\n        long num_2 = 0;\\n        int len = num1.length()-1;\\n        int len2 = num2.length() - 1;\\n        for(int i = 0; i < num1.length(); i++){\\n            long mult = (long) Math.pow(10, len);\\n            num_1 += (num1.charAt(i) - \\'0\\') * mult;  \\n            len--;\\n        }\\n        for(int i = 0; i < num2.length(); i++){\\n            long mult = (long) Math.pow(10, len2);\\n            num_2 += (num2.charAt(i) - \\'0\\') * mult;\\n            len2--;\\n        }\\n        StringBuilder sb = new StringBuilder();\\n        sb.append(num_1*num_2);\\n\\n        return sb.toString();"
                    },
                    {
                        "username": "myahsine_2024",
                        "content": "[@Husoski](/Husoski) Great point thank you!"
                    },
                    {
                        "username": "Husoski",
                        "content": "I haven\\'t looked at all of the code, but one thing that obviously wrong is `Math.pow(10, len)`.  Math.pow() produces a double result, that that only has about 52 bits of precision.  Since `len` can be around 200 and each base 10 digit takes about 3.3 bits, that\\'s a 660 bit number.  The low 200 bits are all 0, so you\\'d need floating point with 660-220 = 440 bits of precision.  Double won\\'t work; and the 660 bit result won\\'t fit in a 64-bit long either."
                    },
                    {
                        "username": "eduard92",
                        "content": "worked on the 12th submission, I did my part\n\nI think in interview is good to discuss this one but the implementation is annoying and the only thing it tests is your attention to details.\nDiscussing the strategy to come to a result and some pseudo code should be enough. Like if the interviewer pulls random test cases after each implementation, that interview will last 3 hours."
                    },
                    {
                        "username": "eduard92",
                        "content": "My reaction to following sentence \"You must not use any built-in BigInteger library\" braaah, \"Acceptance Rate 39.3%\" okay.\n\nOn the good side, I am gonna learn a new way, on the bad side.. gonna spend 20 minutes reading the Editorial, probably I am gonna solve it just like I solved Binary Sum problem, need to carry a carry all over the place, if it works like this, it should be an easy problem then."
                    },
                    {
                        "username": "CalCreate",
                        "content": "Does anyone feel like this question kind of resembles Dynamic Programming in a way? "
                    },
                    {
                        "username": "AyushThakur-7",
                        "content": "In this question, we cannot use ASCII table?\\n"
                    },
                    {
                        "username": "tony7000",
                        "content": "\"You must not use any built-in BigInteger library or convert the inputs to integer directly\".\\n\\nWell, I just did. Thank you. "
                    },
                    {
                        "username": "itzRAYY",
                        "content": "import java.math.BigInteger;\\nclass Solution {\\n    public String multiply(String num1, String num2) {\\n        BigInteger n1 = new BigInteger(num1);\\n        BigInteger n2 = new BigInteger(num2);\\n        n2 = n1.multiply(n2);\\n        return \"\"+n2;\\n    }\\n}"
                    },
                    {
                        "username": "fedupwith060708",
                        "content": "class Solution {\\npublic:\\n    string multiply(string num1, string num2) {\\n        return ToString(ToInt(num1) * ToInt(num2));\\n    }\\n\\n    string ToString(uint64_t n)\\n    {\\n        if(n == 0) return string(\"0\");\\n\\n        string res = \"\";\\n        int size = 0;\\n        \\n        for(int i = 0; pow(10, i) <= n; ++i) ++size;\\n\\n        for(int i = size - 1; i >= 0; --i)\\n        {\\n            uint64_t digit = (uint64_t)(n / pow(10, i)) % 10;\\n            res += (char)digit+\\'0\\';\\n        }\\n\\n        \\n        return res;\\n    }\\n    \\n    uint64_t ToInt(string s)\\n    {\\n        uint64_t sum = 0;\\n        for(int i = s.size()-1; i >= 0; --i)\\n        {\\n            sum += (uint64_t)(s[s.size() - i - 1 ] - \\'0\\') * pow(10, i);\\n        }\\n\\n        return sum;\\n    }\\n};\\n\\nwhy does my solution fail in bigger numbers? \\nI\\'m stuck in 123456789*987654321\\n\\nit gives 121932631112635264 instead of 121932631112635269"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 what about solving this question with python"
                    }
                ]
            },
            {
                "id": 1896854,
                "content": [
                    {
                        "username": "a_andreasian",
                        "content": "I managed to make the string - integers and calculate, but don't know how to make it a string. \n\nLol, I asked chatgpt to give a hint, except for sending the solution, and it got stuck! \n\nOr it runs a for-loop over an integer, or it says \"I'm sorry\" and uses \"\".join to use some mapping, over and over again. Then for-looping the int then again uses .join. \nIt doesn't even understand, if you were able to use join, you can use it to return the answer, instead of mapping some lambda function. \n\nYes, I'm a beginner, I study Python for 4 months, but that \"competitor of google\" is gonna make me \"lose my job\" in the future, oh hold my beer!\n\n"
                    },
                    {
                        "username": "Husoski",
                        "content": "`result = ''.join('0123456789'[digit] for digit in number)`\n...assuming that `number` is a list of integer digits in left-to-right order.  If you build the list in least-significant-first order, then reverse it with `result = result[::-1]`.  If you need to remove leading zeroes, then something like:\n`result = result.lstrip('0') or '0'`\n...where the `or 0` part is a tricky way to convert an empty result (the string was all zeroes) into a single '0'."
                    },
                    {
                        "username": "myahsine_2024",
                        "content": "Can someone tell me why this doesn\\'t work with bigger inputs? small numbers work fine. I also tried int.\\n        long num_1 = 0;\\n        long num_2 = 0;\\n        int len = num1.length()-1;\\n        int len2 = num2.length() - 1;\\n        for(int i = 0; i < num1.length(); i++){\\n            long mult = (long) Math.pow(10, len);\\n            num_1 += (num1.charAt(i) - \\'0\\') * mult;  \\n            len--;\\n        }\\n        for(int i = 0; i < num2.length(); i++){\\n            long mult = (long) Math.pow(10, len2);\\n            num_2 += (num2.charAt(i) - \\'0\\') * mult;\\n            len2--;\\n        }\\n        StringBuilder sb = new StringBuilder();\\n        sb.append(num_1*num_2);\\n\\n        return sb.toString();"
                    },
                    {
                        "username": "myahsine_2024",
                        "content": "[@Husoski](/Husoski) Great point thank you!"
                    },
                    {
                        "username": "Husoski",
                        "content": "I haven\\'t looked at all of the code, but one thing that obviously wrong is `Math.pow(10, len)`.  Math.pow() produces a double result, that that only has about 52 bits of precision.  Since `len` can be around 200 and each base 10 digit takes about 3.3 bits, that\\'s a 660 bit number.  The low 200 bits are all 0, so you\\'d need floating point with 660-220 = 440 bits of precision.  Double won\\'t work; and the 660 bit result won\\'t fit in a 64-bit long either."
                    },
                    {
                        "username": "eduard92",
                        "content": "worked on the 12th submission, I did my part\n\nI think in interview is good to discuss this one but the implementation is annoying and the only thing it tests is your attention to details.\nDiscussing the strategy to come to a result and some pseudo code should be enough. Like if the interviewer pulls random test cases after each implementation, that interview will last 3 hours."
                    },
                    {
                        "username": "eduard92",
                        "content": "My reaction to following sentence \"You must not use any built-in BigInteger library\" braaah, \"Acceptance Rate 39.3%\" okay.\n\nOn the good side, I am gonna learn a new way, on the bad side.. gonna spend 20 minutes reading the Editorial, probably I am gonna solve it just like I solved Binary Sum problem, need to carry a carry all over the place, if it works like this, it should be an easy problem then."
                    },
                    {
                        "username": "CalCreate",
                        "content": "Does anyone feel like this question kind of resembles Dynamic Programming in a way? "
                    },
                    {
                        "username": "AyushThakur-7",
                        "content": "In this question, we cannot use ASCII table?\\n"
                    },
                    {
                        "username": "tony7000",
                        "content": "\"You must not use any built-in BigInteger library or convert the inputs to integer directly\".\\n\\nWell, I just did. Thank you. "
                    },
                    {
                        "username": "itzRAYY",
                        "content": "import java.math.BigInteger;\\nclass Solution {\\n    public String multiply(String num1, String num2) {\\n        BigInteger n1 = new BigInteger(num1);\\n        BigInteger n2 = new BigInteger(num2);\\n        n2 = n1.multiply(n2);\\n        return \"\"+n2;\\n    }\\n}"
                    },
                    {
                        "username": "fedupwith060708",
                        "content": "class Solution {\\npublic:\\n    string multiply(string num1, string num2) {\\n        return ToString(ToInt(num1) * ToInt(num2));\\n    }\\n\\n    string ToString(uint64_t n)\\n    {\\n        if(n == 0) return string(\"0\");\\n\\n        string res = \"\";\\n        int size = 0;\\n        \\n        for(int i = 0; pow(10, i) <= n; ++i) ++size;\\n\\n        for(int i = size - 1; i >= 0; --i)\\n        {\\n            uint64_t digit = (uint64_t)(n / pow(10, i)) % 10;\\n            res += (char)digit+\\'0\\';\\n        }\\n\\n        \\n        return res;\\n    }\\n    \\n    uint64_t ToInt(string s)\\n    {\\n        uint64_t sum = 0;\\n        for(int i = s.size()-1; i >= 0; --i)\\n        {\\n            sum += (uint64_t)(s[s.size() - i - 1 ] - \\'0\\') * pow(10, i);\\n        }\\n\\n        return sum;\\n    }\\n};\\n\\nwhy does my solution fail in bigger numbers? \\nI\\'m stuck in 123456789*987654321\\n\\nit gives 121932631112635264 instead of 121932631112635269"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 what about solving this question with python"
                    }
                ]
            },
            {
                "id": 1880963,
                "content": [
                    {
                        "username": "niiaappoo",
                        "content": "Is this a legal solution? Are f strings part of built-in BigInteger library?\\n```\\nclass Solution:\\n    def multiply(self, num1: str, num2: str) -> str:\\n        def convertstr(s):\\n            res = 0\\n            zeroes = 10 ** (len(s) - 1)\\n            for num in s:\\n                res += (hm[num] * zeroes)\\n\\n                if zeroes != 1:\\n                    zeroes //= 10\\n\\n            return res\\n\\n        hm = {f\\'{i}\\': i for i in range(10)}\\n        return f\\'{convertstr(num1) * convertstr(num2)}\\'\\n```\\n"
                    },
                    {
                        "username": "gandalfTheGray",
                        "content": "I don\\'t understand why this one is medium, converting a stringified number back to a number just requires knowing anything about ASCII, and that seems like a too easy solution for a medium"
                    },
                    {
                        "username": "Krrabs",
                        "content": "Thats the one thing they said not to do in the question, and you did exactly that."
                    },
                    {
                        "username": "DEVELOPER_777M",
                        "content": "class Solution(object):\\n    def multiply(self, num1, num2):\\n        num3 = int(num1) * int(num2)\\n        num3 = str(num3)\\n        return num3"
                    },
                    {
                        "username": "sakkthivel27csbs",
                        "content": "Simple Typecasting method\\nclass Solution:\\n    def multiply(self, num1: str, num2: str) -> str:\\n        num1 = int(num1)\\n        num2 = int(num2)\\n        return str(num1 * num2)"
                    },
                    {
                        "username": "Nikhil_G002109",
                        "content": "Silly question, this should not be on the Leetcode.\nPython- return str(eval(num1+'*'+num2))"
                    },
                    {
                        "username": "tonari",
                        "content": "I don\\'t understand the constraints of the question. Are we supposed to update the result string in place? "
                    },
                    {
                        "username": "codeheart_3814",
                        "content": "python very easy solution stepwise\\n\\nclass Solution:\\n    def multiply(self, num1: str, num2: str) -> str:\\n#type casting to the int\\n        n1 = int(num1)\\n        n2= int(num2)\\n        r = n1*n2\\n#int to str and returning the res\\n        res = str(r)\\n        return res"
                    },
                    {
                        "username": "user3603T",
                        "content": "I have doubt. The constraints specify \\n `1. You must not use any built-in BigInteger library`\\n `2. You must not convert the inputs to integer directly.`\\n\\nSo the eval() function in the python doesn\\'t violate any of the constraints, but isn\\'t that wrong? Or am I thinking to much?"
                    },
                    {
                        "username": "joshahn",
                        "content": "If the question is a one line solution, then it\\'s probably not the intent of the question. In the end, it\\'s for your practice and growth."
                    },
                    {
                        "username": "Stuckers",
                        "content": "why the stoi function is out of range >>>"
                    },
                    {
                        "username": "aditi61",
                        "content": "string multiply(string num1, string num2) {\\n       long long nums1= stoi(num1);\\n       long long nums2= stoi(num2);\\n\\n        long long ans = nums1*nums2;\\n      string ans1 = to_string(ans);\\n        return ans1;\\n     }\\ncan anyone please tell problem with this question it is giving runtime error\\n"
                    },
                    {
                        "username": "mario0010",
                        "content": "First of all, this is not how the problem is intended to be solved. The description mentions you are not to convert the inputs to integers: Note: You must not use any built-in BigInteger library or convert the inputs to integer directly.\\n\\nFor the actual question, stoi does not allow for numbers large enough to accept the strings - you would need to use a larger variable type. However, even if you use stol, you will run into an answer that is too large to be represented in a long long. You will have to find another way to handle it."
                    }
                ]
            },
            {
                "id": 1863041,
                "content": [
                    {
                        "username": "niiaappoo",
                        "content": "Is this a legal solution? Are f strings part of built-in BigInteger library?\\n```\\nclass Solution:\\n    def multiply(self, num1: str, num2: str) -> str:\\n        def convertstr(s):\\n            res = 0\\n            zeroes = 10 ** (len(s) - 1)\\n            for num in s:\\n                res += (hm[num] * zeroes)\\n\\n                if zeroes != 1:\\n                    zeroes //= 10\\n\\n            return res\\n\\n        hm = {f\\'{i}\\': i for i in range(10)}\\n        return f\\'{convertstr(num1) * convertstr(num2)}\\'\\n```\\n"
                    },
                    {
                        "username": "gandalfTheGray",
                        "content": "I don\\'t understand why this one is medium, converting a stringified number back to a number just requires knowing anything about ASCII, and that seems like a too easy solution for a medium"
                    },
                    {
                        "username": "Krrabs",
                        "content": "Thats the one thing they said not to do in the question, and you did exactly that."
                    },
                    {
                        "username": "DEVELOPER_777M",
                        "content": "class Solution(object):\\n    def multiply(self, num1, num2):\\n        num3 = int(num1) * int(num2)\\n        num3 = str(num3)\\n        return num3"
                    },
                    {
                        "username": "sakkthivel27csbs",
                        "content": "Simple Typecasting method\\nclass Solution:\\n    def multiply(self, num1: str, num2: str) -> str:\\n        num1 = int(num1)\\n        num2 = int(num2)\\n        return str(num1 * num2)"
                    },
                    {
                        "username": "Nikhil_G002109",
                        "content": "Silly question, this should not be on the Leetcode.\nPython- return str(eval(num1+'*'+num2))"
                    },
                    {
                        "username": "tonari",
                        "content": "I don\\'t understand the constraints of the question. Are we supposed to update the result string in place? "
                    },
                    {
                        "username": "codeheart_3814",
                        "content": "python very easy solution stepwise\\n\\nclass Solution:\\n    def multiply(self, num1: str, num2: str) -> str:\\n#type casting to the int\\n        n1 = int(num1)\\n        n2= int(num2)\\n        r = n1*n2\\n#int to str and returning the res\\n        res = str(r)\\n        return res"
                    },
                    {
                        "username": "user3603T",
                        "content": "I have doubt. The constraints specify \\n `1. You must not use any built-in BigInteger library`\\n `2. You must not convert the inputs to integer directly.`\\n\\nSo the eval() function in the python doesn\\'t violate any of the constraints, but isn\\'t that wrong? Or am I thinking to much?"
                    },
                    {
                        "username": "joshahn",
                        "content": "If the question is a one line solution, then it\\'s probably not the intent of the question. In the end, it\\'s for your practice and growth."
                    },
                    {
                        "username": "Stuckers",
                        "content": "why the stoi function is out of range >>>"
                    },
                    {
                        "username": "aditi61",
                        "content": "string multiply(string num1, string num2) {\\n       long long nums1= stoi(num1);\\n       long long nums2= stoi(num2);\\n\\n        long long ans = nums1*nums2;\\n      string ans1 = to_string(ans);\\n        return ans1;\\n     }\\ncan anyone please tell problem with this question it is giving runtime error\\n"
                    },
                    {
                        "username": "mario0010",
                        "content": "First of all, this is not how the problem is intended to be solved. The description mentions you are not to convert the inputs to integers: Note: You must not use any built-in BigInteger library or convert the inputs to integer directly.\\n\\nFor the actual question, stoi does not allow for numbers large enough to accept the strings - you would need to use a larger variable type. However, even if you use stol, you will run into an answer that is too large to be represented in a long long. You will have to find another way to handle it."
                    }
                ]
            },
            {
                "id": 1858231,
                "content": [
                    {
                        "username": "niiaappoo",
                        "content": "Is this a legal solution? Are f strings part of built-in BigInteger library?\\n```\\nclass Solution:\\n    def multiply(self, num1: str, num2: str) -> str:\\n        def convertstr(s):\\n            res = 0\\n            zeroes = 10 ** (len(s) - 1)\\n            for num in s:\\n                res += (hm[num] * zeroes)\\n\\n                if zeroes != 1:\\n                    zeroes //= 10\\n\\n            return res\\n\\n        hm = {f\\'{i}\\': i for i in range(10)}\\n        return f\\'{convertstr(num1) * convertstr(num2)}\\'\\n```\\n"
                    },
                    {
                        "username": "gandalfTheGray",
                        "content": "I don\\'t understand why this one is medium, converting a stringified number back to a number just requires knowing anything about ASCII, and that seems like a too easy solution for a medium"
                    },
                    {
                        "username": "Krrabs",
                        "content": "Thats the one thing they said not to do in the question, and you did exactly that."
                    },
                    {
                        "username": "DEVELOPER_777M",
                        "content": "class Solution(object):\\n    def multiply(self, num1, num2):\\n        num3 = int(num1) * int(num2)\\n        num3 = str(num3)\\n        return num3"
                    },
                    {
                        "username": "sakkthivel27csbs",
                        "content": "Simple Typecasting method\\nclass Solution:\\n    def multiply(self, num1: str, num2: str) -> str:\\n        num1 = int(num1)\\n        num2 = int(num2)\\n        return str(num1 * num2)"
                    },
                    {
                        "username": "Nikhil_G002109",
                        "content": "Silly question, this should not be on the Leetcode.\nPython- return str(eval(num1+'*'+num2))"
                    },
                    {
                        "username": "tonari",
                        "content": "I don\\'t understand the constraints of the question. Are we supposed to update the result string in place? "
                    },
                    {
                        "username": "codeheart_3814",
                        "content": "python very easy solution stepwise\\n\\nclass Solution:\\n    def multiply(self, num1: str, num2: str) -> str:\\n#type casting to the int\\n        n1 = int(num1)\\n        n2= int(num2)\\n        r = n1*n2\\n#int to str and returning the res\\n        res = str(r)\\n        return res"
                    },
                    {
                        "username": "user3603T",
                        "content": "I have doubt. The constraints specify \\n `1. You must not use any built-in BigInteger library`\\n `2. You must not convert the inputs to integer directly.`\\n\\nSo the eval() function in the python doesn\\'t violate any of the constraints, but isn\\'t that wrong? Or am I thinking to much?"
                    },
                    {
                        "username": "joshahn",
                        "content": "If the question is a one line solution, then it\\'s probably not the intent of the question. In the end, it\\'s for your practice and growth."
                    },
                    {
                        "username": "Stuckers",
                        "content": "why the stoi function is out of range >>>"
                    },
                    {
                        "username": "aditi61",
                        "content": "string multiply(string num1, string num2) {\\n       long long nums1= stoi(num1);\\n       long long nums2= stoi(num2);\\n\\n        long long ans = nums1*nums2;\\n      string ans1 = to_string(ans);\\n        return ans1;\\n     }\\ncan anyone please tell problem with this question it is giving runtime error\\n"
                    },
                    {
                        "username": "mario0010",
                        "content": "First of all, this is not how the problem is intended to be solved. The description mentions you are not to convert the inputs to integers: Note: You must not use any built-in BigInteger library or convert the inputs to integer directly.\\n\\nFor the actual question, stoi does not allow for numbers large enough to accept the strings - you would need to use a larger variable type. However, even if you use stol, you will run into an answer that is too large to be represented in a long long. You will have to find another way to handle it."
                    }
                ]
            },
            {
                "id": 1853726,
                "content": [
                    {
                        "username": "niiaappoo",
                        "content": "Is this a legal solution? Are f strings part of built-in BigInteger library?\\n```\\nclass Solution:\\n    def multiply(self, num1: str, num2: str) -> str:\\n        def convertstr(s):\\n            res = 0\\n            zeroes = 10 ** (len(s) - 1)\\n            for num in s:\\n                res += (hm[num] * zeroes)\\n\\n                if zeroes != 1:\\n                    zeroes //= 10\\n\\n            return res\\n\\n        hm = {f\\'{i}\\': i for i in range(10)}\\n        return f\\'{convertstr(num1) * convertstr(num2)}\\'\\n```\\n"
                    },
                    {
                        "username": "gandalfTheGray",
                        "content": "I don\\'t understand why this one is medium, converting a stringified number back to a number just requires knowing anything about ASCII, and that seems like a too easy solution for a medium"
                    },
                    {
                        "username": "Krrabs",
                        "content": "Thats the one thing they said not to do in the question, and you did exactly that."
                    },
                    {
                        "username": "DEVELOPER_777M",
                        "content": "class Solution(object):\\n    def multiply(self, num1, num2):\\n        num3 = int(num1) * int(num2)\\n        num3 = str(num3)\\n        return num3"
                    },
                    {
                        "username": "sakkthivel27csbs",
                        "content": "Simple Typecasting method\\nclass Solution:\\n    def multiply(self, num1: str, num2: str) -> str:\\n        num1 = int(num1)\\n        num2 = int(num2)\\n        return str(num1 * num2)"
                    },
                    {
                        "username": "Nikhil_G002109",
                        "content": "Silly question, this should not be on the Leetcode.\nPython- return str(eval(num1+'*'+num2))"
                    },
                    {
                        "username": "tonari",
                        "content": "I don\\'t understand the constraints of the question. Are we supposed to update the result string in place? "
                    },
                    {
                        "username": "codeheart_3814",
                        "content": "python very easy solution stepwise\\n\\nclass Solution:\\n    def multiply(self, num1: str, num2: str) -> str:\\n#type casting to the int\\n        n1 = int(num1)\\n        n2= int(num2)\\n        r = n1*n2\\n#int to str and returning the res\\n        res = str(r)\\n        return res"
                    },
                    {
                        "username": "user3603T",
                        "content": "I have doubt. The constraints specify \\n `1. You must not use any built-in BigInteger library`\\n `2. You must not convert the inputs to integer directly.`\\n\\nSo the eval() function in the python doesn\\'t violate any of the constraints, but isn\\'t that wrong? Or am I thinking to much?"
                    },
                    {
                        "username": "joshahn",
                        "content": "If the question is a one line solution, then it\\'s probably not the intent of the question. In the end, it\\'s for your practice and growth."
                    },
                    {
                        "username": "Stuckers",
                        "content": "why the stoi function is out of range >>>"
                    },
                    {
                        "username": "aditi61",
                        "content": "string multiply(string num1, string num2) {\\n       long long nums1= stoi(num1);\\n       long long nums2= stoi(num2);\\n\\n        long long ans = nums1*nums2;\\n      string ans1 = to_string(ans);\\n        return ans1;\\n     }\\ncan anyone please tell problem with this question it is giving runtime error\\n"
                    },
                    {
                        "username": "mario0010",
                        "content": "First of all, this is not how the problem is intended to be solved. The description mentions you are not to convert the inputs to integers: Note: You must not use any built-in BigInteger library or convert the inputs to integer directly.\\n\\nFor the actual question, stoi does not allow for numbers large enough to accept the strings - you would need to use a larger variable type. However, even if you use stol, you will run into an answer that is too large to be represented in a long long. You will have to find another way to handle it."
                    }
                ]
            },
            {
                "id": 1848365,
                "content": [
                    {
                        "username": "niiaappoo",
                        "content": "Is this a legal solution? Are f strings part of built-in BigInteger library?\\n```\\nclass Solution:\\n    def multiply(self, num1: str, num2: str) -> str:\\n        def convertstr(s):\\n            res = 0\\n            zeroes = 10 ** (len(s) - 1)\\n            for num in s:\\n                res += (hm[num] * zeroes)\\n\\n                if zeroes != 1:\\n                    zeroes //= 10\\n\\n            return res\\n\\n        hm = {f\\'{i}\\': i for i in range(10)}\\n        return f\\'{convertstr(num1) * convertstr(num2)}\\'\\n```\\n"
                    },
                    {
                        "username": "gandalfTheGray",
                        "content": "I don\\'t understand why this one is medium, converting a stringified number back to a number just requires knowing anything about ASCII, and that seems like a too easy solution for a medium"
                    },
                    {
                        "username": "Krrabs",
                        "content": "Thats the one thing they said not to do in the question, and you did exactly that."
                    },
                    {
                        "username": "DEVELOPER_777M",
                        "content": "class Solution(object):\\n    def multiply(self, num1, num2):\\n        num3 = int(num1) * int(num2)\\n        num3 = str(num3)\\n        return num3"
                    },
                    {
                        "username": "sakkthivel27csbs",
                        "content": "Simple Typecasting method\\nclass Solution:\\n    def multiply(self, num1: str, num2: str) -> str:\\n        num1 = int(num1)\\n        num2 = int(num2)\\n        return str(num1 * num2)"
                    },
                    {
                        "username": "Nikhil_G002109",
                        "content": "Silly question, this should not be on the Leetcode.\nPython- return str(eval(num1+'*'+num2))"
                    },
                    {
                        "username": "tonari",
                        "content": "I don\\'t understand the constraints of the question. Are we supposed to update the result string in place? "
                    },
                    {
                        "username": "codeheart_3814",
                        "content": "python very easy solution stepwise\\n\\nclass Solution:\\n    def multiply(self, num1: str, num2: str) -> str:\\n#type casting to the int\\n        n1 = int(num1)\\n        n2= int(num2)\\n        r = n1*n2\\n#int to str and returning the res\\n        res = str(r)\\n        return res"
                    },
                    {
                        "username": "user3603T",
                        "content": "I have doubt. The constraints specify \\n `1. You must not use any built-in BigInteger library`\\n `2. You must not convert the inputs to integer directly.`\\n\\nSo the eval() function in the python doesn\\'t violate any of the constraints, but isn\\'t that wrong? Or am I thinking to much?"
                    },
                    {
                        "username": "joshahn",
                        "content": "If the question is a one line solution, then it\\'s probably not the intent of the question. In the end, it\\'s for your practice and growth."
                    },
                    {
                        "username": "Stuckers",
                        "content": "why the stoi function is out of range >>>"
                    },
                    {
                        "username": "aditi61",
                        "content": "string multiply(string num1, string num2) {\\n       long long nums1= stoi(num1);\\n       long long nums2= stoi(num2);\\n\\n        long long ans = nums1*nums2;\\n      string ans1 = to_string(ans);\\n        return ans1;\\n     }\\ncan anyone please tell problem with this question it is giving runtime error\\n"
                    },
                    {
                        "username": "mario0010",
                        "content": "First of all, this is not how the problem is intended to be solved. The description mentions you are not to convert the inputs to integers: Note: You must not use any built-in BigInteger library or convert the inputs to integer directly.\\n\\nFor the actual question, stoi does not allow for numbers large enough to accept the strings - you would need to use a larger variable type. However, even if you use stol, you will run into an answer that is too large to be represented in a long long. You will have to find another way to handle it."
                    }
                ]
            },
            {
                "id": 1826586,
                "content": [
                    {
                        "username": "niiaappoo",
                        "content": "Is this a legal solution? Are f strings part of built-in BigInteger library?\\n```\\nclass Solution:\\n    def multiply(self, num1: str, num2: str) -> str:\\n        def convertstr(s):\\n            res = 0\\n            zeroes = 10 ** (len(s) - 1)\\n            for num in s:\\n                res += (hm[num] * zeroes)\\n\\n                if zeroes != 1:\\n                    zeroes //= 10\\n\\n            return res\\n\\n        hm = {f\\'{i}\\': i for i in range(10)}\\n        return f\\'{convertstr(num1) * convertstr(num2)}\\'\\n```\\n"
                    },
                    {
                        "username": "gandalfTheGray",
                        "content": "I don\\'t understand why this one is medium, converting a stringified number back to a number just requires knowing anything about ASCII, and that seems like a too easy solution for a medium"
                    },
                    {
                        "username": "Krrabs",
                        "content": "Thats the one thing they said not to do in the question, and you did exactly that."
                    },
                    {
                        "username": "DEVELOPER_777M",
                        "content": "class Solution(object):\\n    def multiply(self, num1, num2):\\n        num3 = int(num1) * int(num2)\\n        num3 = str(num3)\\n        return num3"
                    },
                    {
                        "username": "sakkthivel27csbs",
                        "content": "Simple Typecasting method\\nclass Solution:\\n    def multiply(self, num1: str, num2: str) -> str:\\n        num1 = int(num1)\\n        num2 = int(num2)\\n        return str(num1 * num2)"
                    },
                    {
                        "username": "Nikhil_G002109",
                        "content": "Silly question, this should not be on the Leetcode.\nPython- return str(eval(num1+'*'+num2))"
                    },
                    {
                        "username": "tonari",
                        "content": "I don\\'t understand the constraints of the question. Are we supposed to update the result string in place? "
                    },
                    {
                        "username": "codeheart_3814",
                        "content": "python very easy solution stepwise\\n\\nclass Solution:\\n    def multiply(self, num1: str, num2: str) -> str:\\n#type casting to the int\\n        n1 = int(num1)\\n        n2= int(num2)\\n        r = n1*n2\\n#int to str and returning the res\\n        res = str(r)\\n        return res"
                    },
                    {
                        "username": "user3603T",
                        "content": "I have doubt. The constraints specify \\n `1. You must not use any built-in BigInteger library`\\n `2. You must not convert the inputs to integer directly.`\\n\\nSo the eval() function in the python doesn\\'t violate any of the constraints, but isn\\'t that wrong? Or am I thinking to much?"
                    },
                    {
                        "username": "joshahn",
                        "content": "If the question is a one line solution, then it\\'s probably not the intent of the question. In the end, it\\'s for your practice and growth."
                    },
                    {
                        "username": "Stuckers",
                        "content": "why the stoi function is out of range >>>"
                    },
                    {
                        "username": "aditi61",
                        "content": "string multiply(string num1, string num2) {\\n       long long nums1= stoi(num1);\\n       long long nums2= stoi(num2);\\n\\n        long long ans = nums1*nums2;\\n      string ans1 = to_string(ans);\\n        return ans1;\\n     }\\ncan anyone please tell problem with this question it is giving runtime error\\n"
                    },
                    {
                        "username": "mario0010",
                        "content": "First of all, this is not how the problem is intended to be solved. The description mentions you are not to convert the inputs to integers: Note: You must not use any built-in BigInteger library or convert the inputs to integer directly.\\n\\nFor the actual question, stoi does not allow for numbers large enough to accept the strings - you would need to use a larger variable type. However, even if you use stol, you will run into an answer that is too large to be represented in a long long. You will have to find another way to handle it."
                    }
                ]
            },
            {
                "id": 1816551,
                "content": [
                    {
                        "username": "niiaappoo",
                        "content": "Is this a legal solution? Are f strings part of built-in BigInteger library?\\n```\\nclass Solution:\\n    def multiply(self, num1: str, num2: str) -> str:\\n        def convertstr(s):\\n            res = 0\\n            zeroes = 10 ** (len(s) - 1)\\n            for num in s:\\n                res += (hm[num] * zeroes)\\n\\n                if zeroes != 1:\\n                    zeroes //= 10\\n\\n            return res\\n\\n        hm = {f\\'{i}\\': i for i in range(10)}\\n        return f\\'{convertstr(num1) * convertstr(num2)}\\'\\n```\\n"
                    },
                    {
                        "username": "gandalfTheGray",
                        "content": "I don\\'t understand why this one is medium, converting a stringified number back to a number just requires knowing anything about ASCII, and that seems like a too easy solution for a medium"
                    },
                    {
                        "username": "Krrabs",
                        "content": "Thats the one thing they said not to do in the question, and you did exactly that."
                    },
                    {
                        "username": "DEVELOPER_777M",
                        "content": "class Solution(object):\\n    def multiply(self, num1, num2):\\n        num3 = int(num1) * int(num2)\\n        num3 = str(num3)\\n        return num3"
                    },
                    {
                        "username": "sakkthivel27csbs",
                        "content": "Simple Typecasting method\\nclass Solution:\\n    def multiply(self, num1: str, num2: str) -> str:\\n        num1 = int(num1)\\n        num2 = int(num2)\\n        return str(num1 * num2)"
                    },
                    {
                        "username": "Nikhil_G002109",
                        "content": "Silly question, this should not be on the Leetcode.\nPython- return str(eval(num1+'*'+num2))"
                    },
                    {
                        "username": "tonari",
                        "content": "I don\\'t understand the constraints of the question. Are we supposed to update the result string in place? "
                    },
                    {
                        "username": "codeheart_3814",
                        "content": "python very easy solution stepwise\\n\\nclass Solution:\\n    def multiply(self, num1: str, num2: str) -> str:\\n#type casting to the int\\n        n1 = int(num1)\\n        n2= int(num2)\\n        r = n1*n2\\n#int to str and returning the res\\n        res = str(r)\\n        return res"
                    },
                    {
                        "username": "user3603T",
                        "content": "I have doubt. The constraints specify \\n `1. You must not use any built-in BigInteger library`\\n `2. You must not convert the inputs to integer directly.`\\n\\nSo the eval() function in the python doesn\\'t violate any of the constraints, but isn\\'t that wrong? Or am I thinking to much?"
                    },
                    {
                        "username": "joshahn",
                        "content": "If the question is a one line solution, then it\\'s probably not the intent of the question. In the end, it\\'s for your practice and growth."
                    },
                    {
                        "username": "Stuckers",
                        "content": "why the stoi function is out of range >>>"
                    },
                    {
                        "username": "aditi61",
                        "content": "string multiply(string num1, string num2) {\\n       long long nums1= stoi(num1);\\n       long long nums2= stoi(num2);\\n\\n        long long ans = nums1*nums2;\\n      string ans1 = to_string(ans);\\n        return ans1;\\n     }\\ncan anyone please tell problem with this question it is giving runtime error\\n"
                    },
                    {
                        "username": "mario0010",
                        "content": "First of all, this is not how the problem is intended to be solved. The description mentions you are not to convert the inputs to integers: Note: You must not use any built-in BigInteger library or convert the inputs to integer directly.\\n\\nFor the actual question, stoi does not allow for numbers large enough to accept the strings - you would need to use a larger variable type. However, even if you use stol, you will run into an answer that is too large to be represented in a long long. You will have to find another way to handle it."
                    }
                ]
            },
            {
                "id": 1799333,
                "content": [
                    {
                        "username": "niiaappoo",
                        "content": "Is this a legal solution? Are f strings part of built-in BigInteger library?\\n```\\nclass Solution:\\n    def multiply(self, num1: str, num2: str) -> str:\\n        def convertstr(s):\\n            res = 0\\n            zeroes = 10 ** (len(s) - 1)\\n            for num in s:\\n                res += (hm[num] * zeroes)\\n\\n                if zeroes != 1:\\n                    zeroes //= 10\\n\\n            return res\\n\\n        hm = {f\\'{i}\\': i for i in range(10)}\\n        return f\\'{convertstr(num1) * convertstr(num2)}\\'\\n```\\n"
                    },
                    {
                        "username": "gandalfTheGray",
                        "content": "I don\\'t understand why this one is medium, converting a stringified number back to a number just requires knowing anything about ASCII, and that seems like a too easy solution for a medium"
                    },
                    {
                        "username": "Krrabs",
                        "content": "Thats the one thing they said not to do in the question, and you did exactly that."
                    },
                    {
                        "username": "DEVELOPER_777M",
                        "content": "class Solution(object):\\n    def multiply(self, num1, num2):\\n        num3 = int(num1) * int(num2)\\n        num3 = str(num3)\\n        return num3"
                    },
                    {
                        "username": "sakkthivel27csbs",
                        "content": "Simple Typecasting method\\nclass Solution:\\n    def multiply(self, num1: str, num2: str) -> str:\\n        num1 = int(num1)\\n        num2 = int(num2)\\n        return str(num1 * num2)"
                    },
                    {
                        "username": "Nikhil_G002109",
                        "content": "Silly question, this should not be on the Leetcode.\nPython- return str(eval(num1+'*'+num2))"
                    },
                    {
                        "username": "tonari",
                        "content": "I don\\'t understand the constraints of the question. Are we supposed to update the result string in place? "
                    },
                    {
                        "username": "codeheart_3814",
                        "content": "python very easy solution stepwise\\n\\nclass Solution:\\n    def multiply(self, num1: str, num2: str) -> str:\\n#type casting to the int\\n        n1 = int(num1)\\n        n2= int(num2)\\n        r = n1*n2\\n#int to str and returning the res\\n        res = str(r)\\n        return res"
                    },
                    {
                        "username": "user3603T",
                        "content": "I have doubt. The constraints specify \\n `1. You must not use any built-in BigInteger library`\\n `2. You must not convert the inputs to integer directly.`\\n\\nSo the eval() function in the python doesn\\'t violate any of the constraints, but isn\\'t that wrong? Or am I thinking to much?"
                    },
                    {
                        "username": "joshahn",
                        "content": "If the question is a one line solution, then it\\'s probably not the intent of the question. In the end, it\\'s for your practice and growth."
                    },
                    {
                        "username": "Stuckers",
                        "content": "why the stoi function is out of range >>>"
                    },
                    {
                        "username": "aditi61",
                        "content": "string multiply(string num1, string num2) {\\n       long long nums1= stoi(num1);\\n       long long nums2= stoi(num2);\\n\\n        long long ans = nums1*nums2;\\n      string ans1 = to_string(ans);\\n        return ans1;\\n     }\\ncan anyone please tell problem with this question it is giving runtime error\\n"
                    },
                    {
                        "username": "mario0010",
                        "content": "First of all, this is not how the problem is intended to be solved. The description mentions you are not to convert the inputs to integers: Note: You must not use any built-in BigInteger library or convert the inputs to integer directly.\\n\\nFor the actual question, stoi does not allow for numbers large enough to accept the strings - you would need to use a larger variable type. However, even if you use stol, you will run into an answer that is too large to be represented in a long long. You will have to find another way to handle it."
                    }
                ]
            },
            {
                "id": 1788967,
                "content": [
                    {
                        "username": "niiaappoo",
                        "content": "Is this a legal solution? Are f strings part of built-in BigInteger library?\\n```\\nclass Solution:\\n    def multiply(self, num1: str, num2: str) -> str:\\n        def convertstr(s):\\n            res = 0\\n            zeroes = 10 ** (len(s) - 1)\\n            for num in s:\\n                res += (hm[num] * zeroes)\\n\\n                if zeroes != 1:\\n                    zeroes //= 10\\n\\n            return res\\n\\n        hm = {f\\'{i}\\': i for i in range(10)}\\n        return f\\'{convertstr(num1) * convertstr(num2)}\\'\\n```\\n"
                    },
                    {
                        "username": "gandalfTheGray",
                        "content": "I don\\'t understand why this one is medium, converting a stringified number back to a number just requires knowing anything about ASCII, and that seems like a too easy solution for a medium"
                    },
                    {
                        "username": "Krrabs",
                        "content": "Thats the one thing they said not to do in the question, and you did exactly that."
                    },
                    {
                        "username": "DEVELOPER_777M",
                        "content": "class Solution(object):\\n    def multiply(self, num1, num2):\\n        num3 = int(num1) * int(num2)\\n        num3 = str(num3)\\n        return num3"
                    },
                    {
                        "username": "sakkthivel27csbs",
                        "content": "Simple Typecasting method\\nclass Solution:\\n    def multiply(self, num1: str, num2: str) -> str:\\n        num1 = int(num1)\\n        num2 = int(num2)\\n        return str(num1 * num2)"
                    },
                    {
                        "username": "Nikhil_G002109",
                        "content": "Silly question, this should not be on the Leetcode.\nPython- return str(eval(num1+'*'+num2))"
                    },
                    {
                        "username": "tonari",
                        "content": "I don\\'t understand the constraints of the question. Are we supposed to update the result string in place? "
                    },
                    {
                        "username": "codeheart_3814",
                        "content": "python very easy solution stepwise\\n\\nclass Solution:\\n    def multiply(self, num1: str, num2: str) -> str:\\n#type casting to the int\\n        n1 = int(num1)\\n        n2= int(num2)\\n        r = n1*n2\\n#int to str and returning the res\\n        res = str(r)\\n        return res"
                    },
                    {
                        "username": "user3603T",
                        "content": "I have doubt. The constraints specify \\n `1. You must not use any built-in BigInteger library`\\n `2. You must not convert the inputs to integer directly.`\\n\\nSo the eval() function in the python doesn\\'t violate any of the constraints, but isn\\'t that wrong? Or am I thinking to much?"
                    },
                    {
                        "username": "joshahn",
                        "content": "If the question is a one line solution, then it\\'s probably not the intent of the question. In the end, it\\'s for your practice and growth."
                    },
                    {
                        "username": "Stuckers",
                        "content": "why the stoi function is out of range >>>"
                    },
                    {
                        "username": "aditi61",
                        "content": "string multiply(string num1, string num2) {\\n       long long nums1= stoi(num1);\\n       long long nums2= stoi(num2);\\n\\n        long long ans = nums1*nums2;\\n      string ans1 = to_string(ans);\\n        return ans1;\\n     }\\ncan anyone please tell problem with this question it is giving runtime error\\n"
                    },
                    {
                        "username": "mario0010",
                        "content": "First of all, this is not how the problem is intended to be solved. The description mentions you are not to convert the inputs to integers: Note: You must not use any built-in BigInteger library or convert the inputs to integer directly.\\n\\nFor the actual question, stoi does not allow for numbers large enough to accept the strings - you would need to use a larger variable type. However, even if you use stol, you will run into an answer that is too large to be represented in a long long. You will have to find another way to handle it."
                    }
                ]
            },
            {
                "id": 1776671,
                "content": [
                    {
                        "username": "niiaappoo",
                        "content": "Is this a legal solution? Are f strings part of built-in BigInteger library?\\n```\\nclass Solution:\\n    def multiply(self, num1: str, num2: str) -> str:\\n        def convertstr(s):\\n            res = 0\\n            zeroes = 10 ** (len(s) - 1)\\n            for num in s:\\n                res += (hm[num] * zeroes)\\n\\n                if zeroes != 1:\\n                    zeroes //= 10\\n\\n            return res\\n\\n        hm = {f\\'{i}\\': i for i in range(10)}\\n        return f\\'{convertstr(num1) * convertstr(num2)}\\'\\n```\\n"
                    },
                    {
                        "username": "gandalfTheGray",
                        "content": "I don\\'t understand why this one is medium, converting a stringified number back to a number just requires knowing anything about ASCII, and that seems like a too easy solution for a medium"
                    },
                    {
                        "username": "Krrabs",
                        "content": "Thats the one thing they said not to do in the question, and you did exactly that."
                    },
                    {
                        "username": "DEVELOPER_777M",
                        "content": "class Solution(object):\\n    def multiply(self, num1, num2):\\n        num3 = int(num1) * int(num2)\\n        num3 = str(num3)\\n        return num3"
                    },
                    {
                        "username": "sakkthivel27csbs",
                        "content": "Simple Typecasting method\\nclass Solution:\\n    def multiply(self, num1: str, num2: str) -> str:\\n        num1 = int(num1)\\n        num2 = int(num2)\\n        return str(num1 * num2)"
                    },
                    {
                        "username": "Nikhil_G002109",
                        "content": "Silly question, this should not be on the Leetcode.\nPython- return str(eval(num1+'*'+num2))"
                    },
                    {
                        "username": "tonari",
                        "content": "I don\\'t understand the constraints of the question. Are we supposed to update the result string in place? "
                    },
                    {
                        "username": "codeheart_3814",
                        "content": "python very easy solution stepwise\\n\\nclass Solution:\\n    def multiply(self, num1: str, num2: str) -> str:\\n#type casting to the int\\n        n1 = int(num1)\\n        n2= int(num2)\\n        r = n1*n2\\n#int to str and returning the res\\n        res = str(r)\\n        return res"
                    },
                    {
                        "username": "user3603T",
                        "content": "I have doubt. The constraints specify \\n `1. You must not use any built-in BigInteger library`\\n `2. You must not convert the inputs to integer directly.`\\n\\nSo the eval() function in the python doesn\\'t violate any of the constraints, but isn\\'t that wrong? Or am I thinking to much?"
                    },
                    {
                        "username": "joshahn",
                        "content": "If the question is a one line solution, then it\\'s probably not the intent of the question. In the end, it\\'s for your practice and growth."
                    },
                    {
                        "username": "Stuckers",
                        "content": "why the stoi function is out of range >>>"
                    },
                    {
                        "username": "aditi61",
                        "content": "string multiply(string num1, string num2) {\\n       long long nums1= stoi(num1);\\n       long long nums2= stoi(num2);\\n\\n        long long ans = nums1*nums2;\\n      string ans1 = to_string(ans);\\n        return ans1;\\n     }\\ncan anyone please tell problem with this question it is giving runtime error\\n"
                    },
                    {
                        "username": "mario0010",
                        "content": "First of all, this is not how the problem is intended to be solved. The description mentions you are not to convert the inputs to integers: Note: You must not use any built-in BigInteger library or convert the inputs to integer directly.\\n\\nFor the actual question, stoi does not allow for numbers large enough to accept the strings - you would need to use a larger variable type. However, even if you use stol, you will run into an answer that is too large to be represented in a long long. You will have to find another way to handle it."
                    }
                ]
            },
            {
                "id": 1774129,
                "content": [
                    {
                        "username": "Jayanthsomuri",
                        "content": "->Try doing it with vertical multiplication and storing the values in the vector \\n->Store the values in the final res by typecasting into string and return the final value \\u2705"
                    },
                    {
                        "username": "wodxuming",
                        "content": "```\\nclass Solution {\\npublic:\\nstring multiply(string num1, string num2) {\\n    int m = num1.size(), n = num2.size();\\n    \\n    vector<int> res(m + n, 0);\\n    \\n    for (int i = m - 1; i >= 0; i--)\\n        for (int j = n - 1; j >= 0; j--) {\\n            int mul = (num1[i]-\\'0\\') * (num2[j]-\\'0\\');\\n            \\n            int p1 = i + j, p2 = i + j + 1;\\n            \\n            int sum = mul + res[p2];\\n            res[p2] = sum % 10;\\n            res[p1] += sum / 10;\\n        }\\n    \\n    int i = 0;\\n    while (i < res.size() && res[i] == 0)\\n        i++;\\n    \\n    string str;\\n    for (; i < res.size(); i++)\\n        str.push_back(\\'0\\' + res[i]);\\n    \\n    return str.size() == 0 ? \"0\" : str;\\n}\\n};\\n```"
                    },
                    {
                        "username": "Moofer",
                        "content": "Why is using charAt - \\'0\\' allowed?\\n\\n> convert the inputs to integer directly.\\n\\nseems like that\\'s directly converting an input using a built in function?"
                    },
                    {
                        "username": "woppi123",
                        "content": "int does not have max limit in python 3 so it can calculate any multiplication without considering its size"
                    },
                    {
                        "username": "Sandeep4769",
                        "content": "Try to make a code with elementary method of multiplication.\\nThis question may seems tough but its a easy problem go with elementary method of multiplication."
                    },
                    {
                        "username": "wodxuming",
                        "content": "```\\nclass Solution {\\npublic:\\nstring multiply(string num1, string num2) {\\n    int m = num1.size(), n = num2.size();\\n    \\n    vector<int> res(m + n, 0);\\n    \\n    for (int i = m - 1; i >= 0; i--)\\n        for (int j = n - 1; j >= 0; j--) {\\n            int mul = (num1[i]-\\'0\\') * (num2[j]-\\'0\\');\\n            \\n            int p1 = i + j, p2 = i + j + 1;\\n            \\n            int sum = mul + res[p2];\\n            res[p2] = sum % 10;\\n            res[p1] += sum / 10;\\n        }\\n    \\n    int i = 0;\\n    while (i < res.size() && res[i] == 0)\\n        i++;\\n    \\n    string str;\\n    for (; i < res.size(); i++)\\n        str.push_back(\\'0\\' + res[i]);\\n    \\n    return str.size() == 0 ? \"0\" : str;\\n}\\n};\\n```"
                    },
                    {
                        "username": "RaghavMittal56",
                        "content": "import java.util.*;\\nclass Solution {\\n    public static int num(String s,int l){\\n        double ans=0;\\n        for(int i=1;i<=l;i++){\\nans=ans+s.charAt(i-1)*Math.pow(10,l-i);\\n        }\\n        int a=(int)ans;\\n        return a;\\n    }\\n    public String multiply(String num1, String num2) {\\n    int l1=num1.length();\\n    int l2=num2.length();\\n  \\n\\n\\n\\n\\n        \\n    int ans1=num(num1,l1);\\n        int ans2=num(num2,l2);\\n        int fans=ans1*ans2;\\n        // System.out.println(fans);\\n        // System.out.println(ans1);\\n        // System.out.println(ans2);\\n        String aa=\"\";\\n    while(fans>0){\\n        int f=fans%10;\\n        fans=fans/10;\\naa=f+aa;\\n    }\\n\\n    return aa;\\n    }\\n}\\n\\n\\n// plz somebody tell error in my codeeee"
                    },
                    {
                        "username": "RaghavMittal56",
                        "content": "import java.util.*;\\nclass Solution {\\n    public static int num(String s,int l){\\n        double ans=0;\\n        for(int i=1;i<=l;i++){\\nans=ans+s.charAt(i-1)*Math.pow(10,l-i);\\n        }\\n        int a=(int)ans;\\n        return a;\\n    }\\n    public String multiply(String num1, String num2) {\\n    int l1=num1.length();\\n    int l2=num2.length();\\n  \\n\\n\\n\\n\\n        \\n    int ans1=num(num1,l1);\\n        int ans2=num(num2,l2);\\n        int fans=ans1*ans2;\\n        // System.out.println(fans);\\n        // System.out.println(ans1);\\n        // System.out.println(ans2);\\n        String aa=\"\";\\n    while(fans>0){\\n        int f=fans%10;\\n        fans=fans/10;\\naa=f+aa;\\n    }\\n\\n    return aa;\\n    }\\n}"
                    },
                    {
                        "username": "rkroll17",
                        "content": "How do you solve the int overflow problem?"
                    },
                    {
                        "username": "Joald",
                        "content": "the expected solution is to not convert into integers, but do the math on the strings themselves (or convert them to arrays). The simple solution is use integers that are 64-bit (int64_t in C/C++) or arbitrary length (any in Python, BigInt in JVM langs)."
                    },
                    {
                        "username": "user2510Pj",
                        "content": "Lmao, python conversion to int OP."
                    }
                ]
            },
            {
                "id": 1764210,
                "content": [
                    {
                        "username": "Jayanthsomuri",
                        "content": "->Try doing it with vertical multiplication and storing the values in the vector \\n->Store the values in the final res by typecasting into string and return the final value \\u2705"
                    },
                    {
                        "username": "wodxuming",
                        "content": "```\\nclass Solution {\\npublic:\\nstring multiply(string num1, string num2) {\\n    int m = num1.size(), n = num2.size();\\n    \\n    vector<int> res(m + n, 0);\\n    \\n    for (int i = m - 1; i >= 0; i--)\\n        for (int j = n - 1; j >= 0; j--) {\\n            int mul = (num1[i]-\\'0\\') * (num2[j]-\\'0\\');\\n            \\n            int p1 = i + j, p2 = i + j + 1;\\n            \\n            int sum = mul + res[p2];\\n            res[p2] = sum % 10;\\n            res[p1] += sum / 10;\\n        }\\n    \\n    int i = 0;\\n    while (i < res.size() && res[i] == 0)\\n        i++;\\n    \\n    string str;\\n    for (; i < res.size(); i++)\\n        str.push_back(\\'0\\' + res[i]);\\n    \\n    return str.size() == 0 ? \"0\" : str;\\n}\\n};\\n```"
                    },
                    {
                        "username": "Moofer",
                        "content": "Why is using charAt - \\'0\\' allowed?\\n\\n> convert the inputs to integer directly.\\n\\nseems like that\\'s directly converting an input using a built in function?"
                    },
                    {
                        "username": "woppi123",
                        "content": "int does not have max limit in python 3 so it can calculate any multiplication without considering its size"
                    },
                    {
                        "username": "Sandeep4769",
                        "content": "Try to make a code with elementary method of multiplication.\\nThis question may seems tough but its a easy problem go with elementary method of multiplication."
                    },
                    {
                        "username": "wodxuming",
                        "content": "```\\nclass Solution {\\npublic:\\nstring multiply(string num1, string num2) {\\n    int m = num1.size(), n = num2.size();\\n    \\n    vector<int> res(m + n, 0);\\n    \\n    for (int i = m - 1; i >= 0; i--)\\n        for (int j = n - 1; j >= 0; j--) {\\n            int mul = (num1[i]-\\'0\\') * (num2[j]-\\'0\\');\\n            \\n            int p1 = i + j, p2 = i + j + 1;\\n            \\n            int sum = mul + res[p2];\\n            res[p2] = sum % 10;\\n            res[p1] += sum / 10;\\n        }\\n    \\n    int i = 0;\\n    while (i < res.size() && res[i] == 0)\\n        i++;\\n    \\n    string str;\\n    for (; i < res.size(); i++)\\n        str.push_back(\\'0\\' + res[i]);\\n    \\n    return str.size() == 0 ? \"0\" : str;\\n}\\n};\\n```"
                    },
                    {
                        "username": "RaghavMittal56",
                        "content": "import java.util.*;\\nclass Solution {\\n    public static int num(String s,int l){\\n        double ans=0;\\n        for(int i=1;i<=l;i++){\\nans=ans+s.charAt(i-1)*Math.pow(10,l-i);\\n        }\\n        int a=(int)ans;\\n        return a;\\n    }\\n    public String multiply(String num1, String num2) {\\n    int l1=num1.length();\\n    int l2=num2.length();\\n  \\n\\n\\n\\n\\n        \\n    int ans1=num(num1,l1);\\n        int ans2=num(num2,l2);\\n        int fans=ans1*ans2;\\n        // System.out.println(fans);\\n        // System.out.println(ans1);\\n        // System.out.println(ans2);\\n        String aa=\"\";\\n    while(fans>0){\\n        int f=fans%10;\\n        fans=fans/10;\\naa=f+aa;\\n    }\\n\\n    return aa;\\n    }\\n}\\n\\n\\n// plz somebody tell error in my codeeee"
                    },
                    {
                        "username": "RaghavMittal56",
                        "content": "import java.util.*;\\nclass Solution {\\n    public static int num(String s,int l){\\n        double ans=0;\\n        for(int i=1;i<=l;i++){\\nans=ans+s.charAt(i-1)*Math.pow(10,l-i);\\n        }\\n        int a=(int)ans;\\n        return a;\\n    }\\n    public String multiply(String num1, String num2) {\\n    int l1=num1.length();\\n    int l2=num2.length();\\n  \\n\\n\\n\\n\\n        \\n    int ans1=num(num1,l1);\\n        int ans2=num(num2,l2);\\n        int fans=ans1*ans2;\\n        // System.out.println(fans);\\n        // System.out.println(ans1);\\n        // System.out.println(ans2);\\n        String aa=\"\";\\n    while(fans>0){\\n        int f=fans%10;\\n        fans=fans/10;\\naa=f+aa;\\n    }\\n\\n    return aa;\\n    }\\n}"
                    },
                    {
                        "username": "rkroll17",
                        "content": "How do you solve the int overflow problem?"
                    },
                    {
                        "username": "Joald",
                        "content": "the expected solution is to not convert into integers, but do the math on the strings themselves (or convert them to arrays). The simple solution is use integers that are 64-bit (int64_t in C/C++) or arbitrary length (any in Python, BigInt in JVM langs)."
                    },
                    {
                        "username": "user2510Pj",
                        "content": "Lmao, python conversion to int OP."
                    }
                ]
            },
            {
                "id": 1750545,
                "content": [
                    {
                        "username": "Jayanthsomuri",
                        "content": "->Try doing it with vertical multiplication and storing the values in the vector \\n->Store the values in the final res by typecasting into string and return the final value \\u2705"
                    },
                    {
                        "username": "wodxuming",
                        "content": "```\\nclass Solution {\\npublic:\\nstring multiply(string num1, string num2) {\\n    int m = num1.size(), n = num2.size();\\n    \\n    vector<int> res(m + n, 0);\\n    \\n    for (int i = m - 1; i >= 0; i--)\\n        for (int j = n - 1; j >= 0; j--) {\\n            int mul = (num1[i]-\\'0\\') * (num2[j]-\\'0\\');\\n            \\n            int p1 = i + j, p2 = i + j + 1;\\n            \\n            int sum = mul + res[p2];\\n            res[p2] = sum % 10;\\n            res[p1] += sum / 10;\\n        }\\n    \\n    int i = 0;\\n    while (i < res.size() && res[i] == 0)\\n        i++;\\n    \\n    string str;\\n    for (; i < res.size(); i++)\\n        str.push_back(\\'0\\' + res[i]);\\n    \\n    return str.size() == 0 ? \"0\" : str;\\n}\\n};\\n```"
                    },
                    {
                        "username": "Moofer",
                        "content": "Why is using charAt - \\'0\\' allowed?\\n\\n> convert the inputs to integer directly.\\n\\nseems like that\\'s directly converting an input using a built in function?"
                    },
                    {
                        "username": "woppi123",
                        "content": "int does not have max limit in python 3 so it can calculate any multiplication without considering its size"
                    },
                    {
                        "username": "Sandeep4769",
                        "content": "Try to make a code with elementary method of multiplication.\\nThis question may seems tough but its a easy problem go with elementary method of multiplication."
                    },
                    {
                        "username": "wodxuming",
                        "content": "```\\nclass Solution {\\npublic:\\nstring multiply(string num1, string num2) {\\n    int m = num1.size(), n = num2.size();\\n    \\n    vector<int> res(m + n, 0);\\n    \\n    for (int i = m - 1; i >= 0; i--)\\n        for (int j = n - 1; j >= 0; j--) {\\n            int mul = (num1[i]-\\'0\\') * (num2[j]-\\'0\\');\\n            \\n            int p1 = i + j, p2 = i + j + 1;\\n            \\n            int sum = mul + res[p2];\\n            res[p2] = sum % 10;\\n            res[p1] += sum / 10;\\n        }\\n    \\n    int i = 0;\\n    while (i < res.size() && res[i] == 0)\\n        i++;\\n    \\n    string str;\\n    for (; i < res.size(); i++)\\n        str.push_back(\\'0\\' + res[i]);\\n    \\n    return str.size() == 0 ? \"0\" : str;\\n}\\n};\\n```"
                    },
                    {
                        "username": "RaghavMittal56",
                        "content": "import java.util.*;\\nclass Solution {\\n    public static int num(String s,int l){\\n        double ans=0;\\n        for(int i=1;i<=l;i++){\\nans=ans+s.charAt(i-1)*Math.pow(10,l-i);\\n        }\\n        int a=(int)ans;\\n        return a;\\n    }\\n    public String multiply(String num1, String num2) {\\n    int l1=num1.length();\\n    int l2=num2.length();\\n  \\n\\n\\n\\n\\n        \\n    int ans1=num(num1,l1);\\n        int ans2=num(num2,l2);\\n        int fans=ans1*ans2;\\n        // System.out.println(fans);\\n        // System.out.println(ans1);\\n        // System.out.println(ans2);\\n        String aa=\"\";\\n    while(fans>0){\\n        int f=fans%10;\\n        fans=fans/10;\\naa=f+aa;\\n    }\\n\\n    return aa;\\n    }\\n}\\n\\n\\n// plz somebody tell error in my codeeee"
                    },
                    {
                        "username": "RaghavMittal56",
                        "content": "import java.util.*;\\nclass Solution {\\n    public static int num(String s,int l){\\n        double ans=0;\\n        for(int i=1;i<=l;i++){\\nans=ans+s.charAt(i-1)*Math.pow(10,l-i);\\n        }\\n        int a=(int)ans;\\n        return a;\\n    }\\n    public String multiply(String num1, String num2) {\\n    int l1=num1.length();\\n    int l2=num2.length();\\n  \\n\\n\\n\\n\\n        \\n    int ans1=num(num1,l1);\\n        int ans2=num(num2,l2);\\n        int fans=ans1*ans2;\\n        // System.out.println(fans);\\n        // System.out.println(ans1);\\n        // System.out.println(ans2);\\n        String aa=\"\";\\n    while(fans>0){\\n        int f=fans%10;\\n        fans=fans/10;\\naa=f+aa;\\n    }\\n\\n    return aa;\\n    }\\n}"
                    },
                    {
                        "username": "rkroll17",
                        "content": "How do you solve the int overflow problem?"
                    },
                    {
                        "username": "Joald",
                        "content": "the expected solution is to not convert into integers, but do the math on the strings themselves (or convert them to arrays). The simple solution is use integers that are 64-bit (int64_t in C/C++) or arbitrary length (any in Python, BigInt in JVM langs)."
                    },
                    {
                        "username": "user2510Pj",
                        "content": "Lmao, python conversion to int OP."
                    }
                ]
            },
            {
                "id": 1742128,
                "content": [
                    {
                        "username": "Jayanthsomuri",
                        "content": "->Try doing it with vertical multiplication and storing the values in the vector \\n->Store the values in the final res by typecasting into string and return the final value \\u2705"
                    },
                    {
                        "username": "wodxuming",
                        "content": "```\\nclass Solution {\\npublic:\\nstring multiply(string num1, string num2) {\\n    int m = num1.size(), n = num2.size();\\n    \\n    vector<int> res(m + n, 0);\\n    \\n    for (int i = m - 1; i >= 0; i--)\\n        for (int j = n - 1; j >= 0; j--) {\\n            int mul = (num1[i]-\\'0\\') * (num2[j]-\\'0\\');\\n            \\n            int p1 = i + j, p2 = i + j + 1;\\n            \\n            int sum = mul + res[p2];\\n            res[p2] = sum % 10;\\n            res[p1] += sum / 10;\\n        }\\n    \\n    int i = 0;\\n    while (i < res.size() && res[i] == 0)\\n        i++;\\n    \\n    string str;\\n    for (; i < res.size(); i++)\\n        str.push_back(\\'0\\' + res[i]);\\n    \\n    return str.size() == 0 ? \"0\" : str;\\n}\\n};\\n```"
                    },
                    {
                        "username": "Moofer",
                        "content": "Why is using charAt - \\'0\\' allowed?\\n\\n> convert the inputs to integer directly.\\n\\nseems like that\\'s directly converting an input using a built in function?"
                    },
                    {
                        "username": "woppi123",
                        "content": "int does not have max limit in python 3 so it can calculate any multiplication without considering its size"
                    },
                    {
                        "username": "Sandeep4769",
                        "content": "Try to make a code with elementary method of multiplication.\\nThis question may seems tough but its a easy problem go with elementary method of multiplication."
                    },
                    {
                        "username": "wodxuming",
                        "content": "```\\nclass Solution {\\npublic:\\nstring multiply(string num1, string num2) {\\n    int m = num1.size(), n = num2.size();\\n    \\n    vector<int> res(m + n, 0);\\n    \\n    for (int i = m - 1; i >= 0; i--)\\n        for (int j = n - 1; j >= 0; j--) {\\n            int mul = (num1[i]-\\'0\\') * (num2[j]-\\'0\\');\\n            \\n            int p1 = i + j, p2 = i + j + 1;\\n            \\n            int sum = mul + res[p2];\\n            res[p2] = sum % 10;\\n            res[p1] += sum / 10;\\n        }\\n    \\n    int i = 0;\\n    while (i < res.size() && res[i] == 0)\\n        i++;\\n    \\n    string str;\\n    for (; i < res.size(); i++)\\n        str.push_back(\\'0\\' + res[i]);\\n    \\n    return str.size() == 0 ? \"0\" : str;\\n}\\n};\\n```"
                    },
                    {
                        "username": "RaghavMittal56",
                        "content": "import java.util.*;\\nclass Solution {\\n    public static int num(String s,int l){\\n        double ans=0;\\n        for(int i=1;i<=l;i++){\\nans=ans+s.charAt(i-1)*Math.pow(10,l-i);\\n        }\\n        int a=(int)ans;\\n        return a;\\n    }\\n    public String multiply(String num1, String num2) {\\n    int l1=num1.length();\\n    int l2=num2.length();\\n  \\n\\n\\n\\n\\n        \\n    int ans1=num(num1,l1);\\n        int ans2=num(num2,l2);\\n        int fans=ans1*ans2;\\n        // System.out.println(fans);\\n        // System.out.println(ans1);\\n        // System.out.println(ans2);\\n        String aa=\"\";\\n    while(fans>0){\\n        int f=fans%10;\\n        fans=fans/10;\\naa=f+aa;\\n    }\\n\\n    return aa;\\n    }\\n}\\n\\n\\n// plz somebody tell error in my codeeee"
                    },
                    {
                        "username": "RaghavMittal56",
                        "content": "import java.util.*;\\nclass Solution {\\n    public static int num(String s,int l){\\n        double ans=0;\\n        for(int i=1;i<=l;i++){\\nans=ans+s.charAt(i-1)*Math.pow(10,l-i);\\n        }\\n        int a=(int)ans;\\n        return a;\\n    }\\n    public String multiply(String num1, String num2) {\\n    int l1=num1.length();\\n    int l2=num2.length();\\n  \\n\\n\\n\\n\\n        \\n    int ans1=num(num1,l1);\\n        int ans2=num(num2,l2);\\n        int fans=ans1*ans2;\\n        // System.out.println(fans);\\n        // System.out.println(ans1);\\n        // System.out.println(ans2);\\n        String aa=\"\";\\n    while(fans>0){\\n        int f=fans%10;\\n        fans=fans/10;\\naa=f+aa;\\n    }\\n\\n    return aa;\\n    }\\n}"
                    },
                    {
                        "username": "rkroll17",
                        "content": "How do you solve the int overflow problem?"
                    },
                    {
                        "username": "Joald",
                        "content": "the expected solution is to not convert into integers, but do the math on the strings themselves (or convert them to arrays). The simple solution is use integers that are 64-bit (int64_t in C/C++) or arbitrary length (any in Python, BigInt in JVM langs)."
                    },
                    {
                        "username": "user2510Pj",
                        "content": "Lmao, python conversion to int OP."
                    }
                ]
            },
            {
                "id": 1729001,
                "content": [
                    {
                        "username": "Jayanthsomuri",
                        "content": "->Try doing it with vertical multiplication and storing the values in the vector \\n->Store the values in the final res by typecasting into string and return the final value \\u2705"
                    },
                    {
                        "username": "wodxuming",
                        "content": "```\\nclass Solution {\\npublic:\\nstring multiply(string num1, string num2) {\\n    int m = num1.size(), n = num2.size();\\n    \\n    vector<int> res(m + n, 0);\\n    \\n    for (int i = m - 1; i >= 0; i--)\\n        for (int j = n - 1; j >= 0; j--) {\\n            int mul = (num1[i]-\\'0\\') * (num2[j]-\\'0\\');\\n            \\n            int p1 = i + j, p2 = i + j + 1;\\n            \\n            int sum = mul + res[p2];\\n            res[p2] = sum % 10;\\n            res[p1] += sum / 10;\\n        }\\n    \\n    int i = 0;\\n    while (i < res.size() && res[i] == 0)\\n        i++;\\n    \\n    string str;\\n    for (; i < res.size(); i++)\\n        str.push_back(\\'0\\' + res[i]);\\n    \\n    return str.size() == 0 ? \"0\" : str;\\n}\\n};\\n```"
                    },
                    {
                        "username": "Moofer",
                        "content": "Why is using charAt - \\'0\\' allowed?\\n\\n> convert the inputs to integer directly.\\n\\nseems like that\\'s directly converting an input using a built in function?"
                    },
                    {
                        "username": "woppi123",
                        "content": "int does not have max limit in python 3 so it can calculate any multiplication without considering its size"
                    },
                    {
                        "username": "Sandeep4769",
                        "content": "Try to make a code with elementary method of multiplication.\\nThis question may seems tough but its a easy problem go with elementary method of multiplication."
                    },
                    {
                        "username": "wodxuming",
                        "content": "```\\nclass Solution {\\npublic:\\nstring multiply(string num1, string num2) {\\n    int m = num1.size(), n = num2.size();\\n    \\n    vector<int> res(m + n, 0);\\n    \\n    for (int i = m - 1; i >= 0; i--)\\n        for (int j = n - 1; j >= 0; j--) {\\n            int mul = (num1[i]-\\'0\\') * (num2[j]-\\'0\\');\\n            \\n            int p1 = i + j, p2 = i + j + 1;\\n            \\n            int sum = mul + res[p2];\\n            res[p2] = sum % 10;\\n            res[p1] += sum / 10;\\n        }\\n    \\n    int i = 0;\\n    while (i < res.size() && res[i] == 0)\\n        i++;\\n    \\n    string str;\\n    for (; i < res.size(); i++)\\n        str.push_back(\\'0\\' + res[i]);\\n    \\n    return str.size() == 0 ? \"0\" : str;\\n}\\n};\\n```"
                    },
                    {
                        "username": "RaghavMittal56",
                        "content": "import java.util.*;\\nclass Solution {\\n    public static int num(String s,int l){\\n        double ans=0;\\n        for(int i=1;i<=l;i++){\\nans=ans+s.charAt(i-1)*Math.pow(10,l-i);\\n        }\\n        int a=(int)ans;\\n        return a;\\n    }\\n    public String multiply(String num1, String num2) {\\n    int l1=num1.length();\\n    int l2=num2.length();\\n  \\n\\n\\n\\n\\n        \\n    int ans1=num(num1,l1);\\n        int ans2=num(num2,l2);\\n        int fans=ans1*ans2;\\n        // System.out.println(fans);\\n        // System.out.println(ans1);\\n        // System.out.println(ans2);\\n        String aa=\"\";\\n    while(fans>0){\\n        int f=fans%10;\\n        fans=fans/10;\\naa=f+aa;\\n    }\\n\\n    return aa;\\n    }\\n}\\n\\n\\n// plz somebody tell error in my codeeee"
                    },
                    {
                        "username": "RaghavMittal56",
                        "content": "import java.util.*;\\nclass Solution {\\n    public static int num(String s,int l){\\n        double ans=0;\\n        for(int i=1;i<=l;i++){\\nans=ans+s.charAt(i-1)*Math.pow(10,l-i);\\n        }\\n        int a=(int)ans;\\n        return a;\\n    }\\n    public String multiply(String num1, String num2) {\\n    int l1=num1.length();\\n    int l2=num2.length();\\n  \\n\\n\\n\\n\\n        \\n    int ans1=num(num1,l1);\\n        int ans2=num(num2,l2);\\n        int fans=ans1*ans2;\\n        // System.out.println(fans);\\n        // System.out.println(ans1);\\n        // System.out.println(ans2);\\n        String aa=\"\";\\n    while(fans>0){\\n        int f=fans%10;\\n        fans=fans/10;\\naa=f+aa;\\n    }\\n\\n    return aa;\\n    }\\n}"
                    },
                    {
                        "username": "rkroll17",
                        "content": "How do you solve the int overflow problem?"
                    },
                    {
                        "username": "Joald",
                        "content": "the expected solution is to not convert into integers, but do the math on the strings themselves (or convert them to arrays). The simple solution is use integers that are 64-bit (int64_t in C/C++) or arbitrary length (any in Python, BigInt in JVM langs)."
                    },
                    {
                        "username": "user2510Pj",
                        "content": "Lmao, python conversion to int OP."
                    }
                ]
            },
            {
                "id": 1722086,
                "content": [
                    {
                        "username": "Jayanthsomuri",
                        "content": "->Try doing it with vertical multiplication and storing the values in the vector \\n->Store the values in the final res by typecasting into string and return the final value \\u2705"
                    },
                    {
                        "username": "wodxuming",
                        "content": "```\\nclass Solution {\\npublic:\\nstring multiply(string num1, string num2) {\\n    int m = num1.size(), n = num2.size();\\n    \\n    vector<int> res(m + n, 0);\\n    \\n    for (int i = m - 1; i >= 0; i--)\\n        for (int j = n - 1; j >= 0; j--) {\\n            int mul = (num1[i]-\\'0\\') * (num2[j]-\\'0\\');\\n            \\n            int p1 = i + j, p2 = i + j + 1;\\n            \\n            int sum = mul + res[p2];\\n            res[p2] = sum % 10;\\n            res[p1] += sum / 10;\\n        }\\n    \\n    int i = 0;\\n    while (i < res.size() && res[i] == 0)\\n        i++;\\n    \\n    string str;\\n    for (; i < res.size(); i++)\\n        str.push_back(\\'0\\' + res[i]);\\n    \\n    return str.size() == 0 ? \"0\" : str;\\n}\\n};\\n```"
                    },
                    {
                        "username": "Moofer",
                        "content": "Why is using charAt - \\'0\\' allowed?\\n\\n> convert the inputs to integer directly.\\n\\nseems like that\\'s directly converting an input using a built in function?"
                    },
                    {
                        "username": "woppi123",
                        "content": "int does not have max limit in python 3 so it can calculate any multiplication without considering its size"
                    },
                    {
                        "username": "Sandeep4769",
                        "content": "Try to make a code with elementary method of multiplication.\\nThis question may seems tough but its a easy problem go with elementary method of multiplication."
                    },
                    {
                        "username": "wodxuming",
                        "content": "```\\nclass Solution {\\npublic:\\nstring multiply(string num1, string num2) {\\n    int m = num1.size(), n = num2.size();\\n    \\n    vector<int> res(m + n, 0);\\n    \\n    for (int i = m - 1; i >= 0; i--)\\n        for (int j = n - 1; j >= 0; j--) {\\n            int mul = (num1[i]-\\'0\\') * (num2[j]-\\'0\\');\\n            \\n            int p1 = i + j, p2 = i + j + 1;\\n            \\n            int sum = mul + res[p2];\\n            res[p2] = sum % 10;\\n            res[p1] += sum / 10;\\n        }\\n    \\n    int i = 0;\\n    while (i < res.size() && res[i] == 0)\\n        i++;\\n    \\n    string str;\\n    for (; i < res.size(); i++)\\n        str.push_back(\\'0\\' + res[i]);\\n    \\n    return str.size() == 0 ? \"0\" : str;\\n}\\n};\\n```"
                    },
                    {
                        "username": "RaghavMittal56",
                        "content": "import java.util.*;\\nclass Solution {\\n    public static int num(String s,int l){\\n        double ans=0;\\n        for(int i=1;i<=l;i++){\\nans=ans+s.charAt(i-1)*Math.pow(10,l-i);\\n        }\\n        int a=(int)ans;\\n        return a;\\n    }\\n    public String multiply(String num1, String num2) {\\n    int l1=num1.length();\\n    int l2=num2.length();\\n  \\n\\n\\n\\n\\n        \\n    int ans1=num(num1,l1);\\n        int ans2=num(num2,l2);\\n        int fans=ans1*ans2;\\n        // System.out.println(fans);\\n        // System.out.println(ans1);\\n        // System.out.println(ans2);\\n        String aa=\"\";\\n    while(fans>0){\\n        int f=fans%10;\\n        fans=fans/10;\\naa=f+aa;\\n    }\\n\\n    return aa;\\n    }\\n}\\n\\n\\n// plz somebody tell error in my codeeee"
                    },
                    {
                        "username": "RaghavMittal56",
                        "content": "import java.util.*;\\nclass Solution {\\n    public static int num(String s,int l){\\n        double ans=0;\\n        for(int i=1;i<=l;i++){\\nans=ans+s.charAt(i-1)*Math.pow(10,l-i);\\n        }\\n        int a=(int)ans;\\n        return a;\\n    }\\n    public String multiply(String num1, String num2) {\\n    int l1=num1.length();\\n    int l2=num2.length();\\n  \\n\\n\\n\\n\\n        \\n    int ans1=num(num1,l1);\\n        int ans2=num(num2,l2);\\n        int fans=ans1*ans2;\\n        // System.out.println(fans);\\n        // System.out.println(ans1);\\n        // System.out.println(ans2);\\n        String aa=\"\";\\n    while(fans>0){\\n        int f=fans%10;\\n        fans=fans/10;\\naa=f+aa;\\n    }\\n\\n    return aa;\\n    }\\n}"
                    },
                    {
                        "username": "rkroll17",
                        "content": "How do you solve the int overflow problem?"
                    },
                    {
                        "username": "Joald",
                        "content": "the expected solution is to not convert into integers, but do the math on the strings themselves (or convert them to arrays). The simple solution is use integers that are 64-bit (int64_t in C/C++) or arbitrary length (any in Python, BigInt in JVM langs)."
                    },
                    {
                        "username": "user2510Pj",
                        "content": "Lmao, python conversion to int OP."
                    }
                ]
            },
            {
                "id": 1716010,
                "content": [
                    {
                        "username": "Jayanthsomuri",
                        "content": "->Try doing it with vertical multiplication and storing the values in the vector \\n->Store the values in the final res by typecasting into string and return the final value \\u2705"
                    },
                    {
                        "username": "wodxuming",
                        "content": "```\\nclass Solution {\\npublic:\\nstring multiply(string num1, string num2) {\\n    int m = num1.size(), n = num2.size();\\n    \\n    vector<int> res(m + n, 0);\\n    \\n    for (int i = m - 1; i >= 0; i--)\\n        for (int j = n - 1; j >= 0; j--) {\\n            int mul = (num1[i]-\\'0\\') * (num2[j]-\\'0\\');\\n            \\n            int p1 = i + j, p2 = i + j + 1;\\n            \\n            int sum = mul + res[p2];\\n            res[p2] = sum % 10;\\n            res[p1] += sum / 10;\\n        }\\n    \\n    int i = 0;\\n    while (i < res.size() && res[i] == 0)\\n        i++;\\n    \\n    string str;\\n    for (; i < res.size(); i++)\\n        str.push_back(\\'0\\' + res[i]);\\n    \\n    return str.size() == 0 ? \"0\" : str;\\n}\\n};\\n```"
                    },
                    {
                        "username": "Moofer",
                        "content": "Why is using charAt - \\'0\\' allowed?\\n\\n> convert the inputs to integer directly.\\n\\nseems like that\\'s directly converting an input using a built in function?"
                    },
                    {
                        "username": "woppi123",
                        "content": "int does not have max limit in python 3 so it can calculate any multiplication without considering its size"
                    },
                    {
                        "username": "Sandeep4769",
                        "content": "Try to make a code with elementary method of multiplication.\\nThis question may seems tough but its a easy problem go with elementary method of multiplication."
                    },
                    {
                        "username": "wodxuming",
                        "content": "```\\nclass Solution {\\npublic:\\nstring multiply(string num1, string num2) {\\n    int m = num1.size(), n = num2.size();\\n    \\n    vector<int> res(m + n, 0);\\n    \\n    for (int i = m - 1; i >= 0; i--)\\n        for (int j = n - 1; j >= 0; j--) {\\n            int mul = (num1[i]-\\'0\\') * (num2[j]-\\'0\\');\\n            \\n            int p1 = i + j, p2 = i + j + 1;\\n            \\n            int sum = mul + res[p2];\\n            res[p2] = sum % 10;\\n            res[p1] += sum / 10;\\n        }\\n    \\n    int i = 0;\\n    while (i < res.size() && res[i] == 0)\\n        i++;\\n    \\n    string str;\\n    for (; i < res.size(); i++)\\n        str.push_back(\\'0\\' + res[i]);\\n    \\n    return str.size() == 0 ? \"0\" : str;\\n}\\n};\\n```"
                    },
                    {
                        "username": "RaghavMittal56",
                        "content": "import java.util.*;\\nclass Solution {\\n    public static int num(String s,int l){\\n        double ans=0;\\n        for(int i=1;i<=l;i++){\\nans=ans+s.charAt(i-1)*Math.pow(10,l-i);\\n        }\\n        int a=(int)ans;\\n        return a;\\n    }\\n    public String multiply(String num1, String num2) {\\n    int l1=num1.length();\\n    int l2=num2.length();\\n  \\n\\n\\n\\n\\n        \\n    int ans1=num(num1,l1);\\n        int ans2=num(num2,l2);\\n        int fans=ans1*ans2;\\n        // System.out.println(fans);\\n        // System.out.println(ans1);\\n        // System.out.println(ans2);\\n        String aa=\"\";\\n    while(fans>0){\\n        int f=fans%10;\\n        fans=fans/10;\\naa=f+aa;\\n    }\\n\\n    return aa;\\n    }\\n}\\n\\n\\n// plz somebody tell error in my codeeee"
                    },
                    {
                        "username": "RaghavMittal56",
                        "content": "import java.util.*;\\nclass Solution {\\n    public static int num(String s,int l){\\n        double ans=0;\\n        for(int i=1;i<=l;i++){\\nans=ans+s.charAt(i-1)*Math.pow(10,l-i);\\n        }\\n        int a=(int)ans;\\n        return a;\\n    }\\n    public String multiply(String num1, String num2) {\\n    int l1=num1.length();\\n    int l2=num2.length();\\n  \\n\\n\\n\\n\\n        \\n    int ans1=num(num1,l1);\\n        int ans2=num(num2,l2);\\n        int fans=ans1*ans2;\\n        // System.out.println(fans);\\n        // System.out.println(ans1);\\n        // System.out.println(ans2);\\n        String aa=\"\";\\n    while(fans>0){\\n        int f=fans%10;\\n        fans=fans/10;\\naa=f+aa;\\n    }\\n\\n    return aa;\\n    }\\n}"
                    },
                    {
                        "username": "rkroll17",
                        "content": "How do you solve the int overflow problem?"
                    },
                    {
                        "username": "Joald",
                        "content": "the expected solution is to not convert into integers, but do the math on the strings themselves (or convert them to arrays). The simple solution is use integers that are 64-bit (int64_t in C/C++) or arbitrary length (any in Python, BigInt in JVM langs)."
                    },
                    {
                        "username": "user2510Pj",
                        "content": "Lmao, python conversion to int OP."
                    }
                ]
            },
            {
                "id": 1716007,
                "content": [
                    {
                        "username": "Jayanthsomuri",
                        "content": "->Try doing it with vertical multiplication and storing the values in the vector \\n->Store the values in the final res by typecasting into string and return the final value \\u2705"
                    },
                    {
                        "username": "wodxuming",
                        "content": "```\\nclass Solution {\\npublic:\\nstring multiply(string num1, string num2) {\\n    int m = num1.size(), n = num2.size();\\n    \\n    vector<int> res(m + n, 0);\\n    \\n    for (int i = m - 1; i >= 0; i--)\\n        for (int j = n - 1; j >= 0; j--) {\\n            int mul = (num1[i]-\\'0\\') * (num2[j]-\\'0\\');\\n            \\n            int p1 = i + j, p2 = i + j + 1;\\n            \\n            int sum = mul + res[p2];\\n            res[p2] = sum % 10;\\n            res[p1] += sum / 10;\\n        }\\n    \\n    int i = 0;\\n    while (i < res.size() && res[i] == 0)\\n        i++;\\n    \\n    string str;\\n    for (; i < res.size(); i++)\\n        str.push_back(\\'0\\' + res[i]);\\n    \\n    return str.size() == 0 ? \"0\" : str;\\n}\\n};\\n```"
                    },
                    {
                        "username": "Moofer",
                        "content": "Why is using charAt - \\'0\\' allowed?\\n\\n> convert the inputs to integer directly.\\n\\nseems like that\\'s directly converting an input using a built in function?"
                    },
                    {
                        "username": "woppi123",
                        "content": "int does not have max limit in python 3 so it can calculate any multiplication without considering its size"
                    },
                    {
                        "username": "Sandeep4769",
                        "content": "Try to make a code with elementary method of multiplication.\\nThis question may seems tough but its a easy problem go with elementary method of multiplication."
                    },
                    {
                        "username": "wodxuming",
                        "content": "```\\nclass Solution {\\npublic:\\nstring multiply(string num1, string num2) {\\n    int m = num1.size(), n = num2.size();\\n    \\n    vector<int> res(m + n, 0);\\n    \\n    for (int i = m - 1; i >= 0; i--)\\n        for (int j = n - 1; j >= 0; j--) {\\n            int mul = (num1[i]-\\'0\\') * (num2[j]-\\'0\\');\\n            \\n            int p1 = i + j, p2 = i + j + 1;\\n            \\n            int sum = mul + res[p2];\\n            res[p2] = sum % 10;\\n            res[p1] += sum / 10;\\n        }\\n    \\n    int i = 0;\\n    while (i < res.size() && res[i] == 0)\\n        i++;\\n    \\n    string str;\\n    for (; i < res.size(); i++)\\n        str.push_back(\\'0\\' + res[i]);\\n    \\n    return str.size() == 0 ? \"0\" : str;\\n}\\n};\\n```"
                    },
                    {
                        "username": "RaghavMittal56",
                        "content": "import java.util.*;\\nclass Solution {\\n    public static int num(String s,int l){\\n        double ans=0;\\n        for(int i=1;i<=l;i++){\\nans=ans+s.charAt(i-1)*Math.pow(10,l-i);\\n        }\\n        int a=(int)ans;\\n        return a;\\n    }\\n    public String multiply(String num1, String num2) {\\n    int l1=num1.length();\\n    int l2=num2.length();\\n  \\n\\n\\n\\n\\n        \\n    int ans1=num(num1,l1);\\n        int ans2=num(num2,l2);\\n        int fans=ans1*ans2;\\n        // System.out.println(fans);\\n        // System.out.println(ans1);\\n        // System.out.println(ans2);\\n        String aa=\"\";\\n    while(fans>0){\\n        int f=fans%10;\\n        fans=fans/10;\\naa=f+aa;\\n    }\\n\\n    return aa;\\n    }\\n}\\n\\n\\n// plz somebody tell error in my codeeee"
                    },
                    {
                        "username": "RaghavMittal56",
                        "content": "import java.util.*;\\nclass Solution {\\n    public static int num(String s,int l){\\n        double ans=0;\\n        for(int i=1;i<=l;i++){\\nans=ans+s.charAt(i-1)*Math.pow(10,l-i);\\n        }\\n        int a=(int)ans;\\n        return a;\\n    }\\n    public String multiply(String num1, String num2) {\\n    int l1=num1.length();\\n    int l2=num2.length();\\n  \\n\\n\\n\\n\\n        \\n    int ans1=num(num1,l1);\\n        int ans2=num(num2,l2);\\n        int fans=ans1*ans2;\\n        // System.out.println(fans);\\n        // System.out.println(ans1);\\n        // System.out.println(ans2);\\n        String aa=\"\";\\n    while(fans>0){\\n        int f=fans%10;\\n        fans=fans/10;\\naa=f+aa;\\n    }\\n\\n    return aa;\\n    }\\n}"
                    },
                    {
                        "username": "rkroll17",
                        "content": "How do you solve the int overflow problem?"
                    },
                    {
                        "username": "Joald",
                        "content": "the expected solution is to not convert into integers, but do the math on the strings themselves (or convert them to arrays). The simple solution is use integers that are 64-bit (int64_t in C/C++) or arbitrary length (any in Python, BigInt in JVM langs)."
                    },
                    {
                        "username": "user2510Pj",
                        "content": "Lmao, python conversion to int OP."
                    }
                ]
            },
            {
                "id": 1712369,
                "content": [
                    {
                        "username": "Jayanthsomuri",
                        "content": "->Try doing it with vertical multiplication and storing the values in the vector \\n->Store the values in the final res by typecasting into string and return the final value \\u2705"
                    },
                    {
                        "username": "wodxuming",
                        "content": "```\\nclass Solution {\\npublic:\\nstring multiply(string num1, string num2) {\\n    int m = num1.size(), n = num2.size();\\n    \\n    vector<int> res(m + n, 0);\\n    \\n    for (int i = m - 1; i >= 0; i--)\\n        for (int j = n - 1; j >= 0; j--) {\\n            int mul = (num1[i]-\\'0\\') * (num2[j]-\\'0\\');\\n            \\n            int p1 = i + j, p2 = i + j + 1;\\n            \\n            int sum = mul + res[p2];\\n            res[p2] = sum % 10;\\n            res[p1] += sum / 10;\\n        }\\n    \\n    int i = 0;\\n    while (i < res.size() && res[i] == 0)\\n        i++;\\n    \\n    string str;\\n    for (; i < res.size(); i++)\\n        str.push_back(\\'0\\' + res[i]);\\n    \\n    return str.size() == 0 ? \"0\" : str;\\n}\\n};\\n```"
                    },
                    {
                        "username": "Moofer",
                        "content": "Why is using charAt - \\'0\\' allowed?\\n\\n> convert the inputs to integer directly.\\n\\nseems like that\\'s directly converting an input using a built in function?"
                    },
                    {
                        "username": "woppi123",
                        "content": "int does not have max limit in python 3 so it can calculate any multiplication without considering its size"
                    },
                    {
                        "username": "Sandeep4769",
                        "content": "Try to make a code with elementary method of multiplication.\\nThis question may seems tough but its a easy problem go with elementary method of multiplication."
                    },
                    {
                        "username": "wodxuming",
                        "content": "```\\nclass Solution {\\npublic:\\nstring multiply(string num1, string num2) {\\n    int m = num1.size(), n = num2.size();\\n    \\n    vector<int> res(m + n, 0);\\n    \\n    for (int i = m - 1; i >= 0; i--)\\n        for (int j = n - 1; j >= 0; j--) {\\n            int mul = (num1[i]-\\'0\\') * (num2[j]-\\'0\\');\\n            \\n            int p1 = i + j, p2 = i + j + 1;\\n            \\n            int sum = mul + res[p2];\\n            res[p2] = sum % 10;\\n            res[p1] += sum / 10;\\n        }\\n    \\n    int i = 0;\\n    while (i < res.size() && res[i] == 0)\\n        i++;\\n    \\n    string str;\\n    for (; i < res.size(); i++)\\n        str.push_back(\\'0\\' + res[i]);\\n    \\n    return str.size() == 0 ? \"0\" : str;\\n}\\n};\\n```"
                    },
                    {
                        "username": "RaghavMittal56",
                        "content": "import java.util.*;\\nclass Solution {\\n    public static int num(String s,int l){\\n        double ans=0;\\n        for(int i=1;i<=l;i++){\\nans=ans+s.charAt(i-1)*Math.pow(10,l-i);\\n        }\\n        int a=(int)ans;\\n        return a;\\n    }\\n    public String multiply(String num1, String num2) {\\n    int l1=num1.length();\\n    int l2=num2.length();\\n  \\n\\n\\n\\n\\n        \\n    int ans1=num(num1,l1);\\n        int ans2=num(num2,l2);\\n        int fans=ans1*ans2;\\n        // System.out.println(fans);\\n        // System.out.println(ans1);\\n        // System.out.println(ans2);\\n        String aa=\"\";\\n    while(fans>0){\\n        int f=fans%10;\\n        fans=fans/10;\\naa=f+aa;\\n    }\\n\\n    return aa;\\n    }\\n}\\n\\n\\n// plz somebody tell error in my codeeee"
                    },
                    {
                        "username": "RaghavMittal56",
                        "content": "import java.util.*;\\nclass Solution {\\n    public static int num(String s,int l){\\n        double ans=0;\\n        for(int i=1;i<=l;i++){\\nans=ans+s.charAt(i-1)*Math.pow(10,l-i);\\n        }\\n        int a=(int)ans;\\n        return a;\\n    }\\n    public String multiply(String num1, String num2) {\\n    int l1=num1.length();\\n    int l2=num2.length();\\n  \\n\\n\\n\\n\\n        \\n    int ans1=num(num1,l1);\\n        int ans2=num(num2,l2);\\n        int fans=ans1*ans2;\\n        // System.out.println(fans);\\n        // System.out.println(ans1);\\n        // System.out.println(ans2);\\n        String aa=\"\";\\n    while(fans>0){\\n        int f=fans%10;\\n        fans=fans/10;\\naa=f+aa;\\n    }\\n\\n    return aa;\\n    }\\n}"
                    },
                    {
                        "username": "rkroll17",
                        "content": "How do you solve the int overflow problem?"
                    },
                    {
                        "username": "Joald",
                        "content": "the expected solution is to not convert into integers, but do the math on the strings themselves (or convert them to arrays). The simple solution is use integers that are 64-bit (int64_t in C/C++) or arbitrary length (any in Python, BigInt in JVM langs)."
                    },
                    {
                        "username": "user2510Pj",
                        "content": "Lmao, python conversion to int OP."
                    }
                ]
            },
            {
                "id": 1702421,
                "content": [
                    {
                        "username": "Jayanthsomuri",
                        "content": "->Try doing it with vertical multiplication and storing the values in the vector \\n->Store the values in the final res by typecasting into string and return the final value \\u2705"
                    },
                    {
                        "username": "wodxuming",
                        "content": "```\\nclass Solution {\\npublic:\\nstring multiply(string num1, string num2) {\\n    int m = num1.size(), n = num2.size();\\n    \\n    vector<int> res(m + n, 0);\\n    \\n    for (int i = m - 1; i >= 0; i--)\\n        for (int j = n - 1; j >= 0; j--) {\\n            int mul = (num1[i]-\\'0\\') * (num2[j]-\\'0\\');\\n            \\n            int p1 = i + j, p2 = i + j + 1;\\n            \\n            int sum = mul + res[p2];\\n            res[p2] = sum % 10;\\n            res[p1] += sum / 10;\\n        }\\n    \\n    int i = 0;\\n    while (i < res.size() && res[i] == 0)\\n        i++;\\n    \\n    string str;\\n    for (; i < res.size(); i++)\\n        str.push_back(\\'0\\' + res[i]);\\n    \\n    return str.size() == 0 ? \"0\" : str;\\n}\\n};\\n```"
                    },
                    {
                        "username": "Moofer",
                        "content": "Why is using charAt - \\'0\\' allowed?\\n\\n> convert the inputs to integer directly.\\n\\nseems like that\\'s directly converting an input using a built in function?"
                    },
                    {
                        "username": "woppi123",
                        "content": "int does not have max limit in python 3 so it can calculate any multiplication without considering its size"
                    },
                    {
                        "username": "Sandeep4769",
                        "content": "Try to make a code with elementary method of multiplication.\\nThis question may seems tough but its a easy problem go with elementary method of multiplication."
                    },
                    {
                        "username": "wodxuming",
                        "content": "```\\nclass Solution {\\npublic:\\nstring multiply(string num1, string num2) {\\n    int m = num1.size(), n = num2.size();\\n    \\n    vector<int> res(m + n, 0);\\n    \\n    for (int i = m - 1; i >= 0; i--)\\n        for (int j = n - 1; j >= 0; j--) {\\n            int mul = (num1[i]-\\'0\\') * (num2[j]-\\'0\\');\\n            \\n            int p1 = i + j, p2 = i + j + 1;\\n            \\n            int sum = mul + res[p2];\\n            res[p2] = sum % 10;\\n            res[p1] += sum / 10;\\n        }\\n    \\n    int i = 0;\\n    while (i < res.size() && res[i] == 0)\\n        i++;\\n    \\n    string str;\\n    for (; i < res.size(); i++)\\n        str.push_back(\\'0\\' + res[i]);\\n    \\n    return str.size() == 0 ? \"0\" : str;\\n}\\n};\\n```"
                    },
                    {
                        "username": "RaghavMittal56",
                        "content": "import java.util.*;\\nclass Solution {\\n    public static int num(String s,int l){\\n        double ans=0;\\n        for(int i=1;i<=l;i++){\\nans=ans+s.charAt(i-1)*Math.pow(10,l-i);\\n        }\\n        int a=(int)ans;\\n        return a;\\n    }\\n    public String multiply(String num1, String num2) {\\n    int l1=num1.length();\\n    int l2=num2.length();\\n  \\n\\n\\n\\n\\n        \\n    int ans1=num(num1,l1);\\n        int ans2=num(num2,l2);\\n        int fans=ans1*ans2;\\n        // System.out.println(fans);\\n        // System.out.println(ans1);\\n        // System.out.println(ans2);\\n        String aa=\"\";\\n    while(fans>0){\\n        int f=fans%10;\\n        fans=fans/10;\\naa=f+aa;\\n    }\\n\\n    return aa;\\n    }\\n}\\n\\n\\n// plz somebody tell error in my codeeee"
                    },
                    {
                        "username": "RaghavMittal56",
                        "content": "import java.util.*;\\nclass Solution {\\n    public static int num(String s,int l){\\n        double ans=0;\\n        for(int i=1;i<=l;i++){\\nans=ans+s.charAt(i-1)*Math.pow(10,l-i);\\n        }\\n        int a=(int)ans;\\n        return a;\\n    }\\n    public String multiply(String num1, String num2) {\\n    int l1=num1.length();\\n    int l2=num2.length();\\n  \\n\\n\\n\\n\\n        \\n    int ans1=num(num1,l1);\\n        int ans2=num(num2,l2);\\n        int fans=ans1*ans2;\\n        // System.out.println(fans);\\n        // System.out.println(ans1);\\n        // System.out.println(ans2);\\n        String aa=\"\";\\n    while(fans>0){\\n        int f=fans%10;\\n        fans=fans/10;\\naa=f+aa;\\n    }\\n\\n    return aa;\\n    }\\n}"
                    },
                    {
                        "username": "rkroll17",
                        "content": "How do you solve the int overflow problem?"
                    },
                    {
                        "username": "Joald",
                        "content": "the expected solution is to not convert into integers, but do the math on the strings themselves (or convert them to arrays). The simple solution is use integers that are 64-bit (int64_t in C/C++) or arbitrary length (any in Python, BigInt in JVM langs)."
                    },
                    {
                        "username": "user2510Pj",
                        "content": "Lmao, python conversion to int OP."
                    }
                ]
            }
        ]
    },
    {
        "title": "Reorder List",
        "question_content": "<p>You are given the head of a singly linked-list. The list can be represented as:</p>\n\n<pre>\nL<sub>0</sub> &rarr; L<sub>1</sub> &rarr; &hellip; &rarr; L<sub>n - 1</sub> &rarr; L<sub>n</sub>\n</pre>\n\n<p><em>Reorder the list to be on the following form:</em></p>\n\n<pre>\nL<sub>0</sub> &rarr; L<sub>n</sub> &rarr; L<sub>1</sub> &rarr; L<sub>n - 1</sub> &rarr; L<sub>2</sub> &rarr; L<sub>n - 2</sub> &rarr; &hellip;\n</pre>\n\n<p>You may not modify the values in the list&#39;s nodes. Only nodes themselves may be changed.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/03/04/reorder1linked-list.jpg\" style=\"width: 422px; height: 222px;\" />\n<pre>\n<strong>Input:</strong> head = [1,2,3,4]\n<strong>Output:</strong> [1,4,2,3]\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/03/09/reorder2-linked-list.jpg\" style=\"width: 542px; height: 222px;\" />\n<pre>\n<strong>Input:</strong> head = [1,2,3,4,5]\n<strong>Output:</strong> [1,5,2,4,3]\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li>The number of nodes in the list is in the range <code>[1, 5 * 10<sup>4</sup>]</code>.</li>\n\t<li><code>1 &lt;= Node.val &lt;= 1000</code></li>\n</ul>\n",
        "solutions": [
            {
                "id": 44992,
                "title": "java-solution-with-3-steps",
                "content": "This question is a combination of **Reverse a linked list I & II**. It should be pretty straight forward to do it in 3 steps :)\\n\\n    public void reorderList(ListNode head) {\\n                if(head==null||head.next==null) return;\\n                \\n                //Find the middle of the list\\n                ListNode p1=head;\\n                ListNode p2=head;\\n                while(p2.next!=null&&p2.next.next!=null){ \\n                    p1=p1.next;\\n                    p2=p2.next.next;\\n                }\\n                \\n                //Reverse the half after middle  1->2->3->4->5->6 to 1->2->3->6->5->4\\n                ListNode preMiddle=p1;\\n                ListNode preCurrent=p1.next;\\n                while(preCurrent.next!=null){\\n                    ListNode current=preCurrent.next;\\n                    preCurrent.next=current.next;\\n                    current.next=preMiddle.next;\\n                    preMiddle.next=current;\\n                }\\n                \\n                //Start reorder one by one  1->2->3->6->5->4 to 1->6->2->5->3->4\\n                p1=head;\\n                p2=preMiddle.next;\\n                while(p1!=preMiddle){\\n                    preMiddle.next=p2.next;\\n                    p2.next=p1.next;\\n                    p1.next=p2;\\n                    p1=p2.next;\\n                    p2=preMiddle.next;\\n                }\\n            }",
                "solutionTags": [
                    "Java"
                ],
                "code": "This question is a combination of **Reverse a linked list I & II**. It should be pretty straight forward to do it in 3 steps :)\\n\\n    public void reorderList(ListNode head) {\\n                if(head==null||head.next==null) return;\\n                \\n                //Find the middle of the list\\n                ListNode p1=head;\\n                ListNode p2=head;\\n                while(p2.next!=null&&p2.next.next!=null){ \\n                    p1=p1.next;\\n                    p2=p2.next.next;\\n                }\\n                \\n                //Reverse the half after middle  1->2->3->4->5->6 to 1->2->3->6->5->4\\n                ListNode preMiddle=p1;\\n                ListNode preCurrent=p1.next;\\n                while(preCurrent.next!=null){\\n                    ListNode current=preCurrent.next;\\n                    preCurrent.next=current.next;\\n                    current.next=preMiddle.next;\\n                    preMiddle.next=current;\\n                }\\n                \\n                //Start reorder one by one  1->2->3->6->5->4 to 1->6->2->5->3->4\\n                p1=head;\\n                p2=preMiddle.next;\\n                while(p1!=preMiddle){\\n                    preMiddle.next=p2.next;\\n                    p2.next=p1.next;\\n                    p1.next=p2;\\n                    p1=p2.next;\\n                    p2=preMiddle.next;\\n                }\\n            }",
                "codeTag": "Unknown"
            },
            {
                "id": 801883,
                "title": "python-3-steps-to-success-explained",
                "content": "If you never solved singly linked lists problems before, or you do not have a lot of experience, this problem can be quite difficult. However if you already know all the tricks, it is not difficult at all. Let us first try to understand what we need to do. For list `[1,2,3,4,5,6,7]` we need to return `[1,7,2,6,3,5,4]`. We can note, that it is actually two lists `[1,2,3,4]` and `[7,6,5]`, where elements are interchange. So, to succeed we need to do the following steps:\\n1. Find the middle of or list - be careful, it needs to work properly both for even and for odd number of nodes. For this we can either just count number of elements and then divide it by to, and do two traversals of list. Or we can use `slow/fast` iterators trick, where `slow` moves with speed `1` and `fast` moves with speed `2`. Then when `fast` reches the end, `slow` will be in the middle, as we need.\\n2. Reverse the second part of linked list. Again, if you never done it before, it can be quite painful, please read oficial solution to problem **206. Reverse Linked List**. The idea is to keep **three** pointers: `prev, curr, nextt` stand for previous, current and next and change connections in place. Do not forget to use `slow.next = None`, in opposite case you will have list with loop.\\n3. Finally, we need to merge two lists, given its heads. These heads are denoted by `head` and `prev`, so for simplisity I created `head1` and `head2` variables. What we need to do now is to interchange nodes: we put `head2` as next element of `head1` and then say that `head1` is now `head2` and `head2` is previous `head1.next`. In this way we do one step for one of the lists and rename lists, so next time we will take element from `head2`, then rename again and so on.\\n\\n**Complexity**: Time complexity is `O(n)`, because we first do `O(n)` iterations to find middle, then we do `O(n)` iterations to reverse second half and finally we do `O(n)` iterations to merge lists. Space complexity is `O(1)`.\\n\\n```\\nclass Solution:\\n    def reorderList(self, head):\\n        #step 1: find middle\\n        if not head: return []\\n        slow, fast = head, head\\n        while fast.next and fast.next.next:\\n            slow = slow.next\\n            fast = fast.next.next\\n        \\n        #step 2: reverse second half\\n        prev, curr = None, slow.next\\n        while curr:\\n            nextt = curr.next\\n            curr.next = prev\\n            prev = curr\\n            curr = nextt    \\n        slow.next = None\\n        \\n        #step 3: merge lists\\n        head1, head2 = head, prev\\n        while head2:\\n            nextt = head1.next\\n            head1.next = head2\\n            head1 = head2\\n            head2 = nextt\\n```\\n\\nIf you have any questions, feel free to ask. If you like solution and explanations, please **Upvote!**",
                "solutionTags": [
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution:\\n    def reorderList(self, head):\\n        #step 1: find middle\\n        if not head: return []\\n        slow, fast = head, head\\n        while fast.next and fast.next.next:\\n            slow = slow.next\\n            fast = fast.next.next\\n        \\n        #step 2: reverse second half\\n        prev, curr = None, slow.next\\n        while curr:\\n            nextt = curr.next\\n            curr.next = prev\\n            prev = curr\\n            curr = nextt    \\n        slow.next = None\\n        \\n        #step 3: merge lists\\n        head1, head2 = head, prev\\n        while head2:\\n            nextt = head1.next\\n            head1.next = head2\\n            head1 = head2\\n            head2 = nextt\\n```",
                "codeTag": "Java"
            },
            {
                "id": 802119,
                "title": "c-really-simple-solution-using-stack-with-explanations",
                "content": "**Like it? Please upvote...**\\n```\\nclass Solution {\\npublic:\\n    void reorderList(ListNode* head) {\\n        if ((!head) || (!head->next) || (!head->next->next)) return; // Edge cases\\n        \\n        stack<ListNode*> my_stack;\\n        ListNode* ptr = head;\\n        int size = 0;\\n        while (ptr != NULL) // Put all nodes in stack\\n        {\\n            my_stack.push(ptr);\\n            size++;\\n            ptr = ptr->next;\\n        }\\n        \\n        ListNode* pptr = head;\\n        for (int j=0; j<size/2; j++) // Between every two nodes insert the one in the top of the stack\\n        {\\n            ListNode *element = my_stack.top();\\n            my_stack.pop();\\n            element->next = pptr->next;\\n            pptr->next = element;\\n            pptr = pptr->next->next;\\n        }\\n        pptr->next = NULL;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void reorderList(ListNode* head) {\\n        if ((!head) || (!head->next) || (!head->next->next)) return; // Edge cases\\n        \\n        stack<ListNode*> my_stack;\\n        ListNode* ptr = head;\\n        int size = 0;\\n        while (ptr != NULL) // Put all nodes in stack\\n        {\\n            my_stack.push(ptr);\\n            size++;\\n            ptr = ptr->next;\\n        }\\n        \\n        ListNode* pptr = head;\\n        for (int j=0; j<size/2; j++) // Between every two nodes insert the one in the top of the stack\\n        {\\n            ListNode *element = my_stack.top();\\n            my_stack.pop();\\n            element->next = pptr->next;\\n            pptr->next = element;\\n            pptr = pptr->next->next;\\n        }\\n        pptr->next = NULL;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 45147,
                "title": "java-solution-with-3-steps",
                "content": "      public class Solution {\\n        \\n        public void reorderList(ListNode head) {\\n          if (head == null || head.next == null)\\n              return;\\n          \\n          // step 1. cut the list to two halves\\n          // prev will be the tail of 1st half\\n          // slow will be the head of 2nd half\\n          ListNode prev = null, slow = head, fast = head, l1 = head;\\n          \\n          while (fast != null && fast.next != null) {\\n            prev = slow;\\n            slow = slow.next;\\n            fast = fast.next.next;\\n          }\\n          \\n          prev.next = null;\\n          \\n          // step 2. reverse the 2nd half\\n          ListNode l2 = reverse(slow);\\n          \\n          // step 3. merge the two halves\\n          merge(l1, l2);\\n        }\\n        \\n        ListNode reverse(ListNode head) {\\n          ListNode prev = null, curr = head, next = null;\\n          \\n          while (curr != null) {\\n            next = curr.next;\\n            curr.next = prev;\\n            prev = curr;\\n            curr = next;\\n          }\\n          \\n          return prev;\\n        }\\n        \\n        void merge(ListNode l1, ListNode l2) {\\n          while (l1 != null) {\\n            ListNode n1 = l1.next, n2 = l2.next;\\n            l1.next = l2;\\n            \\n            if (n1 == null)\\n              break;\\n                \\n            l2.next = n1;\\n            l1 = n1;\\n            l2 = n2;\\n          }\\n        }\\n    \\n      }",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n        \\n        public void reorderList(ListNode head) {\\n          if (head == null || head.next == null)\\n              return;\\n          \\n          // step 1. cut the list to two halves\\n          // prev will be the tail of 1st half\\n          // slow will be the head of 2nd half\\n          ListNode prev = null, slow = head, fast = head, l1 = head;\\n          \\n          while (fast != null && fast.next != null) {\\n            prev = slow;\\n            slow = slow.next;\\n            fast = fast.next.next;\\n          }",
                "codeTag": "Java"
            },
            {
                "id": 45003,
                "title": "a-concise-o-n-time-o-1-in-place-solution",
                "content": "    // O(N) time, O(1) space in total\\n    void reorderList(ListNode *head) {\\n        if (!head || !head->next) return;\\n        \\n        // find the middle node: O(n)\\n        ListNode *p1 = head, *p2 = head->next;\\n        while (p2 && p2->next) {\\n            p1 = p1->next;\\n            p2 = p2->next->next;\\n        }\\n        \\n        // cut from the middle and reverse the second half: O(n)\\n        ListNode *head2 = p1->next;\\n        p1->next = NULL;\\n        \\n        p2 = head2->next;\\n        head2->next = NULL;\\n        while (p2) {\\n            p1 = p2->next;\\n            p2->next = head2;\\n            head2 = p2;\\n            p2 = p1;\\n        }\\n        \\n        // merge two lists: O(n)\\n        for (p1 = head, p2 = head2; p1; ) {\\n            auto t = p1->next;\\n            p1 = p1->next = p2;\\n            p2 = t;\\n        }\\n        \\n        //for (p1 = head, p2 = head2; p2; ) {\\n        //    auto t = p1->next;\\n        //    p1->next = p2;\\n        //    p2 = p2->next;\\n        //    p1 = p1->next->next = t;\\n        //}\\n    }",
                "solutionTags": [],
                "code": "    // O(N) time, O(1) space in total\\n    void reorderList(ListNode *head) {\\n        if (!head || !head->next) return;\\n        \\n        // find the middle node: O(n)\\n        ListNode *p1 = head, *p2 = head->next;\\n        while (p2 && p2->next) {\\n            p1 = p1->next;\\n            p2 = p2->next->next;\\n        }\\n        \\n        // cut from the middle and reverse the second half: O(n)\\n        ListNode *head2 = p1->next;\\n        p1->next = NULL;\\n        \\n        p2 = head2->next;\\n        head2->next = NULL;\\n        while (p2) {\\n            p1 = p2->next;\\n            p2->next = head2;\\n            head2 = p2;\\n            p2 = p1;\\n        }\\n        \\n        // merge two lists: O(n)\\n        for (p1 = head, p2 = head2; p1; ) {\\n            auto t = p1->next;\\n            p1 = p1->next = p2;\\n            p2 = t;\\n        }\\n        \\n        //for (p1 = head, p2 = head2; p2; ) {\\n        //    auto t = p1->next;\\n        //    p1->next = p2;\\n        //    p2 = p2->next;\\n        //    p1 = p1->next->next = t;\\n        //}\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1640556,
                "title": "c-easy-to-solve-beginner-friendly-with-detailed-explanation-and-dry-run",
                "content": "**Intuition:-**\\nAfter reading the question we got the gist that we need to reform the linkedlist in the manner such as\\n`firstnode->lastnode->secondnode->penultimate node->third node->3rd last node ............` .\\nSo there are two ways that comes to my mind while thinking about a approach . Those are ,\\n\\n**1. Brute Force :-**\\n* In this we will first traverse to penultimate node and then start relinking each node .\\n\\n**2.** **Two pointer approach[sometimes referred as Tortoise and hare method]:-**\\n* We will have two pointers 1st pointer moving at speed of 1node and 2nd pointer moving at speed of twice the node. So basically one is moving at double speed and thus when it will be finished, the other has to be midway) and possibly adjusting it with lists of even length. This creates two halfs of linkedlist\\n* Then we reverse the second list and Finally we merge these two lists.\\n\\n**Brute-Force Algorithm:-**\\n1. First some base cases that we need to take care i.e if the linked list has zero,one or two elements just return it \\n2. Now next we need to find the penultimate node, so after finding it we can start the relinking process\\n3. Now start the relinking process as 1st node with last node ,2nd node with penultimate node, 3rd node with 3rd last node ......\\n4. Now repeat 2nd and 3rd steps.\\n\\n**Let\\'s have a dy run before starting the code:-**\\n![image](https://assets.leetcode.com/users/images/a436d8ab-0868-4990-9214-74fc5ba59992_1640143095.7645688.jpeg)\\n\\n\\n**Brute-Force code-:**\\n```\\n//Upvote  and Comment\\nclass Solution {\\npublic:\\n    void reorderList(ListNode* head) {\\n        //base case i.e if the linked list has zero,one or two elments just return it\\n        if(!head || !head->next || !head->next->next) return;\\n        \\n        //Find the penultimate node i.e second last node of the linkedlist\\n        ListNode* penultimate = head;\\n        while (penultimate->next->next) penultimate = penultimate->next;\\n        \\n        // Link the penultimate with the second element\\n        penultimate->next->next = head->next;\\n        head->next = penultimate->next;\\n        \\n        //Again set the penultimate to the the last \\n        penultimate->next = NULL;\\n        \\n        // Do the above steps rcursive\\n        reorderList(head->next->next);\\n    }\\n};\\n```\\n.\\n\\n\\n**Two pointer Approach [Tortoise and Hare method]:-**\\n*This approach is much faster and efficient in terms of Time and Space Complexity the only drawback is that it looks a little bit lengthy but trust me it\\'s easy to understand*.\\n\\n**Two pointer Approach Algorithm:**\\n1. First let\\'s take two pointers name it as `half` and `temp` . `temp ` is faster than `half` by 1. \\n2. When `temp` reaches the end of linkedlsit `half` reaches the middle element .So this is how the linkedlist will get divided in two halfes as the center will become a dividing node .\\n3. Now reverse the second half . \\n4. After reversing the second half, merge the first half and second half\\n\\n**Let\\'s have a dy run before starting the code:-**\\nLet\\'s take the same example as above:\\n```\\nLinked list:[1,2,3,4,5]\\n* search for the central element, which will be three in our case\\n* split the list in two halfes that will be [1,2,3] and [4,5]\\n* Now reverse the second half that will be [5,4]\\n* Now merge both the halfes \\n[1,2,3]\\n\\t[5,4]\\n=>[1,5,2,4,3]\\n\\n**See told you it\\'s easy to understand**\\n```\\n\\n\\n**Two pointer Approach Code:-**\\n```\\n//Upvote and Comment\\nclass Solution {\\npublic:\\n    void reorderList(ListNode* head) {\\n        // base case : linkedlist is empty\\n        if (!head) return;\\n        \\n        // finding the middle with the help of two pointer approach\\n        ListNode *tmp = head, *half = head, *prev = NULL;\\n        while (tmp->next && tmp->next->next) {\\n            tmp = tmp->next->next;\\n            half = half->next;\\n        }\\n        \\n        // adding one bit in case of lists with even length\\n        if (tmp->next) half = half->next;\\n        \\n        // Now reverse the second half\\n        while (half) {\\n            tmp = half->next;\\n            half->next = prev;\\n            prev = half;\\n            half = tmp;\\n        }\\n        half = prev;\\n        \\n        // After reversing the second half, let\\'s merge both the halfes\\n        while (head && half) {\\n            tmp = head->next;\\n            prev = half->next;\\n            head->next = half;\\n            half->next = tmp;\\n            head = tmp;\\n            half = prev;\\n        }\\n        \\n        // Base case : closing when we had even length arrays\\n        if (head && head->next) head->next->next = NULL;\\n    }\\n};\\n```\\n**Time Complexity :** *`O(N) [ O(N) to find mid of list, O(N/2) to reverse the 2nd half and in the end O(N) for relinking purpose  ]`*\\n**Space Complexity :** *`O(1) [intermediate state variables are the only thing  that we used]`*\\n\\n***\\n\\n.......*Continuation from previous posts...\\nAll the archeologists were discussing about the theory while sitting inside the chopper . After few minutes the chopper was right above the center of the caged ancient ruins lab of Dr.Cheems . All the archeologist were amazed by the view of laboratory .The laboratory was beautiful complimenting with its humungous size . Regarding the theory that was created by JThree known as \\'Celestial Dogemon\\' was verified that time . Dogelina picked up some scent [Meanwhile others saw some texts inscribed at the top of ceiling ]..\\nTo be continued in the next post*.........\\n\\n**Feel free to comment or upvote if you liked my post**\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Linked List",
                    "Two Pointers",
                    "Recursion"
                ],
                "code": "```\\n//Upvote  and Comment\\nclass Solution {\\npublic:\\n    void reorderList(ListNode* head) {\\n        //base case i.e if the linked list has zero,one or two elments just return it\\n        if(!head || !head->next || !head->next->next) return;\\n        \\n        //Find the penultimate node i.e second last node of the linkedlist\\n        ListNode* penultimate = head;\\n        while (penultimate->next->next) penultimate = penultimate->next;\\n        \\n        // Link the penultimate with the second element\\n        penultimate->next->next = head->next;\\n        head->next = penultimate->next;\\n        \\n        //Again set the penultimate to the the last \\n        penultimate->next = NULL;\\n        \\n        // Do the above steps rcursive\\n        reorderList(head->next->next);\\n    }\\n};\\n```\n```\\nLinked list:[1,2,3,4,5]\\n* search for the central element, which will be three in our case\\n* split the list in two halfes that will be [1,2,3] and [4,5]\\n* Now reverse the second half that will be [5,4]\\n* Now merge both the halfes \\n[1,2,3]\\n\\t[5,4]\\n=>[1,5,2,4,3]\\n\\n**See told you it\\'s easy to understand**\\n```\n```\\n//Upvote and Comment\\nclass Solution {\\npublic:\\n    void reorderList(ListNode* head) {\\n        // base case : linkedlist is empty\\n        if (!head) return;\\n        \\n        // finding the middle with the help of two pointer approach\\n        ListNode *tmp = head, *half = head, *prev = NULL;\\n        while (tmp->next && tmp->next->next) {\\n            tmp = tmp->next->next;\\n            half = half->next;\\n        }\\n        \\n        // adding one bit in case of lists with even length\\n        if (tmp->next) half = half->next;\\n        \\n        // Now reverse the second half\\n        while (half) {\\n            tmp = half->next;\\n            half->next = prev;\\n            prev = half;\\n            half = tmp;\\n        }\\n        half = prev;\\n        \\n        // After reversing the second half, let\\'s merge both the halfes\\n        while (head && half) {\\n            tmp = head->next;\\n            prev = half->next;\\n            head->next = half;\\n            half->next = tmp;\\n            head = tmp;\\n            half = prev;\\n        }\\n        \\n        // Base case : closing when we had even length arrays\\n        if (head && head->next) head->next->next = NULL;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 801971,
                "title": "python-o-n-by-two-pointers-w-visualization",
                "content": "The first method is to reorder by **two pointers** with the help of **aux O(n)** space **array**.\\n\\nThe second method is to reorder by **mid-point finding**, **linked list reverse**, and **linkage update** in O(1) aux space.\\n\\n---\\n\\nMethod_#1\\n\\n**Visualization and Diagram**\\n\\n![image](https://assets.leetcode.com/users/images/9e0e9d9f-80bd-4e03-bdfa-07dffec9a960_1597916142.2456708.png)\\n\\n---\\n\\n**Implementation**:\\n\\n```\\nclass Solution:\\n    def reorderList(self, head: ListNode) -> None:\\n        \"\"\"\\n        Do not return anything, modify head in-place instead.\\n        \"\"\"\\n\\t\\t\\n\\t\\t# ----------------------------------------------\\n\\t\\t# Save linked list in array\\n\\t\\t\\n        arr = []\\n        \\n        cur, length = head, 0\\n\\t\\t\\n        while cur:\\n            arr.append( cur )\\n            cur, length = cur.next, length + 1\\n        \\n\\t\\t# ----------------------------------------------\\n        # Reorder with two-pointers\\n\\t\\t\\n        left, right = 0, length-1\\n        last = head\\n        \\n        while left < right:\\n            arr[left].next = arr[right]\\n            left += 1\\n            \\n            if left == right: \\n                last = arr[right]\\n                break\\n                \\n            arr[right].next = arr[left]\\n            right -= 1\\n            \\n            last = arr[left]\\n        \\n        if last:\\n            last.next= None\\n```\\n\\n---\\n\\nMethod_#2\\n\\n**Visualization and Diagram**\\n\\n![image](https://assets.leetcode.com/users/images/e78d2d3a-5217-49f8-87e3-bc59c19070fc_1597916232.8641367.png)\\n\\n---\\n\\n![image](https://assets.leetcode.com/users/images/68bc80f5-630e-4c0a-a9da-605196a4e004_1597916252.5191195.png)\\n\\n---\\n\\n![image](https://assets.leetcode.com/users/images/391f41fb-ed1f-4d67-a2f9-4d6aaf119214_1597916282.3228247.png)\\n\\n\\n---\\n\\n**Implementation**:\\n\\n```\\nclass Solution:\\n    def reorderList(self, head: ListNode) -> None:\\n        \"\"\"\\n        Do not return anything, modify head in-place instead.\\n        \"\"\"\\n        \\n        if not head:\\n            # Quick response for empty linked list\\n            return None\\n        \\n        # ------------------------------------------\\n        # Locate the mid point of linked list\\n        # First half is the linked list before mid point\\n        # Second half is the linked list after mid point\\n        \\n        fast, slow = head, head\\n        \\n        while fast and fast.next:\\n            slow, fast = slow.next, fast.next.next\\n            \\n        mid = slow\\n        \\n        # ------------------------------------------\\n        # Reverse second half\\n        \\n        prev, cur = None, mid\\n        \\n        while cur:\\n            cur.next, prev, cur = prev, cur, cur.next\\n        \\n        head_of_second_rev = prev\\n        \\n        # ------------------------------------------\\n        # Update link between first half and reversed second half\\n        \\n        first, second = head, head_of_second_rev\\n        \\n        while second.next:\\n            \\n            next_hop = first.next\\n            first.next = second\\n            first = next_hop\\n            \\n            next_hop = second.next\\n            second.next = first\\n            second = next_hop\\n```\\n\\n---",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Linked List",
                    "Two Pointers",
                    "Iterator"
                ],
                "code": "```\\nclass Solution:\\n    def reorderList(self, head: ListNode) -> None:\\n        \"\"\"\\n        Do not return anything, modify head in-place instead.\\n        \"\"\"\\n\\t\\t\\n\\t\\t# ----------------------------------------------\\n\\t\\t# Save linked list in array\\n\\t\\t\\n        arr = []\\n        \\n        cur, length = head, 0\\n\\t\\t\\n        while cur:\\n            arr.append( cur )\\n            cur, length = cur.next, length + 1\\n        \\n\\t\\t# ----------------------------------------------\\n        # Reorder with two-pointers\\n\\t\\t\\n        left, right = 0, length-1\\n        last = head\\n        \\n        while left < right:\\n            arr[left].next = arr[right]\\n            left += 1\\n            \\n            if left == right: \\n                last = arr[right]\\n                break\\n                \\n            arr[right].next = arr[left]\\n            right -= 1\\n            \\n            last = arr[left]\\n        \\n        if last:\\n            last.next= None\\n```\n```\\nclass Solution:\\n    def reorderList(self, head: ListNode) -> None:\\n        \"\"\"\\n        Do not return anything, modify head in-place instead.\\n        \"\"\"\\n        \\n        if not head:\\n            # Quick response for empty linked list\\n            return None\\n        \\n        # ------------------------------------------\\n        # Locate the mid point of linked list\\n        # First half is the linked list before mid point\\n        # Second half is the linked list after mid point\\n        \\n        fast, slow = head, head\\n        \\n        while fast and fast.next:\\n            slow, fast = slow.next, fast.next.next\\n            \\n        mid = slow\\n        \\n        # ------------------------------------------\\n        # Reverse second half\\n        \\n        prev, cur = None, mid\\n        \\n        while cur:\\n            cur.next, prev, cur = prev, cur, cur.next\\n        \\n        head_of_second_rev = prev\\n        \\n        # ------------------------------------------\\n        # Update link between first half and reversed second half\\n        \\n        first, second = head, head_of_second_rev\\n        \\n        while second.next:\\n            \\n            next_hop = first.next\\n            first.next = second\\n            first = next_hop\\n            \\n            next_hop = second.next\\n            second.next = first\\n            second = next_hop\\n```",
                "codeTag": "Java"
            },
            {
                "id": 44988,
                "title": "a-python-solution-o-n-time-o-1-space",
                "content": "\\n\\n    # Splits in place a list in two halves, the first half is >= in size than the second.\\n    # @return A tuple containing the heads of the two halves\\n    def _splitList(head):\\n        fast = head\\n        slow = head\\n        while fast and fast.next:\\n            slow = slow.next\\n            fast = fast.next\\n            fast = fast.next\\n    \\n        middle = slow.next\\n        slow.next = None\\n    \\n        return head, middle\\n    \\n    # Reverses in place a list.\\n    # @return Returns the head of the new reversed list\\n    def _reverseList(head):\\n    \\n      last = None\\n      currentNode = head\\n    \\n      while currentNode:\\n        nextNode = currentNode.next\\n        currentNode.next = last\\n        last = currentNode\\n        currentNode = nextNode\\n    \\n      return last\\n    \\n    # Merges in place two lists\\n    # @return The newly merged list.\\n    def _mergeLists(a, b):\\n    \\n        tail = a\\n        head = a\\n    \\n        a = a.next\\n        while b:\\n            tail.next = b\\n            tail = tail.next\\n            b = b.next\\n            if a:\\n                a, b = b, a\\n                \\n        return head\\n    \\n    \\n    class Solution:\\n    \\n        # @param head, a ListNode\\n        # @return nothing\\n        def reorderList(self, head):\\n    \\n            if not head or not head.next:\\n                return\\n    \\n            a, b = _splitList(head)\\n            b = _reverseList(b)\\n            head = _mergeLists(a, b)",
                "solutionTags": [
                    "Python",
                    "Linked List"
                ],
                "code": "\\n\\n    # Splits in place a list in two halves, the first half is >= in size than the second.\\n    # @return A tuple containing the heads of the two halves\\n    def _splitList(head):\\n        fast = head\\n        slow = head\\n        while fast and fast.next:\\n            slow = slow.next\\n            fast = fast.next\\n            fast = fast.next\\n    \\n        middle = slow.next\\n        slow.next = None\\n    \\n        return head, middle\\n    \\n    # Reverses in place a list.\\n    # @return Returns the head of the new reversed list\\n    def _reverseList(head):\\n    \\n      last = None\\n      currentNode = head\\n    \\n      while currentNode:\\n        nextNode = currentNode.next\\n        currentNode.next = last\\n        last = currentNode\\n        currentNode = nextNode\\n    \\n      return last\\n    \\n    # Merges in place two lists\\n    # @return The newly merged list.\\n    def _mergeLists(a, b):\\n    \\n        tail = a\\n        head = a\\n    \\n        a = a.next\\n        while b:\\n            tail.next = b\\n            tail = tail.next\\n            b = b.next\\n            if a:\\n                a, b = b, a\\n                \\n        return head\\n    \\n    \\n    class Solution:\\n    \\n        # @param head, a ListNode\\n        # @return nothing\\n        def reorderList(self, head):\\n    \\n            if not head or not head.next:\\n                return\\n    \\n            a, b = _splitList(head)\\n            b = _reverseList(b)\\n            head = _mergeLists(a, b)",
                "codeTag": "Java"
            },
            {
                "id": 1641006,
                "title": "c-python-simple-solutions-w-explanation-2-pointers-o-n-inplace-o-1-space-approaches",
                "content": "We are given a list which we need to re-order in alternate fashion like `L1 -> Ln-1 -> L2 -> Ln-2...`\\n\\n---\\n\\n\\u2714\\uFE0F ***Solution - I (2-Pointers using Extra Space)***\\n\\nWe can solve this question easily if using extra space is allowed. The re-ordering arrangement basically consist of 1st node, then last node, then 2nd node, then 2nd last node and so on till all nodes are covered. Thus, we just put one node from the start, then one from end in an alternating fashion. In this approach -  \\n\\n* We first use an auxillary array to store the nodes of linked-list\\n* Once the array is filled, we initialize two variables `L` and `R` which denotes the current positions on the two ends from which we need to re-order the list in alternate fashion\\n* In odd iteration, we assign the next node as `arr[L]` and move the `L` pointer ahead\\n* In even iteration, we assign the next node as `arr[R]` and move the `R` pointer backward\\n* This will re-order the list as alternating nodes from start and end as required.\\n\\n**C++**\\n```cpp\\nclass Solution {\\npublic:\\n    void reorderList(ListNode* head) {\\n        vector<ListNode*> arr;\\n        for(auto iter = head; iter; iter = iter -> next)\\n            arr.push_back(iter);\\n        \\n\\t\\t// pointers to start and end of list. Re-order in alternating fashion from both end\\n        int L = 1, R = size(arr)-1;\\n        for(int i = 0; i < size(arr); i++, head = head -> next) \\n            if(i & 1)                             // odd iteration:\\n                head -> next = arr[L++];          //        - pick node from L & update L ptr\\n            else                                  // even iteration\\n                head -> next = arr[R--];          //        - pick node from R & update R ptr\\n        \\n        head -> next = nullptr;\\n    }\\n};\\n```\\n\\n**Python**\\n```python\\nclass Solution:\\n    def reorderList(self, head):\\n        arr, Iter = [], head\\n        while Iter:\\n            arr.append(Iter)\\n            Iter = Iter.next\\n        \\n        L, R = 1, len(arr)-1\\n        for i in range(len(arr)):\\n            if i & 1:\\n                head.next = arr[L]\\n                L += 1\\n            else:\\n                head.next = arr[R]\\n                R -= 1\\n            head = head.next\\n        head.next = None\\n```\\n\\n***Time Complexity :*** <code>O(N)</code>, where `N` is the number of nodes in the linked list. We traverse linked list once and store it in array. Then we traverse the array once. Thus overall time- `O(2N) = O(N)`\\n***Space Complexity :*** `O(N)`, required to store nodes of list into array\\n\\n---\\n\\n\\u2714\\uFE0F ***Solution - II (In-place Transformation)***\\n\\nIn the above solution, we are simply using two pointers, one to the start and one to the end of array. The nodes pointed by these pointers are picked in alternating manner and then these pointers are iterated in opposite directions. This **continues till they meet in the middle**, i.e, all nodes are covered in the process.\\n\\nBut we are using extra space in the form of array. We required array to be able to iterate the `R` pointer in the backward direction which wouldnt be possible if we directly used linked list. \\n\\nHowever, we can optimize the space by modifying our list to make it possible to iterate backwards from `R` pointer. We can simply reverse the 2nd half of the list which allows us to place `R` at the end and iterate backwards till the mid. Then the rest process remains similar in logic as above.\\n\\n* First **find the mid of linked list**. This can be done using slow & fast pointer algorithm\\n* Then we **reverse the 2nd half** and place the `R` pointer at the end\\n* Initialize `L` pointer to `head->next`\\n* We can now simply **re-order by placing nodes from `L` and `R` pointers in alternating fashion** till they meet. \\n\\n\\n\\n**C++**\\n```cpp\\nclass Solution {\\npublic:\\n\\t// 876. Middle of the Linked List - returns the mid of list using slow-fast pointer approach\\n    ListNode* middleNode(ListNode* head) {\\n        auto slow = head, fast = head;\\n        while(fast && fast -> next)\\n            slow = slow -> next,\\n            fast = fast -> next -> next;            // fast moves at 2x speed\\n        return slow;                                // slow ends up at mid\\n    }\\n\\t// 206. Reverse Linked List - reverses and returns the head of reversed list\\n    ListNode* reverseList(ListNode* head) {\\n        ListNode *prev = nullptr;\\n        while(head) {\\n            auto nextNode = head -> next;           // store next node before reversing next ptr of cur\\n            head -> next = prev;                    // reverse the next ptr to previous node\\n            prev = head;                            // update previous node as cur\\n            head = nextNode;                        // move to orignal next node\\n        }\\n        return prev;                                // returns head of reversed list\\n    }\\n    void reorderList(ListNode* head) {\\n        if(!head || !head -> next) return;\\n        auto mid = middleNode(head);\\n        auto R = reverseList(mid), L = head -> next;\\n        for(int i = 0; L != R; i++, head = head -> next)     // re-order in alternating fashion \\n            if(i & 1) {                              \\n                head -> next = L;\\n                L = L -> next;\\n            }\\n            else {\\n                head -> next = R;\\n                R = R -> next;\\n            }\\n    }\\n};\\n```\\n\\n**Python**\\n```python\\nclass Solution:\\n    def reorderList(self, head):\\n        def middleNode(head):\\n            slow, fast = head, head\\n            while fast and fast.next:\\n                slow = slow.next\\n                fast = fast.next.next\\n            return slow\\n        \\n        def reverseList(head):\\n            prev = None\\n            while head:\\n                nextNode = head.next\\n                head.next = prev\\n                prev, head = head, nextNode\\n            return prev\\n\\n        if not head or not head.next: return\\n        R, L, i = reverseList(middleNode(head)), head.next, 0\\n        while L != R:\\n            if i & 1:\\n                head.next, L = L, L.next\\n            else:\\n                head.next, R = R, R.next\\n            head, i = head.next, i + 1\\n```\\n\\n***Time Complexity :*** <code>O(N)</code>, we need `O(N)` to find mid of list, another `O(N/2) = O(N)` to reverse the 2nd half and finally `O(N)` to re-order the list. Thus overall time: `O(3N) = O(N)`\\n***Space Complexity :*** `O(1)`, only constant extra space is used\\n\\n---\\n---\\n\\n\\uD83D\\uDCBBIf there are any suggestions / questions / mistakes in my post, comment below \\uD83D\\uDC47 \\n\\n---\\n---\\n\\n",
                "solutionTags": [],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    void reorderList(ListNode* head) {\\n        vector<ListNode*> arr;\\n        for(auto iter = head; iter; iter = iter -> next)\\n            arr.push_back(iter);\\n        \\n\\t\\t// pointers to start and end of list. Re-order in alternating fashion from both end\\n        int L = 1, R = size(arr)-1;\\n        for(int i = 0; i < size(arr); i++, head = head -> next) \\n            if(i & 1)                             // odd iteration:\\n                head -> next = arr[L++];          //        - pick node from L & update L ptr\\n            else                                  // even iteration\\n                head -> next = arr[R--];          //        - pick node from R & update R ptr\\n        \\n        head -> next = nullptr;\\n    }\\n};\\n```\n```python\\nclass Solution:\\n    def reorderList(self, head):\\n        arr, Iter = [], head\\n        while Iter:\\n            arr.append(Iter)\\n            Iter = Iter.next\\n        \\n        L, R = 1, len(arr)-1\\n        for i in range(len(arr)):\\n            if i & 1:\\n                head.next = arr[L]\\n                L += 1\\n            else:\\n                head.next = arr[R]\\n                R -= 1\\n            head = head.next\\n        head.next = None\\n```\n```cpp\\nclass Solution {\\npublic:\\n\\t// 876. Middle of the Linked List - returns the mid of list using slow-fast pointer approach\\n    ListNode* middleNode(ListNode* head) {\\n        auto slow = head, fast = head;\\n        while(fast && fast -> next)\\n            slow = slow -> next,\\n            fast = fast -> next -> next;            // fast moves at 2x speed\\n        return slow;                                // slow ends up at mid\\n    }\\n\\t// 206. Reverse Linked List - reverses and returns the head of reversed list\\n    ListNode* reverseList(ListNode* head) {\\n        ListNode *prev = nullptr;\\n        while(head) {\\n            auto nextNode = head -> next;           // store next node before reversing next ptr of cur\\n            head -> next = prev;                    // reverse the next ptr to previous node\\n            prev = head;                            // update previous node as cur\\n            head = nextNode;                        // move to orignal next node\\n        }\\n        return prev;                                // returns head of reversed list\\n    }\\n    void reorderList(ListNode* head) {\\n        if(!head || !head -> next) return;\\n        auto mid = middleNode(head);\\n        auto R = reverseList(mid), L = head -> next;\\n        for(int i = 0; L != R; i++, head = head -> next)     // re-order in alternating fashion \\n            if(i & 1) {                              \\n                head -> next = L;\\n                L = L -> next;\\n            }\\n            else {\\n                head -> next = R;\\n                R = R -> next;\\n            }\\n    }\\n};\\n```\n```python\\nclass Solution:\\n    def reorderList(self, head):\\n        def middleNode(head):\\n            slow, fast = head, head\\n            while fast and fast.next:\\n                slow = slow.next\\n                fast = fast.next.next\\n            return slow\\n        \\n        def reverseList(head):\\n            prev = None\\n            while head:\\n                nextNode = head.next\\n                head.next = prev\\n                prev, head = head, nextNode\\n            return prev\\n\\n        if not head or not head.next: return\\n        R, L, i = reverseList(middleNode(head)), head.next, 0\\n        while L != R:\\n            if i & 1:\\n                head.next, L = L, L.next\\n            else:\\n                head.next, R = R, R.next\\n            head, i = head.next, i + 1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1640806,
                "title": "java-2-approach-2-pointer-approach",
                "content": "***Solution 1* - Split linked list**\\n\\n---\\nsuppose we have two linkedList :\\n>`l1 =  1 -> 2 -> 3`\\n>` l2 =  4 -> 5 -> 6` ,\\n> **l2rev** = ` 6 -> 5  -> 4 `\\n\\n* Now if  we have to merge **l1** and **l2rev** then this question is going to bit more simpler right\\n\\t**Now how do we merge :**\\n\\t\\t**p1 =  l1**\\n\\t\\t**p2 =  l2rev**\\n\\t* p1 is always point to node whose next is going to fill \\n\\t* p2 point to to node which is going to fill in **p1 next**\\n\\n**So steps involve are :**\\n* split linkedlist into two halves\\n\\t* find mid and split\\n\\t* and revese second half\\n* merge these two halves\\n\\n### Lets Code this Approch \\uD83D\\uDC69\\uD83C\\uDFFB\\u200D\\uD83D\\uDCBB \\uD83D\\uDCBB\\n---\\n```\\nclass Solution {\\n    public ListNode midNode(ListNode head){\\n        ListNode fast =  head, slow  =  head;\\n        while(fast.next!=null && fast.next.next!=null){\\n            fast =  fast.next.next;\\n            slow =  slow.next;\\n        }\\n        return slow;\\n    }\\n    \\n    public ListNode reverse(ListNode head){\\n        ListNode curr =  head, prev=  null, next = null;\\n        while(curr!=null){\\n            next  =  curr.next;\\n            curr.next =  prev ;\\n            prev =  curr;\\n            curr  =  next;\\n        }\\n        return prev;\\n    }\\n\\n    \\n    public void reorderList(ListNode head) {\\n        \\n        ListNode midNode =  midNode(head);\\n        ListNode nextToMid =  midNode.next;\\n        midNode.next = null;\\n        ListNode p2 =  reverse(nextToMid);\\n        \\n        ListNode p1 =  head ,p1Next;    \\n        while(p1!=null && p2!=null){\\n            p1Next =  p1.next;                                    \\n\\t\\t\\tp1.next =  p2;\\n\\t\\t\\t           \\n            p1 =  p2;\\n            p2=p1Next;                        \\n        }                \\n    }            \\n}\\n```\\n\\n\\n---\\n\\nTIME COMPLEXITY : **O(n)**\\nSPACE COMPLEXITY : **O(1)**\\n\\n\\n---\\n\\n\\n***Solution 2* - Single traversal (Important concept)**\\n\\n---\\n\\n> Now let suppose we have two pointer left and right if we can move left **forward** and right **backward** then our task is going to simpler right \\n\\n**To merge we need to write only this much code**\\n```\\nLeftnext =  left.next;\\nleft.next =  right;\\nrigt.next =  Leftnext\\nleft =  Leftnext\\n```\\n\\n## let get more insight \\uD83D\\uDCA1\\n---\\n> ![image](https://assets.leetcode.com/users/images/cdd6b60d-d673-4de4-ac89-092616f07cdd_1640152889.938761.png)\\n\\n***Now How do we move two pointer one forward and one backward in linked list***\\n- When we make recursion call on linkedlist then in post area of recursion call  our stack pointer is moving in backward direction:\\n- And to move pointer in forward dirn at the same time , make it in heap , we have two ways to make it in heap\\n\\t 1. use class variable (declare outside the function)\\n\\t 2. Make one size array (it also created in heap), we are using this \\n\\n### Lets Code to get approch more better \\uD83D\\uDC69\\uD83C\\uDFFB\\u200D\\uD83D\\uDCBB\\uD83D\\uDCBB :\\n---\\n```\\n\\nclass Solution {\\n    public void reorderList(ListNode head) {\\n        ListNode [] left =  new ListNode[1];// it will create in heap\\n        left[0]  =  head;\\n        reorder(left,head);\\n        \\n    }\\n    \\n    // left pointer will be created in heap and right pointer will be created in stack\\n     public void reorder(ListNode left[],ListNode right){\\n        if(right==null){\\n            return ;\\n        }\\n        reorder(left,right.next);\\n        \\n    // in post area of recursion right pointer coming back(because of function remove from recursion stack)\\n   // and we move left pointer forward \\n        if(left[0].next!=null){\\n            ListNode leftNext =  left[0].next;\\n            left[0].next =  right;\\n            right.next =  leftNext;\\n            left[0] =  leftNext;            \\n        }\\n        \\n    // as we need to  merge till left pointer behind the right pointer \\n        if(left[0].next == right){\\n            left[0].next =  null;\\n        }                        \\n    }\\n}\\n```\\n\\n---\\nTIME COMPLEXITY : **O(n)**\\nSPACE COMPLEXITY : **O(n), if we consider recursion stack**\\n\\n\\n---\\n\\n",
                "solutionTags": [
                    "Java",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\n    public ListNode midNode(ListNode head){\\n        ListNode fast =  head, slow  =  head;\\n        while(fast.next!=null && fast.next.next!=null){\\n            fast =  fast.next.next;\\n            slow =  slow.next;\\n        }\\n        return slow;\\n    }\\n    \\n    public ListNode reverse(ListNode head){\\n        ListNode curr =  head, prev=  null, next = null;\\n        while(curr!=null){\\n            next  =  curr.next;\\n            curr.next =  prev ;\\n            prev =  curr;\\n            curr  =  next;\\n        }\\n        return prev;\\n    }\\n\\n    \\n    public void reorderList(ListNode head) {\\n        \\n        ListNode midNode =  midNode(head);\\n        ListNode nextToMid =  midNode.next;\\n        midNode.next = null;\\n        ListNode p2 =  reverse(nextToMid);\\n        \\n        ListNode p1 =  head ,p1Next;    \\n        while(p1!=null && p2!=null){\\n            p1Next =  p1.next;                                    \\n\\t\\t\\tp1.next =  p2;\\n\\t\\t\\t           \\n            p1 =  p2;\\n            p2=p1Next;                        \\n        }                \\n    }            \\n}\\n```\n```\\nLeftnext =  left.next;\\nleft.next =  right;\\nrigt.next =  Leftnext\\nleft =  Leftnext\\n```\n```\\n\\nclass Solution {\\n    public void reorderList(ListNode head) {\\n        ListNode [] left =  new ListNode[1];// it will create in heap\\n        left[0]  =  head;\\n        reorder(left,head);\\n        \\n    }\\n    \\n    // left pointer will be created in heap and right pointer will be created in stack\\n     public void reorder(ListNode left[],ListNode right){\\n        if(right==null){\\n            return ;\\n        }\\n        reorder(left,right.next);\\n        \\n    // in post area of recursion right pointer coming back(because of function remove from recursion stack)\\n   // and we move left pointer forward \\n        if(left[0].next!=null){\\n            ListNode leftNext =  left[0].next;\\n            left[0].next =  right;\\n            right.next =  leftNext;\\n            left[0] =  leftNext;            \\n        }\\n        \\n    // as we need to  merge till left pointer behind the right pointer \\n        if(left[0].next == right){\\n            left[0].next =  null;\\n        }                        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 45113,
                "title": "share-a-consise-recursive-solution-in-c",
                "content": "\\n The recursive idea have been posted by yucheng.wang. Given a example, 1->2->3->4->5, the solution will reorder node(3),  then reorder 2 and 4 to have (2->4->3), then 1 and 5 get have 1->5->2->4->3. Each call of reorderList(ListNode* head, int len) will return the last element after this reorderList() call.\\n\\n   int getLength(ListNode *head){\\n        int len = 0;\\n        while( head != NULL ){\\n            ++len;  head = head->next;\\n        }\\n        return len;\\n    }\\n    \\n    ListNode * reorderList(ListNode *head, int len){\\n        if(len == 0)\\n            return NULL;\\n        if( len == 1 )\\n            return head;\\n        if( len == 2 )\\n            return head->next;\\n        ListNode * tail = reorderList(head->next, len-2);\\n        ListNode * tmp = tail->next;\\n        tail->next = tail->next->next;\\n        tmp->next = head->next;\\n        head->next = tmp;\\n        return tail;\\n    }\\n    \\n    void reorderList(ListNode *head) {  //recursive\\n        ListNode  * tail = NULL;\\n        tail = reorderList(head, getLength(head));\\n    }",
                "solutionTags": [],
                "code": "\\n The recursive idea have been posted by yucheng.wang. Given a example, 1->2->3->4->5, the solution will reorder node(3),  then reorder 2 and 4 to have (2->4->3), then 1 and 5 get have 1->5->2->4->3. Each call of reorderList(ListNode* head, int len) will return the last element after this reorderList() call.\\n\\n   int getLength(ListNode *head){\\n        int len = 0;\\n        while( head != NULL ){\\n            ++len;  head = head->next;\\n        }\\n        return len;\\n    }\\n    \\n    ListNode * reorderList(ListNode *head, int len){\\n        if(len == 0)\\n            return NULL;\\n        if( len == 1 )\\n            return head;\\n        if( len == 2 )\\n            return head->next;\\n        ListNode * tail = reorderList(head->next, len-2);\\n        ListNode * tmp = tail->next;\\n        tail->next = tail->next->next;\\n        tmp->next = head->next;\\n        head->next = tmp;\\n        return tail;\\n    }\\n    \\n    void reorderList(ListNode *head) {  //recursive\\n        ListNode  * tail = NULL;\\n        tail = reorderList(head, getLength(head));\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3148599,
                "title": "easily-expalined-step-by-step-code-100-beats-and-0ms-runtime",
                "content": "# Intuition\\nFind the middle of the linked list. For Example:-\\n     1->2->3->4->5\\nHere, middle =3;\\nThen reverse the second half of the Linked List (i.e. 4->5), so after reversing the list will be like 5->4\\nNow, merege both list in ordered way like one element of 1st half linkedlist (i.e 1->2->3) and one element of second half list (i.e 5->4) so after merging the list will be like:-\\n  1->5->2->4->3\\nwhich is the required answer.\\n\\n# Approach\\nFor finding the middle of the linked list we can use slow and fast pointer approach.\\nFor reversing the list we can use the [Reverse linkedList I ](https://leetcode.com/problems/reverse-linked-list/solutions/3111776/100-beats-and-0ms-runtime-easy-java-solution/?orderBy=most_votes) approach.\\nThen we can merge list one by one.\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n \\n\\n- Space complexity: $$O(1)$$\\n \\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public void reorderList(ListNode head) {\\n        // if head will be null or head.next will be null simply return ;\\n        if(head==null || head.next==null)return ;\\n\\n  //finding middle element\\n        ListNode slow = head;\\n        ListNode fast= head;\\n        while(fast!=null && fast.next!=null){\\n            slow=slow.next;\\n            fast=fast.next.next;\\n        }\\n       \\n// reversing the second half of the list\\n       ListNode newNode = reverseList(slow.next);\\n      // breaking the list from the middle\\n        slow.next=null;\\n   //merging both list\\n       //first half list pointer\\n       ListNode curr = head;\\n       //second half list pointer\\n       ListNode dummy = newNode;\\n       while(head!=null && dummy!=null){\\n             //pointer to store next element of curr(1st half list)\\n           ListNode temp = curr.next;\\n           //link element of 1st half to that of second half\\n           curr.next=dummy;\\n           //pointer to store next element of dummy(2nd half list)\\n           ListNode temp2=dummy.next;\\n           //link the rest of the first half list\\n           dummy.next=temp;\\n           //increment curr and dummy pointer to do the same thing again and again util we reach end of the any one list or both list\\n           curr=temp;\\n           dummy=temp2;\\n       }\\n\\n    }\\n\\n   // method to reverse the linkedList\\n    public ListNode reverseList(ListNode node){\\n        ListNode prev = null;\\n        ListNode curr = node;\\n        ListNode next = null;\\n        while(curr!=null){\\n            next=curr.next;\\n            curr.next=prev;\\n            prev=curr;\\n            curr=next;\\n        }\\n         \\n        return prev;\\n    }\\n}\\n```\\n\\n[Nishant Kumar](https://leetcode.com/KumarNishantGunjan/)\\n\\n![cc404213-285c-48ca-bce1-256072316360_1675559254.9353127.png](https://assets.leetcode.com/users/images/9978b049-7731-4e29-89dd-5161c11c5b9e_1675649148.1483843.png)\\n",
                "solutionTags": [
                    "Java",
                    "Linked List"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public void reorderList(ListNode head) {\\n        // if head will be null or head.next will be null simply return ;\\n        if(head==null || head.next==null)return ;\\n\\n  //finding middle element\\n        ListNode slow = head;\\n        ListNode fast= head;\\n        while(fast!=null && fast.next!=null){\\n            slow=slow.next;\\n            fast=fast.next.next;\\n        }\\n       \\n// reversing the second half of the list\\n       ListNode newNode = reverseList(slow.next);\\n      // breaking the list from the middle\\n        slow.next=null;\\n   //merging both list\\n       //first half list pointer\\n       ListNode curr = head;\\n       //second half list pointer\\n       ListNode dummy = newNode;\\n       while(head!=null && dummy!=null){\\n             //pointer to store next element of curr(1st half list)\\n           ListNode temp = curr.next;\\n           //link element of 1st half to that of second half\\n           curr.next=dummy;\\n           //pointer to store next element of dummy(2nd half list)\\n           ListNode temp2=dummy.next;\\n           //link the rest of the first half list\\n           dummy.next=temp;\\n           //increment curr and dummy pointer to do the same thing again and again util we reach end of the any one list or both list\\n           curr=temp;\\n           dummy=temp2;\\n       }\\n\\n    }\\n\\n   // method to reverse the linkedList\\n    public ListNode reverseList(ListNode node){\\n        ListNode prev = null;\\n        ListNode curr = node;\\n        ListNode next = null;\\n        while(curr!=null){\\n            next=curr.next;\\n            curr.next=prev;\\n            prev=curr;\\n            curr=next;\\n        }\\n         \\n        return prev;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 567955,
                "title": "python-2-solutions-stack-3-steps-clean-concise",
                "content": "**\\u2714\\uFE0F Solution 1: Using Stack**\\n- The idea is that we use stack to store all nodes in the linked list. Then the top of the stack is the last node.\\n- Iterate `len(st) // 2` times, link in order:\\n\\t- `nxt = head.next`\\n\\t- `head -> st.pop() -> nxt`\\n\\t- `head = nxt`.\\n![image](https://assets.leetcode.com/users/images/63f8929c-1345-4c13-b711-ba1659a10637_1632724494.2345262.png)\\n\\n```python\\nclass Solution:\\n    def reorderList(self, head: Optional[ListNode]) -> None:\\n        \"\"\"\\n        Do not return anything, modify head in-place instead.\\n        \"\"\"\\n        st = []\\n        cur = head\\n        while cur != None:\\n            st.append(cur)\\n            cur = cur.next\\n            \\n        for i in range(len(st) // 2):\\n            nxt = head.next\\n            head.next = st.pop()\\n            head = head.next\\n            head.next = nxt\\n            head = head.next\\n            \\n        if head != None:\\n            head.next = None\\n```\\nComplexity:\\n- Time: `O(N)`, where `N <= 5 * 10^4` is number of nodes in the linked list.\\n- Space: `O(N)`\\n\\n---\\n**\\u2714\\uFE0F Solution 2: 3 steps**\\n- Step 1: Find the middle of the linked list then cut the middle into 2 halfs.\\n- Step 2: Reverse the last half of the linked list.\\n- Step 3: Merge 2 list one by one.\\n```python\\nclass Solution:\\n    def reorderList(self, head: Optional[ListNode]) -> None:\\n        \"\"\"\\n        Do not return anything, modify head in-place instead.\\n        \"\"\"\\n        def findMiddle(head):  # return mid, prevMid\\n            prevSlow = None\\n            slow = fast = head\\n            while fast != None and fast.next != None:\\n                prevSlow = slow\\n                slow = slow.next\\n                fast = fast.next.next\\n            return slow, prevSlow\\n        \\n        def reverse(head):\\n            newHead = None\\n            while head != None:\\n                nxt = head.next\\n                head.next = newHead\\n                newHead = head\\n                head = nxt\\n            return newHead\\n        \\n        def mergeOneByOne(head1, head2):\\n            dummyNode = curHead = ListNode(0)\\n            while head1 != None and head2 != None:\\n                curHead.next = head1\\n                curHead = curHead.next\\n                head1 = head1.next\\n                    \\n                curHead.next = head2\\n                curHead = curHead.next\\n                head2 = head2.next\\n                \\n            if head1 != None:\\n                curHead.next = head1\\n            elif head2 != None:\\n                curHead.next = head2\\n                \\n            return dummyNode.next\\n        \\n        \\n        # Step 1: Find the middle of the linked list and cut the middle into 2 halfs\\n        mid, prevMid = findMiddle(head)\\n        if prevMid == None: return head  # Case one element\\n        prevMid.next = None  # cut the middle into 2 halfs\\n        \\n        # Step 2: Reverse the last half of the linked list\\n        half = reverse(mid)\\n        \\n        # Step 3: Merge 2 list one by one\\n        return mergeOneByOne(head, half)\\n```\\nComplexity:\\n- Time: `O(N)`, where `N <= 5 * 10^4` is number of nodes in the linked list.\\n- Space: `O(1)`",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def reorderList(self, head: Optional[ListNode]) -> None:\\n        \"\"\"\\n        Do not return anything, modify head in-place instead.\\n        \"\"\"\\n        st = []\\n        cur = head\\n        while cur != None:\\n            st.append(cur)\\n            cur = cur.next\\n            \\n        for i in range(len(st) // 2):\\n            nxt = head.next\\n            head.next = st.pop()\\n            head = head.next\\n            head.next = nxt\\n            head = head.next\\n            \\n        if head != None:\\n            head.next = None\\n```\n```python\\nclass Solution:\\n    def reorderList(self, head: Optional[ListNode]) -> None:\\n        \"\"\"\\n        Do not return anything, modify head in-place instead.\\n        \"\"\"\\n        def findMiddle(head):  # return mid, prevMid\\n            prevSlow = None\\n            slow = fast = head\\n            while fast != None and fast.next != None:\\n                prevSlow = slow\\n                slow = slow.next\\n                fast = fast.next.next\\n            return slow, prevSlow\\n        \\n        def reverse(head):\\n            newHead = None\\n            while head != None:\\n                nxt = head.next\\n                head.next = newHead\\n                newHead = head\\n                head = nxt\\n            return newHead\\n        \\n        def mergeOneByOne(head1, head2):\\n            dummyNode = curHead = ListNode(0)\\n            while head1 != None and head2 != None:\\n                curHead.next = head1\\n                curHead = curHead.next\\n                head1 = head1.next\\n                    \\n                curHead.next = head2\\n                curHead = curHead.next\\n                head2 = head2.next\\n                \\n            if head1 != None:\\n                curHead.next = head1\\n            elif head2 != None:\\n                curHead.next = head2\\n                \\n            return dummyNode.next\\n        \\n        \\n        # Step 1: Find the middle of the linked list and cut the middle into 2 halfs\\n        mid, prevMid = findMiddle(head)\\n        if prevMid == None: return head  # Case one element\\n        prevMid.next = None  # cut the middle into 2 halfs\\n        \\n        # Step 2: Reverse the last half of the linked list\\n        half = reverse(mid)\\n        \\n        # Step 3: Merge 2 list one by one\\n        return mergeOneByOne(head, half)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1640597,
                "title": "python-java-c-2-easy-solutions-visualized-explanation-beginner-friendly",
                "content": "**Please UPVOTE if you LIKE!** \\uD83D\\uDE01\\n* **step 1: find the middle pointer of the linked list and split the linked list into two halves using slow and fast pointers**\\n\\t```\\n\\t\\t\\t\\t\\t\\t\\t\\t\\thead = [1, 2, 3]\\n\\thead = [1, 2, 3, 4, 5]    =>\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tmid  = [4, 5]\\n\\t```\\n* **step 2: reverse the second half**\\n\\t```\\n\\thead = [1, 2, 3]\\n\\tmid  = [4, 5]             =>    mid = [5, 4]\\n\\t```\\n* **step 3: interleaving merge the first half and the reversed second half**\\n\\t```\\n\\thead = [1, 2, 3]\\n\\t\\t\\t\\t\\t\\t      =>    head = [1, 5, 2, 4, 3]\\n\\tmid = [5, 4]\\n\\t```\\n\\n\\n```\\nTime  Complexity: O(N)\\nSpace Complexity: O(1)\\n```\\n\\n<iframe src=\"https://leetcode.com/playground/b7s3MeYC/shared\" frameBorder=\"0\" width=\"100%\" height=\"650\"></iframe>\\n\\n**Basic Solution Using Array or Deque and Repeat `pop_left()` and` pop()`**\\n```\\n# algorithm pseudo code\\ndq = [1, 2, 3, 4, 5]\\nwhile dq:\\n\\tdq.pop_left()\\n\\tif dq: dq.pop()\\n```\\n\\n```\\ndq =  [1, 2, 3, 4, 5] =>  dq.pop_left()   =>   1\\ndq =     [2, 3, 4, 5] =>  dq.pop()        =>   5\\ndq =     [2, 3, 4]    =>  dq.pop_left()   =>   2\\ndq =        [3, 4]    =>  dq.pop()        =>   4\\ndq =        [3]       =>  dq.pop_left()   =>   3\\n```\\n\\n```\\nTime  Complexity: O(N)\\nSpace Complexity: O(N)\\n```\\n<iframe src=\"https://leetcode.com/playground/iTNS2J3s/shared\" frameBorder=\"0\" width=\"100%\" height=\"450\"></iframe>\\n\\n**If you have any question, feel free to ask. If you like the solution or the explanation, Please UPVOTE!**",
                "solutionTags": [],
                "code": "```\\n\\t\\t\\t\\t\\t\\t\\t\\t\\thead = [1, 2, 3]\\n\\thead = [1, 2, 3, 4, 5]    =>\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tmid  = [4, 5]\\n\\t```\n```\\n\\thead = [1, 2, 3]\\n\\tmid  = [4, 5]             =>    mid = [5, 4]\\n\\t```\n```\\n\\thead = [1, 2, 3]\\n\\t\\t\\t\\t\\t\\t      =>    head = [1, 5, 2, 4, 3]\\n\\tmid = [5, 4]\\n\\t```\n```\\nTime  Complexity: O(N)\\nSpace Complexity: O(1)\\n```\n```\\n# algorithm pseudo code\\ndq = [1, 2, 3, 4, 5]\\nwhile dq:\\n\\tdq.pop_left()\\n\\tif dq: dq.pop()\\n```\n```\\ndq =  [1, 2, 3, 4, 5] =>  dq.pop_left()   =>   1\\ndq =     [2, 3, 4, 5] =>  dq.pop()        =>   5\\ndq =     [2, 3, 4]    =>  dq.pop_left()   =>   2\\ndq =        [3, 4]    =>  dq.pop()        =>   4\\ndq =        [3]       =>  dq.pop_left()   =>   3\\n```\n```\\nTime  Complexity: O(N)\\nSpace Complexity: O(N)\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 208984,
                "title": "python-solution",
                "content": "The algorithm consists of two steps: 1. reverse the second half of the list; 2. Insert the second half of the list into the first half appropriately. \\n\\nTo achieve the first step, we initialize a slow pointer `slow` and a fast pointer `fast`, with the `fast` travels twice as fast as the `slow`, so that when `fast` reaches the end of the list, `slow` reaches the middle of the list. Then we can reverse the links between every node to the right of `slow`. \\n\\nTo achieve the second step, we initialze another pointer `trav = head`. Then we can make `trav` and `fast` both travel to the middle of the list, and in each step, insert `fast` between `trav` and `trav.next`.\\n\\nWe illustrate with two examples. Consider first the following list with even length:\\n```\\n1 -> 2 -> 3 -> 4 (before step 1)\\n1 -> 2 -> 3 <- 4 (after step 1, before step 2)\\n1 -> 4 -> 2 -> 3 (after step 2)\\n```\\nNext, consider the following list with odd length:\\n```\\n1 -> 2 -> 3 -> 4 -> 5 (before step 1)\\n1 -> 2 -> 3 <- 4 <- 5 (after step 1, before step 2)\\n1 -> 4 -> 2 -> 5 -> 3 (after step 2)\\n```\\n\\nTime complexity: `O(n)`, space complexity: `O(1)`.\\n\\n```\\nclass Solution:\\n    def reorderList(self, head):\\n        \"\"\"\\n        :type head: ListNode\\n        :rtype: void Do not return anything, modify head in-place instead.\\n        \"\"\"\\n        if not head or not head.next:\\n            return\\n        slow = head\\n        fast = head.next\\n        while fast.next and fast.next.next:\\n            slow = slow.next\\n            fast = fast.next.next\\n        slow = slow.next\\n        if fast.next:\\n            fast = fast.next\\n            \\n        # reverse the second half of the list\\n        prev = slow\\n        curr = slow.next\\n        prev.next = None\\n        while curr:\\n            tmp = curr.next\\n            curr.next = prev\\n            prev = curr\\n            curr = tmp\\n            \\n        # turn the list into zigzag manner\\n        trav = head\\n        while fast.next:\\n            tmp1 = trav.next\\n            tmp2 = fast.next\\n            trav.next = fast\\n            fast.next = tmp1\\n            trav = tmp1\\n            fast = tmp2\\n```",
                "solutionTags": [],
                "code": "```\\n1 -> 2 -> 3 -> 4 (before step 1)\\n1 -> 2 -> 3 <- 4 (after step 1, before step 2)\\n1 -> 4 -> 2 -> 3 (after step 2)\\n```\n```\\n1 -> 2 -> 3 -> 4 -> 5 (before step 1)\\n1 -> 2 -> 3 <- 4 <- 5 (after step 1, before step 2)\\n1 -> 4 -> 2 -> 5 -> 3 (after step 2)\\n```\n```\\nclass Solution:\\n    def reorderList(self, head):\\n        \"\"\"\\n        :type head: ListNode\\n        :rtype: void Do not return anything, modify head in-place instead.\\n        \"\"\"\\n        if not head or not head.next:\\n            return\\n        slow = head\\n        fast = head.next\\n        while fast.next and fast.next.next:\\n            slow = slow.next\\n            fast = fast.next.next\\n        slow = slow.next\\n        if fast.next:\\n            fast = fast.next\\n            \\n        # reverse the second half of the list\\n        prev = slow\\n        curr = slow.next\\n        prev.next = None\\n        while curr:\\n            tmp = curr.next\\n            curr.next = prev\\n            prev = curr\\n            curr = tmp\\n            \\n        # turn the list into zigzag manner\\n        trav = head\\n        while fast.next:\\n            tmp1 = trav.next\\n            tmp2 = fast.next\\n            trav.next = fast\\n            fast.next = tmp1\\n            trav = tmp1\\n            fast = tmp2\\n```",
                "codeTag": "Java"
            },
            {
                "id": 45175,
                "title": "java-solution-with-stack",
                "content": "I see no one use stack with java as the same idea as me, so I share my code here.\\n\\nIt is a bit straightforward, so need not explaination.\\n\\n    public class Solution {\\n        public void reorderList(ListNode head) {\\n            if (head==null||head.next==null) return;\\n            Deque<ListNode> stack = new ArrayDeque<ListNode>();\\n            ListNode ptr=head;\\n            while (ptr!=null) {\\n                stack.push(ptr); ptr=ptr.next;\\n            }\\n            int cnt=(stack.size()-1)/2;\\n            ptr=head;\\n            while (cnt-->0) {\\n                ListNode top = stack.pop();\\n                ListNode tmp = ptr.next;\\n                ptr.next=top;\\n                top.next=tmp;\\n                ptr=tmp;\\n            }\\n            stack.pop().next=null;\\n        }\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n        public void reorderList(ListNode head) {\\n            if (head==null||head.next==null) return;\\n            Deque<ListNode> stack = new ArrayDeque<ListNode>();\\n            ListNode ptr=head;\\n            while (ptr!=null) {\\n                stack.push(ptr); ptr=ptr.next;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 801842,
                "title": "c-simple-recursive-vs-iterative-approaches-compared-and-explained-10-time-60-space",
                "content": "Core ideas:\\n* we have to run through the list to find the penultimate, not the last node;\\n* once we have it, we can also access the last and we set the the second node to follow the last, last to follow the head and `NULL` the penultimate;\\n* after that, we call `reorderList` on the third node;\\n* if the list has less than 3 elements, no point in proceeding, so we `return` (our base case);\\n\\nTime performance is rather low (I go more or less quadratic here), but unless you change the values and/or use a bunch of extra memory to store the most of the list in some collection, I don\\'t see many other ways around than iterating through it a bunch of times; I might try the other approach later, but that is clearly less fun.\\n\\nThe recursive code:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    void reorderList(ListNode* head) {\\n        // base case handled here\\n        if (!head || !head->next || !head->next->next) return;\\n        // we need to find the penultimate node in order to proceed\\n        ListNode* penultimate = head;\\n        while (penultimate->next->next) penultimate = penultimate->next;\\n        // then we move it in the second spot\\n        penultimate->next->next = head->next;\\n        head->next = penultimate->next;\\n        // and set penultimate to be the last\\n        penultimate->next = NULL;\\n        // and then we proceed with the rest, same way\\n        reorderList(head->next->next);\\n    }\\n};\\n```\\n\\nThe iterative code:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    void reorderList(ListNode* head) {\\n        // we need to find the penultimate node in order to proceed\\n        ListNode* penultimate;\\n        while (head && head->next && head->next->next) {\\n            penultimate = head;\\n            while (penultimate->next->next) penultimate = penultimate->next;\\n            // then we move it in the second spot\\n            penultimate->next->next = head->next;\\n            head->next = penultimate->next;\\n            // and set penultimate to be the last\\n            penultimate->next = NULL;\\n            head = head->next->next;\\n        }\\n    }\\n};\\n```\\nCould my pride stop here? Naaaah.\\n\\n[Improved version with the hare-based approach](https://leetcode.com/problems/reorder-list/discuss/802983/)",
                "solutionTags": [
                    "C++",
                    "C",
                    "Linked List",
                    "Recursion",
                    "Iterator"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    void reorderList(ListNode* head) {\\n        // base case handled here\\n        if (!head || !head->next || !head->next->next) return;\\n        // we need to find the penultimate node in order to proceed\\n        ListNode* penultimate = head;\\n        while (penultimate->next->next) penultimate = penultimate->next;\\n        // then we move it in the second spot\\n        penultimate->next->next = head->next;\\n        head->next = penultimate->next;\\n        // and set penultimate to be the last\\n        penultimate->next = NULL;\\n        // and then we proceed with the rest, same way\\n        reorderList(head->next->next);\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    void reorderList(ListNode* head) {\\n        // we need to find the penultimate node in order to proceed\\n        ListNode* penultimate;\\n        while (head && head->next && head->next->next) {\\n            penultimate = head;\\n            while (penultimate->next->next) penultimate = penultimate->next;\\n            // then we move it in the second spot\\n            penultimate->next->next = head->next;\\n            head->next = penultimate->next;\\n            // and set penultimate to be the last\\n            penultimate->next = NULL;\\n            head = head->next->next;\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1059115,
                "title": "java-one-pass-recursive-solution-with-animation-explanation",
                "content": "[animation explaination](https://docs.google.com/presentation/d/e/2PACX-1vQ-Oy-oQ0i4CvWbo8gf9-v42gVOb5gS76sJvhG7jqIntQV7R1dDG3tS7YUhRiPqYXBCjqCcVsJUeZjG/pub?start=true&loop=false&delayms=1500)\\n\\n<img src=\"https://assets.leetcode.com/users/images/0b44167d-f0c4-409a-bb80-9cab9e6b05e0_1612957822.2802742.png\" width=\"600px\" />\\n\\n```\\nclass Solution {\\n    \\n    private ListNode temp;\\n    private boolean isStop;\\n\\n    public void reorderList(ListNode head) {\\n        temp = head;\\n        isStop = false;\\n        reorder(head);\\n    }\\n\\n    private void reorder(ListNode head) {\\n        if (head == null) return;\\n        reorder(head.next);\\n\\n        if (!isStop) {\\n            ListNode next = temp.next;\\n            temp.next = head;\\n            head.next = next;\\n            temp = next;\\n        }\\n\\n        if (temp != null && temp.next == head) {\\n            temp.next = null;\\n            isStop = true;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    \\n    private ListNode temp;\\n    private boolean isStop;\\n\\n    public void reorderList(ListNode head) {\\n        temp = head;\\n        isStop = false;\\n        reorder(head);\\n    }\\n\\n    private void reorder(ListNode head) {\\n        if (head == null) return;\\n        reorder(head.next);\\n\\n        if (!isStop) {\\n            ListNode next = temp.next;\\n            temp.next = head;\\n            head.next = next;\\n            temp = next;\\n        }\\n\\n        if (temp != null && temp.next == head) {\\n            temp.next = null;\\n            isStop = true;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1641016,
                "title": "easy-c-solution-tc-o-n-sc-o-1",
                "content": "**Step 1**:   Find the middle node of linked list by slow and fast pointer technique.\\n**Step 2**: Divide the linked list into 2 , one from start to mid and second from mid+1 to end.\\n**Step 3**: Reverse the second linked list.\\n**Step 4**: At last, Merge the 2 linked list.\\n\\n```\\nclass Solution {\\n    ListNode* reverse(ListNode* head){\\n        ListNode* prev = NULL;\\n        ListNode* curr = head;\\n        ListNode* nexxt;\\n        \\n        while(curr){\\n            nexxt = curr->next;\\n            curr->next = prev;\\n            prev = curr;\\n            curr = nexxt;\\n        }\\n        return prev;\\n    }\\n    \\npublic:\\n    void reorderList(ListNode* head) {\\n        //base case\\n        if(!head || !(head->next) || !(head->next->next)) return;\\n        \\n        //Step1: Find middle node (in case of even length, find first middle node)\\n        ListNode* slow = head;\\n        ListNode* fast = head->next;\\n        \\n        while(fast and fast->next){\\n            fast = fast->next->next;\\n            slow = slow->next;\\n        }\\n        \\n\\t\\t//break linked list into 2 (first from start to mid and second from mid+1 to end)\\n        ListNode* head2 = slow->next;\\n        slow->next = NULL;\\n        \\n        //Step2: Reverse linked list 2 (from mid+1 to end)\\n        head2 = reverse(head2);\\n        \\n        //Step3: Merge 2 linked lists\\n        ListNode* h = head;\\n        while(head2){\\n            ListNode* temp = head2->next;\\n            head2->next = h->next;\\n            h ->next = head2;\\n            head2 = temp;\\n            h = h->next->next;\\n        }\\n    }\\n};\\n```\\n\\n**Time Complexity:  O(n)** \\nO(n/2) to find middle node + O(n/2) to reverse second linked list + O(n/2) to merge 2 list = O(n)\\n**Space Complexity: O(1)**\\n\\n***Please Upvote, if you find the solution helpful.\\nHappy Coding!***",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\n    ListNode* reverse(ListNode* head){\\n        ListNode* prev = NULL;\\n        ListNode* curr = head;\\n        ListNode* nexxt;\\n        \\n        while(curr){\\n            nexxt = curr->next;\\n            curr->next = prev;\\n            prev = curr;\\n            curr = nexxt;\\n        }\\n        return prev;\\n    }\\n    \\npublic:\\n    void reorderList(ListNode* head) {\\n        //base case\\n        if(!head || !(head->next) || !(head->next->next)) return;\\n        \\n        //Step1: Find middle node (in case of even length, find first middle node)\\n        ListNode* slow = head;\\n        ListNode* fast = head->next;\\n        \\n        while(fast and fast->next){\\n            fast = fast->next->next;\\n            slow = slow->next;\\n        }\\n        \\n\\t\\t//break linked list into 2 (first from start to mid and second from mid+1 to end)\\n        ListNode* head2 = slow->next;\\n        slow->next = NULL;\\n        \\n        //Step2: Reverse linked list 2 (from mid+1 to end)\\n        head2 = reverse(head2);\\n        \\n        //Step3: Merge 2 linked lists\\n        ListNode* h = head;\\n        while(head2){\\n            ListNode* temp = head2->next;\\n            head2->next = h->next;\\n            h ->next = head2;\\n            head2 = temp;\\n            h = h->next->next;\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 802902,
                "title": "modular-o-n-time-and-o-1-space-c-solution",
                "content": "This was really a nice problem comprising three common smaller problems of LinkedList\\n1. Find Middle Node in Linked List\\n2. Reverse a Linked List\\n3. Merge Two Linked List in specific manner\\n\\nWe can solve all three problems in O(N) Time and O(1) Space so we can solve this problem in same Time and Space Constraints.\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    ListNode* getMid(ListNode* head)\\n    {\\n        ListNode *slow,*fast;\\n        slow = fast = head;\\n        while(fast->next!=NULL&&fast->next->next!=NULL)\\n        {\\n            slow=slow->next;\\n            fast = fast->next->next;\\n        }\\n        return slow;\\n        \\n    }\\n    \\n    ListNode* getReverse(ListNode* head)\\n    {\\n        ListNode *cur,*prev;\\n        cur=head;\\n        prev = NULL;\\n        while(cur!=NULL)\\n        {\\n            ListNode *temp = cur->next;\\n            cur->next = prev;\\n            prev = cur;\\n            cur = temp;\\n        }\\n        return prev;\\n    }\\n    \\n    void reorderList(ListNode* head) {\\n        \\n        //  If Linked List contains less than 3 nodes then no need to do anything.\\n        if(head==NULL||head->next==NULL||head->next->next==NULL)\\n            return;\\n        \\n        /*  \\n            Get Middle Node\\n            If there is two middle node then return first Middle.\\n        */\\n        ListNode* mid = getMid(head);\\n        \\n        //  Seprate the Second Half of the LinkedList\\n        ListNode* secondHalf = mid->next;\\n        mid->next=NULL;\\n        \\n        //  Reverse the Second Half of LinkedList\\n        ListNode* revHalf = getReverse(secondHalf);\\n        \\n        //  Finally Merge in Required Manner\\n        while(head!=NULL&&revHalf!=NULL)\\n        {\\n            ListNode* temp = head->next;\\n            head->next=revHalf;\\n            revHalf=revHalf->next;\\n            head->next->next=temp;\\n            head = temp;\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    ListNode* getMid(ListNode* head)\\n    {\\n        ListNode *slow,*fast;\\n        slow = fast = head;\\n        while(fast->next!=NULL&&fast->next->next!=NULL)\\n        {\\n            slow=slow->next;\\n            fast = fast->next->next;\\n        }\\n        return slow;\\n        \\n    }\\n    \\n    ListNode* getReverse(ListNode* head)\\n    {\\n        ListNode *cur,*prev;\\n        cur=head;\\n        prev = NULL;\\n        while(cur!=NULL)\\n        {\\n            ListNode *temp = cur->next;\\n            cur->next = prev;\\n            prev = cur;\\n            cur = temp;\\n        }\\n        return prev;\\n    }\\n    \\n    void reorderList(ListNode* head) {\\n        \\n        //  If Linked List contains less than 3 nodes then no need to do anything.\\n        if(head==NULL||head->next==NULL||head->next->next==NULL)\\n            return;\\n        \\n        /*  \\n            Get Middle Node\\n            If there is two middle node then return first Middle.\\n        */\\n        ListNode* mid = getMid(head);\\n        \\n        //  Seprate the Second Half of the LinkedList\\n        ListNode* secondHalf = mid->next;\\n        mid->next=NULL;\\n        \\n        //  Reverse the Second Half of LinkedList\\n        ListNode* revHalf = getReverse(secondHalf);\\n        \\n        //  Finally Merge in Required Manner\\n        while(head!=NULL&&revHalf!=NULL)\\n        {\\n            ListNode* temp = head->next;\\n            head->next=revHalf;\\n            revHalf=revHalf->next;\\n            head->next->next=temp;\\n            head = temp;\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 44997,
                "title": "my-o-n-c-method-accepted",
                "content": "Firstly, I split the list from the middle into two lists. One from head to middle, and the other from middle to the end. Then we reverse the second list. Finally we merge these two lists. O(n) time complexity and O(1) space complexity. \\n\\n    /**\\n     * Definition for singly-linked list.\\n     * struct ListNode {\\n     *     int val;\\n     *     ListNode *next;\\n     *     ListNode(int x) : val(x), next(NULL) {}\\n     * };\\n     */\\n    class Solution {\\n    public:\\n        void reorderList(ListNode *head) {\\n            if(head == NULL || head->next == NULL || head->next->next==NULL)\\n                return;\\n            //find the middle of the list, and split into two lists.    \\n            ListNode *p=head,*q=head;\\n            while(p && q && q->next && q->next->next){\\n                p=p->next;\\n                q=q->next->next;\\n            }\\n            \\n            ListNode *mid = p->next;\\n            p->next=NULL;\\n            p=head;\\n            //reverse from the middle to the end\\n            ListNode *q1=mid, *q2,*q3;\\n            if(mid->next){\\n                q1=mid;\\n                q2=mid->next;\\n                while(q2){\\n                    q3=q2->next;\\n                    q2->next=q1;\\n                    q1=q2;\\n                    q2=q3;\\n                    \\n                }\\n                mid->next=NULL;\\n            }\\n            q=q1;\\n            //merge these two list\\n            ListNode *s=p;\\n            p=p->next;\\n            while(p && q){\\n               s->next=q;\\n               s=s->next;\\n               q=q->next;\\n               \\n               s->next=p;\\n               s=s->next;\\n               p=p->next;\\n            }\\n            if(p){\\n                s->next=p;\\n            }\\n            if(q){\\n                s->next=q;\\n            }\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        void reorderList(ListNode *head) {\\n            if(head == NULL || head->next == NULL || head->next->next==NULL)\\n                return;\\n            //find the middle of the list, and split into two lists.    \\n            ListNode *p=head,*q=head;\\n            while(p && q && q->next && q->next->next){\\n                p=p->next;\\n                q=q->next->next;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 801795,
                "title": "java-algo-explained-beats-100-time",
                "content": "```\\nEXPLANATION:-\\nGiven a list  1 ->  2 -> 3 -> 4 -> 5\\nNow we need to reorder it like 1 -> 5 -> 2 -> 4 -> 3\\n\\nHow can we do this?\\nconsider list elements as L1, L2, .... , Ln-1, Ln.\\nwe need \\nL1 -> Ln -> L2 -> Ln-1 -> . . .\\nNow, if we maintain a pointer at each end, \\nthen we can arrange them alternatively.\\nleft = L1, right = Ln\\nNow 1st iteration\\nList => L1 -> Ln\\n\\n2nd iteration\\nleft = L2, right = Ln-1\\nList => L1 -> Ln -> L2 -> Ln-1\\n\\n3rd iteration\\nleft = l3, right = Ln-2\\nThis process continues until all elements are processed.\\n\\nHere, the problem is if we maintain a pointer at last element in the list\\nwe can\\'t move to it\\'s previous element after \\nit is processed since it is single linked list.\\n\\nSo, to do this, we split the list in two halves and \\nreverse the second half.\\nList = 1 -> 2 -> 3 > 4 -> 5\\nAfter splitting:-\\nL1 = 1 -> 2\\nL2 = 3 -> 4 -> 5\\nNow, we need to reverse second list\\nSo, L2 = 5 -> 4 -> 3\\n\\nNow, insert each element in 2 lists alternatively.\\n1 -> 5 -> 2 -> 4 -> 3\\n\\nThis is how we can get the result.\\n\\nIF YOU HAVE ANY DOUBTS, FEEL FREE TO ASK.\\nIF YOU UNDERSTAND, DON\\'T FORGET TO UPVOTE.\\n\\n\\n```\\n```\\nclass Solution {\\n    public ListNode reverse(ListNode head){\\n        ListNode p1 = head;\\n        ListNode p2 = head.next;\\n        p1.next = null;\\n        while(p2 != null){\\n            ListNode temp = p2.next;\\n            p2.next = p1;\\n            p1 = p2;\\n            p2 = temp;\\n        }\\n        return p1;\\n    }\\n    public void reorderList(ListNode head) {\\n        if(head == null || head.next == null) return ;\\n        ListNode slowPtr = head, fastPtr = head;\\n        ListNode prev = head;\\n\\t\\t// splitting list\\n        while(fastPtr != null && fastPtr.next != null){\\n            prev = slowPtr;\\n            slowPtr = slowPtr.next;\\n            fastPtr = fastPtr.next.next;\\n        }\\n        prev.next = null;\\n\\t\\t// reverse\\n        ListNode rev = reverse(slowPtr);\\n        ListNode ptr = head;\\n\\t\\t// arrange alternatively\\n        while(ptr != null){\\n            ListNode t1 = ptr.next;\\n            ListNode t2 = rev.next;\\n            ptr.next = rev;\\n            if(t1 != null)\\n                rev.next = t1;\\n            ptr = t1;\\n            rev = t2;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nEXPLANATION:-\\nGiven a list  1 ->  2 -> 3 -> 4 -> 5\\nNow we need to reorder it like 1 -> 5 -> 2 -> 4 -> 3\\n\\nHow can we do this?\\nconsider list elements as L1, L2, .... , Ln-1, Ln.\\nwe need \\nL1 -> Ln -> L2 -> Ln-1 -> . . .\\nNow, if we maintain a pointer at each end, \\nthen we can arrange them alternatively.\\nleft = L1, right = Ln\\nNow 1st iteration\\nList => L1 -> Ln\\n\\n2nd iteration\\nleft = L2, right = Ln-1\\nList => L1 -> Ln -> L2 -> Ln-1\\n\\n3rd iteration\\nleft = l3, right = Ln-2\\nThis process continues until all elements are processed.\\n\\nHere, the problem is if we maintain a pointer at last element in the list\\nwe can\\'t move to it\\'s previous element after \\nit is processed since it is single linked list.\\n\\nSo, to do this, we split the list in two halves and \\nreverse the second half.\\nList = 1 -> 2 -> 3 > 4 -> 5\\nAfter splitting:-\\nL1 = 1 -> 2\\nL2 = 3 -> 4 -> 5\\nNow, we need to reverse second list\\nSo, L2 = 5 -> 4 -> 3\\n\\nNow, insert each element in 2 lists alternatively.\\n1 -> 5 -> 2 -> 4 -> 3\\n\\nThis is how we can get the result.\\n\\nIF YOU HAVE ANY DOUBTS, FEEL FREE TO ASK.\\nIF YOU UNDERSTAND, DON\\'T FORGET TO UPVOTE.\\n\\n\\n```\n```\\nclass Solution {\\n    public ListNode reverse(ListNode head){\\n        ListNode p1 = head;\\n        ListNode p2 = head.next;\\n        p1.next = null;\\n        while(p2 != null){\\n            ListNode temp = p2.next;\\n            p2.next = p1;\\n            p1 = p2;\\n            p2 = temp;\\n        }\\n        return p1;\\n    }\\n    public void reorderList(ListNode head) {\\n        if(head == null || head.next == null) return ;\\n        ListNode slowPtr = head, fastPtr = head;\\n        ListNode prev = head;\\n\\t\\t// splitting list\\n        while(fastPtr != null && fastPtr.next != null){\\n            prev = slowPtr;\\n            slowPtr = slowPtr.next;\\n            fastPtr = fastPtr.next.next;\\n        }\\n        prev.next = null;\\n\\t\\t// reverse\\n        ListNode rev = reverse(slowPtr);\\n        ListNode ptr = head;\\n\\t\\t// arrange alternatively\\n        while(ptr != null){\\n            ListNode t1 = ptr.next;\\n            ListNode t2 = rev.next;\\n            ptr.next = rev;\\n            if(t1 != null)\\n                rev.next = t1;\\n            ptr = t1;\\n            rev = t2;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1500997,
                "title": "c-easy-clean-code-with-explaination-o-n-time-and-o-1-space",
                "content": "This problem can be broken down into three simple sub problems and can be solve sequentially to arrive at our final solution.\\n**1. Finding the mid:** take slow and fast ptr and find the start of the second half of Linked List\\n**2. Reverse Linked List:** reverse the second half and split the original Linked list into two independent linked list\\n**3. Merge Linked List:** take each node one by one from both the sublists and merge them into single linked list.\\n```\\nclass Solution {\\npublic:\\n    ListNode* reverse(ListNode* head)\\n    {\\n        ListNode* prev=NULL;\\n        ListNode* curr=head;\\n        ListNode* nxt=NULL;\\n        \\n        while(curr)\\n        {\\n            nxt=curr->next;\\n            curr->next=prev;\\n            prev=curr;\\n            curr=nxt;\\n        }\\n        return prev;\\n    }\\n    \\n    void reorderList(ListNode* head) {\\n        \\n        //step 1 - using slow and fast pointer approach to find the mid of the list\\n        ListNode* slow=head;\\n        ListNode* fast=head->next;\\n        \\n        while(fast and fast->next)\\n        {\\n            slow=slow->next;\\n            fast=fast->next->next;\\n        }\\n        \\n        //step 2 - reverse the second half and split the List into two.\\n        ListNode* second=reverse(slow->next); // independent list second\\n        slow->next=NULL;\\n        ListNode* first=head; // independent list first\\n        \\n        //step 3 - merging the two list\\n        // second list can be shorter when LL size is odd\\n        while(second)\\n        {\\n            ListNode* temp1=first->next;\\n            ListNode* temp2=second->next;\\n            first->next=second;\\n            second->next=temp1;\\n            first=temp1;\\n            second=temp2;\\n        }\\n    }\\n};\\n```\\nExample:\\n**A. for odd length List**\\n1, 2, 3, 4, 5\\nslow ptr= 3\\nreverse(4)\\nsublist1 = 1, 2, 3\\nsublist2 = 5, 4\\nafter merge 1, 5, 2, 4, 3\\n\\n**B, for even length List**\\n1, 2, 3, 4\\nslow ptr= 2\\nreverse(3)\\nsublist1 = 1, 2\\nsublist2 = 4, 3\\nafter merge 1, 4, 2, 3",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* reverse(ListNode* head)\\n    {\\n        ListNode* prev=NULL;\\n        ListNode* curr=head;\\n        ListNode* nxt=NULL;\\n        \\n        while(curr)\\n        {\\n            nxt=curr->next;\\n            curr->next=prev;\\n            prev=curr;\\n            curr=nxt;\\n        }\\n        return prev;\\n    }\\n    \\n    void reorderList(ListNode* head) {\\n        \\n        //step 1 - using slow and fast pointer approach to find the mid of the list\\n        ListNode* slow=head;\\n        ListNode* fast=head->next;\\n        \\n        while(fast and fast->next)\\n        {\\n            slow=slow->next;\\n            fast=fast->next->next;\\n        }\\n        \\n        //step 2 - reverse the second half and split the List into two.\\n        ListNode* second=reverse(slow->next); // independent list second\\n        slow->next=NULL;\\n        ListNode* first=head; // independent list first\\n        \\n        //step 3 - merging the two list\\n        // second list can be shorter when LL size is odd\\n        while(second)\\n        {\\n            ListNode* temp1=first->next;\\n            ListNode* temp2=second->next;\\n            first->next=second;\\n            second->next=temp1;\\n            first=temp1;\\n            second=temp2;\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 345596,
                "title": "simple-js-solution",
                "content": "```\\nvar reorderList = function (head) {\\n  let stack = [], node = head\\n  if (!node) return\\n  while (node) {\\n    stack.push(node)\\n    node = node.next\\n  }\\n\\n  let len = stack.length\\n  node = head\\n  for (let i = 0; i < len; i++) {\\n    if (i % 2 === 0)\\n      node.next = stack.shift()\\n    else\\n      node.next = stack.pop()\\n    node = node.next\\n  }\\n  node.next = null\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar reorderList = function (head) {\\n  let stack = [], node = head\\n  if (!node) return\\n  while (node) {\\n    stack.push(node)\\n    node = node.next\\n  }\\n\\n  let len = stack.length\\n  node = head\\n  for (let i = 0; i < len; i++) {\\n    if (i % 2 === 0)\\n      node.next = stack.shift()\\n    else\\n      node.next = stack.pop()\\n    node = node.next\\n  }\\n  node.next = null\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1298246,
                "title": "java-stack-easy-solution-with-explanation",
                "content": "```\\n![image](https://assets.leetcode.com/users/images/1cef0f2a-8143-45ee-b2c3-58417fdb7aa3_1624714953.3397665.jpeg)\\n![image](https://assets.leetcode.com/users/images/d582cb78-f39e-4dae-9d52-94109194f378_1624714953.383273.jpeg)\\n\\nclass Solution \\n{\\n    public void reorderList(ListNode head) \\n    {\\n        int n=0;\\n        Stack<ListNode> track=new Stack<>();\\n        ListNode temp=head;\\n        \\n        while(temp != null)\\n        {\\n            track.push(temp);//pushing the node into the stack \\n            temp=temp.next;\\n            n+=1;//counting the length \\n        }\\n        \\n        temp=head;\\n        \\n        for (int i=0; i<n/2;i++)//traversing to only the half length \\n        {\\n            ListNode str=temp.next;//storing the next node \\n            \\n            temp.next=track.peek();//current node pointing to the next node \\n            track.pop().next=str;//maintaining the link \\n            \\n            temp=temp.next.next;//as the pair consist of 2, we are covering 2 node at a time \\n        }\\n        \\n        temp.next = null;//to remove the cycle or the cyclic dependency of the elements\\n    }\\n}//Please do vote me, It helps a lot\\n```",
                "solutionTags": [
                    "Java",
                    "Stack"
                ],
                "code": "```\\n![image](https://assets.leetcode.com/users/images/1cef0f2a-8143-45ee-b2c3-58417fdb7aa3_1624714953.3397665.jpeg)\\n![image](https://assets.leetcode.com/users/images/d582cb78-f39e-4dae-9d52-94109194f378_1624714953.383273.jpeg)\\n\\nclass Solution \\n{\\n    public void reorderList(ListNode head) \\n    {\\n        int n=0;\\n        Stack<ListNode> track=new Stack<>();\\n        ListNode temp=head;\\n        \\n        while(temp != null)\\n        {\\n            track.push(temp);//pushing the node into the stack \\n            temp=temp.next;\\n            n+=1;//counting the length \\n        }\\n        \\n        temp=head;\\n        \\n        for (int i=0; i<n/2;i++)//traversing to only the half length \\n        {\\n            ListNode str=temp.next;//storing the next node \\n            \\n            temp.next=track.peek();//current node pointing to the next node \\n            track.pop().next=str;//maintaining the link \\n            \\n            temp=temp.next.next;//as the pair consist of 2, we are covering 2 node at a time \\n        }\\n        \\n        temp.next = null;//to remove the cycle or the cyclic dependency of the elements\\n    }\\n}//Please do vote me, It helps a lot\\n```",
                "codeTag": "Java"
            },
            {
                "id": 590017,
                "title": "intuitive-javascript-solution",
                "content": "```\\n/**\\n * Definition for singly-linked list.\\n * function ListNode(val) {\\n *     this.val = val;\\n *     this.next = null;\\n * }\\n */\\n/**\\n * @param {ListNode} head\\n * @return {void} Do not return anything, modify head in-place instead.\\n */\\nvar reorderList = function(head) {\\n  if (head === null) {\\n    return;\\n  }\\n  /**\\n   * The goal is to reverse the second half of the list and merge it onto\\n   * the first half of the list. The first half will have at most one more\\n   * element than the second half.\\n   */\\n  let second = split(head);\\n  second = reverse(second);\\n  merge(head, second);\\n};\\n\\nfunction split(node) {\\n  let fast = node;\\n  let slow = node;\\n  \\n  while (fast !== null) {\\n    if (fast.next !== null && fast.next.next !== null) {\\n      slow = slow.next;\\n      fast = fast.next.next;\\n    } else {\\n      fast = null;\\n    }\\n  }\\n  \\n  const secondHalf = slow.next;\\n  slow.next = null;\\n  \\n  return secondHalf;\\n}\\n\\nfunction reverse(node) {\\n  let curr = node;\\n  let prev = null;\\n  let next = null;\\n  \\n  while (curr !== null) {\\n    next = curr.next;\\n    curr.next = prev;\\n    prev = curr;\\n    curr = next;\\n  }\\n  \\n  return prev;\\n}\\n\\nfunction merge (l1, l2) {\\n  let l1Next = null;\\n  let l2Next = null;\\n  \\n  while(l2 !== null) {\\n    l1Next = l1.next;\\n    l2Next = l2.next;\\n    \\n    l1.next = l2;\\n    l2.next = l1Next;\\n    \\n    l1 = l1Next;\\n    l2 = l2Next;\\n  }\\n}\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Iterator"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * function ListNode(val) {\\n *     this.val = val;\\n *     this.next = null;\\n * }\\n */\\n/**\\n * @param {ListNode} head\\n * @return {void} Do not return anything, modify head in-place instead.\\n */\\nvar reorderList = function(head) {\\n  if (head === null) {\\n    return;\\n  }\\n  /**\\n   * The goal is to reverse the second half of the list and merge it onto\\n   * the first half of the list. The first half will have at most one more\\n   * element than the second half.\\n   */\\n  let second = split(head);\\n  second = reverse(second);\\n  merge(head, second);\\n};\\n\\nfunction split(node) {\\n  let fast = node;\\n  let slow = node;\\n  \\n  while (fast !== null) {\\n    if (fast.next !== null && fast.next.next !== null) {\\n      slow = slow.next;\\n      fast = fast.next.next;\\n    } else {\\n      fast = null;\\n    }\\n  }\\n  \\n  const secondHalf = slow.next;\\n  slow.next = null;\\n  \\n  return secondHalf;\\n}\\n\\nfunction reverse(node) {\\n  let curr = node;\\n  let prev = null;\\n  let next = null;\\n  \\n  while (curr !== null) {\\n    next = curr.next;\\n    curr.next = prev;\\n    prev = curr;\\n    curr = next;\\n  }\\n  \\n  return prev;\\n}\\n\\nfunction merge (l1, l2) {\\n  let l1Next = null;\\n  let l2Next = null;\\n  \\n  while(l2 !== null) {\\n    l1Next = l1.next;\\n    l2Next = l2.next;\\n    \\n    l1.next = l2;\\n    l2.next = l1Next;\\n    \\n    l1 = l1Next;\\n    l2 = l2Next;\\n  }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1941803,
                "title": "100-fastest-swift-solution-time-o-n-space-o-1",
                "content": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     public var val: Int\\n *     public var next: ListNode?\\n *     public init() { self.val = 0; self.next = nil; }\\n *     public init(_ val: Int) { self.val = val; self.next = nil; }\\n *     public init(_ val: Int, _ next: ListNode?) { self.val = val; self.next = next; }\\n * }\\n */\\nclass Solution {\\n   // - Complexity:\\n    //   - time: O(n), where n is the number of nodes in the linked list.\\n    //   - space: O(1), only constant space is used.\\n    \\n    func reorderList(_ head: ListNode?) {\\n        guard head != nil else { return }\\n\\n        var slow = head\\n        var fast = head\\n\\n        while fast?.next != nil {\\n            slow = slow?.next\\n            fast = fast?.next?.next\\n        }\\n\\n        let reversedList = reverseList(slow)\\n        mergeLists(head, reversedList)\\n    }\\n    \\n\\n    private func reverseList(_ head: ListNode?) -> ListNode? {\\n        var prev: ListNode? = nil\\n        var curr = head\\n        var next: ListNode? = nil\\n\\n        while curr != nil {\\n            next = curr?.next\\n\\n            curr?.next = prev\\n            prev = curr\\n            curr = next\\n        }\\n\\n        return prev\\n    }\\n    \\n\\n    private func mergeLists(_ first: ListNode?, _ second: ListNode?) {\\n        var first = first\\n        var second = second\\n        var tmp: ListNode? = nil\\n\\n        while second?.next != nil {\\n            tmp = first?.next\\n            first?.next = second\\n            first = tmp\\n\\n            tmp = second?.next\\n            second?.next = first\\n            second = tmp\\n        }\\n    }\\n\\n}\\n```\\n\\nLet me know in comments if you have any doubts. I will be happy to answer.\\n\\nPlease upvote if you found the solution useful.",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     public var val: Int\\n *     public var next: ListNode?\\n *     public init() { self.val = 0; self.next = nil; }\\n *     public init(_ val: Int) { self.val = val; self.next = nil; }\\n *     public init(_ val: Int, _ next: ListNode?) { self.val = val; self.next = next; }\\n * }\\n */\\nclass Solution {\\n   // - Complexity:\\n    //   - time: O(n), where n is the number of nodes in the linked list.\\n    //   - space: O(1), only constant space is used.\\n    \\n    func reorderList(_ head: ListNode?) {\\n        guard head != nil else { return }\\n\\n        var slow = head\\n        var fast = head\\n\\n        while fast?.next != nil {\\n            slow = slow?.next\\n            fast = fast?.next?.next\\n        }\\n\\n        let reversedList = reverseList(slow)\\n        mergeLists(head, reversedList)\\n    }\\n    \\n\\n    private func reverseList(_ head: ListNode?) -> ListNode? {\\n        var prev: ListNode? = nil\\n        var curr = head\\n        var next: ListNode? = nil\\n\\n        while curr != nil {\\n            next = curr?.next\\n\\n            curr?.next = prev\\n            prev = curr\\n            curr = next\\n        }\\n\\n        return prev\\n    }\\n    \\n\\n    private func mergeLists(_ first: ListNode?, _ second: ListNode?) {\\n        var first = first\\n        var second = second\\n        var tmp: ListNode? = nil\\n\\n        while second?.next != nil {\\n            tmp = first?.next\\n            first?.next = second\\n            first = tmp\\n\\n            tmp = second?.next\\n            second?.next = first\\n            second = tmp\\n        }\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1734333,
                "title": "3-step-space-efficient-javascript-solution",
                "content": "Recommended prerequisite: https://leetcode.com/problems/reverse-linked-list/\\n\\n```\\n/**\\n * @param {ListNode} head\\n * @return {void} Do not return anything, modify head in-place instead.\\n */\\nvar reorderList = function(head) {\\n    // find middle\\n\\t// by moving \"fast\" twice, we\\'ll have \"slow\" in the middle\\n    let slow = head\\n    let fast = head\\n    while (fast.next && fast.next.next) {\\n        slow = slow.next\\n        fast = fast.next.next\\n    }\\n\\n    // reverse second half\\n\\t// with reverse linked list solution\\n    let prev = null\\n    let cur = slow.next\\n    while (cur) {\\n        let temp = cur.next\\n        cur.next = prev\\n        prev = cur\\n        cur = temp\\n    }\\n\\n    slow.next = null\\n\\n    // combine two halves\\n    let h1 = head\\n    let h2 = prev\\n\\n    // if even, second half will be smaller\\n\\twhile (h2) {\\n        let temp = h1.next\\n        h1.next = h2\\n        h1 = h2\\n        h2 = temp\\n    }\\n};\\n```\\n\\nexample run:\\n```\\nhead: 1 -> 2 -> 3 -> 4 -> 5\\n\\nh1: 1 -> 2 -> 3\\nh2: 5 -> 4\\n\\nhead: 1 -> 5 -> 2 -> 4 -> 3\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {ListNode} head\\n * @return {void} Do not return anything, modify head in-place instead.\\n */\\nvar reorderList = function(head) {\\n    // find middle\\n\\t// by moving \"fast\" twice, we\\'ll have \"slow\" in the middle\\n    let slow = head\\n    let fast = head\\n    while (fast.next && fast.next.next) {\\n        slow = slow.next\\n        fast = fast.next.next\\n    }\\n\\n    // reverse second half\\n\\t// with reverse linked list solution\\n    let prev = null\\n    let cur = slow.next\\n    while (cur) {\\n        let temp = cur.next\\n        cur.next = prev\\n        prev = cur\\n        cur = temp\\n    }\\n\\n    slow.next = null\\n\\n    // combine two halves\\n    let h1 = head\\n    let h2 = prev\\n\\n    // if even, second half will be smaller\\n\\twhile (h2) {\\n        let temp = h1.next\\n        h1.next = h2\\n        h1 = h2\\n        h2 = temp\\n    }\\n};\\n```\n```\\nhead: 1 -> 2 -> 3 -> 4 -> 5\\n\\nh1: 1 -> 2 -> 3\\nh2: 5 -> 4\\n\\nhead: 1 -> 5 -> 2 -> 4 -> 3\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 45127,
                "title": "python-solution",
                "content": "Does't matter if the length of the list is odd or even, find mid, split, reverse the second list and insert. Pretty straightfowward.\\n\\n    class Solution(object):\\n    def reorderList(self, head):\\n        if not head or not head.next or not head.next.next: return\\n        slow, fast=head, head\\n        while fast.next and fast.next.next: slow, fast=slow.next, fast.next.next\\n        head1, head2=head, slow.next\\n        slow.next, cur, pre=None, head2, None\\n        while cur:\\n            curnext=cur.next\\n            cur.next=pre\\n            pre=cur\\n            cur=curnext\\n        cur1, cur2=head1, pre\\n        while cur2:\\n            next1, next2=cur1.next, cur2.next\\n            cur1.next=cur2\\n            cur2.next=next1\\n            cur1, cur2=next1, next2",
                "solutionTags": [],
                "code": "Does't matter if the length of the list is odd or even, find mid, split, reverse the second list and insert. Pretty straightfowward.\\n\\n    class Solution(object):\\n    def reorderList(self, head):\\n        if not head or not head.next or not head.next.next: return\\n        slow, fast=head, head\\n        while fast.next and fast.next.next: slow, fast=slow.next, fast.next.next\\n        head1, head2=head, slow.next\\n        slow.next, cur, pre=None, head2, None\\n        while cur:\\n            curnext=cur.next\\n            cur.next=pre\\n            pre=cur\\n            cur=curnext\\n        cur1, cur2=head1, pre\\n        while cur2:\\n            next1, next2=cur1.next, cur2.next\\n            cur1.next=cur2\\n            cur2.next=next1\\n            cur1, cur2=next1, next2",
                "codeTag": "Java"
            },
            {
                "id": 45015,
                "title": "my-c-code-split-reverse-the-second-half-and-merge-71-ms",
                "content": " The basic idea is to split the list in half, then reverse the second half,  and at last merge them. It is O(n) time, O(1) space. I was also wondering if there is a better solution.\\n\\n    class Solution {\\n    public:\\n        void reorderList(ListNode *head) {\\n      // use fast/slow points to find the second half of the list       \\n                ListNode *head1, *head2;\\n                ListNode *preNode, *curNode;\\n                \\n                if(!head || !(head->next) )\\n                {// if the list is empty or only has one element\\n                    return;\\n                }\\n                else\\n                {\\n                    head1 = head;\\n                    head2 = head->next;\\n                    \\n                    // find the starting point of the second half\\n                    while(head2 && head2->next)\\n                    {\\n                        head1 = head1->next;\\n                        head2 = (head2->next)->next;\\n                    }\\n                    \\n                    //reverse the second half\\n                    head2 =head1->next; // the head of the second half\\n                    head1->next =NULL;\\n                    preNode = NULL;\\n                    \\n                    while(head2)\\n                    {\\n                        curNode = head2->next;\\n                        head2->next = preNode;\\n                        preNode= head2;\\n                        head2 = curNode;\\n                    }\\n                    \\n                    // merge the first half and the reversed second half\\n                    head2 = preNode;\\n                    head1 = head;\\n                    \\n                    while(head2)\\n                    {\\n                        curNode = head1->next;\\n                        head1 = head1->next = head2;\\n                        head2 = curNode;\\n                    }\\n                    \\n                    return;\\n                }\\n            }",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        void reorderList(ListNode *head) {\\n      // use fast/slow points to find the second half of the list       \\n                ListNode *head1, *head2;\\n                ListNode *preNode, *curNode;\\n                \\n                if(!head || !(head->next) )\\n                {// if the list is empty or only has one element\\n                    return;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 3276570,
                "title": "awesome-slow-fast-logic",
                "content": "\\n\\n# Fast And Slow Logic\\n```\\nclass Solution:\\n    def reorderList(self, head: Optional[ListNode]) -> None:\\n        # divide the linked list\\n        slow,fast=head,head.next\\n        while fast and fast.next:\\n            slow=slow.next\\n            fast=fast.next.next\\n        second=slow.next\\n        # making Null of half linked list\\n        prev=slow.next=None\\n        # reverse the end linked list\\n        while second:\\n            nxt=second.next\\n            second.next=prev\\n            prev=second\\n            second=nxt\\n        # merging the divided linked list\\n        first,last=head,prev\\n        while last:\\n            nxt1,nxt2=first.next,last.next\\n            first.next=last\\n            last.next=nxt1\\n            first,last=nxt1,nxt2\\n        \\n```\\n# please upvote me it would encourage me alot\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def reorderList(self, head: Optional[ListNode]) -> None:\\n        # divide the linked list\\n        slow,fast=head,head.next\\n        while fast and fast.next:\\n            slow=slow.next\\n            fast=fast.next.next\\n        second=slow.next\\n        # making Null of half linked list\\n        prev=slow.next=None\\n        # reverse the end linked list\\n        while second:\\n            nxt=second.next\\n            second.next=prev\\n            prev=second\\n            second=nxt\\n        # merging the divided linked list\\n        first,last=head,prev\\n        while last:\\n            nxt1,nxt2=first.next,last.next\\n            first.next=last\\n            last.next=nxt1\\n            first,last=nxt1,nxt2\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 45026,
                "title": "clear-c-solution",
                "content": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     struct ListNode *next;\\n * };\\n */\\n \\nstruct ListNode* getMid(struct ListNode*);\\nstruct ListNode* reverseList(struct ListNode*);\\nvoid merge(struct ListNode*, struct ListNode*);\\n\\nvoid reorderList(struct ListNode* head) {\\n    if(head == NULL || head->next == NULL || head->next->next == NULL) return;\\n    \\n    struct ListNode* mid = getMid(head);\\n    struct ListNode* secondHalf = mid->next;\\n    mid->next = NULL;\\n    secondHalf = reverseList(secondHalf);\\n    merge(head, secondHalf);\\n    \\n}\\n\\nstruct ListNode* getMid(struct ListNode* head){\\n    struct ListNode* fast = head;\\n    struct ListNode* slow = head;\\n    while(fast->next!=NULL && fast->next->next!=NULL){\\n        fast = fast->next->next;\\n        slow = slow->next;\\n    }\\n    return slow;\\n}\\n\\nstruct ListNode* reverseList(struct ListNode* head) {\\n    struct ListNode* tail = NULL;\\n    while(head!=NULL){\\n        struct ListNode* cur = head;\\n        head = head->next;\\n        \\n        cur->next = tail;\\n        tail = cur;\\n    }\\n    \\n    return tail;\\n}\\n\\nvoid merge(struct ListNode* head1, struct ListNode* head2){\\n    struct ListNode* head = head1;\\n    \\n    while(head2!=NULL){\\n        struct ListNode* next = head2->next;\\n        head2->next = head->next;\\n        head->next = head2;\\n        \\n        head = head->next->next;\\n        head2 = next;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     struct ListNode *next;\\n * };\\n */\\n \\nstruct ListNode* getMid(struct ListNode*);\\nstruct ListNode* reverseList(struct ListNode*);\\nvoid merge(struct ListNode*, struct ListNode*);\\n\\nvoid reorderList(struct ListNode* head) {\\n    if(head == NULL || head->next == NULL || head->next->next == NULL) return;\\n    \\n    struct ListNode* mid = getMid(head);\\n    struct ListNode* secondHalf = mid->next;\\n    mid->next = NULL;\\n    secondHalf = reverseList(secondHalf);\\n    merge(head, secondHalf);\\n    \\n}\\n\\nstruct ListNode* getMid(struct ListNode* head){\\n    struct ListNode* fast = head;\\n    struct ListNode* slow = head;\\n    while(fast->next!=NULL && fast->next->next!=NULL){\\n        fast = fast->next->next;\\n        slow = slow->next;\\n    }\\n    return slow;\\n}\\n\\nstruct ListNode* reverseList(struct ListNode* head) {\\n    struct ListNode* tail = NULL;\\n    while(head!=NULL){\\n        struct ListNode* cur = head;\\n        head = head->next;\\n        \\n        cur->next = tail;\\n        tail = cur;\\n    }\\n    \\n    return tail;\\n}\\n\\nvoid merge(struct ListNode* head1, struct ListNode* head2){\\n    struct ListNode* head = head1;\\n    \\n    while(head2!=NULL){\\n        struct ListNode* next = head2->next;\\n        head2->next = head->next;\\n        head->next = head2;\\n        \\n        head = head->next->next;\\n        head2 = next;\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 45153,
                "title": "python-in-place-solution-with-comments-two-pointers",
                "content": "For linked list 1->2->3->4-5, the code first makes the list to be 1->2->3->4<-5 and 4->None, then make 3->None, for even number linked list: 1->2->3->4, make first 1->2->3<-4 and 3->None, and lastly do not forget to make 2->None. \\n    \\n    def reorderList(self, head):\\n        if not head:\\n            return\\n        # ensure the first part has the same or one more node\\n        fast, slow = head.next, head\\n        while fast and fast.next:\\n            fast = fast.next.next\\n            slow = slow.next\\n        # reverse the second half\\n        p = slow.next\\n        slow.next = None\\n        node = None\\n        while p:\\n            nxt = p.next\\n            p.next = node\\n            node = p\\n            p = nxt\\n        # combine head part and node part\\n        p = head\\n        while node:\\n            tmp = node.next\\n            node.next = p.next\\n            p.next = node\\n            p = p.next.next #p = node.next\\n            node = tmp",
                "solutionTags": [
                    "Python",
                    "Two Pointers"
                ],
                "code": "For linked list 1->2->3->4-5, the code first makes the list to be 1->2->3->4<-5 and 4->None, then make 3->None, for even number linked list: 1->2->3->4, make first 1->2->3<-4 and 3->None, and lastly do not forget to make 2->None. \\n    \\n    def reorderList(self, head):\\n        if not head:\\n            return\\n        # ensure the first part has the same or one more node\\n        fast, slow = head.next, head\\n        while fast and fast.next:\\n            fast = fast.next.next\\n            slow = slow.next\\n        # reverse the second half\\n        p = slow.next\\n        slow.next = None\\n        node = None\\n        while p:\\n            nxt = p.next\\n            p.next = node\\n            node = p\\n            p = nxt\\n        # combine head part and node part\\n        p = head\\n        while node:\\n            tmp = node.next\\n            node.next = p.next\\n            p.next = node\\n            p = p.next.next #p = node.next\\n            node = tmp",
                "codeTag": "Python3"
            },
            {
                "id": 44996,
                "title": "my-c-solution-for-u3010reorder-list-u3011ac-within-72ms",
                "content": "    class Solution {\\n    public:\\n        void reorderList(ListNode *head) {\\n    \\t\\tif (!head) return;\\n    \\t\\tListNode dummy(-1);\\n    \\t\\tdummy.next = head;\\n    \\t\\tListNode *p1 = &dummy, *p2 = &dummy;\\n    \\t\\tfor (; p2 && p2->next; p1 = p1->next, p2 = p2->next->next);\\n    \\t\\tfor ( ListNode *prev = p1, *curr = p1->next; curr && curr->next; ){\\n    \\t\\t\\tListNode *tmp = curr->next;\\n    \\t\\t\\tcurr->next = curr->next->next;\\n    \\t\\t\\ttmp->next = prev->next;\\n    \\t\\t\\tprev->next = tmp;\\n    \\t\\t}\\n    \\t\\tfor ( p2 = p1->next, p1->next = NULL,p1 = head; p2; ){\\n    \\t\\t\\tListNode *tmp = p1->next;\\n    \\t\\t\\tp1->next = p2;\\n    \\t\\t\\tp2 = p2->next;\\n    \\t\\t\\tp1->next->next = tmp;\\n    \\t\\t\\tp1 = tmp;\\n    \\t\\t}\\n        }\\n    };\\n\\n\\n\\nStep1. get the mid Node of the list\\n\\nStep2. reverse the second half list \\n\\nStep3. merge the two half lists\\n\\n**Clean & Concise is better**",
                "solutionTags": [
                    "C++",
                    "Linked List"
                ],
                "code": "class Solution {\\n    public:\\n        void reorderList(ListNode *head) {\\n    \\t\\tif (!head) return;\\n    \\t\\tListNode dummy(-1);\\n    \\t\\tdummy.next = head;\\n    \\t\\tListNode *p1 = &dummy, *p2 = &dummy;\\n    \\t\\tfor (; p2 && p2->next; p1 = p1->next, p2 = p2->next->next);\\n    \\t\\tfor ( ListNode *prev = p1, *curr = p1->next; curr && curr->next; ){\\n    \\t\\t\\tListNode *tmp = curr->next;\\n    \\t\\t\\tcurr->next = curr->next->next;\\n    \\t\\t\\ttmp->next = prev->next;\\n    \\t\\t\\tprev->next = tmp;\\n    \\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 390319,
                "title": "javascript-solution-with-3-steps",
                "content": "##### Steps:\\n1. use fast & slow pointer to get to the middle of linked list. Note when list has even number of nodes, get the middle left node of the list.\\n2. break the list in the middle, and reverse the second half of the list \\n3. interleave the reversed second half with the first half\\n\\nImplementation:\\n```js\\nvar reorderList = function(head) {\\n  // nothing need to be done in case list is either empty or contains only one or two nodes\\n  if (!head || !head.next || !head.next.next) return head;\\n\\n  // step 1: use fast and slow pointer to move to the middle of linked list\\n  // in case list is even, then move to the middle left node\\n  let fast = head.next, slow = head;\\n  while (fast && fast.next) {\\n    fast = fast.next.next;\\n    slow = slow.next;\\n  }\\n\\n  // get the second half of list\\n  const secondHalf = slow.next;\\n\\n  // break the list\\n  slow.next = null;\\n\\n  // step 2: reverse the second half\\n  let curr = secondHalf, prev = null, tmp;\\n\\n  while (curr) {\\n    tmp = curr.next;\\n    curr.next = prev;\\n    prev = curr;\\n    curr = tmp;\\n  }\\n\\n  // step 3: interleave the first half with second half\\n  let first = head, second = prev;\\n  while (second) {\\n    tmp = first.next;\\n    first.next = second;\\n    second = second.next;\\n    first.next.next = tmp;\\n    first = tmp;\\n  }\\n};\\n```\\nHappy Coding~",
                "solutionTags": [],
                "code": "```js\\nvar reorderList = function(head) {\\n  // nothing need to be done in case list is either empty or contains only one or two nodes\\n  if (!head || !head.next || !head.next.next) return head;\\n\\n  // step 1: use fast and slow pointer to move to the middle of linked list\\n  // in case list is even, then move to the middle left node\\n  let fast = head.next, slow = head;\\n  while (fast && fast.next) {\\n    fast = fast.next.next;\\n    slow = slow.next;\\n  }\\n\\n  // get the second half of list\\n  const secondHalf = slow.next;\\n\\n  // break the list\\n  slow.next = null;\\n\\n  // step 2: reverse the second half\\n  let curr = secondHalf, prev = null, tmp;\\n\\n  while (curr) {\\n    tmp = curr.next;\\n    curr.next = prev;\\n    prev = curr;\\n    curr = tmp;\\n  }\\n\\n  // step 3: interleave the first half with second half\\n  let first = head, second = prev;\\n  while (second) {\\n    tmp = first.next;\\n    first.next = second;\\n    second = second.next;\\n    first.next.next = tmp;\\n    first = tmp;\\n  }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 297054,
                "title": "very-very-very-simple-idea-by-using-a-stack",
                "content": "For example:\\n1 2 3 4 5\\nyou just create a stack like this:\\n5 4 3 2 1\\nthen link with 1->5->2->4->3\\uFF0Cuse half nodes of the stack, finaly cut the last node , set 3->None\\n```\\n        if not head:\\n            return\\n        stack=[]\\n        node=head\\n        while node:\\n            stack.append(node)\\n            node=node.next\\n        node=head\\n        for i in range(len(stack)//2):\\n            n=stack.pop()\\n            t=node.next\\n            node.next=n\\n            n.next=t\\n            node=t\\n        node.next=None    \\n```",
                "solutionTags": [
                    "Python3",
                    "Stack"
                ],
                "code": "```\\n        if not head:\\n            return\\n        stack=[]\\n        node=head\\n        while node:\\n            stack.append(node)\\n            node=node.next\\n        node=head\\n        for i in range(len(stack)//2):\\n            n=stack.pop()\\n            t=node.next\\n            node.next=n\\n            n.next=t\\n            node=t\\n        node.next=None    \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 802983,
                "title": "c-hare-based-solution-explained-100-time-60-space",
                "content": "This was a complex one for me, since I never reverted a listed string in-place and could not focus enough for a while to spot silly mistakes.\\n\\nAnyway, much more efficiently than [my other attempt](https://leetcode.com/problems/reorder-list/discuss/801842/C%2B%2B-Simple-Recursive-vs.-Iterative-Approaches-Compared-and-Explained-~10-Time-~60-Space), this solution delivers good results and goes in linear time (the previous was quadratic), moving from ~1000ms down up to 28ms, with 40-50ms on average.\\n\\nThis solution can be divided in 3 steps:\\n* finding the first half of the array with the hare approach (ie: having 2 iterators parse it, one moving at double speed and thus when it will be finished, the other has to be midway) and possibly adjusting it with lists of even length;\\n* reverting the list from `half` up to the end - the part that gave me a non-indifferent pain, since I was dumb, period. More info on linked list reversal [here](https://leetcode.com/problems/reverse-linked-list/discuss/803955/);\\n* merging the first half starting with `head` together with the reverted second part starting with `half`, this time having to close things in case we were dealing with an even-lengthed list.\\n\\nThe code:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    void reorderList(ListNode* head) {\\n        // exiting for empty lists\\n        if (!head) return;\\n        // finding the central node with the hare approach\\n        ListNode *tmp = head, *half = head, *prev = NULL;\\n        while (tmp->next && tmp->next->next) {\\n            tmp = tmp->next->next;\\n            half = half->next;\\n        }\\n        // adding one bit in case of lists with even length\\n        if (tmp->next) half = half->next;\\n        // reversing the second half\\n        while (half) {\\n            tmp = half->next;\\n            half->next = prev;\\n            prev = half;\\n            half = tmp;\\n        }\\n        half = prev;\\n        // merging the 2 lists\\n        while (head && half) {\\n            tmp = head->next;\\n            prev = half->next;\\n            head->next = half;\\n            half->next = tmp;\\n            head = tmp;\\n            half = prev;\\n        }\\n        // closing when we had even length arrays\\n        if (head && head->next) head->next->next = NULL;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Linked List"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    void reorderList(ListNode* head) {\\n        // exiting for empty lists\\n        if (!head) return;\\n        // finding the central node with the hare approach\\n        ListNode *tmp = head, *half = head, *prev = NULL;\\n        while (tmp->next && tmp->next->next) {\\n            tmp = tmp->next->next;\\n            half = half->next;\\n        }\\n        // adding one bit in case of lists with even length\\n        if (tmp->next) half = half->next;\\n        // reversing the second half\\n        while (half) {\\n            tmp = half->next;\\n            half->next = prev;\\n            prev = half;\\n            half = tmp;\\n        }\\n        half = prev;\\n        // merging the 2 lists\\n        while (head && half) {\\n            tmp = head->next;\\n            prev = half->next;\\n            head->next = half;\\n            half->next = tmp;\\n            head = tmp;\\n            half = prev;\\n        }\\n        // closing when we had even length arrays\\n        if (head && head->next) head->next->next = NULL;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 45182,
                "title": "my-java-solution-in-o-n-time",
                "content": "    //1. find the middle node\\n    //2. reverse the right side of the list\\n    //3. merger the left side list and right side list\\n    \\n        \\n        public class Solution {\\n            public void reorderList(ListNode head) {\\n                if(head==null) return;\\n                ListNode slow = head, fast = head;\\n                while(fast!=null && fast.next!=null){\\n                    slow = slow.next;\\n                    fast = fast.next.next;\\n                }\\n                ListNode mid = slow, cur = slow.next;\\n                if(cur!=null){\\n                    ListNode tmp = cur.next;\\n                    cur.next = null;\\n                    cur = tmp;\\n                }\\n                while(cur!=null){\\n                    ListNode tmp = cur.next;\\n                    cur.next = mid.next;\\n                    mid.next = cur;\\n                    cur = tmp;\\n                }\\n                ListNode left = head, right = mid.next;\\n                while(right!=null){\\n                    mid.next = right.next;\\n                    right.next = left.next;\\n                    left.next = right;\\n                    left = right.next;\\n                    right = mid.next;\\n                }\\n                \\n            }\\n        }",
                "solutionTags": [],
                "code": "class Solution {\\n            public void reorderList(ListNode head) {\\n                if(head==null) return;\\n                ListNode slow = head, fast = head;\\n                while(fast!=null && fast.next!=null){\\n                    slow = slow.next;\\n                    fast = fast.next.next;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 3384555,
                "title": "java-merging-two-pointers-solution-with-clear-explanation-and-real-life-application",
                "content": "# Intuition\\nThe problem \"Reorder List\" asks us to reorder a singly linked list such that it has a specific structures: the first node, followed by the last node, then the second node, then the second-to-last node, and so on. \\n\\nThis problem is a combination and modification of these 3 problems: Middle of the Linked List, Reversed Linked List, Merge Sort. Here are the links to each:\\n\\n1. https://leetcode.com/problems/middle-of-the-linked-list/\\n2. https://leetcode.com/problems/reverse-linked-list/\\n3. https://leetcode.com/problems/merge-sorted-array/\\n\\n\\nHere is the intuition behind this approach.\\n\\n1. Divide the linked list into two halves by finding the middle node using the slow-fast pointer technique.\\n\\n2. Reverse the second half of the list.\\n\\n3. Merge the two halves into a single sorted linked list.\\n\\n\\n# Approach\\nHere is the approach to this problem:\\n\\n1. Split the original list into two halves: We can split the list into two halves using the slow-fast pointer technique. This will give us two separate lists: the first half starts at the head of the original list and ends before the middle node, and the second half starts at the middle node and ends at the tail.\\n\\n2. Reverse the second half of the list: We need to reverse the second half of the list because we want to start with the last node and work our way towards the middle. \\n\\n3. Merge the two halves: After we have the two separate lists, we can merge them in the required order. We can do this by starting with the first node of the first list and the last node of the second list, then alternating between nodes from both lists until we reach the middle of the list.\\n\\n\\n\\n# Code\\n```\\nclass Solution {\\n    public void reorderList(ListNode head) {\\n        //find middle element\\n        ListNode slow = head;\\n        ListNode fast = head.next;\\n        while(fast != null && fast.next != null)\\n        {\\n            slow = slow.next;\\n            fast = fast.next.next;\\n        }\\n\\n        //reverse the second half of the list starting from the middle\\n        ListNode prev = null;\\n        while(slow != null)\\n        {\\n            ListNode temp = slow.next;\\n            slow.next = prev;\\n            prev = slow;\\n            slow = temp;\\n        }\\n\\n        //Merge two halves\\n        ListNode p1 = head;\\n        ListNode p2 = prev;\\n         while (p1 != null) {\\n        ListNode next1 = p1.next;\\n        ListNode next2 = p2.next;\\n        p1.next = p2;\\n        p2.next = next1;\\n        p1 = next1;\\n        p2 = next2;\\n    }\\n    }\\n}\\n```\\n\\n# Complexity\\n- Time complexity: $$O(n)$$ where n is the length of the linked list. This is because we only need to traverse the list twice to find the middle node and reverse the second half of the list, and then traverse the list again to merge the two halves.\\n\\n- Space complexity: $$O(1)$$ because we only use a constant amount of extra space.\\n\\n# Application\\nThe Reorder List problem have several real-life applications:\\n\\n1. **Browser Hsitory**: a browser history is typically implement using a linked list data structure, where each webpage visited is stored as a node in the list.\\n\\n2. **Music Playlists**: each song is stored as a node in the list, and the order of songs in the playlist is determined by the order of nodes in the list.\\n\\n3. **File systems:** a file system is usually organized as a hierarchy of directories and files. Each directory and file can be represented as a node in a linked list, with a pointer to its parent directory and a list of child nodes.\\n\\n4. **LRU Cache:** a LRU (Least Recently Used) cache is common caching stategy used in computer systems to store recently accessed items.\\n\\n5. **Garbage collection**: implmented using a linked list of objects that are no longer in use called \"free list\". The garbage colletor scans this list periodically to free up memory.\\n\\n\\n5. **Image manipulation**: represent images as a set of pixels. Each pixel is stored as a node in the list, with a pointer to its neighboring pixels.\\nThis allow for efficient image manipulation, such as scaling or cropping.\\n\\n*Thank you for reading! If you found this solution helpful, please give me an upvote. Feel free to add suggestions.*\\n",
                "solutionTags": [
                    "Java",
                    "Linked List",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\n    public void reorderList(ListNode head) {\\n        //find middle element\\n        ListNode slow = head;\\n        ListNode fast = head.next;\\n        while(fast != null && fast.next != null)\\n        {\\n            slow = slow.next;\\n            fast = fast.next.next;\\n        }\\n\\n        //reverse the second half of the list starting from the middle\\n        ListNode prev = null;\\n        while(slow != null)\\n        {\\n            ListNode temp = slow.next;\\n            slow.next = prev;\\n            prev = slow;\\n            slow = temp;\\n        }\\n\\n        //Merge two halves\\n        ListNode p1 = head;\\n        ListNode p2 = prev;\\n         while (p1 != null) {\\n        ListNode next1 = p1.next;\\n        ListNode next2 = p2.next;\\n        p1.next = p2;\\n        p2.next = next1;\\n        p1 = next1;\\n        p2 = next2;\\n    }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3309977,
                "title": "you-will-never-forget-this-solution-java-100-faster-step-bystep-explained",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->O(N)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->O(1)\\n\\n![Screenshot_20230205_171246.png](https://assets.leetcode.com/users/images/6c995458-e63a-420f-b3fe-135f2dff6519_1679117775.3755183.png)\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public void reorderList(ListNode head) {\\n        // Check if the given list is empty or has only one element\\n        if (head == null || head.next == null) {\\n            return;\\n        }\\n        \\n        // Find the middle node of the list\\n        ListNode slow = head;\\n        ListNode fast = head;\\n        while (fast.next != null && fast.next.next != null) {\\n            slow = slow.next;\\n            fast = fast.next.next;\\n        }\\n        \\n        // Reverse the second half of the list\\n        ListNode prev = null;\\n        ListNode curr = slow.next;\\n        slow.next = null;\\n        while (curr != null) {\\n            ListNode next = curr.next;\\n            curr.next = prev;\\n            prev = curr;\\n            curr = next;\\n        }\\n        \\n        // Merge the two halves of the list\\n        ListNode p1 = head;\\n        ListNode p2 = prev;\\n        while (p2 != null) {\\n            ListNode next1 = p1.next;\\n            ListNode next2 = p2.next;\\n            p1.next = p2;\\n            p2.next = next1;\\n            p1 = next1;\\n            p2 = next2;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Linked List"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public void reorderList(ListNode head) {\\n        // Check if the given list is empty or has only one element\\n        if (head == null || head.next == null) {\\n            return;\\n        }\\n        \\n        // Find the middle node of the list\\n        ListNode slow = head;\\n        ListNode fast = head;\\n        while (fast.next != null && fast.next.next != null) {\\n            slow = slow.next;\\n            fast = fast.next.next;\\n        }\\n        \\n        // Reverse the second half of the list\\n        ListNode prev = null;\\n        ListNode curr = slow.next;\\n        slow.next = null;\\n        while (curr != null) {\\n            ListNode next = curr.next;\\n            curr.next = prev;\\n            prev = curr;\\n            curr = next;\\n        }\\n        \\n        // Merge the two halves of the list\\n        ListNode p1 = head;\\n        ListNode p2 = prev;\\n        while (p2 != null) {\\n            ListNode next1 = p1.next;\\n            ListNode next2 = p2.next;\\n            p1.next = p2;\\n            p2.next = next1;\\n            p1 = next1;\\n            p2 = next2;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2099777,
                "title": "detailed-and-easy-python-solution-for-noobs-like-me",
                "content": "### Question\\n\\nYou are given the head of a singly linked list. The list can be represented as:\\n\\n```\\nL0 \\u2192 L1 \\u2192 \\u2026 \\u2192 Ln - 1 \\u2192 Ln\\n```\\n\\n*Reorder the list to be on the following form:*\\n\\n```\\nL0 \\u2192 Ln \\u2192 L1 \\u2192 Ln - 1 \\u2192 L2 \\u2192 Ln - 2 \\u2192 \\u2026\\n\\n```\\n\\nYou may not modify the values in the list\\'s nodes. Only nodes themselves may be changed.\\n\\n```\\nInput: head = [1,2,3,4]\\nOutput: [1,4,2,3]\\n\\nInput: head = [1,2,3,4,5]\\nOutput: [1,5,2,4,3]\\n```\\n\\n### Brainstorming.\\n\\n1. L0 \\u2192 L1 \\u2192 \\u2026 \\u2192 Ln - 1 \\u2192 Ln covert to \\u2014> L0 \\u2192 Ln \\u2192 L1 \\u2192 Ln - 1 \\u2192 L2 \\u2192 Ln - 2 \\u2192\\n    1. FirstElement \\u2014> lastElement \\u2014> Second Element \\u2014> Second LastElement\\n    \\n    ```python\\n    \\n    1->2->3->4. to 1->4->2->3\\n  \\n    \\n    How will we approach this situation, we have a linked list and we have to merge\\n    in a way that it comes to something like this.\\n    FirstElement \\u2014> lastElement(n-1) \\u2014> Second Element \\u2014> Second LastElement(n-2) ...\\n    \\n    If we look at the final output we can see they look something like two arrays \\n    being merged based on the same indexes.\\n    [1,2] [4,3]--this is the reverse of the second half of the list\\n     ^.    ^\\n    \\n    we are merging the first element from array one and then taking the second element\\n    from array 2 and merging them into a new array.\\n    first Step\\n    [1,2] [4,3]\\n     ^.    ^\\n    1->4\\n    Second Step\\n    [1,2] [4,3]\\n       ^.    ^\\n    1->4->2->3\\n    \\n    This is the intuition we will be using to solve the problem.\\n    \\n    Making two arrays out of the linkedList and then joining one with the other in \\n    reverse order.\\n    \\n    Since we are in a linked list we have no idea what is the lenght of an array.\\n    ```\\n    \\n2. How can we find the lenght of the array and also its half if we need to make that merger.\\n    \\n    ```python\\n    How can we use pointers\\n    1->2->3->4\\n    ^  ^\\n    s. f\\n    \\n    imagine we have a slow pointer and a fast pointer. The fast pointer goes twice as\\n    fast as the slow pointer. When the fast pointer reaches the end of the array, where \\n    will the fast pointer be? half Way!\\n    \\n    First\\n    1->2->3->4\\n    ^  ^\\n    s. f\\n    \\n    Second\\n    1->2->3->4\\n       ^     ^\\n       s     f\\n    \\n    How ever there is one catch here, lets say that the lenght of the array is odd\\n    What will happen then?\\n    \\n    First\\n    1->2->3->4->5\\n    ^  ^\\n    s. f\\n    \\n    Second\\n    1->2->3->4->5\\n       ^     ^\\n       s     f\\n    \\n    Third\\n    1->2->3->4->5->None\\n          ^         ^\\n          s         f\\n    \\n    In the odd case the first array will be larger than the second array by one index\\n    l1 = [1,2,3]\\n    l2 = [4,5]\\n    \\n    How can we write this in code?\\n    \\n    input : head\\n    \\n    s(slowPointer) = head\\n    s(fastPointer) = head.next\\n    \\n    while f and f.next: \\n    \\n    \\ts = s.next\\n    \\tf = f.next.next\\n    \\n    #secondHalfStart = second\\n    second = s.next\\n    \\n    ```\\n    \\n3. Now we know where the second half of the list begins how can we use that information?\\n    1. [reverse a linked list](https://www.notion.so/reverse-a-linked-list-6ff7e58a12d346e9a9645057dae75e26) reference and detail for reversing a linked list and why we will use a temp varaible\\n    \\n    ```python\\n    1->2->3->4\\n          ^\\n          second\\n    \\n    What if we start from the half and reverse the list after it.\\n    \\n    1->2<-3<-4-None\\n             ^\\n             second Pointer is now at the end\\n    \\n    1->2<-3<-4\\n    \\n    Code\\n    #reverse the second Half \\n    #setting s to none as well, so when the we are merging the two list we know\\n    # where the array ends and become two seprate array.\\n    1->2->None <-3<-4<-None\\n    \\n    prev,s.next = None \\n    while second:\\n    \\ttemp = second.next\\n    \\tsecond.next = prev\\n    \\tprev = second\\n    \\tsecond = temp\\n    \\n    #the second half has been reversed.\\n    \\n    ```\\n    \\n4. How will we merge these two lists we have\\n    \\n    ```python\\n    Now have the array we can start with two sides and keep merging them\\n    \\n    First Iteration\\n    1->2->None None<-3<-4 to 1->4\\n    ^.                  ^ \\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\n    First              Second  \\n    \\n    Second iteration\\n    \\n    First Iteration\\n    1->2->None None<-3<-4 to 1->4->2->3\\n       ^.            ^ \\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\n       First         Second  \\n    \\n    We are done! now we can write the code.\\n    \\n    first, second = head, prev\\n    \\n    while second:\\n    \\t\\ttemp1, temp2 = first.next, second.next\\n    \\n    \\t\\tfirst.next = second\\n    \\t\\tsecond.next = temp1\\n    \\t\\tfirst = temp1 \\n    \\t\\tsecond = temp2 \\n    \\n    ```\\n    \\n5. Lets code now\\n    \\n    ```python\\n    # Definition for singly-linked list.\\n    # class ListNode:\\n    #     def __init__(self, val=0, next=None):\\n    #         self.val = val\\n    #         self.next = next\\n    class Solution:\\n        def reorderList(self, head: Optional[ListNode]) -> None:\\n            \"\"\"\\n            Do not return anything, modify head in-place instead.\\n            \"\"\"\\n            \\n            # find the half\\n            slow, fast = head, head.next\\n            \\n            while fast and fast.next:\\n                slow = slow.next\\n                fast = fast.next.next\\n                \\n            half = slow.next\\n            slow.next = None\\n            prev = None\\n            \\n            # Reverse the second half\\n            \\n            while half:\\n                temp = half.next\\n                half.next = prev \\n                prev = half\\n                half = temp\\n                \\n            \\n            # merge the two lists\\n            \\n            first, second = head, prev\\n            \\n            while second:\\n                temp1, temp2 = first.next, second.next\\n                \\n                first.next = second\\n                second.next = temp1\\n                first = temp1\\n                second = temp2\\n    ```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nL0 \\u2192 L1 \\u2192 \\u2026 \\u2192 Ln - 1 \\u2192 Ln\\n```\n```\\nL0 \\u2192 Ln \\u2192 L1 \\u2192 Ln - 1 \\u2192 L2 \\u2192 Ln - 2 \\u2192 \\u2026\\n\\n```\n```\\nInput: head = [1,2,3,4]\\nOutput: [1,4,2,3]\\n\\nInput: head = [1,2,3,4,5]\\nOutput: [1,5,2,4,3]\\n```\n```python\\n    \\n    1->2->3->4. to 1->4->2->3\\n  \\n    \\n    How will we approach this situation, we have a linked list and we have to merge\\n    in a way that it comes to something like this.\\n    FirstElement \\u2014> lastElement(n-1) \\u2014> Second Element \\u2014> Second LastElement(n-2) ...\\n    \\n    If we look at the final output we can see they look something like two arrays \\n    being merged based on the same indexes.\\n    [1,2] [4,3]--this is the reverse of the second half of the list\\n     ^.    ^\\n    \\n    we are merging the first element from array one and then taking the second element\\n    from array 2 and merging them into a new array.\\n    first Step\\n    [1,2] [4,3]\\n     ^.    ^\\n    1->4\\n    Second Step\\n    [1,2] [4,3]\\n       ^.    ^\\n    1->4->2->3\\n    \\n    This is the intuition we will be using to solve the problem.\\n    \\n    Making two arrays out of the linkedList and then joining one with the other in \\n    reverse order.\\n    \\n    Since we are in a linked list we have no idea what is the lenght of an array.\\n    ```\n```python\\n    How can we use pointers\\n    1->2->3->4\\n    ^  ^\\n    s. f\\n    \\n    imagine we have a slow pointer and a fast pointer. The fast pointer goes twice as\\n    fast as the slow pointer. When the fast pointer reaches the end of the array, where \\n    will the fast pointer be? half Way!\\n    \\n    First\\n    1->2->3->4\\n    ^  ^\\n    s. f\\n    \\n    Second\\n    1->2->3->4\\n       ^     ^\\n       s     f\\n    \\n    How ever there is one catch here, lets say that the lenght of the array is odd\\n    What will happen then?\\n    \\n    First\\n    1->2->3->4->5\\n    ^  ^\\n    s. f\\n    \\n    Second\\n    1->2->3->4->5\\n       ^     ^\\n       s     f\\n    \\n    Third\\n    1->2->3->4->5->None\\n          ^         ^\\n          s         f\\n    \\n    In the odd case the first array will be larger than the second array by one index\\n    l1 = [1,2,3]\\n    l2 = [4,5]\\n    \\n    How can we write this in code?\\n    \\n    input : head\\n    \\n    s(slowPointer) = head\\n    s(fastPointer) = head.next\\n    \\n    while f and f.next: \\n    \\n    \\ts = s.next\\n    \\tf = f.next.next\\n    \\n    #secondHalfStart = second\\n    second = s.next\\n    \\n    ```\n```python\\n    1->2->3->4\\n          ^\\n          second\\n    \\n    What if we start from the half and reverse the list after it.\\n    \\n    1->2<-3<-4-None\\n             ^\\n             second Pointer is now at the end\\n    \\n    1->2<-3<-4\\n    \\n    Code\\n    #reverse the second Half \\n    #setting s to none as well, so when the we are merging the two list we know\\n    # where the array ends and become two seprate array.\\n    1->2->None <-3<-4<-None\\n    \\n    prev,s.next = None \\n    while second:\\n    \\ttemp = second.next\\n    \\tsecond.next = prev\\n    \\tprev = second\\n    \\tsecond = temp\\n    \\n    #the second half has been reversed.\\n    \\n    ```\n```python\\n    Now have the array we can start with two sides and keep merging them\\n    \\n    First Iteration\\n    1->2->None None<-3<-4 to 1->4\\n    ^.                  ^ \\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\n    First              Second  \\n    \\n    Second iteration\\n    \\n    First Iteration\\n    1->2->None None<-3<-4 to 1->4->2->3\\n       ^.            ^ \\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\n       First         Second  \\n    \\n    We are done! now we can write the code.\\n    \\n    first, second = head, prev\\n    \\n    while second:\\n    \\t\\ttemp1, temp2 = first.next, second.next\\n    \\n    \\t\\tfirst.next = second\\n    \\t\\tsecond.next = temp1\\n    \\t\\tfirst = temp1 \\n    \\t\\tsecond = temp2 \\n    \\n    ```\n```python\\n    # Definition for singly-linked list.\\n    # class ListNode:\\n    #     def __init__(self, val=0, next=None):\\n    #         self.val = val\\n    #         self.next = next\\n    class Solution:\\n        def reorderList(self, head: Optional[ListNode]) -> None:\\n            \"\"\"\\n            Do not return anything, modify head in-place instead.\\n            \"\"\"\\n            \\n            # find the half\\n            slow, fast = head, head.next\\n            \\n            while fast and fast.next:\\n                slow = slow.next\\n                fast = fast.next.next\\n                \\n            half = slow.next\\n            slow.next = None\\n            prev = None\\n            \\n            # Reverse the second half\\n            \\n            while half:\\n                temp = half.next\\n                half.next = prev \\n                prev = half\\n                half = temp\\n                \\n            \\n            # merge the two lists\\n            \\n            first, second = head, prev\\n            \\n            while second:\\n                temp1, temp2 = first.next, second.next\\n                \\n                first.next = second\\n                second.next = temp1\\n                first = temp1\\n                second = temp2\\n    ```",
                "codeTag": "Java"
            },
            {
                "id": 2045022,
                "title": "c-stack-easy-understanding",
                "content": "Its really easy to understand , we first use **tortoise-hare** method to reach at the mid and end element then push last half linked list into stack and then insert its top element in between the the first half  linked list.\\n```\\nclass Solution {\\npublic:\\n    void reorderList(ListNode* head) {\\n        if(head == NULL || head->next == NULL || head->next->next == NULL) return ;\\n        ListNode* slow= head;\\n        ListNode* fast= head;\\n        stack<ListNode*> st;\\n        while( fast!=NULL && fast->next!=NULL){\\n            slow= slow->next;\\n            fast = fast->next->next;\\n        }\\n        ListNode* n;\\n        \\n        if(fast!=NULL){\\n            n= slow->next;\\n            \\n        }\\n        else n= slow;\\n        \\n        while(n!=NULL){\\n           st.push(n);\\n            n= n->next;\\n            \\n        }\\n        fast= head;\\n        \\n        while(st.size()){\\n          \\n        n = fast->next; \\n            fast->next= st.top();\\n            st.top()->next =n;\\n            fast=n;\\n                st.pop();\\n            \\n        }\\n       slow->next= NULL;\\n        \\n        \\n    }\\n};\\n\\n\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Linked List",
                    "Stack",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void reorderList(ListNode* head) {\\n        if(head == NULL || head->next == NULL || head->next->next == NULL) return ;\\n        ListNode* slow= head;\\n        ListNode* fast= head;\\n        stack<ListNode*> st;\\n        while( fast!=NULL && fast->next!=NULL){\\n            slow= slow->next;\\n            fast = fast->next->next;\\n        }\\n        ListNode* n;\\n        \\n        if(fast!=NULL){\\n            n= slow->next;\\n            \\n        }\\n        else n= slow;\\n        \\n        while(n!=NULL){\\n           st.push(n);\\n            n= n->next;\\n            \\n        }\\n        fast= head;\\n        \\n        while(st.size()){\\n          \\n        n = fast->next; \\n            fast->next= st.top();\\n            st.top()->next =n;\\n            fast=n;\\n                st.pop();\\n            \\n        }\\n       slow->next= NULL;\\n        \\n        \\n    }\\n};\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1744995,
                "title": "easy-recursive-solution-in-c",
                "content": "Approach: Add the last node in front of the first and then recurse for the next to next node\\n```\\nvoid reorderList(ListNode* head) \\n    {\\n\\t\\n\\t    //in case of a list with <=2 nodes, no change is required\\n        if(head==nullptr || head->next==nullptr || head->next->next==nullptr)\\n            return;\\t\\n\\t\\t\\n\\t\\t//last here is actually the 2nd last node of the list\\n        ListNode *last=head;\\n        while(last->next->next) \\n            last=last->next;\\n\\t\\t\\t\\n\\t\\t//moving the last node right next to the front node\\n        last->next->next=head->next;\\n        head->next=last->next;\\n        last->next=nullptr;\\n        reorderList(head->next->next);\\n    }\\n```",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "```\\nvoid reorderList(ListNode* head) \\n    {\\n\\t\\n\\t    //in case of a list with <=2 nodes, no change is required\\n        if(head==nullptr || head->next==nullptr || head->next->next==nullptr)\\n            return;\\t\\n\\t\\t\\n\\t\\t//last here is actually the 2nd last node of the list\\n        ListNode *last=head;\\n        while(last->next->next) \\n            last=last->next;\\n\\t\\t\\t\\n\\t\\t//moving the last node right next to the front node\\n        last->next->next=head->next;\\n        head->next=last->next;\\n        last->next=nullptr;\\n        reorderList(head->next->next);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1059772,
                "title": "c-c-faster-than-97-61-o-n-super-simple-clear-solution",
                "content": "\\tclass Solution {\\n\\tpublic:\\n\\t\\tvoid reorderList(ListNode* head) {\\n\\t\\t\\tif ( ! head ) return;\\n\\t\\t\\tListNode *slow = head, *fast = head;\\n\\t\\t\\twhile ( fast->next && fast->next->next )\\n\\t\\t\\t{\\n\\t\\t\\t\\tslow = slow->next;\\n\\t\\t\\t\\tfast = fast->next->next;\\n\\t\\t\\t}\\n\\t\\t\\t\\t\\n\\t\\t\\t\\n\\t\\t\\tListNode *prev = NULL, *cur = slow->next, *save;\\n\\t\\t\\twhile ( cur )\\n\\t\\t\\t{\\n\\t\\t\\t\\tsave = cur->next;\\n\\t\\t\\t\\tcur->next = prev;\\n\\t\\t\\t\\tprev = cur;\\n\\t\\t\\t\\tcur = save;\\n\\t\\t\\t}\\n\\t\\t\\t\\t\\n\\t\\t\\tslow->next = NULL;\\n\\t\\t\\t\\n\\t\\t\\tListNode *head2 = prev;\\n\\t\\t\\twhile ( head2 )\\n\\t\\t\\t{\\n\\t\\t\\t\\tsave = head->next;\\n\\t\\t\\t\\thead->next = head2;\\n\\t\\t\\t\\thead = head2;\\n\\t\\t\\t\\thead2 = save;\\n\\t\\t\\t}      \\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Linked List"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tvoid reorderList(ListNode* head) {\\n\\t\\t\\tif ( ! head ) return;\\n\\t\\t\\tListNode *slow = head, *fast = head;\\n\\t\\t\\twhile ( fast->next && fast->next->next )\\n\\t\\t\\t{\\n\\t\\t\\t\\tslow = slow->next;\\n\\t\\t\\t\\tfast = fast->next->next;\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 473026,
                "title": "javascript-solution",
                "content": "### The idea\\n1. Split the linked list from the middle using 2 pointers into part1& part2\\n2. Reverse part2\\n3. Merge part1 and part2\\n``` javascript\\n/**\\n * @param {ListNode} head\\n * @return {void} Do not return anything, modify head in-place instead.\\n */\\nvar reorderList = function(head) {\\n    \\n    if (!head || !head.next) return; \\n    \\n    // find the middle point\\n    let slow=head, fast=head;\\n    while(fast.next && fast.next.next) {\\n        slow = slow.next;\\n        fast = fast.next.next;\\n    }\\n    \\n    // split into two part head & part2\\n    let part2 = slow.next;\\n    slow.next = null;\\n    \\n    // reverse part 2\\n    let prev = null, cur = part2, next = cur.next;\\n    while(cur) {\\n        next = cur.next;\\n        cur.next = prev;\\n        prev = cur;\\n        cur = next;\\n    }\\n    \\n    part2 = prev;\\n    \\n    // merge head & part2\\n    while(head && part2) {\\n        let p1 = head.next;\\n        let p2 = part2.next\\n        head.next = part2;\\n        head.next.next = p1;\\n        part2 = p2;\\n        head = p1;\\n    }\\n    \\n    return head;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "``` javascript\\n/**\\n * @param {ListNode} head\\n * @return {void} Do not return anything, modify head in-place instead.\\n */\\nvar reorderList = function(head) {\\n    \\n    if (!head || !head.next) return; \\n    \\n    // find the middle point\\n    let slow=head, fast=head;\\n    while(fast.next && fast.next.next) {\\n        slow = slow.next;\\n        fast = fast.next.next;\\n    }\\n    \\n    // split into two part head & part2\\n    let part2 = slow.next;\\n    slow.next = null;\\n    \\n    // reverse part 2\\n    let prev = null, cur = part2, next = cur.next;\\n    while(cur) {\\n        next = cur.next;\\n        cur.next = prev;\\n        prev = cur;\\n        cur = next;\\n    }\\n    \\n    part2 = prev;\\n    \\n    // merge head & part2\\n    while(head && part2) {\\n        let p1 = head.next;\\n        let p2 = part2.next\\n        head.next = part2;\\n        head.next.next = p1;\\n        part2 = p2;\\n        head = p1;\\n    }\\n    \\n    return head;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 45101,
                "title": "concise-recursive-o-n-solution-with-o-1-space-easy-to-understand",
                "content": "    class Solution {\\n    public:\\n        void reorderList(ListNode* head) {\\n            ListNode* temp = head;\\n            helper(temp, head);\\n    }\\n    \\n    private:\\n    bool helper(ListNode*& head, ListNode* node) {\\n        if (!node) {                       // Find the last node\\n            return false;\\n        }\\n        if (helper(head, node->next)) {   // Stop recursion if mid point has met\\n            return true;\\n        }\\n        if (node == head || node == head->next) {  // Change newEnd->next to NULL and tell the function to stop\\n            node->next = NULL;\\n            return true;\\n        }\\n        ListNode *temp = head;\\n        head = head->next;\\n        temp->next = node;\\n        node->next = head;\\n        \\n        return false;  // Ask the function to continue\\n    }\\n    };\\n\\nThe idea is quite simple here. First we use recursion to find the last node then start doing the reordering. The tricky part is how to tell the function to stop when the mid point has met. Here I simply modify this function to return a boolean value, the returned value is whether this function should stop.\\n\\nHope this could help you a little bit. :)",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        void reorderList(ListNode* head) {\\n            ListNode* temp = head;\\n            helper(temp, head);\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 3205828,
                "title": "143-solution-with-step-by-step-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nTo reorder the linked list we can follow the below steps:\\n\\n1. Find the middle node of the linked list using slow and fast pointer approach.\\n2. Reverse the second half of the linked list.\\n3. Merge the first half and the reversed second half of the linked list alternatively.\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nBeats\\n94.68% O(1)\\n\\n# Code\\n```\\nclass Solution:\\n    def reorderList(self, head: ListNode) -> None:\\n        \"\"\"\\n        Do not return anything, modify head in-place instead.\\n        \"\"\"\\n        if not head or not head.next:\\n            return\\n        \\n        # Step 1: Find the middle of the linked list\\n        slow, fast = head, head.next\\n        while fast and fast.next:\\n            slow = slow.next\\n            fast = fast.next.next\\n        \\n        # Step 2: Reverse the second half of the linked list\\n        curr, prev = slow.next, None\\n        slow.next = None # set the next of the slow to None to break the link\\n        while curr:\\n            nxt = curr.next\\n            curr.next = prev\\n            prev = curr\\n            curr = nxt\\n        second_half = prev\\n        \\n        # Step 3: Merge the first half and the reversed second half of the linked list\\n        first_half = head\\n        while first_half and second_half:\\n            temp1, temp2 = first_half.next, second_half.next\\n            first_half.next = second_half\\n            second_half.next = temp1\\n            first_half, second_half = temp1, temp2\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Linked List",
                    "Two Pointers",
                    "Stack"
                ],
                "code": "```\\nclass Solution:\\n    def reorderList(self, head: ListNode) -> None:\\n        \"\"\"\\n        Do not return anything, modify head in-place instead.\\n        \"\"\"\\n        if not head or not head.next:\\n            return\\n        \\n        # Step 1: Find the middle of the linked list\\n        slow, fast = head, head.next\\n        while fast and fast.next:\\n            slow = slow.next\\n            fast = fast.next.next\\n        \\n        # Step 2: Reverse the second half of the linked list\\n        curr, prev = slow.next, None\\n        slow.next = None # set the next of the slow to None to break the link\\n        while curr:\\n            nxt = curr.next\\n            curr.next = prev\\n            prev = curr\\n            curr = nxt\\n        second_half = prev\\n        \\n        # Step 3: Merge the first half and the reversed second half of the linked list\\n        first_half = head\\n        while first_half and second_half:\\n            temp1, temp2 = first_half.next, second_half.next\\n            first_half.next = second_half\\n            second_half.next = temp1\\n            first_half, second_half = temp1, temp2\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2769524,
                "title": "great-java-explaination",
                "content": "# class Solution {\\n    public void reorderList(ListNode head) {\\n      Stack<ListNode> s=new Stack<>();\\n        ListNode curr=head; //take pointer to store address of head\\n        int c=0;\\n        while(curr!=null)\\n        {\\n            s.push(curr);   //push address of head in stack\\n            curr=curr.next;\\n            c++;          //count elements in stack or list\\n        }\\n       curr=head;          //refer example at end for great explaination\\n        for(int i=0;i<(c/2);i++)     //the loop is run to the half of the list to connect the list and stack\\n        {\\n            ListNode temp=curr.next;  //take temp= address of value 2\\n            ListNode end=s.pop();    //take address of 4 in end node\\n            curr.next=end;           //connect 1 with end (4)\\n            end.next=temp;           //connect end(4) with temp(2)\\n            curr=temp;               //pass address of temp to current to repeat the process till the end of list\\n        }\\n        curr.next=null;\\n    }\\n}\\n// Input: head = [1,2,3,4]\\n// Output: [1,4,2,3]",
                "solutionTags": [
                    "Java",
                    "Stack"
                ],
                "code": "class Solution {\\n    public void reorderList(ListNode head) {\\n      Stack<ListNode> s=new Stack<>();\\n        ListNode curr=head; //take pointer to store address of head\\n        int c=0;\\n        while(curr!=null)\\n        {\\n            s.push(curr);   //push address of head in stack\\n            curr=curr.next;\\n            c++;          //count elements in stack or list\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2280180,
                "title": "best-explanation-ever-0",
                "content": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public void reorderList(ListNode head) {\\n        if(head==null||head.next==null)return ;\\n        \\n        //Find the middle of the list\\n        ListNode slow = head;//slow head pe\\n        ListNode fast = head.next;//fast head.next se\\n        while(fast!=null&&fast.next!=null){//slow humare middle pe poch jayega\\n            slow = slow.next;\\n            fast = fast.next.next;\\n        }\\n        \\n        //Reverse the half after middle  1->2->3->4->5->6 to 1->2->3->6->5->4\\n        ListNode second =slow.next;//Second is At the starting point of second half\\n        ListNode prev = null;\\n        slow.next = null;//last node of first half pointing to null\\n        while(second!=null){// basic reversing function\\n            ListNode forw = second.next;\\n            second.next = prev;\\n            prev =second;\\n            second = forw;\\n        }\\n        \\n        //give output as prev as the head of the reverse linked list\\n        //Start reorder one by one  1->2->3->6->5->4 to 1->6->2->5->3->4\\n        \\n        \\n        ListNode first = head;//first pointer at the head of first list\\n        second = prev;//second pointet at the head of the second reverse list\\n        while(second!=null){//merging function\\n            ListNode temp1=first.next;//temp1 to store the next value of first half\\n            ListNode temp2 = second.next;//temp 2 to store the next value of second half\\n            first.next = second;\\n            second.next =temp1;\\n            first = temp1;//reseting first\\n            second = temp2;//resenting second\\n        }\\n    }\\n}  \\n```\\n<hr>\\n<hr>\\n\\n***TIME COMPLEXITY = 0(N)\\nSPACE COMPLEXITY =O(1)*\\n\\n<hr>\\n<hr>\\n",
                "solutionTags": [],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public void reorderList(ListNode head) {\\n        if(head==null||head.next==null)return ;\\n        \\n        //Find the middle of the list\\n        ListNode slow = head;//slow head pe\\n        ListNode fast = head.next;//fast head.next se\\n        while(fast!=null&&fast.next!=null){//slow humare middle pe poch jayega\\n            slow = slow.next;\\n            fast = fast.next.next;\\n        }\\n        \\n        //Reverse the half after middle  1->2->3->4->5->6 to 1->2->3->6->5->4\\n        ListNode second =slow.next;//Second is At the starting point of second half\\n        ListNode prev = null;\\n        slow.next = null;//last node of first half pointing to null\\n        while(second!=null){// basic reversing function\\n            ListNode forw = second.next;\\n            second.next = prev;\\n            prev =second;\\n            second = forw;\\n        }\\n        \\n        //give output as prev as the head of the reverse linked list\\n        //Start reorder one by one  1->2->3->6->5->4 to 1->6->2->5->3->4\\n        \\n        \\n        ListNode first = head;//first pointer at the head of first list\\n        second = prev;//second pointet at the head of the second reverse list\\n        while(second!=null){//merging function\\n            ListNode temp1=first.next;//temp1 to store the next value of first half\\n            ListNode temp2 = second.next;//temp 2 to store the next value of second half\\n            first.next = second;\\n            second.next =temp1;\\n            first = temp1;//reseting first\\n            second = temp2;//resenting second\\n        }\\n    }\\n}  \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2003485,
                "title": "3-step-c-iterative-solution-easy-to-understand-o-1-space-in-place",
                "content": "**Steps:**\\n1) Find the middle node of the linked list\\n2) Reverse the second half of the linked list\\n3) Merge two linked lists\\n\\n\\t\\tGiven:           1 --> 2 --> 3 --> 4 --> 5\\n\\t\\t\\n\\t\\tAfter Step 1:    1 --> 2 --> 3 --> 4 --> 5\\n\\t\\t\\t\\t\\t\\t\\t\\t      |\\n\\t\\t\\t\\t\\t\\t\\t\\t     slow\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\n\\t\\tAfter Step 2:    1 --> 2 --> 3            5--> 4\\n                                                  |\\n\\t\\t\\t\\t\\t\\t             \\t\\t  \\t  prev\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\n\\t\\tAfter Step 3:    1 --> 5 --> 2 --> 4 --> 3\\n```\\nclass Solution {\\npublic:\\n    void reorderList(ListNode* head) {\\n        if(!head->next) return;\\n        \\n        // Finding middle of linked list\\n        ListNode* slow=head;\\n        ListNode* fast=head;\\n        while(fast->next and fast->next->next){\\n            slow=slow->next;\\n            fast=fast->next->next;\\n        }\\n        \\n        // Reversing the second half of the linked list\\n        ListNode* prev=NULL;\\n        ListNode* curr = slow->next;\\n        while(curr){\\n            ListNode* nextt = curr->next;\\n            curr->next = prev;\\n            prev = curr;\\n            curr=nextt;\\n        }\\n        slow->next = NULL;\\n        \\n        // Merge two lists \\n        ListNode* head1=head;\\n        ListNode* head2=prev;\\n        while(head2){\\n            ListNode* temp = head1->next;\\n            head1->next = head2;\\n            head1=head1->next;\\n            head2= temp;\\n        }\\n        \\n    }\\n};\\n\\n\\n\\n",
                "solutionTags": [
                    "C",
                    "Linked List",
                    "Iterator"
                ],
                "code": "class Solution {\\npublic:\\n    void reorderList(ListNode* head) {\\n        if(!head->next) return;\\n        \\n        // Finding middle of linked list\\n        ListNode* slow=head;\\n        ListNode* fast=head;\\n        while(fast->next and fast->next->next){\\n            slow=slow->next;\\n            fast=fast->next->next;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1059760,
                "title": "python-faster-than-95-06-o-n-super-simple-clear-solution",
                "content": "\\tclass Solution:\\n\\t\\tdef reorderList(self, head: ListNode) -> None:\\n\\t\\t\\tif not head: return head\\n\\t\\t\\tslow, fast = head, head\\n\\t\\t\\twhile fast.next and fast.next.next:\\n\\t\\t\\t\\tslow = slow.next\\n\\t\\t\\t\\tfast = fast.next.next\\n\\t\\t\\t\\n\\t\\t\\tprev, cur = None, slow.next\\n\\t\\t\\twhile cur:\\n\\t\\t\\t\\tsave = cur.next\\n\\t\\t\\t\\tcur.next = prev\\n\\t\\t\\t\\tprev = cur\\n\\t\\t\\t\\tcur = save\\n\\t\\t\\tslow.next = None\\n\\t\\t\\t\\n\\t\\t\\thead2 = prev\\n\\t\\t\\twhile head2:\\n\\t\\t\\t\\tsave1 = head.next\\n\\t\\t\\t\\thead.next = head2\\n\\t\\t\\t\\thead = head2\\n\\t\\t\\t\\thead2 = save1",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Linked List"
                ],
                "code": "\\tclass Solution:\\n\\t\\tdef reorderList(self, head: ListNode) -> None:\\n\\t\\t\\tif not head: return head\\n\\t\\t\\tslow, fast = head, head\\n\\t\\t\\twhile fast.next and fast.next.next:\\n\\t\\t\\t\\tslow = slow.next\\n\\t\\t\\t\\tfast = fast.next.next\\n\\t\\t\\t\\n\\t\\t\\tprev, cur = None, slow.next\\n\\t\\t\\twhile cur:\\n\\t\\t\\t\\tsave = cur.next\\n\\t\\t\\t\\tcur.next = prev\\n\\t\\t\\t\\tprev = cur\\n\\t\\t\\t\\tcur = save\\n\\t\\t\\tslow.next = None\\n\\t\\t\\t\\n\\t\\t\\thead2 = prev\\n\\t\\t\\twhile head2:\\n\\t\\t\\t\\tsave1 = head.next\\n\\t\\t\\t\\thead.next = head2\\n\\t\\t\\t\\thead = head2\\n\\t\\t\\t\\thead2 = save1",
                "codeTag": "Java"
            },
            {
                "id": 803111,
                "title": "rust-4ms",
                "content": "Very long solution.\\n1. Calculate the length\\n2. Traverse half way\\n3. Reverse the second half\\n4. Merge\\n\\n```\\nimpl Solution {\\n    pub fn reorder_list(head: &mut Option<Box<ListNode>>) {\\n        let len = Self::length(&head);\\n\\n        let mut ptr = head.as_mut();\\n        for _ in 0..(len / 2) {\\n            if let Some(node) = ptr {\\n                ptr = node.next.as_mut();\\n            }\\n        }\\n\\n        if let Some(node) = ptr {\\n            let reverse = Self::reverse(node.next.take(), None);\\n\\n            if let Some(node) = head {\\n                node.next = Self::merge(reverse, node.next.take(), len - 1);\\n            }\\n        }\\n    }\\n\\n    fn length(mut head: &Option<Box<ListNode>>) -> usize {\\n        let mut count = 0;\\n        while let Some(node) = head {\\n            head = &node.next;\\n            count += 1;\\n        }\\n        count\\n    }\\n\\n    fn reverse(\\n        head: Option<Box<ListNode>>,\\n        accumulator: Option<Box<ListNode>>,\\n    ) -> Option<Box<ListNode>> {\\n        match head {\\n            None => accumulator,\\n            Some(mut node) => {\\n                let next = node.next;\\n                node.next = accumulator;\\n\\n                Self::reverse(next, Some(node))\\n            }\\n        }\\n    }\\n\\n    fn merge(\\n        mut left: Option<Box<ListNode>>,\\n        right: Option<Box<ListNode>>,\\n        count: usize,\\n    ) -> Option<Box<ListNode>> {\\n        if count == 0 {\\n            None\\n        } else {\\n            match (left.as_mut(), right.as_ref()) {\\n                (None, None) => None,\\n                (Some(_), None) => left,\\n                (None, Some(_)) => right,\\n                (Some(l), Some(_)) => {\\n                    l.next = Self::merge(right, l.next.take(), count - 1);\\n                    left\\n                }\\n            }\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nimpl Solution {\\n    pub fn reorder_list(head: &mut Option<Box<ListNode>>) {\\n        let len = Self::length(&head);\\n\\n        let mut ptr = head.as_mut();\\n        for _ in 0..(len / 2) {\\n            if let Some(node) = ptr {\\n                ptr = node.next.as_mut();\\n            }\\n        }\\n\\n        if let Some(node) = ptr {\\n            let reverse = Self::reverse(node.next.take(), None);\\n\\n            if let Some(node) = head {\\n                node.next = Self::merge(reverse, node.next.take(), len - 1);\\n            }\\n        }\\n    }\\n\\n    fn length(mut head: &Option<Box<ListNode>>) -> usize {\\n        let mut count = 0;\\n        while let Some(node) = head {\\n            head = &node.next;\\n            count += 1;\\n        }\\n        count\\n    }\\n\\n    fn reverse(\\n        head: Option<Box<ListNode>>,\\n        accumulator: Option<Box<ListNode>>,\\n    ) -> Option<Box<ListNode>> {\\n        match head {\\n            None => accumulator,\\n            Some(mut node) => {\\n                let next = node.next;\\n                node.next = accumulator;\\n\\n                Self::reverse(next, Some(node))\\n            }\\n        }\\n    }\\n\\n    fn merge(\\n        mut left: Option<Box<ListNode>>,\\n        right: Option<Box<ListNode>>,\\n        count: usize,\\n    ) -> Option<Box<ListNode>> {\\n        if count == 0 {\\n            None\\n        } else {\\n            match (left.as_mut(), right.as_ref()) {\\n                (None, None) => None,\\n                (Some(_), None) => left,\\n                (None, Some(_)) => right,\\n                (Some(l), Some(_)) => {\\n                    l.next = Self::merge(right, l.next.take(), count - 1);\\n                    left\\n                }\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 577883,
                "title": "go-solution",
                "content": "Runtime: 8 ms, faster than 92.81% of Go online submissions for Reorder List.\\nMemory Usage: 5.4 MB, less than 50.00% of Go online submissions for Reorder List.\\n```\\n/**\\n * Definition for singly-linked list.\\n * type ListNode struct {\\n *     Val int\\n *     Next *ListNode\\n * }\\n */\\nfunc reorderList(head *ListNode)  {\\n    if head == nil || head.Next == nil {\\n        return\\n    }\\n    \\n    slow, fast := head, head\\n    for fast != nil && fast.Next != nil {\\n        slow, fast = slow.Next, fast.Next.Next\\n    }\\n    \\n    var prev *ListNode\\n    for slow != nil {\\n        slow.Next, prev, slow = prev, slow, slow.Next\\n    }\\n    \\n\\n    first := head\\n    for prev.Next != nil{\\n        first.Next, first = prev, first.Next\\n        prev.Next, prev = first, prev.Next\\n    }\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * type ListNode struct {\\n *     Val int\\n *     Next *ListNode\\n * }\\n */\\nfunc reorderList(head *ListNode)  {\\n    if head == nil || head.Next == nil {\\n        return\\n    }\\n    \\n    slow, fast := head, head\\n    for fast != nil && fast.Next != nil {\\n        slow, fast = slow.Next, fast.Next.Next\\n    }\\n    \\n    var prev *ListNode\\n    for slow != nil {\\n        slow.Next, prev, slow = prev, slow, slow.Next\\n    }\\n    \\n\\n    first := head\\n    for prev.Next != nil{\\n        first.Next, first = prev, first.Next\\n        prev.Next, prev = first, prev.Next\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 532261,
                "title": "java-easy-solution-using-arraylist-and-2-pointers",
                "content": "```\\npublic void reorderList(ListNode head) {\\n\\tList<ListNode> l = new ArrayList<>();\\n\\tfor(ListNode iter = head; iter!=null; iter = iter.next)\\n\\t\\tl.add(iter);\\n\\tint lo = 0, hi = l.size()-1;\\n\\tListNode dummy = new ListNode(-1);\\n\\twhile(lo <= hi) {\\n\\t\\tdummy.next = l.get(lo++);\\n\\t\\tdummy = dummy.next;\\n\\t\\tdummy.next = l.get(hi--);\\n\\t\\tdummy = dummy.next;\\n\\t}\\n\\tdummy.next = null;                      // eliminate the cycle\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic void reorderList(ListNode head) {\\n\\tList<ListNode> l = new ArrayList<>();\\n\\tfor(ListNode iter = head; iter!=null; iter = iter.next)\\n\\t\\tl.add(iter);\\n\\tint lo = 0, hi = l.size()-1;\\n\\tListNode dummy = new ListNode(-1);\\n\\twhile(lo <= hi) {\\n\\t\\tdummy.next = l.get(lo++);\\n\\t\\tdummy = dummy.next;\\n\\t\\tdummy.next = l.get(hi--);\\n\\t\\tdummy = dummy.next;\\n\\t}\\n\\tdummy.next = null;                      // eliminate the cycle\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 359829,
                "title": "c-o-n-time-o-1-space-solution",
                "content": "1. First Split the list in half.\\n2. Reverse the second linked list.\\n3. Merge two lists together.\\n\\n```\\nclass Solution {\\npublic:\\n    void reorderList(ListNode* head) {\\n        if(!head) return;\\n        \\n        // Cut the list in half\\n        ListNode* head2 = cutInHalf(head);\\n        \\n        // Reverse the second part of the list\\n        head2 = reverse(head2);\\n        \\n        // Merge two list\\n        merge(head, head2);\\n    }\\n    \\n    ListNode* cutInHalf(ListNode* head) {\\n        ListNode* slow = head;\\n        ListNode* fast = head;\\n        \\n        while(fast->next && fast->next->next) {\\n            slow = slow->next;\\n            fast = fast->next->next;\\n        }\\n        \\n        // Cut in half\\n        ListNode* mid = slow->next;\\n        slow->next = NULL;\\n        \\n        return mid;\\n    }\\n    \\n    ListNode* reverse(ListNode* head) {\\n        if(!head) return NULL;\\n        \\n        ListNode* curr = head;\\n        ListNode* temp = head;\\n        ListNode* prev = NULL;\\n        \\n        while(curr) {\\n            temp = curr->next;\\n            curr->next = prev;\\n            prev = curr;\\n            curr = temp;\\n        }\\n        return prev;\\n    }\\n    \\n    \\n    void merge(ListNode* p, ListNode* q) {\\n        if(!p) return;\\n        if(!q) return;\\n        \\n        while(p && q) {\\n            ListNode* pTemp = p->next;\\n            ListNode* qTemp = q->next;\\n            p->next = q;\\n            p = pTemp;\\n            q->next = p;\\n            q = qTemp;\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void reorderList(ListNode* head) {\\n        if(!head) return;\\n        \\n        // Cut the list in half\\n        ListNode* head2 = cutInHalf(head);\\n        \\n        // Reverse the second part of the list\\n        head2 = reverse(head2);\\n        \\n        // Merge two list\\n        merge(head, head2);\\n    }\\n    \\n    ListNode* cutInHalf(ListNode* head) {\\n        ListNode* slow = head;\\n        ListNode* fast = head;\\n        \\n        while(fast->next && fast->next->next) {\\n            slow = slow->next;\\n            fast = fast->next->next;\\n        }\\n        \\n        // Cut in half\\n        ListNode* mid = slow->next;\\n        slow->next = NULL;\\n        \\n        return mid;\\n    }\\n    \\n    ListNode* reverse(ListNode* head) {\\n        if(!head) return NULL;\\n        \\n        ListNode* curr = head;\\n        ListNode* temp = head;\\n        ListNode* prev = NULL;\\n        \\n        while(curr) {\\n            temp = curr->next;\\n            curr->next = prev;\\n            prev = curr;\\n            curr = temp;\\n        }\\n        return prev;\\n    }\\n    \\n    \\n    void merge(ListNode* p, ListNode* q) {\\n        if(!p) return;\\n        if(!q) return;\\n        \\n        while(p && q) {\\n            ListNode* pTemp = p->next;\\n            ListNode* qTemp = q->next;\\n            p->next = q;\\n            p = pTemp;\\n            q->next = p;\\n            q = qTemp;\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 166490,
                "title": "2ms-recursive-java-solution",
                "content": "```\\nclass Solution {\\n    public void reorderList(ListNode head) {\\n        if (head == null) {\\n            return;\\n        }\\n        \\n        tail(head, head);        \\n    }\\n    \\n    // Performs tail end recursion. Starts inserting nodes into the first half once we find the end. \\n    private ListNode tail(ListNode head, ListNode curr) {\\n        // Recurse until we find the tail\\n        if (curr.next != null) {\\n            head = tail(head, curr.next);\\n        }\\n        \\n        // Insertions complete. Stop\\n        if (head == null) {\\n            return null;\\n        }\\n\\n        ListNode second = head.next;\\n        \\n        // Check to see if we\\'ve reached the end of the new merged linked list\\n        if (head == curr || curr == second) {\\n            // Make sure to terminate the linked list\\n            curr.next = null;\\n            return null;\\n        }\\n        \\n        // Insert node from end (curr) between head and second\\n        // head -> curr -> second\\n        head.next = curr; \\n        curr.next = second;\\n        \\n        // Return where the next insertion should begin\\n        return second;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public void reorderList(ListNode head) {\\n        if (head == null) {\\n            return;\\n        }\\n        \\n        tail(head, head);        \\n    }\\n    \\n    // Performs tail end recursion. Starts inserting nodes into the first half once we find the end. \\n    private ListNode tail(ListNode head, ListNode curr) {\\n        // Recurse until we find the tail\\n        if (curr.next != null) {\\n            head = tail(head, curr.next);\\n        }\\n        \\n        // Insertions complete. Stop\\n        if (head == null) {\\n            return null;\\n        }\\n\\n        ListNode second = head.next;\\n        \\n        // Check to see if we\\'ve reached the end of the new merged linked list\\n        if (head == curr || curr == second) {\\n            // Make sure to terminate the linked list\\n            curr.next = null;\\n            return null;\\n        }\\n        \\n        // Insert node from end (curr) between head and second\\n        // head -> curr -> second\\n        head.next = curr; \\n        curr.next = second;\\n        \\n        // Return where the next insertion should begin\\n        return second;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 45080,
                "title": "accepted-answer-in-java",
                "content": "    /**\\n     * Definition for singly-linked list.\\n     * class ListNode {\\n     *     int val;\\n     *     ListNode next;\\n     *     ListNode(int x) {\\n     *         val = x;\\n     *         next = null;\\n     *     }\\n     * }\\n     */\\n    public class Solution {\\n        \\n        private ListNode start;\\n        \\n        public void reorderList(ListNode head) {\\n            \\n            // 1. find the middle point\\n            if(head == null || head.next == null || head.next.next == null)return;\\n    \\n            ListNode a1 = head, a2 = head;\\n            \\n            while(a2.next!=null){\\n                // a1 step = 1\\n                a1 = a1.next;\\n                // a2 step = 2\\n                a2 = a2.next;\\n                if(a2.next==null)break;\\n                else a2 = a2.next;\\n            }\\n            // a1 now points to middle, a2 points to last elem\\n    \\n            // 2. reverse the second half of the list\\n            this.reverseList(a1);\\n    \\n            // 3. merge two lists\\n            ListNode p = head, t1 = head, t2 = head;\\n            while(a2!=a1){ // start from both side of the list. when a1, a2 meet, the merge finishes.\\n                t1 = p;\\n                t2 = a2;\\n                p = p.next;\\n                a2 = a2.next;\\n                \\n                t2.next = t1.next;\\n                t1.next = t2;\\n            }\\n        }\\n        \\n        // use recursion to reverse the right part of the list\\n        private ListNode reverseList(ListNode n){\\n            \\n            if(n.next == null){\\n                // mark the last node\\n                // this.start = n;\\n                return n;\\n            }\\n            \\n            reverseList(n.next).next = n;\\n            n.next = null;\\n            return n;\\n        }\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n        \\n        private ListNode start;\\n        \\n        public void reorderList(ListNode head) {\\n            \\n            // 1. find the middle point\\n            if(head == null || head.next == null || head.next.next == null)return;\\n    \\n            ListNode a1 = head, a2 = head;\\n            \\n            while(a2.next!=null){\\n                // a1 step = 1\\n                a1 = a1.next;\\n                // a2 step = 2\\n                a2 = a2.next;\\n                if(a2.next==null)break;\\n                else a2 = a2.next;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3071240,
                "title": "c-easy-deque-solution-beats-99-71",
                "content": "\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    void reorderList(ListNode* head) {\\n        deque<ListNode*> q;\\n        ListNode* tmp=head;\\n        while(tmp!=NULL)\\n        {\\n            q.push_back(tmp);\\n            tmp=tmp->next;\\n            q.back()->next=NULL;\\n        }\\n        q.pop_front();\\n        bool f=1;\\n        while(!q.empty())\\n        {\\n            if(!f)\\n            {\\n                head->next=q.front();\\n                q.pop_front();\\n            }\\n            else\\n            {\\n                head->next=q.back();\\n                q.pop_back();\\n            }\\n            head=head->next;\\n            f=!f;\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    void reorderList(ListNode* head) {\\n        deque<ListNode*> q;\\n        ListNode* tmp=head;\\n        while(tmp!=NULL)\\n        {\\n            q.push_back(tmp);\\n            tmp=tmp->next;\\n            q.back()->next=NULL;\\n        }\\n        q.pop_front();\\n        bool f=1;\\n        while(!q.empty())\\n        {\\n            if(!f)\\n            {\\n                head->next=q.front();\\n                q.pop_front();\\n            }\\n            else\\n            {\\n                head->next=q.back();\\n                q.pop_back();\\n            }\\n            head=head->next;\\n            f=!f;\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2736247,
                "title": "c-code-with-proper-explanation-diagram",
                "content": "![image](https://assets.leetcode.com/users/images/9b3f7f91-f7fd-4046-832e-a9967a3cec55_1666537832.3092754.png)\\n\\n\\nHere is full explanation of the code i think you guys like these and plz upvote this !\\n\\nclass Solution {\\npublic:\\n    ListNode* getmid(ListNode* &head)\\n    {\\n        ListNode* slow = head;\\n        ListNode* fast = head;\\n        while(fast  != NULL && fast -> next != NULL)\\n        {\\n            slow = slow -> next;\\n            fast = fast -> next -> next;\\n        }\\n        return slow;\\n    }\\n    ListNode* reverse(ListNode* head)\\n    {\\n        ListNode* prev = NULL;\\n        ListNode* curr = head;\\n        ListNode* forward = NULL;\\n        while(curr  != NULL)\\n        {\\n            forward = curr -> next;\\n            curr -> next = prev;\\n            prev = curr;\\n            curr = forward;\\n        }\\n        return prev;\\n    }\\n    void reorderList(ListNode* head) {\\n        if(head == NULL || head -> next == NULL)return;\\n        // find the mid of the linked list\\n        ListNode* mid = getmid(head); \\n        ListNode* l1 = head;\\n        ListNode* l2 = (mid -> next);\\n        mid -> next = NULL;\\n        l2 = reverse(l2);\\n        \\n        while( l2 != NULL)\\n        {\\n            ListNode* f1 =l1 -> next;\\n        ListNode* f2 = l2 -> next;\\n            l1 -> next = l2;\\n            l2 -> next = f1;\\n            l1 = f1;\\n            l2 = f2;\\n            \\n        }\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    ListNode* getmid(ListNode* &head)\\n    {\\n        ListNode* slow = head;\\n        ListNode* fast = head;\\n        while(fast  != NULL && fast -> next != NULL)\\n        {\\n            slow = slow -> next;\\n            fast = fast -> next -> next;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2194971,
                "title": "c-solution-recursive-approch-short-code-using-stack-frame-of-recursion",
                "content": "In this problem, the basic idea I have used is that we will use the **stack frame of each recursive stage**.\\n\\nHere we are doing all thing while returnning from the last node.\\n\\nHere we will 1st recursivelly traverse to the end of the list then connect first element with last element and last element with 2ndnelement. So, 1st-->last-->2nd this will be our new pattern and we are still on the last stack frame of recursive stack, from here we will return 3rd node which is named as 2nd here(I will use \"2nd\" name here ) . Now we wiil be on the 2nd last stack frame of recursion, now we will connect 2nd with with 2nd last node now again we repeat above steps untill :-\\n1.)curr node(from start)become NULL or\\n2.) curr node (from start) and temp (node from current stack frame) are equal or \\n3.)current->next == temp.\\n\\nLets take an :-\\n![image](https://assets.leetcode.com/users/images/30824bf7-bd6a-4f0a-9a71-f0e1eced8ff7_1656154953.5404239.jpeg)\\n\\n\\t*If you find it helpful then upvote pls..*\\n\\n```\\nListNode *sol(ListNode *head, ListNode *temp)\\n    {\\n        if(temp == NULL)return head;\\n        \\n        ListNode *curr = sol(head, temp->next);\\n        \\n        if(!curr)return NULL;\\n        if(curr==temp){\\n            curr->next = NULL;\\n            return NULL;\\n        }\\n        if(curr->next == temp)\\n        {\\n            temp->next=NULL;\\n            return NULL;\\n        }\\n        \\n        temp->next = curr->next;\\n        curr->next = temp;\\n        curr = temp->next;\\n        \\n        return curr;\\n    }\\n    void reorderList(ListNode* head) {\\n        sol(head, head);\\n    }\\n\\t\\n",
                "solutionTags": [
                    "C",
                    "Linked List",
                    "Recursion"
                ],
                "code": "In this problem, the basic idea I have used is that we will use the **stack frame of each recursive stage**.\\n\\nHere we are doing all thing while returnning from the last node.\\n\\nHere we will 1st recursivelly traverse to the end of the list then connect first element with last element and last element with 2ndnelement. So, 1st-->last-->2nd this will be our new pattern and we are still on the last stack frame of recursive stack, from here we will return 3rd node which is named as 2nd here(I will use \"2nd\" name here ) . Now we wiil be on the 2nd last stack frame of recursion, now we will connect 2nd with with 2nd last node now again we repeat above steps untill :-\\n1.)curr node(from start)become NULL or\\n2.) curr node (from start) and temp (node from current stack frame) are equal or \\n3.)current->next == temp.\\n\\nLets take an :-\\n![image](https://assets.leetcode.com/users/images/30824bf7-bd6a-4f0a-9a71-f0e1eced8ff7_1656154953.5404239.jpeg)\\n\\n\\t*If you find it helpful then upvote pls..*\\n\\n```\\nListNode *sol(ListNode *head, ListNode *temp)\\n    {\\n        if(temp == NULL)return head;\\n        \\n        ListNode *curr = sol(head, temp->next);\\n        \\n        if(!curr)return NULL;\\n        if(curr==temp){\\n            curr->next = NULL;\\n            return NULL;\\n        }\\n        if(curr->next == temp)\\n        {\\n            temp->next=NULL;\\n            return NULL;\\n        }\\n        \\n        temp->next = curr->next;\\n        curr->next = temp;\\n        curr = temp->next;\\n        \\n        return curr;\\n    }\\n    void reorderList(ListNode* head) {\\n        sol(head, head);\\n    }\\n\\t\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 2132536,
                "title": "java-o-n-time-o-1-space",
                "content": "```\\nclass Solution {\\n    \\n    public static ListNode middleOfLL(ListNode head){\\n        if(head==null){\\n            return head;\\n        }\\n\\n        ListNode slow = head;\\n        ListNode fast = head;\\n\\n        while(fast.next!=null && fast.next.next!=null){\\n            slow = slow.next;\\n            fast = fast.next.next;\\n        }\\n\\n        return slow;\\n\\n    }\\n\\n    public static ListNode reverseOfLL(ListNode head){\\n        ListNode prev = null;\\n        ListNode curr = head;\\n\\n        while(curr!=null){\\n            //preserve\\n            ListNode next = curr.next;            \\n\\n            //link;\\n            curr.next = prev;\\n            \\n            //move\\n            prev = curr; \\n            curr = next;\\n        }\\n\\n        return prev;\\n    }\\n    \\n    \\n    public void reorderList(ListNode head) {\\n        \\n        ListNode mid = middleOfLL(head);\\n        ListNode nh = mid.next;\\n\\n        mid.next = null;  //break link\\n\\n        nh = reverseOfLL(nh);\\n\\n        ListNode p1 = head;\\n        ListNode p2 = nh;\\n\\n        while(p2!=null){\\n            //preserve\\n            ListNode n1 = p1.next;\\n            ListNode n2 = p2.next;\\n\\n            //link;\\n            p1.next = p2;\\n            p2.next = n1;\\n\\n            //move\\n            p1 = n1;\\n            p2 = n2;\\n        \\n        }   \\n\\n    }\\n    \\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Linked List"
                ],
                "code": "```\\nclass Solution {\\n    \\n    public static ListNode middleOfLL(ListNode head){\\n        if(head==null){\\n            return head;\\n        }\\n\\n        ListNode slow = head;\\n        ListNode fast = head;\\n\\n        while(fast.next!=null && fast.next.next!=null){\\n            slow = slow.next;\\n            fast = fast.next.next;\\n        }\\n\\n        return slow;\\n\\n    }\\n\\n    public static ListNode reverseOfLL(ListNode head){\\n        ListNode prev = null;\\n        ListNode curr = head;\\n\\n        while(curr!=null){\\n            //preserve\\n            ListNode next = curr.next;            \\n\\n            //link;\\n            curr.next = prev;\\n            \\n            //move\\n            prev = curr; \\n            curr = next;\\n        }\\n\\n        return prev;\\n    }\\n    \\n    \\n    public void reorderList(ListNode head) {\\n        \\n        ListNode mid = middleOfLL(head);\\n        ListNode nh = mid.next;\\n\\n        mid.next = null;  //break link\\n\\n        nh = reverseOfLL(nh);\\n\\n        ListNode p1 = head;\\n        ListNode p2 = nh;\\n\\n        while(p2!=null){\\n            //preserve\\n            ListNode n1 = p1.next;\\n            ListNode n2 = p2.next;\\n\\n            //link;\\n            p1.next = p2;\\n            p2.next = n1;\\n\\n            //move\\n            p1 = n1;\\n            p2 = n2;\\n        \\n        }   \\n\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1641048,
                "title": "c-easy-solution-explanation-half-reverse-merge",
                "content": "At first we define some basic function ```len()``` , ```at()```.\\n\\n* `len()` will return the length of the linked list:\\n\\t```cpp\\n\\tint len(ListNode* head) {\\n\\t\\tint c = 0;\\n\\t\\tfor (; head; head = head->next, c++);\\n\\t\\treturn c;\\n\\t}\\n\\t```\\n* `at()` will give you the address of `i-th` index of a linked list:\\n\\t```cpp\\n\\tListNode* at(ListNode* head, int i) {\\n\\t\\tfor (; i--; head = head->next);\\n\\t\\treturn head;\\n\\t}\\n\\t```\\n* now make a function `half()` that will split the array into half and retun the head of that two list:\\n\\t```cpp\\n\\tpair<ListNode*, ListNode*> half(ListNode* head) {\\n\\t\\tif (!head) return {0, 0};\\n\\t\\tListNode *m = at(head, (len(head) - 1) / 2), *y = m->next;\\n\\t\\tm->next = 0;\\n\\t\\treturn {head, y};\\n\\t}\\n\\t```\\n* make a function `reverse()` that will reverse a linked-list [here i write an easy recursion, the function will return the head and tail of the reversed linked list]:\\n\\t```cpp\\n\\tpair<ListNode*, ListNode*> reverse(ListNode* head) {\\n\\t\\tif (!head)return {0, 0};\\n\\t\\tif (!head -> next) return {head, head};\\n\\t\\tauto [x, y] = reverse(head -> next);\\n\\t\\ty -> next = head;\\n\\t\\thead -> next = 0;\\n\\t\\treturn {x, head};\\n\\t}\\n\\t```\\n* make a `merge()` function to merge two linked list [i.e: x0 -> x1 -> x2 -> ... + y0 -> y1 -> y2 -> ... = x0 -> y0 -> x1 -> y1 -> ...]:\\n\\t```cpp\\n\\tListNode* merge(ListNode *x, ListNode *y) {\\n\\t\\tif (!x || !y) return x ? x : y;\\n\\t\\ty = merge(y, x -> next);\\n\\t\\tx -> next = y;\\n\\t\\treturn x;\\n\\t}\\n\\t```\\n* Now to **reorderList** you can just `half()` + `reverse()` + `merge()` :\\n\\t``` cpp\\n\\tvoid reorderList(ListNode* head) {\\n\\t\\tauto [x, y] = half(head);\\n\\t\\ty = reverse(y).first;\\n\\t\\tmerge(x, y);\\n\\t}\\n\\t```\\n\\t\\n\\t\\n\\tFull solution:\\n\\t```cpp\\n\\t/**\\n\\t * Definition for singly-linked list.\\n\\t * struct ListNode {\\n\\t *     int val;\\n\\t *     ListNode *next;\\n\\t *     ListNode() : val(0), next(nullptr) {}\\n\\t *     ListNode(int x) : val(x), next(nullptr) {}\\n\\t *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n\\t * };\\n\\t */\\n\\tclass Solution {\\n\\t\\tint len(ListNode* head) {\\n\\t\\t\\tint c = 0;\\n\\t\\t\\tfor (; head; head = head->next, c++);\\n\\t\\t\\treturn c;\\n\\t\\t}\\n\\t\\tListNode* at(ListNode* head, int i) {\\n\\t\\t\\tfor (; i--; head = head->next);\\n\\t\\t\\treturn head;\\n\\t\\t}\\n\\t\\tpair<ListNode*, ListNode*> half(ListNode* head) {\\n\\t\\t\\tif (!head) return {0, 0};\\n\\t\\t\\tListNode *m = at(head, (len(head) - 1) / 2), *y = m->next;\\n\\t\\t\\tm->next = 0;\\n\\t\\t\\treturn {head, y};\\n\\t\\t}\\n\\t\\tpair<ListNode*, ListNode*> reverse(ListNode* head) {\\n\\t\\t\\tif (!head)return {0, 0};\\n\\t\\t\\tif (!head -> next) return {head, head};\\n\\t\\t\\tauto [x, y] = reverse(head -> next);\\n\\t\\t\\ty -> next = head;\\n\\t\\t\\thead -> next = 0;\\n\\t\\t\\treturn {x, head};\\n\\t\\t}\\n\\t\\tListNode* merge(ListNode *x, ListNode *y) {\\n\\t\\t\\tif (!x || !y) return x ? x : y;\\n\\t\\t\\ty = merge(y, x -> next);\\n\\t\\t\\tx -> next = y;\\n\\t\\t\\treturn x;\\n\\t\\t}\\n\\tpublic:\\n\\t\\tvoid reorderList(ListNode* head) {\\n\\t\\t\\tauto [x, y] = half(head);\\n\\t\\t\\ty = reverse(y).first;\\n\\t\\t\\thead = merge(x, y);\\n\\t\\t}\\n\\t};\\n\\t```\\n\\t\\n\\t\\n\\tNow its time to upvote my solution ^_^ \\n",
                "solutionTags": [
                    "Linked List"
                ],
                "code": "```len()```\n```at()```\n```cpp\\n\\tint len(ListNode* head) {\\n\\t\\tint c = 0;\\n\\t\\tfor (; head; head = head->next, c++);\\n\\t\\treturn c;\\n\\t}\\n\\t```\n```cpp\\n\\tListNode* at(ListNode* head, int i) {\\n\\t\\tfor (; i--; head = head->next);\\n\\t\\treturn head;\\n\\t}\\n\\t```\n```cpp\\n\\tpair<ListNode*, ListNode*> half(ListNode* head) {\\n\\t\\tif (!head) return {0, 0};\\n\\t\\tListNode *m = at(head, (len(head) - 1) / 2), *y = m->next;\\n\\t\\tm->next = 0;\\n\\t\\treturn {head, y};\\n\\t}\\n\\t```\n```cpp\\n\\tpair<ListNode*, ListNode*> reverse(ListNode* head) {\\n\\t\\tif (!head)return {0, 0};\\n\\t\\tif (!head -> next) return {head, head};\\n\\t\\tauto [x, y] = reverse(head -> next);\\n\\t\\ty -> next = head;\\n\\t\\thead -> next = 0;\\n\\t\\treturn {x, head};\\n\\t}\\n\\t```\n```cpp\\n\\tListNode* merge(ListNode *x, ListNode *y) {\\n\\t\\tif (!x || !y) return x ? x : y;\\n\\t\\ty = merge(y, x -> next);\\n\\t\\tx -> next = y;\\n\\t\\treturn x;\\n\\t}\\n\\t```\n``` cpp\\n\\tvoid reorderList(ListNode* head) {\\n\\t\\tauto [x, y] = half(head);\\n\\t\\ty = reverse(y).first;\\n\\t\\tmerge(x, y);\\n\\t}\\n\\t```\n```cpp\\n\\t/**\\n\\t * Definition for singly-linked list.\\n\\t * struct ListNode {\\n\\t *     int val;\\n\\t *     ListNode *next;\\n\\t *     ListNode() : val(0), next(nullptr) {}\\n\\t *     ListNode(int x) : val(x), next(nullptr) {}\\n\\t *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n\\t * };\\n\\t */\\n\\tclass Solution {\\n\\t\\tint len(ListNode* head) {\\n\\t\\t\\tint c = 0;\\n\\t\\t\\tfor (; head; head = head->next, c++);\\n\\t\\t\\treturn c;\\n\\t\\t}\\n\\t\\tListNode* at(ListNode* head, int i) {\\n\\t\\t\\tfor (; i--; head = head->next);\\n\\t\\t\\treturn head;\\n\\t\\t}\\n\\t\\tpair<ListNode*, ListNode*> half(ListNode* head) {\\n\\t\\t\\tif (!head) return {0, 0};\\n\\t\\t\\tListNode *m = at(head, (len(head) - 1) / 2), *y = m->next;\\n\\t\\t\\tm->next = 0;\\n\\t\\t\\treturn {head, y};\\n\\t\\t}\\n\\t\\tpair<ListNode*, ListNode*> reverse(ListNode* head) {\\n\\t\\t\\tif (!head)return {0, 0};\\n\\t\\t\\tif (!head -> next) return {head, head};\\n\\t\\t\\tauto [x, y] = reverse(head -> next);\\n\\t\\t\\ty -> next = head;\\n\\t\\t\\thead -> next = 0;\\n\\t\\t\\treturn {x, head};\\n\\t\\t}\\n\\t\\tListNode* merge(ListNode *x, ListNode *y) {\\n\\t\\t\\tif (!x || !y) return x ? x : y;\\n\\t\\t\\ty = merge(y, x -> next);\\n\\t\\t\\tx -> next = y;\\n\\t\\t\\treturn x;\\n\\t\\t}\\n\\tpublic:\\n\\t\\tvoid reorderList(ListNode* head) {\\n\\t\\t\\tauto [x, y] = half(head);\\n\\t\\t\\ty = reverse(y).first;\\n\\t\\t\\thead = merge(x, y);\\n\\t\\t}\\n\\t};\\n\\t```",
                "codeTag": "Java"
            },
            {
                "id": 1487975,
                "title": "rust-itertaive-in-place-re-ordering-with-o-1-additional-space",
                "content": "\\n```rust\\nuse std::hint::unreachable_unchecked;\\n\\npub fn reorder_list(head: &mut Option<Box<ListNode>>) {\\n    // Find how many nodes are in the list;\\n    let mut count = 0;\\n    let mut list = &*head;\\n\\n    while let Some(node) = list {\\n        list = &node.next;\\n        count += 1;\\n    }\\n\\n    // If there are less than two nodes, then there is nothing to do\\n    if count <= 2 {\\n        return;\\n    }\\n\\n    // Reach the middle of the list in order to split in to two lists\\n    let mut half = head.as_mut();\\n    for _ in 0..count / 2 {\\n        match half {\\n            // SAFETY: we have counted the number of nodes, so we know there are more nodes\\n            None => unsafe { unreachable_unchecked() },\\n            Some(node) => {\\n                half = node.next.as_mut();\\n            }\\n        }\\n    }\\n\\n    // Reverse the second half\\n    let mut half = match half {\\n        // SAFETY: we have counted the number of nodes, so we know there are more nodes\\n        None => unsafe { unreachable_unchecked() },\\n        Some(node) => node.next.take(),\\n    };\\n\\n    let mut reversed = ListNode::new(0);\\n    while let Some(mut node) = half.take() {\\n        half = node.next.take();\\n        node.next = reversed.next.take();\\n        reversed.next = Some(node);\\n    }\\n\\n    // merge the two lists, tail points to the node in the first list\\n    // that has to be disconnected in order to put a node from the reversed\\n    // list in its place. Then it\\'s reattached as \"next\" of the new node\\n    let mut tail = match head.as_mut() {\\n        // SAFETY: we know there is node at HEAD\\n        None => unsafe { unreachable_unchecked() },\\n        Some(node) => &mut node.next,\\n    };\\n\\n    while tail.is_some() && reversed.next.is_some() {\\n        // SAFETY: We know there is a reversed.next because we already checked it\\n        let mut rev = reversed.next.take().unwrap();\\n        reversed.next = rev.next.take();\\n\\n        rev.next = tail.take();\\n        *tail = Some(rev);\\n        tail = &mut tail.as_mut().unwrap().next;\\n        if let Some(node) = tail {\\n            tail = &mut node.next;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```rust\\nuse std::hint::unreachable_unchecked;\\n\\npub fn reorder_list(head: &mut Option<Box<ListNode>>) {\\n    // Find how many nodes are in the list;\\n    let mut count = 0;\\n    let mut list = &*head;\\n\\n    while let Some(node) = list {\\n        list = &node.next;\\n        count += 1;\\n    }\\n\\n    // If there are less than two nodes, then there is nothing to do\\n    if count <= 2 {\\n        return;\\n    }\\n\\n    // Reach the middle of the list in order to split in to two lists\\n    let mut half = head.as_mut();\\n    for _ in 0..count / 2 {\\n        match half {\\n            // SAFETY: we have counted the number of nodes, so we know there are more nodes\\n            None => unsafe { unreachable_unchecked() },\\n            Some(node) => {\\n                half = node.next.as_mut();\\n            }\\n        }\\n    }\\n\\n    // Reverse the second half\\n    let mut half = match half {\\n        // SAFETY: we have counted the number of nodes, so we know there are more nodes\\n        None => unsafe { unreachable_unchecked() },\\n        Some(node) => node.next.take(),\\n    };\\n\\n    let mut reversed = ListNode::new(0);\\n    while let Some(mut node) = half.take() {\\n        half = node.next.take();\\n        node.next = reversed.next.take();\\n        reversed.next = Some(node);\\n    }\\n\\n    // merge the two lists, tail points to the node in the first list\\n    // that has to be disconnected in order to put a node from the reversed\\n    // list in its place. Then it\\'s reattached as \"next\" of the new node\\n    let mut tail = match head.as_mut() {\\n        // SAFETY: we know there is node at HEAD\\n        None => unsafe { unreachable_unchecked() },\\n        Some(node) => &mut node.next,\\n    };\\n\\n    while tail.is_some() && reversed.next.is_some() {\\n        // SAFETY: We know there is a reversed.next because we already checked it\\n        let mut rev = reversed.next.take().unwrap();\\n        reversed.next = rev.next.take();\\n\\n        rev.next = tail.take();\\n        *tail = Some(rev);\\n        tail = &mut tail.as_mut().unwrap().next;\\n        if let Some(node) = tail {\\n            tail = &mut node.next;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 802161,
                "title": "python-simple-solution-explained-video-code",
                "content": "https://www.youtube.com/watch?v=To_uAJRu8NQ\\n[](https://www.youtube.com/watch?v=To_uAJRu8NQ)\\n```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nfrom collections import deque\\nclass Solution:\\n    def reorderList(self, head: ListNode) -> None:\\n        \"\"\"\\n        Do not return anything, modify head in-place instead.\\n        \"\"\"\\n        if not head:\\n            return\\n        \\n        q = deque()\\n        node = head\\n        while True:\\n            node = node.next\\n            if not node:\\n                break\\n            q.append(node)\\n        \\n        while q:\\n            if head:\\n                temp = q.pop()\\n                head.next = temp\\n                head = head.next\\n            \\n            if head and q:\\n                temp = q.popleft()\\n                head.next = temp\\n                head = head.next\\n                \\n        head.next = None\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Linked List"
                ],
                "code": "```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nfrom collections import deque\\nclass Solution:\\n    def reorderList(self, head: ListNode) -> None:\\n        \"\"\"\\n        Do not return anything, modify head in-place instead.\\n        \"\"\"\\n        if not head:\\n            return\\n        \\n        q = deque()\\n        node = head\\n        while True:\\n            node = node.next\\n            if not node:\\n                break\\n            q.append(node)\\n        \\n        while q:\\n            if head:\\n                temp = q.pop()\\n                head.next = temp\\n                head = head.next\\n            \\n            if head and q:\\n                temp = q.popleft()\\n                head.next = temp\\n                head = head.next\\n                \\n        head.next = None\\n```",
                "codeTag": "Java"
            },
            {
                "id": 403371,
                "title": "concise-and-straightforward-python-solution-find-mid-reverse-merge",
                "content": "```\\nclass Solution:\\n    def reorderList(self, head: ListNode) -> None:\\n        if not head:\\n            return head\\n        \\n        # find mid point \\n        slow = fast = head\\n        \\n        while fast and fast.next:\\n            slow = slow.next\\n            fast = fast.next.next\\n        \\n        # reverse the second half in-place\\n        # slow.next: the start point of reverse\\n        \\n        head2 = None\\n\\t\\tcurr = slow.next\\n\\t\\tslow.next = None\\n        while slow.next:\\n            next = curr.next\\n            curr.next = head2\\n            head2 = curr\\n            curr = next\\n        \\n        # merge in-place\\n        first, second = head, head2\\n        \\n        while second:\\n            first.next, first = second, first.next\\n            second.next, second = first, second.next\\n        return\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def reorderList(self, head: ListNode) -> None:\\n        if not head:\\n            return head\\n        \\n        # find mid point \\n        slow = fast = head\\n        \\n        while fast and fast.next:\\n            slow = slow.next\\n            fast = fast.next.next\\n        \\n        # reverse the second half in-place\\n        # slow.next: the start point of reverse\\n        \\n        head2 = None\\n\\t\\tcurr = slow.next\\n\\t\\tslow.next = None\\n        while slow.next:\\n            next = curr.next\\n            curr.next = head2\\n            head2 = curr\\n            curr = next\\n        \\n        # merge in-place\\n        first, second = head, head2\\n        \\n        while second:\\n            first.next, first = second, first.next\\n            second.next, second = first, second.next\\n        return\\n```",
                "codeTag": "Java"
            },
            {
                "id": 264397,
                "title": "cpp-solution-using-a-stack-and-a-queue",
                "content": "```c++\\nvoid reorderList(ListNode* head) {\\n    stack<ListNode*> s;\\n    queue<ListNode*> q;\\n    int len = 0, count = 0;\\n    ListNode dummyHead(0);\\n    ListNode *p = head;\\n    while(p){\\n        s.push(p);\\n        q.push(p);\\n        p = p->next;\\n        len++;\\n    }\\n    p = &dummyHead;\\n    while(count < len){\\n        p->next = q.front();\\n        q.front()->next = s.top();\\n        p = s.top();\\n        q.pop();\\n        s.pop();\\n        count += 2;\\n    }\\n    p->next = NULL;\\n}\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```c++\\nvoid reorderList(ListNode* head) {\\n    stack<ListNode*> s;\\n    queue<ListNode*> q;\\n    int len = 0, count = 0;\\n    ListNode dummyHead(0);\\n    ListNode *p = head;\\n    while(p){\\n        s.push(p);\\n        q.push(p);\\n        p = p->next;\\n        len++;\\n    }\\n    p = &dummyHead;\\n    while(count < len){\\n        p->next = q.front();\\n        q.front()->next = s.top();\\n        p = s.top();\\n        q.pop();\\n        s.pop();\\n        count += 2;\\n    }\\n    p->next = NULL;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 143710,
                "title": "my-python-solution-with-some-comments-o-1-space-easy-to-understand",
                "content": "```\\nclass Solution:\\n    def reorderList(self, head):\\n        \"\"\"\\n        :type head: ListNode\\n        :rtype: void Do not return anything, modify head in-place instead.\\n        \"\"\"\\n        if head and head.next and head.next.next:   #check if the list has two more nodes\\n            \\n            # partition the nodes into two parts\\n            pre, slow, fast = ListNode(None), head, head\\n            while fast and fast.next:\\n                pre, slow, fast = slow, slow.next, fast.next.next\\n            pre.next = None\\n            \\n            # reverse the second half\\n            temp = None\\n            while slow:\\n                nxt = slow.next\\n                slow.next = temp\\n                temp = slow\\n                slow = nxt\\n                \\n            # reorder two parts\\n            dummy = head\\n            while dummy and temp:\\n                nxt= dummy.next\\n                dummy.next,dummy,temp = temp, temp, nxt\\n```\\nInput: [1,2,3,4,5,6]\\nStep 1: partition the input into two parts -- head: [1,2,3], slow: [4,5,6]\\nStep 2: reverse slow, temp: [6,5,4]\\nStep 3: at the first node of head, temp is inserted. then head.next is inserted, etc.",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def reorderList(self, head):\\n        \"\"\"\\n        :type head: ListNode\\n        :rtype: void Do not return anything, modify head in-place instead.\\n        \"\"\"\\n        if head and head.next and head.next.next:   #check if the list has two more nodes\\n            \\n            # partition the nodes into two parts\\n            pre, slow, fast = ListNode(None), head, head\\n            while fast and fast.next:\\n                pre, slow, fast = slow, slow.next, fast.next.next\\n            pre.next = None\\n            \\n            # reverse the second half\\n            temp = None\\n            while slow:\\n                nxt = slow.next\\n                slow.next = temp\\n                temp = slow\\n                slow = nxt\\n                \\n            # reorder two parts\\n            dummy = head\\n            while dummy and temp:\\n                nxt= dummy.next\\n                dummy.next,dummy,temp = temp, temp, nxt\\n```",
                "codeTag": "Java"
            },
            {
                "id": 45218,
                "title": "my-java-solution-with-a-hashmap",
                "content": "     public void reorderList(ListNode head) {\\n    \\t        \\n    \\t    HashMap <Integer,ListNode> nodeMap = new HashMap<Integer,ListNode> ();\\n    \\t    int len = 0 ;\\n    \\t    ListNode p = head ; \\n    \\t    \\n    \\t    while (p != null) {\\n    \\t    \\tnodeMap.put(len++, p);\\n    \\t    \\tp = p.next ;\\n    \\t    }\\n    \\t   \\n    \\t    \\n    \\t    int i = 0 ; \\n    \\t    int j = len - 1 ;\\n    \\t    for (; i < j - 1 ; ++i ,--j) {\\t    \\t\\n    \\t    \\tListNode tmp = nodeMap.get(i).next ;\\n    \\t    \\tnodeMap.get(i).next = nodeMap.get(j);\\n    \\t    \\tnodeMap.get(j).next = tmp ;\\n    \\t    \\tnodeMap.get(j - 1).next = null;\\n    \\t    \\t\\n    \\t    }",
                "solutionTags": [],
                "code": "     public void reorderList(ListNode head) {\\n    \\t        \\n    \\t    HashMap <Integer,ListNode> nodeMap = new HashMap<Integer,ListNode> ();\\n    \\t    int len = 0 ;\\n    \\t    ListNode p = head ; \\n    \\t    \\n    \\t    while (p != null) {\\n    \\t    \\tnodeMap.put(len++, p);\\n    \\t    \\tp = p.next ;\\n    \\t    }\\n    \\t   \\n    \\t    \\n    \\t    int i = 0 ; \\n    \\t    int j = len - 1 ;\\n    \\t    for (; i < j - 1 ; ++i ,--j) {\\t    \\t\\n    \\t    \\tListNode tmp = nodeMap.get(i).next ;\\n    \\t    \\tnodeMap.get(i).next = nodeMap.get(j);\\n    \\t    \\tnodeMap.get(j).next = tmp ;\\n    \\t    \\tnodeMap.get(j - 1).next = null;\\n    \\t    \\t\\n    \\t    }",
                "codeTag": "Unknown"
            },
            {
                "id": 4079692,
                "title": "best-o-n-solution",
                "content": "# Approach\\nUsing Stack\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    void reorderList(ListNode* head) {\\n        int size = 0;\\n        ListNode* dummy = head;\\n        stack <ListNode*> nodes;\\n        while (dummy != NULL) {\\n            nodes.push(dummy);\\n            size++;\\n            dummy = dummy->next;\\n        }\\n        dummy = head;\\n        for (int i = 0; i < size / 2; i++) {\\n            ListNode* temp = dummy->next;\\n            dummy->next = nodes.top();\\n            nodes.pop();\\n            dummy = dummy->next;\\n            dummy->next = temp;\\n            dummy = temp;\\n        }\\n        dummy->next = NULL;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    void reorderList(ListNode* head) {\\n        int size = 0;\\n        ListNode* dummy = head;\\n        stack <ListNode*> nodes;\\n        while (dummy != NULL) {\\n            nodes.push(dummy);\\n            size++;\\n            dummy = dummy->next;\\n        }\\n        dummy = head;\\n        for (int i = 0; i < size / 2; i++) {\\n            ListNode* temp = dummy->next;\\n            dummy->next = nodes.top();\\n            nodes.pop();\\n            dummy = dummy->next;\\n            dummy->next = temp;\\n            dummy = temp;\\n        }\\n        dummy->next = NULL;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3886310,
                "title": "3-solutions-with-stack-without-stack-and-recursion-solutions-beats-100",
                "content": "# Code\\n```\\n// Solution 1 - Without stack\\nclass Solution {\\npublic:\\n    // Function to reverse the LL\\n    ListNode *reverse(ListNode *head){\\n        ListNode *curr = head, *prev = NULL, *forward = NULL;\\n        while(curr != NULL){\\n            forward = curr->next;\\n            curr->next = prev;\\n            prev = curr;\\n            curr = forward;\\n        }\\n        return prev;\\n    }\\n\\n    void reorderList(ListNode* head) {\\n        // Check for edge cases\\n        if(head->next == NULL || head->next->next == NULL)\\n            return;\\n\\n        // Step 1 - Find middle of the LL with slow-fast pointer approach\\n        ListNode *slow = head, *fast = head, *slow_prev = NULL;\\n        while(fast != NULL && fast->next != NULL){\\n            slow_prev = slow;\\n            slow = slow->next;\\n            fast = fast->next->next;\\n        }\\n\\n        // Step 2 - Split the LL into 2 parts from the middle \\n        // and reverse the second part\\n        ListNode *h1 = head, *h2;\\n        if(fast == NULL){\\n            h2 = reverse(slow);\\n            slow_prev->next = NULL;\\n        }\\n        else{\\n            h2 = reverse(slow->next);\\n            slow->next = NULL;\\n        }\\n        \\n        // Traverse both the LL while linking heads of both LL\\n        ListNode *next1 = h1->next, *next2 = h2->next;\\n        while(h1 != NULL && h2 != NULL){\\n            next1 = h1->next;\\n            next2 = h2->next;\\n\\n            h1->next = h2;\\n            h2->next = next1;\\n\\n            h1 = next1;\\n            h2 = next2;\\n        }\\n    }\\n};\\n\\n// Solution 2 - With stack\\nclass Solution {\\npublic:\\n    void reorderList(ListNode* head) {\\n        // base case\\n        if(head->next == NULL || head->next->next == NULL) \\n            return ;\\n        \\n        // Step 1 - Find middle of the LL with slow-fast pointer approach\\n        ListNode* slow= head,  *fast= head;\\n        stack<ListNode*> st;\\n        while(fast!=NULL && fast->next!=NULL){\\n            slow= slow->next;\\n            fast = fast->next->next;\\n        }\\n        \\n        // Step 2 - Split the LL into 2 parts from the middle\\n        ListNode* h2;\\n        if(fast != NULL)\\n            h2 = slow->next;    \\n        else \\n            h2 = slow;\\n        \\n        // Step 3 - Push the second LL into a stack so that the last element remains at top\\n        while(h2!=NULL){\\n            st.push(h2);\\n            h2 = h2->next;  \\n        }\\n        fast = head;\\n        \\n        // Step 4 - Link the first node with the last node and then pop the stack\\n        while(st.size()){ \\n            h2 = fast->next; \\n            fast->next = st.top();\\n            st.top()->next = h2;\\n            fast = h2;\\n            st.pop();    \\n        }\\n\\n        slow->next = NULL;\\n    }\\n};\\n\\n// Solution 3 - Recursion\\nclass Solution {\\npublic:\\n    void reorderList(ListNode* head) {\\n        //base case\\n        if(head!=NULL || head->next!=NULL || !head->next->next!= NULL) \\n            return;\\n        \\n        //Find the penultimate node i.e second last node of the linkedlist\\n        ListNode* penultimate = head;\\n        while (penultimate->next->next) \\n            penultimate = penultimate->next;\\n        \\n        // Link the penultimate node with the second node\\n        penultimate->next->next = head->next;\\n        head->next = penultimate->next;\\n        \\n        // Set the penultimate to the the last \\n        penultimate->next = NULL;\\n        \\n        // Recursive call\\n        reorderList(head->next->next);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Linked List",
                    "Two Pointers",
                    "Stack",
                    "Recursion"
                ],
                "code": "```\\n// Solution 1 - Without stack\\nclass Solution {\\npublic:\\n    // Function to reverse the LL\\n    ListNode *reverse(ListNode *head){\\n        ListNode *curr = head, *prev = NULL, *forward = NULL;\\n        while(curr != NULL){\\n            forward = curr->next;\\n            curr->next = prev;\\n            prev = curr;\\n            curr = forward;\\n        }\\n        return prev;\\n    }\\n\\n    void reorderList(ListNode* head) {\\n        // Check for edge cases\\n        if(head->next == NULL || head->next->next == NULL)\\n            return;\\n\\n        // Step 1 - Find middle of the LL with slow-fast pointer approach\\n        ListNode *slow = head, *fast = head, *slow_prev = NULL;\\n        while(fast != NULL && fast->next != NULL){\\n            slow_prev = slow;\\n            slow = slow->next;\\n            fast = fast->next->next;\\n        }\\n\\n        // Step 2 - Split the LL into 2 parts from the middle \\n        // and reverse the second part\\n        ListNode *h1 = head, *h2;\\n        if(fast == NULL){\\n            h2 = reverse(slow);\\n            slow_prev->next = NULL;\\n        }\\n        else{\\n            h2 = reverse(slow->next);\\n            slow->next = NULL;\\n        }\\n        \\n        // Traverse both the LL while linking heads of both LL\\n        ListNode *next1 = h1->next, *next2 = h2->next;\\n        while(h1 != NULL && h2 != NULL){\\n            next1 = h1->next;\\n            next2 = h2->next;\\n\\n            h1->next = h2;\\n            h2->next = next1;\\n\\n            h1 = next1;\\n            h2 = next2;\\n        }\\n    }\\n};\\n\\n// Solution 2 - With stack\\nclass Solution {\\npublic:\\n    void reorderList(ListNode* head) {\\n        // base case\\n        if(head->next == NULL || head->next->next == NULL) \\n            return ;\\n        \\n        // Step 1 - Find middle of the LL with slow-fast pointer approach\\n        ListNode* slow= head,  *fast= head;\\n        stack<ListNode*> st;\\n        while(fast!=NULL && fast->next!=NULL){\\n            slow= slow->next;\\n            fast = fast->next->next;\\n        }\\n        \\n        // Step 2 - Split the LL into 2 parts from the middle\\n        ListNode* h2;\\n        if(fast != NULL)\\n            h2 = slow->next;    \\n        else \\n            h2 = slow;\\n        \\n        // Step 3 - Push the second LL into a stack so that the last element remains at top\\n        while(h2!=NULL){\\n            st.push(h2);\\n            h2 = h2->next;  \\n        }\\n        fast = head;\\n        \\n        // Step 4 - Link the first node with the last node and then pop the stack\\n        while(st.size()){ \\n            h2 = fast->next; \\n            fast->next = st.top();\\n            st.top()->next = h2;\\n            fast = h2;\\n            st.pop();    \\n        }\\n\\n        slow->next = NULL;\\n    }\\n};\\n\\n// Solution 3 - Recursion\\nclass Solution {\\npublic:\\n    void reorderList(ListNode* head) {\\n        //base case\\n        if(head!=NULL || head->next!=NULL || !head->next->next!= NULL) \\n            return;\\n        \\n        //Find the penultimate node i.e second last node of the linkedlist\\n        ListNode* penultimate = head;\\n        while (penultimate->next->next) \\n            penultimate = penultimate->next;\\n        \\n        // Link the penultimate node with the second node\\n        penultimate->next->next = head->next;\\n        head->next = penultimate->next;\\n        \\n        // Set the penultimate to the the last \\n        penultimate->next = NULL;\\n        \\n        // Recursive call\\n        reorderList(head->next->next);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3068676,
                "title": "reversing-2nd-half-then-merging-two-new-lists",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public void reorderList(ListNode head) {\\n\\n        //Find the middle node\\n        ListNode slow = head, fast = head, prev = null;\\n        while(fast!=null && fast.next!=null){\\n            slow = slow.next;\\n            fast = fast.next.next;\\n        }\\n\\n        //Reverse the 2nd Half of List, make it a separate list\\n        ListNode curr = slow.next;\\n       slow.next = null;\\n        while(curr!=null){\\n            ListNode nextNode = curr.next;\\n            curr.next = prev;\\n            prev = curr;\\n            curr = nextNode;\\n        }\\n        \\n        //Merging two Linked Lists\\n        ListNode curr1 = head;\\n        ListNode curr2 = prev;\\n        while(curr1!=null && curr2!=null){\\n            ListNode next1 = curr1.next;\\n            ListNode next2 = curr2.next;\\n            \\n            curr1.next = curr2;\\n            curr2.next = next1;\\n\\n            curr1 = next1;\\n            curr2 = next2;\\n        }\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public void reorderList(ListNode head) {\\n\\n        //Find the middle node\\n        ListNode slow = head, fast = head, prev = null;\\n        while(fast!=null && fast.next!=null){\\n            slow = slow.next;\\n            fast = fast.next.next;\\n        }\\n\\n        //Reverse the 2nd Half of List, make it a separate list\\n        ListNode curr = slow.next;\\n       slow.next = null;\\n        while(curr!=null){\\n            ListNode nextNode = curr.next;\\n            curr.next = prev;\\n            prev = curr;\\n            curr = nextNode;\\n        }\\n        \\n        //Merging two Linked Lists\\n        ListNode curr1 = head;\\n        ListNode curr2 = prev;\\n        while(curr1!=null && curr2!=null){\\n            ListNode next1 = curr1.next;\\n            ListNode next2 = curr2.next;\\n            \\n            curr1.next = curr2;\\n            curr2.next = next1;\\n\\n            curr1 = next1;\\n            curr2 = next2;\\n        }\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3050461,
                "title": "accepted-easy-solution-short-simple-best-method",
                "content": "\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    void reorderList(ListNode* head) {\\n        vector<ListNode*> v;\\n        ListNode* p=head;\\n        while(p)\\n        {  \\n            v.push_back(p);\\n            p=p->next;\\n        }\\n        ListNode* dummy=new ListNode();\\n        ListNode* d=dummy;\\n        int i=0, j=v.size()-1;\\n        cout<<v.size();\\n        while(i<=j)\\n        {\\n            dummy->next=v[i];\\n            i++;\\n            dummy=dummy->next;\\n            if(i<=j)\\n            {\\n                dummy->next=v[j];\\n                j--;\\n                dummy=dummy->next;\\n            }\\n        }\\n        dummy->next=NULL;    \\n        head=d->next;\\n    }\\n};\\n```\\nPlease **UPVOTE** if it helps \\u2764\\uFE0F\\uD83D\\uDE0A\\nThank You and Happy To Help You!!",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    void reorderList(ListNode* head) {\\n        vector<ListNode*> v;\\n        ListNode* p=head;\\n        while(p)\\n        {  \\n            v.push_back(p);\\n            p=p->next;\\n        }\\n        ListNode* dummy=new ListNode();\\n        ListNode* d=dummy;\\n        int i=0, j=v.size()-1;\\n        cout<<v.size();\\n        while(i<=j)\\n        {\\n            dummy->next=v[i];\\n            i++;\\n            dummy=dummy->next;\\n            if(i<=j)\\n            {\\n                dummy->next=v[j];\\n                j--;\\n                dummy=dummy->next;\\n            }\\n        }\\n        dummy->next=NULL;    \\n        head=d->next;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2507653,
                "title": "c-simple-and-easy-approach",
                "content": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    void reorderList(ListNode* head) {\\n        \\n//      step 1 : Finding the middle of the list in order to split it in 2 parts\\n        ListNode *slow=head;\\n        ListNode *fast=head->next;\\n        \\n        while(fast&&fast->next)\\n        {\\n        slow=slow->next;\\n        fast=fast->next->next;\\n        }\\n        \\n        ListNode *head2=slow->next;\\n        slow->next=NULL;\\n        \\n//      step 2 : Reversing the 2nd half of the list\\n        ListNode *forward=NULL;\\n        ListNode *prev=NULL;\\n        ListNode *curr=head2;\\n        \\n        while(curr)\\n        {\\n            forward=curr->next;\\n            curr->next=prev;\\n            prev=curr;\\n            curr=forward;\\n        }\\n        \\n//       Step 3 : Merge the 2 lists \\n        head2=prev;\\n        while(head2)\\n        {\\n            ListNode *ptr1=head->next;\\n            ListNode *ptr2=head2->next;\\n            \\n            head->next=head2;\\n            head2->next=ptr1;\\n            head=ptr1;\\n            head2=ptr2;\\n            \\n        }\\n    }\\n};\\n```\\nIf you like my solution plz upvote.",
                "solutionTags": [
                    "C++",
                    "C",
                    "Linked List"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    void reorderList(ListNode* head) {\\n        \\n//      step 1 : Finding the middle of the list in order to split it in 2 parts\\n        ListNode *slow=head;\\n        ListNode *fast=head->next;\\n        \\n        while(fast&&fast->next)\\n        {\\n        slow=slow->next;\\n        fast=fast->next->next;\\n        }\\n        \\n        ListNode *head2=slow->next;\\n        slow->next=NULL;\\n        \\n//      step 2 : Reversing the 2nd half of the list\\n        ListNode *forward=NULL;\\n        ListNode *prev=NULL;\\n        ListNode *curr=head2;\\n        \\n        while(curr)\\n        {\\n            forward=curr->next;\\n            curr->next=prev;\\n            prev=curr;\\n            curr=forward;\\n        }\\n        \\n//       Step 3 : Merge the 2 lists \\n        head2=prev;\\n        while(head2)\\n        {\\n            ListNode *ptr1=head->next;\\n            ListNode *ptr2=head2->next;\\n            \\n            head->next=head2;\\n            head2->next=ptr1;\\n            head=ptr1;\\n            head2=ptr2;\\n            \\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1823146,
                "title": "python-3-clean-interview-answer-easy-readability",
                "content": "\\tclass Solution:\\n\\t\\tdef reorderList(self, head: Optional[ListNode]) -> None:\\n\\t\\t\\n\\t\\t# Don\\'t be intimidated by the length, it\\'s literally three easy questions combined you get to learn\\n\\t\\t# How to Find the Middle Node | Reverse A Linked List        | Merge Two Lists\\n\\t\\t# Find Middle Node: # 876     | Reverse Linked List: #206    | Merge Two Sorted Lists: #21\\n\\t\\t# It\\'s one of the best linked list questions on here\\n\\n\\n\\t\\t\\t# **** Find Middle Node ****\\n\\t\\t\\tslow, fast = head, head\\n\\t\\t\\twhile fast and fast.next:\\n\\n\\t\\t\\t\\tslow, fast = slow.next, fast.next.next       \\n\\n\\t\\t\\tprev, current = None, slow.next\\n\\t\\t\\t# Using Example 2, node 3 will no longer point to 4, this splits the list in half\\n\\t\\t\\tslow.next = None\\n\\t\\t\\t# **** Reverse The Second Half ****\\n\\t\\t\\twhile current:\\n\\t\\t\\t\\ttemp = current\\n\\t\\t\\t\\tcurrent = current.next\\n\\t\\t\\t\\ttemp.next = prev\\n\\t\\t\\t\\tprev = temp\\n\\n\\t\\t\\t# **** Merge The Lists Together ****\\n\\n\\t\\t\\tdummy = curr = ListNode(0)\\n\\t\\t\\t# head1 will be the start of the first list (node 1)\\n\\t\\t\\t# head2 will be the start of the second list (node 5)\\n\\t\\t\\thead1, head2 = head, prev\\n\\n\\t\\t\\twhile head1 and head2:\\n\\t\\t\\t\\tif head1:\\n\\t\\t\\t\\t\\tcurr.next, head1 = head1, head1.next\\n\\t\\t\\t\\t\\tcurr = curr.next\\n\\n\\t\\t\\t\\tif head2:\\n\\t\\t\\t\\t\\tcurr.next, head2 = head2, head2.next \\n\\t\\t\\t\\t\\tcurr = curr.next\\n\\n\\t\\t\\t# whichever head1 or head2 still has a node remaining, we point to that remaining node\\n\\t\\t\\tcurr.next = head1 or head2\\n\\n\\t\\t\\t\"\"\"\\n\\t\\t\\tDo not return anything, modify head in-place instead.\\n\\t\\t\\t\"\"\"\\n",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "\\tclass Solution:\\n\\t\\tdef reorderList(self, head: Optional[ListNode]) -> None:\\n\\t\\t\\n\\t\\t# Don\\'t be intimidated by the length, it\\'s literally three easy questions combined you get to learn\\n\\t\\t# How to Find the Middle Node | Reverse A Linked List        | Merge Two Lists\\n\\t\\t# Find Middle Node: # 876     | Reverse Linked List: #206    | Merge Two Sorted Lists: #21\\n\\t\\t# It\\'s one of the best linked list questions on here\\n\\n\\n\\t\\t\\t# **** Find Middle Node ****\\n\\t\\t\\tslow, fast = head, head\\n\\t\\t\\twhile fast and fast.next:\\n\\n\\t\\t\\t\\tslow, fast = slow.next, fast.next.next       \\n\\n\\t\\t\\tprev, current = None, slow.next\\n\\t\\t\\t# Using Example 2, node 3 will no longer point to 4, this splits the list in half\\n\\t\\t\\tslow.next = None\\n\\t\\t\\t# **** Reverse The Second Half ****\\n\\t\\t\\twhile current:\\n\\t\\t\\t\\ttemp = current\\n\\t\\t\\t\\tcurrent = current.next\\n\\t\\t\\t\\ttemp.next = prev\\n\\t\\t\\t\\tprev = temp\\n\\n\\t\\t\\t# **** Merge The Lists Together ****\\n\\n\\t\\t\\tdummy = curr = ListNode(0)\\n\\t\\t\\t# head1 will be the start of the first list (node 1)\\n\\t\\t\\t# head2 will be the start of the second list (node 5)\\n\\t\\t\\thead1, head2 = head, prev\\n\\n\\t\\t\\twhile head1 and head2:\\n\\t\\t\\t\\tif head1:\\n\\t\\t\\t\\t\\tcurr.next, head1 = head1, head1.next\\n\\t\\t\\t\\t\\tcurr = curr.next\\n\\n\\t\\t\\t\\tif head2:\\n\\t\\t\\t\\t\\tcurr.next, head2 = head2, head2.next \\n\\t\\t\\t\\t\\tcurr = curr.next\\n\\n\\t\\t\\t# whichever head1 or head2 still has a node remaining, we point to that remaining node\\n\\t\\t\\tcurr.next = head1 or head2\\n\\n\\t\\t\\t\"\"\"\\n\\t\\t\\tDo not return anything, modify head in-place instead.\\n\\t\\t\\t\"\"\"\\n",
                "codeTag": "Java"
            },
            {
                "id": 1640529,
                "title": "python3-one-pass-l-o-explained",
                "content": "Honestly, it\\'s one and a half pass \\uD83E\\uDD25. So the first half pass we do to find the middle of the list. For that, we use *the slow and fast pointers* technic. The slow one moves one node at a time, and the fast one - two nodes at a time. When the fast one riches the end of the list, the slow one points to the middle point of the list. \\n\\nFrom the found middle node, we start our second half pass. We detach the left part of the list from the right part and reverse the right part so that the tail would become a head of the right part: `head0 -> head1 -> ...  x  ... <- tail1 <- tail0`\\n\\nNow we do the third half pass. We iterate over two resulting lists at the same time, and connect nodes as asked in the problem: `head0 -> tail0 -> head1 -> tail1 -> ...`.\\n\\nTime: **O(n)** - linear for scan\\nSpace: **O(1)** - store nothing\\n\\nRuntime: 84 ms, faster than **94.16%** of Python3 online submissions for Reorder List.\\nMemory Usage: 23.2 MB, less than **94.94%** of Python3 online submissions for Reorder List.\\n\\n```\\nclass Solution:\\n    def reorderList(self, head: Optional[ListNode]) -> None:\\n        if not head.next or not head.next.next:\\n            return\\n        \\n        # search for the middle\\n        slow, fast = head, head\\n        while fast.next and fast.next.next:\\n            slow = slow.next\\n            fast = fast.next.next\\n\\n        tail, cur = None, slow.next\\n        slow.next = None # detach list on the middle\\n        \\n        # reverse right part\\n        while cur:\\n            cur.next, tail, cur = tail, cur, cur.next\\n        \\n\\t\\t# rearrange nodes as asked\\n        headCur, headNext = head, head.next\\n        tailCur, tailNext = tail, tail.next\\n        while True:\\n            headCur.next, tailCur.next = tailCur, headNext\\n             \\n            if not tailNext:\\n                return\\n            \\n            tailCur, headCur = tailNext, headNext\\n            tailNext, headNext = tailNext.next, headNext.next\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def reorderList(self, head: Optional[ListNode]) -> None:\\n        if not head.next or not head.next.next:\\n            return\\n        \\n        # search for the middle\\n        slow, fast = head, head\\n        while fast.next and fast.next.next:\\n            slow = slow.next\\n            fast = fast.next.next\\n\\n        tail, cur = None, slow.next\\n        slow.next = None # detach list on the middle\\n        \\n        # reverse right part\\n        while cur:\\n            cur.next, tail, cur = tail, cur, cur.next\\n        \\n\\t\\t# rearrange nodes as asked\\n        headCur, headNext = head, head.next\\n        tailCur, tailNext = tail, tail.next\\n        while True:\\n            headCur.next, tailCur.next = tailCur, headNext\\n             \\n            if not tailNext:\\n                return\\n            \\n            tailCur, headCur = tailNext, headNext\\n            tailNext, headNext = tailNext.next, headNext.next\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1394712,
                "title": "c-o-n-time-o-1-space-iterative-approach",
                "content": "The idea here is to update our input list by reversing the second half of the list.\\nWe find the middle of the List, and call the ```reverseList()```, which returns back the head from the right side. After this, we will have two pointers, one pointing to the input head node (on the left) and the new head (on the right side) with the second half reversed. [**O(n)** time]\\n```c++\\n\\t 1->2->3->4->null;\\n\\t //After rearrangements\\n\\t (head1) 1->2-> null <-3<-4 (head2)\\n```\\n\\nNow we can alternatively pick nodes and update the links to create the required list and finally update our input head.  [**O(n)** time.]\\n```c++\\nListNode *reverseList(ListNode *h){\\n        ListNode *r = nullptr, *q = nullptr, *p = h;\\n        do{\\n            r = q;\\n            q = p;\\n            p = p->next;\\n            q->next = r;\\n        }while(p);\\n        return q;\\n    }\\n    void reorderList(ListNode* head) {\\n        if(!head || !head->next) return;\\n        \\n        ListNode *ptr1 = head, *ptr2 = head;\\n        while(ptr2 and ptr2->next){\\n            ptr1 = ptr1->next;\\n            ptr2 = ptr2->next->next;\\n        }\\n\\n        ptr2 = reverseList(ptr1);\\n        ptr1 = head; \\n        \\n        ListNode *header = new ListNode(-1);\\n        ListNode *p = header;\\n\\t\\t// mutex will strictly iterate between 0 & 1 to pick nodes.\\n        int mutex = 1; \\n        while(ptr1 and ptr2){\\n            if(mutex){\\n                p->next = ptr1;\\n                p = ptr1;\\n                ptr1 = ptr1->next;\\n                p->next = nullptr;\\n            }else{\\n                p->next = ptr2;\\n                p = ptr2;\\n                ptr2 = ptr2->next;\\n                p->next =nullptr;\\n            }\\n            mutex = (1 + mutex)%2;\\n        }\\n\\t\\t//update the input head node and return.\\n        head = header->next;\\n        return;\\n    }\\n\\n```\\n",
                "solutionTags": [],
                "code": "```reverseList()```\n```c++\\n\\t 1->2->3->4->null;\\n\\t //After rearrangements\\n\\t (head1) 1->2-> null <-3<-4 (head2)\\n```\n```c++\\nListNode *reverseList(ListNode *h){\\n        ListNode *r = nullptr, *q = nullptr, *p = h;\\n        do{\\n            r = q;\\n            q = p;\\n            p = p->next;\\n            q->next = r;\\n        }while(p);\\n        return q;\\n    }\\n    void reorderList(ListNode* head) {\\n        if(!head || !head->next) return;\\n        \\n        ListNode *ptr1 = head, *ptr2 = head;\\n        while(ptr2 and ptr2->next){\\n            ptr1 = ptr1->next;\\n            ptr2 = ptr2->next->next;\\n        }\\n\\n        ptr2 = reverseList(ptr1);\\n        ptr1 = head; \\n        \\n        ListNode *header = new ListNode(-1);\\n        ListNode *p = header;\\n\\t\\t// mutex will strictly iterate between 0 & 1 to pick nodes.\\n        int mutex = 1; \\n        while(ptr1 and ptr2){\\n            if(mutex){\\n                p->next = ptr1;\\n                p = ptr1;\\n                ptr1 = ptr1->next;\\n                p->next = nullptr;\\n            }else{\\n                p->next = ptr2;\\n                p = ptr2;\\n                ptr2 = ptr2->next;\\n                p->next =nullptr;\\n            }\\n            mutex = (1 + mutex)%2;\\n        }\\n\\t\\t//update the input head node and return.\\n        head = header->next;\\n        return;\\n    }\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1339389,
                "title": "simple-c-solution-using-stack-with-explanation",
                "content": "**Approach**:\\n\\t\\t\\t\\tFirstly we have to calculate the centre of the linked list, So, inorder to calculate the centre basically there there are two approaches:\\n\\t\\t\\t\\t1) We will traverse the list and count the number of nodes and then divide the count by 2 and again traverse the list in order to calculate the centre.\\n\\t\\t\\t\\t2) By using hare and tortoise, i.e one pointer will go slow (p=p->next) & another pointer will go fast(q=q->next->next) and we checking loop for the reaching the q at null as q is fast moving pointer.\\n\\t\\t\\t\\tAfter finding the centre then we push all the subsequent nodes on the stack sequentially. So the last node will come at the top of the stack. Then we can pop the element from the stack, and keeping form the first pointer and changing the links.\\n```\\nvoid reorderList(ListNode* head) {\\n        stack<ListNode*> s;\\n        ListNode *p=head,*q=head;\\n        while(q && q->next){\\n            p=p->next;\\n            q=q->next->next;\\n        }\\n        ListNode *mk_null=p;\\n        p=p->next;\\n        mk_null->next=NULL;\\n        while(p!=NULL){\\n            s.push(p);\\n            p=p->next;\\n        }\\n        p=head;\\n        while(!s.empty()){\\n            q=head->next;\\n            head->next=s.top();\\n            s.pop();\\n            head=head->next;\\n            head->next=q;\\n            head=q;\\n        } \\n    }\\n```\\nIf any doubt feel free to ask !!\\nAlso, if you get some value from this, then show some love by upvoting it !!!!\\nHappy Coding",
                "solutionTags": [
                    "C++",
                    "C",
                    "Stack"
                ],
                "code": "```\\nvoid reorderList(ListNode* head) {\\n        stack<ListNode*> s;\\n        ListNode *p=head,*q=head;\\n        while(q && q->next){\\n            p=p->next;\\n            q=q->next->next;\\n        }\\n        ListNode *mk_null=p;\\n        p=p->next;\\n        mk_null->next=NULL;\\n        while(p!=NULL){\\n            s.push(p);\\n            p=p->next;\\n        }\\n        p=head;\\n        while(!s.empty()){\\n            q=head->next;\\n            head->next=s.top();\\n            s.pop();\\n            head=head->next;\\n            head->next=q;\\n            head=q;\\n        } \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 989097,
                "title": "java-clear-solution-that-beats-99",
                "content": "The main idea is to split the given list into two different list, then reorder the second one, and after that merge them.\\nMy solution based on 3 previously solved problems with little changes:\\n1) https://leetcode.com/problems/reverse-linked-list/\\n2) https://leetcode.com/problems/middle-of-the-linked-list/\\n3) https://leetcode.com/problems/merge-two-sorted-lists/\\n```java\\nimport java.util.List;\\n\\npublic class Solution {\\n\\t// just simple reversing\\n    public ListNode reverseList(ListNode head) {\\n        ListNode prev = null;\\n        while (head != null) {\\n            ListNode next = head.next;\\n            head.next = prev;\\n            prev = head;\\n            head = next;\\n        }\\n        return prev;\\n    }\\n    public ListNode getMediumNode(ListNode head) {\\n        if (head == null || head.next == null) {\\n            return head;\\n        }\\n        ListNode slowNode = head;\\n        ListNode prevNode = slowNode;\\n        ListNode fastNode = head;\\n        while (fastNode != null && fastNode.next != null) {\\n            prevNode = slowNode;\\n            slowNode = slowNode.next;\\n            fastNode = fastNode.next.next;\\n        }\\n\\t\\t// spliting the list \\n        prevNode.next = null;\\n        return slowNode;\\n    }\\n\\t// simple merging\\n    public void mergeTwoLists(ListNode l1, ListNode l2) {\\n        ListNode curNode = new ListNode(0);\\n        while (l1 != null && l2 != null) {\\n            curNode.next = l1;\\n            l1 = l1.next;\\n            curNode = curNode.next;\\n            curNode.next = l2;\\n            l2 = l2.next;\\n            curNode = curNode.next;\\n        }\\n        if (l1 != null) {\\n            curNode.next = l1;\\n        }\\n        if (l2 != null) {\\n            curNode.next = l2;\\n        }\\n    }\\n    // Given 1->2->3->4, reorder it to 1->4->2->3.\\n    // Given 1->2->3->4->5, reorder it to 1->5->2->4->3.\\n    public void reorderList(ListNode head) {\\n        if (head == null || head.next == null) return;\\n        ListNode secondHalf = reverseList(getMediumNode(head)); // after that both head and secondHalf are changing\\n        mergeTwoLists(head, secondHalf);\\n    }\\n}\\n\\n```",
                "solutionTags": [],
                "code": "```java\\nimport java.util.List;\\n\\npublic class Solution {\\n\\t// just simple reversing\\n    public ListNode reverseList(ListNode head) {\\n        ListNode prev = null;\\n        while (head != null) {\\n            ListNode next = head.next;\\n            head.next = prev;\\n            prev = head;\\n            head = next;\\n        }\\n        return prev;\\n    }\\n    public ListNode getMediumNode(ListNode head) {\\n        if (head == null || head.next == null) {\\n            return head;\\n        }\\n        ListNode slowNode = head;\\n        ListNode prevNode = slowNode;\\n        ListNode fastNode = head;\\n        while (fastNode != null && fastNode.next != null) {\\n            prevNode = slowNode;\\n            slowNode = slowNode.next;\\n            fastNode = fastNode.next.next;\\n        }\\n\\t\\t// spliting the list \\n        prevNode.next = null;\\n        return slowNode;\\n    }\\n\\t// simple merging\\n    public void mergeTwoLists(ListNode l1, ListNode l2) {\\n        ListNode curNode = new ListNode(0);\\n        while (l1 != null && l2 != null) {\\n            curNode.next = l1;\\n            l1 = l1.next;\\n            curNode = curNode.next;\\n            curNode.next = l2;\\n            l2 = l2.next;\\n            curNode = curNode.next;\\n        }\\n        if (l1 != null) {\\n            curNode.next = l1;\\n        }\\n        if (l2 != null) {\\n            curNode.next = l2;\\n        }\\n    }\\n    // Given 1->2->3->4, reorder it to 1->4->2->3.\\n    // Given 1->2->3->4->5, reorder it to 1->5->2->4->3.\\n    public void reorderList(ListNode head) {\\n        if (head == null || head.next == null) return;\\n        ListNode secondHalf = reverseList(getMediumNode(head)); // after that both head and secondHalf are changing\\n        mergeTwoLists(head, secondHalf);\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 802099,
                "title": "my-python-solution",
                "content": "1. Find the middle of the list\\n2. Reverse the elements of the list after the middle\\n3. Then merge the elements one by one in the way we want.\\n\\n```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def reorderList(self, head: ListNode) -> None:\\n        \"\"\"\\n        Do not return anything, modify head in-place instead.\\n        \"\"\"\\n        if not head:\\n            return head\\n        slow = head\\n        fast = head\\n        while fast != None and fast.next != None:\\n            slow = slow.next\\n            fast = fast.next.next\\n            \\n        node1 = head\\n        reverseSlow = self.reverse(slow.next)\\n        slow.next = None\\n        while reverseSlow:\\n            node1.next, node1 = reverseSlow, node1.next\\n            reverseSlow.next, reverseSlow = node1, reverseSlow.next\\n            \\n    def reverse(self, node):\\n        current = node\\n        previous = None\\n        while current:\\n            currentNext = current.next\\n            current.next = previous\\n            previous = current\\n            current = currentNext\\n        return previous\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Linked List"
                ],
                "code": "```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def reorderList(self, head: ListNode) -> None:\\n        \"\"\"\\n        Do not return anything, modify head in-place instead.\\n        \"\"\"\\n        if not head:\\n            return head\\n        slow = head\\n        fast = head\\n        while fast != None and fast.next != None:\\n            slow = slow.next\\n            fast = fast.next.next\\n            \\n        node1 = head\\n        reverseSlow = self.reverse(slow.next)\\n        slow.next = None\\n        while reverseSlow:\\n            node1.next, node1 = reverseSlow, node1.next\\n            reverseSlow.next, reverseSlow = node1, reverseSlow.next\\n            \\n    def reverse(self, node):\\n        current = node\\n        previous = None\\n        while current:\\n            currentNext = current.next\\n            current.next = previous\\n            previous = current\\n            current = currentNext\\n        return previous\\n```",
                "codeTag": "Java"
            },
            {
                "id": 802054,
                "title": "very-simple-two-pointers-approach",
                "content": "```\\nclass Solution {\\n    public void reorderList(ListNode head) {\\n        if(head == null) return;\\n        ArrayList<ListNode> list = new ArrayList<>();\\n        ListNode dummy = head;\\n        while(dummy != null){\\n            list.add(dummy);\\n            dummy = dummy.next;\\n        } \\n        int i = 1, left = 1, right = list.size() - 1;\\n        dummy = head;\\n        while(i < list.size()){\\n            if(i % 2 == 0) dummy.next = list.get(left++);\\n            else dummy.next = list.get(right--);\\n            dummy = dummy.next;\\n            i++;        \\n        }\\n        dummy.next = null;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\n    public void reorderList(ListNode head) {\\n        if(head == null) return;\\n        ArrayList<ListNode> list = new ArrayList<>();\\n        ListNode dummy = head;\\n        while(dummy != null){\\n            list.add(dummy);\\n            dummy = dummy.next;\\n        } \\n        int i = 1, left = 1, right = list.size() - 1;\\n        dummy = head;\\n        while(i < list.size()){\\n            if(i % 2 == 0) dummy.next = list.get(left++);\\n            else dummy.next = list.get(right--);\\n            dummy = dummy.next;\\n            i++;        \\n        }\\n        dummy.next = null;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 605694,
                "title": "simple-javascript-solution-87-50",
                "content": "Runtime: 80 ms, faster than 87.16% of JavaScript online submissions for Reorder List.\\nMemory Usage: 41.8 MB, less than 50.00% of JavaScript online submissions for Reorder List.\\n```\\nfunction reorderList(head) {\\n  const arr = [];\\n  let index = head;\\n  \\n  while (index) {\\n    arr.push(index);\\n    index = index.next;\\n  }\\n\\n  for (let l = 0; l < arr.length; l++) {\\n    let r = arr.length - 1 - l;\\n    if (l >= r) { arr[l].next = null; break; }\\n    arr[l].next = arr[r];\\n    arr[r].next = arr[l + 1];\\n  }\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nfunction reorderList(head) {\\n  const arr = [];\\n  let index = head;\\n  \\n  while (index) {\\n    arr.push(index);\\n    index = index.next;\\n  }\\n\\n  for (let l = 0; l < arr.length; l++) {\\n    let r = arr.length - 1 - l;\\n    if (l >= r) { arr[l].next = null; break; }\\n    arr[l].next = arr[r];\\n    arr[r].next = arr[l + 1];\\n  }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 502344,
                "title": "javascript-no-stack-easy-to-read",
                "content": "```\\nvar reorderList = function(head) {\\n    if (!head) return;\\n    let cur = head, middle = findMiddle(head);\\n    let rev = reverseList(middle.next);\\n    while (rev) {\\n        const saved = cur.next;\\n        cur.next = rev;\\n        rev = rev.next;\\n        cur.next.next = saved;\\n        cur = saved;\\n    }\\n    \\n    middle.next = null;\\n};\\n\\nvar findMiddle = function(head) {\\n    if (!head) return;\\n    let middle = head;\\n    while (head && head.next) {\\n        head = head.next.next;\\n        middle = middle.next;\\n    }\\n    \\n    return middle;\\n}\\n\\nvar reverseList = function(head) {\\n    if (!head) return;\\n    let prev = null;\\n    while (head) {\\n        const saved = head.next;\\n        head.next = prev;\\n        prev = head;\\n        head = saved;\\n    }\\n    \\n    return prev;\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar reorderList = function(head) {\\n    if (!head) return;\\n    let cur = head, middle = findMiddle(head);\\n    let rev = reverseList(middle.next);\\n    while (rev) {\\n        const saved = cur.next;\\n        cur.next = rev;\\n        rev = rev.next;\\n        cur.next.next = saved;\\n        cur = saved;\\n    }\\n    \\n    middle.next = null;\\n};\\n\\nvar findMiddle = function(head) {\\n    if (!head) return;\\n    let middle = head;\\n    while (head && head.next) {\\n        head = head.next.next;\\n        middle = middle.next;\\n    }\\n    \\n    return middle;\\n}\\n\\nvar reverseList = function(head) {\\n    if (!head) return;\\n    let prev = null;\\n    while (head) {\\n        const saved = head.next;\\n        head.next = prev;\\n        prev = head;\\n        head = saved;\\n    }\\n    \\n    return prev;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 446239,
                "title": "99-speed-100-mem-python-solution-with-explanations",
                "content": "Runtime: 76 ms, faster than 99.23% of Python3 online submissions for Reorder List.\\nMemory Usage: 20.8 MB, less than 100.00% of Python3 online submissions for Reorder List.\\n\\n```python\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.next = None\\n\\nclass Solution:\\n    def reorderList(self, head: ListNode) -> None:\\n        \"\"\"\\n        Do not return anything, modify head in-place instead.\\n        \"\"\"\\n        if not head:\\n            return\\n        \\n        # find the middle node `prev`\\n        # for [1,2,3,4,5] prev will be pointing at 3\\n        # for [1,2,3,4] prev will be pointing at 2\\n        # first half is equal or one longer than 2nd half\\n        mid = head\\n        tail = head\\n        prev = None\\n        while tail:\\n            prev = mid\\n            mid = mid.next            \\n            tail = tail.next\\n            if tail:\\n                tail = tail.next\\n        \\n        # cut off the first haf\\n        prev.next = None\\n        \\n        # reverse the 2nd half\\n        prev = None\\n        curr = mid\\n        while curr:\\n            n = curr.next\\n            curr.next = prev            \\n            prev = curr\\n            curr = n        \\n        tail = prev\\n        \\n        #print(tail)\\n        #print(head)\\n        # merge the two\\n        begin = head\\n        while begin and tail:\\n            n = begin.next\\n            tn = tail.next\\n            \\n            begin.next = tail\\n            tail.next = n\\n                        \\n            begin = n\\n            tail = tn\\n",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "Runtime: 76 ms, faster than 99.23% of Python3 online submissions for Reorder List.\\nMemory Usage: 20.8 MB, less than 100.00% of Python3 online submissions for Reorder List.\\n\\n```python\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.next = None\\n\\nclass Solution:\\n    def reorderList(self, head: ListNode) -> None:\\n        \"\"\"\\n        Do not return anything, modify head in-place instead.\\n        \"\"\"\\n        if not head:\\n            return\\n        \\n        # find the middle node `prev`\\n        # for [1,2,3,4,5] prev will be pointing at 3\\n        # for [1,2,3,4] prev will be pointing at 2\\n        # first half is equal or one longer than 2nd half\\n        mid = head\\n        tail = head\\n        prev = None\\n        while tail:\\n            prev = mid\\n            mid = mid.next            \\n            tail = tail.next\\n            if tail:\\n                tail = tail.next\\n        \\n        # cut off the first haf\\n        prev.next = None\\n        \\n        # reverse the 2nd half\\n        prev = None\\n        curr = mid\\n        while curr:\\n            n = curr.next\\n            curr.next = prev            \\n            prev = curr\\n            curr = n        \\n        tail = prev\\n        \\n        #print(tail)\\n        #print(head)\\n        # merge the two\\n        begin = head\\n        while begin and tail:\\n            n = begin.next\\n            tn = tail.next\\n            \\n            begin.next = tail\\n            tail.next = n\\n                        \\n            begin = n\\n            tail = tn\\n",
                "codeTag": "Java"
            },
            {
                "id": 388571,
                "title": "javascript-easy-to-understand-2-solutions-72ms",
                "content": "The first solution, it\\'s a normal one, and I think it\\'s more in line with the requirements \"NOT modify the node\". Here is the algorithm:\\n\\n1. Traversal the linked list to find the middle node\\n2. Reverse the latter half\\n3. Reorder the whole linked list\\n\\n```js\\nconst reorderList = head => {\\n  if (!head || !head.next || !head.next.next) return head;\\n\\n  let slow = head;\\n  let fast = head.next;\\n  while (fast && fast.next) {\\n    slow = slow.next;\\n    fast = fast.next.next;\\n  }\\n\\n  let prev = slow.next;\\n  let tail = prev.next;\\n  while (tail) {\\n    const next = tail.next;\\n    tail.next = prev;\\n    prev = tail;\\n    tail = next;\\n  }\\n  slow.next.next = null;\\n  slow.next = prev;\\n\\n  let left = head;\\n  let right = slow.next;\\n  slow.next = null;\\n  while (left && right) {\\n    const ln = left.next;\\n    const rn = right.next;\\n    left.next = right;\\n    right.next = ln;\\n    left = ln;\\n    right = rn;\\n  }\\n\\n  return head;\\n};\\n```\\n\\nThe second solution, may be a little cheating, by which I mean I add a pointer for each node link to the previous one. I\\'m not pretty sure that it\\'s modify the values of node or not. And here\\'s the algorithm:\\n\\n1. Traversal the linked list and convert it to a doubly linked list\\n2. Reorder the whole linked list from both 2 side\\n\\n```js\\nconst reorderList = head => {\\n  if (!head || !head.next) return head;\\n  let prev = head;\\n  let tail = head.next;\\n  while (tail) {\\n    tail.prev = prev;\\n    prev = tail;\\n    tail = tail.next;\\n  }\\n  let cur = head;\\n  while (cur !== prev && cur.prev !== prev) {\\n    const next = cur.next;\\n    cur.next = prev;\\n    prev.next = next;\\n    prev = prev.prev;\\n    cur = next;\\n  }\\n  cur.next = null;\\n  return head;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```js\\nconst reorderList = head => {\\n  if (!head || !head.next || !head.next.next) return head;\\n\\n  let slow = head;\\n  let fast = head.next;\\n  while (fast && fast.next) {\\n    slow = slow.next;\\n    fast = fast.next.next;\\n  }\\n\\n  let prev = slow.next;\\n  let tail = prev.next;\\n  while (tail) {\\n    const next = tail.next;\\n    tail.next = prev;\\n    prev = tail;\\n    tail = next;\\n  }\\n  slow.next.next = null;\\n  slow.next = prev;\\n\\n  let left = head;\\n  let right = slow.next;\\n  slow.next = null;\\n  while (left && right) {\\n    const ln = left.next;\\n    const rn = right.next;\\n    left.next = right;\\n    right.next = ln;\\n    left = ln;\\n    right = rn;\\n  }\\n\\n  return head;\\n};\\n```\n```js\\nconst reorderList = head => {\\n  if (!head || !head.next) return head;\\n  let prev = head;\\n  let tail = head.next;\\n  while (tail) {\\n    tail.prev = prev;\\n    prev = tail;\\n    tail = tail.next;\\n  }\\n  let cur = head;\\n  while (cur !== prev && cur.prev !== prev) {\\n    const next = cur.next;\\n    cur.next = prev;\\n    prev.next = next;\\n    prev = prev.prev;\\n    cur = next;\\n  }\\n  cur.next = null;\\n  return head;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 327858,
                "title": "swift-90-beat-o-n-with-o-1-memory-three-step-koderz-kamp",
                "content": "```\\nclass Solution {\\n    func reorderList(_ head: ListNode?) {\\n        \\n        //Find the middle of the list.\\n        var premid = head\\n        var mid = head\\n        var fast = head\\n        while fast != nil && fast!.next != nil {\\n            premid = mid\\n            mid = mid!.next\\n            fast = fast!.next!.next\\n        }\\n        if mid === head { return }\\n        premid!.next = nil\\n        \\n        \\n        //Now reverse from the middle onward\\n        var prev = mid\\n        var next = mid!.next\\n        mid!.next = nil\\n        mid = next\\n        while mid != nil {\\n            next = mid!.next\\n            mid!.next = prev\\n            prev = mid\\n            mid = next\\n        }\\n\\n        //Not interleave the two halves.\\n        var rev = prev\\n        var node = head\\n        prev = node\\n        while node != nil && rev != nil {\\n            prev = node\\n            next = node!.next\\n            node!.next = rev\\n            node = next\\n            \\n            next = rev!.next\\n            if node != nil { rev!.next = node } /* Note: The \"reverse\" may be 1 link longer. */\\n            rev = next\\n        }\\n    }\\n}\\n```\\n\\nTo me this \"feels\" sloppy, there must be some way to make it less verbose.",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    func reorderList(_ head: ListNode?) {\\n        \\n        //Find the middle of the list.\\n        var premid = head\\n        var mid = head\\n        var fast = head\\n        while fast != nil && fast!.next != nil {\\n            premid = mid\\n            mid = mid!.next\\n            fast = fast!.next!.next\\n        }\\n        if mid === head { return }\\n        premid!.next = nil\\n        \\n        \\n        //Now reverse from the middle onward\\n        var prev = mid\\n        var next = mid!.next\\n        mid!.next = nil\\n        mid = next\\n        while mid != nil {\\n            next = mid!.next\\n            mid!.next = prev\\n            prev = mid\\n            mid = next\\n        }\\n\\n        //Not interleave the two halves.\\n        var rev = prev\\n        var node = head\\n        prev = node\\n        while node != nil && rev != nil {\\n            prev = node\\n            next = node!.next\\n            node!.next = rev\\n            node = next\\n            \\n            next = rev!.next\\n            if node != nil { rev!.next = node } /* Note: The \"reverse\" may be 1 link longer. */\\n            rev = next\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 196192,
                "title": "concise-python-solution-with-o-n-time-and-o-1-space",
                "content": "Three steps: 1) find mid node and split list to left and right halves 2) reverse right part 3) merge left and right part\\n```\\ndef reorderList(head):\\n    if not head or not head.next:\\n        return\\n    slow, fast = head, head.next\\n    while fast and fast.next:\\n        slow, fast = slow.next, fast.next.next\\n    right, slow.next = slow.next, None\\n    pre, cur = None, right\\n    while cur:\\n        cur.next, pre, cur = pre, cur, cur.next\\n    left, right = head, pre\\n    while right:\\n        left.next, right.next, left, right = right, left.next, left.next, right.next\\n```",
                "solutionTags": [],
                "code": "```\\ndef reorderList(head):\\n    if not head or not head.next:\\n        return\\n    slow, fast = head, head.next\\n    while fast and fast.next:\\n        slow, fast = slow.next, fast.next.next\\n    right, slow.next = slow.next, None\\n    pre, cur = None, right\\n    while cur:\\n        cur.next, pre, cur = pre, cur, cur.next\\n    left, right = head, pre\\n    while right:\\n        left.next, right.next, left, right = right, left.next, left.next, right.next\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3917312,
                "title": "python3-beats-96-alternating-reordering-of-linked-list",
                "content": "# Intuition\\nThe key insight is to first divide the list into two halves and then reverse the second half. The crux lies in the reversed second half. When nodes are reversed, the last node becomes the first, and the second-to-last becomes the second, and so on. This reversal aligns with the alternating order. By inserting these reversed nodes into the first half, we achieve the desired alternating reordering.\\n\\n# Approach\\n**Splitting the List:** We divide the list into two halves using two pointers, slow and fast, with slow moving one step and fast moving two steps at a time. This positions slow at the middle of the list.\\n\\n**Reversing the Second Half:** After finding the middle, we reverse the second half of the list. This is achieved by traversing the second half and changing the direction of pointers using a curr pointer along with prev and holder variables.\\n\\n**Merging Alternately:** With the reversed second half ready, we merge the two halves alternately. We traverse both halves using curr1 and curr2 pointers. By switching pointers and using holder1 and holder2 to store next nodes, we achieve the alternating reordering.\\n\\n# Complexity\\n- Time complexity\\nWe traverse the linked list three times. Once for finding the middle, once for reversing the second half, and once for merging. Thus, the time complexity is **O(n)**, where n is the number of nodes in the linked list.\\n\\n- Space complexity:\\nThe extra space used for pointers and temporary variables is constant, leading to a space complexity of **O(1)**\\n\\n# Code\\n```\\nclass Solution:\\n    def reorderList(self, head: Optional[ListNode]) -> None:\\n        # No need to reorder if the list is empty or has 1 or 2 elements\\n        if not head or not head.next or not head.next.next:\\n            return\\n\\n        # Find the middle of the list\\n        slow = head\\n        fast = head\\n        while fast and fast.next:\\n            slow = slow.next\\n            fast = fast.next.next\\n\\n        head2 = slow.next\\n        slow.next = None\\n\\n        # Reverse the second half of the list\\n        curr = head2\\n        prev = None\\n \\n        while curr:\\n            holder = curr.next\\n            curr.next = prev\\n            prev = curr\\n            curr = holder\\n    \\n        # Merge the two halves of the list alternatively\\n        curr1 = head\\n        curr2 = prev # Because after reversing the second half, the last node is actually the head of our reversed list\\n        \\n        while curr2:\\n            holder1, holder2 = curr1.next, curr2.next\\n            curr1.next = curr2\\n            curr2.next = holder1\\n            curr1, curr2 = holder1, holder2\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Linked List",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution:\\n    def reorderList(self, head: Optional[ListNode]) -> None:\\n        # No need to reorder if the list is empty or has 1 or 2 elements\\n        if not head or not head.next or not head.next.next:\\n            return\\n\\n        # Find the middle of the list\\n        slow = head\\n        fast = head\\n        while fast and fast.next:\\n            slow = slow.next\\n            fast = fast.next.next\\n\\n        head2 = slow.next\\n        slow.next = None\\n\\n        # Reverse the second half of the list\\n        curr = head2\\n        prev = None\\n \\n        while curr:\\n            holder = curr.next\\n            curr.next = prev\\n            prev = curr\\n            curr = holder\\n    \\n        # Merge the two halves of the list alternatively\\n        curr1 = head\\n        curr2 = prev # Because after reversing the second half, the last node is actually the head of our reversed list\\n        \\n        while curr2:\\n            holder1, holder2 = curr1.next, curr2.next\\n            curr1.next = curr2\\n            curr2.next = holder1\\n            curr1, curr2 = holder1, holder2\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3785861,
                "title": "easy-java-solution-find-middle-and-reverse-beats-100",
                "content": "# Intuition\\nFind middle of linkedlist. Divide linkedlist into two parts reverse the second half. Keep pointers on head of both the linkedlist, keep traversing and redordering as required by question\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n<!-- # Approach -->\\n<!-- Describe your approach to solving the problem. -->\\n\\n\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode mid(ListNode head){\\n        ListNode slow = head;\\n        ListNode fast = head;\\n        while(fast!=null && fast.next!=null){\\n            fast = fast.next.next;\\n            slow = slow.next;\\n        }\\n        return slow;\\n    }\\n\\n    public ListNode rev(ListNode head){\\n        ListNode curr = head; \\n        ListNode prev = null;\\n        ListNode forward = null;\\n        while(curr!= null){\\n            forward = curr.next;\\n            curr.next = prev;\\n            prev = curr;\\n            curr = forward;\\n        }\\n        return prev;\\n    }\\n\\n    public void reorderList(ListNode head) {\\n        ListNode mid = mid(head);\\n        ListNode midNext = mid.next;\\n        mid.next = null;\\n        ListNode p2 = rev(midNext);\\n        ListNode p1 = head;\\n\\n        ListNode temp;\\n\\n        while(p1!=null && p2!=null){\\n            temp = p1.next;\\n            p1.next = p2;\\n            \\n            p1 = p2;\\n            p2 = temp;\\n        }\\n    }\\n    \\n}\\n```\\n![upVoteCatt.jpg](https://assets.leetcode.com/users/images/02f20020-b0b2-454e-b3b6-18a6c996da49_1689742245.8278887.jpeg)\\n",
                "solutionTags": [
                    "Java",
                    "Linked List"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode mid(ListNode head){\\n        ListNode slow = head;\\n        ListNode fast = head;\\n        while(fast!=null && fast.next!=null){\\n            fast = fast.next.next;\\n            slow = slow.next;\\n        }\\n        return slow;\\n    }\\n\\n    public ListNode rev(ListNode head){\\n        ListNode curr = head; \\n        ListNode prev = null;\\n        ListNode forward = null;\\n        while(curr!= null){\\n            forward = curr.next;\\n            curr.next = prev;\\n            prev = curr;\\n            curr = forward;\\n        }\\n        return prev;\\n    }\\n\\n    public void reorderList(ListNode head) {\\n        ListNode mid = mid(head);\\n        ListNode midNext = mid.next;\\n        mid.next = null;\\n        ListNode p2 = rev(midNext);\\n        ListNode p1 = head;\\n\\n        ListNode temp;\\n\\n        while(p1!=null && p2!=null){\\n            temp = p1.next;\\n            p1.next = p2;\\n            \\n            p1 = p2;\\n            p2 = temp;\\n        }\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3546169,
                "title": "self-made-approach-easy-to-build-your-logic",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public void reorderList(ListNode head) {\\n        \\n        if(head== null || head.next == null) return ;\\n        ListNode curr= head;\\n        List<Integer> l = new ArrayList<>();\\n        List<Integer> l1 = new ArrayList<>();\\n        while(curr!=null){\\n            l.add(curr.val);\\n            curr= curr.next;\\n        }\\n        int i=0;\\n        int j = len(head)-1;\\n        while(i<=j){\\n            if(i!=j){\\n                l1.add(l.get(i));\\n                l1.add(l.get(j));\\n            }\\n            else{\\n                l1.add(l.get(i));\\n            }\\n            i++;\\n            j--;\\n        }\\n        i=0;\\n        while(head!=null){\\n            head.val = l1.get(i);\\n            head=head.next;\\n            i++;\\n            \\n        }\\n        return ;\\n        \\n    }\\n    public int len(ListNode node){\\n        int c=0;\\n        while(node!=null){\\n            c++;\\n            node=node.next;\\n        }\\n        return c;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Linked List"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public void reorderList(ListNode head) {\\n        \\n        if(head== null || head.next == null) return ;\\n        ListNode curr= head;\\n        List<Integer> l = new ArrayList<>();\\n        List<Integer> l1 = new ArrayList<>();\\n        while(curr!=null){\\n            l.add(curr.val);\\n            curr= curr.next;\\n        }\\n        int i=0;\\n        int j = len(head)-1;\\n        while(i<=j){\\n            if(i!=j){\\n                l1.add(l.get(i));\\n                l1.add(l.get(j));\\n            }\\n            else{\\n                l1.add(l.get(i));\\n            }\\n            i++;\\n            j--;\\n        }\\n        i=0;\\n        while(head!=null){\\n            head.val = l1.get(i);\\n            head=head.next;\\n            i++;\\n            \\n        }\\n        return ;\\n        \\n    }\\n    public int len(ListNode node){\\n        int c=0;\\n        while(node!=null){\\n            c++;\\n            node=node.next;\\n        }\\n        return c;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3316697,
                "title": "java-solution",
                "content": "\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public void reorderList(ListNode head) {\\n         //Find the middle node\\n        ListNode slow = head, fast = head, prev = null;\\n        while(fast!=null && fast.next!=null){\\n            slow = slow.next;\\n            fast = fast.next.next;\\n        }\\n\\n        //Reverse the 2nd Half of List, make it a separate list\\n        ListNode curr = slow.next;\\n       slow.next = null;\\n        while(curr!=null){\\n            ListNode nextNode = curr.next;\\n            curr.next = prev;\\n            prev = curr;\\n            curr = nextNode;\\n        }\\n        \\n        //Merging two Linked Lists\\n        ListNode curr1 = head;\\n        ListNode curr2 = prev;\\n        while(curr1!=null && curr2!=null){\\n            ListNode next1 = curr1.next;\\n            ListNode next2 = curr2.next;\\n            \\n            curr1.next = curr2;\\n            curr2.next = next1;\\n\\n            curr1 = next1;\\n            curr2 = next2;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public void reorderList(ListNode head) {\\n         //Find the middle node\\n        ListNode slow = head, fast = head, prev = null;\\n        while(fast!=null && fast.next!=null){\\n            slow = slow.next;\\n            fast = fast.next.next;\\n        }\\n\\n        //Reverse the 2nd Half of List, make it a separate list\\n        ListNode curr = slow.next;\\n       slow.next = null;\\n        while(curr!=null){\\n            ListNode nextNode = curr.next;\\n            curr.next = prev;\\n            prev = curr;\\n            curr = nextNode;\\n        }\\n        \\n        //Merging two Linked Lists\\n        ListNode curr1 = head;\\n        ListNode curr2 = prev;\\n        while(curr1!=null && curr2!=null){\\n            ListNode next1 = curr1.next;\\n            ListNode next2 = curr2.next;\\n            \\n            curr1.next = curr2;\\n            curr2.next = next1;\\n\\n            curr1 = next1;\\n            curr2 = next2;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3012286,
                "title": "java-o-n-using-stack",
                "content": "# Complexity\\n- Time complexity: O(N)\\n\\n- Space complexity: O(N)\\n\\n# Code\\n```\\nclass Solution {\\n    public void reorderList(ListNode head) {\\n        if (head.next == null || head.next.next == null) return;\\n        Stack<ListNode> stack = new Stack<>();\\n        ListNode temp = head;\\n        while (temp != null) {\\n            stack.push(temp);\\n            temp = temp.next;\\n        }\\n        temp = head;\\n        int size = stack.size();\\n        for (int i = 0; i < size / 2; i++) {\\n            ListNode mem = temp.next;\\n            temp.next = stack.pop();\\n            temp.next.next = mem;\\n            temp = mem;\\n        }\\n        temp.next = null;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public void reorderList(ListNode head) {\\n        if (head.next == null || head.next.next == null) return;\\n        Stack<ListNode> stack = new Stack<>();\\n        ListNode temp = head;\\n        while (temp != null) {\\n            stack.push(temp);\\n            temp = temp.next;\\n        }\\n        temp = head;\\n        int size = stack.size();\\n        for (int i = 0; i < size / 2; i++) {\\n            ListNode mem = temp.next;\\n            temp.next = stack.pop();\\n            temp.next.next = mem;\\n            temp = mem;\\n        }\\n        temp.next = null;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2695295,
                "title": "python-recursion",
                "content": "\\'\\'\\'\\n\\n    def reorderList(self, head):\\n        \\n        phead = head\\n        def f(head, phead):\\n            if head.next == None:\\n                return phead\\n            \\n            t = f(head.next, phead)\\n            \\n            if t == None or t.next == None or t == head:\\n                return None\\n\\n            bk = t.next\\n            t.next = head.next\\n            head.next = None\\n\\n            t.next.next = bk\\n            \\n            return t.next.next\\n            \\n        f(head, phead)\\n\\t\\t\\n\\'\\'\\'",
                "solutionTags": [
                    "Python",
                    "Linked List",
                    "Recursion"
                ],
                "code": "\\'\\'\\'\\n\\n    def reorderList(self, head):\\n        \\n        phead = head\\n        def f(head, phead):\\n            if head.next == None:\\n                return phead\\n            \\n            t = f(head.next, phead)\\n            \\n            if t == None or t.next == None or t == head:\\n                return None\\n\\n            bk = t.next\\n            t.next = head.next\\n            head.next = None\\n\\n            t.next.next = bk\\n            \\n            return t.next.next\\n            \\n        f(head, phead)\\n\\t\\t\\n\\'\\'\\'",
                "codeTag": "Python3"
            },
            {
                "id": 2602959,
                "title": "clean-modular-c-code-with-meaningful-variable-names",
                "content": "```\\nclass Solution {\\nprivate:\\n    int getLength(ListNode* head)\\n    {\\n        int count = 0;\\n        ListNode* temp = head;\\n        while(temp)\\n        {\\n            temp = temp->next;\\n            count++;\\n        }\\n        return count;\\n    }\\n    ListNode* getNthNode(ListNode* head, int n)\\n    {\\n        int count = 1;\\n        ListNode* temp = head;\\n        while(temp)\\n        {\\n            if(count == n)\\n            {\\n                return temp;\\n            }\\n            temp = temp->next;\\n            count++;\\n        }\\n        return NULL;\\n    }\\n    ListNode* reverse(ListNode* head)\\n    {\\n        if(!head or !head->next)\\n            return head;\\n        \\n        ListNode* cur = head;\\n        ListNode* nxt = head->next;\\n        ListNode* reversedHead = reverse(nxt);\\n        cur->next = NULL;\\n        nxt->next = cur;\\n        return reversedHead;\\n    }\\n    ListNode* merge(ListNode* l, ListNode* r)\\n    {\\n        ListNode* dummy = new ListNode();\\n        ListNode* temp = dummy;\\n        \\n        while(l and r)\\n        {\\n            dummy->next = l;\\n            dummy = dummy->next;\\n            l = l->next;\\n            dummy->next = r;\\n            dummy = dummy->next;\\n            r = r->next;\\n        }\\n        if(l)\\n        {\\n            dummy->next = l;\\n        }   \\n        else\\n        {\\n            dummy->next = r;\\n        }\\n        \\n        return temp->next;\\n    }\\npublic:\\n    void reorderList(ListNode* head)\\n    {\\n        //len 0,1,2\\n        if(!head or !head->next or !head->next->next)\\n        {\\n            return;\\n        }\\n        \\n        int length = getLength(head); \\n        int mid = (length+1)/2;\\n        \\n        ListNode* midNode = getNthNode(head, mid);\\n        \\n        ListNode* next = midNode->next;\\n        midNode->next = NULL;\\n        \\n        ListNode* reversedRightHalf = reverse(next);\\n        \\n        head = merge(head,reversedRightHalf);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    int getLength(ListNode* head)\\n    {\\n        int count = 0;\\n        ListNode* temp = head;\\n        while(temp)\\n        {\\n            temp = temp->next;\\n            count++;\\n        }\\n        return count;\\n    }\\n    ListNode* getNthNode(ListNode* head, int n)\\n    {\\n        int count = 1;\\n        ListNode* temp = head;\\n        while(temp)\\n        {\\n            if(count == n)\\n            {\\n                return temp;\\n            }\\n            temp = temp->next;\\n            count++;\\n        }\\n        return NULL;\\n    }\\n    ListNode* reverse(ListNode* head)\\n    {\\n        if(!head or !head->next)\\n            return head;\\n        \\n        ListNode* cur = head;\\n        ListNode* nxt = head->next;\\n        ListNode* reversedHead = reverse(nxt);\\n        cur->next = NULL;\\n        nxt->next = cur;\\n        return reversedHead;\\n    }\\n    ListNode* merge(ListNode* l, ListNode* r)\\n    {\\n        ListNode* dummy = new ListNode();\\n        ListNode* temp = dummy;\\n        \\n        while(l and r)\\n        {\\n            dummy->next = l;\\n            dummy = dummy->next;\\n            l = l->next;\\n            dummy->next = r;\\n            dummy = dummy->next;\\n            r = r->next;\\n        }\\n        if(l)\\n        {\\n            dummy->next = l;\\n        }   \\n        else\\n        {\\n            dummy->next = r;\\n        }\\n        \\n        return temp->next;\\n    }\\npublic:\\n    void reorderList(ListNode* head)\\n    {\\n        //len 0,1,2\\n        if(!head or !head->next or !head->next->next)\\n        {\\n            return;\\n        }\\n        \\n        int length = getLength(head); \\n        int mid = (length+1)/2;\\n        \\n        ListNode* midNode = getNthNode(head, mid);\\n        \\n        ListNode* next = midNode->next;\\n        midNode->next = NULL;\\n        \\n        ListNode* reversedRightHalf = reverse(next);\\n        \\n        head = merge(head,reversedRightHalf);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2556626,
                "title": "java-100-fast-faster-and-easy-to-understand",
                "content": "In this question we will use inplace reversal as well as finding middle and we will just merge them.\\n```class Solution {\\n    \\n    public void reorderList(ListNode head) {\\n        ListNode mid = getMidPointer(head);\\n        ListNode second = reverse(mid);\\n        ListNode first = head;\\n        //first and second denote first head and second head respectively\\n        merge(first, second);\\n    }\\n    \\n    private void merge(ListNode first, ListNode second) {        \\n        while (first != null && second != null) {\\n            ListNode temp = first.next;\\n            first.next = second;\\n            first = temp;\\n            \\n            temp = second.next;\\n            second.next = first;\\n            second = temp;\\n\\n        }\\n        if (first != null) first.next = null;\\n    }\\n    \\n    private ListNode reverse(ListNode head) {\\n        \\n        ListNode cur = head;\\n        ListNode prev = null;\\n        \\n        while (cur != null) {\\n            ListNode next = cur.next;\\n            cur.next = prev;\\n            \\n            prev = cur;\\n            cur = next;\\n        }\\n        return prev;\\n    }\\n    \\n    private ListNode getMidPointer(ListNode head) {\\n        ListNode slow = head;\\n        ListNode fast = head;\\n        \\n        while (fast != null && fast.next != null) {\\n            slow = slow.next;\\n            fast = fast.next.next;\\n        }\\n        return slow;\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Linked List"
                ],
                "code": "class Solution {\\n    \\n    public void reorderList(ListNode head) {\\n        ListNode mid = getMidPointer(head);\\n        ListNode second = reverse(mid);\\n        ListNode first = head;\\n        //first and second denote first head and second head respectively\\n        merge(first, second);\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 2537020,
                "title": "clean-easy-solution-to-understand-typescript",
                "content": "```\\nfunction reorderList(head: ListNode | null): void {\\n    // find middle \\n    // reverse the part after middle \\n    // remove the cycle from the middle \\n    // merge the first side with the second reversed side;\\n\\n    let slow = findMiddle(haed) // \\n    let head2 = reverse(slow.next) // \\n    slow.next = null// to prevent cycle after reversing\\n    \\n        \\n    merge(head, head2) // \\n\\n\\n};\\n\\nfunction findMiddle(head:ListNode|null):ListNode|null{\\n    let slow=head; //\\n    let fast=head; //\\n    \\n    while(fast && fast.next){\\n        slow=slow.next;\\n        fast= fast?.next?.next\\n    }\\n    return slow\\n}\\nfunction reverse(head: ListNode | null): ListNode | null{\\n    let previous=null\\n    let current=head;\\n        \\n    while(current){\\n        let next=current.next;\\n        current.next=previous;\\n        previous=current;\\n        current=next;\\n    }\\n    return previous\\n}\\n        \\nfunction merge(headA: ListNode | null,headB: ListNode | null){\\n    while(headB){\\n        let next=headA.next;\\n        headA.next=headB;\\n        headA=headB;\\n        headB=next;\\n    }\\n}\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript",
                    "Linked List"
                ],
                "code": "```\\nfunction reorderList(head: ListNode | null): void {\\n    // find middle \\n    // reverse the part after middle \\n    // remove the cycle from the middle \\n    // merge the first side with the second reversed side;\\n\\n    let slow = findMiddle(haed) // \\n    let head2 = reverse(slow.next) // \\n    slow.next = null// to prevent cycle after reversing\\n    \\n        \\n    merge(head, head2) // \\n\\n\\n};\\n\\nfunction findMiddle(head:ListNode|null):ListNode|null{\\n    let slow=head; //\\n    let fast=head; //\\n    \\n    while(fast && fast.next){\\n        slow=slow.next;\\n        fast= fast?.next?.next\\n    }\\n    return slow\\n}\\nfunction reverse(head: ListNode | null): ListNode | null{\\n    let previous=null\\n    let current=head;\\n        \\n    while(current){\\n        let next=current.next;\\n        current.next=previous;\\n        previous=current;\\n        current=next;\\n    }\\n    return previous\\n}\\n        \\nfunction merge(headA: ListNode | null,headB: ListNode | null){\\n    while(headB){\\n        let next=headA.next;\\n        headA.next=headB;\\n        headA=headB;\\n        headB=next;\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2511137,
                "title": "typescript-javascript-fast-slow-pointers",
                "content": "```\\nfunction reorderList(head: ListNode | null): void {\\n  let fast = head;\\n  let slow = head;\\n  \\n  while(fast && fast.next){\\n    fast = fast.next.next;\\n    slow = slow.next;\\n  }\\n  \\n  // store the second half of linked list\\n  let secondHalf = slow.next;\\n\\n  // make last node in left half equal to null\\n  slow.next = null;\\n\\n  // reverse right half\\n  let prev = null;\\n  while(secondHalf){\\n    const temp = secondHalf.next;\\n    secondHalf.next = prev;\\n    prev = secondHalf;\\n    secondHalf = temp;\\n  }\\n  \\n  \\n  let left = head;\\n  let right = prev;\\n\\n  // alternate nodes\\n  while(left && right){\\n    const tempLeft = left.next;\\n    const tempRight = right.next;\\n    \\n    left.next = right;\\n    right.next = tempLeft;\\n    \\n    left = tempLeft;\\n    right = tempRight;\\n  }\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "```\\nfunction reorderList(head: ListNode | null): void {\\n  let fast = head;\\n  let slow = head;\\n  \\n  while(fast && fast.next){\\n    fast = fast.next.next;\\n    slow = slow.next;\\n  }\\n  \\n  // store the second half of linked list\\n  let secondHalf = slow.next;\\n\\n  // make last node in left half equal to null\\n  slow.next = null;\\n\\n  // reverse right half\\n  let prev = null;\\n  while(secondHalf){\\n    const temp = secondHalf.next;\\n    secondHalf.next = prev;\\n    prev = secondHalf;\\n    secondHalf = temp;\\n  }\\n  \\n  \\n  let left = head;\\n  let right = prev;\\n\\n  // alternate nodes\\n  while(left && right){\\n    const tempLeft = left.next;\\n    const tempRight = right.next;\\n    \\n    left.next = right;\\n    right.next = tempLeft;\\n    \\n    left = tempLeft;\\n    right = tempRight;\\n  }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1854363,
                "title": "c-simple-o-1-space",
                "content": "```\\nListNode* reverse(ListNode* head) {\\n\\tListNode* rhead = NULL;\\n\\twhile(head) {\\n\\t\\tListNode* temp = head->next;\\n\\t\\thead->next = rhead;\\n\\t\\trhead = head;\\n\\t\\thead = temp;\\n\\t}\\n\\treturn rhead;\\n}\\nvoid reorderList(ListNode* head) {\\n\\tListNode *slow = head, *fast = head;\\n\\twhile(slow && fast->next && fast->next->next) {\\n\\t\\tslow = slow->next;\\n\\t\\tfast = fast->next->next;\\n\\t}\\n\\tListNode* head2 = reverse(slow->next), *curr = head;\\n\\tslow->next = NULL;\\n\\n\\twhile(curr) {\\n\\t\\tListNode* temp = curr->next;\\n\\t\\tcurr->next = head2;\\n\\t\\tcurr = curr->next;\\n\\t\\tif(head2) {\\n\\t\\t\\thead2 = head2->next;\\n\\t\\t\\tcurr->next = temp;\\n\\t\\t\\tcurr = curr->next;\\n\\t\\t}\\n\\t}\\n}\\n```",
                "solutionTags": [
                    "C",
                    "Linked List"
                ],
                "code": "```\\nListNode* reverse(ListNode* head) {\\n\\tListNode* rhead = NULL;\\n\\twhile(head) {\\n\\t\\tListNode* temp = head->next;\\n\\t\\thead->next = rhead;\\n\\t\\trhead = head;\\n\\t\\thead = temp;\\n\\t}\\n\\treturn rhead;\\n}\\nvoid reorderList(ListNode* head) {\\n\\tListNode *slow = head, *fast = head;\\n\\twhile(slow && fast->next && fast->next->next) {\\n\\t\\tslow = slow->next;\\n\\t\\tfast = fast->next->next;\\n\\t}\\n\\tListNode* head2 = reverse(slow->next), *curr = head;\\n\\tslow->next = NULL;\\n\\n\\twhile(curr) {\\n\\t\\tListNode* temp = curr->next;\\n\\t\\tcurr->next = head2;\\n\\t\\tcurr = curr->next;\\n\\t\\tif(head2) {\\n\\t\\t\\thead2 = head2->next;\\n\\t\\t\\tcurr->next = temp;\\n\\t\\t\\tcurr = curr->next;\\n\\t\\t}\\n\\t}\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1640786,
                "title": "slow-and-fast-pointer-o-1-space",
                "content": "**Idea?**\\n* We need to keep alternate nodes from start as well backside of the list, How to do that efficiently?\\n* Obviously, **we need to reverse the second half of the list**.\\n* Maintain **slow and fast pointers to find the middle node and break the list into two parts** and reverse the second half of the list.\\n* Now, create a dummy node and each time pick alternate nodes from start as well as backside of the list.\\n* Check the Code.\\n\\n```\\nclass Solution {\\npublic:\\n    ListNode* reverse(ListNode* head){\\n        ListNode *prev = nullptr,*temp;\\n        while(head!=nullptr){\\n            temp = head->next;\\n            head->next = prev;\\n            prev = head;\\n            head = temp;\\n        }\\n        return prev;\\n    }\\n    void reorderList(ListNode* head) {\\n        ListNode *slow = head,*fast = head,*prev = nullptr;\\n        while(fast and fast->next){\\n            prev = slow;\\n            slow = slow->next;\\n            fast = fast->next->next;\\n        }\\n        ListNode *head1 = head,*head2;\\n        if(fast){\\n            head2 = slow->next;\\n            slow->next = nullptr;\\n        }\\n        else{\\n            head2 = slow;\\n            prev->next = nullptr;\\n        }\\n        // reversing the other half of the list\\n        head2 = reverse(head2);        \\n        int turn = 1;\\n        ListNode *ans = new ListNode(0);\\n        ListNode* curr = ans;\\n        while(head1 or head2){\\n            if(turn){\\n                curr->next = head1;\\n                head1 = head1->next;\\n            }\\n            else{\\n                curr->next = head2;\\n                head2 = head2->next;\\n            }\\n            turn^=1;\\n            curr = curr->next;\\n        }\\n        if(head1)\\n            curr->next = head1;\\n    }\\n};\\n```\\n**Don\\'t Forget to Upvote!**",
                "solutionTags": [
                    "Linked List"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* reverse(ListNode* head){\\n        ListNode *prev = nullptr,*temp;\\n        while(head!=nullptr){\\n            temp = head->next;\\n            head->next = prev;\\n            prev = head;\\n            head = temp;\\n        }\\n        return prev;\\n    }\\n    void reorderList(ListNode* head) {\\n        ListNode *slow = head,*fast = head,*prev = nullptr;\\n        while(fast and fast->next){\\n            prev = slow;\\n            slow = slow->next;\\n            fast = fast->next->next;\\n        }\\n        ListNode *head1 = head,*head2;\\n        if(fast){\\n            head2 = slow->next;\\n            slow->next = nullptr;\\n        }\\n        else{\\n            head2 = slow;\\n            prev->next = nullptr;\\n        }\\n        // reversing the other half of the list\\n        head2 = reverse(head2);        \\n        int turn = 1;\\n        ListNode *ans = new ListNode(0);\\n        ListNode* curr = ans;\\n        while(head1 or head2){\\n            if(turn){\\n                curr->next = head1;\\n                head1 = head1->next;\\n            }\\n            else{\\n                curr->next = head2;\\n                head2 = head2->next;\\n            }\\n            turn^=1;\\n            curr = curr->next;\\n        }\\n        if(head1)\\n            curr->next = head1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1640675,
                "title": "java-stack-detailed-explanation-easy-approach",
                "content": "```\\nIntuition :\\n1) Push the node in stack so that we can fetch in reverse order.\\n2) Calculate half size of list.\\n3) Traverse till the size, take one node from list & one from stack\\n4) Assign null in stack\\'s last node otherwise it will have the link to other nodes.\\n\\nAlternative Approach :\\nWe can solve this by using 3 steps\\n1) Find the middle node\\n2) Reverse the list from middle to end\\n3) Joins both lists\\n```\\n```\\npublic void reorderList(ListNode head) {\\n        Stack<ListNode> stack = new Stack<>();\\n        ListNode curr = head;\\n        while(curr != null){\\n            stack.push(curr);\\n            curr = curr.next;\\n        }\\n        int size = (stack.size()-1)/2;\\n        curr = head;\\n        while(size-- > 0){\\n            ListNode top = stack.pop();\\n            ListNode temp = curr.next;\\n            curr.next = top;\\n            top.next = temp;\\n            curr = temp;\\n        }\\n        stack.pop().next = null;\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Stack"
                ],
                "code": "```\\nIntuition :\\n1) Push the node in stack so that we can fetch in reverse order.\\n2) Calculate half size of list.\\n3) Traverse till the size, take one node from list & one from stack\\n4) Assign null in stack\\'s last node otherwise it will have the link to other nodes.\\n\\nAlternative Approach :\\nWe can solve this by using 3 steps\\n1) Find the middle node\\n2) Reverse the list from middle to end\\n3) Joins both lists\\n```\n```\\npublic void reorderList(ListNode head) {\\n        Stack<ListNode> stack = new Stack<>();\\n        ListNode curr = head;\\n        while(curr != null){\\n            stack.push(curr);\\n            curr = curr.next;\\n        }\\n        int size = (stack.size()-1)/2;\\n        curr = head;\\n        while(size-- > 0){\\n            ListNode top = stack.pop();\\n            ListNode temp = curr.next;\\n            curr.next = top;\\n            top.next = temp;\\n            curr = temp;\\n        }\\n        stack.pop().next = null;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1517252,
                "title": "stack-c",
                "content": "```\\nvoid reorderList(ListNode* head) {\\n        int l=0;\\n        stack<ListNode*>s;\\n        ListNode* temp=head;\\n        while(temp)\\n        {\\n            l++;\\n            s.push(temp);\\n            temp=temp->next;\\n        }\\n       \\n        ListNode* next;\\n        for(int i=0;i<l/2;i++)\\n        {\\n           next=head->next;\\n            head->next=s.top();\\n            s.pop();\\n            head=head->next;\\n            head->next=next;\\n            head=head->next;\\n        }\\n        head->next=NULL;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvoid reorderList(ListNode* head) {\\n        int l=0;\\n        stack<ListNode*>s;\\n        ListNode* temp=head;\\n        while(temp)\\n        {\\n            l++;\\n            s.push(temp);\\n            temp=temp->next;\\n        }\\n       \\n        ListNode* next;\\n        for(int i=0;i<l/2;i++)\\n        {\\n           next=head->next;\\n            head->next=s.top();\\n            s.pop();\\n            head=head->next;\\n            head->next=next;\\n            head=head->next;\\n        }\\n        head->next=NULL;\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1387700,
                "title": "c-simple-with-explanation-get-it-right-on-the-first-try",
                "content": "As with most of the other linked list problems, the problem has 2 challenges:\\n\\n* Solving the core problem efficiently (common with every LC problem)\\n* Getting it right on the first try (specific to Linked List problems)\\n\\nThis problem is tricky if never seen before. On my first try I used an array to store the ListNodes and then arranged them in order. However immediately after submitting this basic solution the right idea clicked in my mind. The combined list required is a merged list made out of the first half in order and the second half in reverse order.\\n\\nThe **3 steps** mentioned in the top answers are as follows:\\n\\n* Use two pointers to separate the two halves of the list\\n* Reverse the second half\\n* Merge the two halves according to the rule\\n\\nTo get it **right on the first try** one should know how to initialize the two pointers and where they will end up. \\n\\nWe initialize both the slow and fast pointer from the head and move the slow pointer once and the fast pointer twice on every iteration. A common concern is where the slow pointer will end up with odd and even length lists. Testing it out with lists of 5 and 4 nodes (which is fast mentally), we can confirm that the slow node will always end on the last node on the left side in case of an even list and on the middle node in an odd list. \\n\\nThis is perfect because by separating the two lists in this way, the merging step does not need any special treatment due to odd or even list (the last node on the first half will already be assigned appropriately in case of odd lists, since to separate the lists we have to make its next pointer NULL, and in the case of even list its next pointer will be assigned to the last node on the reversed second half)\\n\\nThen we reverse the second half. To **always reverse perfectly** memorize the following:\\n```\\nnext = curr->next;\\ncurr->next = prev;\\nprev = curr;\\ncurr = next;\\n```\\n\\n**REMEMBER** with this inside of the while loop, the condition is curr!=NULL for the while loop. At the end, prev is at the head of the reversed list. \\n\\nThen to merge, use pointers to store the next elements of both halves to be assigned after the present nodes are pointed correctly.\\n\\n```\\n    void reorderList(ListNode* head) {\\n        ListNode* slow = head;\\n        ListNode* fast = head;\\n        \\n        while(fast != NULL && fast->next != NULL)\\n        {\\n            slow = slow->next;\\n            fast = fast->next->next;\\n        }\\n        \\n        ListNode* part2 = slow->next;\\n        slow->next = NULL;\\n        \\n        ListNode* curr = part2;\\n        ListNode* prev = NULL;\\n        ListNode* next = NULL;\\n        \\n        while(curr != NULL)\\n        {\\n            next = curr->next;\\n            curr->next = prev;\\n            prev = curr;\\n            curr = next;\\n        }\\n        \\n        part2 = prev;\\n        \\n        ListNode* part1 = head;\\n        \\n        ListNode* next1;\\n        ListNode* next2;\\n        \\n        while(part2 != NULL)\\n        {\\n            next1 = part1->next;\\n            next2 = part2->next;\\n            \\n            part1->next = part2;\\n            part2->next = next1;\\n            \\n            part1 = next1;\\n            part2 = next2;\\n        }\\n    }\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nnext = curr->next;\\ncurr->next = prev;\\nprev = curr;\\ncurr = next;\\n```\n```\\n    void reorderList(ListNode* head) {\\n        ListNode* slow = head;\\n        ListNode* fast = head;\\n        \\n        while(fast != NULL && fast->next != NULL)\\n        {\\n            slow = slow->next;\\n            fast = fast->next->next;\\n        }\\n        \\n        ListNode* part2 = slow->next;\\n        slow->next = NULL;\\n        \\n        ListNode* curr = part2;\\n        ListNode* prev = NULL;\\n        ListNode* next = NULL;\\n        \\n        while(curr != NULL)\\n        {\\n            next = curr->next;\\n            curr->next = prev;\\n            prev = curr;\\n            curr = next;\\n        }\\n        \\n        part2 = prev;\\n        \\n        ListNode* part1 = head;\\n        \\n        ListNode* next1;\\n        ListNode* next2;\\n        \\n        while(part2 != NULL)\\n        {\\n            next1 = part1->next;\\n            next2 = part2->next;\\n            \\n            part1->next = part2;\\n            part2->next = next1;\\n            \\n            part1 = next1;\\n            part2 = next2;\\n        }\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1272729,
                "title": "c-easy-iterative-solution-o-n",
                "content": "```\\nclass Solution {\\npublic:\\n    ListNode *midNode(ListNode *head)\\n    {\\n        ListNode* slow=head , *fast=head;\\n        while(fast && fast->next && fast->next->next){\\n            slow=slow->next;\\n            fast=fast->next->next;\\n        }\\n        return slow;\\n    }\\n\\n    ListNode *reverse(ListNode* head){\\n        ListNode* curr=head,*prev=nullptr,*nex=nullptr;\\n        while(curr){\\n            nex=curr->next;\\n            curr->next=prev;\\n            prev=curr;\\n            curr=nex;\\n        }\\n        return prev;\\n    }\\n    void reorderList(ListNode* head) {\\n        if(!head || !head->next){\\n            return;\\n        }\\n        ListNode* temp=head;\\n        ListNode* mid=midNode(head);\\n        ListNode* rev=reverse(mid);\\n\\n        ListNode* cnext=nullptr,*rnext=nullptr;\\n        while(temp && rev){\\n            cnext=temp->next;\\n            rnext=rev->next;\\n\\n            temp->next=rev;\\n\\n            rev->next=cnext;\\n\\n            temp=cnext;\\n            rev=rnext;\\n\\n        }\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode *midNode(ListNode *head)\\n    {\\n        ListNode* slow=head , *fast=head;\\n        while(fast && fast->next && fast->next->next){\\n            slow=slow->next;\\n            fast=fast->next->next;\\n        }\\n        return slow;\\n    }\\n\\n    ListNode *reverse(ListNode* head){\\n        ListNode* curr=head,*prev=nullptr,*nex=nullptr;\\n        while(curr){\\n            nex=curr->next;\\n            curr->next=prev;\\n            prev=curr;\\n            curr=nex;\\n        }\\n        return prev;\\n    }\\n    void reorderList(ListNode* head) {\\n        if(!head || !head->next){\\n            return;\\n        }\\n        ListNode* temp=head;\\n        ListNode* mid=midNode(head);\\n        ListNode* rev=reverse(mid);\\n\\n        ListNode* cnext=nullptr,*rnext=nullptr;\\n        while(temp && rev){\\n            cnext=temp->next;\\n            rnext=rev->next;\\n\\n            temp->next=rev;\\n\\n            rev->next=cnext;\\n\\n            temp=cnext;\\n            rev=rnext;\\n\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1153782,
                "title": "easy-c-solution-problem-broken-into-3-parts-with-comments",
                "content": "```\\n*\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\n\\n*\\nStep 1:Break the list from between. \\nStep 2: Reverse the second part of the broken list. \\nStep 3: Start from the first list and alternatively add elements from both the lists.\\n*\\n\\nclass Solution {\\npublic:\\n    void reorderList(ListNode* head) \\n    {\\n\\t    if(head->next!=NULL) // if case [1] then we need not do anything\\n        {     \\n        ListNode *slow=head;\\n        ListNode *fast=head->next;\\n        \\n        //breaking at mid\\n        while(fast!=NULL && fast->next!=NULL)\\n        {\\n            slow=slow->next;\\n            fast=fast->next->next;\\n        }\\n        ListNode *curr=slow->next;//head of the broken list i.e. 2nd part of the original list\\n        slow->next=NULL;\\n        \\n        //reversal of the second part of the original list\\n        ListNode *prev=NULL;\\n        ListNode *nextt=curr->next;\\n        while(curr!=NULL)\\n        {\\n            curr->next=prev;\\n            prev=curr;\\n            curr=nextt;\\n            if(nextt==NULL)\\n                continue;\\n            nextt=nextt->next;\\n        }\\n        \\n        //linking first half and reversed list\\n        ListNode *temp1=head->next;\\n        ListNode *temp2=prev->next;\\n        while(head->next!=NULL && prev->next!=NULL)\\n        {\\n            head->next=prev;\\n            head=temp1;\\n            temp1=temp1->next;\\n            \\n            prev->next=head;\\n            prev=temp2;\\n            temp2=temp2->next;\\n        }\\n        if(head->next==NULL)\\n        {\\n            head->next=prev;\\n        }\\n        else\\n        {\\n            head->next=prev;\\n            prev->next=temp1;\\n        }\\n        \\n        }\\n        \\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n*\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\n\\n*\\nStep 1:Break the list from between. \\nStep 2: Reverse the second part of the broken list. \\nStep 3: Start from the first list and alternatively add elements from both the lists.\\n*\\n\\nclass Solution {\\npublic:\\n    void reorderList(ListNode* head) \\n    {\\n\\t    if(head->next!=NULL) // if case [1] then we need not do anything\\n        {     \\n        ListNode *slow=head;\\n        ListNode *fast=head->next;\\n        \\n        //breaking at mid\\n        while(fast!=NULL && fast->next!=NULL)\\n        {\\n            slow=slow->next;\\n            fast=fast->next->next;\\n        }\\n        ListNode *curr=slow->next;//head of the broken list i.e. 2nd part of the original list\\n        slow->next=NULL;\\n        \\n        //reversal of the second part of the original list\\n        ListNode *prev=NULL;\\n        ListNode *nextt=curr->next;\\n        while(curr!=NULL)\\n        {\\n            curr->next=prev;\\n            prev=curr;\\n            curr=nextt;\\n            if(nextt==NULL)\\n                continue;\\n            nextt=nextt->next;\\n        }\\n        \\n        //linking first half and reversed list\\n        ListNode *temp1=head->next;\\n        ListNode *temp2=prev->next;\\n        while(head->next!=NULL && prev->next!=NULL)\\n        {\\n            head->next=prev;\\n            head=temp1;\\n            temp1=temp1->next;\\n            \\n            prev->next=head;\\n            prev=temp2;\\n            temp2=temp2->next;\\n        }\\n        if(head->next==NULL)\\n        {\\n            head->next=prev;\\n        }\\n        else\\n        {\\n            head->next=prev;\\n            prev->next=temp1;\\n        }\\n        \\n        }\\n        \\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 924685,
                "title": "easy-js-solution",
                "content": "```\\nvar reorderList = function(head) {\\n    let median = findMedian(head);\\n    let cur1 = head;\\n    let cur2 = reverseList(median);\\n    let dummyHead = new ListNode(), cur = dummyHead;\\n    while (cur1 && cur2) {\\n        cur.next = cur1;\\n        cur = cur.next;\\n        cur1 = cur1.next;\\n        if (!cur1) break;\\n        cur.next = cur2;\\n        cur = cur.next;\\n        cur2 = cur2.next;\\n    }\\n    return dummyHead.next;\\n    // T.C: O(N)\\n    // S.C: O(1)\\n};\\nfunction reverseList(head) {\\n    let prev = null, cur = head;\\n    while (cur !== null) {\\n        let next = cur.next;\\n        cur.next = prev;\\n        prev = cur;\\n        cur = next;\\n    }\\n    return prev;\\n}\\n\\nfunction findMedian(head) {\\n    let slow = head, fast = head;\\n    while (fast !== null) {\\n        fast = fast.next;\\n        if (!fast) break;\\n        fast = fast.next;\\n        slow = slow.next;\\n    }\\n    return slow;\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar reorderList = function(head) {\\n    let median = findMedian(head);\\n    let cur1 = head;\\n    let cur2 = reverseList(median);\\n    let dummyHead = new ListNode(), cur = dummyHead;\\n    while (cur1 && cur2) {\\n        cur.next = cur1;\\n        cur = cur.next;\\n        cur1 = cur1.next;\\n        if (!cur1) break;\\n        cur.next = cur2;\\n        cur = cur.next;\\n        cur2 = cur2.next;\\n    }\\n    return dummyHead.next;\\n    // T.C: O(N)\\n    // S.C: O(1)\\n};\\nfunction reverseList(head) {\\n    let prev = null, cur = head;\\n    while (cur !== null) {\\n        let next = cur.next;\\n        cur.next = prev;\\n        prev = cur;\\n        cur = next;\\n    }\\n    return prev;\\n}\\n\\nfunction findMedian(head) {\\n    let slow = head, fast = head;\\n    while (fast !== null) {\\n        fast = fast.next;\\n        if (!fast) break;\\n        fast = fast.next;\\n        slow = slow.next;\\n    }\\n    return slow;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 824623,
                "title": "c-iterative-recursive-solution",
                "content": "**Recursive Solution:**\\n\\nRuntime: 48 ms, faster than 39.95% of C++ online submissions for Reorder List.\\nMemory Usage: 15.7 MB, less than 7.19% of C++ online submissions for Reorder List.\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    void listTraverse(ListNode* head, ListNode*& thead)\\n    {\\n        if(head->next)\\n            listTraverse(head->next,thead);\\n        \\n        if(thead)\\n        {\\n            if(thead==head || thead->next==head)\\n            {\\n                head->next = NULL;\\n                thead = NULL;\\n            }\\n            else \\n            {\\n                ListNode * tnext = thead->next;\\n                thead->next = head;\\n                head->next = tnext;\\n                thead = tnext;                \\n            }\\n        }\\n    }\\n    \\n    void reorderList(ListNode* head) {\\n        if(head)\\n            listTraverse(head,head);\\n    }\\n};\\n```\\n\\n**Iterative Solution:**\\n\\nRuntime: 36 ms, faster than 94.88% of C++ online submissions for Reorder List.\\nMemory Usage: 18.4 MB, less than 33.24% of C++ online submissions for Reorder List.\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    void reorderList(ListNode* head) {\\n        \\n        // no update needed for 0 or 1 elements\\n        if(!head || !head->next) return;\\n        \\n        int n = 0;\\n        ListNode * node = head;\\n        ListNode * tnode = NULL;\\n        stack<ListNode *>stak;\\n        \\n        // add all nodes to stack and count total nodes n\\n        while(node!=NULL)\\n        {\\n            stak.push(node);\\n            node = node->next;\\n            n++;\\n        }\\n        \\n        // loop through stack and pop item from top n/2 times\\n        // add item to the next of current node and set current->next as item->next\\n        node = head;\\n        for(int i=0;i<=n/2;i++)\\n        {\\n            tnode = stak.top();\\n            stak.pop();\\n            tnode->next = node->next;\\n            node->next = tnode;\\n            node = tnode->next;\\n        }\\n\\n        // set last node\\'s next as NULL to terminate list\\n        node->next = NULL;\\n                \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Linked List",
                    "Stack",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    void listTraverse(ListNode* head, ListNode*& thead)\\n    {\\n        if(head->next)\\n            listTraverse(head->next,thead);\\n        \\n        if(thead)\\n        {\\n            if(thead==head || thead->next==head)\\n            {\\n                head->next = NULL;\\n                thead = NULL;\\n            }\\n            else \\n            {\\n                ListNode * tnext = thead->next;\\n                thead->next = head;\\n                head->next = tnext;\\n                thead = tnext;                \\n            }\\n        }\\n    }\\n    \\n    void reorderList(ListNode* head) {\\n        if(head)\\n            listTraverse(head,head);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    \\n    void reorderList(ListNode* head) {\\n        \\n        // no update needed for 0 or 1 elements\\n        if(!head || !head->next) return;\\n        \\n        int n = 0;\\n        ListNode * node = head;\\n        ListNode * tnode = NULL;\\n        stack<ListNode *>stak;\\n        \\n        // add all nodes to stack and count total nodes n\\n        while(node!=NULL)\\n        {\\n            stak.push(node);\\n            node = node->next;\\n            n++;\\n        }\\n        \\n        // loop through stack and pop item from top n/2 times\\n        // add item to the next of current node and set current->next as item->next\\n        node = head;\\n        for(int i=0;i<=n/2;i++)\\n        {\\n            tnode = stak.top();\\n            stak.pop();\\n            tnode->next = node->next;\\n            node->next = tnode;\\n            node = tnode->next;\\n        }\\n\\n        // set last node\\'s next as NULL to terminate list\\n        node->next = NULL;\\n                \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 703982,
                "title": "easy-to-understand-in-two-pass-python-solution",
                "content": "```\\n# Definition for singly-linked list.\\n# class ListNode(object):\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution(object):\\n    def reorderList(self, head):\\n        \"\"\"\\n        :type head: ListNode\\n        :rtype: None Do not return anything, modify head in-place instead.\\n        \"\"\"\\n        l = []\\n        temp = head\\n        if not head:\\n            return None\\n        while temp:\\n            l.append(temp)\\n            temp = temp.next\\n        start = 0\\n        end = len(l)-1\\n        \\n        while start < end:\\n            l[start].next = l[end]\\n            l[end].next = l[start+1]\\n            start +=1\\n            end -=1\\n            \\n        if len(l)%2 ==0:\\n            l[start].next = None\\n        else:\\n            l[end].next = None\\n        return head\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\n# Definition for singly-linked list.\\n# class ListNode(object):\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution(object):\\n    def reorderList(self, head):\\n        \"\"\"\\n        :type head: ListNode\\n        :rtype: None Do not return anything, modify head in-place instead.\\n        \"\"\"\\n        l = []\\n        temp = head\\n        if not head:\\n            return None\\n        while temp:\\n            l.append(temp)\\n            temp = temp.next\\n        start = 0\\n        end = len(l)-1\\n        \\n        while start < end:\\n            l[start].next = l[end]\\n            l[end].next = l[start+1]\\n            start +=1\\n            end -=1\\n            \\n        if len(l)%2 ==0:\\n            l[start].next = None\\n        else:\\n            l[end].next = None\\n        return head\\n```",
                "codeTag": "Java"
            },
            {
                "id": 675556,
                "title": "python-stack-o-n-time-o-n-space-beats-95-with-comments",
                "content": "```python\\nclass Solution:\\n    def reorderList(self, head: ListNode) -> None:\\n        if not head or not head.next:\\n            return head\\n        a = head\\n        a_nxt = head.next\\n        # create a stack with the nodes\\n        stack = []\\n        while head:\\n            stack.append(head)\\n            head = head.next\\n        b = stack.pop() # b pointer is the last node\\n        b_prev = None   # b_prev is the node before the last\\n        while a != b_prev and b != a_nxt:\\n            b_prev = stack.pop()\\n            a.next = b\\n            b.next = a_nxt\\n            b_prev.next = None\\n            # update a, b and a_nxt pointers \\n            a = a_nxt\\n            b = b_prev\\n            a_nxt = a.next\\n```",
                "solutionTags": [
                    "Python",
                    "Stack"
                ],
                "code": "```python\\nclass Solution:\\n    def reorderList(self, head: ListNode) -> None:\\n        if not head or not head.next:\\n            return head\\n        a = head\\n        a_nxt = head.next\\n        # create a stack with the nodes\\n        stack = []\\n        while head:\\n            stack.append(head)\\n            head = head.next\\n        b = stack.pop() # b pointer is the last node\\n        b_prev = None   # b_prev is the node before the last\\n        while a != b_prev and b != a_nxt:\\n            b_prev = stack.pop()\\n            a.next = b\\n            b.next = a_nxt\\n            b_prev.next = None\\n            # update a, b and a_nxt pointers \\n            a = a_nxt\\n            b = b_prev\\n            a_nxt = a.next\\n```",
                "codeTag": "Java"
            },
            {
                "id": 537223,
                "title": "go-8ms-solution",
                "content": "Runtime: 8 ms, faster than 93.15% of Go online submissions for Reorder List.\\nMemory Usage: 6 MB, less than 25.00% of Go online submissions for Reorder List.\\n\\n```\\nfunc reorderList(head *ListNode) {\\n    if head == nil {\\n        return\\n    }\\n    \\n    list := []*ListNode{}\\n    tmp := head\\n    \\n    for tmp != nil {\\n        list = append(list, tmp)\\n        tmp = tmp.Next\\n    }\\n\\n    h := head\\n    for i := len(list)-1; i > (len(list)-1)/2; i-- {\\n        next := h.Next\\n        h.Next = list[i]\\n        h.Next.Next = next\\n        h = next\\n    }\\n    h.Next = nil\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc reorderList(head *ListNode) {\\n    if head == nil {\\n        return\\n    }\\n    \\n    list := []*ListNode{}\\n    tmp := head\\n    \\n    for tmp != nil {\\n        list = append(list, tmp)\\n        tmp = tmp.Next\\n    }\\n\\n    h := head\\n    for i := len(list)-1; i > (len(list)-1)/2; i-- {\\n        next := h.Next\\n        h.Next = list[i]\\n        h.Next.Next = next\\n        h = next\\n    }\\n    h.Next = nil\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 512830,
                "title": "c-singly-as-doubly-o-1-space-o-n-time-no-additional-data-structure",
                "content": "```\\n#define xor_ptrs(p1, p2)    ((uintptr_t)(p1) ^ (uintptr_t)(p2))\\n\\nvoid reorderList(struct ListNode* head){    \\n    int num_nodes = 0;\\n    struct ListNode *prev = NULL;\\n    for (struct ListNode *cur = head, *next; cur; num_nodes++) {\\n        next = cur->next; \\n        cur->next = xor_ptrs(prev, cur->next);  // Abstract singly-linked-list as doubly-linked-list\\n        prev = cur;\\n        cur = next;         \\n    }\\n    struct ListNode *front = head, *back = prev, *fprev = NULL, *fnext = NULL, *bprev = NULL, *bnext = NULL;\\n    for (int i = 1 + !(num_nodes & 0x1); i <= num_nodes / 2; i++) {\\n        fnext = xor_ptrs(front->next, fprev); // Restore the original\\n        bnext = xor_ptrs(back->next, bprev);\\n        front->next = back; // Do the reordering\\n        back->next = fnext;        \\n        fprev = front; // Move back and forth\\n        bprev = back;\\n        front = fnext;\\n        back = bnext;\\n    }\\n    fnext ? (fnext->next = bnext) : (num_nodes && (prev->next = NULL)); // Remaining fixups\\n    bnext ? (bnext->next = NULL) : 0;\\n}\\n\\n```\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n#define xor_ptrs(p1, p2)    ((uintptr_t)(p1) ^ (uintptr_t)(p2))\\n\\nvoid reorderList(struct ListNode* head){    \\n    int num_nodes = 0;\\n    struct ListNode *prev = NULL;\\n    for (struct ListNode *cur = head, *next; cur; num_nodes++) {\\n        next = cur->next; \\n        cur->next = xor_ptrs(prev, cur->next);  // Abstract singly-linked-list as doubly-linked-list\\n        prev = cur;\\n        cur = next;         \\n    }\\n    struct ListNode *front = head, *back = prev, *fprev = NULL, *fnext = NULL, *bprev = NULL, *bnext = NULL;\\n    for (int i = 1 + !(num_nodes & 0x1); i <= num_nodes / 2; i++) {\\n        fnext = xor_ptrs(front->next, fprev); // Restore the original\\n        bnext = xor_ptrs(back->next, bprev);\\n        front->next = back; // Do the reordering\\n        back->next = fnext;        \\n        fprev = front; // Move back and forth\\n        bprev = back;\\n        front = fnext;\\n        back = bnext;\\n    }\\n    fnext ? (fnext->next = bnext) : (num_nodes && (prev->next = NULL)); // Remaining fixups\\n    bnext ? (bnext->next = NULL) : 0;\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 414444,
                "title": "a-simple-recursion-based-o-n-python-solution",
                "content": "\\tdef reorderList(self, head):\\n        \"\"\"\\n        :type head: ListNode\\n        :rtype: None Do not return anything, modify head in-place instead.\\n        \"\"\"\\n        def reorder(cur, root):\\n            if not cur:\\n                return root\\n            node = reorder(cur.next, root)\\n            if not node:\\n                return node\\n            if node == cur or node.next == cur:\\n                cur.next = None\\n            else:    \\n                cur.next = node.next\\n                node.next = cur\\n            return cur.next\\n        \\n        reorder(head,head)",
                "solutionTags": [],
                "code": "\\tdef reorderList(self, head):\\n        \"\"\"\\n        :type head: ListNode\\n        :rtype: None Do not return anything, modify head in-place instead.\\n        \"\"\"\\n        def reorder(cur, root):\\n            if not cur:\\n                return root\\n            node = reorder(cur.next, root)\\n            if not node:\\n                return node\\n            if node == cur or node.next == cur:\\n                cur.next = None\\n            else:    \\n                cur.next = node.next\\n                node.next = cur\\n            return cur.next\\n        \\n        reorder(head,head)",
                "codeTag": "Python3"
            },
            {
                "id": 347502,
                "title": "simple-python-solution",
                "content": "```\\nclass Solution:\\n    def reverseList(self, head: ListNode) -> ListNode:\\n        p = None\\n        while head:\\n            q = head.next\\n            head.next = p\\n            p = head\\n            head = q\\n        return p\\n\\n    def reorderList(self, head: ListNode) -> None:\\n        if not head or not head.next:\\n            return \\n        slow, fast = head, head.next\\n        while fast and fast.next:\\n            slow = slow.next\\n            fast = fast.next.next\\n        head1 = self.reverseList(slow.next)\\n        slow.next = None\\n        p = head\\n        q = head1\\n        while q:\\n            p_nxt = p.next\\n            q_nxt = q.next\\n            p.next = q\\n            q.next = p_nxt\\n            p = p_nxt\\n            q = q_nxt\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def reverseList(self, head: ListNode) -> ListNode:\\n        p = None\\n        while head:\\n            q = head.next\\n            head.next = p\\n            p = head\\n            head = q\\n        return p\\n\\n    def reorderList(self, head: ListNode) -> None:\\n        if not head or not head.next:\\n            return \\n        slow, fast = head, head.next\\n        while fast and fast.next:\\n            slow = slow.next\\n            fast = fast.next.next\\n        head1 = self.reverseList(slow.next)\\n        slow.next = None\\n        p = head\\n        q = head1\\n        while q:\\n            p_nxt = p.next\\n            q_nxt = q.next\\n            p.next = q\\n            q.next = p_nxt\\n            p = p_nxt\\n            q = q_nxt\\n```",
                "codeTag": "Java"
            },
            {
                "id": 327883,
                "title": "c-o-n-time-complexity-o-1-space-complexity-in-place-90-beat",
                "content": "```\\nclass Solution {\\npublic:\\n    void reorderList(ListNode* head) {\\n        \\n        //Find the middle of the linked list...\\n        ListNode *aNode = head;\\n        ListNode *aMid = head;\\n        while (aNode != NULL && aNode->next != NULL) {\\n            aMid = aMid->next;\\n            aNode = aNode->next->next;\\n        }\\n        \\n        if (aMid == head) { return; }\\n        \\n        ListNode *aNext = aMid->next;\\n        aMid->next = NULL;\\n        aMid = aNext;\\n        if (aMid == NULL) { return; }\\n        \\n        \\n        //Reverse the 2nd half of the linked list...\\n        ListNode *aPrev = NULL;\\n        while (aMid != NULL) {\\n            aNext = aMid->next;\\n            aMid->next = aPrev;\\n            aPrev = aMid;\\n            aMid = aNext;\\n        }\\n        \\n        \\n        //Interleave the two portions of the list...\\n        aMid = aPrev;\\n        aNode = head;\\n        while (aMid != NULL && aNode != NULL) {\\n            aNext = aNode->next;\\n            aNode->next = aMid;\\n            aNode = aNext;\\n            \\n            aNext = aMid->next;\\n            aMid->next = aNode;\\n            aMid = aNext;\\n        }\\n    }\\n};\\n```\\n\\nThis differes from previously submitted solution, condenses 3rd loop into something more efficient. We can always advance the \"mid\" pointer once before reversing. The middle of the list will meet the same either way. I know this through empirical testing.",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    void reorderList(ListNode* head) {\\n        \\n        //Find the middle of the linked list...\\n        ListNode *aNode = head;\\n        ListNode *aMid = head;\\n        while (aNode != NULL && aNode->next != NULL) {\\n            aMid = aMid->next;\\n            aNode = aNode->next->next;\\n        }\\n        \\n        if (aMid == head) { return; }\\n        \\n        ListNode *aNext = aMid->next;\\n        aMid->next = NULL;\\n        aMid = aNext;\\n        if (aMid == NULL) { return; }\\n        \\n        \\n        //Reverse the 2nd half of the linked list...\\n        ListNode *aPrev = NULL;\\n        while (aMid != NULL) {\\n            aNext = aMid->next;\\n            aMid->next = aPrev;\\n            aPrev = aMid;\\n            aMid = aNext;\\n        }\\n        \\n        \\n        //Interleave the two portions of the list...\\n        aMid = aPrev;\\n        aNode = head;\\n        while (aMid != NULL && aNode != NULL) {\\n            aNext = aNode->next;\\n            aNode->next = aMid;\\n            aNode = aNext;\\n            \\n            aNext = aMid->next;\\n            aMid->next = aNode;\\n            aMid = aNext;\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 327847,
                "title": "c-98-beat-o-n-simple-technique-o-n-extra-memory-koderz-kamp",
                "content": "```\\nclass Solution {\\npublic:\\n    void reorderList(ListNode* head) {\\n        \\n        vector<ListNode*> aList;\\n        \\n        ListNode *aNode = head;\\n        ListNode *aNext;\\n        while (aNode) {\\n            aNext = aNode->next;\\n            aNode->next = NULL;\\n            aList.push_back(aNode);\\n            aNode = aNext;\\n        }\\n        \\n        int aLo = 1;\\n        int aHi = aList.size() - 1;\\n        \\n        aNode = head;\\n        \\n        while (aLo <= aHi) {\\n            aNode->next = aList[aHi--];\\n            aNode = aNode->next;\\n            if (aLo <= aHi) {\\n                aNode->next = aList[aLo++];\\n                aNode = aNode->next;\\n            }    \\n        }\\n    }\\n};\\n```\\n\\nThere must be a way to do it without requiring extra memory - I can\\'t think of it yet since the nodes only have 1 direction pointer.",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    void reorderList(ListNode* head) {\\n        \\n        vector<ListNode*> aList;\\n        \\n        ListNode *aNode = head;\\n        ListNode *aNext;\\n        while (aNode) {\\n            aNext = aNode->next;\\n            aNode->next = NULL;\\n            aList.push_back(aNode);\\n            aNode = aNext;\\n        }\\n        \\n        int aLo = 1;\\n        int aHi = aList.size() - 1;\\n        \\n        aNode = head;\\n        \\n        while (aLo <= aHi) {\\n            aNode->next = aList[aHi--];\\n            aNode = aNode->next;\\n            if (aLo <= aHi) {\\n                aNode->next = aList[aLo++];\\n                aNode = aNode->next;\\n            }    \\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 231267,
                "title": "javascript-o-n-time-o-1-space-beats-100",
                "content": "```js\\n/**\\n * Definition for singly-linked list.\\n * function ListNode(val) {\\n *     this.val = val;\\n *     this.next = null;\\n * }\\n */\\n/**\\n * @param {ListNode} head\\n * @return {void} Do not return anything, modify head in-place instead.\\n */\\nvar reorderList = function(head) {\\n  if (!head || !head.next) return head\\n  \\n  // 1. find the middle node O(n)\\n  let slow = head\\n  let fast = head.next\\n  \\n  while (fast && fast.next) {\\n    fast = fast.next.next\\n    slow = slow.next\\n  }\\n  \\n  // 2. reverse from middle\\n  let newHead = null\\n  let curr = slow.next\\n  slow.next = null\\n  \\n  while (curr) {\\n    const next = curr.next\\n    curr.next = newHead\\n    newHead = curr\\n    curr = next\\n  }\\n\\n  // 3. merge mid and head\\n  let currHead = head\\n  let currMid = newHead\\n  \\n  while (currHead && currMid) {\\n    const headNext = currHead.next\\n    const midNext = currMid.next\\n    \\n    currHead.next = currMid\\n    currMid.next = headNext\\n    \\n    currHead = headNext\\n    currMid = midNext\\n  }\\n  \\n  return head\\n};\\n```",
                "solutionTags": [],
                "code": "```js\\n/**\\n * Definition for singly-linked list.\\n * function ListNode(val) {\\n *     this.val = val;\\n *     this.next = null;\\n * }\\n */\\n/**\\n * @param {ListNode} head\\n * @return {void} Do not return anything, modify head in-place instead.\\n */\\nvar reorderList = function(head) {\\n  if (!head || !head.next) return head\\n  \\n  // 1. find the middle node O(n)\\n  let slow = head\\n  let fast = head.next\\n  \\n  while (fast && fast.next) {\\n    fast = fast.next.next\\n    slow = slow.next\\n  }\\n  \\n  // 2. reverse from middle\\n  let newHead = null\\n  let curr = slow.next\\n  slow.next = null\\n  \\n  while (curr) {\\n    const next = curr.next\\n    curr.next = newHead\\n    newHead = curr\\n    curr = next\\n  }\\n\\n  // 3. merge mid and head\\n  let currHead = head\\n  let currMid = newHead\\n  \\n  while (currHead && currMid) {\\n    const headNext = currHead.next\\n    const midNext = currMid.next\\n    \\n    currHead.next = currMid\\n    currMid.next = headNext\\n    \\n    currHead = headNext\\n    currMid = midNext\\n  }\\n  \\n  return head\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 221373,
                "title": "python-split-reverse-merge-solution-o-n-time-o-1-space",
                "content": "```\\nclass Solution:\\n    def reorderList(self, head):\\n        \"\"\"\\n        :type head: ListNode\\n        :rtype: void Do not return anything, modify head in-place instead.\\n        \"\"\"\\n        if not head:\\n            return\\n        \\n        mid = find_middle(head)\\n        tail = reverse(mid.next)\\n        mid.next = None\\n        \\n        merge(head, tail)\\n        \\n\\ndef find_middle(head):\\n    slow = fast = head\\n    \\n    while fast and fast.next and fast.next.next:\\n        fast = fast.next.next\\n        slow = slow.next\\n    \\n    return slow\\n        \\n\\ndef reverse(head):\\n    prev = None\\n    \\n    cur = head\\n    while cur:\\n        tmp = cur.next\\n        cur.next = prev\\n        prev = cur\\n        cur = tmp\\n    \\n    return prev\\n\\n\\ndef merge(l1, l2):\\n    dummy_head = ListNode(0)\\n    cur = dummy_head\\n    \\n    while l1 or l2:\\n        cur.next = l1\\n        cur = cur.next\\n        l1 = l1.next\\n        l1, l2 = l2, l1\\n    \\n    return dummy_head.next\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def reorderList(self, head):\\n        \"\"\"\\n        :type head: ListNode\\n        :rtype: void Do not return anything, modify head in-place instead.\\n        \"\"\"\\n        if not head:\\n            return\\n        \\n        mid = find_middle(head)\\n        tail = reverse(mid.next)\\n        mid.next = None\\n        \\n        merge(head, tail)\\n        \\n\\ndef find_middle(head):\\n    slow = fast = head\\n    \\n    while fast and fast.next and fast.next.next:\\n        fast = fast.next.next\\n        slow = slow.next\\n    \\n    return slow\\n        \\n\\ndef reverse(head):\\n    prev = None\\n    \\n    cur = head\\n    while cur:\\n        tmp = cur.next\\n        cur.next = prev\\n        prev = cur\\n        cur = tmp\\n    \\n    return prev\\n\\n\\ndef merge(l1, l2):\\n    dummy_head = ListNode(0)\\n    cur = dummy_head\\n    \\n    while l1 or l2:\\n        cur.next = l1\\n        cur = cur.next\\n        l1 = l1.next\\n        l1, l2 = l2, l1\\n    \\n    return dummy_head.next\\n```",
                "codeTag": "Java"
            },
            {
                "id": 44986,
                "title": "c-clean-solution-with-explaination",
                "content": "```\\n     void reorderList(ListNode* head) {\\n        if(!head) return;\\n        ListNode* slow = head;\\n        ListNode* fast = head->next;\\n        while(fast && fast->next){\\n            fast = fast->next->next;\\n            slow = slow->next;\\n        }\\n        fast = slow->next;   // find the middle of the list\\n        slow->next = NULL;   // and set the end of the first list as NULL\\n        slow = fast;         // set \"slow\" as the head of the second list\\n        \\n        ListNode* pre = NULL; // reverse the second list, its head becomes \"pre\"\\n        while(slow){\\n            ListNode* temp = slow->next;\\n            slow->next = pre;\\n            pre = slow;\\n            slow = temp;\\n        }\\n        \\n        ListNode* l1 = head;  //set l1 as the head of the first list\\n        ListNode* l2 = pre;   //set l2 as the head of the reverse second list and combine them\\n        while(l1 && l2){\\n            ListNode* temp1 = l1->next;\\n            ListNode* temp2 = l2->next;\\n            l1->next = l2;\\n            l2->next = temp1;\\n            l1 = temp1;\\n            l2 = temp2;\\n        }\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n     void reorderList(ListNode* head) {\\n        if(!head) return;\\n        ListNode* slow = head;\\n        ListNode* fast = head->next;\\n        while(fast && fast->next){\\n            fast = fast->next->next;\\n            slow = slow->next;\\n        }\\n        fast = slow->next;   // find the middle of the list\\n        slow->next = NULL;   // and set the end of the first list as NULL\\n        slow = fast;         // set \"slow\" as the head of the second list\\n        \\n        ListNode* pre = NULL; // reverse the second list, its head becomes \"pre\"\\n        while(slow){\\n            ListNode* temp = slow->next;\\n            slow->next = pre;\\n            pre = slow;\\n            slow = temp;\\n        }\\n        \\n        ListNode* l1 = head;  //set l1 as the head of the first list\\n        ListNode* l2 = pre;   //set l2 as the head of the reverse second list and combine them\\n        while(l1 && l2){\\n            ListNode* temp1 = l1->next;\\n            ListNode* temp2 = l2->next;\\n            l1->next = l2;\\n            l2->next = temp1;\\n            l1 = temp1;\\n            l2 = temp2;\\n        }\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 45037,
                "title": "c-split-reverse-tail-merge",
                "content": "same basic 3 steps as others.  \\n\\n1) Find middle (leaving odd number to the front, tail will be smaller or same size)\\n2) reverse tail\\n3) merge front with tail, alternating nodes.\\n\\n```\\n    public void ReorderList(ListNode head) \\n    {\\n        if (head == null) return;\\n        ListNode head2 = Split(head);\\n        head2 = Reverse(head2);\\n        Merge(head, head2);\\n    }\\n    \\n    public ListNode Split(ListNode head)\\n    {\\n        ListNode slow = head;\\n        ListNode fast = head.next;\\n        \\n        while (fast != null && fast.next != null)\\n        {\\n            slow = slow.next;\\n            fast = fast.next.next;\\n        }\\n        \\n        ListNode head2 = slow.next;\\n        slow.next = null;\\n        return head2;\\n    }\\n    \\n    public ListNode Reverse(ListNode head)\\n    {\\n        ListNode curr = head;\\n        ListNode prev = null;\\n        \\n        while (curr != null)\\n        {\\n            ListNode next = curr.next;\\n            curr.next = prev;\\n            prev = curr;\\n            curr = next;\\n        }\\n        \\n        return prev;\\n    }\\n    \\n    public ListNode Merge(ListNode head1, ListNode head2)\\n    {\\n        ListNode curr1 = head1;\\n        ListNode curr2 = head2;\\n        \\n        while (curr1 != null && curr2 != null)\\n        {\\n            ListNode next1 = curr1.next;\\n            ListNode next2 = curr2.next;\\n            \\n            curr1.next = curr2;\\n            curr2.next = next1;\\n            \\n            curr1 = next1;\\n            curr2 = next2;\\n        }\\n        \\n        return head1;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public void ReorderList(ListNode head) \\n    {\\n        if (head == null) return;\\n        ListNode head2 = Split(head);\\n        head2 = Reverse(head2);\\n        Merge(head, head2);\\n    }\\n    \\n    public ListNode Split(ListNode head)\\n    {\\n        ListNode slow = head;\\n        ListNode fast = head.next;\\n        \\n        while (fast != null && fast.next != null)\\n        {\\n            slow = slow.next;\\n            fast = fast.next.next;\\n        }\\n        \\n        ListNode head2 = slow.next;\\n        slow.next = null;\\n        return head2;\\n    }\\n    \\n    public ListNode Reverse(ListNode head)\\n    {\\n        ListNode curr = head;\\n        ListNode prev = null;\\n        \\n        while (curr != null)\\n        {\\n            ListNode next = curr.next;\\n            curr.next = prev;\\n            prev = curr;\\n            curr = next;\\n        }\\n        \\n        return prev;\\n    }\\n    \\n    public ListNode Merge(ListNode head1, ListNode head2)\\n    {\\n        ListNode curr1 = head1;\\n        ListNode curr2 = head2;\\n        \\n        while (curr1 != null && curr2 != null)\\n        {\\n            ListNode next1 = curr1.next;\\n            ListNode next2 = curr2.next;\\n            \\n            curr1.next = curr2;\\n            curr2.next = next1;\\n            \\n            curr1 = next1;\\n            curr2 = next2;\\n        }\\n        \\n        return head1;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 45099,
                "title": "java-iterative-in-place-solution",
                "content": "        \\n    public void reorderList(ListNode head) {\\n        if (head == null || head.next == null || head.next.next == null) {\\n            return;\\n        }\\n        ListNode slow = head, fast = head.next; // take care here\\n        while (fast != null && fast.next != null) {\\n            fast = fast.next.next;\\n            slow = slow.next;\\n        }\\n        ListNode p = slow.next, node = null;\\n        slow.next = null;  // cut the first part\\n        while (p != null) {  // reverse the second part\\n            ListNode nxt = p.next;\\n            p.next = node;\\n            node = p;\\n            p = nxt;\\n        }\\n        while (node != null) {  // merge two lists\\n            ListNode nxt = node.next;\\n            node.next = head.next;\\n            head.next = node;\\n            head = head.next.next;\\n            node = nxt;\\n        }\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "        \\n    public void reorderList(ListNode head) {\\n        if (head == null || head.next == null || head.next.next == null) {\\n            return;\\n        }\\n        ListNode slow = head, fast = head.next; // take care here\\n        while (fast != null && fast.next != null) {\\n            fast = fast.next.next;\\n            slow = slow.next;\\n        }\\n        ListNode p = slow.next, node = null;\\n        slow.next = null;  // cut the first part\\n        while (p != null) {  // reverse the second part\\n            ListNode nxt = p.next;\\n            p.next = node;\\n            node = p;\\n            p = nxt;\\n        }\\n        while (node != null) {  // merge two lists\\n            ListNode nxt = node.next;\\n            node.next = head.next;\\n            head.next = node;\\n            head = head.next.next;\\n            node = nxt;\\n        }\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 45116,
                "title": "20ms-simple-c-solution-with-comments",
                "content": "    /**\\n     * Definition for singly-linked list.\\n     * struct ListNode {\\n     *     int val;\\n     *     struct ListNode *next;\\n     * };\\n     */\\n    struct ListNode* revertList(struct ListNode* head) {\\n        if(head == NULL || head->next == NULL) {\\n            return head;\\n        }\\n        \\n        struct ListNode* prev = NULL;\\n        struct ListNode* cur = head;\\n        struct ListNode* next = NULL;\\n        \\n        while(cur != NULL) {\\n            next = cur->next;\\n            \\n            cur->next = prev;\\n            prev = cur;\\n            cur = next;\\n        }\\n        \\n        return prev;\\n    }\\n     \\n    void reorderList(struct ListNode* head) {\\n        struct ListNode* newHead = NULL;\\n        struct ListNode* newNode = NULL;\\n        struct ListNode* node = head;\\n        \\n        if(head == NULL || head->next == NULL) {\\n            return;\\n        }\\n        \\n        //find the middle nodes\\n        struct ListNode* slow = head;\\n        struct ListNode* fast = head->next->next;\\n        while(fast != NULL && fast->next != NULL) {\\n            slow = slow->next;\\n            fast = fast->next->next;\\n        }\\n        \\n        if(fast != NULL) {\\n            slow = slow->next;\\n        }\\n        \\n        newHead = slow->next;\\n        slow->next = NULL;\\n        \\n        //revert the 2nd linklist\\n        newHead = revertList(newHead);\\n        \\n        //merge 2 link list together\\n        newNode = newHead;\\n        node = head;\\n        int index = 0;\\n        while(newNode != NULL && node != NULL) {\\n            if((index % 2) == 0) {\\n                struct ListNode* next = node->next;\\n                node->next = newNode;\\n                node = next;\\n            }\\n            else {\\n                struct ListNode* next = newNode->next;\\n                newNode->next = node;\\n                newNode = next;\\n            }\\n            index++;\\n        }\\n    }",
                "solutionTags": [],
                "code": "    /**\\n     * Definition for singly-linked list.\\n     * struct ListNode {\\n     *     int val;\\n     *     struct ListNode *next;\\n     * };\\n     */\\n    struct ListNode* revertList(struct ListNode* head) {\\n        if(head == NULL || head->next == NULL) {\\n            return head;\\n        }\\n        \\n        struct ListNode* prev = NULL;\\n        struct ListNode* cur = head;\\n        struct ListNode* next = NULL;\\n        \\n        while(cur != NULL) {\\n            next = cur->next;\\n            \\n            cur->next = prev;\\n            prev = cur;\\n            cur = next;\\n        }\\n        \\n        return prev;\\n    }\\n     \\n    void reorderList(struct ListNode* head) {\\n        struct ListNode* newHead = NULL;\\n        struct ListNode* newNode = NULL;\\n        struct ListNode* node = head;\\n        \\n        if(head == NULL || head->next == NULL) {\\n            return;\\n        }\\n        \\n        //find the middle nodes\\n        struct ListNode* slow = head;\\n        struct ListNode* fast = head->next->next;\\n        while(fast != NULL && fast->next != NULL) {\\n            slow = slow->next;\\n            fast = fast->next->next;\\n        }\\n        \\n        if(fast != NULL) {\\n            slow = slow->next;\\n        }\\n        \\n        newHead = slow->next;\\n        slow->next = NULL;\\n        \\n        //revert the 2nd linklist\\n        newHead = revertList(newHead);\\n        \\n        //merge 2 link list together\\n        newNode = newHead;\\n        node = head;\\n        int index = 0;\\n        while(newNode != NULL && node != NULL) {\\n            if((index % 2) == 0) {\\n                struct ListNode* next = node->next;\\n                node->next = newNode;\\n                node = next;\\n            }\\n            else {\\n                struct ListNode* next = newNode->next;\\n                newNode->next = node;\\n                newNode = next;\\n            }\\n            index++;\\n        }\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 45134,
                "title": "clear-and-simple-java-o-n-solution-with-o-1-extra-space",
                "content": "    public class Solution {\\n        public void reorderList(ListNode head) {\\n            if (head == null || head.next == null) return;\\n            ListNode slow = head;\\n            ListNode fast = head;\\n            while (fast != null && fast.next != null) {\\n                slow = slow.next;\\n                fast = fast.next.next;\\n            }\\n            ListNode n2 = reverse(slow.next);\\n            slow.next = null;\\n            combine(head, n2);\\n        }\\n        private ListNode reverse(ListNode head) {\\n            if (head == null || head.next == null) return head;\\n            ListNode preHead = new ListNode(0);\\n            ListNode runner = head;\\n            while (runner != null) {\\n                ListNode tmp = preHead.next;\\n                preHead.next = runner;\\n                runner = runner.next;\\n                preHead.next.next = tmp;\\n            }\\n            return preHead.next;\\n        }\\n        private void combine(ListNode n1, ListNode n2) {\\n            if (n1 == null || n2 == null) return;\\n            ListNode preHead = new ListNode(0);\\n            ListNode runner = preHead;\\n            while (n1 != null && n2 != null) {\\n                runner.next = n1;\\n                n1 = n1.next;\\n                runner.next.next = n2;\\n                n2 = n2.next;\\n                runner = runner.next.next;\\n            }\\n            runner.next = n1 == null ? n2 : n1;\\n        }\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n        public void reorderList(ListNode head) {\\n            if (head == null || head.next == null) return;\\n            ListNode slow = head;\\n            ListNode fast = head;\\n            while (fast != null && fast.next != null) {\\n                slow = slow.next;\\n                fast = fast.next.next;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3772694,
                "title": "easy-link-connection-method-c-simple-solution",
                "content": "\\n\\n\\n    class Solution {\\n    public:\\n    \\n    ListNode* reverse(ListNode* head){\\n        if(head==NULL or head->next==NULL)return head;\\n        ListNode* p=reverse(head->next);\\n        head->next->next=head;\\n        head->next=NULL;\\n        return p;\\n    }\\n    \\n    void reorderList(ListNode* head) {\\n        ListNode* slow=head;\\n        ListNode* p=head;\\n        ListNode* fast=head;\\n        while(fast!=NULL and fast->next!=NULL){\\n            slow=slow->next;\\n            fast=fast->next->next;\\n        }\\n        slow=reverse(slow);\\n        ListNode* r=head;\\n        while(p->next!=NULL and slow->next!=NULL){\\n            p=p->next;\\n            r->next=slow;\\n            slow=slow->next;\\n            r->next->next=p;\\n            r=p;\\n         }\\n       }\\n    };",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\n    public:\\n    \\n    ListNode* reverse(ListNode* head){\\n        if(head==NULL or head->next==NULL)return head;\\n        ListNode* p=reverse(head->next);\\n        head->next->next=head;\\n        head->next=NULL;\\n        return p;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 3412830,
                "title": "c-recursion-solution-simple-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution\\n{\\npublic:\\n    void solve(ListNode *head, ListNode *next){\\n        if (head->next == NULL || head->next->next == NULL)  return;\\n\\n        ListNode *temp = head;\\n        ListNode *prev;\\n        while (temp->next){\\n            prev = temp;\\n            temp = temp->next;\\n        }\\n\\n        next = head->next;\\n        head->next = temp;\\n        temp->next = next;\\n        head = temp;\\n        prev->next = NULL;\\n        solve(head->next, next);\\n    }\\n    void reorderList(ListNode *head){\\n        ListNode *temp = head;\\n        ListNode *next = NULL;\\n        solve(temp, next);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution\\n{\\npublic:\\n    void solve(ListNode *head, ListNode *next){\\n        if (head->next == NULL || head->next->next == NULL)  return;\\n\\n        ListNode *temp = head;\\n        ListNode *prev;\\n        while (temp->next){\\n            prev = temp;\\n            temp = temp->next;\\n        }\\n\\n        next = head->next;\\n        head->next = temp;\\n        temp->next = next;\\n        head = temp;\\n        prev->next = NULL;\\n        solve(head->next, next);\\n    }\\n    void reorderList(ListNode *head){\\n        ListNode *temp = head;\\n        ListNode *next = NULL;\\n        solve(temp, next);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3332795,
                "title": "solution-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    void reorderList(ListNode* head)\\n     {\\n        if ((!head) || (!head->next) || (!head->next->next)) return;\\n        stack<ListNode*> my_stack;\\n        ListNode* ptr = head;\\n        int size = 0;\\n        while (ptr != NULL) \\n        {\\n            my_stack.push(ptr);\\n            size++;\\n            ptr = ptr->next;\\n        }\\n        ListNode* pptr = head;\\n        for (int j=0; j<size/2; j++) \\n        {\\n            ListNode *element = my_stack.top();\\n            my_stack.pop();\\n            element->next = pptr->next;\\n            pptr->next = element;\\n            pptr = pptr->next->next;\\n        }\\n        pptr->next = NULL;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    void reorderList(ListNode* head)\\n     {\\n        if ((!head) || (!head->next) || (!head->next->next)) return;\\n        stack<ListNode*> my_stack;\\n        ListNode* ptr = head;\\n        int size = 0;\\n        while (ptr != NULL) \\n        {\\n            my_stack.push(ptr);\\n            size++;\\n            ptr = ptr->next;\\n        }\\n        ListNode* pptr = head;\\n        for (int j=0; j<size/2; j++) \\n        {\\n            ListNode *element = my_stack.top();\\n            my_stack.pop();\\n            element->next = pptr->next;\\n            pptr->next = element;\\n            pptr = pptr->next->next;\\n        }\\n        pptr->next = NULL;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3321020,
                "title": "easy-soln-find-middle-reverse-second-half-merge-both",
                "content": "# Intuition\\n---> REVERSING THE SECOND HALF AND MERGING BOTH <--\\n\\n# Approach\\nSIMPLE APPROACH\\n---> REVERSING THE SECOND HALF AND MERGING BOTH <--\\nSTEP 1 : By using Slow and Fast Pointer method find the middle of the Linked List\\nSTEP 2 : And then reversing the Second half of the Linked List\\nSTEP 3 : Now merge First and Second half of the Linked List\\n\\n# Complexity\\n- Time complexity:\\nHere the time complexity of the soln is -> O(n)\\n\\n- Space complexity:\\nHere the space complexity of the soln is -> O(1)\\n\\n# Code\\nclass Solution {\\npublic:\\n    ListNode* Reverse(ListNode* head)\\n    {\\n        ListNode* curr = head;\\n        ListNode* prev = NULL;\\n        ListNode* ptr = NULL;\\n\\n        while(curr != NULL)\\n        {\\n            ptr = curr -> next;\\n            curr -> next = prev;\\n            prev = curr;\\n            curr = ptr;\\n        }\\n        return prev;\\n    }\\n\\n    void reorderList(ListNode* head) \\n    {\\n        // Return Ans If Linked List is Empty OR Have only One Node\\n        if(head -> next == NULL || head -> next -> next == NULL)\\n        {     return;     }    \\n\\n        ListNode* slow = head;\\n        ListNode* fast = head;\\n        ListNode* last = head;\\n        while(fast != NULL)\\n        {\\n            last = slow;\\n            slow = slow -> next;\\n            fast = fast -> next;\\n            if(fast != NULL)\\n            {   fast = fast -> next;  }\\n        }\\n        //Seperating First and Second Half\\n        last -> next = NULL;\\n        //Reversing Second Half\\n        ListNode* second = Reverse(slow);\\n        ListNode* first = head;\\n\\n        //Merging First And Second Half of Linked List\\n        while(second)\\n        {\\n            ListNode* temp1 = first -> next;\\n            ListNode* temp2 = second -> next;\\n\\n            first -> next = second;\\n            second -> next = temp1;\\n\\n            second = temp2;\\n            first = temp1;\\n        }\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "Linked List"
                ],
                "code": "class Solution {\\npublic:\\n    ListNode* Reverse(ListNode* head)\\n    {\\n        ListNode* curr = head;\\n        ListNode* prev = NULL;\\n        ListNode* ptr = NULL;\\n\\n        while(curr != NULL)\\n        {\\n            ptr = curr -> next;\\n            curr -> next = prev;\\n            prev = curr;\\n            curr = ptr;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3275284,
                "title": "easy-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    void reorderList(ListNode* head) {\\n        if(head==NULL) return;\\n        ListNode *temp=head;\\n        vector<int> o, e;\\n        int l=0;\\n        while(temp)\\n        {\\n           l++;    temp=temp->next;    \\n        }\\n        temp=head;\\n        int i=1;\\n        if(l%2==0)\\n                while(temp)\\n                {\\n                    if(i<=l/2)\\n                        e.push_back(temp->val);\\n                    else\\n                       o.push_back(temp->val);\\n                    i++;\\n                    temp=temp->next;\\n                }\\n        else\\n                while(temp)\\n                {                   \\n                    if(i<=((l/2)+1))\\n                        e.push_back(temp->val);\\n                    else\\n                       o.push_back(temp->val);\\n                    i++;\\n                    temp=temp->next;\\n                }\\n        temp=head;\\n        reverse(o.begin(),o.end());\\n        int p=0, q=0;\\n        i=0;\\n        while(temp)\\n        {\\n                if(i%2==0)\\n                   temp->val = e[p++];\\n                else\\n                   temp->val= o[q++];\\n                i++;\\n            temp=temp->next;\\n        }\\n\\n    }\\n};\\n\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    void reorderList(ListNode* head) {\\n        if(head==NULL) return;\\n        ListNode *temp=head;\\n        vector<int> o, e;\\n        int l=0;\\n        while(temp)\\n        {\\n           l++;    temp=temp->next;    \\n        }\\n        temp=head;\\n        int i=1;\\n        if(l%2==0)\\n                while(temp)\\n                {\\n                    if(i<=l/2)\\n                        e.push_back(temp->val);\\n                    else\\n                       o.push_back(temp->val);\\n                    i++;\\n                    temp=temp->next;\\n                }\\n        else\\n                while(temp)\\n                {                   \\n                    if(i<=((l/2)+1))\\n                        e.push_back(temp->val);\\n                    else\\n                       o.push_back(temp->val);\\n                    i++;\\n                    temp=temp->next;\\n                }\\n        temp=head;\\n        reverse(o.begin(),o.end());\\n        int p=0, q=0;\\n        i=0;\\n        while(temp)\\n        {\\n                if(i%2==0)\\n                   temp->val = e[p++];\\n                else\\n                   temp->val= o[q++];\\n                i++;\\n            temp=temp->next;\\n        }\\n\\n    }\\n};\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3228900,
                "title": "best-and-easiest-3-steps-code-in-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nIn this question we basically, do three steps:\\n    1). Find the Midddle element(slow & fast Algo).\\n    2). 2nd half reverse.\\n    3). Alternate merging.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public void reorderList(ListNode head) {\\n        // step - find mid \\n        ListNode slow = head;\\n        ListNode fast = head.next;\\n        while(fast!=null&&fast.next!=null){\\n            slow = slow.next;\\n            fast = fast.next.next;\\n        }\\n        ListNode mid = slow;\\n\\n        // reverse the 2nd half\\n        ListNode curr = mid.next;\\n        mid.next = null;\\n        ListNode prev = null;\\n        ListNode next;\\n        while(curr!=null){\\n            next = curr.next;\\n            curr.next = prev;\\n            prev = curr;\\n            curr = next;\\n        }\\n        // alternate merging\\n        ListNode left  = head;\\n        ListNode right = prev;\\n        ListNode nextL, nextR;\\n        while(left!=null && right!=null){\\n            nextL = left.next;\\n            left.next = right;\\n            nextR = right.next;\\n            right.next = nextL;\\n            left = nextL;\\n            right = nextR;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public void reorderList(ListNode head) {\\n        // step - find mid \\n        ListNode slow = head;\\n        ListNode fast = head.next;\\n        while(fast!=null&&fast.next!=null){\\n            slow = slow.next;\\n            fast = fast.next.next;\\n        }\\n        ListNode mid = slow;\\n\\n        // reverse the 2nd half\\n        ListNode curr = mid.next;\\n        mid.next = null;\\n        ListNode prev = null;\\n        ListNode next;\\n        while(curr!=null){\\n            next = curr.next;\\n            curr.next = prev;\\n            prev = curr;\\n            curr = next;\\n        }\\n        // alternate merging\\n        ListNode left  = head;\\n        ListNode right = prev;\\n        ListNode nextL, nextR;\\n        while(left!=null && right!=null){\\n            nextL = left.next;\\n            left.next = right;\\n            nextR = right.next;\\n            right.next = nextL;\\n            left = nextL;\\n            right = nextR;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3059062,
                "title": "c-easy-approach-explained-via-comments",
                "content": "\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n\\n    // Reverse a List and return head of it\\n    ListNode* reverse(ListNode* &prev, ListNode* &curr){\\n        if(curr == NULL)\\n            return prev;\\n        ListNode* forward = curr -> next;\\n        curr -> next = prev;\\n        return reverse(curr, forward);\\n    }\\n\\n\\n    // Find a middle node of an element;\\n    ListNode* findMid(ListNode* &head){\\n\\n        ListNode* slow = head;\\n        ListNode* fast = head -> next;\\n\\n        while(fast && fast->next){\\n            slow = slow -> next;\\n            fast = fast -> next -> next;\\n        }\\n        return slow;\\n    }\\n\\n\\n    void reorderList(ListNode* head) {\\n        \\n        //Base condition\\n        if(!head || !head->next )\\n            return;\\n\\n        //firstList\\n        ListNode* firstList = head;\\n\\n        //middle element\\n        ListNode* mid = findMid(head);\\n\\n        //secondList\\n        ListNode* secondList = mid->next;\\n        mid->next = NULL;\\n        \\n        //reverse second list\\n        ListNode* prev = NULL;\\n        secondList = reverse(prev, secondList);\\n\\n        ListNode* ans = new ListNode(-1);\\n        ListNode* temp = ans;\\n            \\n\\n        while(firstList != NULL){\\n\\n            temp -> next = firstList;\\n            temp = firstList;\\n            firstList = firstList -> next;\\n            \\n            if(secondList != NULL){\\n                temp -> next = secondList;\\n                temp = secondList;\\n                secondList = secondList -> next;\\n            }\\n        }\\n\\n        head = ans -> next;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n\\n    // Reverse a List and return head of it\\n    ListNode* reverse(ListNode* &prev, ListNode* &curr){\\n        if(curr == NULL)\\n            return prev;\\n        ListNode* forward = curr -> next;\\n        curr -> next = prev;\\n        return reverse(curr, forward);\\n    }\\n\\n\\n    // Find a middle node of an element;\\n    ListNode* findMid(ListNode* &head){\\n\\n        ListNode* slow = head;\\n        ListNode* fast = head -> next;\\n\\n        while(fast && fast->next){\\n            slow = slow -> next;\\n            fast = fast -> next -> next;\\n        }\\n        return slow;\\n    }\\n\\n\\n    void reorderList(ListNode* head) {\\n        \\n        //Base condition\\n        if(!head || !head->next )\\n            return;\\n\\n        //firstList\\n        ListNode* firstList = head;\\n\\n        //middle element\\n        ListNode* mid = findMid(head);\\n\\n        //secondList\\n        ListNode* secondList = mid->next;\\n        mid->next = NULL;\\n        \\n        //reverse second list\\n        ListNode* prev = NULL;\\n        secondList = reverse(prev, secondList);\\n\\n        ListNode* ans = new ListNode(-1);\\n        ListNode* temp = ans;\\n            \\n\\n        while(firstList != NULL){\\n\\n            temp -> next = firstList;\\n            temp = firstList;\\n            firstList = firstList -> next;\\n            \\n            if(secondList != NULL){\\n                temp -> next = secondList;\\n                temp = secondList;\\n                secondList = secondList -> next;\\n            }\\n        }\\n\\n        head = ans -> next;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2984352,
                "title": "c-faster-than-92-beginner-friendly-approach-clean-concise-code",
                "content": "\\n# Code\\n```\\n\\nclass Solution {\\npublic:\\n\\n    void reorderList(ListNode* head) {\\n        \\n      vector<int>v;\\n      ListNode *ptr = head, *ptr2 = head;\\n\\n      while(ptr != NULL)\\n      {\\n          v.push_back(ptr->val);\\n          ptr = ptr->next;\\n      }\\n\\n\\n      int l = 0, r = v.size()-1;\\n      int turn = 0;\\n\\n      while(ptr2!=NULL && l <= r)\\n      {\\n\\n       if(turn == 0) ptr2->val = v[l++];\\n\\n       else ptr2->val = v[r--];\\n\\n       ptr2 = ptr2->next;\\n       turn ^= 1;\\n\\n      }\\n      \\n      return;\\n      \\n    }\\n};\\n\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n\\n    void reorderList(ListNode* head) {\\n        \\n      vector<int>v;\\n      ListNode *ptr = head, *ptr2 = head;\\n\\n      while(ptr != NULL)\\n      {\\n          v.push_back(ptr->val);\\n          ptr = ptr->next;\\n      }\\n\\n\\n      int l = 0, r = v.size()-1;\\n      int turn = 0;\\n\\n      while(ptr2!=NULL && l <= r)\\n      {\\n\\n       if(turn == 0) ptr2->val = v[l++];\\n\\n       else ptr2->val = v[r--];\\n\\n       ptr2 = ptr2->next;\\n       turn ^= 1;\\n\\n      }\\n      \\n      return;\\n      \\n    }\\n};\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2862709,
                "title": "java-2-solutions-in-place-100-faster-stack",
                "content": "### **Please Upvote** :D\\n##### 1. By reversing second half:\\n![image](https://assets.leetcode.com/users/images/ec75b620-7b2b-40f9-b7e7-b69d6f0d8e0e_1669808593.2045705.png)\\n```\\nclass Solution {\\n    public void reorderList(ListNode head) {\\n        if (head == null || head.next == null) return;\\n\\n        // find middle node\\n        ListNode slow = head, fast = head;\\n        ListNode mid = slow;\\n\\n        while (fast != null && fast.next != null) {\\n            mid = slow;\\n            slow = slow.next;\\n            fast = fast.next.next;\\n        }\\n\\n        mid.next = null;                // free the original second half from original list\\n        ListNode rev = reverse(slow);   // reverse second half\\n\\n        ListNode itr1 = head, itr2 = rev;\\n\\n        // in place operation\\n        while (true) {\\n            ListNode temp1 = itr1.next;\\n            itr1.next = itr2;\\n            itr1 = temp1;\\n\\n            ListNode temp2 = itr2.next;\\n            if (itr1 == null) break;\\n\\n            itr2.next = itr1;\\n            itr2 = temp2;\\n        }\\n    }\\n\\n    // reverse method\\n    private ListNode reverse(ListNode head) {\\n        ListNode prev = null;\\n\\n        while (head != null) {\\n            ListNode next = head.next;\\n            head.next = prev;\\n            prev = head;\\n            head = next;\\n        }\\n\\n        return prev;\\n    }\\n}\\n\\n// TC: O(n), SC: O(1)\\n```\\n##### 2. Using stack:\\n```\\nclass Solution {\\n    public void reorderList(ListNode head) {\\n        if (head == null || head.next == null) return;\\n\\n        Stack<ListNode> stack = new Stack<>();\\n        ListNode curr = head;\\n\\n        while (curr != null) {\\n            stack.push(curr);\\n            curr = curr.next;\\n        }\\n\\n        curr = head;\\n        int size = stack.size() / 2;\\n\\n        while (size-- > 0) {\\n            ListNode top = stack.pop();\\n            ListNode temp = curr.next;\\n\\n            curr.next = top;\\n            curr = temp;\\n            top.next = temp;\\n        }\\n\\n        curr.next = null;\\n    }\\n}\\n\\n// TC: O(n), SC: O(n)\\n```",
                "solutionTags": [
                    "Java",
                    "Linked List",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\n    public void reorderList(ListNode head) {\\n        if (head == null || head.next == null) return;\\n\\n        // find middle node\\n        ListNode slow = head, fast = head;\\n        ListNode mid = slow;\\n\\n        while (fast != null && fast.next != null) {\\n            mid = slow;\\n            slow = slow.next;\\n            fast = fast.next.next;\\n        }\\n\\n        mid.next = null;                // free the original second half from original list\\n        ListNode rev = reverse(slow);   // reverse second half\\n\\n        ListNode itr1 = head, itr2 = rev;\\n\\n        // in place operation\\n        while (true) {\\n            ListNode temp1 = itr1.next;\\n            itr1.next = itr2;\\n            itr1 = temp1;\\n\\n            ListNode temp2 = itr2.next;\\n            if (itr1 == null) break;\\n\\n            itr2.next = itr1;\\n            itr2 = temp2;\\n        }\\n    }\\n\\n    // reverse method\\n    private ListNode reverse(ListNode head) {\\n        ListNode prev = null;\\n\\n        while (head != null) {\\n            ListNode next = head.next;\\n            head.next = prev;\\n            prev = head;\\n            head = next;\\n        }\\n\\n        return prev;\\n    }\\n}\\n\\n// TC: O(n), SC: O(1)\\n```\n```\\nclass Solution {\\n    public void reorderList(ListNode head) {\\n        if (head == null || head.next == null) return;\\n\\n        Stack<ListNode> stack = new Stack<>();\\n        ListNode curr = head;\\n\\n        while (curr != null) {\\n            stack.push(curr);\\n            curr = curr.next;\\n        }\\n\\n        curr = head;\\n        int size = stack.size() / 2;\\n\\n        while (size-- > 0) {\\n            ListNode top = stack.pop();\\n            ListNode temp = curr.next;\\n\\n            curr.next = top;\\n            curr = temp;\\n            top.next = temp;\\n        }\\n\\n        curr.next = null;\\n    }\\n}\\n\\n// TC: O(n), SC: O(n)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2813362,
                "title": "java-reorder-linkedlist",
                "content": "# Intuition\\nInplace reversal \\nfast and slow pointer\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n1. We need to add last value to second and second at third but we can\\'t go backwards. As shown in below diagram . \\nSo we first reverse linkedlist from middle.\\n![image.png](https://assets.leetcode.com/users/images/15744fe8-39e8-4fd7-843c-e4724821813a_1668416846.4267662.png)\\n2. get Middle of linkedlist by using fast and slow pointer.\\n3. Reverse linkedlist from middle .\\n4. Now use two pointer first headFirst and second HeadSecond to move forward , but we need to store headFirst.next value somewhere so later on second can point to it.As shown below.\\n![image.png](https://assets.leetcode.com/users/images/eb8c9f82-949b-4eea-8a3d-ee4226fe7001_1668417032.3747687.png)\\nso we store \\n    temp = hf.next; // store hf.next in temp\\n    hf.next = hs;   // now first linkedlist is pointing to first     headsond\\n    hf = temp;     // now temp is stored in headfirst \\n    temp = hs.next;\\n    hs.next = hf;\\n    hs = temp \\n\\n\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:  O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public void reorderList(ListNode head) {\\n        ListNode mid = getMid(head);\\n        ListNode headSecond = reverseLinkedList(mid);\\n        ListNode headFirst = head;\\n        if(headFirst == null){\\n            return;\\n        }\\n        while(headFirst!= null && headSecond !=null){\\n            ListNode temp = headFirst.next;\\n            headFirst.next = headSecond;\\n            headFirst = temp;\\n\\n            temp = headSecond.next;\\n            headSecond.next = headFirst;\\n            headSecond = temp;\\n        }\\n\\n        if(headFirst!=null){\\n            headFirst.next = null;\\n        }\\n    }\\n\\n    public ListNode reverseLinkedList(ListNode head){\\n        ListNode prev = null;\\n        ListNode current = head;\\n        ListNode next = current.next;\\n\\n        while(current != null){\\n            current.next = prev;\\n            prev = current;\\n            current = next;\\n            if(next != null){\\n                next = next.next;\\n            }\\n        }\\n\\n        return prev;\\n    }\\n\\n    public ListNode getMid(ListNode head){\\n        ListNode slow = head;\\n        ListNode fast = head;\\n        while(fast != null && fast.next !=null){\\n            slow = slow.next;\\n            fast = fast.next.next;\\n        }\\n\\n        return slow;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public void reorderList(ListNode head) {\\n        ListNode mid = getMid(head);\\n        ListNode headSecond = reverseLinkedList(mid);\\n        ListNode headFirst = head;\\n        if(headFirst == null){\\n            return;\\n        }\\n        while(headFirst!= null && headSecond !=null){\\n            ListNode temp = headFirst.next;\\n            headFirst.next = headSecond;\\n            headFirst = temp;\\n\\n            temp = headSecond.next;\\n            headSecond.next = headFirst;\\n            headSecond = temp;\\n        }\\n\\n        if(headFirst!=null){\\n            headFirst.next = null;\\n        }\\n    }\\n\\n    public ListNode reverseLinkedList(ListNode head){\\n        ListNode prev = null;\\n        ListNode current = head;\\n        ListNode next = current.next;\\n\\n        while(current != null){\\n            current.next = prev;\\n            prev = current;\\n            current = next;\\n            if(next != null){\\n                next = next.next;\\n            }\\n        }\\n\\n        return prev;\\n    }\\n\\n    public ListNode getMid(ListNode head){\\n        ListNode slow = head;\\n        ListNode fast = head;\\n        while(fast != null && fast.next !=null){\\n            slow = slow.next;\\n            fast = fast.next.next;\\n        }\\n\\n        return slow;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2672178,
                "title": "java-1-ms-faster-than-100-00-of-java-online-submissions",
                "content": "### \\uD83D\\uDCAF Java solution\\n*explanation below*\\n```\\n\\tclass Solution {\\n\\t\\n\\t\\tpublic void reorderList(ListNode head) { \\n\\n\\t\\t\\tListNode slow = head, fast = head;\\n\\n\\t\\t\\twhile(fast != null && fast.next != null) {\\n\\t\\t\\t\\tslow = slow.next;\\n\\t\\t\\t\\tfast = fast.next.next;\\n\\t\\t\\t}\\n\\n\\t\\t\\tslow = reverse(slow);\\n\\n\\t\\t\\tListNode p1 = head;\\n\\t\\t\\tListNode p2 = slow;\\n\\n\\t\\t\\tListNode n1 = p1.next;\\n\\t\\t\\tListNode n2 = p2.next;\\n\\n\\t\\t\\twhile(n1 != null) {\\n\\t\\t\\t\\tn1 = p1.next;\\n\\t\\t\\t\\tp1.next = p2;\\n\\t\\t\\t\\tp1 = n1;\\n\\t\\t\\t\\tif(p2!= null) {\\n\\t\\t\\t\\t\\tn2 = p2.next;\\n\\t\\t\\t\\t\\tp2.next = p1;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tp2 = n2;\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\t}\\n\\t\\n\\t\\tpublic ListNode reverse(ListNode head) {\\n\\n\\t\\t\\tif(head == null || head.next == null) \\n\\t\\t\\t\\treturn head;\\n\\n\\t\\t\\tListNode prev = null;\\n\\t\\t\\tListNode curr = head;\\n\\t\\t\\tListNode next = head.next;\\n\\n\\t\\t\\twhile(curr != null) {\\n\\t\\t\\t\\tcurr.next = prev;\\n\\t\\t\\t\\tprev = curr;\\n\\t\\t\\t\\tcurr = next;\\n\\t\\t\\t\\tif(next != null) {\\n\\t\\t\\t\\t\\tnext = next.next;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn prev;\\n\\t\\t}\\n\\n\\n```\\n\\n```\\n\\t1.  find the middle of the list using fast and slow pointers.\\n\\t2.  reverse the last half of linked-list\\n\\t3.  rearrange the list in zigzag manner\\n\\neg : we have   1 , 2, 3, 4, 5, 6\\n\\n => 1, 2, 3\\n => 6, 5, 4\\n \\n after rearranging \\n => 1, 6, 2, 5, 3, 4\\n \\n```",
                "solutionTags": [
                    "Linked List"
                ],
                "code": "```\\n\\tclass Solution {\\n\\t\\n\\t\\tpublic void reorderList(ListNode head) { \\n\\n\\t\\t\\tListNode slow = head, fast = head;\\n\\n\\t\\t\\twhile(fast != null && fast.next != null) {\\n\\t\\t\\t\\tslow = slow.next;\\n\\t\\t\\t\\tfast = fast.next.next;\\n\\t\\t\\t}\\n\\n\\t\\t\\tslow = reverse(slow);\\n\\n\\t\\t\\tListNode p1 = head;\\n\\t\\t\\tListNode p2 = slow;\\n\\n\\t\\t\\tListNode n1 = p1.next;\\n\\t\\t\\tListNode n2 = p2.next;\\n\\n\\t\\t\\twhile(n1 != null) {\\n\\t\\t\\t\\tn1 = p1.next;\\n\\t\\t\\t\\tp1.next = p2;\\n\\t\\t\\t\\tp1 = n1;\\n\\t\\t\\t\\tif(p2!= null) {\\n\\t\\t\\t\\t\\tn2 = p2.next;\\n\\t\\t\\t\\t\\tp2.next = p1;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tp2 = n2;\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\t}\\n\\t\\n\\t\\tpublic ListNode reverse(ListNode head) {\\n\\n\\t\\t\\tif(head == null || head.next == null) \\n\\t\\t\\t\\treturn head;\\n\\n\\t\\t\\tListNode prev = null;\\n\\t\\t\\tListNode curr = head;\\n\\t\\t\\tListNode next = head.next;\\n\\n\\t\\t\\twhile(curr != null) {\\n\\t\\t\\t\\tcurr.next = prev;\\n\\t\\t\\t\\tprev = curr;\\n\\t\\t\\t\\tcurr = next;\\n\\t\\t\\t\\tif(next != null) {\\n\\t\\t\\t\\t\\tnext = next.next;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn prev;\\n\\t\\t}\\n\\n\\n```\n```\\n\\t1.  find the middle of the list using fast and slow pointers.\\n\\t2.  reverse the last half of linked-list\\n\\t3.  rearrange the list in zigzag manner\\n\\neg : we have   1 , 2, 3, 4, 5, 6\\n\\n => 1, 2, 3\\n => 6, 5, 4\\n \\n after rearranging \\n => 1, 6, 2, 5, 3, 4\\n \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2662587,
                "title": "143-reorder-list-c-slow-fast-pointer",
                "content": "class Solution {\\npublic:\\n    void reorderList(ListNode* head) {\\n        \\n        ListNode* slow = head;\\n        ListNode* fast = head;\\n        ListNode* first = head;\\n        while(fast != NULL && fast->next != NULL)\\n        {\\n            slow = slow->next;\\n            fast = fast->next->next;\\n        }\\n        ListNode* curr = slow->next;\\n        ListNode* prev = NULL;\\n        ListNode* next = NULL;\\n        while(curr != NULL)\\n        {\\n            next = curr->next;\\n            curr->next = prev;\\n            prev = curr;\\n            curr = next;\\n        }\\n        slow->next = NULL;\\n        ListNode* second = prev;\\n        while(second != NULL)\\n        {\\n           ListNode* temp1 = first->next;\\n           ListNode* temp2 = second->next; \\n           first->next = second;\\n           second->next = temp1;\\n           first = temp1;\\n           second = temp2;\\n        }\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    void reorderList(ListNode* head) {\\n        \\n        ListNode* slow = head;\\n        ListNode* fast = head;\\n        ListNode* first = head;\\n        while(fast != NULL && fast->next != NULL)\\n        {\\n            slow = slow->next;\\n            fast = fast->next->next;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2646867,
                "title": "very-easy-and-clever-method-to-solve-in-c",
                "content": "Simply add every value in a vector and change the data of the nodes accordingly. no need to reorder the list nodes.\\n```\\nclass Solution {\\npublic:\\n    void reorderList(ListNode* head) {\\n        vector<int> v;\\n        ListNode *temp = head;\\n\\t\\t// adding values in the vector\\n        while(temp != NULL) {\\n            v.push_back(temp->val);\\n            temp = temp->next;\\n        }\\n\\t\\t// creating two pointers to the vector and iterating accordingly\\n\\t\\t// updating the values of the list.\\n        int start = 0;\\n        int end = v.size() - 1;\\n        while(start < end) {\\n\\t\\t\\t// for the odd length case\\n            if(start + 2 == end) {\\n                head->val = v[start];\\n                head->next->val = v[end--];\\n                head->next->next->val = v[start + 1];\\n                break;\\n            }\\n            head->val = v[start++];\\n            head->next->val = v[end--];\\n            head = head->next->next;\\n        }\\n    }\\n};\\n```\\n\\nPlease upvote if you like the solution.",
                "solutionTags": [
                    "C",
                    "Linked List",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void reorderList(ListNode* head) {\\n        vector<int> v;\\n        ListNode *temp = head;\\n\\t\\t// adding values in the vector\\n        while(temp != NULL) {\\n            v.push_back(temp->val);\\n            temp = temp->next;\\n        }\\n\\t\\t// creating two pointers to the vector and iterating accordingly\\n\\t\\t// updating the values of the list.\\n        int start = 0;\\n        int end = v.size() - 1;\\n        while(start < end) {\\n\\t\\t\\t// for the odd length case\\n            if(start + 2 == end) {\\n                head->val = v[start];\\n                head->next->val = v[end--];\\n                head->next->next->val = v[start + 1];\\n                break;\\n            }\\n            head->val = v[start++];\\n            head->next->val = v[end--];\\n            head = head->next->next;\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2646397,
                "title": "java-hashmap-easy-solution-recursion",
                "content": "Upvote if you liked the solution :)\\n```\\nclass Solution {\\n    ListNode help(ListNode head,int s,int e, Map<Integer,ListNode> map){\\n        \\n        if(s>e)return null;\\n        \\n        ListNode slist=help(head.next,s+1,e-1,map);\\n        \\n        ListNode start=map.get(s);\\n        ListNode end=map.get(e);\\n        start.next=end;\\n        end.next=slist;\\n        return start;\\n\\t\\t\\n    }    \\n    public void reorderList(ListNode head) {\\n     \\n        Map<Integer,ListNode> map=new HashMap<>();//index  maps to Node\\n        ListNode temp=head;\\n        int i=0;\\n        while(temp!=null){\\n            map.put(i,temp);\\n            i++;\\n            temp=temp.next;\\n        }\\n        int l=i;//length\\n        \\n         help(head,0,l-1,map);\\n        \\n           \\n    }\\n}              \\n\\n```",
                "solutionTags": [
                    "Java",
                    "Linked List",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    ListNode help(ListNode head,int s,int e, Map<Integer,ListNode> map){\\n        \\n        if(s>e)return null;\\n        \\n        ListNode slist=help(head.next,s+1,e-1,map);\\n        \\n        ListNode start=map.get(s);\\n        ListNode end=map.get(e);\\n        start.next=end;\\n        end.next=slist;\\n        return start;\\n\\t\\t\\n    }    \\n    public void reorderList(ListNode head) {\\n     \\n        Map<Integer,ListNode> map=new HashMap<>();//index  maps to Node\\n        ListNode temp=head;\\n        int i=0;\\n        while(temp!=null){\\n            map.put(i,temp);\\n            i++;\\n            temp=temp.next;\\n        }\\n        int l=i;//length\\n        \\n         help(head,0,l-1,map);\\n        \\n           \\n    }\\n}              \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2619218,
                "title": "c-recursion-easy-to-understand",
                "content": "\\tListNode* swapList(ListNode* head) {\\n        //Each time call swapList will set L(n-i) = Li->next\\n        if (head == NULL || head->next == NULL || head->next->next == NULL) return head;\\n\\n        ListNode* cur = head;\\n        ListNode* tmp = head->next;\\n        ListNode* prev = head->next;\\n        while (tmp->next != NULL) {\\n            prev = tmp;\\n            tmp = tmp->next;\\n        }\\n        prev->next = NULL;\\n        tmp->next = cur->next;\\n        cur->next = tmp;\\n        cur = cur->next->next;\\n        swapList(cur);\\n        return head;\\n    }\\n\\n    void reorderList(ListNode* head) {\\n        swapList(head);\\n    }",
                "solutionTags": [],
                "code": "\\tListNode* swapList(ListNode* head) {\\n        //Each time call swapList will set L(n-i) = Li->next\\n        if (head == NULL || head->next == NULL || head->next->next == NULL) return head;\\n\\n        ListNode* cur = head;\\n        ListNode* tmp = head->next;\\n        ListNode* prev = head->next;\\n        while (tmp->next != NULL) {\\n            prev = tmp;\\n            tmp = tmp->next;\\n        }\\n        prev->next = NULL;\\n        tmp->next = cur->next;\\n        cur->next = tmp;\\n        cur = cur->next->next;\\n        swapList(cur);\\n        return head;\\n    }\\n\\n    void reorderList(ListNode* head) {\\n        swapList(head);\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2516535,
                "title": "easy-solution-python",
                "content": "This problem is a combination of three subproblems:\\n1. [Middle of the linked list](https://leetcode.com/problems/middle-of-the-linked-list/)\\n2. [Reverse linked list](https://leetcode.com/problems/reverse-linked-list/)\\n3. [Merge two sorted lists](https://leetcode.com/problems/merge-two-sorted-lists/)\\n\\n**Complexity**\\n* Time: O(n)\\n* Space: O(1)\\n\\n```\\nclass Solution:\\n    def reorderList(self, head: Optional[ListNode]) -> None:\\n        \"\"\"\\n        Do not return anything, modify head in-place instead.\\n        \"\"\"\\n\\n        if not head: return\\n        \\n        # Find the middle node\\n        slow = fast = head\\n        while fast and fast.next:\\n            slow = slow.next\\n            fast = fast.next.next\\n        \\n        # Reverse the second half\\n        prev, curr = None, slow\\n        while curr:\\n            temp = curr.next\\n            curr.next = prev\\n            prev = curr\\n            curr = temp\\n        \\n        # Merge the two sorts\\n        first, second = head, prev\\n        while second.next:\\n            temp1 = first.next\\n            first.next = second\\n            first = temp1\\n            \\n            temp2 = second.next\\n            second.next = first\\n            second = temp2\\n```\\n\\nFor simpler code:\\n```\\nclass Solution:\\n    def reorderList(self, head: Optional[ListNode]) -> None:\\n        \"\"\"\\n        Do not return anything, modify head in-place instead.\\n        \"\"\"\\n\\n        if not head: return\\n        \\n        # Find the middle node\\n        slow = fast = head\\n        while fast and fast.next:\\n            slow = slow.next\\n            fast = fast.next.next\\n        \\n        # Reverse the second half\\n        prev, curr = None, slow\\n        while curr:\\n            curr.next, prev, curr = prev, curr, curr.next\\n        \\n        # Merge the two sorts\\n        first, second = head, prev\\n        while second.next:\\n            first.next, first = second, first.next\\n            second.next, second = first, second.next\\n```",
                "solutionTags": [
                    "Python",
                    "Linked List"
                ],
                "code": "```\\nclass Solution:\\n    def reorderList(self, head: Optional[ListNode]) -> None:\\n        \"\"\"\\n        Do not return anything, modify head in-place instead.\\n        \"\"\"\\n\\n        if not head: return\\n        \\n        # Find the middle node\\n        slow = fast = head\\n        while fast and fast.next:\\n            slow = slow.next\\n            fast = fast.next.next\\n        \\n        # Reverse the second half\\n        prev, curr = None, slow\\n        while curr:\\n            temp = curr.next\\n            curr.next = prev\\n            prev = curr\\n            curr = temp\\n        \\n        # Merge the two sorts\\n        first, second = head, prev\\n        while second.next:\\n            temp1 = first.next\\n            first.next = second\\n            first = temp1\\n            \\n            temp2 = second.next\\n            second.next = first\\n            second = temp2\\n```\n```\\nclass Solution:\\n    def reorderList(self, head: Optional[ListNode]) -> None:\\n        \"\"\"\\n        Do not return anything, modify head in-place instead.\\n        \"\"\"\\n\\n        if not head: return\\n        \\n        # Find the middle node\\n        slow = fast = head\\n        while fast and fast.next:\\n            slow = slow.next\\n            fast = fast.next.next\\n        \\n        # Reverse the second half\\n        prev, curr = None, slow\\n        while curr:\\n            curr.next, prev, curr = prev, curr, curr.next\\n        \\n        # Merge the two sorts\\n        first, second = head, prev\\n        while second.next:\\n            first.next, first = second, first.next\\n            second.next, second = first, second.next\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2497995,
                "title": "very-easy-and-iterative-straight-forward-implementation-beats-80-runtime",
                "content": "```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def reorderList(self, head: Optional[ListNode]) -> None:\\n        \"\"\"\\n        Do not return anything, modify head in-place instead.\\n        \"\"\"\\n        nodelist=[]\\n        tmp=head\\n        while tmp:\\n            curr=tmp\\n            tmp=tmp.next\\n            curr.next=None\\n            nodelist.append(curr)        ####storing individual Node in list then changing the order\\n        #print(nodelist)\\n        head=nodelist[0]\\n        tail=None\\n        for i in range(len(nodelist)//2):\\n            nodelist[i].next=nodelist[-1-i]\\n            nodelist[i].next.next=nodelist[i+1]\\n            tail=nodelist[i].next.next\\n            #print(nodelist)\\n        if tail:\\n            tail.next=None          ###for deleting the cycle of tail node(reference to itself) if number of node is even.\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Recursion"
                ],
                "code": "```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def reorderList(self, head: Optional[ListNode]) -> None:\\n        \"\"\"\\n        Do not return anything, modify head in-place instead.\\n        \"\"\"\\n        nodelist=[]\\n        tmp=head\\n        while tmp:\\n            curr=tmp\\n            tmp=tmp.next\\n            curr.next=None\\n            nodelist.append(curr)        ####storing individual Node in list then changing the order\\n        #print(nodelist)\\n        head=nodelist[0]\\n        tail=None\\n        for i in range(len(nodelist)//2):\\n            nodelist[i].next=nodelist[-1-i]\\n            nodelist[i].next.next=nodelist[i+1]\\n            tail=nodelist[i].next.next\\n            #print(nodelist)\\n        if tail:\\n            tail.next=None          ###for deleting the cycle of tail node(reference to itself) if number of node is even.\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2448925,
                "title": "python-beats-99-75-with-full-working-explanation",
                "content": "```\\nclass Solution:\\n    def reorderList(self, head: Optional[ListNode]) -> None:  # Time: O(n) and Space: O(1)\\n\\n        # Find Middle: find middle and divide the list in to two\\n        slow, fast = head, head.next  # head(slow) -> 1 -> 2(fast) -> ...\\n        while fast and fast.next:     # while fast exists and there is next element to travel keep moving\\n            slow = slow.next          # fast moving twice as much as slow, will lead slow to point in the middle \\n            fast = fast.next.next     # Even(4): slow = 2, fast = 4 & Odd(5): slow = 3, fast = None \\n\\n        # Reverse: reverse the second list\\n        second = slow.next       # in Odd case lets say 1-> 2(slow) -> 3 -> 4(fast): second = 3(2.next) \\n        prev = slow.next = None  # Created Two separate nodes 1->2 & 3->4 \\n        while second:\\n            tmp = second.next   # tmp = 4\\n            second.next = prev  # 3 -> None\\n            prev = second       # prev = 3\\n            second = tmp        # second = 4\\n        # So, in the next iteration \\n            # tmp = None \\n            # 4.next = prev(3) and our linked is reversed\\n\\t\\t\\t# prev = 4 \\n\\t\\t\\t# second = None\\n\\n        # Merge: merge the first with the reversed second  \\n        first, second = head, prev  # first will point to starting of the 1st Node and second to 2nd Node\\n        while second:\\n            tmp1, tmp2 = first.next, second.next  # tmp1 = 2, tmp2 = 3\\n            first.next = second                   # 1 -> 4\\n            second.next = tmp1                    # 4.next = 2 i.e. 1 -> 4 -> 2 \\n            first, second = tmp1, tmp2            # first = 2, second = 3\\n        # So, in the next iteration \\n            # tmp1 = tmp2 = None\\n            # 2 -> 3 i.e. 1 -> 4 -> 2 -> 3\\n            # 1 -> 4 -> 2 -> 3 -> None\\n\\t\\t\\t# first = second = None\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def reorderList(self, head: Optional[ListNode]) -> None:  # Time: O(n) and Space: O(1)\\n\\n        # Find Middle: find middle and divide the list in to two\\n        slow, fast = head, head.next  # head(slow) -> 1 -> 2(fast) -> ...\\n        while fast and fast.next:     # while fast exists and there is next element to travel keep moving\\n            slow = slow.next          # fast moving twice as much as slow, will lead slow to point in the middle \\n            fast = fast.next.next     # Even(4): slow = 2, fast = 4 & Odd(5): slow = 3, fast = None \\n\\n        # Reverse: reverse the second list\\n        second = slow.next       # in Odd case lets say 1-> 2(slow) -> 3 -> 4(fast): second = 3(2.next) \\n        prev = slow.next = None  # Created Two separate nodes 1->2 & 3->4 \\n        while second:\\n            tmp = second.next   # tmp = 4\\n            second.next = prev  # 3 -> None\\n            prev = second       # prev = 3\\n            second = tmp        # second = 4\\n        # So, in the next iteration \\n            # tmp = None \\n            # 4.next = prev(3) and our linked is reversed\\n\\t\\t\\t# prev = 4 \\n\\t\\t\\t# second = None\\n\\n        # Merge: merge the first with the reversed second  \\n        first, second = head, prev  # first will point to starting of the 1st Node and second to 2nd Node\\n        while second:\\n            tmp1, tmp2 = first.next, second.next  # tmp1 = 2, tmp2 = 3\\n            first.next = second                   # 1 -> 4\\n            second.next = tmp1                    # 4.next = 2 i.e. 1 -> 4 -> 2 \\n            first, second = tmp1, tmp2            # first = 2, second = 3\\n        # So, in the next iteration \\n            # tmp1 = tmp2 = None\\n            # 2 -> 3 i.e. 1 -> 4 -> 2 -> 3\\n            # 1 -> 4 -> 2 -> 3 -> None\\n\\t\\t\\t# first = second = None\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2437191,
                "title": "using-recursion-100-faster-easy-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    ListNode* front;\\n    \\n    bool  check;\\n    \\n    void reorderList(ListNode* head) {\\n        // corner case \\n        if(head->next == NULL || head->next->next == NULL)\\n            return;\\n        \\n        return recur(head,head);\\n        \\n    }\\n    \\n    void recur(ListNode* back,ListNode* temp){\\n        \\n        if( back->next == NULL ){\\n                front       = temp;             // front starts from head \\n                back->next  = front->next;\\n                front->next = back;\\n                front = back->next;\\n            \\n                return;\\n        }\\n        \\n        recur( back->next,temp ); // back is managed by recursion bhaiya \\n        if(check == true) // so that folded part not gets unfolded \\n            return;\\n        \\n        if( front->next == back || front == back){ // this if will run when all folding is done ( dry run to understand ) (ex 1 - 2 - 3 - 4 - 5- 6 , it will hit for front: 3 , back :4 [ updated list at that time : 1 --> 6 --> 2 --> 5 --> 3 --> 4( 4 next has 5 )\\n            back->next = NULL;\\n            check = true;\\n            return;\\n        }\\n        \\n        \\n        back->next   = front->next;\\n        front->next  = back;\\n        front        = back->next;\\n        \\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* front;\\n    \\n    bool  check;\\n    \\n    void reorderList(ListNode* head) {\\n        // corner case \\n        if(head->next == NULL || head->next->next == NULL)\\n            return;\\n        \\n        return recur(head,head);\\n        \\n    }\\n    \\n    void recur(ListNode* back,ListNode* temp){\\n        \\n        if( back->next == NULL ){\\n                front       = temp;             // front starts from head \\n                back->next  = front->next;\\n                front->next = back;\\n                front = back->next;\\n            \\n                return;\\n        }\\n        \\n        recur( back->next,temp ); // back is managed by recursion bhaiya \\n        if(check == true) // so that folded part not gets unfolded \\n            return;\\n        \\n        if( front->next == back || front == back){ // this if will run when all folding is done ( dry run to understand ) (ex 1 - 2 - 3 - 4 - 5- 6 , it will hit for front: 3 , back :4 [ updated list at that time : 1 --> 6 --> 2 --> 5 --> 3 --> 4( 4 next has 5 )\\n            back->next = NULL;\\n            check = true;\\n            return;\\n        }\\n        \\n        \\n        back->next   = front->next;\\n        front->next  = back;\\n        front        = back->next;\\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2433139,
                "title": "python-easy-to-understand-3-steps-approach",
                "content": "It may look long but read through and you\\'ll definitely understand.\\n\\n**Approach:**\\n1. Find the middle of the given linked list and create a newlist with the node after the middle node\\n2. Reverse the new list\\n3. Now interjoin original list and new list together\\n\\nFor example,\\n```\\nList = 1 -> 2 -> 3 -> 4 -> 5\\nmid = 3\\nso, \\nList = 1 -> 2 -> 3\\nnewList = 4 -> 5\\nreversedNewList = 5 -> 4\\nInter Join List (1 -> 2 -> 3) and reversedNewList (5 -> 4):\\n1 -> 5 -> 2 -> 4 -> 3\\n```\\n```\\ndef reorderList(self, head: Optional[ListNode]) -> None:\\n\\t# Find the middle of given linked list\\n\\tslow = head\\n\\tfast = head\\n\\n\\twhile fast and fast.next:\\n\\t\\tslow = slow.next\\n\\t\\tfast = fast.next.next\\n\\n\\tnewList = slow.next # create a new list with the node after the middle node\\n\\tslow.next = None # set next node of middle node to none\\n\\n\\t# Reverse the new list\\n\\tprev = None\\n\\tcur = newList\\n\\n\\twhile cur:\\n\\t\\tnxt = cur.next\\n\\t\\tcur.next = prev\\n\\t\\tprev = cur\\n\\t\\tcur = nxt\\n\\n\\tnewReversedHead = prev # head of new list\\n\\n\\t# Interjoin head and newReversedHead\\n\\tnode1, node2 = head, newReversedHead\\n\\tflag = 1\\n\\n\\twhile node1 and node2:\\n\\t\\tif flag:\\n\\t\\t\\tnxt = node1.next\\n\\t\\t\\tnode1.next = node2\\n\\t\\t\\tnode1 = nxt\\n\\t\\telse:\\n\\t\\t\\tnxt = node2.next\\n\\t\\t\\tnode2.next = node1\\n\\t\\t\\tnode2 = nxt\\n\\n\\t\\tflag = not flag\\n```\\n\\n![image](https://assets.leetcode.com/users/images/f3b072f4-37b5-444d-8aad-f5670481406e_1660753826.2818317.png)\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Linked List"
                ],
                "code": "```\\nList = 1 -> 2 -> 3 -> 4 -> 5\\nmid = 3\\nso, \\nList = 1 -> 2 -> 3\\nnewList = 4 -> 5\\nreversedNewList = 5 -> 4\\nInter Join List (1 -> 2 -> 3) and reversedNewList (5 -> 4):\\n1 -> 5 -> 2 -> 4 -> 3\\n```\n```\\ndef reorderList(self, head: Optional[ListNode]) -> None:\\n\\t# Find the middle of given linked list\\n\\tslow = head\\n\\tfast = head\\n\\n\\twhile fast and fast.next:\\n\\t\\tslow = slow.next\\n\\t\\tfast = fast.next.next\\n\\n\\tnewList = slow.next # create a new list with the node after the middle node\\n\\tslow.next = None # set next node of middle node to none\\n\\n\\t# Reverse the new list\\n\\tprev = None\\n\\tcur = newList\\n\\n\\twhile cur:\\n\\t\\tnxt = cur.next\\n\\t\\tcur.next = prev\\n\\t\\tprev = cur\\n\\t\\tcur = nxt\\n\\n\\tnewReversedHead = prev # head of new list\\n\\n\\t# Interjoin head and newReversedHead\\n\\tnode1, node2 = head, newReversedHead\\n\\tflag = 1\\n\\n\\twhile node1 and node2:\\n\\t\\tif flag:\\n\\t\\t\\tnxt = node1.next\\n\\t\\t\\tnode1.next = node2\\n\\t\\t\\tnode1 = nxt\\n\\t\\telse:\\n\\t\\t\\tnxt = node2.next\\n\\t\\t\\tnode2.next = node1\\n\\t\\t\\tnode2 = nxt\\n\\n\\t\\tflag = not flag\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2279142,
                "title": "c-most-optimized-reorder-list-solution-with-comments-easy-understanding",
                "content": "```\\nclass Solution {\\npublic:\\n    void reorderList(ListNode* head) {\\n        if(!head or !head->next) return;            // if there is no or one node in linked list, no need to reorder\\n        \\n        ListNode *slow=head;\\n        ListNode *fast=head;\\n        while(fast->next!=NULL and fast->next->next!=NULL){ // slow and fast pointer approach to find mid/2+1\\n                                                            // it is setting slow->next to mid/2+1 \\n            slow=slow->next;                                // in both the cases whether linked list has odd or even nodes \\n            fast=fast->next->next;\\n        }\\n        \\n        ListNode *a=NULL, *b=slow->next;                        \\n        slow->next=NULL;\\n        while(b!=NULL){             // reversing second part of linked list\\n            ListNode *c=b->next;\\n            b->next=a;\\n            a=b;\\n            b=c;\\n        }\\n        \\n        b=a;                                                    \\n        a=head;\\n        \\n        while(a!=NULL and b!=NULL){             // mergeing both the linked lists and hence required reordering takes place\\n            ListNode *t1=a->next;\\n            ListNode *t2=b->next;\\n            a->next=b;\\n            a=t1;\\n            b->next=a;\\n            b=t2;\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Linked List",
                    "Iterator"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void reorderList(ListNode* head) {\\n        if(!head or !head->next) return;            // if there is no or one node in linked list, no need to reorder\\n        \\n        ListNode *slow=head;\\n        ListNode *fast=head;\\n        while(fast->next!=NULL and fast->next->next!=NULL){ // slow and fast pointer approach to find mid/2+1\\n                                                            // it is setting slow->next to mid/2+1 \\n            slow=slow->next;                                // in both the cases whether linked list has odd or even nodes \\n            fast=fast->next->next;\\n        }\\n        \\n        ListNode *a=NULL, *b=slow->next;                        \\n        slow->next=NULL;\\n        while(b!=NULL){             // reversing second part of linked list\\n            ListNode *c=b->next;\\n            b->next=a;\\n            a=b;\\n            b=c;\\n        }\\n        \\n        b=a;                                                    \\n        a=head;\\n        \\n        while(a!=NULL and b!=NULL){             // mergeing both the linked lists and hence required reordering takes place\\n            ListNode *t1=a->next;\\n            ListNode *t2=b->next;\\n            a->next=b;\\n            a=t1;\\n            b->next=a;\\n            b=t2;\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2243930,
                "title": "java-in-depth-explanation",
                "content": "**Intuition**\\n\\n1. Get the middle node of LinkedList\\n2. Reverse that middle node of LinkedList\\n3. Merge two LinkedList.\\n\\n```\\nclass Solution\\n{\\n    public void reorderList(ListNode head) \\n    {\\n        // O(n) time | O(1) space\\n        if (head == null || head.next == null)\\n            return;\\n      \\n        ListNode middle = getMiddle(head);\\n        ListNode second = reverseLinkedList(middle);\\n        ListNode first = head;\\n        ListNode nextNode;\\n        \\n        while(second.next != null)\\n        {\\n            nextNode = first.next;\\n            first.next = second;\\n            first = second;\\n            second = nextNode;\\n        }\\n    }\\n    \\n    public ListNode getMiddle(ListNode head)\\n    {\\n        ListNode slow = head;\\n        ListNode fast = head;\\n        \\n        while(fast != null && fast.next != null)\\n        {\\n            slow = slow.next;\\n            fast = fast.next.next;\\n        }\\n        return slow;\\n    }\\n    \\n    public ListNode reverseLinkedList(ListNode head)\\n    {\\n        ListNode prev = null;\\n        ListNode cur = head;\\n        ListNode next_node;\\n        \\n        while(cur != null)\\n        {\\n            next_node = cur.next;\\n            cur.next = prev;\\n            prev = cur;\\n            cur = next_node;\\n        }       \\n        return prev;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution\\n{\\n    public void reorderList(ListNode head) \\n    {\\n        // O(n) time | O(1) space\\n        if (head == null || head.next == null)\\n            return;\\n      \\n        ListNode middle = getMiddle(head);\\n        ListNode second = reverseLinkedList(middle);\\n        ListNode first = head;\\n        ListNode nextNode;\\n        \\n        while(second.next != null)\\n        {\\n            nextNode = first.next;\\n            first.next = second;\\n            first = second;\\n            second = nextNode;\\n        }\\n    }\\n    \\n    public ListNode getMiddle(ListNode head)\\n    {\\n        ListNode slow = head;\\n        ListNode fast = head;\\n        \\n        while(fast != null && fast.next != null)\\n        {\\n            slow = slow.next;\\n            fast = fast.next.next;\\n        }\\n        return slow;\\n    }\\n    \\n    public ListNode reverseLinkedList(ListNode head)\\n    {\\n        ListNode prev = null;\\n        ListNode cur = head;\\n        ListNode next_node;\\n        \\n        while(cur != null)\\n        {\\n            next_node = cur.next;\\n            cur.next = prev;\\n            prev = cur;\\n            cur = next_node;\\n        }       \\n        return prev;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2078674,
                "title": "reorder-list",
                "content": "```\\nvoid reorderList(ListNode* head) {\\n\\t\\t// To get the size of linked list\\n        ListNode* temp = head;\\n        int count = 0;\\n        while(temp != NULL){\\n            temp = temp->next;\\n            count++;\\n        }\\n        \\n\\t\\t// To get middle node\\n        ListNode* slow = head;\\n        ListNode* fast = head;\\n        while(fast->next != NULL && fast->next->next != NULL){\\n            fast = fast->next->next;\\n            slow = slow->next;\\n        }\\n        \\n\\t\\t// Pushing the nodes after middle node into the stack\\n        slow = slow->next;\\n        stack<ListNode*> st;\\n        while(slow != NULL){\\n            st.push(slow);\\n            slow = slow->next;\\n        }\\n        \\n\\t\\t// connecting the links as required\\n        temp = head;\\n        int k = count/2;\\n        while(k--){\\n            ListNode* ntem = temp->next;\\n            ListNode* val = st.top();\\n            st.pop();\\n            temp->next = val;\\n            val->next = ntem;\\n            temp = ntem;\\n        }\\n        \\n        temp->next = NULL;\\n            \\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nvoid reorderList(ListNode* head) {\\n\\t\\t// To get the size of linked list\\n        ListNode* temp = head;\\n        int count = 0;\\n        while(temp != NULL){\\n            temp = temp->next;\\n            count++;\\n        }\\n        \\n\\t\\t// To get middle node\\n        ListNode* slow = head;\\n        ListNode* fast = head;\\n        while(fast->next != NULL && fast->next->next != NULL){\\n            fast = fast->next->next;\\n            slow = slow->next;\\n        }\\n        \\n\\t\\t// Pushing the nodes after middle node into the stack\\n        slow = slow->next;\\n        stack<ListNode*> st;\\n        while(slow != NULL){\\n            st.push(slow);\\n            slow = slow->next;\\n        }\\n        \\n\\t\\t// connecting the links as required\\n        temp = head;\\n        int k = count/2;\\n        while(k--){\\n            ListNode* ntem = temp->next;\\n            ListNode* val = st.top();\\n            st.pop();\\n            temp->next = val;\\n            val->next = ntem;\\n            temp = ntem;\\n        }\\n        \\n        temp->next = NULL;\\n            \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2029194,
                "title": "using-linked-list-cycle-method-o-n-in-place-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    ListNode* reverse(ListNode* head)\\n    {\\n        ListNode* prev=NULL;\\n        ListNode* curr=head;\\n        ListNode* nxt=NULL;\\n        \\n        while(curr)\\n        {\\n            nxt=curr->next;\\n            curr->next=prev;\\n            prev=curr;\\n            curr=nxt;\\n        }\\n        return prev;\\n    }\\n    \\n    void reorderList(ListNode* head) {\\n        \\n        //step 1 - using slow and fast pointer approach to find the mid of the list\\n        ListNode* slow=head;\\n        ListNode* fast=head->next;\\n        \\n        while(fast and fast->next)\\n        {\\n            slow=slow->next;\\n            fast=fast->next->next;\\n        }\\n        \\n        //step 2 - reverse the second half and split the List into two.\\n        ListNode* second=reverse(slow->next); // independent list second\\n        slow->next=NULL;\\n        ListNode* first=head; // independent list first\\n        \\n        //step 3 - merging the two list\\n        // second list can be shorter when LL size is odd\\n        while(second)\\n        {\\n            ListNode* temp1=first->next;\\n            ListNode* temp2=second->next;\\n            first->next=second;\\n            second->next=temp1;\\n            first=temp1;\\n            second=temp2;\\n        }\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    ListNode* reverse(ListNode* head)\\n    {\\n        ListNode* prev=NULL;\\n        ListNode* curr=head;\\n        ListNode* nxt=NULL;\\n        \\n        while(curr)\\n        {\\n            nxt=curr->next;\\n            curr->next=prev;\\n            prev=curr;\\n            curr=nxt;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1990927,
                "title": "java-c-python-javascript-kotlin-swift-o-n-time-beats-99-97-memory-speed-0ms-april-2022",
                "content": "```\\n```\\n\\n(Note: This is part of a series of Leetcode solution explanations. If you like this solution or find it useful, ***please upvote*** this post.)\\n***Take care brother, peace, love!***\\n\\n```\\n```\\n\\n```\\n```\\n\\n```\\n```\\n\\nThe best result for the code below is ***0ms / 38.2MB*** (beats 92.04% / 24.00%).\\n* ***Java***\\n```\\nclass Solution {\\n    private ListNode mid(ListNode head) {\\n        if (head == null) return head;\\n        ListNode slow = head;\\n        ListNode fast = head;\\n        while (fast != null && fast.next != null) {\\n            slow = slow.next;\\n            fast = fast.next.next;\\n        }\\n        return slow;\\n    }\\n    private ListNode reverse(ListNode head) {\\n        ListNode prev = null;\\n        ListNode curr = head;\\n        while (curr != null) {\\n            ListNode forward = curr.next;\\n            curr.next = prev;\\n            prev = curr;\\n            curr = forward;\\n        }\\n        return prev;\\n    }\\n    public void reorderList(ListNode head) {\\n        if (head == null || head.next == null) return;\\n        ListNode mid = mid(head);\\n        ListNode second = reverse(mid);\\n        ListNode first = head;\\n        while (first != null && second != null) {\\n            ListNode temp = first.next;\\n            first.next = second;\\n            first = temp;\\n            temp = second.next;\\n            second.next = first;\\n            second = temp;\\n        }\\n            if (first != null) first.next = null;\\n    }\\n}\\n```\\n\\n```\\n```\\n\\n```\\n```\\n\\nThe best result for the code below is ***0ms / 7.0MB*** (beats 100.00% / 100.00%).\\n* ***C++***\\n```\\nclass Solution {\\npublic:\\n    void reorderList(ListNode* head) {\\n        if (!head->next) return;\\n        \\n        // Find the middle of the list\\n        ListNode* middle = findMiddleOfList(head);\\n        \\n        // Reverse the second half of list\\n        ListNode* right = reverseList(middle->next);\\n        middle->next = nullptr;\\n        \\n        // Now, reorder the list\\n        ListNode *left = head, *currL = left, *currR = right;\\n        while(left && right) {\\n            currL = left;\\n            currR = right;\\n            left = left->next;\\n            right = right->next;\\n            currL->next = currR;\\n            currR->next = left;\\n        }\\n    }\\n    \\nprivate:\\n    ListNode* findMiddleOfList(ListNode* node) {\\n        ListNode *slow = node, *fast = node;\\n        \\n        while(fast->next && fast->next->next) {\\n            slow = slow->next;\\n            fast = fast->next->next;\\n        }\\n        \\n        return slow;\\n    }\\n    \\n    ListNode* reverseList(ListNode* node) {\\n        ListNode *curr = node, *upcoming = node, *prev = nullptr;\\n        while(curr->next) {\\n            upcoming = curr->next;\\n            curr->next = prev;\\n            prev = curr;\\n            curr = upcoming;\\n        }\\n        curr->next = prev;\\n        return curr;\\n    }\\n};\\n```\\n\\n```\\n```\\n\\n```\\n```\\n\\n\\nThe best result for the code below is ***26ms / 12.2MB*** (beats 95.42% / 82.32%).\\n* ***Python***\\n```\\nclass Solution:\\n    def reverse(self , head):\\n        prev = None\\n        after = None\\n        curr = head\\n        while(curr):\\n            after = curr.next\\n            curr.next = prev\\n            prev = curr\\n            curr = after\\n        return prev\\n            \\n    def find_middle(self , head):\\n        slow = head\\n        fast = head\\n        while(fast and fast.next):\\n            fast = fast.next.next\\n            slow = slow.next\\n        return slow\\n        \\n    def reorderList(self, head: Optional[ListNode]) -> None:\\n        mid = self.find_middle(head)\\n        rev = self.reverse(mid)\\n        first = head\\n        second = rev\\n        \\n        while(second.next):\\n            temp = first.next\\n            first.next = second\\n            first = temp\\n            \\n            temp = second.next\\n            second.next = first\\n            second = temp\\n```\\n\\n```\\n```\\n\\n```\\n```\\n\\nThe best result for the code below is ***51ms / 34.2MB*** (beats 100.00% / 84.12%).\\n* ***JavaScript***\\n```\\nvar reorderList = function (head) {\\n  //using the 2 pointers method, loop through the LL till slow get to the midpoint, then set its next node to be the head of the second list\\n  let [slow, fast] = [head, head.next];\\n  //when this loop exits slow will be at half of the list\\n  while (fast && fast.next) {\\n    slow = slow.next;\\n    fast = fast.next.next;\\n  }\\n  //now that slow is at the midpoint, split the LL in half by having \\'second\\' be the head of the second list and make slow point to null as next so that becomes the end of the first list \\n  let second = slow.next;\\n  slow.next = null;\\n\\n  //reverse the second list\\n\\tlet prev = null\\n\\twhile (second) {\\n\\t\\tlet temp = second.next;\\n\\t\\tsecond.next = prev;\\n\\t\\tprev = second;\\n\\t\\tsecond = temp;\\n  }\\n\\n  //merge the two LL\\n  let first = head;\\n  second = prev;\\n  while (second) {\\n    let [temp1, temp2] = [first.next, second.next];\\n    first.next = second;\\n    second.next = temp1;\\n    first = temp1;\\n    second = temp2;\\n  }\\n};\\n```\\n\\n```\\n```\\n\\n```\\n```\\n\\nThe best result for the code below is ***68ms / 44.2MB*** (beats 100.00% / 45.25%).\\n* ***Kotlin***\\n```\\n/**\\n * Example:\\n * var li = ListNode(5)\\n * var v = li.`val`\\n * Definition for singly-linked list.\\n * class ListNode(var `val`: Int) {\\n *     var next: ListNode? = null\\n * }\\n */\\nclass Solution {\\n    fun reorderList(head: ListNode?): Unit {\\n        \\n        if (head == null || head.next == null) return\\n        \\n        var fast = head; var slow = head\\n        while(fast?.next != null){\\n            fast = fast.next.next\\n            slow = slow?.next\\n        }\\n        \\n        var _2ndHalfReversed = reverse(slow)\\n        var _1stHalf = head\\n        \\n        while(_2ndHalfReversed != null && _1stHalf != null){\\n            var _1stHalfNext = _1stHalf?.next\\n            var _2ndHalfReversedNext = _2ndHalfReversed?.next\\n            _1stHalf?.next = _2ndHalfReversed\\n            _2ndHalfReversed?.next = _1stHalfNext\\n            _1stHalf = _1stHalfNext\\n            _2ndHalfReversed = _2ndHalfReversedNext\\n        }\\n        if (_2ndHalfReversed != null) _2ndHalfReversed.next = null\\n        else _1stHalf?.next = null\\n        \\n    }\\n    \\n    fun reverse(head: ListNode?) : ListNode?{\\n        \\n        var curr = head\\n        var next = curr?.next\\n        var prev : ListNode? = null\\n        \\n        while(curr != null){\\n            next = curr.next\\n            curr.next = prev\\n            prev = curr\\n            curr = next            \\n        }\\n        return prev\\n    }\\n}\\n```\\n\\n```\\n```\\n\\n```\\n```\\n\\nThe best result for the code below is ***12ms / 32.2MB*** (beats 95% / 84%).\\n* ***Swift***\\n```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     public var val: Int\\n *     public var next: ListNode?\\n *     public init() { self.val = 0; self.next = nil; }\\n *     public init(_ val: Int) { self.val = val; self.next = nil; }\\n *     public init(_ val: Int, _ next: ListNode?) { self.val = val; self.next = next; }\\n * }\\n */\\nclass Solution {\\n   // - Complexity:\\n    //   - time: O(n), where n is the number of nodes in the linked list.\\n    //   - space: O(1), only constant space is used.\\n    \\n    func reorderList(_ head: ListNode?) {\\n        guard head != nil else { return }\\n\\n        var slow = head\\n        var fast = head\\n\\n        while fast?.next != nil {\\n            slow = slow?.next\\n            fast = fast?.next?.next\\n        }\\n\\n        let reversedList = reverseList(slow)\\n        mergeLists(head, reversedList)\\n    }\\n    \\n\\n    private func reverseList(_ head: ListNode?) -> ListNode? {\\n        var prev: ListNode? = nil\\n        var curr = head\\n        var next: ListNode? = nil\\n\\n        while curr != nil {\\n            next = curr?.next\\n\\n            curr?.next = prev\\n            prev = curr\\n            curr = next\\n        }\\n\\n        return prev\\n    }\\n    \\n\\n    private func mergeLists(_ first: ListNode?, _ second: ListNode?) {\\n        var first = first\\n        var second = second\\n        var tmp: ListNode? = nil\\n\\n        while second?.next != nil {\\n            tmp = first?.next\\n            first?.next = second\\n            first = tmp\\n\\n            tmp = second?.next\\n            second?.next = first\\n            second = tmp\\n        }\\n    }\\n\\n}\\n```\\n\\n```\\n```\\n\\n```\\n```\\n\\n***\"Open your eyes. Expect us.\" - \\uD835\\uDCD0\\uD835\\uDCF7\\uD835\\uDCF8\\uD835\\uDCF7\\uD835\\uDD02\\uD835\\uDCF6\\uD835\\uDCF8\\uD835\\uDCFE\\uD835\\uDCFC***",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Python3",
                    "C",
                    "JavaScript",
                    "Swift",
                    "Kotlin"
                ],
                "code": "```\\n```\n```\\n```\n```\\n```\n```\\n```\n```\\nclass Solution {\\n    private ListNode mid(ListNode head) {\\n        if (head == null) return head;\\n        ListNode slow = head;\\n        ListNode fast = head;\\n        while (fast != null && fast.next != null) {\\n            slow = slow.next;\\n            fast = fast.next.next;\\n        }\\n        return slow;\\n    }\\n    private ListNode reverse(ListNode head) {\\n        ListNode prev = null;\\n        ListNode curr = head;\\n        while (curr != null) {\\n            ListNode forward = curr.next;\\n            curr.next = prev;\\n            prev = curr;\\n            curr = forward;\\n        }\\n        return prev;\\n    }\\n    public void reorderList(ListNode head) {\\n        if (head == null || head.next == null) return;\\n        ListNode mid = mid(head);\\n        ListNode second = reverse(mid);\\n        ListNode first = head;\\n        while (first != null && second != null) {\\n            ListNode temp = first.next;\\n            first.next = second;\\n            first = temp;\\n            temp = second.next;\\n            second.next = first;\\n            second = temp;\\n        }\\n            if (first != null) first.next = null;\\n    }\\n}\\n```\n```\\n```\n```\\n```\n```\\nclass Solution {\\npublic:\\n    void reorderList(ListNode* head) {\\n        if (!head->next) return;\\n        \\n        // Find the middle of the list\\n        ListNode* middle = findMiddleOfList(head);\\n        \\n        // Reverse the second half of list\\n        ListNode* right = reverseList(middle->next);\\n        middle->next = nullptr;\\n        \\n        // Now, reorder the list\\n        ListNode *left = head, *currL = left, *currR = right;\\n        while(left && right) {\\n            currL = left;\\n            currR = right;\\n            left = left->next;\\n            right = right->next;\\n            currL->next = currR;\\n            currR->next = left;\\n        }\\n    }\\n    \\nprivate:\\n    ListNode* findMiddleOfList(ListNode* node) {\\n        ListNode *slow = node, *fast = node;\\n        \\n        while(fast->next && fast->next->next) {\\n            slow = slow->next;\\n            fast = fast->next->next;\\n        }\\n        \\n        return slow;\\n    }\\n    \\n    ListNode* reverseList(ListNode* node) {\\n        ListNode *curr = node, *upcoming = node, *prev = nullptr;\\n        while(curr->next) {\\n            upcoming = curr->next;\\n            curr->next = prev;\\n            prev = curr;\\n            curr = upcoming;\\n        }\\n        curr->next = prev;\\n        return curr;\\n    }\\n};\\n```\n```\\n```\n```\\n```\n```\\nclass Solution:\\n    def reverse(self , head):\\n        prev = None\\n        after = None\\n        curr = head\\n        while(curr):\\n            after = curr.next\\n            curr.next = prev\\n            prev = curr\\n            curr = after\\n        return prev\\n            \\n    def find_middle(self , head):\\n        slow = head\\n        fast = head\\n        while(fast and fast.next):\\n            fast = fast.next.next\\n            slow = slow.next\\n        return slow\\n        \\n    def reorderList(self, head: Optional[ListNode]) -> None:\\n        mid = self.find_middle(head)\\n        rev = self.reverse(mid)\\n        first = head\\n        second = rev\\n        \\n        while(second.next):\\n            temp = first.next\\n            first.next = second\\n            first = temp\\n            \\n            temp = second.next\\n            second.next = first\\n            second = temp\\n```\n```\\n```\n```\\n```\n```\\nvar reorderList = function (head) {\\n  //using the 2 pointers method, loop through the LL till slow get to the midpoint, then set its next node to be the head of the second list\\n  let [slow, fast] = [head, head.next];\\n  //when this loop exits slow will be at half of the list\\n  while (fast && fast.next) {\\n    slow = slow.next;\\n    fast = fast.next.next;\\n  }\\n  //now that slow is at the midpoint, split the LL in half by having \\'second\\' be the head of the second list and make slow point to null as next so that becomes the end of the first list \\n  let second = slow.next;\\n  slow.next = null;\\n\\n  //reverse the second list\\n\\tlet prev = null\\n\\twhile (second) {\\n\\t\\tlet temp = second.next;\\n\\t\\tsecond.next = prev;\\n\\t\\tprev = second;\\n\\t\\tsecond = temp;\\n  }\\n\\n  //merge the two LL\\n  let first = head;\\n  second = prev;\\n  while (second) {\\n    let [temp1, temp2] = [first.next, second.next];\\n    first.next = second;\\n    second.next = temp1;\\n    first = temp1;\\n    second = temp2;\\n  }\\n};\\n```\n```\\n```\n```\\n```\n```\\n/**\\n * Example:\\n * var li = ListNode(5)\\n * var v = li.`val`\\n * Definition for singly-linked list.\\n * class ListNode(var `val`: Int) {\\n *     var next: ListNode? = null\\n * }\\n */\\nclass Solution {\\n    fun reorderList(head: ListNode?): Unit {\\n        \\n        if (head == null || head.next == null) return\\n        \\n        var fast = head; var slow = head\\n        while(fast?.next != null){\\n            fast = fast.next.next\\n            slow = slow?.next\\n        }\\n        \\n        var _2ndHalfReversed = reverse(slow)\\n        var _1stHalf = head\\n        \\n        while(_2ndHalfReversed != null && _1stHalf != null){\\n            var _1stHalfNext = _1stHalf?.next\\n            var _2ndHalfReversedNext = _2ndHalfReversed?.next\\n            _1stHalf?.next = _2ndHalfReversed\\n            _2ndHalfReversed?.next = _1stHalfNext\\n            _1stHalf = _1stHalfNext\\n            _2ndHalfReversed = _2ndHalfReversedNext\\n        }\\n        if (_2ndHalfReversed != null) _2ndHalfReversed.next = null\\n        else _1stHalf?.next = null\\n        \\n    }\\n    \\n    fun reverse(head: ListNode?) : ListNode?{\\n        \\n        var curr = head\\n        var next = curr?.next\\n        var prev : ListNode? = null\\n        \\n        while(curr != null){\\n            next = curr.next\\n            curr.next = prev\\n            prev = curr\\n            curr = next            \\n        }\\n        return prev\\n    }\\n}\\n```\n```\\n```\n```\\n```\n```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     public var val: Int\\n *     public var next: ListNode?\\n *     public init() { self.val = 0; self.next = nil; }\\n *     public init(_ val: Int) { self.val = val; self.next = nil; }\\n *     public init(_ val: Int, _ next: ListNode?) { self.val = val; self.next = next; }\\n * }\\n */\\nclass Solution {\\n   // - Complexity:\\n    //   - time: O(n), where n is the number of nodes in the linked list.\\n    //   - space: O(1), only constant space is used.\\n    \\n    func reorderList(_ head: ListNode?) {\\n        guard head != nil else { return }\\n\\n        var slow = head\\n        var fast = head\\n\\n        while fast?.next != nil {\\n            slow = slow?.next\\n            fast = fast?.next?.next\\n        }\\n\\n        let reversedList = reverseList(slow)\\n        mergeLists(head, reversedList)\\n    }\\n    \\n\\n    private func reverseList(_ head: ListNode?) -> ListNode? {\\n        var prev: ListNode? = nil\\n        var curr = head\\n        var next: ListNode? = nil\\n\\n        while curr != nil {\\n            next = curr?.next\\n\\n            curr?.next = prev\\n            prev = curr\\n            curr = next\\n        }\\n\\n        return prev\\n    }\\n    \\n\\n    private func mergeLists(_ first: ListNode?, _ second: ListNode?) {\\n        var first = first\\n        var second = second\\n        var tmp: ListNode? = nil\\n\\n        while second?.next != nil {\\n            tmp = first?.next\\n            first?.next = second\\n            first = tmp\\n\\n            tmp = second?.next\\n            second?.next = first\\n            second = tmp\\n        }\\n    }\\n\\n}\\n```\n```\\n```\n```\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1774588,
                "title": "c-recursion",
                "content": "```\\nclass Solution {\\npublic:\\n    ListNode* recursion(ListNode* head){\\n        if(head->next==NULL || head->next->next==NULL){\\n            return head;\\n        }\\n        ListNode* temp=head;\\n        while(temp->next->next!=NULL){\\n            temp=temp->next;\\n        }\\n        temp->next->next=head->next;\\n        head->next=temp->next;\\n        temp->next=NULL;\\n        head->next->next=recursion(head->next->next);\\n        return head;\\n        \\n    }\\n    void reorderList(ListNode* head) {\\n        head=recursion(head);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* recursion(ListNode* head){\\n        if(head->next==NULL || head->next->next==NULL){\\n            return head;\\n        }\\n        ListNode* temp=head;\\n        while(temp->next->next!=NULL){\\n            temp=temp->next;\\n        }\\n        temp->next->next=head->next;\\n        head->next=temp->next;\\n        temp->next=NULL;\\n        head->next->next=recursion(head->next->next);\\n        return head;\\n        \\n    }\\n    void reorderList(ListNode* head) {\\n        head=recursion(head);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1771091,
                "title": "javascript-solution-using-2-pointers-split-and-merge-comments",
                "content": "```\\nvar reorderList = function (head) {\\n  //using the 2 pointers method, loop through the LL till slow get to the midpoint, then set its next node to be the head of the second list\\n  let [slow, fast] = [head, head.next];\\n  //when this loop exits slow will be at half of the list\\n  while (fast && fast.next) {\\n    slow = slow.next;\\n    fast = fast.next.next;\\n  }\\n  //now that slow is at the midpoint, split the LL in half by having \\'second\\' be the head of the second list and make slow point to null as next so that becomes the end of the first list \\n  let second = slow.next;\\n  slow.next = null;\\n\\n  //reverse the second list\\n\\tlet prev = null\\n\\twhile (second) {\\n\\t\\tlet temp = second.next;\\n\\t\\tsecond.next = prev;\\n\\t\\tprev = second;\\n\\t\\tsecond = temp;\\n  }\\n\\n  //merge the two LL\\n  let first = head;\\n  second = prev;\\n  while (second) {\\n    let [temp1, temp2] = [first.next, second.next];\\n    first.next = second;\\n    second.next = temp1;\\n    first = temp1;\\n    second = temp2;\\n  }\\n};\\n```\\nThis solution consists of 3 parts: divide list in 2 lists, reverse second list, merge together the 2 lists.",
                "solutionTags": [
                    "JavaScript",
                    "Two Pointers"
                ],
                "code": "```\\nvar reorderList = function (head) {\\n  //using the 2 pointers method, loop through the LL till slow get to the midpoint, then set its next node to be the head of the second list\\n  let [slow, fast] = [head, head.next];\\n  //when this loop exits slow will be at half of the list\\n  while (fast && fast.next) {\\n    slow = slow.next;\\n    fast = fast.next.next;\\n  }\\n  //now that slow is at the midpoint, split the LL in half by having \\'second\\' be the head of the second list and make slow point to null as next so that becomes the end of the first list \\n  let second = slow.next;\\n  slow.next = null;\\n\\n  //reverse the second list\\n\\tlet prev = null\\n\\twhile (second) {\\n\\t\\tlet temp = second.next;\\n\\t\\tsecond.next = prev;\\n\\t\\tprev = second;\\n\\t\\tsecond = temp;\\n  }\\n\\n  //merge the two LL\\n  let first = head;\\n  second = prev;\\n  while (second) {\\n    let [temp1, temp2] = [first.next, second.next];\\n    first.next = second;\\n    second.next = temp1;\\n    first = temp1;\\n    second = temp2;\\n  }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1645756,
                "title": "100-faster-easy-to-understand-c-code",
                "content": "1. **Find middle of linked list and then divide it into two linked list with head node l1 and l2 . Reverse the list with node l2 . After this merge l1 and l2 .**\\n\\n* *****Time Complexity : O(N)*****\\n* *****Space Complexity : O(1)*****\\n\\n```\\nListNode* reverse(ListNode* slow)\\n    {\\n        ListNode* prev = NULL;\\n        ListNode* curr = slow;\\n        while(curr != NULL)\\n        {\\n            ListNode* next = curr->next;\\n            curr->next = prev;\\n            prev = curr;\\n            curr = next;\\n        }\\n        return prev;\\n    }\\n    \\n    void merge(ListNode* l1, ListNode* l2)\\n    {\\n        while(l2 != NULL)\\n        {\\n            ListNode* next = l1->next;\\n            l1->next = l2;\\n            l1 = l2;\\n            l2 = next;\\n        }\\n    }\\n    \\n    void reorderList(ListNode* head) {\\n        if(head == NULL || head->next == NULL)\\n            return ;\\n        \\n        ListNode* prev = head;\\n        ListNode* slow = head;\\n        ListNode* fast = head;\\n        \\n        while(fast && fast->next)\\n        {\\n            prev = slow;\\n            slow = slow->next;\\n            fast = fast->next->next;\\n        }\\n        \\n        prev->next = NULL;\\n        \\n        ListNode* l1 = head;\\n        \\n        ListNode* l2 = reverse(slow);\\n        \\n        merge(l1,l2);\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nListNode* reverse(ListNode* slow)\\n    {\\n        ListNode* prev = NULL;\\n        ListNode* curr = slow;\\n        while(curr != NULL)\\n        {\\n            ListNode* next = curr->next;\\n            curr->next = prev;\\n            prev = curr;\\n            curr = next;\\n        }\\n        return prev;\\n    }\\n    \\n    void merge(ListNode* l1, ListNode* l2)\\n    {\\n        while(l2 != NULL)\\n        {\\n            ListNode* next = l1->next;\\n            l1->next = l2;\\n            l1 = l2;\\n            l2 = next;\\n        }\\n    }\\n    \\n    void reorderList(ListNode* head) {\\n        if(head == NULL || head->next == NULL)\\n            return ;\\n        \\n        ListNode* prev = head;\\n        ListNode* slow = head;\\n        ListNode* fast = head;\\n        \\n        while(fast && fast->next)\\n        {\\n            prev = slow;\\n            slow = slow->next;\\n            fast = fast->next->next;\\n        }\\n        \\n        prev->next = NULL;\\n        \\n        ListNode* l1 = head;\\n        \\n        ListNode* l2 = reverse(slow);\\n        \\n        merge(l1,l2);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1640927,
                "title": "simple-java-solution-using-stack",
                "content": "stack can be used to store data so that when we pop we have last node which needed to be fit in middle everytime. \\n```\\npublic void reorderList(ListNode head) {\\n    ListNode temp = head;\\n    Deque<ListNode> stack = new LinkedList<>();\\n    //add elements to the stack\\n    while(temp!=null) {\\n        stack.push(temp);\\n        temp=temp.next;\\n    }\\n    \\n    int count=(stack.size())/2;\\n    temp=head;\\n    //start taking each element from stack and add it to the list.\\n    while (count-->0) {\\n        ListNode next = temp.next;\\n        temp.next=stack.pop();\\n        temp.next.next=next;\\n        temp=next;\\n    }\\n    //reset last node next to avoid loop in linkedlist\\n    temp.next=null; \\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Stack"
                ],
                "code": "```\\npublic void reorderList(ListNode head) {\\n    ListNode temp = head;\\n    Deque<ListNode> stack = new LinkedList<>();\\n    //add elements to the stack\\n    while(temp!=null) {\\n        stack.push(temp);\\n        temp=temp.next;\\n    }\\n    \\n    int count=(stack.size())/2;\\n    temp=head;\\n    //start taking each element from stack and add it to the list.\\n    while (count-->0) {\\n        ListNode next = temp.next;\\n        temp.next=stack.pop();\\n        temp.next.next=next;\\n        temp=next;\\n    }\\n    //reset last node next to avoid loop in linkedlist\\n    temp.next=null; \\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1640489,
                "title": "java-easy-solution",
                "content": "\\tclass Solution {\\n    public void reorderList(ListNode head) {\\n        left = head;\\n        dfs(head);\\n    }\\n    \\n    ListNode left = null;\\n    public void dfs(ListNode right){\\n        if(right == null)\\n            return;\\n        \\n        dfs(right.next);\\n        \\n        if(left.next != null){\\n            ListNode lNext = left.next;\\n            left.next = right;\\n            right.next = lNext;\\n            left = lNext;\\n        }\\n        if(left.next == right){\\n            left.next = null;\\n        }\\n        \\n    \\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Depth-First Search"
                ],
                "code": "class Solution {\\n    public void reorderList(ListNode head) {\\n        left = head;\\n        dfs(head);\\n    }",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1695325,
                "content": [
                    {
                        "username": "bugslayer312",
                        "content": "1. Find the middle by moving fast & slow iterators.\\n2. Remember right part beginning and cut off left part from the right.\\n3. Reverse right list, remember it new beginning.\\n4. Iterate left part from beginning and right part merging right list nodes into left list."
                    },
                    {
                        "username": "Aryadev19",
                        "content": "Thanks to this I was able to code it myself, thinking this solution was not easy"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "[@letsstart2020](/letsstart2020) because without cutting or making the previous pointer of the mid half resulting in making the graph, two pointers pointing the same node, so it will definitely give some pain to the programmer"
                    },
                    {
                        "username": "tejasX",
                        "content": "[@user9333qj](/user9333qj) \n\nSOLUTION BELOW:\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n```\nclass Solution {\npublic:\n\n    ListNode* getMiddle(ListNode* head){\n        ListNode* slow = head;\n        ListNode* fast = head;\n\n        while(fast){\n            if(!fast->next or !fast->next->next) return slow;\n            fast = fast->next->next;\n            slow = slow->next;\n        }\n\n        return slow;\n    }\n\n    ListNode* reverseList(ListNode* head){\n        if(!head) return head;\n\n        ListNode* prev = NULL;\n        ListNode* cur = head;\n        ListNode* nex = cur->next;\n\n        while(cur){\n            cur->next = prev;\n            prev = cur;\n            cur = nex;\n            if(nex) nex = nex->next;\n        }\n\n        return prev;\n    }\n\n    void reorderList(ListNode* head) {\n        ListNode* mid = getMiddle(head);\n        ListNode* nextPart = mid->next;\n        mid->next = NULL;\n\n        //two pointer:\n        ListNode* l1 = head;\n        ListNode* l2 = reverseList(nextPart);\n\n        ListNode* result = new ListNode(-1);\n        ListNode* res = result;\n\n        while(l1 or l2){\n            if(l1) {\n                res->next = l1;\n                res = res->next;\n                l1 = l1->next;\n            }\n            if(l2){\n                res->next = l2;\n                res = res->next;\n                l2 = l2->next;\n            }\n        }\n\n        res->next = NULL;\n        result->next = NULL;\n        return;\n    }\n};\n```\n"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "That\\'s of great help without posting solution "
                    },
                    {
                        "username": "songyang_dev",
                        "content": "Thanks! Step 2 solved my cycles"
                    },
                    {
                        "username": "letsstart2020",
                        "content": "I did not cut the two lists and was getting time limit exceeded, could you please explain why as i am new to linked list"
                    },
                    {
                        "username": "user9333qj",
                        "content": "I used the same method, but it is showing error. Could you please provide me with the code, If possible? \\nThanks."
                    },
                    {
                        "username": "harishaseri28",
                        "content": "I used this approach only."
                    },
                    {
                        "username": "mariohdez",
                        "content": "To be honest, the concepts aren\\'t super hard here. But I think the combination of reversal + merging operations during an interview settting makes this problem on the harder end of medium problems. This, coupled with the fact you have to recognize that in order to get the new order, you have to reverse the second half, then merge the two halves. IDK, seems hard to do in 45 minutes. Took me 10 minutes to figure out the pattern, and 40 minutes to code."
                    },
                    {
                        "username": "eiqnaict",
                        "content": "I solved it by using O(N) space in O(N) time."
                    },
                    {
                        "username": "Jayacha",
                        "content": "good job \\n"
                    },
                    {
                        "username": "AshishBibyan",
                        "content": "I used a stack for this solution to store the 2nd half of the list.\\nLater iteratively popped the last node from the stack and inserted it after the current node of the list and progressed until the stack is empty."
                    },
                    {
                        "username": "hafid-hub",
                        "content": "I used this approach in first time. I code and pass the tests. But $$O(n)$$  as space complexity... We can do better, right?\\nHow?\\nAfter about 4 hours, doing some sport exercises, I get the idea: reverse the second part! "
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "[@deepsym](/deepsym) uski marzi bhai \\uD83D\\uDE02"
                    },
                    {
                        "username": "coder42032",
                        "content": "I also applied this approach.\\n"
                    },
                    {
                        "username": "deepsym",
                        "content": "You could do this with O(1) space complexity."
                    },
                    {
                        "username": "dimal97psn",
                        "content": "Input:\\t[]\\nOutput:\\t[]\\nExpected:\\t{}"
                    },
                    {
                        "username": "Naveen_somireddy",
                        "content": "i used deque to solve this question .\\ni have copied the complete list into deque and iterated it from front and back succesivley"
                    },
                    {
                        "username": "brutalaty",
                        "content": "[@nikalinov](/nikalinov) I can\\'t see that as a restriction, was this problem updated ?"
                    },
                    {
                        "username": "nikalinov",
                        "content": "that is not O(1) space complexity tho"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 22.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/reorder-list/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Reverse the Second Part of the List and Merge Two Sorted Lists\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "chailattewithcream",
                        "content": "So stupid. I forgot to remove my \"print\" from while I was debugging and gave me TLE, ended spending a long time wondering why lol."
                    },
                    {
                        "username": "naman-exe",
                        "content": "this sucks mate, i did this in a contest for 50 mins"
                    },
                    {
                        "username": "Shengmin.Zhang",
                        "content": "What if there are odd number of nodes?\\n\\nFor example:\\n\\nL: L0\\n\\nWhat's the result?\\n\\nL: L0 -> L0?"
                    },
                    {
                        "username": "ryanthompson591",
                        "content": "I made a special case for odd nodes. If you think about it the very last node will be that middle node.\\n\\nExample:\\nL1->L2->L3-L4->L5\\nwil be\\nL1->L5->L2->L4->L3"
                    },
                    {
                        "username": "AshishBibyan",
                        "content": "After the stack is empty, make the last node point to NULL to remove this unwanted loop,"
                    },
                    {
                        "username": "danoob",
                        "content": "I am asking this because I am trying to use stack for my solution. Is it considered in-place ?"
                    },
                    {
                        "username": "BigDT",
                        "content": "that would be using extra space which isn\\'t optimal"
                    }
                ]
            },
            {
                "id": 1716671,
                "content": [
                    {
                        "username": "bugslayer312",
                        "content": "1. Find the middle by moving fast & slow iterators.\\n2. Remember right part beginning and cut off left part from the right.\\n3. Reverse right list, remember it new beginning.\\n4. Iterate left part from beginning and right part merging right list nodes into left list."
                    },
                    {
                        "username": "Aryadev19",
                        "content": "Thanks to this I was able to code it myself, thinking this solution was not easy"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "[@letsstart2020](/letsstart2020) because without cutting or making the previous pointer of the mid half resulting in making the graph, two pointers pointing the same node, so it will definitely give some pain to the programmer"
                    },
                    {
                        "username": "tejasX",
                        "content": "[@user9333qj](/user9333qj) \n\nSOLUTION BELOW:\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n```\nclass Solution {\npublic:\n\n    ListNode* getMiddle(ListNode* head){\n        ListNode* slow = head;\n        ListNode* fast = head;\n\n        while(fast){\n            if(!fast->next or !fast->next->next) return slow;\n            fast = fast->next->next;\n            slow = slow->next;\n        }\n\n        return slow;\n    }\n\n    ListNode* reverseList(ListNode* head){\n        if(!head) return head;\n\n        ListNode* prev = NULL;\n        ListNode* cur = head;\n        ListNode* nex = cur->next;\n\n        while(cur){\n            cur->next = prev;\n            prev = cur;\n            cur = nex;\n            if(nex) nex = nex->next;\n        }\n\n        return prev;\n    }\n\n    void reorderList(ListNode* head) {\n        ListNode* mid = getMiddle(head);\n        ListNode* nextPart = mid->next;\n        mid->next = NULL;\n\n        //two pointer:\n        ListNode* l1 = head;\n        ListNode* l2 = reverseList(nextPart);\n\n        ListNode* result = new ListNode(-1);\n        ListNode* res = result;\n\n        while(l1 or l2){\n            if(l1) {\n                res->next = l1;\n                res = res->next;\n                l1 = l1->next;\n            }\n            if(l2){\n                res->next = l2;\n                res = res->next;\n                l2 = l2->next;\n            }\n        }\n\n        res->next = NULL;\n        result->next = NULL;\n        return;\n    }\n};\n```\n"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "That\\'s of great help without posting solution "
                    },
                    {
                        "username": "songyang_dev",
                        "content": "Thanks! Step 2 solved my cycles"
                    },
                    {
                        "username": "letsstart2020",
                        "content": "I did not cut the two lists and was getting time limit exceeded, could you please explain why as i am new to linked list"
                    },
                    {
                        "username": "user9333qj",
                        "content": "I used the same method, but it is showing error. Could you please provide me with the code, If possible? \\nThanks."
                    },
                    {
                        "username": "harishaseri28",
                        "content": "I used this approach only."
                    },
                    {
                        "username": "mariohdez",
                        "content": "To be honest, the concepts aren\\'t super hard here. But I think the combination of reversal + merging operations during an interview settting makes this problem on the harder end of medium problems. This, coupled with the fact you have to recognize that in order to get the new order, you have to reverse the second half, then merge the two halves. IDK, seems hard to do in 45 minutes. Took me 10 minutes to figure out the pattern, and 40 minutes to code."
                    },
                    {
                        "username": "eiqnaict",
                        "content": "I solved it by using O(N) space in O(N) time."
                    },
                    {
                        "username": "Jayacha",
                        "content": "good job \\n"
                    },
                    {
                        "username": "AshishBibyan",
                        "content": "I used a stack for this solution to store the 2nd half of the list.\\nLater iteratively popped the last node from the stack and inserted it after the current node of the list and progressed until the stack is empty."
                    },
                    {
                        "username": "hafid-hub",
                        "content": "I used this approach in first time. I code and pass the tests. But $$O(n)$$  as space complexity... We can do better, right?\\nHow?\\nAfter about 4 hours, doing some sport exercises, I get the idea: reverse the second part! "
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "[@deepsym](/deepsym) uski marzi bhai \\uD83D\\uDE02"
                    },
                    {
                        "username": "coder42032",
                        "content": "I also applied this approach.\\n"
                    },
                    {
                        "username": "deepsym",
                        "content": "You could do this with O(1) space complexity."
                    },
                    {
                        "username": "dimal97psn",
                        "content": "Input:\\t[]\\nOutput:\\t[]\\nExpected:\\t{}"
                    },
                    {
                        "username": "Naveen_somireddy",
                        "content": "i used deque to solve this question .\\ni have copied the complete list into deque and iterated it from front and back succesivley"
                    },
                    {
                        "username": "brutalaty",
                        "content": "[@nikalinov](/nikalinov) I can\\'t see that as a restriction, was this problem updated ?"
                    },
                    {
                        "username": "nikalinov",
                        "content": "that is not O(1) space complexity tho"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 22.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/reorder-list/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Reverse the Second Part of the List and Merge Two Sorted Lists\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "chailattewithcream",
                        "content": "So stupid. I forgot to remove my \"print\" from while I was debugging and gave me TLE, ended spending a long time wondering why lol."
                    },
                    {
                        "username": "naman-exe",
                        "content": "this sucks mate, i did this in a contest for 50 mins"
                    },
                    {
                        "username": "Shengmin.Zhang",
                        "content": "What if there are odd number of nodes?\\n\\nFor example:\\n\\nL: L0\\n\\nWhat's the result?\\n\\nL: L0 -> L0?"
                    },
                    {
                        "username": "ryanthompson591",
                        "content": "I made a special case for odd nodes. If you think about it the very last node will be that middle node.\\n\\nExample:\\nL1->L2->L3-L4->L5\\nwil be\\nL1->L5->L2->L4->L3"
                    },
                    {
                        "username": "AshishBibyan",
                        "content": "After the stack is empty, make the last node point to NULL to remove this unwanted loop,"
                    },
                    {
                        "username": "danoob",
                        "content": "I am asking this because I am trying to use stack for my solution. Is it considered in-place ?"
                    },
                    {
                        "username": "BigDT",
                        "content": "that would be using extra space which isn\\'t optimal"
                    }
                ]
            },
            {
                "id": 1565741,
                "content": [
                    {
                        "username": "bugslayer312",
                        "content": "1. Find the middle by moving fast & slow iterators.\\n2. Remember right part beginning and cut off left part from the right.\\n3. Reverse right list, remember it new beginning.\\n4. Iterate left part from beginning and right part merging right list nodes into left list."
                    },
                    {
                        "username": "Aryadev19",
                        "content": "Thanks to this I was able to code it myself, thinking this solution was not easy"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "[@letsstart2020](/letsstart2020) because without cutting or making the previous pointer of the mid half resulting in making the graph, two pointers pointing the same node, so it will definitely give some pain to the programmer"
                    },
                    {
                        "username": "tejasX",
                        "content": "[@user9333qj](/user9333qj) \n\nSOLUTION BELOW:\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n```\nclass Solution {\npublic:\n\n    ListNode* getMiddle(ListNode* head){\n        ListNode* slow = head;\n        ListNode* fast = head;\n\n        while(fast){\n            if(!fast->next or !fast->next->next) return slow;\n            fast = fast->next->next;\n            slow = slow->next;\n        }\n\n        return slow;\n    }\n\n    ListNode* reverseList(ListNode* head){\n        if(!head) return head;\n\n        ListNode* prev = NULL;\n        ListNode* cur = head;\n        ListNode* nex = cur->next;\n\n        while(cur){\n            cur->next = prev;\n            prev = cur;\n            cur = nex;\n            if(nex) nex = nex->next;\n        }\n\n        return prev;\n    }\n\n    void reorderList(ListNode* head) {\n        ListNode* mid = getMiddle(head);\n        ListNode* nextPart = mid->next;\n        mid->next = NULL;\n\n        //two pointer:\n        ListNode* l1 = head;\n        ListNode* l2 = reverseList(nextPart);\n\n        ListNode* result = new ListNode(-1);\n        ListNode* res = result;\n\n        while(l1 or l2){\n            if(l1) {\n                res->next = l1;\n                res = res->next;\n                l1 = l1->next;\n            }\n            if(l2){\n                res->next = l2;\n                res = res->next;\n                l2 = l2->next;\n            }\n        }\n\n        res->next = NULL;\n        result->next = NULL;\n        return;\n    }\n};\n```\n"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "That\\'s of great help without posting solution "
                    },
                    {
                        "username": "songyang_dev",
                        "content": "Thanks! Step 2 solved my cycles"
                    },
                    {
                        "username": "letsstart2020",
                        "content": "I did not cut the two lists and was getting time limit exceeded, could you please explain why as i am new to linked list"
                    },
                    {
                        "username": "user9333qj",
                        "content": "I used the same method, but it is showing error. Could you please provide me with the code, If possible? \\nThanks."
                    },
                    {
                        "username": "harishaseri28",
                        "content": "I used this approach only."
                    },
                    {
                        "username": "mariohdez",
                        "content": "To be honest, the concepts aren\\'t super hard here. But I think the combination of reversal + merging operations during an interview settting makes this problem on the harder end of medium problems. This, coupled with the fact you have to recognize that in order to get the new order, you have to reverse the second half, then merge the two halves. IDK, seems hard to do in 45 minutes. Took me 10 minutes to figure out the pattern, and 40 minutes to code."
                    },
                    {
                        "username": "eiqnaict",
                        "content": "I solved it by using O(N) space in O(N) time."
                    },
                    {
                        "username": "Jayacha",
                        "content": "good job \\n"
                    },
                    {
                        "username": "AshishBibyan",
                        "content": "I used a stack for this solution to store the 2nd half of the list.\\nLater iteratively popped the last node from the stack and inserted it after the current node of the list and progressed until the stack is empty."
                    },
                    {
                        "username": "hafid-hub",
                        "content": "I used this approach in first time. I code and pass the tests. But $$O(n)$$  as space complexity... We can do better, right?\\nHow?\\nAfter about 4 hours, doing some sport exercises, I get the idea: reverse the second part! "
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "[@deepsym](/deepsym) uski marzi bhai \\uD83D\\uDE02"
                    },
                    {
                        "username": "coder42032",
                        "content": "I also applied this approach.\\n"
                    },
                    {
                        "username": "deepsym",
                        "content": "You could do this with O(1) space complexity."
                    },
                    {
                        "username": "dimal97psn",
                        "content": "Input:\\t[]\\nOutput:\\t[]\\nExpected:\\t{}"
                    },
                    {
                        "username": "Naveen_somireddy",
                        "content": "i used deque to solve this question .\\ni have copied the complete list into deque and iterated it from front and back succesivley"
                    },
                    {
                        "username": "brutalaty",
                        "content": "[@nikalinov](/nikalinov) I can\\'t see that as a restriction, was this problem updated ?"
                    },
                    {
                        "username": "nikalinov",
                        "content": "that is not O(1) space complexity tho"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 22.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/reorder-list/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Reverse the Second Part of the List and Merge Two Sorted Lists\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "chailattewithcream",
                        "content": "So stupid. I forgot to remove my \"print\" from while I was debugging and gave me TLE, ended spending a long time wondering why lol."
                    },
                    {
                        "username": "naman-exe",
                        "content": "this sucks mate, i did this in a contest for 50 mins"
                    },
                    {
                        "username": "Shengmin.Zhang",
                        "content": "What if there are odd number of nodes?\\n\\nFor example:\\n\\nL: L0\\n\\nWhat's the result?\\n\\nL: L0 -> L0?"
                    },
                    {
                        "username": "ryanthompson591",
                        "content": "I made a special case for odd nodes. If you think about it the very last node will be that middle node.\\n\\nExample:\\nL1->L2->L3-L4->L5\\nwil be\\nL1->L5->L2->L4->L3"
                    },
                    {
                        "username": "AshishBibyan",
                        "content": "After the stack is empty, make the last node point to NULL to remove this unwanted loop,"
                    },
                    {
                        "username": "danoob",
                        "content": "I am asking this because I am trying to use stack for my solution. Is it considered in-place ?"
                    },
                    {
                        "username": "BigDT",
                        "content": "that would be using extra space which isn\\'t optimal"
                    }
                ]
            },
            {
                "id": 1636670,
                "content": [
                    {
                        "username": "bugslayer312",
                        "content": "1. Find the middle by moving fast & slow iterators.\\n2. Remember right part beginning and cut off left part from the right.\\n3. Reverse right list, remember it new beginning.\\n4. Iterate left part from beginning and right part merging right list nodes into left list."
                    },
                    {
                        "username": "Aryadev19",
                        "content": "Thanks to this I was able to code it myself, thinking this solution was not easy"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "[@letsstart2020](/letsstart2020) because without cutting or making the previous pointer of the mid half resulting in making the graph, two pointers pointing the same node, so it will definitely give some pain to the programmer"
                    },
                    {
                        "username": "tejasX",
                        "content": "[@user9333qj](/user9333qj) \n\nSOLUTION BELOW:\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n```\nclass Solution {\npublic:\n\n    ListNode* getMiddle(ListNode* head){\n        ListNode* slow = head;\n        ListNode* fast = head;\n\n        while(fast){\n            if(!fast->next or !fast->next->next) return slow;\n            fast = fast->next->next;\n            slow = slow->next;\n        }\n\n        return slow;\n    }\n\n    ListNode* reverseList(ListNode* head){\n        if(!head) return head;\n\n        ListNode* prev = NULL;\n        ListNode* cur = head;\n        ListNode* nex = cur->next;\n\n        while(cur){\n            cur->next = prev;\n            prev = cur;\n            cur = nex;\n            if(nex) nex = nex->next;\n        }\n\n        return prev;\n    }\n\n    void reorderList(ListNode* head) {\n        ListNode* mid = getMiddle(head);\n        ListNode* nextPart = mid->next;\n        mid->next = NULL;\n\n        //two pointer:\n        ListNode* l1 = head;\n        ListNode* l2 = reverseList(nextPart);\n\n        ListNode* result = new ListNode(-1);\n        ListNode* res = result;\n\n        while(l1 or l2){\n            if(l1) {\n                res->next = l1;\n                res = res->next;\n                l1 = l1->next;\n            }\n            if(l2){\n                res->next = l2;\n                res = res->next;\n                l2 = l2->next;\n            }\n        }\n\n        res->next = NULL;\n        result->next = NULL;\n        return;\n    }\n};\n```\n"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "That\\'s of great help without posting solution "
                    },
                    {
                        "username": "songyang_dev",
                        "content": "Thanks! Step 2 solved my cycles"
                    },
                    {
                        "username": "letsstart2020",
                        "content": "I did not cut the two lists and was getting time limit exceeded, could you please explain why as i am new to linked list"
                    },
                    {
                        "username": "user9333qj",
                        "content": "I used the same method, but it is showing error. Could you please provide me with the code, If possible? \\nThanks."
                    },
                    {
                        "username": "harishaseri28",
                        "content": "I used this approach only."
                    },
                    {
                        "username": "mariohdez",
                        "content": "To be honest, the concepts aren\\'t super hard here. But I think the combination of reversal + merging operations during an interview settting makes this problem on the harder end of medium problems. This, coupled with the fact you have to recognize that in order to get the new order, you have to reverse the second half, then merge the two halves. IDK, seems hard to do in 45 minutes. Took me 10 minutes to figure out the pattern, and 40 minutes to code."
                    },
                    {
                        "username": "eiqnaict",
                        "content": "I solved it by using O(N) space in O(N) time."
                    },
                    {
                        "username": "Jayacha",
                        "content": "good job \\n"
                    },
                    {
                        "username": "AshishBibyan",
                        "content": "I used a stack for this solution to store the 2nd half of the list.\\nLater iteratively popped the last node from the stack and inserted it after the current node of the list and progressed until the stack is empty."
                    },
                    {
                        "username": "hafid-hub",
                        "content": "I used this approach in first time. I code and pass the tests. But $$O(n)$$  as space complexity... We can do better, right?\\nHow?\\nAfter about 4 hours, doing some sport exercises, I get the idea: reverse the second part! "
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "[@deepsym](/deepsym) uski marzi bhai \\uD83D\\uDE02"
                    },
                    {
                        "username": "coder42032",
                        "content": "I also applied this approach.\\n"
                    },
                    {
                        "username": "deepsym",
                        "content": "You could do this with O(1) space complexity."
                    },
                    {
                        "username": "dimal97psn",
                        "content": "Input:\\t[]\\nOutput:\\t[]\\nExpected:\\t{}"
                    },
                    {
                        "username": "Naveen_somireddy",
                        "content": "i used deque to solve this question .\\ni have copied the complete list into deque and iterated it from front and back succesivley"
                    },
                    {
                        "username": "brutalaty",
                        "content": "[@nikalinov](/nikalinov) I can\\'t see that as a restriction, was this problem updated ?"
                    },
                    {
                        "username": "nikalinov",
                        "content": "that is not O(1) space complexity tho"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 22.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/reorder-list/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Reverse the Second Part of the List and Merge Two Sorted Lists\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "chailattewithcream",
                        "content": "So stupid. I forgot to remove my \"print\" from while I was debugging and gave me TLE, ended spending a long time wondering why lol."
                    },
                    {
                        "username": "naman-exe",
                        "content": "this sucks mate, i did this in a contest for 50 mins"
                    },
                    {
                        "username": "Shengmin.Zhang",
                        "content": "What if there are odd number of nodes?\\n\\nFor example:\\n\\nL: L0\\n\\nWhat's the result?\\n\\nL: L0 -> L0?"
                    },
                    {
                        "username": "ryanthompson591",
                        "content": "I made a special case for odd nodes. If you think about it the very last node will be that middle node.\\n\\nExample:\\nL1->L2->L3-L4->L5\\nwil be\\nL1->L5->L2->L4->L3"
                    },
                    {
                        "username": "AshishBibyan",
                        "content": "After the stack is empty, make the last node point to NULL to remove this unwanted loop,"
                    },
                    {
                        "username": "danoob",
                        "content": "I am asking this because I am trying to use stack for my solution. Is it considered in-place ?"
                    },
                    {
                        "username": "BigDT",
                        "content": "that would be using extra space which isn\\'t optimal"
                    }
                ]
            },
            {
                "id": 1566241,
                "content": [
                    {
                        "username": "bugslayer312",
                        "content": "1. Find the middle by moving fast & slow iterators.\\n2. Remember right part beginning and cut off left part from the right.\\n3. Reverse right list, remember it new beginning.\\n4. Iterate left part from beginning and right part merging right list nodes into left list."
                    },
                    {
                        "username": "Aryadev19",
                        "content": "Thanks to this I was able to code it myself, thinking this solution was not easy"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "[@letsstart2020](/letsstart2020) because without cutting or making the previous pointer of the mid half resulting in making the graph, two pointers pointing the same node, so it will definitely give some pain to the programmer"
                    },
                    {
                        "username": "tejasX",
                        "content": "[@user9333qj](/user9333qj) \n\nSOLUTION BELOW:\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n```\nclass Solution {\npublic:\n\n    ListNode* getMiddle(ListNode* head){\n        ListNode* slow = head;\n        ListNode* fast = head;\n\n        while(fast){\n            if(!fast->next or !fast->next->next) return slow;\n            fast = fast->next->next;\n            slow = slow->next;\n        }\n\n        return slow;\n    }\n\n    ListNode* reverseList(ListNode* head){\n        if(!head) return head;\n\n        ListNode* prev = NULL;\n        ListNode* cur = head;\n        ListNode* nex = cur->next;\n\n        while(cur){\n            cur->next = prev;\n            prev = cur;\n            cur = nex;\n            if(nex) nex = nex->next;\n        }\n\n        return prev;\n    }\n\n    void reorderList(ListNode* head) {\n        ListNode* mid = getMiddle(head);\n        ListNode* nextPart = mid->next;\n        mid->next = NULL;\n\n        //two pointer:\n        ListNode* l1 = head;\n        ListNode* l2 = reverseList(nextPart);\n\n        ListNode* result = new ListNode(-1);\n        ListNode* res = result;\n\n        while(l1 or l2){\n            if(l1) {\n                res->next = l1;\n                res = res->next;\n                l1 = l1->next;\n            }\n            if(l2){\n                res->next = l2;\n                res = res->next;\n                l2 = l2->next;\n            }\n        }\n\n        res->next = NULL;\n        result->next = NULL;\n        return;\n    }\n};\n```\n"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "That\\'s of great help without posting solution "
                    },
                    {
                        "username": "songyang_dev",
                        "content": "Thanks! Step 2 solved my cycles"
                    },
                    {
                        "username": "letsstart2020",
                        "content": "I did not cut the two lists and was getting time limit exceeded, could you please explain why as i am new to linked list"
                    },
                    {
                        "username": "user9333qj",
                        "content": "I used the same method, but it is showing error. Could you please provide me with the code, If possible? \\nThanks."
                    },
                    {
                        "username": "harishaseri28",
                        "content": "I used this approach only."
                    },
                    {
                        "username": "mariohdez",
                        "content": "To be honest, the concepts aren\\'t super hard here. But I think the combination of reversal + merging operations during an interview settting makes this problem on the harder end of medium problems. This, coupled with the fact you have to recognize that in order to get the new order, you have to reverse the second half, then merge the two halves. IDK, seems hard to do in 45 minutes. Took me 10 minutes to figure out the pattern, and 40 minutes to code."
                    },
                    {
                        "username": "eiqnaict",
                        "content": "I solved it by using O(N) space in O(N) time."
                    },
                    {
                        "username": "Jayacha",
                        "content": "good job \\n"
                    },
                    {
                        "username": "AshishBibyan",
                        "content": "I used a stack for this solution to store the 2nd half of the list.\\nLater iteratively popped the last node from the stack and inserted it after the current node of the list and progressed until the stack is empty."
                    },
                    {
                        "username": "hafid-hub",
                        "content": "I used this approach in first time. I code and pass the tests. But $$O(n)$$  as space complexity... We can do better, right?\\nHow?\\nAfter about 4 hours, doing some sport exercises, I get the idea: reverse the second part! "
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "[@deepsym](/deepsym) uski marzi bhai \\uD83D\\uDE02"
                    },
                    {
                        "username": "coder42032",
                        "content": "I also applied this approach.\\n"
                    },
                    {
                        "username": "deepsym",
                        "content": "You could do this with O(1) space complexity."
                    },
                    {
                        "username": "dimal97psn",
                        "content": "Input:\\t[]\\nOutput:\\t[]\\nExpected:\\t{}"
                    },
                    {
                        "username": "Naveen_somireddy",
                        "content": "i used deque to solve this question .\\ni have copied the complete list into deque and iterated it from front and back succesivley"
                    },
                    {
                        "username": "brutalaty",
                        "content": "[@nikalinov](/nikalinov) I can\\'t see that as a restriction, was this problem updated ?"
                    },
                    {
                        "username": "nikalinov",
                        "content": "that is not O(1) space complexity tho"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 22.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/reorder-list/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Reverse the Second Part of the List and Merge Two Sorted Lists\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "chailattewithcream",
                        "content": "So stupid. I forgot to remove my \"print\" from while I was debugging and gave me TLE, ended spending a long time wondering why lol."
                    },
                    {
                        "username": "naman-exe",
                        "content": "this sucks mate, i did this in a contest for 50 mins"
                    },
                    {
                        "username": "Shengmin.Zhang",
                        "content": "What if there are odd number of nodes?\\n\\nFor example:\\n\\nL: L0\\n\\nWhat's the result?\\n\\nL: L0 -> L0?"
                    },
                    {
                        "username": "ryanthompson591",
                        "content": "I made a special case for odd nodes. If you think about it the very last node will be that middle node.\\n\\nExample:\\nL1->L2->L3-L4->L5\\nwil be\\nL1->L5->L2->L4->L3"
                    },
                    {
                        "username": "AshishBibyan",
                        "content": "After the stack is empty, make the last node point to NULL to remove this unwanted loop,"
                    },
                    {
                        "username": "danoob",
                        "content": "I am asking this because I am trying to use stack for my solution. Is it considered in-place ?"
                    },
                    {
                        "username": "BigDT",
                        "content": "that would be using extra space which isn\\'t optimal"
                    }
                ]
            },
            {
                "id": 1733040,
                "content": [
                    {
                        "username": "bugslayer312",
                        "content": "1. Find the middle by moving fast & slow iterators.\\n2. Remember right part beginning and cut off left part from the right.\\n3. Reverse right list, remember it new beginning.\\n4. Iterate left part from beginning and right part merging right list nodes into left list."
                    },
                    {
                        "username": "Aryadev19",
                        "content": "Thanks to this I was able to code it myself, thinking this solution was not easy"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "[@letsstart2020](/letsstart2020) because without cutting or making the previous pointer of the mid half resulting in making the graph, two pointers pointing the same node, so it will definitely give some pain to the programmer"
                    },
                    {
                        "username": "tejasX",
                        "content": "[@user9333qj](/user9333qj) \n\nSOLUTION BELOW:\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n```\nclass Solution {\npublic:\n\n    ListNode* getMiddle(ListNode* head){\n        ListNode* slow = head;\n        ListNode* fast = head;\n\n        while(fast){\n            if(!fast->next or !fast->next->next) return slow;\n            fast = fast->next->next;\n            slow = slow->next;\n        }\n\n        return slow;\n    }\n\n    ListNode* reverseList(ListNode* head){\n        if(!head) return head;\n\n        ListNode* prev = NULL;\n        ListNode* cur = head;\n        ListNode* nex = cur->next;\n\n        while(cur){\n            cur->next = prev;\n            prev = cur;\n            cur = nex;\n            if(nex) nex = nex->next;\n        }\n\n        return prev;\n    }\n\n    void reorderList(ListNode* head) {\n        ListNode* mid = getMiddle(head);\n        ListNode* nextPart = mid->next;\n        mid->next = NULL;\n\n        //two pointer:\n        ListNode* l1 = head;\n        ListNode* l2 = reverseList(nextPart);\n\n        ListNode* result = new ListNode(-1);\n        ListNode* res = result;\n\n        while(l1 or l2){\n            if(l1) {\n                res->next = l1;\n                res = res->next;\n                l1 = l1->next;\n            }\n            if(l2){\n                res->next = l2;\n                res = res->next;\n                l2 = l2->next;\n            }\n        }\n\n        res->next = NULL;\n        result->next = NULL;\n        return;\n    }\n};\n```\n"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "That\\'s of great help without posting solution "
                    },
                    {
                        "username": "songyang_dev",
                        "content": "Thanks! Step 2 solved my cycles"
                    },
                    {
                        "username": "letsstart2020",
                        "content": "I did not cut the two lists and was getting time limit exceeded, could you please explain why as i am new to linked list"
                    },
                    {
                        "username": "user9333qj",
                        "content": "I used the same method, but it is showing error. Could you please provide me with the code, If possible? \\nThanks."
                    },
                    {
                        "username": "harishaseri28",
                        "content": "I used this approach only."
                    },
                    {
                        "username": "mariohdez",
                        "content": "To be honest, the concepts aren\\'t super hard here. But I think the combination of reversal + merging operations during an interview settting makes this problem on the harder end of medium problems. This, coupled with the fact you have to recognize that in order to get the new order, you have to reverse the second half, then merge the two halves. IDK, seems hard to do in 45 minutes. Took me 10 minutes to figure out the pattern, and 40 minutes to code."
                    },
                    {
                        "username": "eiqnaict",
                        "content": "I solved it by using O(N) space in O(N) time."
                    },
                    {
                        "username": "Jayacha",
                        "content": "good job \\n"
                    },
                    {
                        "username": "AshishBibyan",
                        "content": "I used a stack for this solution to store the 2nd half of the list.\\nLater iteratively popped the last node from the stack and inserted it after the current node of the list and progressed until the stack is empty."
                    },
                    {
                        "username": "hafid-hub",
                        "content": "I used this approach in first time. I code and pass the tests. But $$O(n)$$  as space complexity... We can do better, right?\\nHow?\\nAfter about 4 hours, doing some sport exercises, I get the idea: reverse the second part! "
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "[@deepsym](/deepsym) uski marzi bhai \\uD83D\\uDE02"
                    },
                    {
                        "username": "coder42032",
                        "content": "I also applied this approach.\\n"
                    },
                    {
                        "username": "deepsym",
                        "content": "You could do this with O(1) space complexity."
                    },
                    {
                        "username": "dimal97psn",
                        "content": "Input:\\t[]\\nOutput:\\t[]\\nExpected:\\t{}"
                    },
                    {
                        "username": "Naveen_somireddy",
                        "content": "i used deque to solve this question .\\ni have copied the complete list into deque and iterated it from front and back succesivley"
                    },
                    {
                        "username": "brutalaty",
                        "content": "[@nikalinov](/nikalinov) I can\\'t see that as a restriction, was this problem updated ?"
                    },
                    {
                        "username": "nikalinov",
                        "content": "that is not O(1) space complexity tho"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 22.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/reorder-list/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Reverse the Second Part of the List and Merge Two Sorted Lists\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "chailattewithcream",
                        "content": "So stupid. I forgot to remove my \"print\" from while I was debugging and gave me TLE, ended spending a long time wondering why lol."
                    },
                    {
                        "username": "naman-exe",
                        "content": "this sucks mate, i did this in a contest for 50 mins"
                    },
                    {
                        "username": "Shengmin.Zhang",
                        "content": "What if there are odd number of nodes?\\n\\nFor example:\\n\\nL: L0\\n\\nWhat's the result?\\n\\nL: L0 -> L0?"
                    },
                    {
                        "username": "ryanthompson591",
                        "content": "I made a special case for odd nodes. If you think about it the very last node will be that middle node.\\n\\nExample:\\nL1->L2->L3-L4->L5\\nwil be\\nL1->L5->L2->L4->L3"
                    },
                    {
                        "username": "AshishBibyan",
                        "content": "After the stack is empty, make the last node point to NULL to remove this unwanted loop,"
                    },
                    {
                        "username": "danoob",
                        "content": "I am asking this because I am trying to use stack for my solution. Is it considered in-place ?"
                    },
                    {
                        "username": "BigDT",
                        "content": "that would be using extra space which isn\\'t optimal"
                    }
                ]
            },
            {
                "id": 1565641,
                "content": [
                    {
                        "username": "bugslayer312",
                        "content": "1. Find the middle by moving fast & slow iterators.\\n2. Remember right part beginning and cut off left part from the right.\\n3. Reverse right list, remember it new beginning.\\n4. Iterate left part from beginning and right part merging right list nodes into left list."
                    },
                    {
                        "username": "Aryadev19",
                        "content": "Thanks to this I was able to code it myself, thinking this solution was not easy"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "[@letsstart2020](/letsstart2020) because without cutting or making the previous pointer of the mid half resulting in making the graph, two pointers pointing the same node, so it will definitely give some pain to the programmer"
                    },
                    {
                        "username": "tejasX",
                        "content": "[@user9333qj](/user9333qj) \n\nSOLUTION BELOW:\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n```\nclass Solution {\npublic:\n\n    ListNode* getMiddle(ListNode* head){\n        ListNode* slow = head;\n        ListNode* fast = head;\n\n        while(fast){\n            if(!fast->next or !fast->next->next) return slow;\n            fast = fast->next->next;\n            slow = slow->next;\n        }\n\n        return slow;\n    }\n\n    ListNode* reverseList(ListNode* head){\n        if(!head) return head;\n\n        ListNode* prev = NULL;\n        ListNode* cur = head;\n        ListNode* nex = cur->next;\n\n        while(cur){\n            cur->next = prev;\n            prev = cur;\n            cur = nex;\n            if(nex) nex = nex->next;\n        }\n\n        return prev;\n    }\n\n    void reorderList(ListNode* head) {\n        ListNode* mid = getMiddle(head);\n        ListNode* nextPart = mid->next;\n        mid->next = NULL;\n\n        //two pointer:\n        ListNode* l1 = head;\n        ListNode* l2 = reverseList(nextPart);\n\n        ListNode* result = new ListNode(-1);\n        ListNode* res = result;\n\n        while(l1 or l2){\n            if(l1) {\n                res->next = l1;\n                res = res->next;\n                l1 = l1->next;\n            }\n            if(l2){\n                res->next = l2;\n                res = res->next;\n                l2 = l2->next;\n            }\n        }\n\n        res->next = NULL;\n        result->next = NULL;\n        return;\n    }\n};\n```\n"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "That\\'s of great help without posting solution "
                    },
                    {
                        "username": "songyang_dev",
                        "content": "Thanks! Step 2 solved my cycles"
                    },
                    {
                        "username": "letsstart2020",
                        "content": "I did not cut the two lists and was getting time limit exceeded, could you please explain why as i am new to linked list"
                    },
                    {
                        "username": "user9333qj",
                        "content": "I used the same method, but it is showing error. Could you please provide me with the code, If possible? \\nThanks."
                    },
                    {
                        "username": "harishaseri28",
                        "content": "I used this approach only."
                    },
                    {
                        "username": "mariohdez",
                        "content": "To be honest, the concepts aren\\'t super hard here. But I think the combination of reversal + merging operations during an interview settting makes this problem on the harder end of medium problems. This, coupled with the fact you have to recognize that in order to get the new order, you have to reverse the second half, then merge the two halves. IDK, seems hard to do in 45 minutes. Took me 10 minutes to figure out the pattern, and 40 minutes to code."
                    },
                    {
                        "username": "eiqnaict",
                        "content": "I solved it by using O(N) space in O(N) time."
                    },
                    {
                        "username": "Jayacha",
                        "content": "good job \\n"
                    },
                    {
                        "username": "AshishBibyan",
                        "content": "I used a stack for this solution to store the 2nd half of the list.\\nLater iteratively popped the last node from the stack and inserted it after the current node of the list and progressed until the stack is empty."
                    },
                    {
                        "username": "hafid-hub",
                        "content": "I used this approach in first time. I code and pass the tests. But $$O(n)$$  as space complexity... We can do better, right?\\nHow?\\nAfter about 4 hours, doing some sport exercises, I get the idea: reverse the second part! "
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "[@deepsym](/deepsym) uski marzi bhai \\uD83D\\uDE02"
                    },
                    {
                        "username": "coder42032",
                        "content": "I also applied this approach.\\n"
                    },
                    {
                        "username": "deepsym",
                        "content": "You could do this with O(1) space complexity."
                    },
                    {
                        "username": "dimal97psn",
                        "content": "Input:\\t[]\\nOutput:\\t[]\\nExpected:\\t{}"
                    },
                    {
                        "username": "Naveen_somireddy",
                        "content": "i used deque to solve this question .\\ni have copied the complete list into deque and iterated it from front and back succesivley"
                    },
                    {
                        "username": "brutalaty",
                        "content": "[@nikalinov](/nikalinov) I can\\'t see that as a restriction, was this problem updated ?"
                    },
                    {
                        "username": "nikalinov",
                        "content": "that is not O(1) space complexity tho"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 22.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/reorder-list/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Reverse the Second Part of the List and Merge Two Sorted Lists\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "chailattewithcream",
                        "content": "So stupid. I forgot to remove my \"print\" from while I was debugging and gave me TLE, ended spending a long time wondering why lol."
                    },
                    {
                        "username": "naman-exe",
                        "content": "this sucks mate, i did this in a contest for 50 mins"
                    },
                    {
                        "username": "Shengmin.Zhang",
                        "content": "What if there are odd number of nodes?\\n\\nFor example:\\n\\nL: L0\\n\\nWhat's the result?\\n\\nL: L0 -> L0?"
                    },
                    {
                        "username": "ryanthompson591",
                        "content": "I made a special case for odd nodes. If you think about it the very last node will be that middle node.\\n\\nExample:\\nL1->L2->L3-L4->L5\\nwil be\\nL1->L5->L2->L4->L3"
                    },
                    {
                        "username": "AshishBibyan",
                        "content": "After the stack is empty, make the last node point to NULL to remove this unwanted loop,"
                    },
                    {
                        "username": "danoob",
                        "content": "I am asking this because I am trying to use stack for my solution. Is it considered in-place ?"
                    },
                    {
                        "username": "BigDT",
                        "content": "that would be using extra space which isn\\'t optimal"
                    }
                ]
            },
            {
                "id": 1880017,
                "content": [
                    {
                        "username": "bugslayer312",
                        "content": "1. Find the middle by moving fast & slow iterators.\\n2. Remember right part beginning and cut off left part from the right.\\n3. Reverse right list, remember it new beginning.\\n4. Iterate left part from beginning and right part merging right list nodes into left list."
                    },
                    {
                        "username": "Aryadev19",
                        "content": "Thanks to this I was able to code it myself, thinking this solution was not easy"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "[@letsstart2020](/letsstart2020) because without cutting or making the previous pointer of the mid half resulting in making the graph, two pointers pointing the same node, so it will definitely give some pain to the programmer"
                    },
                    {
                        "username": "tejasX",
                        "content": "[@user9333qj](/user9333qj) \n\nSOLUTION BELOW:\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n```\nclass Solution {\npublic:\n\n    ListNode* getMiddle(ListNode* head){\n        ListNode* slow = head;\n        ListNode* fast = head;\n\n        while(fast){\n            if(!fast->next or !fast->next->next) return slow;\n            fast = fast->next->next;\n            slow = slow->next;\n        }\n\n        return slow;\n    }\n\n    ListNode* reverseList(ListNode* head){\n        if(!head) return head;\n\n        ListNode* prev = NULL;\n        ListNode* cur = head;\n        ListNode* nex = cur->next;\n\n        while(cur){\n            cur->next = prev;\n            prev = cur;\n            cur = nex;\n            if(nex) nex = nex->next;\n        }\n\n        return prev;\n    }\n\n    void reorderList(ListNode* head) {\n        ListNode* mid = getMiddle(head);\n        ListNode* nextPart = mid->next;\n        mid->next = NULL;\n\n        //two pointer:\n        ListNode* l1 = head;\n        ListNode* l2 = reverseList(nextPart);\n\n        ListNode* result = new ListNode(-1);\n        ListNode* res = result;\n\n        while(l1 or l2){\n            if(l1) {\n                res->next = l1;\n                res = res->next;\n                l1 = l1->next;\n            }\n            if(l2){\n                res->next = l2;\n                res = res->next;\n                l2 = l2->next;\n            }\n        }\n\n        res->next = NULL;\n        result->next = NULL;\n        return;\n    }\n};\n```\n"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "That\\'s of great help without posting solution "
                    },
                    {
                        "username": "songyang_dev",
                        "content": "Thanks! Step 2 solved my cycles"
                    },
                    {
                        "username": "letsstart2020",
                        "content": "I did not cut the two lists and was getting time limit exceeded, could you please explain why as i am new to linked list"
                    },
                    {
                        "username": "user9333qj",
                        "content": "I used the same method, but it is showing error. Could you please provide me with the code, If possible? \\nThanks."
                    },
                    {
                        "username": "harishaseri28",
                        "content": "I used this approach only."
                    },
                    {
                        "username": "mariohdez",
                        "content": "To be honest, the concepts aren\\'t super hard here. But I think the combination of reversal + merging operations during an interview settting makes this problem on the harder end of medium problems. This, coupled with the fact you have to recognize that in order to get the new order, you have to reverse the second half, then merge the two halves. IDK, seems hard to do in 45 minutes. Took me 10 minutes to figure out the pattern, and 40 minutes to code."
                    },
                    {
                        "username": "eiqnaict",
                        "content": "I solved it by using O(N) space in O(N) time."
                    },
                    {
                        "username": "Jayacha",
                        "content": "good job \\n"
                    },
                    {
                        "username": "AshishBibyan",
                        "content": "I used a stack for this solution to store the 2nd half of the list.\\nLater iteratively popped the last node from the stack and inserted it after the current node of the list and progressed until the stack is empty."
                    },
                    {
                        "username": "hafid-hub",
                        "content": "I used this approach in first time. I code and pass the tests. But $$O(n)$$  as space complexity... We can do better, right?\\nHow?\\nAfter about 4 hours, doing some sport exercises, I get the idea: reverse the second part! "
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "[@deepsym](/deepsym) uski marzi bhai \\uD83D\\uDE02"
                    },
                    {
                        "username": "coder42032",
                        "content": "I also applied this approach.\\n"
                    },
                    {
                        "username": "deepsym",
                        "content": "You could do this with O(1) space complexity."
                    },
                    {
                        "username": "dimal97psn",
                        "content": "Input:\\t[]\\nOutput:\\t[]\\nExpected:\\t{}"
                    },
                    {
                        "username": "Naveen_somireddy",
                        "content": "i used deque to solve this question .\\ni have copied the complete list into deque and iterated it from front and back succesivley"
                    },
                    {
                        "username": "brutalaty",
                        "content": "[@nikalinov](/nikalinov) I can\\'t see that as a restriction, was this problem updated ?"
                    },
                    {
                        "username": "nikalinov",
                        "content": "that is not O(1) space complexity tho"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 22.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/reorder-list/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Reverse the Second Part of the List and Merge Two Sorted Lists\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "chailattewithcream",
                        "content": "So stupid. I forgot to remove my \"print\" from while I was debugging and gave me TLE, ended spending a long time wondering why lol."
                    },
                    {
                        "username": "naman-exe",
                        "content": "this sucks mate, i did this in a contest for 50 mins"
                    },
                    {
                        "username": "Shengmin.Zhang",
                        "content": "What if there are odd number of nodes?\\n\\nFor example:\\n\\nL: L0\\n\\nWhat's the result?\\n\\nL: L0 -> L0?"
                    },
                    {
                        "username": "ryanthompson591",
                        "content": "I made a special case for odd nodes. If you think about it the very last node will be that middle node.\\n\\nExample:\\nL1->L2->L3-L4->L5\\nwil be\\nL1->L5->L2->L4->L3"
                    },
                    {
                        "username": "AshishBibyan",
                        "content": "After the stack is empty, make the last node point to NULL to remove this unwanted loop,"
                    },
                    {
                        "username": "danoob",
                        "content": "I am asking this because I am trying to use stack for my solution. Is it considered in-place ?"
                    },
                    {
                        "username": "BigDT",
                        "content": "that would be using extra space which isn\\'t optimal"
                    }
                ]
            },
            {
                "id": 1568967,
                "content": [
                    {
                        "username": "bugslayer312",
                        "content": "1. Find the middle by moving fast & slow iterators.\\n2. Remember right part beginning and cut off left part from the right.\\n3. Reverse right list, remember it new beginning.\\n4. Iterate left part from beginning and right part merging right list nodes into left list."
                    },
                    {
                        "username": "Aryadev19",
                        "content": "Thanks to this I was able to code it myself, thinking this solution was not easy"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "[@letsstart2020](/letsstart2020) because without cutting or making the previous pointer of the mid half resulting in making the graph, two pointers pointing the same node, so it will definitely give some pain to the programmer"
                    },
                    {
                        "username": "tejasX",
                        "content": "[@user9333qj](/user9333qj) \n\nSOLUTION BELOW:\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n```\nclass Solution {\npublic:\n\n    ListNode* getMiddle(ListNode* head){\n        ListNode* slow = head;\n        ListNode* fast = head;\n\n        while(fast){\n            if(!fast->next or !fast->next->next) return slow;\n            fast = fast->next->next;\n            slow = slow->next;\n        }\n\n        return slow;\n    }\n\n    ListNode* reverseList(ListNode* head){\n        if(!head) return head;\n\n        ListNode* prev = NULL;\n        ListNode* cur = head;\n        ListNode* nex = cur->next;\n\n        while(cur){\n            cur->next = prev;\n            prev = cur;\n            cur = nex;\n            if(nex) nex = nex->next;\n        }\n\n        return prev;\n    }\n\n    void reorderList(ListNode* head) {\n        ListNode* mid = getMiddle(head);\n        ListNode* nextPart = mid->next;\n        mid->next = NULL;\n\n        //two pointer:\n        ListNode* l1 = head;\n        ListNode* l2 = reverseList(nextPart);\n\n        ListNode* result = new ListNode(-1);\n        ListNode* res = result;\n\n        while(l1 or l2){\n            if(l1) {\n                res->next = l1;\n                res = res->next;\n                l1 = l1->next;\n            }\n            if(l2){\n                res->next = l2;\n                res = res->next;\n                l2 = l2->next;\n            }\n        }\n\n        res->next = NULL;\n        result->next = NULL;\n        return;\n    }\n};\n```\n"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "That\\'s of great help without posting solution "
                    },
                    {
                        "username": "songyang_dev",
                        "content": "Thanks! Step 2 solved my cycles"
                    },
                    {
                        "username": "letsstart2020",
                        "content": "I did not cut the two lists and was getting time limit exceeded, could you please explain why as i am new to linked list"
                    },
                    {
                        "username": "user9333qj",
                        "content": "I used the same method, but it is showing error. Could you please provide me with the code, If possible? \\nThanks."
                    },
                    {
                        "username": "harishaseri28",
                        "content": "I used this approach only."
                    },
                    {
                        "username": "mariohdez",
                        "content": "To be honest, the concepts aren\\'t super hard here. But I think the combination of reversal + merging operations during an interview settting makes this problem on the harder end of medium problems. This, coupled with the fact you have to recognize that in order to get the new order, you have to reverse the second half, then merge the two halves. IDK, seems hard to do in 45 minutes. Took me 10 minutes to figure out the pattern, and 40 minutes to code."
                    },
                    {
                        "username": "eiqnaict",
                        "content": "I solved it by using O(N) space in O(N) time."
                    },
                    {
                        "username": "Jayacha",
                        "content": "good job \\n"
                    },
                    {
                        "username": "AshishBibyan",
                        "content": "I used a stack for this solution to store the 2nd half of the list.\\nLater iteratively popped the last node from the stack and inserted it after the current node of the list and progressed until the stack is empty."
                    },
                    {
                        "username": "hafid-hub",
                        "content": "I used this approach in first time. I code and pass the tests. But $$O(n)$$  as space complexity... We can do better, right?\\nHow?\\nAfter about 4 hours, doing some sport exercises, I get the idea: reverse the second part! "
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "[@deepsym](/deepsym) uski marzi bhai \\uD83D\\uDE02"
                    },
                    {
                        "username": "coder42032",
                        "content": "I also applied this approach.\\n"
                    },
                    {
                        "username": "deepsym",
                        "content": "You could do this with O(1) space complexity."
                    },
                    {
                        "username": "dimal97psn",
                        "content": "Input:\\t[]\\nOutput:\\t[]\\nExpected:\\t{}"
                    },
                    {
                        "username": "Naveen_somireddy",
                        "content": "i used deque to solve this question .\\ni have copied the complete list into deque and iterated it from front and back succesivley"
                    },
                    {
                        "username": "brutalaty",
                        "content": "[@nikalinov](/nikalinov) I can\\'t see that as a restriction, was this problem updated ?"
                    },
                    {
                        "username": "nikalinov",
                        "content": "that is not O(1) space complexity tho"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 22.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/reorder-list/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Reverse the Second Part of the List and Merge Two Sorted Lists\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "chailattewithcream",
                        "content": "So stupid. I forgot to remove my \"print\" from while I was debugging and gave me TLE, ended spending a long time wondering why lol."
                    },
                    {
                        "username": "naman-exe",
                        "content": "this sucks mate, i did this in a contest for 50 mins"
                    },
                    {
                        "username": "Shengmin.Zhang",
                        "content": "What if there are odd number of nodes?\\n\\nFor example:\\n\\nL: L0\\n\\nWhat's the result?\\n\\nL: L0 -> L0?"
                    },
                    {
                        "username": "ryanthompson591",
                        "content": "I made a special case for odd nodes. If you think about it the very last node will be that middle node.\\n\\nExample:\\nL1->L2->L3-L4->L5\\nwil be\\nL1->L5->L2->L4->L3"
                    },
                    {
                        "username": "AshishBibyan",
                        "content": "After the stack is empty, make the last node point to NULL to remove this unwanted loop,"
                    },
                    {
                        "username": "danoob",
                        "content": "I am asking this because I am trying to use stack for my solution. Is it considered in-place ?"
                    },
                    {
                        "username": "BigDT",
                        "content": "that would be using extra space which isn\\'t optimal"
                    }
                ]
            },
            {
                "id": 1571309,
                "content": [
                    {
                        "username": "bugslayer312",
                        "content": "1. Find the middle by moving fast & slow iterators.\\n2. Remember right part beginning and cut off left part from the right.\\n3. Reverse right list, remember it new beginning.\\n4. Iterate left part from beginning and right part merging right list nodes into left list."
                    },
                    {
                        "username": "Aryadev19",
                        "content": "Thanks to this I was able to code it myself, thinking this solution was not easy"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "[@letsstart2020](/letsstart2020) because without cutting or making the previous pointer of the mid half resulting in making the graph, two pointers pointing the same node, so it will definitely give some pain to the programmer"
                    },
                    {
                        "username": "tejasX",
                        "content": "[@user9333qj](/user9333qj) \n\nSOLUTION BELOW:\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n```\nclass Solution {\npublic:\n\n    ListNode* getMiddle(ListNode* head){\n        ListNode* slow = head;\n        ListNode* fast = head;\n\n        while(fast){\n            if(!fast->next or !fast->next->next) return slow;\n            fast = fast->next->next;\n            slow = slow->next;\n        }\n\n        return slow;\n    }\n\n    ListNode* reverseList(ListNode* head){\n        if(!head) return head;\n\n        ListNode* prev = NULL;\n        ListNode* cur = head;\n        ListNode* nex = cur->next;\n\n        while(cur){\n            cur->next = prev;\n            prev = cur;\n            cur = nex;\n            if(nex) nex = nex->next;\n        }\n\n        return prev;\n    }\n\n    void reorderList(ListNode* head) {\n        ListNode* mid = getMiddle(head);\n        ListNode* nextPart = mid->next;\n        mid->next = NULL;\n\n        //two pointer:\n        ListNode* l1 = head;\n        ListNode* l2 = reverseList(nextPart);\n\n        ListNode* result = new ListNode(-1);\n        ListNode* res = result;\n\n        while(l1 or l2){\n            if(l1) {\n                res->next = l1;\n                res = res->next;\n                l1 = l1->next;\n            }\n            if(l2){\n                res->next = l2;\n                res = res->next;\n                l2 = l2->next;\n            }\n        }\n\n        res->next = NULL;\n        result->next = NULL;\n        return;\n    }\n};\n```\n"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "That\\'s of great help without posting solution "
                    },
                    {
                        "username": "songyang_dev",
                        "content": "Thanks! Step 2 solved my cycles"
                    },
                    {
                        "username": "letsstart2020",
                        "content": "I did not cut the two lists and was getting time limit exceeded, could you please explain why as i am new to linked list"
                    },
                    {
                        "username": "user9333qj",
                        "content": "I used the same method, but it is showing error. Could you please provide me with the code, If possible? \\nThanks."
                    },
                    {
                        "username": "harishaseri28",
                        "content": "I used this approach only."
                    },
                    {
                        "username": "mariohdez",
                        "content": "To be honest, the concepts aren\\'t super hard here. But I think the combination of reversal + merging operations during an interview settting makes this problem on the harder end of medium problems. This, coupled with the fact you have to recognize that in order to get the new order, you have to reverse the second half, then merge the two halves. IDK, seems hard to do in 45 minutes. Took me 10 minutes to figure out the pattern, and 40 minutes to code."
                    },
                    {
                        "username": "eiqnaict",
                        "content": "I solved it by using O(N) space in O(N) time."
                    },
                    {
                        "username": "Jayacha",
                        "content": "good job \\n"
                    },
                    {
                        "username": "AshishBibyan",
                        "content": "I used a stack for this solution to store the 2nd half of the list.\\nLater iteratively popped the last node from the stack and inserted it after the current node of the list and progressed until the stack is empty."
                    },
                    {
                        "username": "hafid-hub",
                        "content": "I used this approach in first time. I code and pass the tests. But $$O(n)$$  as space complexity... We can do better, right?\\nHow?\\nAfter about 4 hours, doing some sport exercises, I get the idea: reverse the second part! "
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "[@deepsym](/deepsym) uski marzi bhai \\uD83D\\uDE02"
                    },
                    {
                        "username": "coder42032",
                        "content": "I also applied this approach.\\n"
                    },
                    {
                        "username": "deepsym",
                        "content": "You could do this with O(1) space complexity."
                    },
                    {
                        "username": "dimal97psn",
                        "content": "Input:\\t[]\\nOutput:\\t[]\\nExpected:\\t{}"
                    },
                    {
                        "username": "Naveen_somireddy",
                        "content": "i used deque to solve this question .\\ni have copied the complete list into deque and iterated it from front and back succesivley"
                    },
                    {
                        "username": "brutalaty",
                        "content": "[@nikalinov](/nikalinov) I can\\'t see that as a restriction, was this problem updated ?"
                    },
                    {
                        "username": "nikalinov",
                        "content": "that is not O(1) space complexity tho"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 22.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/reorder-list/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Reverse the Second Part of the List and Merge Two Sorted Lists\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "chailattewithcream",
                        "content": "So stupid. I forgot to remove my \"print\" from while I was debugging and gave me TLE, ended spending a long time wondering why lol."
                    },
                    {
                        "username": "naman-exe",
                        "content": "this sucks mate, i did this in a contest for 50 mins"
                    },
                    {
                        "username": "Shengmin.Zhang",
                        "content": "What if there are odd number of nodes?\\n\\nFor example:\\n\\nL: L0\\n\\nWhat's the result?\\n\\nL: L0 -> L0?"
                    },
                    {
                        "username": "ryanthompson591",
                        "content": "I made a special case for odd nodes. If you think about it the very last node will be that middle node.\\n\\nExample:\\nL1->L2->L3-L4->L5\\nwil be\\nL1->L5->L2->L4->L3"
                    },
                    {
                        "username": "AshishBibyan",
                        "content": "After the stack is empty, make the last node point to NULL to remove this unwanted loop,"
                    },
                    {
                        "username": "danoob",
                        "content": "I am asking this because I am trying to use stack for my solution. Is it considered in-place ?"
                    },
                    {
                        "username": "BigDT",
                        "content": "that would be using extra space which isn\\'t optimal"
                    }
                ]
            },
            {
                "id": 1695325,
                "content": [
                    {
                        "username": "bugslayer312",
                        "content": "1. Find the middle by moving fast & slow iterators.\\n2. Remember right part beginning and cut off left part from the right.\\n3. Reverse right list, remember it new beginning.\\n4. Iterate left part from beginning and right part merging right list nodes into left list."
                    },
                    {
                        "username": "Aryadev19",
                        "content": "Thanks to this I was able to code it myself, thinking this solution was not easy"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "[@letsstart2020](/letsstart2020) because without cutting or making the previous pointer of the mid half resulting in making the graph, two pointers pointing the same node, so it will definitely give some pain to the programmer"
                    },
                    {
                        "username": "tejasX",
                        "content": "[@user9333qj](/user9333qj) \n\nSOLUTION BELOW:\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n```\nclass Solution {\npublic:\n\n    ListNode* getMiddle(ListNode* head){\n        ListNode* slow = head;\n        ListNode* fast = head;\n\n        while(fast){\n            if(!fast->next or !fast->next->next) return slow;\n            fast = fast->next->next;\n            slow = slow->next;\n        }\n\n        return slow;\n    }\n\n    ListNode* reverseList(ListNode* head){\n        if(!head) return head;\n\n        ListNode* prev = NULL;\n        ListNode* cur = head;\n        ListNode* nex = cur->next;\n\n        while(cur){\n            cur->next = prev;\n            prev = cur;\n            cur = nex;\n            if(nex) nex = nex->next;\n        }\n\n        return prev;\n    }\n\n    void reorderList(ListNode* head) {\n        ListNode* mid = getMiddle(head);\n        ListNode* nextPart = mid->next;\n        mid->next = NULL;\n\n        //two pointer:\n        ListNode* l1 = head;\n        ListNode* l2 = reverseList(nextPart);\n\n        ListNode* result = new ListNode(-1);\n        ListNode* res = result;\n\n        while(l1 or l2){\n            if(l1) {\n                res->next = l1;\n                res = res->next;\n                l1 = l1->next;\n            }\n            if(l2){\n                res->next = l2;\n                res = res->next;\n                l2 = l2->next;\n            }\n        }\n\n        res->next = NULL;\n        result->next = NULL;\n        return;\n    }\n};\n```\n"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "That\\'s of great help without posting solution "
                    },
                    {
                        "username": "songyang_dev",
                        "content": "Thanks! Step 2 solved my cycles"
                    },
                    {
                        "username": "letsstart2020",
                        "content": "I did not cut the two lists and was getting time limit exceeded, could you please explain why as i am new to linked list"
                    },
                    {
                        "username": "user9333qj",
                        "content": "I used the same method, but it is showing error. Could you please provide me with the code, If possible? \\nThanks."
                    },
                    {
                        "username": "harishaseri28",
                        "content": "I used this approach only."
                    },
                    {
                        "username": "mariohdez",
                        "content": "To be honest, the concepts aren\\'t super hard here. But I think the combination of reversal + merging operations during an interview settting makes this problem on the harder end of medium problems. This, coupled with the fact you have to recognize that in order to get the new order, you have to reverse the second half, then merge the two halves. IDK, seems hard to do in 45 minutes. Took me 10 minutes to figure out the pattern, and 40 minutes to code."
                    },
                    {
                        "username": "eiqnaict",
                        "content": "I solved it by using O(N) space in O(N) time."
                    },
                    {
                        "username": "Jayacha",
                        "content": "good job \\n"
                    },
                    {
                        "username": "AshishBibyan",
                        "content": "I used a stack for this solution to store the 2nd half of the list.\\nLater iteratively popped the last node from the stack and inserted it after the current node of the list and progressed until the stack is empty."
                    },
                    {
                        "username": "hafid-hub",
                        "content": "I used this approach in first time. I code and pass the tests. But $$O(n)$$  as space complexity... We can do better, right?\\nHow?\\nAfter about 4 hours, doing some sport exercises, I get the idea: reverse the second part! "
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "[@deepsym](/deepsym) uski marzi bhai \\uD83D\\uDE02"
                    },
                    {
                        "username": "coder42032",
                        "content": "I also applied this approach.\\n"
                    },
                    {
                        "username": "deepsym",
                        "content": "You could do this with O(1) space complexity."
                    },
                    {
                        "username": "dimal97psn",
                        "content": "Input:\\t[]\\nOutput:\\t[]\\nExpected:\\t{}"
                    },
                    {
                        "username": "Naveen_somireddy",
                        "content": "i used deque to solve this question .\\ni have copied the complete list into deque and iterated it from front and back succesivley"
                    },
                    {
                        "username": "brutalaty",
                        "content": "[@nikalinov](/nikalinov) I can\\'t see that as a restriction, was this problem updated ?"
                    },
                    {
                        "username": "nikalinov",
                        "content": "that is not O(1) space complexity tho"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 22.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/reorder-list/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Reverse the Second Part of the List and Merge Two Sorted Lists\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "chailattewithcream",
                        "content": "So stupid. I forgot to remove my \"print\" from while I was debugging and gave me TLE, ended spending a long time wondering why lol."
                    },
                    {
                        "username": "naman-exe",
                        "content": "this sucks mate, i did this in a contest for 50 mins"
                    },
                    {
                        "username": "Shengmin.Zhang",
                        "content": "What if there are odd number of nodes?\\n\\nFor example:\\n\\nL: L0\\n\\nWhat's the result?\\n\\nL: L0 -> L0?"
                    },
                    {
                        "username": "ryanthompson591",
                        "content": "I made a special case for odd nodes. If you think about it the very last node will be that middle node.\\n\\nExample:\\nL1->L2->L3-L4->L5\\nwil be\\nL1->L5->L2->L4->L3"
                    },
                    {
                        "username": "AshishBibyan",
                        "content": "After the stack is empty, make the last node point to NULL to remove this unwanted loop,"
                    },
                    {
                        "username": "danoob",
                        "content": "I am asking this because I am trying to use stack for my solution. Is it considered in-place ?"
                    },
                    {
                        "username": "BigDT",
                        "content": "that would be using extra space which isn\\'t optimal"
                    }
                ]
            },
            {
                "id": 1716671,
                "content": [
                    {
                        "username": "bugslayer312",
                        "content": "1. Find the middle by moving fast & slow iterators.\\n2. Remember right part beginning and cut off left part from the right.\\n3. Reverse right list, remember it new beginning.\\n4. Iterate left part from beginning and right part merging right list nodes into left list."
                    },
                    {
                        "username": "Aryadev19",
                        "content": "Thanks to this I was able to code it myself, thinking this solution was not easy"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "[@letsstart2020](/letsstart2020) because without cutting or making the previous pointer of the mid half resulting in making the graph, two pointers pointing the same node, so it will definitely give some pain to the programmer"
                    },
                    {
                        "username": "tejasX",
                        "content": "[@user9333qj](/user9333qj) \n\nSOLUTION BELOW:\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n```\nclass Solution {\npublic:\n\n    ListNode* getMiddle(ListNode* head){\n        ListNode* slow = head;\n        ListNode* fast = head;\n\n        while(fast){\n            if(!fast->next or !fast->next->next) return slow;\n            fast = fast->next->next;\n            slow = slow->next;\n        }\n\n        return slow;\n    }\n\n    ListNode* reverseList(ListNode* head){\n        if(!head) return head;\n\n        ListNode* prev = NULL;\n        ListNode* cur = head;\n        ListNode* nex = cur->next;\n\n        while(cur){\n            cur->next = prev;\n            prev = cur;\n            cur = nex;\n            if(nex) nex = nex->next;\n        }\n\n        return prev;\n    }\n\n    void reorderList(ListNode* head) {\n        ListNode* mid = getMiddle(head);\n        ListNode* nextPart = mid->next;\n        mid->next = NULL;\n\n        //two pointer:\n        ListNode* l1 = head;\n        ListNode* l2 = reverseList(nextPart);\n\n        ListNode* result = new ListNode(-1);\n        ListNode* res = result;\n\n        while(l1 or l2){\n            if(l1) {\n                res->next = l1;\n                res = res->next;\n                l1 = l1->next;\n            }\n            if(l2){\n                res->next = l2;\n                res = res->next;\n                l2 = l2->next;\n            }\n        }\n\n        res->next = NULL;\n        result->next = NULL;\n        return;\n    }\n};\n```\n"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "That\\'s of great help without posting solution "
                    },
                    {
                        "username": "songyang_dev",
                        "content": "Thanks! Step 2 solved my cycles"
                    },
                    {
                        "username": "letsstart2020",
                        "content": "I did not cut the two lists and was getting time limit exceeded, could you please explain why as i am new to linked list"
                    },
                    {
                        "username": "user9333qj",
                        "content": "I used the same method, but it is showing error. Could you please provide me with the code, If possible? \\nThanks."
                    },
                    {
                        "username": "harishaseri28",
                        "content": "I used this approach only."
                    },
                    {
                        "username": "mariohdez",
                        "content": "To be honest, the concepts aren\\'t super hard here. But I think the combination of reversal + merging operations during an interview settting makes this problem on the harder end of medium problems. This, coupled with the fact you have to recognize that in order to get the new order, you have to reverse the second half, then merge the two halves. IDK, seems hard to do in 45 minutes. Took me 10 minutes to figure out the pattern, and 40 minutes to code."
                    },
                    {
                        "username": "eiqnaict",
                        "content": "I solved it by using O(N) space in O(N) time."
                    },
                    {
                        "username": "Jayacha",
                        "content": "good job \\n"
                    },
                    {
                        "username": "AshishBibyan",
                        "content": "I used a stack for this solution to store the 2nd half of the list.\\nLater iteratively popped the last node from the stack and inserted it after the current node of the list and progressed until the stack is empty."
                    },
                    {
                        "username": "hafid-hub",
                        "content": "I used this approach in first time. I code and pass the tests. But $$O(n)$$  as space complexity... We can do better, right?\\nHow?\\nAfter about 4 hours, doing some sport exercises, I get the idea: reverse the second part! "
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "[@deepsym](/deepsym) uski marzi bhai \\uD83D\\uDE02"
                    },
                    {
                        "username": "coder42032",
                        "content": "I also applied this approach.\\n"
                    },
                    {
                        "username": "deepsym",
                        "content": "You could do this with O(1) space complexity."
                    },
                    {
                        "username": "dimal97psn",
                        "content": "Input:\\t[]\\nOutput:\\t[]\\nExpected:\\t{}"
                    },
                    {
                        "username": "Naveen_somireddy",
                        "content": "i used deque to solve this question .\\ni have copied the complete list into deque and iterated it from front and back succesivley"
                    },
                    {
                        "username": "brutalaty",
                        "content": "[@nikalinov](/nikalinov) I can\\'t see that as a restriction, was this problem updated ?"
                    },
                    {
                        "username": "nikalinov",
                        "content": "that is not O(1) space complexity tho"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 22.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/reorder-list/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Reverse the Second Part of the List and Merge Two Sorted Lists\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "chailattewithcream",
                        "content": "So stupid. I forgot to remove my \"print\" from while I was debugging and gave me TLE, ended spending a long time wondering why lol."
                    },
                    {
                        "username": "naman-exe",
                        "content": "this sucks mate, i did this in a contest for 50 mins"
                    },
                    {
                        "username": "Shengmin.Zhang",
                        "content": "What if there are odd number of nodes?\\n\\nFor example:\\n\\nL: L0\\n\\nWhat's the result?\\n\\nL: L0 -> L0?"
                    },
                    {
                        "username": "ryanthompson591",
                        "content": "I made a special case for odd nodes. If you think about it the very last node will be that middle node.\\n\\nExample:\\nL1->L2->L3-L4->L5\\nwil be\\nL1->L5->L2->L4->L3"
                    },
                    {
                        "username": "AshishBibyan",
                        "content": "After the stack is empty, make the last node point to NULL to remove this unwanted loop,"
                    },
                    {
                        "username": "danoob",
                        "content": "I am asking this because I am trying to use stack for my solution. Is it considered in-place ?"
                    },
                    {
                        "username": "BigDT",
                        "content": "that would be using extra space which isn\\'t optimal"
                    }
                ]
            },
            {
                "id": 1565741,
                "content": [
                    {
                        "username": "bugslayer312",
                        "content": "1. Find the middle by moving fast & slow iterators.\\n2. Remember right part beginning and cut off left part from the right.\\n3. Reverse right list, remember it new beginning.\\n4. Iterate left part from beginning and right part merging right list nodes into left list."
                    },
                    {
                        "username": "Aryadev19",
                        "content": "Thanks to this I was able to code it myself, thinking this solution was not easy"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "[@letsstart2020](/letsstart2020) because without cutting or making the previous pointer of the mid half resulting in making the graph, two pointers pointing the same node, so it will definitely give some pain to the programmer"
                    },
                    {
                        "username": "tejasX",
                        "content": "[@user9333qj](/user9333qj) \n\nSOLUTION BELOW:\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n```\nclass Solution {\npublic:\n\n    ListNode* getMiddle(ListNode* head){\n        ListNode* slow = head;\n        ListNode* fast = head;\n\n        while(fast){\n            if(!fast->next or !fast->next->next) return slow;\n            fast = fast->next->next;\n            slow = slow->next;\n        }\n\n        return slow;\n    }\n\n    ListNode* reverseList(ListNode* head){\n        if(!head) return head;\n\n        ListNode* prev = NULL;\n        ListNode* cur = head;\n        ListNode* nex = cur->next;\n\n        while(cur){\n            cur->next = prev;\n            prev = cur;\n            cur = nex;\n            if(nex) nex = nex->next;\n        }\n\n        return prev;\n    }\n\n    void reorderList(ListNode* head) {\n        ListNode* mid = getMiddle(head);\n        ListNode* nextPart = mid->next;\n        mid->next = NULL;\n\n        //two pointer:\n        ListNode* l1 = head;\n        ListNode* l2 = reverseList(nextPart);\n\n        ListNode* result = new ListNode(-1);\n        ListNode* res = result;\n\n        while(l1 or l2){\n            if(l1) {\n                res->next = l1;\n                res = res->next;\n                l1 = l1->next;\n            }\n            if(l2){\n                res->next = l2;\n                res = res->next;\n                l2 = l2->next;\n            }\n        }\n\n        res->next = NULL;\n        result->next = NULL;\n        return;\n    }\n};\n```\n"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "That\\'s of great help without posting solution "
                    },
                    {
                        "username": "songyang_dev",
                        "content": "Thanks! Step 2 solved my cycles"
                    },
                    {
                        "username": "letsstart2020",
                        "content": "I did not cut the two lists and was getting time limit exceeded, could you please explain why as i am new to linked list"
                    },
                    {
                        "username": "user9333qj",
                        "content": "I used the same method, but it is showing error. Could you please provide me with the code, If possible? \\nThanks."
                    },
                    {
                        "username": "harishaseri28",
                        "content": "I used this approach only."
                    },
                    {
                        "username": "mariohdez",
                        "content": "To be honest, the concepts aren\\'t super hard here. But I think the combination of reversal + merging operations during an interview settting makes this problem on the harder end of medium problems. This, coupled with the fact you have to recognize that in order to get the new order, you have to reverse the second half, then merge the two halves. IDK, seems hard to do in 45 minutes. Took me 10 minutes to figure out the pattern, and 40 minutes to code."
                    },
                    {
                        "username": "eiqnaict",
                        "content": "I solved it by using O(N) space in O(N) time."
                    },
                    {
                        "username": "Jayacha",
                        "content": "good job \\n"
                    },
                    {
                        "username": "AshishBibyan",
                        "content": "I used a stack for this solution to store the 2nd half of the list.\\nLater iteratively popped the last node from the stack and inserted it after the current node of the list and progressed until the stack is empty."
                    },
                    {
                        "username": "hafid-hub",
                        "content": "I used this approach in first time. I code and pass the tests. But $$O(n)$$  as space complexity... We can do better, right?\\nHow?\\nAfter about 4 hours, doing some sport exercises, I get the idea: reverse the second part! "
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "[@deepsym](/deepsym) uski marzi bhai \\uD83D\\uDE02"
                    },
                    {
                        "username": "coder42032",
                        "content": "I also applied this approach.\\n"
                    },
                    {
                        "username": "deepsym",
                        "content": "You could do this with O(1) space complexity."
                    },
                    {
                        "username": "dimal97psn",
                        "content": "Input:\\t[]\\nOutput:\\t[]\\nExpected:\\t{}"
                    },
                    {
                        "username": "Naveen_somireddy",
                        "content": "i used deque to solve this question .\\ni have copied the complete list into deque and iterated it from front and back succesivley"
                    },
                    {
                        "username": "brutalaty",
                        "content": "[@nikalinov](/nikalinov) I can\\'t see that as a restriction, was this problem updated ?"
                    },
                    {
                        "username": "nikalinov",
                        "content": "that is not O(1) space complexity tho"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 22.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/reorder-list/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Reverse the Second Part of the List and Merge Two Sorted Lists\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "chailattewithcream",
                        "content": "So stupid. I forgot to remove my \"print\" from while I was debugging and gave me TLE, ended spending a long time wondering why lol."
                    },
                    {
                        "username": "naman-exe",
                        "content": "this sucks mate, i did this in a contest for 50 mins"
                    },
                    {
                        "username": "Shengmin.Zhang",
                        "content": "What if there are odd number of nodes?\\n\\nFor example:\\n\\nL: L0\\n\\nWhat's the result?\\n\\nL: L0 -> L0?"
                    },
                    {
                        "username": "ryanthompson591",
                        "content": "I made a special case for odd nodes. If you think about it the very last node will be that middle node.\\n\\nExample:\\nL1->L2->L3-L4->L5\\nwil be\\nL1->L5->L2->L4->L3"
                    },
                    {
                        "username": "AshishBibyan",
                        "content": "After the stack is empty, make the last node point to NULL to remove this unwanted loop,"
                    },
                    {
                        "username": "danoob",
                        "content": "I am asking this because I am trying to use stack for my solution. Is it considered in-place ?"
                    },
                    {
                        "username": "BigDT",
                        "content": "that would be using extra space which isn\\'t optimal"
                    }
                ]
            },
            {
                "id": 1636670,
                "content": [
                    {
                        "username": "bugslayer312",
                        "content": "1. Find the middle by moving fast & slow iterators.\\n2. Remember right part beginning and cut off left part from the right.\\n3. Reverse right list, remember it new beginning.\\n4. Iterate left part from beginning and right part merging right list nodes into left list."
                    },
                    {
                        "username": "Aryadev19",
                        "content": "Thanks to this I was able to code it myself, thinking this solution was not easy"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "[@letsstart2020](/letsstart2020) because without cutting or making the previous pointer of the mid half resulting in making the graph, two pointers pointing the same node, so it will definitely give some pain to the programmer"
                    },
                    {
                        "username": "tejasX",
                        "content": "[@user9333qj](/user9333qj) \n\nSOLUTION BELOW:\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n```\nclass Solution {\npublic:\n\n    ListNode* getMiddle(ListNode* head){\n        ListNode* slow = head;\n        ListNode* fast = head;\n\n        while(fast){\n            if(!fast->next or !fast->next->next) return slow;\n            fast = fast->next->next;\n            slow = slow->next;\n        }\n\n        return slow;\n    }\n\n    ListNode* reverseList(ListNode* head){\n        if(!head) return head;\n\n        ListNode* prev = NULL;\n        ListNode* cur = head;\n        ListNode* nex = cur->next;\n\n        while(cur){\n            cur->next = prev;\n            prev = cur;\n            cur = nex;\n            if(nex) nex = nex->next;\n        }\n\n        return prev;\n    }\n\n    void reorderList(ListNode* head) {\n        ListNode* mid = getMiddle(head);\n        ListNode* nextPart = mid->next;\n        mid->next = NULL;\n\n        //two pointer:\n        ListNode* l1 = head;\n        ListNode* l2 = reverseList(nextPart);\n\n        ListNode* result = new ListNode(-1);\n        ListNode* res = result;\n\n        while(l1 or l2){\n            if(l1) {\n                res->next = l1;\n                res = res->next;\n                l1 = l1->next;\n            }\n            if(l2){\n                res->next = l2;\n                res = res->next;\n                l2 = l2->next;\n            }\n        }\n\n        res->next = NULL;\n        result->next = NULL;\n        return;\n    }\n};\n```\n"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "That\\'s of great help without posting solution "
                    },
                    {
                        "username": "songyang_dev",
                        "content": "Thanks! Step 2 solved my cycles"
                    },
                    {
                        "username": "letsstart2020",
                        "content": "I did not cut the two lists and was getting time limit exceeded, could you please explain why as i am new to linked list"
                    },
                    {
                        "username": "user9333qj",
                        "content": "I used the same method, but it is showing error. Could you please provide me with the code, If possible? \\nThanks."
                    },
                    {
                        "username": "harishaseri28",
                        "content": "I used this approach only."
                    },
                    {
                        "username": "mariohdez",
                        "content": "To be honest, the concepts aren\\'t super hard here. But I think the combination of reversal + merging operations during an interview settting makes this problem on the harder end of medium problems. This, coupled with the fact you have to recognize that in order to get the new order, you have to reverse the second half, then merge the two halves. IDK, seems hard to do in 45 minutes. Took me 10 minutes to figure out the pattern, and 40 minutes to code."
                    },
                    {
                        "username": "eiqnaict",
                        "content": "I solved it by using O(N) space in O(N) time."
                    },
                    {
                        "username": "Jayacha",
                        "content": "good job \\n"
                    },
                    {
                        "username": "AshishBibyan",
                        "content": "I used a stack for this solution to store the 2nd half of the list.\\nLater iteratively popped the last node from the stack and inserted it after the current node of the list and progressed until the stack is empty."
                    },
                    {
                        "username": "hafid-hub",
                        "content": "I used this approach in first time. I code and pass the tests. But $$O(n)$$  as space complexity... We can do better, right?\\nHow?\\nAfter about 4 hours, doing some sport exercises, I get the idea: reverse the second part! "
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "[@deepsym](/deepsym) uski marzi bhai \\uD83D\\uDE02"
                    },
                    {
                        "username": "coder42032",
                        "content": "I also applied this approach.\\n"
                    },
                    {
                        "username": "deepsym",
                        "content": "You could do this with O(1) space complexity."
                    },
                    {
                        "username": "dimal97psn",
                        "content": "Input:\\t[]\\nOutput:\\t[]\\nExpected:\\t{}"
                    },
                    {
                        "username": "Naveen_somireddy",
                        "content": "i used deque to solve this question .\\ni have copied the complete list into deque and iterated it from front and back succesivley"
                    },
                    {
                        "username": "brutalaty",
                        "content": "[@nikalinov](/nikalinov) I can\\'t see that as a restriction, was this problem updated ?"
                    },
                    {
                        "username": "nikalinov",
                        "content": "that is not O(1) space complexity tho"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 22.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/reorder-list/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Reverse the Second Part of the List and Merge Two Sorted Lists\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "chailattewithcream",
                        "content": "So stupid. I forgot to remove my \"print\" from while I was debugging and gave me TLE, ended spending a long time wondering why lol."
                    },
                    {
                        "username": "naman-exe",
                        "content": "this sucks mate, i did this in a contest for 50 mins"
                    },
                    {
                        "username": "Shengmin.Zhang",
                        "content": "What if there are odd number of nodes?\\n\\nFor example:\\n\\nL: L0\\n\\nWhat's the result?\\n\\nL: L0 -> L0?"
                    },
                    {
                        "username": "ryanthompson591",
                        "content": "I made a special case for odd nodes. If you think about it the very last node will be that middle node.\\n\\nExample:\\nL1->L2->L3-L4->L5\\nwil be\\nL1->L5->L2->L4->L3"
                    },
                    {
                        "username": "AshishBibyan",
                        "content": "After the stack is empty, make the last node point to NULL to remove this unwanted loop,"
                    },
                    {
                        "username": "danoob",
                        "content": "I am asking this because I am trying to use stack for my solution. Is it considered in-place ?"
                    },
                    {
                        "username": "BigDT",
                        "content": "that would be using extra space which isn\\'t optimal"
                    }
                ]
            },
            {
                "id": 1566241,
                "content": [
                    {
                        "username": "bugslayer312",
                        "content": "1. Find the middle by moving fast & slow iterators.\\n2. Remember right part beginning and cut off left part from the right.\\n3. Reverse right list, remember it new beginning.\\n4. Iterate left part from beginning and right part merging right list nodes into left list."
                    },
                    {
                        "username": "Aryadev19",
                        "content": "Thanks to this I was able to code it myself, thinking this solution was not easy"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "[@letsstart2020](/letsstart2020) because without cutting or making the previous pointer of the mid half resulting in making the graph, two pointers pointing the same node, so it will definitely give some pain to the programmer"
                    },
                    {
                        "username": "tejasX",
                        "content": "[@user9333qj](/user9333qj) \n\nSOLUTION BELOW:\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n```\nclass Solution {\npublic:\n\n    ListNode* getMiddle(ListNode* head){\n        ListNode* slow = head;\n        ListNode* fast = head;\n\n        while(fast){\n            if(!fast->next or !fast->next->next) return slow;\n            fast = fast->next->next;\n            slow = slow->next;\n        }\n\n        return slow;\n    }\n\n    ListNode* reverseList(ListNode* head){\n        if(!head) return head;\n\n        ListNode* prev = NULL;\n        ListNode* cur = head;\n        ListNode* nex = cur->next;\n\n        while(cur){\n            cur->next = prev;\n            prev = cur;\n            cur = nex;\n            if(nex) nex = nex->next;\n        }\n\n        return prev;\n    }\n\n    void reorderList(ListNode* head) {\n        ListNode* mid = getMiddle(head);\n        ListNode* nextPart = mid->next;\n        mid->next = NULL;\n\n        //two pointer:\n        ListNode* l1 = head;\n        ListNode* l2 = reverseList(nextPart);\n\n        ListNode* result = new ListNode(-1);\n        ListNode* res = result;\n\n        while(l1 or l2){\n            if(l1) {\n                res->next = l1;\n                res = res->next;\n                l1 = l1->next;\n            }\n            if(l2){\n                res->next = l2;\n                res = res->next;\n                l2 = l2->next;\n            }\n        }\n\n        res->next = NULL;\n        result->next = NULL;\n        return;\n    }\n};\n```\n"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "That\\'s of great help without posting solution "
                    },
                    {
                        "username": "songyang_dev",
                        "content": "Thanks! Step 2 solved my cycles"
                    },
                    {
                        "username": "letsstart2020",
                        "content": "I did not cut the two lists and was getting time limit exceeded, could you please explain why as i am new to linked list"
                    },
                    {
                        "username": "user9333qj",
                        "content": "I used the same method, but it is showing error. Could you please provide me with the code, If possible? \\nThanks."
                    },
                    {
                        "username": "harishaseri28",
                        "content": "I used this approach only."
                    },
                    {
                        "username": "mariohdez",
                        "content": "To be honest, the concepts aren\\'t super hard here. But I think the combination of reversal + merging operations during an interview settting makes this problem on the harder end of medium problems. This, coupled with the fact you have to recognize that in order to get the new order, you have to reverse the second half, then merge the two halves. IDK, seems hard to do in 45 minutes. Took me 10 minutes to figure out the pattern, and 40 minutes to code."
                    },
                    {
                        "username": "eiqnaict",
                        "content": "I solved it by using O(N) space in O(N) time."
                    },
                    {
                        "username": "Jayacha",
                        "content": "good job \\n"
                    },
                    {
                        "username": "AshishBibyan",
                        "content": "I used a stack for this solution to store the 2nd half of the list.\\nLater iteratively popped the last node from the stack and inserted it after the current node of the list and progressed until the stack is empty."
                    },
                    {
                        "username": "hafid-hub",
                        "content": "I used this approach in first time. I code and pass the tests. But $$O(n)$$  as space complexity... We can do better, right?\\nHow?\\nAfter about 4 hours, doing some sport exercises, I get the idea: reverse the second part! "
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "[@deepsym](/deepsym) uski marzi bhai \\uD83D\\uDE02"
                    },
                    {
                        "username": "coder42032",
                        "content": "I also applied this approach.\\n"
                    },
                    {
                        "username": "deepsym",
                        "content": "You could do this with O(1) space complexity."
                    },
                    {
                        "username": "dimal97psn",
                        "content": "Input:\\t[]\\nOutput:\\t[]\\nExpected:\\t{}"
                    },
                    {
                        "username": "Naveen_somireddy",
                        "content": "i used deque to solve this question .\\ni have copied the complete list into deque and iterated it from front and back succesivley"
                    },
                    {
                        "username": "brutalaty",
                        "content": "[@nikalinov](/nikalinov) I can\\'t see that as a restriction, was this problem updated ?"
                    },
                    {
                        "username": "nikalinov",
                        "content": "that is not O(1) space complexity tho"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 22.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/reorder-list/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Reverse the Second Part of the List and Merge Two Sorted Lists\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "chailattewithcream",
                        "content": "So stupid. I forgot to remove my \"print\" from while I was debugging and gave me TLE, ended spending a long time wondering why lol."
                    },
                    {
                        "username": "naman-exe",
                        "content": "this sucks mate, i did this in a contest for 50 mins"
                    },
                    {
                        "username": "Shengmin.Zhang",
                        "content": "What if there are odd number of nodes?\\n\\nFor example:\\n\\nL: L0\\n\\nWhat's the result?\\n\\nL: L0 -> L0?"
                    },
                    {
                        "username": "ryanthompson591",
                        "content": "I made a special case for odd nodes. If you think about it the very last node will be that middle node.\\n\\nExample:\\nL1->L2->L3-L4->L5\\nwil be\\nL1->L5->L2->L4->L3"
                    },
                    {
                        "username": "AshishBibyan",
                        "content": "After the stack is empty, make the last node point to NULL to remove this unwanted loop,"
                    },
                    {
                        "username": "danoob",
                        "content": "I am asking this because I am trying to use stack for my solution. Is it considered in-place ?"
                    },
                    {
                        "username": "BigDT",
                        "content": "that would be using extra space which isn\\'t optimal"
                    }
                ]
            },
            {
                "id": 1733040,
                "content": [
                    {
                        "username": "bugslayer312",
                        "content": "1. Find the middle by moving fast & slow iterators.\\n2. Remember right part beginning and cut off left part from the right.\\n3. Reverse right list, remember it new beginning.\\n4. Iterate left part from beginning and right part merging right list nodes into left list."
                    },
                    {
                        "username": "Aryadev19",
                        "content": "Thanks to this I was able to code it myself, thinking this solution was not easy"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "[@letsstart2020](/letsstart2020) because without cutting or making the previous pointer of the mid half resulting in making the graph, two pointers pointing the same node, so it will definitely give some pain to the programmer"
                    },
                    {
                        "username": "tejasX",
                        "content": "[@user9333qj](/user9333qj) \n\nSOLUTION BELOW:\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n```\nclass Solution {\npublic:\n\n    ListNode* getMiddle(ListNode* head){\n        ListNode* slow = head;\n        ListNode* fast = head;\n\n        while(fast){\n            if(!fast->next or !fast->next->next) return slow;\n            fast = fast->next->next;\n            slow = slow->next;\n        }\n\n        return slow;\n    }\n\n    ListNode* reverseList(ListNode* head){\n        if(!head) return head;\n\n        ListNode* prev = NULL;\n        ListNode* cur = head;\n        ListNode* nex = cur->next;\n\n        while(cur){\n            cur->next = prev;\n            prev = cur;\n            cur = nex;\n            if(nex) nex = nex->next;\n        }\n\n        return prev;\n    }\n\n    void reorderList(ListNode* head) {\n        ListNode* mid = getMiddle(head);\n        ListNode* nextPart = mid->next;\n        mid->next = NULL;\n\n        //two pointer:\n        ListNode* l1 = head;\n        ListNode* l2 = reverseList(nextPart);\n\n        ListNode* result = new ListNode(-1);\n        ListNode* res = result;\n\n        while(l1 or l2){\n            if(l1) {\n                res->next = l1;\n                res = res->next;\n                l1 = l1->next;\n            }\n            if(l2){\n                res->next = l2;\n                res = res->next;\n                l2 = l2->next;\n            }\n        }\n\n        res->next = NULL;\n        result->next = NULL;\n        return;\n    }\n};\n```\n"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "That\\'s of great help without posting solution "
                    },
                    {
                        "username": "songyang_dev",
                        "content": "Thanks! Step 2 solved my cycles"
                    },
                    {
                        "username": "letsstart2020",
                        "content": "I did not cut the two lists and was getting time limit exceeded, could you please explain why as i am new to linked list"
                    },
                    {
                        "username": "user9333qj",
                        "content": "I used the same method, but it is showing error. Could you please provide me with the code, If possible? \\nThanks."
                    },
                    {
                        "username": "harishaseri28",
                        "content": "I used this approach only."
                    },
                    {
                        "username": "mariohdez",
                        "content": "To be honest, the concepts aren\\'t super hard here. But I think the combination of reversal + merging operations during an interview settting makes this problem on the harder end of medium problems. This, coupled with the fact you have to recognize that in order to get the new order, you have to reverse the second half, then merge the two halves. IDK, seems hard to do in 45 minutes. Took me 10 minutes to figure out the pattern, and 40 minutes to code."
                    },
                    {
                        "username": "eiqnaict",
                        "content": "I solved it by using O(N) space in O(N) time."
                    },
                    {
                        "username": "Jayacha",
                        "content": "good job \\n"
                    },
                    {
                        "username": "AshishBibyan",
                        "content": "I used a stack for this solution to store the 2nd half of the list.\\nLater iteratively popped the last node from the stack and inserted it after the current node of the list and progressed until the stack is empty."
                    },
                    {
                        "username": "hafid-hub",
                        "content": "I used this approach in first time. I code and pass the tests. But $$O(n)$$  as space complexity... We can do better, right?\\nHow?\\nAfter about 4 hours, doing some sport exercises, I get the idea: reverse the second part! "
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "[@deepsym](/deepsym) uski marzi bhai \\uD83D\\uDE02"
                    },
                    {
                        "username": "coder42032",
                        "content": "I also applied this approach.\\n"
                    },
                    {
                        "username": "deepsym",
                        "content": "You could do this with O(1) space complexity."
                    },
                    {
                        "username": "dimal97psn",
                        "content": "Input:\\t[]\\nOutput:\\t[]\\nExpected:\\t{}"
                    },
                    {
                        "username": "Naveen_somireddy",
                        "content": "i used deque to solve this question .\\ni have copied the complete list into deque and iterated it from front and back succesivley"
                    },
                    {
                        "username": "brutalaty",
                        "content": "[@nikalinov](/nikalinov) I can\\'t see that as a restriction, was this problem updated ?"
                    },
                    {
                        "username": "nikalinov",
                        "content": "that is not O(1) space complexity tho"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 22.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/reorder-list/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Reverse the Second Part of the List and Merge Two Sorted Lists\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "chailattewithcream",
                        "content": "So stupid. I forgot to remove my \"print\" from while I was debugging and gave me TLE, ended spending a long time wondering why lol."
                    },
                    {
                        "username": "naman-exe",
                        "content": "this sucks mate, i did this in a contest for 50 mins"
                    },
                    {
                        "username": "Shengmin.Zhang",
                        "content": "What if there are odd number of nodes?\\n\\nFor example:\\n\\nL: L0\\n\\nWhat's the result?\\n\\nL: L0 -> L0?"
                    },
                    {
                        "username": "ryanthompson591",
                        "content": "I made a special case for odd nodes. If you think about it the very last node will be that middle node.\\n\\nExample:\\nL1->L2->L3-L4->L5\\nwil be\\nL1->L5->L2->L4->L3"
                    },
                    {
                        "username": "AshishBibyan",
                        "content": "After the stack is empty, make the last node point to NULL to remove this unwanted loop,"
                    },
                    {
                        "username": "danoob",
                        "content": "I am asking this because I am trying to use stack for my solution. Is it considered in-place ?"
                    },
                    {
                        "username": "BigDT",
                        "content": "that would be using extra space which isn\\'t optimal"
                    }
                ]
            },
            {
                "id": 1565641,
                "content": [
                    {
                        "username": "bugslayer312",
                        "content": "1. Find the middle by moving fast & slow iterators.\\n2. Remember right part beginning and cut off left part from the right.\\n3. Reverse right list, remember it new beginning.\\n4. Iterate left part from beginning and right part merging right list nodes into left list."
                    },
                    {
                        "username": "Aryadev19",
                        "content": "Thanks to this I was able to code it myself, thinking this solution was not easy"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "[@letsstart2020](/letsstart2020) because without cutting or making the previous pointer of the mid half resulting in making the graph, two pointers pointing the same node, so it will definitely give some pain to the programmer"
                    },
                    {
                        "username": "tejasX",
                        "content": "[@user9333qj](/user9333qj) \n\nSOLUTION BELOW:\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n```\nclass Solution {\npublic:\n\n    ListNode* getMiddle(ListNode* head){\n        ListNode* slow = head;\n        ListNode* fast = head;\n\n        while(fast){\n            if(!fast->next or !fast->next->next) return slow;\n            fast = fast->next->next;\n            slow = slow->next;\n        }\n\n        return slow;\n    }\n\n    ListNode* reverseList(ListNode* head){\n        if(!head) return head;\n\n        ListNode* prev = NULL;\n        ListNode* cur = head;\n        ListNode* nex = cur->next;\n\n        while(cur){\n            cur->next = prev;\n            prev = cur;\n            cur = nex;\n            if(nex) nex = nex->next;\n        }\n\n        return prev;\n    }\n\n    void reorderList(ListNode* head) {\n        ListNode* mid = getMiddle(head);\n        ListNode* nextPart = mid->next;\n        mid->next = NULL;\n\n        //two pointer:\n        ListNode* l1 = head;\n        ListNode* l2 = reverseList(nextPart);\n\n        ListNode* result = new ListNode(-1);\n        ListNode* res = result;\n\n        while(l1 or l2){\n            if(l1) {\n                res->next = l1;\n                res = res->next;\n                l1 = l1->next;\n            }\n            if(l2){\n                res->next = l2;\n                res = res->next;\n                l2 = l2->next;\n            }\n        }\n\n        res->next = NULL;\n        result->next = NULL;\n        return;\n    }\n};\n```\n"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "That\\'s of great help without posting solution "
                    },
                    {
                        "username": "songyang_dev",
                        "content": "Thanks! Step 2 solved my cycles"
                    },
                    {
                        "username": "letsstart2020",
                        "content": "I did not cut the two lists and was getting time limit exceeded, could you please explain why as i am new to linked list"
                    },
                    {
                        "username": "user9333qj",
                        "content": "I used the same method, but it is showing error. Could you please provide me with the code, If possible? \\nThanks."
                    },
                    {
                        "username": "harishaseri28",
                        "content": "I used this approach only."
                    },
                    {
                        "username": "mariohdez",
                        "content": "To be honest, the concepts aren\\'t super hard here. But I think the combination of reversal + merging operations during an interview settting makes this problem on the harder end of medium problems. This, coupled with the fact you have to recognize that in order to get the new order, you have to reverse the second half, then merge the two halves. IDK, seems hard to do in 45 minutes. Took me 10 minutes to figure out the pattern, and 40 minutes to code."
                    },
                    {
                        "username": "eiqnaict",
                        "content": "I solved it by using O(N) space in O(N) time."
                    },
                    {
                        "username": "Jayacha",
                        "content": "good job \\n"
                    },
                    {
                        "username": "AshishBibyan",
                        "content": "I used a stack for this solution to store the 2nd half of the list.\\nLater iteratively popped the last node from the stack and inserted it after the current node of the list and progressed until the stack is empty."
                    },
                    {
                        "username": "hafid-hub",
                        "content": "I used this approach in first time. I code and pass the tests. But $$O(n)$$  as space complexity... We can do better, right?\\nHow?\\nAfter about 4 hours, doing some sport exercises, I get the idea: reverse the second part! "
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "[@deepsym](/deepsym) uski marzi bhai \\uD83D\\uDE02"
                    },
                    {
                        "username": "coder42032",
                        "content": "I also applied this approach.\\n"
                    },
                    {
                        "username": "deepsym",
                        "content": "You could do this with O(1) space complexity."
                    },
                    {
                        "username": "dimal97psn",
                        "content": "Input:\\t[]\\nOutput:\\t[]\\nExpected:\\t{}"
                    },
                    {
                        "username": "Naveen_somireddy",
                        "content": "i used deque to solve this question .\\ni have copied the complete list into deque and iterated it from front and back succesivley"
                    },
                    {
                        "username": "brutalaty",
                        "content": "[@nikalinov](/nikalinov) I can\\'t see that as a restriction, was this problem updated ?"
                    },
                    {
                        "username": "nikalinov",
                        "content": "that is not O(1) space complexity tho"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 22.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/reorder-list/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Reverse the Second Part of the List and Merge Two Sorted Lists\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "chailattewithcream",
                        "content": "So stupid. I forgot to remove my \"print\" from while I was debugging and gave me TLE, ended spending a long time wondering why lol."
                    },
                    {
                        "username": "naman-exe",
                        "content": "this sucks mate, i did this in a contest for 50 mins"
                    },
                    {
                        "username": "Shengmin.Zhang",
                        "content": "What if there are odd number of nodes?\\n\\nFor example:\\n\\nL: L0\\n\\nWhat's the result?\\n\\nL: L0 -> L0?"
                    },
                    {
                        "username": "ryanthompson591",
                        "content": "I made a special case for odd nodes. If you think about it the very last node will be that middle node.\\n\\nExample:\\nL1->L2->L3-L4->L5\\nwil be\\nL1->L5->L2->L4->L3"
                    },
                    {
                        "username": "AshishBibyan",
                        "content": "After the stack is empty, make the last node point to NULL to remove this unwanted loop,"
                    },
                    {
                        "username": "danoob",
                        "content": "I am asking this because I am trying to use stack for my solution. Is it considered in-place ?"
                    },
                    {
                        "username": "BigDT",
                        "content": "that would be using extra space which isn\\'t optimal"
                    }
                ]
            },
            {
                "id": 1880017,
                "content": [
                    {
                        "username": "bugslayer312",
                        "content": "1. Find the middle by moving fast & slow iterators.\\n2. Remember right part beginning and cut off left part from the right.\\n3. Reverse right list, remember it new beginning.\\n4. Iterate left part from beginning and right part merging right list nodes into left list."
                    },
                    {
                        "username": "Aryadev19",
                        "content": "Thanks to this I was able to code it myself, thinking this solution was not easy"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "[@letsstart2020](/letsstart2020) because without cutting or making the previous pointer of the mid half resulting in making the graph, two pointers pointing the same node, so it will definitely give some pain to the programmer"
                    },
                    {
                        "username": "tejasX",
                        "content": "[@user9333qj](/user9333qj) \n\nSOLUTION BELOW:\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n```\nclass Solution {\npublic:\n\n    ListNode* getMiddle(ListNode* head){\n        ListNode* slow = head;\n        ListNode* fast = head;\n\n        while(fast){\n            if(!fast->next or !fast->next->next) return slow;\n            fast = fast->next->next;\n            slow = slow->next;\n        }\n\n        return slow;\n    }\n\n    ListNode* reverseList(ListNode* head){\n        if(!head) return head;\n\n        ListNode* prev = NULL;\n        ListNode* cur = head;\n        ListNode* nex = cur->next;\n\n        while(cur){\n            cur->next = prev;\n            prev = cur;\n            cur = nex;\n            if(nex) nex = nex->next;\n        }\n\n        return prev;\n    }\n\n    void reorderList(ListNode* head) {\n        ListNode* mid = getMiddle(head);\n        ListNode* nextPart = mid->next;\n        mid->next = NULL;\n\n        //two pointer:\n        ListNode* l1 = head;\n        ListNode* l2 = reverseList(nextPart);\n\n        ListNode* result = new ListNode(-1);\n        ListNode* res = result;\n\n        while(l1 or l2){\n            if(l1) {\n                res->next = l1;\n                res = res->next;\n                l1 = l1->next;\n            }\n            if(l2){\n                res->next = l2;\n                res = res->next;\n                l2 = l2->next;\n            }\n        }\n\n        res->next = NULL;\n        result->next = NULL;\n        return;\n    }\n};\n```\n"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "That\\'s of great help without posting solution "
                    },
                    {
                        "username": "songyang_dev",
                        "content": "Thanks! Step 2 solved my cycles"
                    },
                    {
                        "username": "letsstart2020",
                        "content": "I did not cut the two lists and was getting time limit exceeded, could you please explain why as i am new to linked list"
                    },
                    {
                        "username": "user9333qj",
                        "content": "I used the same method, but it is showing error. Could you please provide me with the code, If possible? \\nThanks."
                    },
                    {
                        "username": "harishaseri28",
                        "content": "I used this approach only."
                    },
                    {
                        "username": "mariohdez",
                        "content": "To be honest, the concepts aren\\'t super hard here. But I think the combination of reversal + merging operations during an interview settting makes this problem on the harder end of medium problems. This, coupled with the fact you have to recognize that in order to get the new order, you have to reverse the second half, then merge the two halves. IDK, seems hard to do in 45 minutes. Took me 10 minutes to figure out the pattern, and 40 minutes to code."
                    },
                    {
                        "username": "eiqnaict",
                        "content": "I solved it by using O(N) space in O(N) time."
                    },
                    {
                        "username": "Jayacha",
                        "content": "good job \\n"
                    },
                    {
                        "username": "AshishBibyan",
                        "content": "I used a stack for this solution to store the 2nd half of the list.\\nLater iteratively popped the last node from the stack and inserted it after the current node of the list and progressed until the stack is empty."
                    },
                    {
                        "username": "hafid-hub",
                        "content": "I used this approach in first time. I code and pass the tests. But $$O(n)$$  as space complexity... We can do better, right?\\nHow?\\nAfter about 4 hours, doing some sport exercises, I get the idea: reverse the second part! "
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "[@deepsym](/deepsym) uski marzi bhai \\uD83D\\uDE02"
                    },
                    {
                        "username": "coder42032",
                        "content": "I also applied this approach.\\n"
                    },
                    {
                        "username": "deepsym",
                        "content": "You could do this with O(1) space complexity."
                    },
                    {
                        "username": "dimal97psn",
                        "content": "Input:\\t[]\\nOutput:\\t[]\\nExpected:\\t{}"
                    },
                    {
                        "username": "Naveen_somireddy",
                        "content": "i used deque to solve this question .\\ni have copied the complete list into deque and iterated it from front and back succesivley"
                    },
                    {
                        "username": "brutalaty",
                        "content": "[@nikalinov](/nikalinov) I can\\'t see that as a restriction, was this problem updated ?"
                    },
                    {
                        "username": "nikalinov",
                        "content": "that is not O(1) space complexity tho"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 22.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/reorder-list/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Reverse the Second Part of the List and Merge Two Sorted Lists\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "chailattewithcream",
                        "content": "So stupid. I forgot to remove my \"print\" from while I was debugging and gave me TLE, ended spending a long time wondering why lol."
                    },
                    {
                        "username": "naman-exe",
                        "content": "this sucks mate, i did this in a contest for 50 mins"
                    },
                    {
                        "username": "Shengmin.Zhang",
                        "content": "What if there are odd number of nodes?\\n\\nFor example:\\n\\nL: L0\\n\\nWhat's the result?\\n\\nL: L0 -> L0?"
                    },
                    {
                        "username": "ryanthompson591",
                        "content": "I made a special case for odd nodes. If you think about it the very last node will be that middle node.\\n\\nExample:\\nL1->L2->L3-L4->L5\\nwil be\\nL1->L5->L2->L4->L3"
                    },
                    {
                        "username": "AshishBibyan",
                        "content": "After the stack is empty, make the last node point to NULL to remove this unwanted loop,"
                    },
                    {
                        "username": "danoob",
                        "content": "I am asking this because I am trying to use stack for my solution. Is it considered in-place ?"
                    },
                    {
                        "username": "BigDT",
                        "content": "that would be using extra space which isn\\'t optimal"
                    }
                ]
            },
            {
                "id": 1568967,
                "content": [
                    {
                        "username": "bugslayer312",
                        "content": "1. Find the middle by moving fast & slow iterators.\\n2. Remember right part beginning and cut off left part from the right.\\n3. Reverse right list, remember it new beginning.\\n4. Iterate left part from beginning and right part merging right list nodes into left list."
                    },
                    {
                        "username": "Aryadev19",
                        "content": "Thanks to this I was able to code it myself, thinking this solution was not easy"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "[@letsstart2020](/letsstart2020) because without cutting or making the previous pointer of the mid half resulting in making the graph, two pointers pointing the same node, so it will definitely give some pain to the programmer"
                    },
                    {
                        "username": "tejasX",
                        "content": "[@user9333qj](/user9333qj) \n\nSOLUTION BELOW:\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n```\nclass Solution {\npublic:\n\n    ListNode* getMiddle(ListNode* head){\n        ListNode* slow = head;\n        ListNode* fast = head;\n\n        while(fast){\n            if(!fast->next or !fast->next->next) return slow;\n            fast = fast->next->next;\n            slow = slow->next;\n        }\n\n        return slow;\n    }\n\n    ListNode* reverseList(ListNode* head){\n        if(!head) return head;\n\n        ListNode* prev = NULL;\n        ListNode* cur = head;\n        ListNode* nex = cur->next;\n\n        while(cur){\n            cur->next = prev;\n            prev = cur;\n            cur = nex;\n            if(nex) nex = nex->next;\n        }\n\n        return prev;\n    }\n\n    void reorderList(ListNode* head) {\n        ListNode* mid = getMiddle(head);\n        ListNode* nextPart = mid->next;\n        mid->next = NULL;\n\n        //two pointer:\n        ListNode* l1 = head;\n        ListNode* l2 = reverseList(nextPart);\n\n        ListNode* result = new ListNode(-1);\n        ListNode* res = result;\n\n        while(l1 or l2){\n            if(l1) {\n                res->next = l1;\n                res = res->next;\n                l1 = l1->next;\n            }\n            if(l2){\n                res->next = l2;\n                res = res->next;\n                l2 = l2->next;\n            }\n        }\n\n        res->next = NULL;\n        result->next = NULL;\n        return;\n    }\n};\n```\n"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "That\\'s of great help without posting solution "
                    },
                    {
                        "username": "songyang_dev",
                        "content": "Thanks! Step 2 solved my cycles"
                    },
                    {
                        "username": "letsstart2020",
                        "content": "I did not cut the two lists and was getting time limit exceeded, could you please explain why as i am new to linked list"
                    },
                    {
                        "username": "user9333qj",
                        "content": "I used the same method, but it is showing error. Could you please provide me with the code, If possible? \\nThanks."
                    },
                    {
                        "username": "harishaseri28",
                        "content": "I used this approach only."
                    },
                    {
                        "username": "mariohdez",
                        "content": "To be honest, the concepts aren\\'t super hard here. But I think the combination of reversal + merging operations during an interview settting makes this problem on the harder end of medium problems. This, coupled with the fact you have to recognize that in order to get the new order, you have to reverse the second half, then merge the two halves. IDK, seems hard to do in 45 minutes. Took me 10 minutes to figure out the pattern, and 40 minutes to code."
                    },
                    {
                        "username": "eiqnaict",
                        "content": "I solved it by using O(N) space in O(N) time."
                    },
                    {
                        "username": "Jayacha",
                        "content": "good job \\n"
                    },
                    {
                        "username": "AshishBibyan",
                        "content": "I used a stack for this solution to store the 2nd half of the list.\\nLater iteratively popped the last node from the stack and inserted it after the current node of the list and progressed until the stack is empty."
                    },
                    {
                        "username": "hafid-hub",
                        "content": "I used this approach in first time. I code and pass the tests. But $$O(n)$$  as space complexity... We can do better, right?\\nHow?\\nAfter about 4 hours, doing some sport exercises, I get the idea: reverse the second part! "
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "[@deepsym](/deepsym) uski marzi bhai \\uD83D\\uDE02"
                    },
                    {
                        "username": "coder42032",
                        "content": "I also applied this approach.\\n"
                    },
                    {
                        "username": "deepsym",
                        "content": "You could do this with O(1) space complexity."
                    },
                    {
                        "username": "dimal97psn",
                        "content": "Input:\\t[]\\nOutput:\\t[]\\nExpected:\\t{}"
                    },
                    {
                        "username": "Naveen_somireddy",
                        "content": "i used deque to solve this question .\\ni have copied the complete list into deque and iterated it from front and back succesivley"
                    },
                    {
                        "username": "brutalaty",
                        "content": "[@nikalinov](/nikalinov) I can\\'t see that as a restriction, was this problem updated ?"
                    },
                    {
                        "username": "nikalinov",
                        "content": "that is not O(1) space complexity tho"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 22.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/reorder-list/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Reverse the Second Part of the List and Merge Two Sorted Lists\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "chailattewithcream",
                        "content": "So stupid. I forgot to remove my \"print\" from while I was debugging and gave me TLE, ended spending a long time wondering why lol."
                    },
                    {
                        "username": "naman-exe",
                        "content": "this sucks mate, i did this in a contest for 50 mins"
                    },
                    {
                        "username": "Shengmin.Zhang",
                        "content": "What if there are odd number of nodes?\\n\\nFor example:\\n\\nL: L0\\n\\nWhat's the result?\\n\\nL: L0 -> L0?"
                    },
                    {
                        "username": "ryanthompson591",
                        "content": "I made a special case for odd nodes. If you think about it the very last node will be that middle node.\\n\\nExample:\\nL1->L2->L3-L4->L5\\nwil be\\nL1->L5->L2->L4->L3"
                    },
                    {
                        "username": "AshishBibyan",
                        "content": "After the stack is empty, make the last node point to NULL to remove this unwanted loop,"
                    },
                    {
                        "username": "danoob",
                        "content": "I am asking this because I am trying to use stack for my solution. Is it considered in-place ?"
                    },
                    {
                        "username": "BigDT",
                        "content": "that would be using extra space which isn\\'t optimal"
                    }
                ]
            },
            {
                "id": 1571309,
                "content": [
                    {
                        "username": "bugslayer312",
                        "content": "1. Find the middle by moving fast & slow iterators.\\n2. Remember right part beginning and cut off left part from the right.\\n3. Reverse right list, remember it new beginning.\\n4. Iterate left part from beginning and right part merging right list nodes into left list."
                    },
                    {
                        "username": "Aryadev19",
                        "content": "Thanks to this I was able to code it myself, thinking this solution was not easy"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "[@letsstart2020](/letsstart2020) because without cutting or making the previous pointer of the mid half resulting in making the graph, two pointers pointing the same node, so it will definitely give some pain to the programmer"
                    },
                    {
                        "username": "tejasX",
                        "content": "[@user9333qj](/user9333qj) \n\nSOLUTION BELOW:\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n```\nclass Solution {\npublic:\n\n    ListNode* getMiddle(ListNode* head){\n        ListNode* slow = head;\n        ListNode* fast = head;\n\n        while(fast){\n            if(!fast->next or !fast->next->next) return slow;\n            fast = fast->next->next;\n            slow = slow->next;\n        }\n\n        return slow;\n    }\n\n    ListNode* reverseList(ListNode* head){\n        if(!head) return head;\n\n        ListNode* prev = NULL;\n        ListNode* cur = head;\n        ListNode* nex = cur->next;\n\n        while(cur){\n            cur->next = prev;\n            prev = cur;\n            cur = nex;\n            if(nex) nex = nex->next;\n        }\n\n        return prev;\n    }\n\n    void reorderList(ListNode* head) {\n        ListNode* mid = getMiddle(head);\n        ListNode* nextPart = mid->next;\n        mid->next = NULL;\n\n        //two pointer:\n        ListNode* l1 = head;\n        ListNode* l2 = reverseList(nextPart);\n\n        ListNode* result = new ListNode(-1);\n        ListNode* res = result;\n\n        while(l1 or l2){\n            if(l1) {\n                res->next = l1;\n                res = res->next;\n                l1 = l1->next;\n            }\n            if(l2){\n                res->next = l2;\n                res = res->next;\n                l2 = l2->next;\n            }\n        }\n\n        res->next = NULL;\n        result->next = NULL;\n        return;\n    }\n};\n```\n"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "That\\'s of great help without posting solution "
                    },
                    {
                        "username": "songyang_dev",
                        "content": "Thanks! Step 2 solved my cycles"
                    },
                    {
                        "username": "letsstart2020",
                        "content": "I did not cut the two lists and was getting time limit exceeded, could you please explain why as i am new to linked list"
                    },
                    {
                        "username": "user9333qj",
                        "content": "I used the same method, but it is showing error. Could you please provide me with the code, If possible? \\nThanks."
                    },
                    {
                        "username": "harishaseri28",
                        "content": "I used this approach only."
                    },
                    {
                        "username": "mariohdez",
                        "content": "To be honest, the concepts aren\\'t super hard here. But I think the combination of reversal + merging operations during an interview settting makes this problem on the harder end of medium problems. This, coupled with the fact you have to recognize that in order to get the new order, you have to reverse the second half, then merge the two halves. IDK, seems hard to do in 45 minutes. Took me 10 minutes to figure out the pattern, and 40 minutes to code."
                    },
                    {
                        "username": "eiqnaict",
                        "content": "I solved it by using O(N) space in O(N) time."
                    },
                    {
                        "username": "Jayacha",
                        "content": "good job \\n"
                    },
                    {
                        "username": "AshishBibyan",
                        "content": "I used a stack for this solution to store the 2nd half of the list.\\nLater iteratively popped the last node from the stack and inserted it after the current node of the list and progressed until the stack is empty."
                    },
                    {
                        "username": "hafid-hub",
                        "content": "I used this approach in first time. I code and pass the tests. But $$O(n)$$  as space complexity... We can do better, right?\\nHow?\\nAfter about 4 hours, doing some sport exercises, I get the idea: reverse the second part! "
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "[@deepsym](/deepsym) uski marzi bhai \\uD83D\\uDE02"
                    },
                    {
                        "username": "coder42032",
                        "content": "I also applied this approach.\\n"
                    },
                    {
                        "username": "deepsym",
                        "content": "You could do this with O(1) space complexity."
                    },
                    {
                        "username": "dimal97psn",
                        "content": "Input:\\t[]\\nOutput:\\t[]\\nExpected:\\t{}"
                    },
                    {
                        "username": "Naveen_somireddy",
                        "content": "i used deque to solve this question .\\ni have copied the complete list into deque and iterated it from front and back succesivley"
                    },
                    {
                        "username": "brutalaty",
                        "content": "[@nikalinov](/nikalinov) I can\\'t see that as a restriction, was this problem updated ?"
                    },
                    {
                        "username": "nikalinov",
                        "content": "that is not O(1) space complexity tho"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 22.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/reorder-list/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Reverse the Second Part of the List and Merge Two Sorted Lists\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "chailattewithcream",
                        "content": "So stupid. I forgot to remove my \"print\" from while I was debugging and gave me TLE, ended spending a long time wondering why lol."
                    },
                    {
                        "username": "naman-exe",
                        "content": "this sucks mate, i did this in a contest for 50 mins"
                    },
                    {
                        "username": "Shengmin.Zhang",
                        "content": "What if there are odd number of nodes?\\n\\nFor example:\\n\\nL: L0\\n\\nWhat's the result?\\n\\nL: L0 -> L0?"
                    },
                    {
                        "username": "ryanthompson591",
                        "content": "I made a special case for odd nodes. If you think about it the very last node will be that middle node.\\n\\nExample:\\nL1->L2->L3-L4->L5\\nwil be\\nL1->L5->L2->L4->L3"
                    },
                    {
                        "username": "AshishBibyan",
                        "content": "After the stack is empty, make the last node point to NULL to remove this unwanted loop,"
                    },
                    {
                        "username": "danoob",
                        "content": "I am asking this because I am trying to use stack for my solution. Is it considered in-place ?"
                    },
                    {
                        "username": "BigDT",
                        "content": "that would be using extra space which isn\\'t optimal"
                    }
                ]
            },
            {
                "id": 1970047,
                "content": [
                    {
                        "username": "yuangaonyc",
                        "content": "Good practice for most of the important techniques of dealing with linked lists, ie. 2 pointer traversing, reversing, merging, ... "
                    },
                    {
                        "username": "MangoTroll34",
                        "content": "This question utilizes the linked list patterns you pick up from doing \\'easy\\' problems. I got stuck on merging the two lists because if you leave the middle node in both lists then you will create a cycle. Continuing until the reversed lists next is null prevents you from adding the second list node when it already exists at the end of the first list. "
                    },
                    {
                        "username": "anin9",
                        "content": "Can someone please help - getting TLE on my code with one of the test cases and can't figure why :( \n\n```\ndef reorderList(self, head):\n        # 1. Find middle of list\n        slow = fast = head\n        while fast and fast.next:\n            slow = slow.next\n            fast = fast.next.next     \n        \n        second = slow.next\n        slow.next = None\n\n        # Reverse the second half\n        current, previous = second, None\n        while current:\n            nextNode = current.next\n            current.next = previous\n            previous = current\n            current = nextNode\n        second = previous\n\n        # Merge both linked lists:\n        node1, node2 = head, second\n        while node1 and node2:\n            nextNode1 = node1.next\n            nextNode2 = node2.next\n\n            node1.next = node2\n            node1 = nextNode1\n\n            node2.next = node1\n            node2 = nextNode2\n```"
                    },
                    {
                        "username": "sufiyan052",
                        "content": "Here, Need to re-arrange list values. \\nJust draw the outcome in paper and try to see what need to do first and then focus on how to do this.\\n\\n# Approach\\n1 : Find middle of List.\\n2 : Reverse second half.\\n3 : Now take two pointer first & second.\\n4 : Move both pointer one by one & add value accordingly. "
                    },
                    {
                        "username": "Ravitejai1",
                        "content": "I am getting a runtime error that member access within misaligned address ,But when i run it on online compiler i got the desired output, can any  one help me with this"
                    },
                    {
                        "username": "user5228Qg",
                        "content": "Something wrong with the test cases. Always returns the original list no matter what i do. Even if I returned None, it still outputs the original list..."
                    },
                    {
                        "username": "User147077",
                        "content": "this is because you are not supposed to return anything, you\\'re supposed to modify the list in place. so the test cases are printing the list based on the head that they gave your function, not based on the head that you\\'re returning"
                    },
                    {
                        "username": "Arun_A",
                        "content": "Can anyone tell why this is not working for the test case : [1,4,3,2] ??\\n\\nclass Solution {\\npublic:\\n    void reorderList(ListNode* head) {\\n        stack <ListNode*> st;\\n        queue <ListNode*> v;\\n        ListNode* temp = head;\\n        while(temp)\\n        {\\n            v.push(temp);\\n            temp = temp->next;\\n            if(temp!=NULL)\\n            {\\n                st.push(temp);\\n                temp = temp->next;\\n            }\\n        }\\n        head = v.front();\\n        v.pop();\\n\\n        temp = head;\\n        while(!st.empty() && !v.empty())\\n        {\\n            temp->next = st.top();\\n            st.pop();\\n            temp = temp->next;\\n\\n            temp->next = v.front();\\n            v.pop();\\n            temp = temp->next;\\n        }\\n\\n        if(!st.empty())\\n        {\\n            temp->next = st.top();\\n            temp = temp->next;\\n            st.pop();\\n        }\\n        temp -> next = NULL;\\n    }\\n};\\n"
                    },
                    {
                        "username": "ZoeZzzy",
                        "content": "Could anyone help? Why is this wrong \n\nclass Solution(object):\n\n    def reorderList(self, head):\n        list_ = []\n        temp = head\n        output = temp\n        while head is not None:\n            list_.append(head.val)\n            head = head.next\n\n        for i in range(len(list_)):\n            index = i // 2\n            if i % 2 == 0:\n                temp.next = ListNode(list_[index])\n            else:\n                temp.next = ListNode(list_[-index - 1])\n            temp = temp.next\n\n        try:\n            output = output.next  \n            return output\n        except:\n            return None\n    \n"
                    },
                    {
                        "username": "mskamel",
                        "content": "Why does my code causes a cycle in the linked list:\n\n`\nclass Solution {\n    public void reorderList(ListNode head) {\n        ListNode midNode = midNode(head);\n        Stack<ListNode> lastListNodesStack = new Stack<>();\n        appendNodesToStack(midNode, lastListNodesStack);\n        ListNode current = head;\n        ListNode prev = null;\n        ListNode next = null;\n\n        while (lastListNodesStack.isEmpty() == false) {\n            ListNode lastNode = lastListNodesStack.pop();\n            next = current.next;\n            prev = current;\n            current.next = lastNode;\n            lastNode.next = next;\n            current = next;\n        }\n    }\n\n    ListNode midNode(ListNode head) {\n        ListNode slowPointer = head;\n        ListNode fastPointer = head;\n\n        while (fastPointer != null && fastPointer.next != null) {\n            slowPointer = slowPointer.next;\n            fastPointer = fastPointer.next.next;\n        }\n\n        return slowPointer;\n    }\n\n    void appendNodesToStack(ListNode midNode, Stack<ListNode> stack) {\n        while (midNode != null) {\n            stack.push(midNode);\n            midNode = midNode.next;\n        }\n    }\n}\n`"
                    },
                    {
                        "username": "hafid-hub",
                        "content": "I have the some problem. It take me time to figure out why I have this cycle?\\nDrawing help me to understand  what happen.\\nTake an example:\\n1 ->  2 ->  3 -> 4 -> null\\n- stack has: 4 -> null and  3 -> 4 in reversed order\\n- current is : 1 - > 2 -> 3 -> 4 -> null\\nIn the first iteration:\\n- next is: 2 -> 3 -> 4 -> null-last is 4 -> null\\ncurrent.next = last, has as consequence:\\nhead  = 1 -> 4 -> null\\nnext = 2 -> 3 -> 4  -> null\\nIn other hand, last.next = next has as result:\\n4 -> next\\n4 -> 2 -> 3 -> 4 -> (nut null but the same ListNode)\\nand head: 1 -> |  4 -> 2 -> 3 -> 4 |  -> 2 -> 3 -> 4 -> 2 -> 3 -> 4....\\nI hope that will helpful. And forgive my English! \\n"
                    },
                    {
                        "username": "shahparam1903",
                        "content": "class Solution {\\npublic:\\n    ListNode* reverse(ListNode* head){\\n        if(head==NULL){\\n            return NULL;\\n        }\\n        if(head->next==NULL){\\n            return head;\\n        }\\n        ListNode *cur=head;\\n        ListNode *prev=NULL;\\n        ListNode *forward;\\n        while(cur!=NULL){\\n            forward=cur->next;\\n            cur->next=prev;\\n            prev=cur;\\n            cur=forward;\\n        }\\n        return prev;\\n    }\\n    void reorderList(ListNode* head) {\\n        if(head->next==NULL){\\n            return;\\n        }\\n        ListNode *slow=head;\\n        ListNode *fast=head->next;\\n        while(fast!=NULL){\\n            fast=fast->next;\\n            if(fast){\\n                fast=fast->next;\\n            }\\n            slow=slow->next;\\n        }\\n    ListNode *q=reverse(slow);\\n    ListNode *p=head;\\n    ListNode *r=NULL;\\n    ListNode *s=NULL;\\n    while( q && p ){\\n        r=p->next;\\n        s=q->next;\\n        p->next=q;\\n        q->next=r;\\n        p=r;\\n        q=s;\\n    }\\n    return;\\n    }\\n};  SOMEONE PLZ DEBUG THIS CODE FOR ME.....my logic is find the middle node...reverse it form middle and then adjust the links..."
                    }
                ]
            },
            {
                "id": 1807628,
                "content": [
                    {
                        "username": "yuangaonyc",
                        "content": "Good practice for most of the important techniques of dealing with linked lists, ie. 2 pointer traversing, reversing, merging, ... "
                    },
                    {
                        "username": "MangoTroll34",
                        "content": "This question utilizes the linked list patterns you pick up from doing \\'easy\\' problems. I got stuck on merging the two lists because if you leave the middle node in both lists then you will create a cycle. Continuing until the reversed lists next is null prevents you from adding the second list node when it already exists at the end of the first list. "
                    },
                    {
                        "username": "anin9",
                        "content": "Can someone please help - getting TLE on my code with one of the test cases and can't figure why :( \n\n```\ndef reorderList(self, head):\n        # 1. Find middle of list\n        slow = fast = head\n        while fast and fast.next:\n            slow = slow.next\n            fast = fast.next.next     \n        \n        second = slow.next\n        slow.next = None\n\n        # Reverse the second half\n        current, previous = second, None\n        while current:\n            nextNode = current.next\n            current.next = previous\n            previous = current\n            current = nextNode\n        second = previous\n\n        # Merge both linked lists:\n        node1, node2 = head, second\n        while node1 and node2:\n            nextNode1 = node1.next\n            nextNode2 = node2.next\n\n            node1.next = node2\n            node1 = nextNode1\n\n            node2.next = node1\n            node2 = nextNode2\n```"
                    },
                    {
                        "username": "sufiyan052",
                        "content": "Here, Need to re-arrange list values. \\nJust draw the outcome in paper and try to see what need to do first and then focus on how to do this.\\n\\n# Approach\\n1 : Find middle of List.\\n2 : Reverse second half.\\n3 : Now take two pointer first & second.\\n4 : Move both pointer one by one & add value accordingly. "
                    },
                    {
                        "username": "Ravitejai1",
                        "content": "I am getting a runtime error that member access within misaligned address ,But when i run it on online compiler i got the desired output, can any  one help me with this"
                    },
                    {
                        "username": "user5228Qg",
                        "content": "Something wrong with the test cases. Always returns the original list no matter what i do. Even if I returned None, it still outputs the original list..."
                    },
                    {
                        "username": "User147077",
                        "content": "this is because you are not supposed to return anything, you\\'re supposed to modify the list in place. so the test cases are printing the list based on the head that they gave your function, not based on the head that you\\'re returning"
                    },
                    {
                        "username": "Arun_A",
                        "content": "Can anyone tell why this is not working for the test case : [1,4,3,2] ??\\n\\nclass Solution {\\npublic:\\n    void reorderList(ListNode* head) {\\n        stack <ListNode*> st;\\n        queue <ListNode*> v;\\n        ListNode* temp = head;\\n        while(temp)\\n        {\\n            v.push(temp);\\n            temp = temp->next;\\n            if(temp!=NULL)\\n            {\\n                st.push(temp);\\n                temp = temp->next;\\n            }\\n        }\\n        head = v.front();\\n        v.pop();\\n\\n        temp = head;\\n        while(!st.empty() && !v.empty())\\n        {\\n            temp->next = st.top();\\n            st.pop();\\n            temp = temp->next;\\n\\n            temp->next = v.front();\\n            v.pop();\\n            temp = temp->next;\\n        }\\n\\n        if(!st.empty())\\n        {\\n            temp->next = st.top();\\n            temp = temp->next;\\n            st.pop();\\n        }\\n        temp -> next = NULL;\\n    }\\n};\\n"
                    },
                    {
                        "username": "ZoeZzzy",
                        "content": "Could anyone help? Why is this wrong \n\nclass Solution(object):\n\n    def reorderList(self, head):\n        list_ = []\n        temp = head\n        output = temp\n        while head is not None:\n            list_.append(head.val)\n            head = head.next\n\n        for i in range(len(list_)):\n            index = i // 2\n            if i % 2 == 0:\n                temp.next = ListNode(list_[index])\n            else:\n                temp.next = ListNode(list_[-index - 1])\n            temp = temp.next\n\n        try:\n            output = output.next  \n            return output\n        except:\n            return None\n    \n"
                    },
                    {
                        "username": "mskamel",
                        "content": "Why does my code causes a cycle in the linked list:\n\n`\nclass Solution {\n    public void reorderList(ListNode head) {\n        ListNode midNode = midNode(head);\n        Stack<ListNode> lastListNodesStack = new Stack<>();\n        appendNodesToStack(midNode, lastListNodesStack);\n        ListNode current = head;\n        ListNode prev = null;\n        ListNode next = null;\n\n        while (lastListNodesStack.isEmpty() == false) {\n            ListNode lastNode = lastListNodesStack.pop();\n            next = current.next;\n            prev = current;\n            current.next = lastNode;\n            lastNode.next = next;\n            current = next;\n        }\n    }\n\n    ListNode midNode(ListNode head) {\n        ListNode slowPointer = head;\n        ListNode fastPointer = head;\n\n        while (fastPointer != null && fastPointer.next != null) {\n            slowPointer = slowPointer.next;\n            fastPointer = fastPointer.next.next;\n        }\n\n        return slowPointer;\n    }\n\n    void appendNodesToStack(ListNode midNode, Stack<ListNode> stack) {\n        while (midNode != null) {\n            stack.push(midNode);\n            midNode = midNode.next;\n        }\n    }\n}\n`"
                    },
                    {
                        "username": "hafid-hub",
                        "content": "I have the some problem. It take me time to figure out why I have this cycle?\\nDrawing help me to understand  what happen.\\nTake an example:\\n1 ->  2 ->  3 -> 4 -> null\\n- stack has: 4 -> null and  3 -> 4 in reversed order\\n- current is : 1 - > 2 -> 3 -> 4 -> null\\nIn the first iteration:\\n- next is: 2 -> 3 -> 4 -> null-last is 4 -> null\\ncurrent.next = last, has as consequence:\\nhead  = 1 -> 4 -> null\\nnext = 2 -> 3 -> 4  -> null\\nIn other hand, last.next = next has as result:\\n4 -> next\\n4 -> 2 -> 3 -> 4 -> (nut null but the same ListNode)\\nand head: 1 -> |  4 -> 2 -> 3 -> 4 |  -> 2 -> 3 -> 4 -> 2 -> 3 -> 4....\\nI hope that will helpful. And forgive my English! \\n"
                    },
                    {
                        "username": "shahparam1903",
                        "content": "class Solution {\\npublic:\\n    ListNode* reverse(ListNode* head){\\n        if(head==NULL){\\n            return NULL;\\n        }\\n        if(head->next==NULL){\\n            return head;\\n        }\\n        ListNode *cur=head;\\n        ListNode *prev=NULL;\\n        ListNode *forward;\\n        while(cur!=NULL){\\n            forward=cur->next;\\n            cur->next=prev;\\n            prev=cur;\\n            cur=forward;\\n        }\\n        return prev;\\n    }\\n    void reorderList(ListNode* head) {\\n        if(head->next==NULL){\\n            return;\\n        }\\n        ListNode *slow=head;\\n        ListNode *fast=head->next;\\n        while(fast!=NULL){\\n            fast=fast->next;\\n            if(fast){\\n                fast=fast->next;\\n            }\\n            slow=slow->next;\\n        }\\n    ListNode *q=reverse(slow);\\n    ListNode *p=head;\\n    ListNode *r=NULL;\\n    ListNode *s=NULL;\\n    while( q && p ){\\n        r=p->next;\\n        s=q->next;\\n        p->next=q;\\n        q->next=r;\\n        p=r;\\n        q=s;\\n    }\\n    return;\\n    }\\n};  SOMEONE PLZ DEBUG THIS CODE FOR ME.....my logic is find the middle node...reverse it form middle and then adjust the links..."
                    }
                ]
            },
            {
                "id": 2061251,
                "content": [
                    {
                        "username": "yuangaonyc",
                        "content": "Good practice for most of the important techniques of dealing with linked lists, ie. 2 pointer traversing, reversing, merging, ... "
                    },
                    {
                        "username": "MangoTroll34",
                        "content": "This question utilizes the linked list patterns you pick up from doing \\'easy\\' problems. I got stuck on merging the two lists because if you leave the middle node in both lists then you will create a cycle. Continuing until the reversed lists next is null prevents you from adding the second list node when it already exists at the end of the first list. "
                    },
                    {
                        "username": "anin9",
                        "content": "Can someone please help - getting TLE on my code with one of the test cases and can't figure why :( \n\n```\ndef reorderList(self, head):\n        # 1. Find middle of list\n        slow = fast = head\n        while fast and fast.next:\n            slow = slow.next\n            fast = fast.next.next     \n        \n        second = slow.next\n        slow.next = None\n\n        # Reverse the second half\n        current, previous = second, None\n        while current:\n            nextNode = current.next\n            current.next = previous\n            previous = current\n            current = nextNode\n        second = previous\n\n        # Merge both linked lists:\n        node1, node2 = head, second\n        while node1 and node2:\n            nextNode1 = node1.next\n            nextNode2 = node2.next\n\n            node1.next = node2\n            node1 = nextNode1\n\n            node2.next = node1\n            node2 = nextNode2\n```"
                    },
                    {
                        "username": "sufiyan052",
                        "content": "Here, Need to re-arrange list values. \\nJust draw the outcome in paper and try to see what need to do first and then focus on how to do this.\\n\\n# Approach\\n1 : Find middle of List.\\n2 : Reverse second half.\\n3 : Now take two pointer first & second.\\n4 : Move both pointer one by one & add value accordingly. "
                    },
                    {
                        "username": "Ravitejai1",
                        "content": "I am getting a runtime error that member access within misaligned address ,But when i run it on online compiler i got the desired output, can any  one help me with this"
                    },
                    {
                        "username": "user5228Qg",
                        "content": "Something wrong with the test cases. Always returns the original list no matter what i do. Even if I returned None, it still outputs the original list..."
                    },
                    {
                        "username": "User147077",
                        "content": "this is because you are not supposed to return anything, you\\'re supposed to modify the list in place. so the test cases are printing the list based on the head that they gave your function, not based on the head that you\\'re returning"
                    },
                    {
                        "username": "Arun_A",
                        "content": "Can anyone tell why this is not working for the test case : [1,4,3,2] ??\\n\\nclass Solution {\\npublic:\\n    void reorderList(ListNode* head) {\\n        stack <ListNode*> st;\\n        queue <ListNode*> v;\\n        ListNode* temp = head;\\n        while(temp)\\n        {\\n            v.push(temp);\\n            temp = temp->next;\\n            if(temp!=NULL)\\n            {\\n                st.push(temp);\\n                temp = temp->next;\\n            }\\n        }\\n        head = v.front();\\n        v.pop();\\n\\n        temp = head;\\n        while(!st.empty() && !v.empty())\\n        {\\n            temp->next = st.top();\\n            st.pop();\\n            temp = temp->next;\\n\\n            temp->next = v.front();\\n            v.pop();\\n            temp = temp->next;\\n        }\\n\\n        if(!st.empty())\\n        {\\n            temp->next = st.top();\\n            temp = temp->next;\\n            st.pop();\\n        }\\n        temp -> next = NULL;\\n    }\\n};\\n"
                    },
                    {
                        "username": "ZoeZzzy",
                        "content": "Could anyone help? Why is this wrong \n\nclass Solution(object):\n\n    def reorderList(self, head):\n        list_ = []\n        temp = head\n        output = temp\n        while head is not None:\n            list_.append(head.val)\n            head = head.next\n\n        for i in range(len(list_)):\n            index = i // 2\n            if i % 2 == 0:\n                temp.next = ListNode(list_[index])\n            else:\n                temp.next = ListNode(list_[-index - 1])\n            temp = temp.next\n\n        try:\n            output = output.next  \n            return output\n        except:\n            return None\n    \n"
                    },
                    {
                        "username": "mskamel",
                        "content": "Why does my code causes a cycle in the linked list:\n\n`\nclass Solution {\n    public void reorderList(ListNode head) {\n        ListNode midNode = midNode(head);\n        Stack<ListNode> lastListNodesStack = new Stack<>();\n        appendNodesToStack(midNode, lastListNodesStack);\n        ListNode current = head;\n        ListNode prev = null;\n        ListNode next = null;\n\n        while (lastListNodesStack.isEmpty() == false) {\n            ListNode lastNode = lastListNodesStack.pop();\n            next = current.next;\n            prev = current;\n            current.next = lastNode;\n            lastNode.next = next;\n            current = next;\n        }\n    }\n\n    ListNode midNode(ListNode head) {\n        ListNode slowPointer = head;\n        ListNode fastPointer = head;\n\n        while (fastPointer != null && fastPointer.next != null) {\n            slowPointer = slowPointer.next;\n            fastPointer = fastPointer.next.next;\n        }\n\n        return slowPointer;\n    }\n\n    void appendNodesToStack(ListNode midNode, Stack<ListNode> stack) {\n        while (midNode != null) {\n            stack.push(midNode);\n            midNode = midNode.next;\n        }\n    }\n}\n`"
                    },
                    {
                        "username": "hafid-hub",
                        "content": "I have the some problem. It take me time to figure out why I have this cycle?\\nDrawing help me to understand  what happen.\\nTake an example:\\n1 ->  2 ->  3 -> 4 -> null\\n- stack has: 4 -> null and  3 -> 4 in reversed order\\n- current is : 1 - > 2 -> 3 -> 4 -> null\\nIn the first iteration:\\n- next is: 2 -> 3 -> 4 -> null-last is 4 -> null\\ncurrent.next = last, has as consequence:\\nhead  = 1 -> 4 -> null\\nnext = 2 -> 3 -> 4  -> null\\nIn other hand, last.next = next has as result:\\n4 -> next\\n4 -> 2 -> 3 -> 4 -> (nut null but the same ListNode)\\nand head: 1 -> |  4 -> 2 -> 3 -> 4 |  -> 2 -> 3 -> 4 -> 2 -> 3 -> 4....\\nI hope that will helpful. And forgive my English! \\n"
                    },
                    {
                        "username": "shahparam1903",
                        "content": "class Solution {\\npublic:\\n    ListNode* reverse(ListNode* head){\\n        if(head==NULL){\\n            return NULL;\\n        }\\n        if(head->next==NULL){\\n            return head;\\n        }\\n        ListNode *cur=head;\\n        ListNode *prev=NULL;\\n        ListNode *forward;\\n        while(cur!=NULL){\\n            forward=cur->next;\\n            cur->next=prev;\\n            prev=cur;\\n            cur=forward;\\n        }\\n        return prev;\\n    }\\n    void reorderList(ListNode* head) {\\n        if(head->next==NULL){\\n            return;\\n        }\\n        ListNode *slow=head;\\n        ListNode *fast=head->next;\\n        while(fast!=NULL){\\n            fast=fast->next;\\n            if(fast){\\n                fast=fast->next;\\n            }\\n            slow=slow->next;\\n        }\\n    ListNode *q=reverse(slow);\\n    ListNode *p=head;\\n    ListNode *r=NULL;\\n    ListNode *s=NULL;\\n    while( q && p ){\\n        r=p->next;\\n        s=q->next;\\n        p->next=q;\\n        q->next=r;\\n        p=r;\\n        q=s;\\n    }\\n    return;\\n    }\\n};  SOMEONE PLZ DEBUG THIS CODE FOR ME.....my logic is find the middle node...reverse it form middle and then adjust the links..."
                    }
                ]
            },
            {
                "id": 2045053,
                "content": [
                    {
                        "username": "yuangaonyc",
                        "content": "Good practice for most of the important techniques of dealing with linked lists, ie. 2 pointer traversing, reversing, merging, ... "
                    },
                    {
                        "username": "MangoTroll34",
                        "content": "This question utilizes the linked list patterns you pick up from doing \\'easy\\' problems. I got stuck on merging the two lists because if you leave the middle node in both lists then you will create a cycle. Continuing until the reversed lists next is null prevents you from adding the second list node when it already exists at the end of the first list. "
                    },
                    {
                        "username": "anin9",
                        "content": "Can someone please help - getting TLE on my code with one of the test cases and can't figure why :( \n\n```\ndef reorderList(self, head):\n        # 1. Find middle of list\n        slow = fast = head\n        while fast and fast.next:\n            slow = slow.next\n            fast = fast.next.next     \n        \n        second = slow.next\n        slow.next = None\n\n        # Reverse the second half\n        current, previous = second, None\n        while current:\n            nextNode = current.next\n            current.next = previous\n            previous = current\n            current = nextNode\n        second = previous\n\n        # Merge both linked lists:\n        node1, node2 = head, second\n        while node1 and node2:\n            nextNode1 = node1.next\n            nextNode2 = node2.next\n\n            node1.next = node2\n            node1 = nextNode1\n\n            node2.next = node1\n            node2 = nextNode2\n```"
                    },
                    {
                        "username": "sufiyan052",
                        "content": "Here, Need to re-arrange list values. \\nJust draw the outcome in paper and try to see what need to do first and then focus on how to do this.\\n\\n# Approach\\n1 : Find middle of List.\\n2 : Reverse second half.\\n3 : Now take two pointer first & second.\\n4 : Move both pointer one by one & add value accordingly. "
                    },
                    {
                        "username": "Ravitejai1",
                        "content": "I am getting a runtime error that member access within misaligned address ,But when i run it on online compiler i got the desired output, can any  one help me with this"
                    },
                    {
                        "username": "user5228Qg",
                        "content": "Something wrong with the test cases. Always returns the original list no matter what i do. Even if I returned None, it still outputs the original list..."
                    },
                    {
                        "username": "User147077",
                        "content": "this is because you are not supposed to return anything, you\\'re supposed to modify the list in place. so the test cases are printing the list based on the head that they gave your function, not based on the head that you\\'re returning"
                    },
                    {
                        "username": "Arun_A",
                        "content": "Can anyone tell why this is not working for the test case : [1,4,3,2] ??\\n\\nclass Solution {\\npublic:\\n    void reorderList(ListNode* head) {\\n        stack <ListNode*> st;\\n        queue <ListNode*> v;\\n        ListNode* temp = head;\\n        while(temp)\\n        {\\n            v.push(temp);\\n            temp = temp->next;\\n            if(temp!=NULL)\\n            {\\n                st.push(temp);\\n                temp = temp->next;\\n            }\\n        }\\n        head = v.front();\\n        v.pop();\\n\\n        temp = head;\\n        while(!st.empty() && !v.empty())\\n        {\\n            temp->next = st.top();\\n            st.pop();\\n            temp = temp->next;\\n\\n            temp->next = v.front();\\n            v.pop();\\n            temp = temp->next;\\n        }\\n\\n        if(!st.empty())\\n        {\\n            temp->next = st.top();\\n            temp = temp->next;\\n            st.pop();\\n        }\\n        temp -> next = NULL;\\n    }\\n};\\n"
                    },
                    {
                        "username": "ZoeZzzy",
                        "content": "Could anyone help? Why is this wrong \n\nclass Solution(object):\n\n    def reorderList(self, head):\n        list_ = []\n        temp = head\n        output = temp\n        while head is not None:\n            list_.append(head.val)\n            head = head.next\n\n        for i in range(len(list_)):\n            index = i // 2\n            if i % 2 == 0:\n                temp.next = ListNode(list_[index])\n            else:\n                temp.next = ListNode(list_[-index - 1])\n            temp = temp.next\n\n        try:\n            output = output.next  \n            return output\n        except:\n            return None\n    \n"
                    },
                    {
                        "username": "mskamel",
                        "content": "Why does my code causes a cycle in the linked list:\n\n`\nclass Solution {\n    public void reorderList(ListNode head) {\n        ListNode midNode = midNode(head);\n        Stack<ListNode> lastListNodesStack = new Stack<>();\n        appendNodesToStack(midNode, lastListNodesStack);\n        ListNode current = head;\n        ListNode prev = null;\n        ListNode next = null;\n\n        while (lastListNodesStack.isEmpty() == false) {\n            ListNode lastNode = lastListNodesStack.pop();\n            next = current.next;\n            prev = current;\n            current.next = lastNode;\n            lastNode.next = next;\n            current = next;\n        }\n    }\n\n    ListNode midNode(ListNode head) {\n        ListNode slowPointer = head;\n        ListNode fastPointer = head;\n\n        while (fastPointer != null && fastPointer.next != null) {\n            slowPointer = slowPointer.next;\n            fastPointer = fastPointer.next.next;\n        }\n\n        return slowPointer;\n    }\n\n    void appendNodesToStack(ListNode midNode, Stack<ListNode> stack) {\n        while (midNode != null) {\n            stack.push(midNode);\n            midNode = midNode.next;\n        }\n    }\n}\n`"
                    },
                    {
                        "username": "hafid-hub",
                        "content": "I have the some problem. It take me time to figure out why I have this cycle?\\nDrawing help me to understand  what happen.\\nTake an example:\\n1 ->  2 ->  3 -> 4 -> null\\n- stack has: 4 -> null and  3 -> 4 in reversed order\\n- current is : 1 - > 2 -> 3 -> 4 -> null\\nIn the first iteration:\\n- next is: 2 -> 3 -> 4 -> null-last is 4 -> null\\ncurrent.next = last, has as consequence:\\nhead  = 1 -> 4 -> null\\nnext = 2 -> 3 -> 4  -> null\\nIn other hand, last.next = next has as result:\\n4 -> next\\n4 -> 2 -> 3 -> 4 -> (nut null but the same ListNode)\\nand head: 1 -> |  4 -> 2 -> 3 -> 4 |  -> 2 -> 3 -> 4 -> 2 -> 3 -> 4....\\nI hope that will helpful. And forgive my English! \\n"
                    },
                    {
                        "username": "shahparam1903",
                        "content": "class Solution {\\npublic:\\n    ListNode* reverse(ListNode* head){\\n        if(head==NULL){\\n            return NULL;\\n        }\\n        if(head->next==NULL){\\n            return head;\\n        }\\n        ListNode *cur=head;\\n        ListNode *prev=NULL;\\n        ListNode *forward;\\n        while(cur!=NULL){\\n            forward=cur->next;\\n            cur->next=prev;\\n            prev=cur;\\n            cur=forward;\\n        }\\n        return prev;\\n    }\\n    void reorderList(ListNode* head) {\\n        if(head->next==NULL){\\n            return;\\n        }\\n        ListNode *slow=head;\\n        ListNode *fast=head->next;\\n        while(fast!=NULL){\\n            fast=fast->next;\\n            if(fast){\\n                fast=fast->next;\\n            }\\n            slow=slow->next;\\n        }\\n    ListNode *q=reverse(slow);\\n    ListNode *p=head;\\n    ListNode *r=NULL;\\n    ListNode *s=NULL;\\n    while( q && p ){\\n        r=p->next;\\n        s=q->next;\\n        p->next=q;\\n        q->next=r;\\n        p=r;\\n        q=s;\\n    }\\n    return;\\n    }\\n};  SOMEONE PLZ DEBUG THIS CODE FOR ME.....my logic is find the middle node...reverse it form middle and then adjust the links..."
                    }
                ]
            },
            {
                "id": 2002738,
                "content": [
                    {
                        "username": "yuangaonyc",
                        "content": "Good practice for most of the important techniques of dealing with linked lists, ie. 2 pointer traversing, reversing, merging, ... "
                    },
                    {
                        "username": "MangoTroll34",
                        "content": "This question utilizes the linked list patterns you pick up from doing \\'easy\\' problems. I got stuck on merging the two lists because if you leave the middle node in both lists then you will create a cycle. Continuing until the reversed lists next is null prevents you from adding the second list node when it already exists at the end of the first list. "
                    },
                    {
                        "username": "anin9",
                        "content": "Can someone please help - getting TLE on my code with one of the test cases and can't figure why :( \n\n```\ndef reorderList(self, head):\n        # 1. Find middle of list\n        slow = fast = head\n        while fast and fast.next:\n            slow = slow.next\n            fast = fast.next.next     \n        \n        second = slow.next\n        slow.next = None\n\n        # Reverse the second half\n        current, previous = second, None\n        while current:\n            nextNode = current.next\n            current.next = previous\n            previous = current\n            current = nextNode\n        second = previous\n\n        # Merge both linked lists:\n        node1, node2 = head, second\n        while node1 and node2:\n            nextNode1 = node1.next\n            nextNode2 = node2.next\n\n            node1.next = node2\n            node1 = nextNode1\n\n            node2.next = node1\n            node2 = nextNode2\n```"
                    },
                    {
                        "username": "sufiyan052",
                        "content": "Here, Need to re-arrange list values. \\nJust draw the outcome in paper and try to see what need to do first and then focus on how to do this.\\n\\n# Approach\\n1 : Find middle of List.\\n2 : Reverse second half.\\n3 : Now take two pointer first & second.\\n4 : Move both pointer one by one & add value accordingly. "
                    },
                    {
                        "username": "Ravitejai1",
                        "content": "I am getting a runtime error that member access within misaligned address ,But when i run it on online compiler i got the desired output, can any  one help me with this"
                    },
                    {
                        "username": "user5228Qg",
                        "content": "Something wrong with the test cases. Always returns the original list no matter what i do. Even if I returned None, it still outputs the original list..."
                    },
                    {
                        "username": "User147077",
                        "content": "this is because you are not supposed to return anything, you\\'re supposed to modify the list in place. so the test cases are printing the list based on the head that they gave your function, not based on the head that you\\'re returning"
                    },
                    {
                        "username": "Arun_A",
                        "content": "Can anyone tell why this is not working for the test case : [1,4,3,2] ??\\n\\nclass Solution {\\npublic:\\n    void reorderList(ListNode* head) {\\n        stack <ListNode*> st;\\n        queue <ListNode*> v;\\n        ListNode* temp = head;\\n        while(temp)\\n        {\\n            v.push(temp);\\n            temp = temp->next;\\n            if(temp!=NULL)\\n            {\\n                st.push(temp);\\n                temp = temp->next;\\n            }\\n        }\\n        head = v.front();\\n        v.pop();\\n\\n        temp = head;\\n        while(!st.empty() && !v.empty())\\n        {\\n            temp->next = st.top();\\n            st.pop();\\n            temp = temp->next;\\n\\n            temp->next = v.front();\\n            v.pop();\\n            temp = temp->next;\\n        }\\n\\n        if(!st.empty())\\n        {\\n            temp->next = st.top();\\n            temp = temp->next;\\n            st.pop();\\n        }\\n        temp -> next = NULL;\\n    }\\n};\\n"
                    },
                    {
                        "username": "ZoeZzzy",
                        "content": "Could anyone help? Why is this wrong \n\nclass Solution(object):\n\n    def reorderList(self, head):\n        list_ = []\n        temp = head\n        output = temp\n        while head is not None:\n            list_.append(head.val)\n            head = head.next\n\n        for i in range(len(list_)):\n            index = i // 2\n            if i % 2 == 0:\n                temp.next = ListNode(list_[index])\n            else:\n                temp.next = ListNode(list_[-index - 1])\n            temp = temp.next\n\n        try:\n            output = output.next  \n            return output\n        except:\n            return None\n    \n"
                    },
                    {
                        "username": "mskamel",
                        "content": "Why does my code causes a cycle in the linked list:\n\n`\nclass Solution {\n    public void reorderList(ListNode head) {\n        ListNode midNode = midNode(head);\n        Stack<ListNode> lastListNodesStack = new Stack<>();\n        appendNodesToStack(midNode, lastListNodesStack);\n        ListNode current = head;\n        ListNode prev = null;\n        ListNode next = null;\n\n        while (lastListNodesStack.isEmpty() == false) {\n            ListNode lastNode = lastListNodesStack.pop();\n            next = current.next;\n            prev = current;\n            current.next = lastNode;\n            lastNode.next = next;\n            current = next;\n        }\n    }\n\n    ListNode midNode(ListNode head) {\n        ListNode slowPointer = head;\n        ListNode fastPointer = head;\n\n        while (fastPointer != null && fastPointer.next != null) {\n            slowPointer = slowPointer.next;\n            fastPointer = fastPointer.next.next;\n        }\n\n        return slowPointer;\n    }\n\n    void appendNodesToStack(ListNode midNode, Stack<ListNode> stack) {\n        while (midNode != null) {\n            stack.push(midNode);\n            midNode = midNode.next;\n        }\n    }\n}\n`"
                    },
                    {
                        "username": "hafid-hub",
                        "content": "I have the some problem. It take me time to figure out why I have this cycle?\\nDrawing help me to understand  what happen.\\nTake an example:\\n1 ->  2 ->  3 -> 4 -> null\\n- stack has: 4 -> null and  3 -> 4 in reversed order\\n- current is : 1 - > 2 -> 3 -> 4 -> null\\nIn the first iteration:\\n- next is: 2 -> 3 -> 4 -> null-last is 4 -> null\\ncurrent.next = last, has as consequence:\\nhead  = 1 -> 4 -> null\\nnext = 2 -> 3 -> 4  -> null\\nIn other hand, last.next = next has as result:\\n4 -> next\\n4 -> 2 -> 3 -> 4 -> (nut null but the same ListNode)\\nand head: 1 -> |  4 -> 2 -> 3 -> 4 |  -> 2 -> 3 -> 4 -> 2 -> 3 -> 4....\\nI hope that will helpful. And forgive my English! \\n"
                    },
                    {
                        "username": "shahparam1903",
                        "content": "class Solution {\\npublic:\\n    ListNode* reverse(ListNode* head){\\n        if(head==NULL){\\n            return NULL;\\n        }\\n        if(head->next==NULL){\\n            return head;\\n        }\\n        ListNode *cur=head;\\n        ListNode *prev=NULL;\\n        ListNode *forward;\\n        while(cur!=NULL){\\n            forward=cur->next;\\n            cur->next=prev;\\n            prev=cur;\\n            cur=forward;\\n        }\\n        return prev;\\n    }\\n    void reorderList(ListNode* head) {\\n        if(head->next==NULL){\\n            return;\\n        }\\n        ListNode *slow=head;\\n        ListNode *fast=head->next;\\n        while(fast!=NULL){\\n            fast=fast->next;\\n            if(fast){\\n                fast=fast->next;\\n            }\\n            slow=slow->next;\\n        }\\n    ListNode *q=reverse(slow);\\n    ListNode *p=head;\\n    ListNode *r=NULL;\\n    ListNode *s=NULL;\\n    while( q && p ){\\n        r=p->next;\\n        s=q->next;\\n        p->next=q;\\n        q->next=r;\\n        p=r;\\n        q=s;\\n    }\\n    return;\\n    }\\n};  SOMEONE PLZ DEBUG THIS CODE FOR ME.....my logic is find the middle node...reverse it form middle and then adjust the links..."
                    }
                ]
            },
            {
                "id": 1991196,
                "content": [
                    {
                        "username": "yuangaonyc",
                        "content": "Good practice for most of the important techniques of dealing with linked lists, ie. 2 pointer traversing, reversing, merging, ... "
                    },
                    {
                        "username": "MangoTroll34",
                        "content": "This question utilizes the linked list patterns you pick up from doing \\'easy\\' problems. I got stuck on merging the two lists because if you leave the middle node in both lists then you will create a cycle. Continuing until the reversed lists next is null prevents you from adding the second list node when it already exists at the end of the first list. "
                    },
                    {
                        "username": "anin9",
                        "content": "Can someone please help - getting TLE on my code with one of the test cases and can't figure why :( \n\n```\ndef reorderList(self, head):\n        # 1. Find middle of list\n        slow = fast = head\n        while fast and fast.next:\n            slow = slow.next\n            fast = fast.next.next     \n        \n        second = slow.next\n        slow.next = None\n\n        # Reverse the second half\n        current, previous = second, None\n        while current:\n            nextNode = current.next\n            current.next = previous\n            previous = current\n            current = nextNode\n        second = previous\n\n        # Merge both linked lists:\n        node1, node2 = head, second\n        while node1 and node2:\n            nextNode1 = node1.next\n            nextNode2 = node2.next\n\n            node1.next = node2\n            node1 = nextNode1\n\n            node2.next = node1\n            node2 = nextNode2\n```"
                    },
                    {
                        "username": "sufiyan052",
                        "content": "Here, Need to re-arrange list values. \\nJust draw the outcome in paper and try to see what need to do first and then focus on how to do this.\\n\\n# Approach\\n1 : Find middle of List.\\n2 : Reverse second half.\\n3 : Now take two pointer first & second.\\n4 : Move both pointer one by one & add value accordingly. "
                    },
                    {
                        "username": "Ravitejai1",
                        "content": "I am getting a runtime error that member access within misaligned address ,But when i run it on online compiler i got the desired output, can any  one help me with this"
                    },
                    {
                        "username": "user5228Qg",
                        "content": "Something wrong with the test cases. Always returns the original list no matter what i do. Even if I returned None, it still outputs the original list..."
                    },
                    {
                        "username": "User147077",
                        "content": "this is because you are not supposed to return anything, you\\'re supposed to modify the list in place. so the test cases are printing the list based on the head that they gave your function, not based on the head that you\\'re returning"
                    },
                    {
                        "username": "Arun_A",
                        "content": "Can anyone tell why this is not working for the test case : [1,4,3,2] ??\\n\\nclass Solution {\\npublic:\\n    void reorderList(ListNode* head) {\\n        stack <ListNode*> st;\\n        queue <ListNode*> v;\\n        ListNode* temp = head;\\n        while(temp)\\n        {\\n            v.push(temp);\\n            temp = temp->next;\\n            if(temp!=NULL)\\n            {\\n                st.push(temp);\\n                temp = temp->next;\\n            }\\n        }\\n        head = v.front();\\n        v.pop();\\n\\n        temp = head;\\n        while(!st.empty() && !v.empty())\\n        {\\n            temp->next = st.top();\\n            st.pop();\\n            temp = temp->next;\\n\\n            temp->next = v.front();\\n            v.pop();\\n            temp = temp->next;\\n        }\\n\\n        if(!st.empty())\\n        {\\n            temp->next = st.top();\\n            temp = temp->next;\\n            st.pop();\\n        }\\n        temp -> next = NULL;\\n    }\\n};\\n"
                    },
                    {
                        "username": "ZoeZzzy",
                        "content": "Could anyone help? Why is this wrong \n\nclass Solution(object):\n\n    def reorderList(self, head):\n        list_ = []\n        temp = head\n        output = temp\n        while head is not None:\n            list_.append(head.val)\n            head = head.next\n\n        for i in range(len(list_)):\n            index = i // 2\n            if i % 2 == 0:\n                temp.next = ListNode(list_[index])\n            else:\n                temp.next = ListNode(list_[-index - 1])\n            temp = temp.next\n\n        try:\n            output = output.next  \n            return output\n        except:\n            return None\n    \n"
                    },
                    {
                        "username": "mskamel",
                        "content": "Why does my code causes a cycle in the linked list:\n\n`\nclass Solution {\n    public void reorderList(ListNode head) {\n        ListNode midNode = midNode(head);\n        Stack<ListNode> lastListNodesStack = new Stack<>();\n        appendNodesToStack(midNode, lastListNodesStack);\n        ListNode current = head;\n        ListNode prev = null;\n        ListNode next = null;\n\n        while (lastListNodesStack.isEmpty() == false) {\n            ListNode lastNode = lastListNodesStack.pop();\n            next = current.next;\n            prev = current;\n            current.next = lastNode;\n            lastNode.next = next;\n            current = next;\n        }\n    }\n\n    ListNode midNode(ListNode head) {\n        ListNode slowPointer = head;\n        ListNode fastPointer = head;\n\n        while (fastPointer != null && fastPointer.next != null) {\n            slowPointer = slowPointer.next;\n            fastPointer = fastPointer.next.next;\n        }\n\n        return slowPointer;\n    }\n\n    void appendNodesToStack(ListNode midNode, Stack<ListNode> stack) {\n        while (midNode != null) {\n            stack.push(midNode);\n            midNode = midNode.next;\n        }\n    }\n}\n`"
                    },
                    {
                        "username": "hafid-hub",
                        "content": "I have the some problem. It take me time to figure out why I have this cycle?\\nDrawing help me to understand  what happen.\\nTake an example:\\n1 ->  2 ->  3 -> 4 -> null\\n- stack has: 4 -> null and  3 -> 4 in reversed order\\n- current is : 1 - > 2 -> 3 -> 4 -> null\\nIn the first iteration:\\n- next is: 2 -> 3 -> 4 -> null-last is 4 -> null\\ncurrent.next = last, has as consequence:\\nhead  = 1 -> 4 -> null\\nnext = 2 -> 3 -> 4  -> null\\nIn other hand, last.next = next has as result:\\n4 -> next\\n4 -> 2 -> 3 -> 4 -> (nut null but the same ListNode)\\nand head: 1 -> |  4 -> 2 -> 3 -> 4 |  -> 2 -> 3 -> 4 -> 2 -> 3 -> 4....\\nI hope that will helpful. And forgive my English! \\n"
                    },
                    {
                        "username": "shahparam1903",
                        "content": "class Solution {\\npublic:\\n    ListNode* reverse(ListNode* head){\\n        if(head==NULL){\\n            return NULL;\\n        }\\n        if(head->next==NULL){\\n            return head;\\n        }\\n        ListNode *cur=head;\\n        ListNode *prev=NULL;\\n        ListNode *forward;\\n        while(cur!=NULL){\\n            forward=cur->next;\\n            cur->next=prev;\\n            prev=cur;\\n            cur=forward;\\n        }\\n        return prev;\\n    }\\n    void reorderList(ListNode* head) {\\n        if(head->next==NULL){\\n            return;\\n        }\\n        ListNode *slow=head;\\n        ListNode *fast=head->next;\\n        while(fast!=NULL){\\n            fast=fast->next;\\n            if(fast){\\n                fast=fast->next;\\n            }\\n            slow=slow->next;\\n        }\\n    ListNode *q=reverse(slow);\\n    ListNode *p=head;\\n    ListNode *r=NULL;\\n    ListNode *s=NULL;\\n    while( q && p ){\\n        r=p->next;\\n        s=q->next;\\n        p->next=q;\\n        q->next=r;\\n        p=r;\\n        q=s;\\n    }\\n    return;\\n    }\\n};  SOMEONE PLZ DEBUG THIS CODE FOR ME.....my logic is find the middle node...reverse it form middle and then adjust the links..."
                    }
                ]
            },
            {
                "id": 1990050,
                "content": [
                    {
                        "username": "yuangaonyc",
                        "content": "Good practice for most of the important techniques of dealing with linked lists, ie. 2 pointer traversing, reversing, merging, ... "
                    },
                    {
                        "username": "MangoTroll34",
                        "content": "This question utilizes the linked list patterns you pick up from doing \\'easy\\' problems. I got stuck on merging the two lists because if you leave the middle node in both lists then you will create a cycle. Continuing until the reversed lists next is null prevents you from adding the second list node when it already exists at the end of the first list. "
                    },
                    {
                        "username": "anin9",
                        "content": "Can someone please help - getting TLE on my code with one of the test cases and can't figure why :( \n\n```\ndef reorderList(self, head):\n        # 1. Find middle of list\n        slow = fast = head\n        while fast and fast.next:\n            slow = slow.next\n            fast = fast.next.next     \n        \n        second = slow.next\n        slow.next = None\n\n        # Reverse the second half\n        current, previous = second, None\n        while current:\n            nextNode = current.next\n            current.next = previous\n            previous = current\n            current = nextNode\n        second = previous\n\n        # Merge both linked lists:\n        node1, node2 = head, second\n        while node1 and node2:\n            nextNode1 = node1.next\n            nextNode2 = node2.next\n\n            node1.next = node2\n            node1 = nextNode1\n\n            node2.next = node1\n            node2 = nextNode2\n```"
                    },
                    {
                        "username": "sufiyan052",
                        "content": "Here, Need to re-arrange list values. \\nJust draw the outcome in paper and try to see what need to do first and then focus on how to do this.\\n\\n# Approach\\n1 : Find middle of List.\\n2 : Reverse second half.\\n3 : Now take two pointer first & second.\\n4 : Move both pointer one by one & add value accordingly. "
                    },
                    {
                        "username": "Ravitejai1",
                        "content": "I am getting a runtime error that member access within misaligned address ,But when i run it on online compiler i got the desired output, can any  one help me with this"
                    },
                    {
                        "username": "user5228Qg",
                        "content": "Something wrong with the test cases. Always returns the original list no matter what i do. Even if I returned None, it still outputs the original list..."
                    },
                    {
                        "username": "User147077",
                        "content": "this is because you are not supposed to return anything, you\\'re supposed to modify the list in place. so the test cases are printing the list based on the head that they gave your function, not based on the head that you\\'re returning"
                    },
                    {
                        "username": "Arun_A",
                        "content": "Can anyone tell why this is not working for the test case : [1,4,3,2] ??\\n\\nclass Solution {\\npublic:\\n    void reorderList(ListNode* head) {\\n        stack <ListNode*> st;\\n        queue <ListNode*> v;\\n        ListNode* temp = head;\\n        while(temp)\\n        {\\n            v.push(temp);\\n            temp = temp->next;\\n            if(temp!=NULL)\\n            {\\n                st.push(temp);\\n                temp = temp->next;\\n            }\\n        }\\n        head = v.front();\\n        v.pop();\\n\\n        temp = head;\\n        while(!st.empty() && !v.empty())\\n        {\\n            temp->next = st.top();\\n            st.pop();\\n            temp = temp->next;\\n\\n            temp->next = v.front();\\n            v.pop();\\n            temp = temp->next;\\n        }\\n\\n        if(!st.empty())\\n        {\\n            temp->next = st.top();\\n            temp = temp->next;\\n            st.pop();\\n        }\\n        temp -> next = NULL;\\n    }\\n};\\n"
                    },
                    {
                        "username": "ZoeZzzy",
                        "content": "Could anyone help? Why is this wrong \n\nclass Solution(object):\n\n    def reorderList(self, head):\n        list_ = []\n        temp = head\n        output = temp\n        while head is not None:\n            list_.append(head.val)\n            head = head.next\n\n        for i in range(len(list_)):\n            index = i // 2\n            if i % 2 == 0:\n                temp.next = ListNode(list_[index])\n            else:\n                temp.next = ListNode(list_[-index - 1])\n            temp = temp.next\n\n        try:\n            output = output.next  \n            return output\n        except:\n            return None\n    \n"
                    },
                    {
                        "username": "mskamel",
                        "content": "Why does my code causes a cycle in the linked list:\n\n`\nclass Solution {\n    public void reorderList(ListNode head) {\n        ListNode midNode = midNode(head);\n        Stack<ListNode> lastListNodesStack = new Stack<>();\n        appendNodesToStack(midNode, lastListNodesStack);\n        ListNode current = head;\n        ListNode prev = null;\n        ListNode next = null;\n\n        while (lastListNodesStack.isEmpty() == false) {\n            ListNode lastNode = lastListNodesStack.pop();\n            next = current.next;\n            prev = current;\n            current.next = lastNode;\n            lastNode.next = next;\n            current = next;\n        }\n    }\n\n    ListNode midNode(ListNode head) {\n        ListNode slowPointer = head;\n        ListNode fastPointer = head;\n\n        while (fastPointer != null && fastPointer.next != null) {\n            slowPointer = slowPointer.next;\n            fastPointer = fastPointer.next.next;\n        }\n\n        return slowPointer;\n    }\n\n    void appendNodesToStack(ListNode midNode, Stack<ListNode> stack) {\n        while (midNode != null) {\n            stack.push(midNode);\n            midNode = midNode.next;\n        }\n    }\n}\n`"
                    },
                    {
                        "username": "hafid-hub",
                        "content": "I have the some problem. It take me time to figure out why I have this cycle?\\nDrawing help me to understand  what happen.\\nTake an example:\\n1 ->  2 ->  3 -> 4 -> null\\n- stack has: 4 -> null and  3 -> 4 in reversed order\\n- current is : 1 - > 2 -> 3 -> 4 -> null\\nIn the first iteration:\\n- next is: 2 -> 3 -> 4 -> null-last is 4 -> null\\ncurrent.next = last, has as consequence:\\nhead  = 1 -> 4 -> null\\nnext = 2 -> 3 -> 4  -> null\\nIn other hand, last.next = next has as result:\\n4 -> next\\n4 -> 2 -> 3 -> 4 -> (nut null but the same ListNode)\\nand head: 1 -> |  4 -> 2 -> 3 -> 4 |  -> 2 -> 3 -> 4 -> 2 -> 3 -> 4....\\nI hope that will helpful. And forgive my English! \\n"
                    },
                    {
                        "username": "shahparam1903",
                        "content": "class Solution {\\npublic:\\n    ListNode* reverse(ListNode* head){\\n        if(head==NULL){\\n            return NULL;\\n        }\\n        if(head->next==NULL){\\n            return head;\\n        }\\n        ListNode *cur=head;\\n        ListNode *prev=NULL;\\n        ListNode *forward;\\n        while(cur!=NULL){\\n            forward=cur->next;\\n            cur->next=prev;\\n            prev=cur;\\n            cur=forward;\\n        }\\n        return prev;\\n    }\\n    void reorderList(ListNode* head) {\\n        if(head->next==NULL){\\n            return;\\n        }\\n        ListNode *slow=head;\\n        ListNode *fast=head->next;\\n        while(fast!=NULL){\\n            fast=fast->next;\\n            if(fast){\\n                fast=fast->next;\\n            }\\n            slow=slow->next;\\n        }\\n    ListNode *q=reverse(slow);\\n    ListNode *p=head;\\n    ListNode *r=NULL;\\n    ListNode *s=NULL;\\n    while( q && p ){\\n        r=p->next;\\n        s=q->next;\\n        p->next=q;\\n        q->next=r;\\n        p=r;\\n        q=s;\\n    }\\n    return;\\n    }\\n};  SOMEONE PLZ DEBUG THIS CODE FOR ME.....my logic is find the middle node...reverse it form middle and then adjust the links..."
                    }
                ]
            },
            {
                "id": 1970861,
                "content": [
                    {
                        "username": "yuangaonyc",
                        "content": "Good practice for most of the important techniques of dealing with linked lists, ie. 2 pointer traversing, reversing, merging, ... "
                    },
                    {
                        "username": "MangoTroll34",
                        "content": "This question utilizes the linked list patterns you pick up from doing \\'easy\\' problems. I got stuck on merging the two lists because if you leave the middle node in both lists then you will create a cycle. Continuing until the reversed lists next is null prevents you from adding the second list node when it already exists at the end of the first list. "
                    },
                    {
                        "username": "anin9",
                        "content": "Can someone please help - getting TLE on my code with one of the test cases and can't figure why :( \n\n```\ndef reorderList(self, head):\n        # 1. Find middle of list\n        slow = fast = head\n        while fast and fast.next:\n            slow = slow.next\n            fast = fast.next.next     \n        \n        second = slow.next\n        slow.next = None\n\n        # Reverse the second half\n        current, previous = second, None\n        while current:\n            nextNode = current.next\n            current.next = previous\n            previous = current\n            current = nextNode\n        second = previous\n\n        # Merge both linked lists:\n        node1, node2 = head, second\n        while node1 and node2:\n            nextNode1 = node1.next\n            nextNode2 = node2.next\n\n            node1.next = node2\n            node1 = nextNode1\n\n            node2.next = node1\n            node2 = nextNode2\n```"
                    },
                    {
                        "username": "sufiyan052",
                        "content": "Here, Need to re-arrange list values. \\nJust draw the outcome in paper and try to see what need to do first and then focus on how to do this.\\n\\n# Approach\\n1 : Find middle of List.\\n2 : Reverse second half.\\n3 : Now take two pointer first & second.\\n4 : Move both pointer one by one & add value accordingly. "
                    },
                    {
                        "username": "Ravitejai1",
                        "content": "I am getting a runtime error that member access within misaligned address ,But when i run it on online compiler i got the desired output, can any  one help me with this"
                    },
                    {
                        "username": "user5228Qg",
                        "content": "Something wrong with the test cases. Always returns the original list no matter what i do. Even if I returned None, it still outputs the original list..."
                    },
                    {
                        "username": "User147077",
                        "content": "this is because you are not supposed to return anything, you\\'re supposed to modify the list in place. so the test cases are printing the list based on the head that they gave your function, not based on the head that you\\'re returning"
                    },
                    {
                        "username": "Arun_A",
                        "content": "Can anyone tell why this is not working for the test case : [1,4,3,2] ??\\n\\nclass Solution {\\npublic:\\n    void reorderList(ListNode* head) {\\n        stack <ListNode*> st;\\n        queue <ListNode*> v;\\n        ListNode* temp = head;\\n        while(temp)\\n        {\\n            v.push(temp);\\n            temp = temp->next;\\n            if(temp!=NULL)\\n            {\\n                st.push(temp);\\n                temp = temp->next;\\n            }\\n        }\\n        head = v.front();\\n        v.pop();\\n\\n        temp = head;\\n        while(!st.empty() && !v.empty())\\n        {\\n            temp->next = st.top();\\n            st.pop();\\n            temp = temp->next;\\n\\n            temp->next = v.front();\\n            v.pop();\\n            temp = temp->next;\\n        }\\n\\n        if(!st.empty())\\n        {\\n            temp->next = st.top();\\n            temp = temp->next;\\n            st.pop();\\n        }\\n        temp -> next = NULL;\\n    }\\n};\\n"
                    },
                    {
                        "username": "ZoeZzzy",
                        "content": "Could anyone help? Why is this wrong \n\nclass Solution(object):\n\n    def reorderList(self, head):\n        list_ = []\n        temp = head\n        output = temp\n        while head is not None:\n            list_.append(head.val)\n            head = head.next\n\n        for i in range(len(list_)):\n            index = i // 2\n            if i % 2 == 0:\n                temp.next = ListNode(list_[index])\n            else:\n                temp.next = ListNode(list_[-index - 1])\n            temp = temp.next\n\n        try:\n            output = output.next  \n            return output\n        except:\n            return None\n    \n"
                    },
                    {
                        "username": "mskamel",
                        "content": "Why does my code causes a cycle in the linked list:\n\n`\nclass Solution {\n    public void reorderList(ListNode head) {\n        ListNode midNode = midNode(head);\n        Stack<ListNode> lastListNodesStack = new Stack<>();\n        appendNodesToStack(midNode, lastListNodesStack);\n        ListNode current = head;\n        ListNode prev = null;\n        ListNode next = null;\n\n        while (lastListNodesStack.isEmpty() == false) {\n            ListNode lastNode = lastListNodesStack.pop();\n            next = current.next;\n            prev = current;\n            current.next = lastNode;\n            lastNode.next = next;\n            current = next;\n        }\n    }\n\n    ListNode midNode(ListNode head) {\n        ListNode slowPointer = head;\n        ListNode fastPointer = head;\n\n        while (fastPointer != null && fastPointer.next != null) {\n            slowPointer = slowPointer.next;\n            fastPointer = fastPointer.next.next;\n        }\n\n        return slowPointer;\n    }\n\n    void appendNodesToStack(ListNode midNode, Stack<ListNode> stack) {\n        while (midNode != null) {\n            stack.push(midNode);\n            midNode = midNode.next;\n        }\n    }\n}\n`"
                    },
                    {
                        "username": "hafid-hub",
                        "content": "I have the some problem. It take me time to figure out why I have this cycle?\\nDrawing help me to understand  what happen.\\nTake an example:\\n1 ->  2 ->  3 -> 4 -> null\\n- stack has: 4 -> null and  3 -> 4 in reversed order\\n- current is : 1 - > 2 -> 3 -> 4 -> null\\nIn the first iteration:\\n- next is: 2 -> 3 -> 4 -> null-last is 4 -> null\\ncurrent.next = last, has as consequence:\\nhead  = 1 -> 4 -> null\\nnext = 2 -> 3 -> 4  -> null\\nIn other hand, last.next = next has as result:\\n4 -> next\\n4 -> 2 -> 3 -> 4 -> (nut null but the same ListNode)\\nand head: 1 -> |  4 -> 2 -> 3 -> 4 |  -> 2 -> 3 -> 4 -> 2 -> 3 -> 4....\\nI hope that will helpful. And forgive my English! \\n"
                    },
                    {
                        "username": "shahparam1903",
                        "content": "class Solution {\\npublic:\\n    ListNode* reverse(ListNode* head){\\n        if(head==NULL){\\n            return NULL;\\n        }\\n        if(head->next==NULL){\\n            return head;\\n        }\\n        ListNode *cur=head;\\n        ListNode *prev=NULL;\\n        ListNode *forward;\\n        while(cur!=NULL){\\n            forward=cur->next;\\n            cur->next=prev;\\n            prev=cur;\\n            cur=forward;\\n        }\\n        return prev;\\n    }\\n    void reorderList(ListNode* head) {\\n        if(head->next==NULL){\\n            return;\\n        }\\n        ListNode *slow=head;\\n        ListNode *fast=head->next;\\n        while(fast!=NULL){\\n            fast=fast->next;\\n            if(fast){\\n                fast=fast->next;\\n            }\\n            slow=slow->next;\\n        }\\n    ListNode *q=reverse(slow);\\n    ListNode *p=head;\\n    ListNode *r=NULL;\\n    ListNode *s=NULL;\\n    while( q && p ){\\n        r=p->next;\\n        s=q->next;\\n        p->next=q;\\n        q->next=r;\\n        p=r;\\n        q=s;\\n    }\\n    return;\\n    }\\n};  SOMEONE PLZ DEBUG THIS CODE FOR ME.....my logic is find the middle node...reverse it form middle and then adjust the links..."
                    }
                ]
            },
            {
                "id": 1963048,
                "content": [
                    {
                        "username": "yuangaonyc",
                        "content": "Good practice for most of the important techniques of dealing with linked lists, ie. 2 pointer traversing, reversing, merging, ... "
                    },
                    {
                        "username": "MangoTroll34",
                        "content": "This question utilizes the linked list patterns you pick up from doing \\'easy\\' problems. I got stuck on merging the two lists because if you leave the middle node in both lists then you will create a cycle. Continuing until the reversed lists next is null prevents you from adding the second list node when it already exists at the end of the first list. "
                    },
                    {
                        "username": "anin9",
                        "content": "Can someone please help - getting TLE on my code with one of the test cases and can't figure why :( \n\n```\ndef reorderList(self, head):\n        # 1. Find middle of list\n        slow = fast = head\n        while fast and fast.next:\n            slow = slow.next\n            fast = fast.next.next     \n        \n        second = slow.next\n        slow.next = None\n\n        # Reverse the second half\n        current, previous = second, None\n        while current:\n            nextNode = current.next\n            current.next = previous\n            previous = current\n            current = nextNode\n        second = previous\n\n        # Merge both linked lists:\n        node1, node2 = head, second\n        while node1 and node2:\n            nextNode1 = node1.next\n            nextNode2 = node2.next\n\n            node1.next = node2\n            node1 = nextNode1\n\n            node2.next = node1\n            node2 = nextNode2\n```"
                    },
                    {
                        "username": "sufiyan052",
                        "content": "Here, Need to re-arrange list values. \\nJust draw the outcome in paper and try to see what need to do first and then focus on how to do this.\\n\\n# Approach\\n1 : Find middle of List.\\n2 : Reverse second half.\\n3 : Now take two pointer first & second.\\n4 : Move both pointer one by one & add value accordingly. "
                    },
                    {
                        "username": "Ravitejai1",
                        "content": "I am getting a runtime error that member access within misaligned address ,But when i run it on online compiler i got the desired output, can any  one help me with this"
                    },
                    {
                        "username": "user5228Qg",
                        "content": "Something wrong with the test cases. Always returns the original list no matter what i do. Even if I returned None, it still outputs the original list..."
                    },
                    {
                        "username": "User147077",
                        "content": "this is because you are not supposed to return anything, you\\'re supposed to modify the list in place. so the test cases are printing the list based on the head that they gave your function, not based on the head that you\\'re returning"
                    },
                    {
                        "username": "Arun_A",
                        "content": "Can anyone tell why this is not working for the test case : [1,4,3,2] ??\\n\\nclass Solution {\\npublic:\\n    void reorderList(ListNode* head) {\\n        stack <ListNode*> st;\\n        queue <ListNode*> v;\\n        ListNode* temp = head;\\n        while(temp)\\n        {\\n            v.push(temp);\\n            temp = temp->next;\\n            if(temp!=NULL)\\n            {\\n                st.push(temp);\\n                temp = temp->next;\\n            }\\n        }\\n        head = v.front();\\n        v.pop();\\n\\n        temp = head;\\n        while(!st.empty() && !v.empty())\\n        {\\n            temp->next = st.top();\\n            st.pop();\\n            temp = temp->next;\\n\\n            temp->next = v.front();\\n            v.pop();\\n            temp = temp->next;\\n        }\\n\\n        if(!st.empty())\\n        {\\n            temp->next = st.top();\\n            temp = temp->next;\\n            st.pop();\\n        }\\n        temp -> next = NULL;\\n    }\\n};\\n"
                    },
                    {
                        "username": "ZoeZzzy",
                        "content": "Could anyone help? Why is this wrong \n\nclass Solution(object):\n\n    def reorderList(self, head):\n        list_ = []\n        temp = head\n        output = temp\n        while head is not None:\n            list_.append(head.val)\n            head = head.next\n\n        for i in range(len(list_)):\n            index = i // 2\n            if i % 2 == 0:\n                temp.next = ListNode(list_[index])\n            else:\n                temp.next = ListNode(list_[-index - 1])\n            temp = temp.next\n\n        try:\n            output = output.next  \n            return output\n        except:\n            return None\n    \n"
                    },
                    {
                        "username": "mskamel",
                        "content": "Why does my code causes a cycle in the linked list:\n\n`\nclass Solution {\n    public void reorderList(ListNode head) {\n        ListNode midNode = midNode(head);\n        Stack<ListNode> lastListNodesStack = new Stack<>();\n        appendNodesToStack(midNode, lastListNodesStack);\n        ListNode current = head;\n        ListNode prev = null;\n        ListNode next = null;\n\n        while (lastListNodesStack.isEmpty() == false) {\n            ListNode lastNode = lastListNodesStack.pop();\n            next = current.next;\n            prev = current;\n            current.next = lastNode;\n            lastNode.next = next;\n            current = next;\n        }\n    }\n\n    ListNode midNode(ListNode head) {\n        ListNode slowPointer = head;\n        ListNode fastPointer = head;\n\n        while (fastPointer != null && fastPointer.next != null) {\n            slowPointer = slowPointer.next;\n            fastPointer = fastPointer.next.next;\n        }\n\n        return slowPointer;\n    }\n\n    void appendNodesToStack(ListNode midNode, Stack<ListNode> stack) {\n        while (midNode != null) {\n            stack.push(midNode);\n            midNode = midNode.next;\n        }\n    }\n}\n`"
                    },
                    {
                        "username": "hafid-hub",
                        "content": "I have the some problem. It take me time to figure out why I have this cycle?\\nDrawing help me to understand  what happen.\\nTake an example:\\n1 ->  2 ->  3 -> 4 -> null\\n- stack has: 4 -> null and  3 -> 4 in reversed order\\n- current is : 1 - > 2 -> 3 -> 4 -> null\\nIn the first iteration:\\n- next is: 2 -> 3 -> 4 -> null-last is 4 -> null\\ncurrent.next = last, has as consequence:\\nhead  = 1 -> 4 -> null\\nnext = 2 -> 3 -> 4  -> null\\nIn other hand, last.next = next has as result:\\n4 -> next\\n4 -> 2 -> 3 -> 4 -> (nut null but the same ListNode)\\nand head: 1 -> |  4 -> 2 -> 3 -> 4 |  -> 2 -> 3 -> 4 -> 2 -> 3 -> 4....\\nI hope that will helpful. And forgive my English! \\n"
                    },
                    {
                        "username": "shahparam1903",
                        "content": "class Solution {\\npublic:\\n    ListNode* reverse(ListNode* head){\\n        if(head==NULL){\\n            return NULL;\\n        }\\n        if(head->next==NULL){\\n            return head;\\n        }\\n        ListNode *cur=head;\\n        ListNode *prev=NULL;\\n        ListNode *forward;\\n        while(cur!=NULL){\\n            forward=cur->next;\\n            cur->next=prev;\\n            prev=cur;\\n            cur=forward;\\n        }\\n        return prev;\\n    }\\n    void reorderList(ListNode* head) {\\n        if(head->next==NULL){\\n            return;\\n        }\\n        ListNode *slow=head;\\n        ListNode *fast=head->next;\\n        while(fast!=NULL){\\n            fast=fast->next;\\n            if(fast){\\n                fast=fast->next;\\n            }\\n            slow=slow->next;\\n        }\\n    ListNode *q=reverse(slow);\\n    ListNode *p=head;\\n    ListNode *r=NULL;\\n    ListNode *s=NULL;\\n    while( q && p ){\\n        r=p->next;\\n        s=q->next;\\n        p->next=q;\\n        q->next=r;\\n        p=r;\\n        q=s;\\n    }\\n    return;\\n    }\\n};  SOMEONE PLZ DEBUG THIS CODE FOR ME.....my logic is find the middle node...reverse it form middle and then adjust the links..."
                    }
                ]
            },
            {
                "id": 1913242,
                "content": [
                    {
                        "username": "yuangaonyc",
                        "content": "Good practice for most of the important techniques of dealing with linked lists, ie. 2 pointer traversing, reversing, merging, ... "
                    },
                    {
                        "username": "MangoTroll34",
                        "content": "This question utilizes the linked list patterns you pick up from doing \\'easy\\' problems. I got stuck on merging the two lists because if you leave the middle node in both lists then you will create a cycle. Continuing until the reversed lists next is null prevents you from adding the second list node when it already exists at the end of the first list. "
                    },
                    {
                        "username": "anin9",
                        "content": "Can someone please help - getting TLE on my code with one of the test cases and can't figure why :( \n\n```\ndef reorderList(self, head):\n        # 1. Find middle of list\n        slow = fast = head\n        while fast and fast.next:\n            slow = slow.next\n            fast = fast.next.next     \n        \n        second = slow.next\n        slow.next = None\n\n        # Reverse the second half\n        current, previous = second, None\n        while current:\n            nextNode = current.next\n            current.next = previous\n            previous = current\n            current = nextNode\n        second = previous\n\n        # Merge both linked lists:\n        node1, node2 = head, second\n        while node1 and node2:\n            nextNode1 = node1.next\n            nextNode2 = node2.next\n\n            node1.next = node2\n            node1 = nextNode1\n\n            node2.next = node1\n            node2 = nextNode2\n```"
                    },
                    {
                        "username": "sufiyan052",
                        "content": "Here, Need to re-arrange list values. \\nJust draw the outcome in paper and try to see what need to do first and then focus on how to do this.\\n\\n# Approach\\n1 : Find middle of List.\\n2 : Reverse second half.\\n3 : Now take two pointer first & second.\\n4 : Move both pointer one by one & add value accordingly. "
                    },
                    {
                        "username": "Ravitejai1",
                        "content": "I am getting a runtime error that member access within misaligned address ,But when i run it on online compiler i got the desired output, can any  one help me with this"
                    },
                    {
                        "username": "user5228Qg",
                        "content": "Something wrong with the test cases. Always returns the original list no matter what i do. Even if I returned None, it still outputs the original list..."
                    },
                    {
                        "username": "User147077",
                        "content": "this is because you are not supposed to return anything, you\\'re supposed to modify the list in place. so the test cases are printing the list based on the head that they gave your function, not based on the head that you\\'re returning"
                    },
                    {
                        "username": "Arun_A",
                        "content": "Can anyone tell why this is not working for the test case : [1,4,3,2] ??\\n\\nclass Solution {\\npublic:\\n    void reorderList(ListNode* head) {\\n        stack <ListNode*> st;\\n        queue <ListNode*> v;\\n        ListNode* temp = head;\\n        while(temp)\\n        {\\n            v.push(temp);\\n            temp = temp->next;\\n            if(temp!=NULL)\\n            {\\n                st.push(temp);\\n                temp = temp->next;\\n            }\\n        }\\n        head = v.front();\\n        v.pop();\\n\\n        temp = head;\\n        while(!st.empty() && !v.empty())\\n        {\\n            temp->next = st.top();\\n            st.pop();\\n            temp = temp->next;\\n\\n            temp->next = v.front();\\n            v.pop();\\n            temp = temp->next;\\n        }\\n\\n        if(!st.empty())\\n        {\\n            temp->next = st.top();\\n            temp = temp->next;\\n            st.pop();\\n        }\\n        temp -> next = NULL;\\n    }\\n};\\n"
                    },
                    {
                        "username": "ZoeZzzy",
                        "content": "Could anyone help? Why is this wrong \n\nclass Solution(object):\n\n    def reorderList(self, head):\n        list_ = []\n        temp = head\n        output = temp\n        while head is not None:\n            list_.append(head.val)\n            head = head.next\n\n        for i in range(len(list_)):\n            index = i // 2\n            if i % 2 == 0:\n                temp.next = ListNode(list_[index])\n            else:\n                temp.next = ListNode(list_[-index - 1])\n            temp = temp.next\n\n        try:\n            output = output.next  \n            return output\n        except:\n            return None\n    \n"
                    },
                    {
                        "username": "mskamel",
                        "content": "Why does my code causes a cycle in the linked list:\n\n`\nclass Solution {\n    public void reorderList(ListNode head) {\n        ListNode midNode = midNode(head);\n        Stack<ListNode> lastListNodesStack = new Stack<>();\n        appendNodesToStack(midNode, lastListNodesStack);\n        ListNode current = head;\n        ListNode prev = null;\n        ListNode next = null;\n\n        while (lastListNodesStack.isEmpty() == false) {\n            ListNode lastNode = lastListNodesStack.pop();\n            next = current.next;\n            prev = current;\n            current.next = lastNode;\n            lastNode.next = next;\n            current = next;\n        }\n    }\n\n    ListNode midNode(ListNode head) {\n        ListNode slowPointer = head;\n        ListNode fastPointer = head;\n\n        while (fastPointer != null && fastPointer.next != null) {\n            slowPointer = slowPointer.next;\n            fastPointer = fastPointer.next.next;\n        }\n\n        return slowPointer;\n    }\n\n    void appendNodesToStack(ListNode midNode, Stack<ListNode> stack) {\n        while (midNode != null) {\n            stack.push(midNode);\n            midNode = midNode.next;\n        }\n    }\n}\n`"
                    },
                    {
                        "username": "hafid-hub",
                        "content": "I have the some problem. It take me time to figure out why I have this cycle?\\nDrawing help me to understand  what happen.\\nTake an example:\\n1 ->  2 ->  3 -> 4 -> null\\n- stack has: 4 -> null and  3 -> 4 in reversed order\\n- current is : 1 - > 2 -> 3 -> 4 -> null\\nIn the first iteration:\\n- next is: 2 -> 3 -> 4 -> null-last is 4 -> null\\ncurrent.next = last, has as consequence:\\nhead  = 1 -> 4 -> null\\nnext = 2 -> 3 -> 4  -> null\\nIn other hand, last.next = next has as result:\\n4 -> next\\n4 -> 2 -> 3 -> 4 -> (nut null but the same ListNode)\\nand head: 1 -> |  4 -> 2 -> 3 -> 4 |  -> 2 -> 3 -> 4 -> 2 -> 3 -> 4....\\nI hope that will helpful. And forgive my English! \\n"
                    },
                    {
                        "username": "shahparam1903",
                        "content": "class Solution {\\npublic:\\n    ListNode* reverse(ListNode* head){\\n        if(head==NULL){\\n            return NULL;\\n        }\\n        if(head->next==NULL){\\n            return head;\\n        }\\n        ListNode *cur=head;\\n        ListNode *prev=NULL;\\n        ListNode *forward;\\n        while(cur!=NULL){\\n            forward=cur->next;\\n            cur->next=prev;\\n            prev=cur;\\n            cur=forward;\\n        }\\n        return prev;\\n    }\\n    void reorderList(ListNode* head) {\\n        if(head->next==NULL){\\n            return;\\n        }\\n        ListNode *slow=head;\\n        ListNode *fast=head->next;\\n        while(fast!=NULL){\\n            fast=fast->next;\\n            if(fast){\\n                fast=fast->next;\\n            }\\n            slow=slow->next;\\n        }\\n    ListNode *q=reverse(slow);\\n    ListNode *p=head;\\n    ListNode *r=NULL;\\n    ListNode *s=NULL;\\n    while( q && p ){\\n        r=p->next;\\n        s=q->next;\\n        p->next=q;\\n        q->next=r;\\n        p=r;\\n        q=s;\\n    }\\n    return;\\n    }\\n};  SOMEONE PLZ DEBUG THIS CODE FOR ME.....my logic is find the middle node...reverse it form middle and then adjust the links..."
                    }
                ]
            },
            {
                "id": 1909305,
                "content": [
                    {
                        "username": "ankurmaurya08",
                        "content": "1 .  Put all elements  of LL in queue except first element\\n2 .  Then pop element from back and put to LL\\n3 .  Now pop element from start and put to LL\\n4 .  Repeat 2&3 till queue is empty."
                    },
                    {
                        "username": "hafid-hub",
                        "content": "Good idea but we can do better with constant space."
                    },
                    {
                        "username": "Narasimha-png",
                        "content": "When we add elements into list and then by removing and last it\\'s my intution but it came error as cycle formed\\nhere is code\\n\\nclass Solution {\\n    public void reorderList(ListNode head) {\\n        List<ListNode> res=new ArrayList<ListNode>();\\n        ListNode head1=head.next;\\n        while(head1!=null){\\n            res.add(head1);\\n            head1=head1.next;\\n        }\\n        int end=res.size()-1;\\n        int start=0;\\n        ListNode head2=head;\\n        ListNode tem=res.get(0);\\n        System.out.println(tem.next.val);\\n        while(start<=end){\\n            if(start==end){\\n                head2.next=res.get(start++);\\n                head2=head2.next;\\n                head.next=null;\\n                continue;\\n            }\\n            head2.next=res.get(end--);\\n            head2=head2.next;\\n            head.next=null;\\n            head2.next=res.get(start++);\\n            head2=head2.next;\\n            head.next=null;\\n        }\\n       \\n        \\n    }\\n}"
                    },
                    {
                        "username": "pandeyharshit122",
                        "content": "hi\\n"
                    },
                    {
                        "username": "DreamZerone",
                        "content": "hello sir\\n"
                    },
                    {
                        "username": "DreamZerone",
                        "content": "hello guys"
                    },
                    {
                        "username": "crazysamurai",
                        "content": "Find middle -> reverse the list after middle -> merge the two lists"
                    },
                    {
                        "username": "Curious_hritik",
                        "content": " `your inline code...your inline code...`\\n ListNode* swapList(ListNode* head) {\\n    //Each time call swapList will set L(n-i) = Li->next\\n    if (head == NULL || head->next == NULL || head->next->next == NULL) \\n        return head;\\n\\n    ListNode* cur = head;\\n    ListNode* tmp = head->next;\\n    ListNode* prev = head->next;\\n    while (tmp->next != NULL) {\\n        prev = tmp;\\n        tmp = tmp->next;\\n    }\\n    prev->next = NULL;\\n    tmp->next = cur->next;\\n    cur->next = tmp;\\n    cur = cur->next->next;\\n    swapList(cur);\\n    return head;\\n}\\n\\nvoid reorderList(ListNode* head) {\\n    swapList(head);\\n   }\\n};"
                    },
                    {
                        "username": "kokatekuntal",
                        "content": "You can do this in Time -> O(N) and Space -> O(1)\\nThere are other easy approaches in Space -> O(N) using deque, sets, etc.\\n\\n1. Break the list in two almost equal halves (first half should be ceil(n/2) length)\\n2. Reverse the second half\\n3. Now merge lists "
                    },
                    {
                        "username": "jd-0312",
                        "content": "How???? example?"
                    },
                    {
                        "username": "vipin1211",
                        "content": "Just changing the first few lines to the below:\\n`dummy = ListNode()\\ndummy.next = head\\nslow = dummy\\nfast = head`\\n\\nResults in \\'\\'NoneType\\' object has no attribute \\'next\\'\\' exception even though the head holds the right answer, can anyone explain why?"
                    },
                    {
                        "username": "hermit_ops000",
                        "content": "I am quite certain my code is correct returning a linked list of [1,4,2,3] as expected for an input of [1,2,3,4].  But when I run my code on the test case, I get an output of [1,2,3,4] instead (which is wrong).  I am really confused as to why.  \\n\\nIf anyone can take a look at my code and share their thoughts I\\'d really appreciate it.  \\n\\n`# Definition for singly-linked list.\\nclass ListNode(object):\\n    def __init__(self, val=0, next=None):\\n        self.val = val\\n        self.next = next\\n\\nclass Solution(object):\\n    def reorderList(self, head):\\n        \"\"\"\\n        :type head: ListNode\\n        :rtype: None Do not return anything, modify head in-place instead.\\n        \"\"\"\\n\\n        nodes_list = []\\n        insert_cnt = 0\\n\\n        # get values of node into list \\n        while head is not None:\\n            nodes_list.append(head.val)\\n            head = head.next \\n        # print (\"nodes_list\", nodes_list)\\n\\n        # even and odd length arrays \\n        if len(nodes_list) % 2 != 0: # odd len array \\n            midpt_index = int(len(nodes_list)/2)+1 # +1 to mimic ceiling  \\n        else: # even len array \\n            midpt_index = len(nodes_list)/2\\n\\n        # print (midpt_index)\\n\\n        lft_arr = nodes_list[0:midpt_index]\\n        rt_arr = nodes_list[midpt_index:len(nodes_list)+1]\\n        rt_arr_rev = list(reversed(rt_arr))\\n\\n        # print (lft_arr, rt_arr_rev)\\n\\n        for i, val in enumerate(rt_arr_rev):\\n            i_insert = i+1 + insert_cnt\\n            lft_arr.insert(i_insert, val)\\n            insert_cnt += 1\\n\\n        # print (\"lft_arr\", lft_arr)\\n\\n        # convert list into LL\\n        newHead = temp = ListNode()\\n\\n        for val in lft_arr:\\n            # print (\"val\", val)\\n            temp.next = ListNode(val)\\n            temp = temp.next\\n\\n        # print (\"newHead.next\", newHead.next.next.next.next.val)\\n        return newHead.next`"
                    },
                    {
                        "username": "hafid-hub",
                        "content": "You don\\'t need  to return any thing. \\nYou change the values, and it is what the problem ask for.\\nRead again carefully the problem. "
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/8N_L_c71avU"
                    }
                ]
            },
            {
                "id": 1884243,
                "content": [
                    {
                        "username": "ankurmaurya08",
                        "content": "1 .  Put all elements  of LL in queue except first element\\n2 .  Then pop element from back and put to LL\\n3 .  Now pop element from start and put to LL\\n4 .  Repeat 2&3 till queue is empty."
                    },
                    {
                        "username": "hafid-hub",
                        "content": "Good idea but we can do better with constant space."
                    },
                    {
                        "username": "Narasimha-png",
                        "content": "When we add elements into list and then by removing and last it\\'s my intution but it came error as cycle formed\\nhere is code\\n\\nclass Solution {\\n    public void reorderList(ListNode head) {\\n        List<ListNode> res=new ArrayList<ListNode>();\\n        ListNode head1=head.next;\\n        while(head1!=null){\\n            res.add(head1);\\n            head1=head1.next;\\n        }\\n        int end=res.size()-1;\\n        int start=0;\\n        ListNode head2=head;\\n        ListNode tem=res.get(0);\\n        System.out.println(tem.next.val);\\n        while(start<=end){\\n            if(start==end){\\n                head2.next=res.get(start++);\\n                head2=head2.next;\\n                head.next=null;\\n                continue;\\n            }\\n            head2.next=res.get(end--);\\n            head2=head2.next;\\n            head.next=null;\\n            head2.next=res.get(start++);\\n            head2=head2.next;\\n            head.next=null;\\n        }\\n       \\n        \\n    }\\n}"
                    },
                    {
                        "username": "pandeyharshit122",
                        "content": "hi\\n"
                    },
                    {
                        "username": "DreamZerone",
                        "content": "hello sir\\n"
                    },
                    {
                        "username": "DreamZerone",
                        "content": "hello guys"
                    },
                    {
                        "username": "crazysamurai",
                        "content": "Find middle -> reverse the list after middle -> merge the two lists"
                    },
                    {
                        "username": "Curious_hritik",
                        "content": " `your inline code...your inline code...`\\n ListNode* swapList(ListNode* head) {\\n    //Each time call swapList will set L(n-i) = Li->next\\n    if (head == NULL || head->next == NULL || head->next->next == NULL) \\n        return head;\\n\\n    ListNode* cur = head;\\n    ListNode* tmp = head->next;\\n    ListNode* prev = head->next;\\n    while (tmp->next != NULL) {\\n        prev = tmp;\\n        tmp = tmp->next;\\n    }\\n    prev->next = NULL;\\n    tmp->next = cur->next;\\n    cur->next = tmp;\\n    cur = cur->next->next;\\n    swapList(cur);\\n    return head;\\n}\\n\\nvoid reorderList(ListNode* head) {\\n    swapList(head);\\n   }\\n};"
                    },
                    {
                        "username": "kokatekuntal",
                        "content": "You can do this in Time -> O(N) and Space -> O(1)\\nThere are other easy approaches in Space -> O(N) using deque, sets, etc.\\n\\n1. Break the list in two almost equal halves (first half should be ceil(n/2) length)\\n2. Reverse the second half\\n3. Now merge lists "
                    },
                    {
                        "username": "jd-0312",
                        "content": "How???? example?"
                    },
                    {
                        "username": "vipin1211",
                        "content": "Just changing the first few lines to the below:\\n`dummy = ListNode()\\ndummy.next = head\\nslow = dummy\\nfast = head`\\n\\nResults in \\'\\'NoneType\\' object has no attribute \\'next\\'\\' exception even though the head holds the right answer, can anyone explain why?"
                    },
                    {
                        "username": "hermit_ops000",
                        "content": "I am quite certain my code is correct returning a linked list of [1,4,2,3] as expected for an input of [1,2,3,4].  But when I run my code on the test case, I get an output of [1,2,3,4] instead (which is wrong).  I am really confused as to why.  \\n\\nIf anyone can take a look at my code and share their thoughts I\\'d really appreciate it.  \\n\\n`# Definition for singly-linked list.\\nclass ListNode(object):\\n    def __init__(self, val=0, next=None):\\n        self.val = val\\n        self.next = next\\n\\nclass Solution(object):\\n    def reorderList(self, head):\\n        \"\"\"\\n        :type head: ListNode\\n        :rtype: None Do not return anything, modify head in-place instead.\\n        \"\"\"\\n\\n        nodes_list = []\\n        insert_cnt = 0\\n\\n        # get values of node into list \\n        while head is not None:\\n            nodes_list.append(head.val)\\n            head = head.next \\n        # print (\"nodes_list\", nodes_list)\\n\\n        # even and odd length arrays \\n        if len(nodes_list) % 2 != 0: # odd len array \\n            midpt_index = int(len(nodes_list)/2)+1 # +1 to mimic ceiling  \\n        else: # even len array \\n            midpt_index = len(nodes_list)/2\\n\\n        # print (midpt_index)\\n\\n        lft_arr = nodes_list[0:midpt_index]\\n        rt_arr = nodes_list[midpt_index:len(nodes_list)+1]\\n        rt_arr_rev = list(reversed(rt_arr))\\n\\n        # print (lft_arr, rt_arr_rev)\\n\\n        for i, val in enumerate(rt_arr_rev):\\n            i_insert = i+1 + insert_cnt\\n            lft_arr.insert(i_insert, val)\\n            insert_cnt += 1\\n\\n        # print (\"lft_arr\", lft_arr)\\n\\n        # convert list into LL\\n        newHead = temp = ListNode()\\n\\n        for val in lft_arr:\\n            # print (\"val\", val)\\n            temp.next = ListNode(val)\\n            temp = temp.next\\n\\n        # print (\"newHead.next\", newHead.next.next.next.next.val)\\n        return newHead.next`"
                    },
                    {
                        "username": "hafid-hub",
                        "content": "You don\\'t need  to return any thing. \\nYou change the values, and it is what the problem ask for.\\nRead again carefully the problem. "
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/8N_L_c71avU"
                    }
                ]
            },
            {
                "id": 1878171,
                "content": [
                    {
                        "username": "ankurmaurya08",
                        "content": "1 .  Put all elements  of LL in queue except first element\\n2 .  Then pop element from back and put to LL\\n3 .  Now pop element from start and put to LL\\n4 .  Repeat 2&3 till queue is empty."
                    },
                    {
                        "username": "hafid-hub",
                        "content": "Good idea but we can do better with constant space."
                    },
                    {
                        "username": "Narasimha-png",
                        "content": "When we add elements into list and then by removing and last it\\'s my intution but it came error as cycle formed\\nhere is code\\n\\nclass Solution {\\n    public void reorderList(ListNode head) {\\n        List<ListNode> res=new ArrayList<ListNode>();\\n        ListNode head1=head.next;\\n        while(head1!=null){\\n            res.add(head1);\\n            head1=head1.next;\\n        }\\n        int end=res.size()-1;\\n        int start=0;\\n        ListNode head2=head;\\n        ListNode tem=res.get(0);\\n        System.out.println(tem.next.val);\\n        while(start<=end){\\n            if(start==end){\\n                head2.next=res.get(start++);\\n                head2=head2.next;\\n                head.next=null;\\n                continue;\\n            }\\n            head2.next=res.get(end--);\\n            head2=head2.next;\\n            head.next=null;\\n            head2.next=res.get(start++);\\n            head2=head2.next;\\n            head.next=null;\\n        }\\n       \\n        \\n    }\\n}"
                    },
                    {
                        "username": "pandeyharshit122",
                        "content": "hi\\n"
                    },
                    {
                        "username": "DreamZerone",
                        "content": "hello sir\\n"
                    },
                    {
                        "username": "DreamZerone",
                        "content": "hello guys"
                    },
                    {
                        "username": "crazysamurai",
                        "content": "Find middle -> reverse the list after middle -> merge the two lists"
                    },
                    {
                        "username": "Curious_hritik",
                        "content": " `your inline code...your inline code...`\\n ListNode* swapList(ListNode* head) {\\n    //Each time call swapList will set L(n-i) = Li->next\\n    if (head == NULL || head->next == NULL || head->next->next == NULL) \\n        return head;\\n\\n    ListNode* cur = head;\\n    ListNode* tmp = head->next;\\n    ListNode* prev = head->next;\\n    while (tmp->next != NULL) {\\n        prev = tmp;\\n        tmp = tmp->next;\\n    }\\n    prev->next = NULL;\\n    tmp->next = cur->next;\\n    cur->next = tmp;\\n    cur = cur->next->next;\\n    swapList(cur);\\n    return head;\\n}\\n\\nvoid reorderList(ListNode* head) {\\n    swapList(head);\\n   }\\n};"
                    },
                    {
                        "username": "kokatekuntal",
                        "content": "You can do this in Time -> O(N) and Space -> O(1)\\nThere are other easy approaches in Space -> O(N) using deque, sets, etc.\\n\\n1. Break the list in two almost equal halves (first half should be ceil(n/2) length)\\n2. Reverse the second half\\n3. Now merge lists "
                    },
                    {
                        "username": "jd-0312",
                        "content": "How???? example?"
                    },
                    {
                        "username": "vipin1211",
                        "content": "Just changing the first few lines to the below:\\n`dummy = ListNode()\\ndummy.next = head\\nslow = dummy\\nfast = head`\\n\\nResults in \\'\\'NoneType\\' object has no attribute \\'next\\'\\' exception even though the head holds the right answer, can anyone explain why?"
                    },
                    {
                        "username": "hermit_ops000",
                        "content": "I am quite certain my code is correct returning a linked list of [1,4,2,3] as expected for an input of [1,2,3,4].  But when I run my code on the test case, I get an output of [1,2,3,4] instead (which is wrong).  I am really confused as to why.  \\n\\nIf anyone can take a look at my code and share their thoughts I\\'d really appreciate it.  \\n\\n`# Definition for singly-linked list.\\nclass ListNode(object):\\n    def __init__(self, val=0, next=None):\\n        self.val = val\\n        self.next = next\\n\\nclass Solution(object):\\n    def reorderList(self, head):\\n        \"\"\"\\n        :type head: ListNode\\n        :rtype: None Do not return anything, modify head in-place instead.\\n        \"\"\"\\n\\n        nodes_list = []\\n        insert_cnt = 0\\n\\n        # get values of node into list \\n        while head is not None:\\n            nodes_list.append(head.val)\\n            head = head.next \\n        # print (\"nodes_list\", nodes_list)\\n\\n        # even and odd length arrays \\n        if len(nodes_list) % 2 != 0: # odd len array \\n            midpt_index = int(len(nodes_list)/2)+1 # +1 to mimic ceiling  \\n        else: # even len array \\n            midpt_index = len(nodes_list)/2\\n\\n        # print (midpt_index)\\n\\n        lft_arr = nodes_list[0:midpt_index]\\n        rt_arr = nodes_list[midpt_index:len(nodes_list)+1]\\n        rt_arr_rev = list(reversed(rt_arr))\\n\\n        # print (lft_arr, rt_arr_rev)\\n\\n        for i, val in enumerate(rt_arr_rev):\\n            i_insert = i+1 + insert_cnt\\n            lft_arr.insert(i_insert, val)\\n            insert_cnt += 1\\n\\n        # print (\"lft_arr\", lft_arr)\\n\\n        # convert list into LL\\n        newHead = temp = ListNode()\\n\\n        for val in lft_arr:\\n            # print (\"val\", val)\\n            temp.next = ListNode(val)\\n            temp = temp.next\\n\\n        # print (\"newHead.next\", newHead.next.next.next.next.val)\\n        return newHead.next`"
                    },
                    {
                        "username": "hafid-hub",
                        "content": "You don\\'t need  to return any thing. \\nYou change the values, and it is what the problem ask for.\\nRead again carefully the problem. "
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/8N_L_c71avU"
                    }
                ]
            },
            {
                "id": 1878169,
                "content": [
                    {
                        "username": "ankurmaurya08",
                        "content": "1 .  Put all elements  of LL in queue except first element\\n2 .  Then pop element from back and put to LL\\n3 .  Now pop element from start and put to LL\\n4 .  Repeat 2&3 till queue is empty."
                    },
                    {
                        "username": "hafid-hub",
                        "content": "Good idea but we can do better with constant space."
                    },
                    {
                        "username": "Narasimha-png",
                        "content": "When we add elements into list and then by removing and last it\\'s my intution but it came error as cycle formed\\nhere is code\\n\\nclass Solution {\\n    public void reorderList(ListNode head) {\\n        List<ListNode> res=new ArrayList<ListNode>();\\n        ListNode head1=head.next;\\n        while(head1!=null){\\n            res.add(head1);\\n            head1=head1.next;\\n        }\\n        int end=res.size()-1;\\n        int start=0;\\n        ListNode head2=head;\\n        ListNode tem=res.get(0);\\n        System.out.println(tem.next.val);\\n        while(start<=end){\\n            if(start==end){\\n                head2.next=res.get(start++);\\n                head2=head2.next;\\n                head.next=null;\\n                continue;\\n            }\\n            head2.next=res.get(end--);\\n            head2=head2.next;\\n            head.next=null;\\n            head2.next=res.get(start++);\\n            head2=head2.next;\\n            head.next=null;\\n        }\\n       \\n        \\n    }\\n}"
                    },
                    {
                        "username": "pandeyharshit122",
                        "content": "hi\\n"
                    },
                    {
                        "username": "DreamZerone",
                        "content": "hello sir\\n"
                    },
                    {
                        "username": "DreamZerone",
                        "content": "hello guys"
                    },
                    {
                        "username": "crazysamurai",
                        "content": "Find middle -> reverse the list after middle -> merge the two lists"
                    },
                    {
                        "username": "Curious_hritik",
                        "content": " `your inline code...your inline code...`\\n ListNode* swapList(ListNode* head) {\\n    //Each time call swapList will set L(n-i) = Li->next\\n    if (head == NULL || head->next == NULL || head->next->next == NULL) \\n        return head;\\n\\n    ListNode* cur = head;\\n    ListNode* tmp = head->next;\\n    ListNode* prev = head->next;\\n    while (tmp->next != NULL) {\\n        prev = tmp;\\n        tmp = tmp->next;\\n    }\\n    prev->next = NULL;\\n    tmp->next = cur->next;\\n    cur->next = tmp;\\n    cur = cur->next->next;\\n    swapList(cur);\\n    return head;\\n}\\n\\nvoid reorderList(ListNode* head) {\\n    swapList(head);\\n   }\\n};"
                    },
                    {
                        "username": "kokatekuntal",
                        "content": "You can do this in Time -> O(N) and Space -> O(1)\\nThere are other easy approaches in Space -> O(N) using deque, sets, etc.\\n\\n1. Break the list in two almost equal halves (first half should be ceil(n/2) length)\\n2. Reverse the second half\\n3. Now merge lists "
                    },
                    {
                        "username": "jd-0312",
                        "content": "How???? example?"
                    },
                    {
                        "username": "vipin1211",
                        "content": "Just changing the first few lines to the below:\\n`dummy = ListNode()\\ndummy.next = head\\nslow = dummy\\nfast = head`\\n\\nResults in \\'\\'NoneType\\' object has no attribute \\'next\\'\\' exception even though the head holds the right answer, can anyone explain why?"
                    },
                    {
                        "username": "hermit_ops000",
                        "content": "I am quite certain my code is correct returning a linked list of [1,4,2,3] as expected for an input of [1,2,3,4].  But when I run my code on the test case, I get an output of [1,2,3,4] instead (which is wrong).  I am really confused as to why.  \\n\\nIf anyone can take a look at my code and share their thoughts I\\'d really appreciate it.  \\n\\n`# Definition for singly-linked list.\\nclass ListNode(object):\\n    def __init__(self, val=0, next=None):\\n        self.val = val\\n        self.next = next\\n\\nclass Solution(object):\\n    def reorderList(self, head):\\n        \"\"\"\\n        :type head: ListNode\\n        :rtype: None Do not return anything, modify head in-place instead.\\n        \"\"\"\\n\\n        nodes_list = []\\n        insert_cnt = 0\\n\\n        # get values of node into list \\n        while head is not None:\\n            nodes_list.append(head.val)\\n            head = head.next \\n        # print (\"nodes_list\", nodes_list)\\n\\n        # even and odd length arrays \\n        if len(nodes_list) % 2 != 0: # odd len array \\n            midpt_index = int(len(nodes_list)/2)+1 # +1 to mimic ceiling  \\n        else: # even len array \\n            midpt_index = len(nodes_list)/2\\n\\n        # print (midpt_index)\\n\\n        lft_arr = nodes_list[0:midpt_index]\\n        rt_arr = nodes_list[midpt_index:len(nodes_list)+1]\\n        rt_arr_rev = list(reversed(rt_arr))\\n\\n        # print (lft_arr, rt_arr_rev)\\n\\n        for i, val in enumerate(rt_arr_rev):\\n            i_insert = i+1 + insert_cnt\\n            lft_arr.insert(i_insert, val)\\n            insert_cnt += 1\\n\\n        # print (\"lft_arr\", lft_arr)\\n\\n        # convert list into LL\\n        newHead = temp = ListNode()\\n\\n        for val in lft_arr:\\n            # print (\"val\", val)\\n            temp.next = ListNode(val)\\n            temp = temp.next\\n\\n        # print (\"newHead.next\", newHead.next.next.next.next.val)\\n        return newHead.next`"
                    },
                    {
                        "username": "hafid-hub",
                        "content": "You don\\'t need  to return any thing. \\nYou change the values, and it is what the problem ask for.\\nRead again carefully the problem. "
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/8N_L_c71avU"
                    }
                ]
            },
            {
                "id": 1796487,
                "content": [
                    {
                        "username": "ankurmaurya08",
                        "content": "1 .  Put all elements  of LL in queue except first element\\n2 .  Then pop element from back and put to LL\\n3 .  Now pop element from start and put to LL\\n4 .  Repeat 2&3 till queue is empty."
                    },
                    {
                        "username": "hafid-hub",
                        "content": "Good idea but we can do better with constant space."
                    },
                    {
                        "username": "Narasimha-png",
                        "content": "When we add elements into list and then by removing and last it\\'s my intution but it came error as cycle formed\\nhere is code\\n\\nclass Solution {\\n    public void reorderList(ListNode head) {\\n        List<ListNode> res=new ArrayList<ListNode>();\\n        ListNode head1=head.next;\\n        while(head1!=null){\\n            res.add(head1);\\n            head1=head1.next;\\n        }\\n        int end=res.size()-1;\\n        int start=0;\\n        ListNode head2=head;\\n        ListNode tem=res.get(0);\\n        System.out.println(tem.next.val);\\n        while(start<=end){\\n            if(start==end){\\n                head2.next=res.get(start++);\\n                head2=head2.next;\\n                head.next=null;\\n                continue;\\n            }\\n            head2.next=res.get(end--);\\n            head2=head2.next;\\n            head.next=null;\\n            head2.next=res.get(start++);\\n            head2=head2.next;\\n            head.next=null;\\n        }\\n       \\n        \\n    }\\n}"
                    },
                    {
                        "username": "pandeyharshit122",
                        "content": "hi\\n"
                    },
                    {
                        "username": "DreamZerone",
                        "content": "hello sir\\n"
                    },
                    {
                        "username": "DreamZerone",
                        "content": "hello guys"
                    },
                    {
                        "username": "crazysamurai",
                        "content": "Find middle -> reverse the list after middle -> merge the two lists"
                    },
                    {
                        "username": "Curious_hritik",
                        "content": " `your inline code...your inline code...`\\n ListNode* swapList(ListNode* head) {\\n    //Each time call swapList will set L(n-i) = Li->next\\n    if (head == NULL || head->next == NULL || head->next->next == NULL) \\n        return head;\\n\\n    ListNode* cur = head;\\n    ListNode* tmp = head->next;\\n    ListNode* prev = head->next;\\n    while (tmp->next != NULL) {\\n        prev = tmp;\\n        tmp = tmp->next;\\n    }\\n    prev->next = NULL;\\n    tmp->next = cur->next;\\n    cur->next = tmp;\\n    cur = cur->next->next;\\n    swapList(cur);\\n    return head;\\n}\\n\\nvoid reorderList(ListNode* head) {\\n    swapList(head);\\n   }\\n};"
                    },
                    {
                        "username": "kokatekuntal",
                        "content": "You can do this in Time -> O(N) and Space -> O(1)\\nThere are other easy approaches in Space -> O(N) using deque, sets, etc.\\n\\n1. Break the list in two almost equal halves (first half should be ceil(n/2) length)\\n2. Reverse the second half\\n3. Now merge lists "
                    },
                    {
                        "username": "jd-0312",
                        "content": "How???? example?"
                    },
                    {
                        "username": "vipin1211",
                        "content": "Just changing the first few lines to the below:\\n`dummy = ListNode()\\ndummy.next = head\\nslow = dummy\\nfast = head`\\n\\nResults in \\'\\'NoneType\\' object has no attribute \\'next\\'\\' exception even though the head holds the right answer, can anyone explain why?"
                    },
                    {
                        "username": "hermit_ops000",
                        "content": "I am quite certain my code is correct returning a linked list of [1,4,2,3] as expected for an input of [1,2,3,4].  But when I run my code on the test case, I get an output of [1,2,3,4] instead (which is wrong).  I am really confused as to why.  \\n\\nIf anyone can take a look at my code and share their thoughts I\\'d really appreciate it.  \\n\\n`# Definition for singly-linked list.\\nclass ListNode(object):\\n    def __init__(self, val=0, next=None):\\n        self.val = val\\n        self.next = next\\n\\nclass Solution(object):\\n    def reorderList(self, head):\\n        \"\"\"\\n        :type head: ListNode\\n        :rtype: None Do not return anything, modify head in-place instead.\\n        \"\"\"\\n\\n        nodes_list = []\\n        insert_cnt = 0\\n\\n        # get values of node into list \\n        while head is not None:\\n            nodes_list.append(head.val)\\n            head = head.next \\n        # print (\"nodes_list\", nodes_list)\\n\\n        # even and odd length arrays \\n        if len(nodes_list) % 2 != 0: # odd len array \\n            midpt_index = int(len(nodes_list)/2)+1 # +1 to mimic ceiling  \\n        else: # even len array \\n            midpt_index = len(nodes_list)/2\\n\\n        # print (midpt_index)\\n\\n        lft_arr = nodes_list[0:midpt_index]\\n        rt_arr = nodes_list[midpt_index:len(nodes_list)+1]\\n        rt_arr_rev = list(reversed(rt_arr))\\n\\n        # print (lft_arr, rt_arr_rev)\\n\\n        for i, val in enumerate(rt_arr_rev):\\n            i_insert = i+1 + insert_cnt\\n            lft_arr.insert(i_insert, val)\\n            insert_cnt += 1\\n\\n        # print (\"lft_arr\", lft_arr)\\n\\n        # convert list into LL\\n        newHead = temp = ListNode()\\n\\n        for val in lft_arr:\\n            # print (\"val\", val)\\n            temp.next = ListNode(val)\\n            temp = temp.next\\n\\n        # print (\"newHead.next\", newHead.next.next.next.next.val)\\n        return newHead.next`"
                    },
                    {
                        "username": "hafid-hub",
                        "content": "You don\\'t need  to return any thing. \\nYou change the values, and it is what the problem ask for.\\nRead again carefully the problem. "
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/8N_L_c71avU"
                    }
                ]
            },
            {
                "id": 1793267,
                "content": [
                    {
                        "username": "ankurmaurya08",
                        "content": "1 .  Put all elements  of LL in queue except first element\\n2 .  Then pop element from back and put to LL\\n3 .  Now pop element from start and put to LL\\n4 .  Repeat 2&3 till queue is empty."
                    },
                    {
                        "username": "hafid-hub",
                        "content": "Good idea but we can do better with constant space."
                    },
                    {
                        "username": "Narasimha-png",
                        "content": "When we add elements into list and then by removing and last it\\'s my intution but it came error as cycle formed\\nhere is code\\n\\nclass Solution {\\n    public void reorderList(ListNode head) {\\n        List<ListNode> res=new ArrayList<ListNode>();\\n        ListNode head1=head.next;\\n        while(head1!=null){\\n            res.add(head1);\\n            head1=head1.next;\\n        }\\n        int end=res.size()-1;\\n        int start=0;\\n        ListNode head2=head;\\n        ListNode tem=res.get(0);\\n        System.out.println(tem.next.val);\\n        while(start<=end){\\n            if(start==end){\\n                head2.next=res.get(start++);\\n                head2=head2.next;\\n                head.next=null;\\n                continue;\\n            }\\n            head2.next=res.get(end--);\\n            head2=head2.next;\\n            head.next=null;\\n            head2.next=res.get(start++);\\n            head2=head2.next;\\n            head.next=null;\\n        }\\n       \\n        \\n    }\\n}"
                    },
                    {
                        "username": "pandeyharshit122",
                        "content": "hi\\n"
                    },
                    {
                        "username": "DreamZerone",
                        "content": "hello sir\\n"
                    },
                    {
                        "username": "DreamZerone",
                        "content": "hello guys"
                    },
                    {
                        "username": "crazysamurai",
                        "content": "Find middle -> reverse the list after middle -> merge the two lists"
                    },
                    {
                        "username": "Curious_hritik",
                        "content": " `your inline code...your inline code...`\\n ListNode* swapList(ListNode* head) {\\n    //Each time call swapList will set L(n-i) = Li->next\\n    if (head == NULL || head->next == NULL || head->next->next == NULL) \\n        return head;\\n\\n    ListNode* cur = head;\\n    ListNode* tmp = head->next;\\n    ListNode* prev = head->next;\\n    while (tmp->next != NULL) {\\n        prev = tmp;\\n        tmp = tmp->next;\\n    }\\n    prev->next = NULL;\\n    tmp->next = cur->next;\\n    cur->next = tmp;\\n    cur = cur->next->next;\\n    swapList(cur);\\n    return head;\\n}\\n\\nvoid reorderList(ListNode* head) {\\n    swapList(head);\\n   }\\n};"
                    },
                    {
                        "username": "kokatekuntal",
                        "content": "You can do this in Time -> O(N) and Space -> O(1)\\nThere are other easy approaches in Space -> O(N) using deque, sets, etc.\\n\\n1. Break the list in two almost equal halves (first half should be ceil(n/2) length)\\n2. Reverse the second half\\n3. Now merge lists "
                    },
                    {
                        "username": "jd-0312",
                        "content": "How???? example?"
                    },
                    {
                        "username": "vipin1211",
                        "content": "Just changing the first few lines to the below:\\n`dummy = ListNode()\\ndummy.next = head\\nslow = dummy\\nfast = head`\\n\\nResults in \\'\\'NoneType\\' object has no attribute \\'next\\'\\' exception even though the head holds the right answer, can anyone explain why?"
                    },
                    {
                        "username": "hermit_ops000",
                        "content": "I am quite certain my code is correct returning a linked list of [1,4,2,3] as expected for an input of [1,2,3,4].  But when I run my code on the test case, I get an output of [1,2,3,4] instead (which is wrong).  I am really confused as to why.  \\n\\nIf anyone can take a look at my code and share their thoughts I\\'d really appreciate it.  \\n\\n`# Definition for singly-linked list.\\nclass ListNode(object):\\n    def __init__(self, val=0, next=None):\\n        self.val = val\\n        self.next = next\\n\\nclass Solution(object):\\n    def reorderList(self, head):\\n        \"\"\"\\n        :type head: ListNode\\n        :rtype: None Do not return anything, modify head in-place instead.\\n        \"\"\"\\n\\n        nodes_list = []\\n        insert_cnt = 0\\n\\n        # get values of node into list \\n        while head is not None:\\n            nodes_list.append(head.val)\\n            head = head.next \\n        # print (\"nodes_list\", nodes_list)\\n\\n        # even and odd length arrays \\n        if len(nodes_list) % 2 != 0: # odd len array \\n            midpt_index = int(len(nodes_list)/2)+1 # +1 to mimic ceiling  \\n        else: # even len array \\n            midpt_index = len(nodes_list)/2\\n\\n        # print (midpt_index)\\n\\n        lft_arr = nodes_list[0:midpt_index]\\n        rt_arr = nodes_list[midpt_index:len(nodes_list)+1]\\n        rt_arr_rev = list(reversed(rt_arr))\\n\\n        # print (lft_arr, rt_arr_rev)\\n\\n        for i, val in enumerate(rt_arr_rev):\\n            i_insert = i+1 + insert_cnt\\n            lft_arr.insert(i_insert, val)\\n            insert_cnt += 1\\n\\n        # print (\"lft_arr\", lft_arr)\\n\\n        # convert list into LL\\n        newHead = temp = ListNode()\\n\\n        for val in lft_arr:\\n            # print (\"val\", val)\\n            temp.next = ListNode(val)\\n            temp = temp.next\\n\\n        # print (\"newHead.next\", newHead.next.next.next.next.val)\\n        return newHead.next`"
                    },
                    {
                        "username": "hafid-hub",
                        "content": "You don\\'t need  to return any thing. \\nYou change the values, and it is what the problem ask for.\\nRead again carefully the problem. "
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/8N_L_c71avU"
                    }
                ]
            },
            {
                "id": 1783452,
                "content": [
                    {
                        "username": "ankurmaurya08",
                        "content": "1 .  Put all elements  of LL in queue except first element\\n2 .  Then pop element from back and put to LL\\n3 .  Now pop element from start and put to LL\\n4 .  Repeat 2&3 till queue is empty."
                    },
                    {
                        "username": "hafid-hub",
                        "content": "Good idea but we can do better with constant space."
                    },
                    {
                        "username": "Narasimha-png",
                        "content": "When we add elements into list and then by removing and last it\\'s my intution but it came error as cycle formed\\nhere is code\\n\\nclass Solution {\\n    public void reorderList(ListNode head) {\\n        List<ListNode> res=new ArrayList<ListNode>();\\n        ListNode head1=head.next;\\n        while(head1!=null){\\n            res.add(head1);\\n            head1=head1.next;\\n        }\\n        int end=res.size()-1;\\n        int start=0;\\n        ListNode head2=head;\\n        ListNode tem=res.get(0);\\n        System.out.println(tem.next.val);\\n        while(start<=end){\\n            if(start==end){\\n                head2.next=res.get(start++);\\n                head2=head2.next;\\n                head.next=null;\\n                continue;\\n            }\\n            head2.next=res.get(end--);\\n            head2=head2.next;\\n            head.next=null;\\n            head2.next=res.get(start++);\\n            head2=head2.next;\\n            head.next=null;\\n        }\\n       \\n        \\n    }\\n}"
                    },
                    {
                        "username": "pandeyharshit122",
                        "content": "hi\\n"
                    },
                    {
                        "username": "DreamZerone",
                        "content": "hello sir\\n"
                    },
                    {
                        "username": "DreamZerone",
                        "content": "hello guys"
                    },
                    {
                        "username": "crazysamurai",
                        "content": "Find middle -> reverse the list after middle -> merge the two lists"
                    },
                    {
                        "username": "Curious_hritik",
                        "content": " `your inline code...your inline code...`\\n ListNode* swapList(ListNode* head) {\\n    //Each time call swapList will set L(n-i) = Li->next\\n    if (head == NULL || head->next == NULL || head->next->next == NULL) \\n        return head;\\n\\n    ListNode* cur = head;\\n    ListNode* tmp = head->next;\\n    ListNode* prev = head->next;\\n    while (tmp->next != NULL) {\\n        prev = tmp;\\n        tmp = tmp->next;\\n    }\\n    prev->next = NULL;\\n    tmp->next = cur->next;\\n    cur->next = tmp;\\n    cur = cur->next->next;\\n    swapList(cur);\\n    return head;\\n}\\n\\nvoid reorderList(ListNode* head) {\\n    swapList(head);\\n   }\\n};"
                    },
                    {
                        "username": "kokatekuntal",
                        "content": "You can do this in Time -> O(N) and Space -> O(1)\\nThere are other easy approaches in Space -> O(N) using deque, sets, etc.\\n\\n1. Break the list in two almost equal halves (first half should be ceil(n/2) length)\\n2. Reverse the second half\\n3. Now merge lists "
                    },
                    {
                        "username": "jd-0312",
                        "content": "How???? example?"
                    },
                    {
                        "username": "vipin1211",
                        "content": "Just changing the first few lines to the below:\\n`dummy = ListNode()\\ndummy.next = head\\nslow = dummy\\nfast = head`\\n\\nResults in \\'\\'NoneType\\' object has no attribute \\'next\\'\\' exception even though the head holds the right answer, can anyone explain why?"
                    },
                    {
                        "username": "hermit_ops000",
                        "content": "I am quite certain my code is correct returning a linked list of [1,4,2,3] as expected for an input of [1,2,3,4].  But when I run my code on the test case, I get an output of [1,2,3,4] instead (which is wrong).  I am really confused as to why.  \\n\\nIf anyone can take a look at my code and share their thoughts I\\'d really appreciate it.  \\n\\n`# Definition for singly-linked list.\\nclass ListNode(object):\\n    def __init__(self, val=0, next=None):\\n        self.val = val\\n        self.next = next\\n\\nclass Solution(object):\\n    def reorderList(self, head):\\n        \"\"\"\\n        :type head: ListNode\\n        :rtype: None Do not return anything, modify head in-place instead.\\n        \"\"\"\\n\\n        nodes_list = []\\n        insert_cnt = 0\\n\\n        # get values of node into list \\n        while head is not None:\\n            nodes_list.append(head.val)\\n            head = head.next \\n        # print (\"nodes_list\", nodes_list)\\n\\n        # even and odd length arrays \\n        if len(nodes_list) % 2 != 0: # odd len array \\n            midpt_index = int(len(nodes_list)/2)+1 # +1 to mimic ceiling  \\n        else: # even len array \\n            midpt_index = len(nodes_list)/2\\n\\n        # print (midpt_index)\\n\\n        lft_arr = nodes_list[0:midpt_index]\\n        rt_arr = nodes_list[midpt_index:len(nodes_list)+1]\\n        rt_arr_rev = list(reversed(rt_arr))\\n\\n        # print (lft_arr, rt_arr_rev)\\n\\n        for i, val in enumerate(rt_arr_rev):\\n            i_insert = i+1 + insert_cnt\\n            lft_arr.insert(i_insert, val)\\n            insert_cnt += 1\\n\\n        # print (\"lft_arr\", lft_arr)\\n\\n        # convert list into LL\\n        newHead = temp = ListNode()\\n\\n        for val in lft_arr:\\n            # print (\"val\", val)\\n            temp.next = ListNode(val)\\n            temp = temp.next\\n\\n        # print (\"newHead.next\", newHead.next.next.next.next.val)\\n        return newHead.next`"
                    },
                    {
                        "username": "hafid-hub",
                        "content": "You don\\'t need  to return any thing. \\nYou change the values, and it is what the problem ask for.\\nRead again carefully the problem. "
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/8N_L_c71avU"
                    }
                ]
            },
            {
                "id": 1773288,
                "content": [
                    {
                        "username": "ankurmaurya08",
                        "content": "1 .  Put all elements  of LL in queue except first element\\n2 .  Then pop element from back and put to LL\\n3 .  Now pop element from start and put to LL\\n4 .  Repeat 2&3 till queue is empty."
                    },
                    {
                        "username": "hafid-hub",
                        "content": "Good idea but we can do better with constant space."
                    },
                    {
                        "username": "Narasimha-png",
                        "content": "When we add elements into list and then by removing and last it\\'s my intution but it came error as cycle formed\\nhere is code\\n\\nclass Solution {\\n    public void reorderList(ListNode head) {\\n        List<ListNode> res=new ArrayList<ListNode>();\\n        ListNode head1=head.next;\\n        while(head1!=null){\\n            res.add(head1);\\n            head1=head1.next;\\n        }\\n        int end=res.size()-1;\\n        int start=0;\\n        ListNode head2=head;\\n        ListNode tem=res.get(0);\\n        System.out.println(tem.next.val);\\n        while(start<=end){\\n            if(start==end){\\n                head2.next=res.get(start++);\\n                head2=head2.next;\\n                head.next=null;\\n                continue;\\n            }\\n            head2.next=res.get(end--);\\n            head2=head2.next;\\n            head.next=null;\\n            head2.next=res.get(start++);\\n            head2=head2.next;\\n            head.next=null;\\n        }\\n       \\n        \\n    }\\n}"
                    },
                    {
                        "username": "pandeyharshit122",
                        "content": "hi\\n"
                    },
                    {
                        "username": "DreamZerone",
                        "content": "hello sir\\n"
                    },
                    {
                        "username": "DreamZerone",
                        "content": "hello guys"
                    },
                    {
                        "username": "crazysamurai",
                        "content": "Find middle -> reverse the list after middle -> merge the two lists"
                    },
                    {
                        "username": "Curious_hritik",
                        "content": " `your inline code...your inline code...`\\n ListNode* swapList(ListNode* head) {\\n    //Each time call swapList will set L(n-i) = Li->next\\n    if (head == NULL || head->next == NULL || head->next->next == NULL) \\n        return head;\\n\\n    ListNode* cur = head;\\n    ListNode* tmp = head->next;\\n    ListNode* prev = head->next;\\n    while (tmp->next != NULL) {\\n        prev = tmp;\\n        tmp = tmp->next;\\n    }\\n    prev->next = NULL;\\n    tmp->next = cur->next;\\n    cur->next = tmp;\\n    cur = cur->next->next;\\n    swapList(cur);\\n    return head;\\n}\\n\\nvoid reorderList(ListNode* head) {\\n    swapList(head);\\n   }\\n};"
                    },
                    {
                        "username": "kokatekuntal",
                        "content": "You can do this in Time -> O(N) and Space -> O(1)\\nThere are other easy approaches in Space -> O(N) using deque, sets, etc.\\n\\n1. Break the list in two almost equal halves (first half should be ceil(n/2) length)\\n2. Reverse the second half\\n3. Now merge lists "
                    },
                    {
                        "username": "jd-0312",
                        "content": "How???? example?"
                    },
                    {
                        "username": "vipin1211",
                        "content": "Just changing the first few lines to the below:\\n`dummy = ListNode()\\ndummy.next = head\\nslow = dummy\\nfast = head`\\n\\nResults in \\'\\'NoneType\\' object has no attribute \\'next\\'\\' exception even though the head holds the right answer, can anyone explain why?"
                    },
                    {
                        "username": "hermit_ops000",
                        "content": "I am quite certain my code is correct returning a linked list of [1,4,2,3] as expected for an input of [1,2,3,4].  But when I run my code on the test case, I get an output of [1,2,3,4] instead (which is wrong).  I am really confused as to why.  \\n\\nIf anyone can take a look at my code and share their thoughts I\\'d really appreciate it.  \\n\\n`# Definition for singly-linked list.\\nclass ListNode(object):\\n    def __init__(self, val=0, next=None):\\n        self.val = val\\n        self.next = next\\n\\nclass Solution(object):\\n    def reorderList(self, head):\\n        \"\"\"\\n        :type head: ListNode\\n        :rtype: None Do not return anything, modify head in-place instead.\\n        \"\"\"\\n\\n        nodes_list = []\\n        insert_cnt = 0\\n\\n        # get values of node into list \\n        while head is not None:\\n            nodes_list.append(head.val)\\n            head = head.next \\n        # print (\"nodes_list\", nodes_list)\\n\\n        # even and odd length arrays \\n        if len(nodes_list) % 2 != 0: # odd len array \\n            midpt_index = int(len(nodes_list)/2)+1 # +1 to mimic ceiling  \\n        else: # even len array \\n            midpt_index = len(nodes_list)/2\\n\\n        # print (midpt_index)\\n\\n        lft_arr = nodes_list[0:midpt_index]\\n        rt_arr = nodes_list[midpt_index:len(nodes_list)+1]\\n        rt_arr_rev = list(reversed(rt_arr))\\n\\n        # print (lft_arr, rt_arr_rev)\\n\\n        for i, val in enumerate(rt_arr_rev):\\n            i_insert = i+1 + insert_cnt\\n            lft_arr.insert(i_insert, val)\\n            insert_cnt += 1\\n\\n        # print (\"lft_arr\", lft_arr)\\n\\n        # convert list into LL\\n        newHead = temp = ListNode()\\n\\n        for val in lft_arr:\\n            # print (\"val\", val)\\n            temp.next = ListNode(val)\\n            temp = temp.next\\n\\n        # print (\"newHead.next\", newHead.next.next.next.next.val)\\n        return newHead.next`"
                    },
                    {
                        "username": "hafid-hub",
                        "content": "You don\\'t need  to return any thing. \\nYou change the values, and it is what the problem ask for.\\nRead again carefully the problem. "
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/8N_L_c71avU"
                    }
                ]
            },
            {
                "id": 1771699,
                "content": [
                    {
                        "username": "ankurmaurya08",
                        "content": "1 .  Put all elements  of LL in queue except first element\\n2 .  Then pop element from back and put to LL\\n3 .  Now pop element from start and put to LL\\n4 .  Repeat 2&3 till queue is empty."
                    },
                    {
                        "username": "hafid-hub",
                        "content": "Good idea but we can do better with constant space."
                    },
                    {
                        "username": "Narasimha-png",
                        "content": "When we add elements into list and then by removing and last it\\'s my intution but it came error as cycle formed\\nhere is code\\n\\nclass Solution {\\n    public void reorderList(ListNode head) {\\n        List<ListNode> res=new ArrayList<ListNode>();\\n        ListNode head1=head.next;\\n        while(head1!=null){\\n            res.add(head1);\\n            head1=head1.next;\\n        }\\n        int end=res.size()-1;\\n        int start=0;\\n        ListNode head2=head;\\n        ListNode tem=res.get(0);\\n        System.out.println(tem.next.val);\\n        while(start<=end){\\n            if(start==end){\\n                head2.next=res.get(start++);\\n                head2=head2.next;\\n                head.next=null;\\n                continue;\\n            }\\n            head2.next=res.get(end--);\\n            head2=head2.next;\\n            head.next=null;\\n            head2.next=res.get(start++);\\n            head2=head2.next;\\n            head.next=null;\\n        }\\n       \\n        \\n    }\\n}"
                    },
                    {
                        "username": "pandeyharshit122",
                        "content": "hi\\n"
                    },
                    {
                        "username": "DreamZerone",
                        "content": "hello sir\\n"
                    },
                    {
                        "username": "DreamZerone",
                        "content": "hello guys"
                    },
                    {
                        "username": "crazysamurai",
                        "content": "Find middle -> reverse the list after middle -> merge the two lists"
                    },
                    {
                        "username": "Curious_hritik",
                        "content": " `your inline code...your inline code...`\\n ListNode* swapList(ListNode* head) {\\n    //Each time call swapList will set L(n-i) = Li->next\\n    if (head == NULL || head->next == NULL || head->next->next == NULL) \\n        return head;\\n\\n    ListNode* cur = head;\\n    ListNode* tmp = head->next;\\n    ListNode* prev = head->next;\\n    while (tmp->next != NULL) {\\n        prev = tmp;\\n        tmp = tmp->next;\\n    }\\n    prev->next = NULL;\\n    tmp->next = cur->next;\\n    cur->next = tmp;\\n    cur = cur->next->next;\\n    swapList(cur);\\n    return head;\\n}\\n\\nvoid reorderList(ListNode* head) {\\n    swapList(head);\\n   }\\n};"
                    },
                    {
                        "username": "kokatekuntal",
                        "content": "You can do this in Time -> O(N) and Space -> O(1)\\nThere are other easy approaches in Space -> O(N) using deque, sets, etc.\\n\\n1. Break the list in two almost equal halves (first half should be ceil(n/2) length)\\n2. Reverse the second half\\n3. Now merge lists "
                    },
                    {
                        "username": "jd-0312",
                        "content": "How???? example?"
                    },
                    {
                        "username": "vipin1211",
                        "content": "Just changing the first few lines to the below:\\n`dummy = ListNode()\\ndummy.next = head\\nslow = dummy\\nfast = head`\\n\\nResults in \\'\\'NoneType\\' object has no attribute \\'next\\'\\' exception even though the head holds the right answer, can anyone explain why?"
                    },
                    {
                        "username": "hermit_ops000",
                        "content": "I am quite certain my code is correct returning a linked list of [1,4,2,3] as expected for an input of [1,2,3,4].  But when I run my code on the test case, I get an output of [1,2,3,4] instead (which is wrong).  I am really confused as to why.  \\n\\nIf anyone can take a look at my code and share their thoughts I\\'d really appreciate it.  \\n\\n`# Definition for singly-linked list.\\nclass ListNode(object):\\n    def __init__(self, val=0, next=None):\\n        self.val = val\\n        self.next = next\\n\\nclass Solution(object):\\n    def reorderList(self, head):\\n        \"\"\"\\n        :type head: ListNode\\n        :rtype: None Do not return anything, modify head in-place instead.\\n        \"\"\"\\n\\n        nodes_list = []\\n        insert_cnt = 0\\n\\n        # get values of node into list \\n        while head is not None:\\n            nodes_list.append(head.val)\\n            head = head.next \\n        # print (\"nodes_list\", nodes_list)\\n\\n        # even and odd length arrays \\n        if len(nodes_list) % 2 != 0: # odd len array \\n            midpt_index = int(len(nodes_list)/2)+1 # +1 to mimic ceiling  \\n        else: # even len array \\n            midpt_index = len(nodes_list)/2\\n\\n        # print (midpt_index)\\n\\n        lft_arr = nodes_list[0:midpt_index]\\n        rt_arr = nodes_list[midpt_index:len(nodes_list)+1]\\n        rt_arr_rev = list(reversed(rt_arr))\\n\\n        # print (lft_arr, rt_arr_rev)\\n\\n        for i, val in enumerate(rt_arr_rev):\\n            i_insert = i+1 + insert_cnt\\n            lft_arr.insert(i_insert, val)\\n            insert_cnt += 1\\n\\n        # print (\"lft_arr\", lft_arr)\\n\\n        # convert list into LL\\n        newHead = temp = ListNode()\\n\\n        for val in lft_arr:\\n            # print (\"val\", val)\\n            temp.next = ListNode(val)\\n            temp = temp.next\\n\\n        # print (\"newHead.next\", newHead.next.next.next.next.val)\\n        return newHead.next`"
                    },
                    {
                        "username": "hafid-hub",
                        "content": "You don\\'t need  to return any thing. \\nYou change the values, and it is what the problem ask for.\\nRead again carefully the problem. "
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/8N_L_c71avU"
                    }
                ]
            },
            {
                "id": 1761018,
                "content": [
                    {
                        "username": "ankurmaurya08",
                        "content": "1 .  Put all elements  of LL in queue except first element\\n2 .  Then pop element from back and put to LL\\n3 .  Now pop element from start and put to LL\\n4 .  Repeat 2&3 till queue is empty."
                    },
                    {
                        "username": "hafid-hub",
                        "content": "Good idea but we can do better with constant space."
                    },
                    {
                        "username": "Narasimha-png",
                        "content": "When we add elements into list and then by removing and last it\\'s my intution but it came error as cycle formed\\nhere is code\\n\\nclass Solution {\\n    public void reorderList(ListNode head) {\\n        List<ListNode> res=new ArrayList<ListNode>();\\n        ListNode head1=head.next;\\n        while(head1!=null){\\n            res.add(head1);\\n            head1=head1.next;\\n        }\\n        int end=res.size()-1;\\n        int start=0;\\n        ListNode head2=head;\\n        ListNode tem=res.get(0);\\n        System.out.println(tem.next.val);\\n        while(start<=end){\\n            if(start==end){\\n                head2.next=res.get(start++);\\n                head2=head2.next;\\n                head.next=null;\\n                continue;\\n            }\\n            head2.next=res.get(end--);\\n            head2=head2.next;\\n            head.next=null;\\n            head2.next=res.get(start++);\\n            head2=head2.next;\\n            head.next=null;\\n        }\\n       \\n        \\n    }\\n}"
                    },
                    {
                        "username": "pandeyharshit122",
                        "content": "hi\\n"
                    },
                    {
                        "username": "DreamZerone",
                        "content": "hello sir\\n"
                    },
                    {
                        "username": "DreamZerone",
                        "content": "hello guys"
                    },
                    {
                        "username": "crazysamurai",
                        "content": "Find middle -> reverse the list after middle -> merge the two lists"
                    },
                    {
                        "username": "Curious_hritik",
                        "content": " `your inline code...your inline code...`\\n ListNode* swapList(ListNode* head) {\\n    //Each time call swapList will set L(n-i) = Li->next\\n    if (head == NULL || head->next == NULL || head->next->next == NULL) \\n        return head;\\n\\n    ListNode* cur = head;\\n    ListNode* tmp = head->next;\\n    ListNode* prev = head->next;\\n    while (tmp->next != NULL) {\\n        prev = tmp;\\n        tmp = tmp->next;\\n    }\\n    prev->next = NULL;\\n    tmp->next = cur->next;\\n    cur->next = tmp;\\n    cur = cur->next->next;\\n    swapList(cur);\\n    return head;\\n}\\n\\nvoid reorderList(ListNode* head) {\\n    swapList(head);\\n   }\\n};"
                    },
                    {
                        "username": "kokatekuntal",
                        "content": "You can do this in Time -> O(N) and Space -> O(1)\\nThere are other easy approaches in Space -> O(N) using deque, sets, etc.\\n\\n1. Break the list in two almost equal halves (first half should be ceil(n/2) length)\\n2. Reverse the second half\\n3. Now merge lists "
                    },
                    {
                        "username": "jd-0312",
                        "content": "How???? example?"
                    },
                    {
                        "username": "vipin1211",
                        "content": "Just changing the first few lines to the below:\\n`dummy = ListNode()\\ndummy.next = head\\nslow = dummy\\nfast = head`\\n\\nResults in \\'\\'NoneType\\' object has no attribute \\'next\\'\\' exception even though the head holds the right answer, can anyone explain why?"
                    },
                    {
                        "username": "hermit_ops000",
                        "content": "I am quite certain my code is correct returning a linked list of [1,4,2,3] as expected for an input of [1,2,3,4].  But when I run my code on the test case, I get an output of [1,2,3,4] instead (which is wrong).  I am really confused as to why.  \\n\\nIf anyone can take a look at my code and share their thoughts I\\'d really appreciate it.  \\n\\n`# Definition for singly-linked list.\\nclass ListNode(object):\\n    def __init__(self, val=0, next=None):\\n        self.val = val\\n        self.next = next\\n\\nclass Solution(object):\\n    def reorderList(self, head):\\n        \"\"\"\\n        :type head: ListNode\\n        :rtype: None Do not return anything, modify head in-place instead.\\n        \"\"\"\\n\\n        nodes_list = []\\n        insert_cnt = 0\\n\\n        # get values of node into list \\n        while head is not None:\\n            nodes_list.append(head.val)\\n            head = head.next \\n        # print (\"nodes_list\", nodes_list)\\n\\n        # even and odd length arrays \\n        if len(nodes_list) % 2 != 0: # odd len array \\n            midpt_index = int(len(nodes_list)/2)+1 # +1 to mimic ceiling  \\n        else: # even len array \\n            midpt_index = len(nodes_list)/2\\n\\n        # print (midpt_index)\\n\\n        lft_arr = nodes_list[0:midpt_index]\\n        rt_arr = nodes_list[midpt_index:len(nodes_list)+1]\\n        rt_arr_rev = list(reversed(rt_arr))\\n\\n        # print (lft_arr, rt_arr_rev)\\n\\n        for i, val in enumerate(rt_arr_rev):\\n            i_insert = i+1 + insert_cnt\\n            lft_arr.insert(i_insert, val)\\n            insert_cnt += 1\\n\\n        # print (\"lft_arr\", lft_arr)\\n\\n        # convert list into LL\\n        newHead = temp = ListNode()\\n\\n        for val in lft_arr:\\n            # print (\"val\", val)\\n            temp.next = ListNode(val)\\n            temp = temp.next\\n\\n        # print (\"newHead.next\", newHead.next.next.next.next.val)\\n        return newHead.next`"
                    },
                    {
                        "username": "hafid-hub",
                        "content": "You don\\'t need  to return any thing. \\nYou change the values, and it is what the problem ask for.\\nRead again carefully the problem. "
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/8N_L_c71avU"
                    }
                ]
            }
        ]
    },
    {
        "title": "Shortest Word Distance",
        "question_content": null,
        "solutions": [],
        "discussions": [
            {
                "id": 1565161,
                "content": [
                    {
                        "username": "princessmaja",
                        "content": "I don't understand the problem.\\nIf we have an array of words: \\n\\n>  [\"practice\", \"makes\", \"perfect\", \"coding\", \"makes\"]\\n\\nthen \"coding\" and \"practice\" are 2 words apart (\"makes\" and \"perfect\"), not 3 like the problem states.\\nSame as \"makes\" and \"coding\" are 1 word apart.\\n\\nWhat am I missing?"
                    },
                    {
                        "username": "JoyboyBrian",
                        "content": "Yeah. It is comparing indices. Notice that there another \"makes\" in the dictionary, and there are 0 words apart. "
                    },
                    {
                        "username": "JoseRdz",
                        "content": "Imagine you are on a straight line:\n\n> |0|1|2|3|4|\n> |---|---|---|---|---|\n> |practice|makes|perfect|coding|makes|\n\nIf you stand at position 0 (`practice`), how many steps you need to walk to get to position 3 (`coding`)?\n**Ans =** 3 steps\n\nIn other words:\n\n* `coding` is 3 words apart if you are standing on `practice`\n* also `practice` is 3 words apart if you are standing on `coding`\n\nThis is exactly how you would calculate distance between two points on a number line."
                    },
                    {
                        "username": "capp10",
                        "content": "It\\'s comparing the indices"
                    },
                    {
                        "username": "Farissa21",
                        "content": "I used the below solution. But for input wordsDict=[\"practice\", \"makes\", \"perfect\", \"coding\", \"makes\"],word1=\"coding\",word2 =\n\"practice\" the output is 3 when I run the code on google colab. But in leetcode it fails on this test case and shows that my output is sending 1 instead of 3. I dont know what is the issue\n\n\n\n        \n        wordsDict = list(set(wordsDict))\n        index1 = -1\n        index2 = -1\n        for i in range(len(wordsDict)):\n            if wordsDict[i] == word1:\n                index1 = i\n            if wordsDict[i] == word2:\n                index2 = i\n\n        if word1 == word2:\n            return 0\n\n        index = abs(index1 - index2)\n        return index\n"
                    },
                    {
                        "username": "gazeman",
                        "content": "The problem is not clear"
                    }
                ]
            },
            {
                "id": 2062369,
                "content": [
                    {
                        "username": "princessmaja",
                        "content": "I don't understand the problem.\\nIf we have an array of words: \\n\\n>  [\"practice\", \"makes\", \"perfect\", \"coding\", \"makes\"]\\n\\nthen \"coding\" and \"practice\" are 2 words apart (\"makes\" and \"perfect\"), not 3 like the problem states.\\nSame as \"makes\" and \"coding\" are 1 word apart.\\n\\nWhat am I missing?"
                    },
                    {
                        "username": "JoyboyBrian",
                        "content": "Yeah. It is comparing indices. Notice that there another \"makes\" in the dictionary, and there are 0 words apart. "
                    },
                    {
                        "username": "JoseRdz",
                        "content": "Imagine you are on a straight line:\n\n> |0|1|2|3|4|\n> |---|---|---|---|---|\n> |practice|makes|perfect|coding|makes|\n\nIf you stand at position 0 (`practice`), how many steps you need to walk to get to position 3 (`coding`)?\n**Ans =** 3 steps\n\nIn other words:\n\n* `coding` is 3 words apart if you are standing on `practice`\n* also `practice` is 3 words apart if you are standing on `coding`\n\nThis is exactly how you would calculate distance between two points on a number line."
                    },
                    {
                        "username": "capp10",
                        "content": "It\\'s comparing the indices"
                    },
                    {
                        "username": "Farissa21",
                        "content": "I used the below solution. But for input wordsDict=[\"practice\", \"makes\", \"perfect\", \"coding\", \"makes\"],word1=\"coding\",word2 =\n\"practice\" the output is 3 when I run the code on google colab. But in leetcode it fails on this test case and shows that my output is sending 1 instead of 3. I dont know what is the issue\n\n\n\n        \n        wordsDict = list(set(wordsDict))\n        index1 = -1\n        index2 = -1\n        for i in range(len(wordsDict)):\n            if wordsDict[i] == word1:\n                index1 = i\n            if wordsDict[i] == word2:\n                index2 = i\n\n        if word1 == word2:\n            return 0\n\n        index = abs(index1 - index2)\n        return index\n"
                    },
                    {
                        "username": "gazeman",
                        "content": "The problem is not clear"
                    }
                ]
            },
            {
                "id": 2023297,
                "content": [
                    {
                        "username": "princessmaja",
                        "content": "I don't understand the problem.\\nIf we have an array of words: \\n\\n>  [\"practice\", \"makes\", \"perfect\", \"coding\", \"makes\"]\\n\\nthen \"coding\" and \"practice\" are 2 words apart (\"makes\" and \"perfect\"), not 3 like the problem states.\\nSame as \"makes\" and \"coding\" are 1 word apart.\\n\\nWhat am I missing?"
                    },
                    {
                        "username": "JoyboyBrian",
                        "content": "Yeah. It is comparing indices. Notice that there another \"makes\" in the dictionary, and there are 0 words apart. "
                    },
                    {
                        "username": "JoseRdz",
                        "content": "Imagine you are on a straight line:\n\n> |0|1|2|3|4|\n> |---|---|---|---|---|\n> |practice|makes|perfect|coding|makes|\n\nIf you stand at position 0 (`practice`), how many steps you need to walk to get to position 3 (`coding`)?\n**Ans =** 3 steps\n\nIn other words:\n\n* `coding` is 3 words apart if you are standing on `practice`\n* also `practice` is 3 words apart if you are standing on `coding`\n\nThis is exactly how you would calculate distance between two points on a number line."
                    },
                    {
                        "username": "capp10",
                        "content": "It\\'s comparing the indices"
                    },
                    {
                        "username": "Farissa21",
                        "content": "I used the below solution. But for input wordsDict=[\"practice\", \"makes\", \"perfect\", \"coding\", \"makes\"],word1=\"coding\",word2 =\n\"practice\" the output is 3 when I run the code on google colab. But in leetcode it fails on this test case and shows that my output is sending 1 instead of 3. I dont know what is the issue\n\n\n\n        \n        wordsDict = list(set(wordsDict))\n        index1 = -1\n        index2 = -1\n        for i in range(len(wordsDict)):\n            if wordsDict[i] == word1:\n                index1 = i\n            if wordsDict[i] == word2:\n                index2 = i\n\n        if word1 == word2:\n            return 0\n\n        index = abs(index1 - index2)\n        return index\n"
                    },
                    {
                        "username": "gazeman",
                        "content": "The problem is not clear"
                    }
                ]
            }
        ]
    }
]