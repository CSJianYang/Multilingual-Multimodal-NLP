[
    {
        "title": "Kth Largest Sum in a Binary Tree",
        "question_content": "You are given the root of a binary tree and a positive integer k.\nThe level sum in the tree is the sum of the values of the nodes that are on the same level.\nReturn the kth largest level sum in the tree (not necessarily distinct). If there are fewer than k levels in the tree, return -1.\nNote that two nodes are on the same level if they have the same distance from the root.\n&nbsp;\nExample 1:\n\nInput: root = [5,8,9,2,1,3,7,4,6], k = 2\nOutput: 13\nExplanation: The level sums are the following:\n- Level 1: 5.\n- Level 2: 8 + 9 = 17.\n- Level 3: 2 + 1 + 3 + 7 = 13.\n- Level 4: 4 + 6 = 10.\nThe 2nd largest level sum is 13.\n\nExample 2:\n\nInput: root = [1,2,null,3], k = 1\nOutput: 3\nExplanation: The largest level sum is 3.\n\n&nbsp;\nConstraints:\n\n\tThe number of nodes in the tree is n.\n\t2 <= n <= 105\n\t1 <= Node.val <= 106\n\t1 <= k <= n",
        "solutions": [
            {
                "id": 3258219,
                "title": "c-level-order-traversal-priority-queue-beats-100-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nUsing Level Order Traversal find the sum of elements at each level and store them in priority queue. Now return the kth largest element from the priority queue if found otherwise return -1;\\n\\n# Complexity\\n- Time complexity: O(nlogn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    long long kthLargestLevelSum(TreeNode* root, int k) {\\n        vector<vector<int>>v;\\n        int i,n;\\n        if(!root)return -1;        \\n        queue<TreeNode*>q;\\n        priority_queue<long long>pq;\\n        q.push(root);\\n        while(!q.empty()){\\n            n=q.size();\\n            long long sum=0;\\n            for(i=0;i<n;i++){\\n                TreeNode* x = q.front();\\n                q.pop();\\n                sum+=x->val;\\n                if(x->left)q.push(x->left);\\n                if(x->right)q.push(x->right);\\n            }\\n            pq.push(sum);\\n        }\\n        if(pq.size()<k)return -1;\\n        k=k-1;\\n        while(k--)pq.pop();\\n        return pq.top();\\n    }\\n};\\n```\\n\\nFor more such solutions, you can join my telegram channel : \\nhttps://t.me/leetcodegfgdailysolution\\n",
                "solutionTags": [
                    "C++",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    long long kthLargestLevelSum(TreeNode* root, int k) {\\n        vector<vector<int>>v;\\n        int i,n;\\n        if(!root)return -1;        \\n        queue<TreeNode*>q;\\n        priority_queue<long long>pq;\\n        q.push(root);\\n        while(!q.empty()){\\n            n=q.size();\\n            long long sum=0;\\n            for(i=0;i<n;i++){\\n                TreeNode* x = q.front();\\n                q.pop();\\n                sum+=x->val;\\n                if(x->left)q.push(x->left);\\n                if(x->right)q.push(x->right);\\n            }\\n            pq.push(sum);\\n        }\\n        if(pq.size()<k)return -1;\\n        k=k-1;\\n        while(k--)pq.pop();\\n        return pq.top();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3259589,
                "title": "white-board-solution-level-order-traversal-video-solution-intution",
                "content": "# Intuition\\nhttps://www.youtube.com/watch?v=ALxOT9U6rDI\\n\\n# Approach & Intution\\n![image.png](https://assets.leetcode.com/users/images/b0dad850-2cd2-47db-bc37-bd0c01a315e7_1678008143.9924862.png)\\n![image.png](https://assets.leetcode.com/users/images/0092f859-6054-409c-9100-7088f18741cc_1678008152.731945.png)\\n![image.png](https://assets.leetcode.com/users/images/92e3e504-35b9-41c6-97fa-d013d39f524d_1678008159.136446.png)\\n\\n\\n# Code\\n```\\n#define ll long long int\\n\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    long long kthLargestLevelSum(TreeNode* root, int k) {\\n        queue<TreeNode*> q;\\n        q.push(root);\\n        \\n        vector<ll> lvlSum;\\n        \\n        while(!q.empty()){\\n            \\n            ll sum = 0;\\n            queue<TreeNode *> q2;\\n            \\n            while(!q.empty()){\\n                auto cur = q.front();\\n                q.pop();\\n                sum += cur->val;\\n                \\n                if(cur->left != nullptr)\\n                    q2.push(cur->left);\\n                if(cur->right != nullptr)\\n                    q2.push(cur->right);\\n            }\\n            lvlSum.push_back(sum);\\n            q = q2;\\n        }\\n        \\n        sort(lvlSum.begin(), lvlSum.end(), greater<ll>());\\n        \\n        if(lvlSum.size() < k)\\n            return -1;\\n        \\n        return lvlSum[k-1];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n#define ll long long int\\n\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    long long kthLargestLevelSum(TreeNode* root, int k) {\\n        queue<TreeNode*> q;\\n        q.push(root);\\n        \\n        vector<ll> lvlSum;\\n        \\n        while(!q.empty()){\\n            \\n            ll sum = 0;\\n            queue<TreeNode *> q2;\\n            \\n            while(!q.empty()){\\n                auto cur = q.front();\\n                q.pop();\\n                sum += cur->val;\\n                \\n                if(cur->left != nullptr)\\n                    q2.push(cur->left);\\n                if(cur->right != nullptr)\\n                    q2.push(cur->right);\\n            }\\n            lvlSum.push_back(sum);\\n            q = q2;\\n        }\\n        \\n        sort(lvlSum.begin(), lvlSum.end(), greater<ll>());\\n        \\n        if(lvlSum.size() < k)\\n            return -1;\\n        \\n        return lvlSum[k-1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3258099,
                "title": "track-level-sum-o-n",
                "content": "We traverse the tree, tracking the current `depth`.\\n\\nWe use the `lsum` array to track the sum for each `depth`.\\n\\nFinally, we use `lsum` to find out `kth`-largest sum.\\n\\nWe do not have to sort the array, we can use `nth_element` that do the partition in linear time.\\n\\n**C++**\\n```cpp\\nvoid traverse(TreeNode* n, vector<long long> &lsum, int depth = 0) {\\n    if (n == nullptr)\\n        return;\\n    if (lsum.size() == depth)\\n        lsum.push_back(0);\\n    lsum[depth] += n->val;\\n    traverse(n->left, lsum, depth + 1);\\n    traverse(n->right, lsum, depth + 1);\\n}\\nlong long kthLargestLevelSum(TreeNode* root, int k) {\\n    vector<long long> lsum;\\n    traverse(root, lsum);\\n    if (lsum.size() < k)\\n        return -1;\\n    nth_element(begin(lsum), begin(lsum) + k - 1, end(lsum), greater<>());\\n    return lsum[k - 1];\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```cpp\\nvoid traverse(TreeNode* n, vector<long long> &lsum, int depth = 0) {\\n    if (n == nullptr)\\n        return;\\n    if (lsum.size() == depth)\\n        lsum.push_back(0);\\n    lsum[depth] += n->val;\\n    traverse(n->left, lsum, depth + 1);\\n    traverse(n->right, lsum, depth + 1);\\n}\\nlong long kthLargestLevelSum(TreeNode* root, int k) {\\n    vector<long long> lsum;\\n    traverse(root, lsum);\\n    if (lsum.size() < k)\\n        return -1;\\n    nth_element(begin(lsum), begin(lsum) + k - 1, end(lsum), greater<>());\\n    return lsum[k - 1];\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3258523,
                "title": "bfs-sorting-heap",
                "content": "\\n# Approach\\nVery straight forward soln. We have travelled node level by level fashion using BFS. At each level we will keep track of level sum and store it. Different level could have different values. If we sort the level than it becomes easier to go to kth element. Alternatively, we can also maintain heap of size k. \\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long kthLargestLevelSum(TreeNode* root, int k) {\\n        queue<TreeNode*> q;\\n        q.push(root);\\n\\n        long long sum;\\n        vector<long long> level_sum;\\n\\n        while(!q.empty())\\n        {\\n            int sz = q.size();\\n            sum = 0;\\n            for(int i=0; i<sz; i++)\\n            {\\n                TreeNode* node = q.front(); \\n                q.pop();\\n                sum += node->val;\\n                if(node->left) q.push(node->left);\\n                if(node->right) q.push(node->right);\\n            }\\n            level_sum.push_back(sum);\\n        }\\n\\n        int n=level_sum.size();\\n\\n        if(n < k) return -1; //if k is greater than the avaialble level\\n        sort(level_sum.begin(), level_sum.end());\\n        return level_sum[n-k];      //5, 10, 13, 17 \\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long kthLargestLevelSum(TreeNode* root, int k) {\\n        queue<TreeNode*> q;\\n        q.push(root);\\n\\n        long long sum;\\n        vector<long long> level_sum;\\n\\n        while(!q.empty())\\n        {\\n            int sz = q.size();\\n            sum = 0;\\n            for(int i=0; i<sz; i++)\\n            {\\n                TreeNode* node = q.front(); \\n                q.pop();\\n                sum += node->val;\\n                if(node->left) q.push(node->left);\\n                if(node->right) q.push(node->right);\\n            }\\n            level_sum.push_back(sum);\\n        }\\n\\n        int n=level_sum.size();\\n\\n        if(n < k) return -1; //if k is greater than the avaialble level\\n        sort(level_sum.begin(), level_sum.end());\\n        return level_sum[n-k];      //5, 10, 13, 17 \\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3258305,
                "title": "python3-dfs",
                "content": "Please pull this [commit](https://github.com/gaosanyong/leetcode/commit/e3093716659ec141e47ca013abcf405967592686) for solutions of weekly 335. \\n\\n**Intuition**\\nWe can run either a BFS or DFS to collect sum of node values on each level. Here, I choose to do DFS. \\nUpon collecting all such values, I sort the array to retrieve the kth element. \\n**Implementation**\\n```\\nclass Solution:\\n    def kthLargestLevelSum(self, root: Optional[TreeNode], k: int) -> int:\\n        vals = []\\n        stack = [(root, 0)]\\n        while stack: \\n            node, i = stack.pop()\\n            if i == len(vals): vals.append(0)\\n            vals[i] += node.val \\n            if node.left: stack.append((node.left, i+1))\\n            if node.right: stack.append((node.right, i+1))\\n        return sorted(vals, reverse=True)[k-1] if len(vals) >= k else -1\\n```\\n**Complexity**\\nTime `O(NlogN)`\\nSpace `O(N)`",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def kthLargestLevelSum(self, root: Optional[TreeNode], k: int) -> int:\\n        vals = []\\n        stack = [(root, 0)]\\n        while stack: \\n            node, i = stack.pop()\\n            if i == len(vals): vals.append(0)\\n            vals[i] += node.val \\n            if node.left: stack.append((node.left, i+1))\\n            if node.right: stack.append((node.right, i+1))\\n        return sorted(vals, reverse=True)[k-1] if len(vals) >= k else -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3258091,
                "title": "6308-kth-largest-sum-in-a-binary-tree-java-sol",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(n log n) where n is the height of\\xA0the\\xA0tree\\n\\n- Space complexity:\\nO(n) where n is the height of\\xA0the\\xA0tree\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public long kthLargestLevelSum(TreeNode root, int k) {\\n        List<Long> list=new ArrayList<>();\\n        Queue<TreeNode> qu=new LinkedList<>();\\n        qu.offer(root);\\n        while(!qu.isEmpty())\\n        {\\n            int p=qu.size();\\n            long s=0;\\n            for(int i=0;i<p;i++)\\n            {\\n                if(qu.peek().left!=null)\\n                    qu.offer(qu.peek().left);\\n                if(qu.peek().right!=null)\\n                    qu.offer(qu.peek().right);\\n                s+=(long)qu.poll().val;\\n            }\\n            list.add(s);\\n        }\\n        Collections.sort(list);\\n        return k > list.size() ? -1 : list.get(list.size()-k);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public long kthLargestLevelSum(TreeNode root, int k) {\\n        List<Long> list=new ArrayList<>();\\n        Queue<TreeNode> qu=new LinkedList<>();\\n        qu.offer(root);\\n        while(!qu.isEmpty())\\n        {\\n            int p=qu.size();\\n            long s=0;\\n            for(int i=0;i<p;i++)\\n            {\\n                if(qu.peek().left!=null)\\n                    qu.offer(qu.peek().left);\\n                if(qu.peek().right!=null)\\n                    qu.offer(qu.peek().right);\\n                s+=(long)qu.poll().val;\\n            }\\n            list.add(s);\\n        }\\n        Collections.sort(list);\\n        return k > list.size() ? -1 : list.get(list.size()-k);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3270163,
                "title": "c-iterative-level-order-traversal-and-std-nth-element-fast-151ms-100",
                "content": "**TODO(heder): Insert cute cat meme to ask for up-votes. ;)**\\n\\n# Approach 1: iterative level-order traversal and std::nth_element (151ms, 100%?)\\nWe are stiching together level order traversal and finding the kth largest element in a vector.\\n\\n```cpp\\n    static long long kthLargestLevelSum(const TreeNode* root, int k) {\\n        vector<long long> sums;\\n\\n        // Iterative level-order traversal.\\n        queue<const TreeNode*> q;\\n        if (root) q.push(root);\\n        \\n        while (!empty(q)) {\\n            int q_size = size(q);\\n            long long sum = 0;\\n            while (q_size--) {\\n                const TreeNode* node = q.front(); q.pop();\\n                // Visit the node.\\n                sum += node->val;\\n                if (node->left) q.push(node->left);\\n                if (node->right) q.push(node->right);\\n            }\\n            sums.push_back(sum);\\n        }\\n\\n        // Is the tree deep enough?\\n        if (size(sums) < k) return -1;\\n\\n        // Get the kth largest sum.\\n        nth_element(begin(sums), next(begin(sums), k - 1), end(sums), greater<>{});\\n        return sums[k - 1];\\n    }\\n```\\n\\n**Complexity Analysis**\\nLet $$n$$ be the number of nodes in the tree then the\\n  * Time complexity: $$O(n)$$ as we need to visit each node and ```nth_element``` is linear in $$k$$, but $$k$$ is bounded by $$n$$, and the \\n  * Space complexity: $$O(n)$$ as we have at most $$n$$ levels.\\n\\n_As always: Feedback, questions, and comments are welcome. Leaving an up-vote sparks joy! :)_\\n\\n**p.s. Join us on the [LeetCode The Hard Way Discord Server](https://discord.gg/hFUyVyWy2E)!**\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```cpp\\n    static long long kthLargestLevelSum(const TreeNode* root, int k) {\\n        vector<long long> sums;\\n\\n        // Iterative level-order traversal.\\n        queue<const TreeNode*> q;\\n        if (root) q.push(root);\\n        \\n        while (!empty(q)) {\\n            int q_size = size(q);\\n            long long sum = 0;\\n            while (q_size--) {\\n                const TreeNode* node = q.front(); q.pop();\\n                // Visit the node.\\n                sum += node->val;\\n                if (node->left) q.push(node->left);\\n                if (node->right) q.push(node->right);\\n            }\\n            sums.push_back(sum);\\n        }\\n\\n        // Is the tree deep enough?\\n        if (size(sums) < k) return -1;\\n\\n        // Get the kth largest sum.\\n        nth_element(begin(sums), next(begin(sums), k - 1), end(sums), greater<>{});\\n        return sums[k - 1];\\n    }\\n```\n```nth_element```",
                "codeTag": "Unknown"
            },
            {
                "id": 3264087,
                "title": "java-solution-100-time-and-space-complexity",
                "content": "Please **UPVOTE** if you like my solution!\\n\\n```\\nclass Solution {\\n    public long kthLargestLevelSum(TreeNode root, int k) {\\n        if(root == null){\\n            return -1;\\n        }\\n        Queue<TreeNode> q= new LinkedList<>();\\n        q.add(root);\\n        ArrayList<Long> list = new ArrayList<>();\\n\\n        while(!q.isEmpty()){\\n            int size=q.size();\\n            long sum = 0;\\n            for(int i = 0;i<size;i++){\\n                TreeNode temp = q.remove();\\n                sum += temp.val;\\n                if(temp.left != null) {\\n                    q.add(temp.left);\\n                }\\n                if(temp.right != null) {\\n                    q.add(temp.right);\\n                }\\n            }\\n            list.add(sum);\\n        }\\n        \\n        if(k > list.size()){\\n            return -1;\\n        }\\n        Collections.sort(list);\\n        \\n        return list.get(list.size() - k);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long kthLargestLevelSum(TreeNode root, int k) {\\n        if(root == null){\\n            return -1;\\n        }\\n        Queue<TreeNode> q= new LinkedList<>();\\n        q.add(root);\\n        ArrayList<Long> list = new ArrayList<>();\\n\\n        while(!q.isEmpty()){\\n            int size=q.size();\\n            long sum = 0;\\n            for(int i = 0;i<size;i++){\\n                TreeNode temp = q.remove();\\n                sum += temp.val;\\n                if(temp.left != null) {\\n                    q.add(temp.left);\\n                }\\n                if(temp.right != null) {\\n                    q.add(temp.right);\\n                }\\n            }\\n            list.add(sum);\\n        }\\n        \\n        if(k > list.size()){\\n            return -1;\\n        }\\n        Collections.sort(list);\\n        \\n        return list.get(list.size() - k);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3259929,
                "title": "java-100-faster-time-complexity-o-n-space-complexity-o-height-of-binary-tree",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nJust do level order terversal and insert element in priority queue then remove k-1 element from it and return peek element from priority queue...\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nJust do level order terversal and insert element in priority queue then remove k-1 element from it and return peek element from priority queue...\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(Height of Binary Tree)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public long kthLargestLevelSum(TreeNode root, int k) {\\n        PriorityQueue<Long>p=new PriorityQueue<>(Comparator.reverseOrder());\\n        Queue<TreeNode>q=new LinkedList<>();\\n        q.offer(root);\\n        while(q.isEmpty()==false)\\n        {\\n            int n=q.size();\\n            long sum=0;\\n            for(int i=0;i<n;i++)\\n            {\\n                TreeNode t=q.peek();\\n                q.poll();\\n                if(t.left!=null)\\n                    q.offer(t.left);\\n                if(t.right!=null)\\n                    q.offer(t.right);\\n                sum+=t.val;\\n            }\\n            p.add(sum);\\n        }\\n        while(k>1 && !p.isEmpty())\\n        {\\n            k--;\\n            p.poll();\\n        }\\n        if(p.isEmpty())\\n            return -1;\\n        return p.peek();\\n    }\\n}\\nfeel free to ask your doubt happy to help.....\\nIf it help then plz upvote...Thanks!!!\\n```",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search",
                    "Heap (Priority Queue)",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public long kthLargestLevelSum(TreeNode root, int k) {\\n        PriorityQueue<Long>p=new PriorityQueue<>(Comparator.reverseOrder());\\n        Queue<TreeNode>q=new LinkedList<>();\\n        q.offer(root);\\n        while(q.isEmpty()==false)\\n        {\\n            int n=q.size();\\n            long sum=0;\\n            for(int i=0;i<n;i++)\\n            {\\n                TreeNode t=q.peek();\\n                q.poll();\\n                if(t.left!=null)\\n                    q.offer(t.left);\\n                if(t.right!=null)\\n                    q.offer(t.right);\\n                sum+=t.val;\\n            }\\n            p.add(sum);\\n        }\\n        while(k>1 && !p.isEmpty())\\n        {\\n            k--;\\n            p.poll();\\n        }\\n        if(p.isEmpty())\\n            return -1;\\n        return p.peek();\\n    }\\n}\\nfeel free to ask your doubt happy to help.....\\nIf it help then plz upvote...Thanks!!!\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3639547,
                "title": "java-runtime-faster-than-95-level-order-traversal-priority-queue",
                "content": "# Approach\\nUsing Level Order Traversal find the sum of the elements at each level.\\nStore the level sum in the priority queue if it is greater than the first item in the heap or heap size is less than k.\\nReturn the first element from the heap or -1.\\n\\n# Complexity\\n- Time complexity: O(n * logn)\\n- Space complexity: O(n)\\n\\n# Code\\n```\\nclass Solution {\\n    public long kthLargestLevelSum(TreeNode root, int k) {\\n        Queue<Long> heap = new PriorityQueue<>();\\n        Queue<TreeNode> levels = new ArrayDeque<>();\\n        levels.offer(root);\\n\\n        while (!levels.isEmpty()) {\\n            long sum = 0;\\n            int size = levels.size();\\n\\n            for (int i = 0; i < size; i++) {\\n                TreeNode node = levels.poll();\\n                sum += node.val;\\n\\n                if (node.left != null) levels.offer(node.left);\\n                if (node.right != null) levels.offer(node.right);\\n            }\\n\\n            if (heap.size() < k) {\\n                heap.offer(sum);\\n            } else if (heap.peek() < sum) {\\n                heap.poll();\\n                heap.offer(sum);\\n            }\\n        }\\n\\n        return heap.size() < k ? -1 : heap.peek();\\n    }\\n}\\n```\\n\\n![time.png](https://assets.leetcode.com/users/images/ebbb2bc6-a021-49da-bdc9-7a1e0769f0a8_1686801929.6669812.png)\\n",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\n    public long kthLargestLevelSum(TreeNode root, int k) {\\n        Queue<Long> heap = new PriorityQueue<>();\\n        Queue<TreeNode> levels = new ArrayDeque<>();\\n        levels.offer(root);\\n\\n        while (!levels.isEmpty()) {\\n            long sum = 0;\\n            int size = levels.size();\\n\\n            for (int i = 0; i < size; i++) {\\n                TreeNode node = levels.poll();\\n                sum += node.val;\\n\\n                if (node.left != null) levels.offer(node.left);\\n                if (node.right != null) levels.offer(node.right);\\n            }\\n\\n            if (heap.size() < k) {\\n                heap.offer(sum);\\n            } else if (heap.peek() < sum) {\\n                heap.poll();\\n                heap.offer(sum);\\n            }\\n        }\\n\\n        return heap.size() < k ? -1 : heap.peek();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3615162,
                "title": "java-solution-o-n-log-n-using-bfs-for-lvl-order-traversal",
                "content": "# Approach\\nAs problem state we have to perform level order traversal and find the sum of all node at same level\\n**But the crux in this problem**\\nIs that the value k given to us is not the sum we have to return at that number of level\\nHere we have to get all the sum and store it in any data structure and than return  the kth largest value\\n**Like we have 5 10 13 17 and value of k is 3 than it means the 3rd maximum value. like 10 will be the answer**\\n# So steps to solve it\\n- Perform any level order traversal like BFS or DFS here I have use BFS\\n- Now while perorming add the value of node in a variable sum \\n- And now use one arraylist to store the value of sum\\n- Now after traversal sort them\\n- Here our end work if k is <arr.size()return the value of that size-k index \\n- Else our base case which is when k is > than size return -1\\n\\nNow go through the code for better understanding\\n\\n# Complexity\\n- Time complexity:\\n**O(n log(n))** as we traverse to each node and than sort our array for kth largest\\n\\n- Space complexity:\\nThe size of the arraylist as depends on number of levels in our tree\\n\\n\\n**Please upvote it if you like the sollution**\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public long kthLargestLevelSum(TreeNode root, int k) {\\n        Queue<TreeNode>que = new ArrayDeque<TreeNode>();\\n        que.add(root);\\n        int count=-1;\\n        ArrayList<Long>arr = new ArrayList<Long>(); \\n// creating arraylist to store the sum\\n        while(!que.isEmpty()){\\n            int size =que.size();\\n            long sum=0; \\n            while(size-->0){\\n                TreeNode rnode = que.remove();\\n                sum+=rnode.val;\\n// adding the value of all node present on same level\\n                if(rnode.left!=null)que.add(rnode.left);\\n                if(rnode.right!=null)que.add(rnode.right);\\n            }\\n// adding the sum to our arraylist\\n            arr.add(sum);\\n                // count++;\\n                // System.out.println(count);\\n        }\\n        Collections.sort(arr);\\n        if(k-1<arr.size()){\\n// sorting it and getting the index of our answer\\n            int idx = arr.size()-k;\\n            return arr.get(idx);\\n        }\\n        else  return -1;\\n// returning the base case as when k > levels in our tree\\n    }\\n}\\n```\\n# Upvote it or if any doubt ask in comments",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public long kthLargestLevelSum(TreeNode root, int k) {\\n        Queue<TreeNode>que = new ArrayDeque<TreeNode>();\\n        que.add(root);\\n        int count=-1;\\n        ArrayList<Long>arr = new ArrayList<Long>(); \\n// creating arraylist to store the sum\\n        while(!que.isEmpty()){\\n            int size =que.size();\\n            long sum=0; \\n            while(size-->0){\\n                TreeNode rnode = que.remove();\\n                sum+=rnode.val;\\n// adding the value of all node present on same level\\n                if(rnode.left!=null)que.add(rnode.left);\\n                if(rnode.right!=null)que.add(rnode.right);\\n            }\\n// adding the sum to our arraylist\\n            arr.add(sum);\\n                // count++;\\n                // System.out.println(count);\\n        }\\n        Collections.sort(arr);\\n        if(k-1<arr.size()){\\n// sorting it and getting the index of our answer\\n            int idx = arr.size()-k;\\n            return arr.get(idx);\\n        }\\n        else  return -1;\\n// returning the base case as when k > levels in our tree\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3258259,
                "title": "easy-c",
                "content": "# Approach\\nLevel Order Traversal + Finding Kth largest element\\n\\n# Try this:\\nhttps://leetcode.com/problems/kth-largest-element-in-an-array/description/\\nhttps://leetcode.com/problems/binary-tree-level-order-traversal/\\n\\n\\n# Code\\n```\\ntypedef long long ll;\\nclass Solution {\\npublic:\\n    long long kthLargestLevelSum(TreeNode* root, int k) {\\n        priority_queue<ll,vector<ll>,greater<ll>> pq;   //min Priority queue\\n        queue<TreeNode* > qu;\\n        qu.push(root);\\n        int l=0;\\n        while(qu.size()){\\n            int sz=qu.size();\\n            ll sum=0;\\n            for(int i=0;i<sz;i++){\\n                auto fr = qu.front();\\n                sum += (fr->val);\\n                qu.pop();\\n                if(fr->left){\\n                    qu.push(fr->left);\\n                }\\n                if(fr->right){\\n                    qu.push(fr->right);\\n                }\\n            }\\n            l++;\\n            pq.push(sum);\\n            if(l> k){\\n                pq.pop();\\n            }\\n        }\\n        if(k>l)\\n            return -1;\\n        return pq.top();\\n    }\\n    \\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\ntypedef long long ll;\\nclass Solution {\\npublic:\\n    long long kthLargestLevelSum(TreeNode* root, int k) {\\n        priority_queue<ll,vector<ll>,greater<ll>> pq;   //min Priority queue\\n        queue<TreeNode* > qu;\\n        qu.push(root);\\n        int l=0;\\n        while(qu.size()){\\n            int sz=qu.size();\\n            ll sum=0;\\n            for(int i=0;i<sz;i++){\\n                auto fr = qu.front();\\n                sum += (fr->val);\\n                qu.pop();\\n                if(fr->left){\\n                    qu.push(fr->left);\\n                }\\n                if(fr->right){\\n                    qu.push(fr->right);\\n                }\\n            }\\n            l++;\\n            pq.push(sum);\\n            if(l> k){\\n                pq.pop();\\n            }\\n        }\\n        if(k>l)\\n            return -1;\\n        return pq.top();\\n    }\\n    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3258119,
                "title": "clean-simple-java",
                "content": "\\n# Code\\n```java []\\nclass Solution {\\n    List<Long> list = new ArrayList<>();\\n    public long kthLargestLevelSum(TreeNode root, int k) {\\n        collectSum(root,0);\\n        PriorityQueue<Long> pq = new PriorityQueue<>((a,b)->Long.compare(b,a));\\n        pq.addAll(list);\\n        if(pq.size() < k)   return -1;\\n        while(k-- > 1)  pq.poll();\\n        return pq.poll();\\n    }\\n    void collectSum(TreeNode root, int level){\\n        if(root == null)    return;\\n        if(level == list.size()) list.add((long)root.val);\\n        else    list.set(level,list.get(level)+root.val);\\n        collectSum(root.left, level+1);\\n        collectSum(root.right, level+1);\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```java []\\nclass Solution {\\n    List<Long> list = new ArrayList<>();\\n    public long kthLargestLevelSum(TreeNode root, int k) {\\n        collectSum(root,0);\\n        PriorityQueue<Long> pq = new PriorityQueue<>((a,b)->Long.compare(b,a));\\n        pq.addAll(list);\\n        if(pq.size() < k)   return -1;\\n        while(k-- > 1)  pq.poll();\\n        return pq.poll();\\n    }\\n    void collectSum(TreeNode root, int level){\\n        if(root == null)    return;\\n        if(level == list.size()) list.add((long)root.val);\\n        else    list.set(level,list.get(level)+root.val);\\n        collectSum(root.left, level+1);\\n        collectSum(root.right, level+1);\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3258106,
                "title": "c-level-order-traversal-sorting-efficient-code",
                "content": "\\n\\n# Code\\n```\\nclass Solution \\n{\\npublic:\\n    long long kthLargestLevelSum(TreeNode* root, int k) \\n    {\\n        queue<TreeNode*> q;\\n        q.push(root);\\n        long long sum;\\n        vector<long long> level_sum;\\n        while(!q.empty())\\n        {\\n            int sz = q.size();\\n            sum = 0;\\n            for(int i=0; i<sz; i++)\\n            {\\n                TreeNode* node = q.front(); q.pop();\\n                sum += node->val;\\n                if(node->left) q.push(node->left);\\n                if(node->right) q.push(node->right);\\n            }\\n            level_sum.push_back(sum);\\n        }\\n        int n=level_sum.size();\\n        if(n < k) return -1;\\n        sort(level_sum.begin(), level_sum.end());\\n        return level_sum[n-k];       \\n        \\n    }\\n};\\n```\\n\\n# Please upvote if you like this approach :)",
                "solutionTags": [
                    "C++",
                    "Sort",
                    "Queue",
                    "Sorting",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution \\n{\\npublic:\\n    long long kthLargestLevelSum(TreeNode* root, int k) \\n    {\\n        queue<TreeNode*> q;\\n        q.push(root);\\n        long long sum;\\n        vector<long long> level_sum;\\n        while(!q.empty())\\n        {\\n            int sz = q.size();\\n            sum = 0;\\n            for(int i=0; i<sz; i++)\\n            {\\n                TreeNode* node = q.front(); q.pop();\\n                sum += node->val;\\n                if(node->left) q.push(node->left);\\n                if(node->right) q.push(node->right);\\n            }\\n            level_sum.push_back(sum);\\n        }\\n        int n=level_sum.size();\\n        if(n < k) return -1;\\n        sort(level_sum.begin(), level_sum.end());\\n        return level_sum[n-k];       \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3534807,
                "title": "c-level-order-traversal-simple",
                "content": "```\\nclass Solution {\\npublic:\\n    long long kthLargestLevelSum(TreeNode* root, int k) {\\n        priority_queue<long long int,vector<long long int>,greater<long long int>> pq;\\n        long long int ans = 0;\\n        queue<TreeNode*> q;\\n        TreeNode* p;\\n        q.push(root);\\n        int n;\\n        while(!q.empty()){\\n            n = q.size();\\n            ans = 0;\\n            while(n--){\\n                p = q.front();\\n                q.pop();\\n                ans += p->val;\\n                if(p->left)q.push(p->left);\\n                if(p->right)q.push(p->right); \\n            }\\n            pq.push(ans);\\n            if(pq.size()>k){\\n                pq.pop();\\n            }\\n        }\\n        if(pq.size()<k)return -1;\\n        return pq.top();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search",
                    "Tree",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long kthLargestLevelSum(TreeNode* root, int k) {\\n        priority_queue<long long int,vector<long long int>,greater<long long int>> pq;\\n        long long int ans = 0;\\n        queue<TreeNode*> q;\\n        TreeNode* p;\\n        q.push(root);\\n        int n;\\n        while(!q.empty()){\\n            n = q.size();\\n            ans = 0;\\n            while(n--){\\n                p = q.front();\\n                q.pop();\\n                ans += p->val;\\n                if(p->left)q.push(p->left);\\n                if(p->right)q.push(p->right); \\n            }\\n            pq.push(ans);\\n            if(pq.size()>k){\\n                pq.pop();\\n            }\\n        }\\n        if(pq.size()<k)return -1;\\n        return pq.top();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3265686,
                "title": "c-100-faster-level-order-traversal-priority-queue",
                "content": "```c++\\nclass Solution {\\npublic:\\n    long long kthLargestLevelSum(TreeNode* root, int k) {\\n        priority_queue<long long> pq;\\n        vector<TreeNode*> q;\\n        q.push_back(root);\\n\\t\\t\\n        while (q.size()) {\\n            auto sz = q.size();\\n            long long sum = 0;\\n            vector<TreeNode*> temp;\\n            while (sz--) {\\n                auto elem = q.back(); q.pop_back();\\n                sum += elem->val;\\n                if (elem->left) temp.push_back(elem->left);\\n                if (elem->right) temp.push_back(elem->right);\\n            }\\n            pq.push(-sum);\\n            if (pq.size() == k + 1) pq.pop();\\n            swap(temp, q);\\n        }\\n        if (pq.size() != k) return -1;\\n        while (pq.size() != k) pq.pop();\\n        return -pq.top();\\n    }\\n};\\n```\\n\\n**For more solutions, check out this \\uD83C\\uDFC6  [GITHUB REPOSITORY](https://github.com/MuhtasimTanmoy/playground) with over 1500+ solutions.**",
                "solutionTags": [],
                "code": "```c++\\nclass Solution {\\npublic:\\n    long long kthLargestLevelSum(TreeNode* root, int k) {\\n        priority_queue<long long> pq;\\n        vector<TreeNode*> q;\\n        q.push_back(root);\\n\\t\\t\\n        while (q.size()) {\\n            auto sz = q.size();\\n            long long sum = 0;\\n            vector<TreeNode*> temp;\\n            while (sz--) {\\n                auto elem = q.back(); q.pop_back();\\n                sum += elem->val;\\n                if (elem->left) temp.push_back(elem->left);\\n                if (elem->right) temp.push_back(elem->right);\\n            }\\n            pq.push(-sum);\\n            if (pq.size() == k + 1) pq.pop();\\n            swap(temp, q);\\n        }\\n        if (pq.size() != k) return -1;\\n        while (pq.size() != k) pq.pop();\\n        return -pq.top();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3261439,
                "title": "python-3-bfs-queue-t-m-94-86",
                "content": "```\\nclass Solution:\\n    def kthLargestLevelSum(self, root: TreeNode, k: int) -> int:\\n\\n        queue, ans = deque([root]), []\\n\\n        while len(queue) > 0:\\n            count = 0\\n\\n            for _ in range(len(queue)):\\n                node = queue.popleft()\\n\\n                if node.left : queue.append(node.left )\\n                if node.right: queue.append(node.right)\\n\\n                count+= node.val\\n\\n            ans.append(count)\\n\\n        return sorted(ans)[-k] if k <= len(ans) else -1\\n\\n```\\n[https://leetcode.com/problems/kth-largest-sum-in-a-binary-tree/submissions/1031896679/](http://)\\n\\nI could be wrong, but I think that time complexity is *O*(*N*) and space complexity is *O*(*N*).\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def kthLargestLevelSum(self, root: TreeNode, k: int) -> int:\\n\\n        queue, ans = deque([root]), []\\n\\n        while len(queue) > 0:\\n            count = 0\\n\\n            for _ in range(len(queue)):\\n                node = queue.popleft()\\n\\n                if node.left : queue.append(node.left )\\n                if node.right: queue.append(node.right)\\n\\n                count+= node.val\\n\\n            ans.append(count)\\n\\n        return sorted(ans)[-k] if k <= len(ans) else -1\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3259975,
                "title": "100-acceptance-easy-c-approach-beginner-friendly-solution",
                "content": "# Intuition: Easy basic breadth first search (BFS)\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    long long kthLargestLevelSum(TreeNode* root, int k) {\\n        priority_queue<long long >pq;\\n        queue<TreeNode*>q;\\n        q.push(root);\\n        int lev=0;\\n        while(!q.empty()){\\n            int size=q.size();\\n            long long sum=0;\\n            while(size--){\\n                TreeNode* t=q.front();\\n                q.pop();\\n                sum+=t->val;\\n                if(t->left)q.push(t->left);\\n                if(t->right)q.push(t->right);\\n            }\\n            lev++;\\n            pq.push(sum);\\n        }\\n        if(lev<k){\\n            return -1;\\n        }\\n        while(k!=1){\\n            pq.pop();\\n            k--;\\n        }\\n        return pq.top();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Breadth-First Search",
                    "Sorting",
                    "Heap (Priority Queue)",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    long long kthLargestLevelSum(TreeNode* root, int k) {\\n        priority_queue<long long >pq;\\n        queue<TreeNode*>q;\\n        q.push(root);\\n        int lev=0;\\n        while(!q.empty()){\\n            int size=q.size();\\n            long long sum=0;\\n            while(size--){\\n                TreeNode* t=q.front();\\n                q.pop();\\n                sum+=t->val;\\n                if(t->left)q.push(t->left);\\n                if(t->right)q.push(t->right);\\n            }\\n            lev++;\\n            pq.push(sum);\\n        }\\n        if(lev<k){\\n            return -1;\\n        }\\n        while(k!=1){\\n            pq.pop();\\n            k--;\\n        }\\n        return pq.top();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3259893,
                "title": "kth-largest-sum-in-bt-using-level-order-traversal-java",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public long kthLargestLevelSum(TreeNode root, int k) {\\n        if (root == null) return -1;\\n        Queue<TreeNode> queue = new LinkedList<>();\\n        queue.add(root);\\n        ArrayList<Long> list = new ArrayList<>();\\n        while (!queue.isEmpty()) {\\n            int size = queue.size();\\n            long levelSum = 0;\\n            for (int i = 0; i < size; i++) {\\n                TreeNode node = queue.poll();\\n                levelSum += node.val;\\n                if (node.left != null) queue.add(node.left);\\n                if (node.right != null) queue.add(node.right);\\n            }\\n            list.add(levelSum);\\n        }\\n        Collections.sort(list);\\n        if(k>list.size()){\\n            return -1;\\n        }\\n        \\n        return list.get(list.size()-k);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long kthLargestLevelSum(TreeNode root, int k) {\\n        if (root == null) return -1;\\n        Queue<TreeNode> queue = new LinkedList<>();\\n        queue.add(root);\\n        ArrayList<Long> list = new ArrayList<>();\\n        while (!queue.isEmpty()) {\\n            int size = queue.size();\\n            long levelSum = 0;\\n            for (int i = 0; i < size; i++) {\\n                TreeNode node = queue.poll();\\n                levelSum += node.val;\\n                if (node.left != null) queue.add(node.left);\\n                if (node.right != null) queue.add(node.right);\\n            }\\n            list.add(levelSum);\\n        }\\n        Collections.sort(list);\\n        if(k>list.size()){\\n            return -1;\\n        }\\n        \\n        return list.get(list.size()-k);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3258402,
                "title": "simplest-python-level-order",
                "content": "\\n# Code\\n```\\nclass Solution:\\n    def kthLargestLevelSum(self, root: Optional[TreeNode], k: int) -> int:\\n        a = []\\n        \\n        def dfs(node, h):\\n            if not node: return\\n            if h == len(a):\\n                a.append([])\\n            a[h].append(node.val)\\n            dfs(node.left, h+1)\\n            dfs(node.right, h+1)\\n        \\n        dfs(root, 0)\\n        ans = []\\n        for i in range(len(a)):\\n            ans.append(sum(a[i]))\\n            \\n        return sorted(ans)[-k] if len(ans) >= k else -1\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def kthLargestLevelSum(self, root: Optional[TreeNode], k: int) -> int:\\n        a = []\\n        \\n        def dfs(node, h):\\n            if not node: return\\n            if h == len(a):\\n                a.append([])\\n            a[h].append(node.val)\\n            dfs(node.left, h+1)\\n            dfs(node.right, h+1)\\n        \\n        dfs(root, 0)\\n        ans = []\\n        for i in range(len(a)):\\n            ans.append(sum(a[i]))\\n            \\n        return sorted(ans)[-k] if len(ans) >= k else -1\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3258237,
                "title": "java-bfs-o-n-time-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n  public long kthLargestLevelSum(TreeNode root, int k) {\\n    var queue = new PriorityQueue<Long>(Collections.reverseOrder());\\n    var q = new ArrayDeque<TreeNode>();\\n    q.offer(root);\\n    \\n    while (!q.isEmpty()) {\\n      var sum = 0L;\\n      \\n      for (var i = q.size(); i>0; i--) {\\n        var node = q.poll();\\n        \\n        sum += node.val;\\n        if (node.left != null) q.offer(node.left);\\n        if (node.right != null) q.offer(node.right);\\n      }\\n      queue.offer(sum);\\n    }\\n    if (queue.size() < k) return -1;\\n    \\n    while (--k > 0) queue.poll();\\n    \\n    return queue.poll();\\n  }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\n  public long kthLargestLevelSum(TreeNode root, int k) {\\n    var queue = new PriorityQueue<Long>(Collections.reverseOrder());\\n    var q = new ArrayDeque<TreeNode>();\\n    q.offer(root);\\n    \\n    while (!q.isEmpty()) {\\n      var sum = 0L;\\n      \\n      for (var i = q.size(); i>0; i--) {\\n        var node = q.poll();\\n        \\n        sum += node.val;\\n        if (node.left != null) q.offer(node.left);\\n        if (node.right != null) q.offer(node.right);\\n      }\\n      queue.offer(sum);\\n    }\\n    if (queue.size() < k) return -1;\\n    \\n    while (--k > 0) queue.poll();\\n    \\n    return queue.poll();\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3258152,
                "title": "simple-bfs-solution-level-traversal",
                "content": "\\n\\n\\n\\n# Code\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def kthLargestLevelSum(self, root: Optional[TreeNode], k: int) -> int:\\n        q = collections.deque([root])\\n        sum_by_level = []\\n        while q:\\n            tmp_sum = 0\\n            for i in range(len(q)):\\n                node = q.popleft()\\n                tmp_sum += node.val\\n                if node.left:\\n                    q.append(node.left)\\n                if node.right:\\n                    q.append(node.right)\\n            sum_by_level.append(tmp_sum)\\n        if len(sum_by_level) < k:\\n            return -1\\n        else:\\n            sum_by_level.sort(reverse=True)\\n            return sum_by_level[k-1]\\n            \\n            \\n            \\n            \\n            \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def kthLargestLevelSum(self, root: Optional[TreeNode], k: int) -> int:\\n        q = collections.deque([root])\\n        sum_by_level = []\\n        while q:\\n            tmp_sum = 0\\n            for i in range(len(q)):\\n                node = q.popleft()\\n                tmp_sum += node.val\\n                if node.left:\\n                    q.append(node.left)\\n                if node.right:\\n                    q.append(node.right)\\n            sum_by_level.append(tmp_sum)\\n        if len(sum_by_level) < k:\\n            return -1\\n        else:\\n            sum_by_level.sort(reverse=True)\\n            return sum_by_level[k-1]\\n            \\n            \\n            \\n            \\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3258118,
                "title": "easy-java-solution-level-order-traversal",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public long kthLargestLevelSum(TreeNode root, int k) {\\n        Queue<TreeNode> q=new LinkedList<>();\\n        long ans=0;\\n        q.offer(root);\\n        ArrayList<Long> sub=new ArrayList<>();\\n        while(!q.isEmpty()){\\n            int size=q.size();\\n            long sum=0;\\n            \\n            for(int i=0;i<size;i++){\\n                TreeNode node=q.poll();\\n                if(node.left!=null){\\n                    q.offer(node.left);\\n                }\\n                if(node.right!=null){\\n                    q.offer(node.right);\\n                }\\n                sum+=node.val;\\n            }\\n            sub.add(sum);\\n        }\\n        Collections.sort(sub,Collections.reverseOrder());\\n        if(sub.size()>=k){\\n            ans=sub.get(k-1);\\n            return ans;\\n        }\\n        \\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public long kthLargestLevelSum(TreeNode root, int k) {\\n        Queue<TreeNode> q=new LinkedList<>();\\n        long ans=0;\\n        q.offer(root);\\n        ArrayList<Long> sub=new ArrayList<>();\\n        while(!q.isEmpty()){\\n            int size=q.size();\\n            long sum=0;\\n            \\n            for(int i=0;i<size;i++){\\n                TreeNode node=q.poll();\\n                if(node.left!=null){\\n                    q.offer(node.left);\\n                }\\n                if(node.right!=null){\\n                    q.offer(node.right);\\n                }\\n                sum+=node.val;\\n            }\\n            sub.add(sum);\\n        }\\n        Collections.sort(sub,Collections.reverseOrder());\\n        if(sub.size()>=k){\\n            ans=sub.get(k-1);\\n            return ans;\\n        }\\n        \\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4034884,
                "title": "kth-largest-sum-in-a-binary-tree-o-n-javascript-memory-95-45-meaningful-vars",
                "content": "Time Complexity: O(NLogN)\\nSpace Complexity: O(N)\\n```\\nvar kthLargestLevelSum = function (root, k) {\\n    const config = {};\\n    var kthLargestLevelSumHelper = function (root, level = 1) {\\n        if (!root) {\\n            return;\\n        }\\n        const value = root.val || 0;\\n        if (!config[level]) {\\n            config[level] = 0;\\n        }\\n        const prevSum = config[level];\\n        const totalSum = prevSum + value;\\n        config[level] = totalSum;\\n        kthLargestLevelSumHelper(root.left, level + 1);\\n        kthLargestLevelSumHelper(root.right, level + 1);\\n    };\\n    kthLargestLevelSumHelper(root);\\n    const sorted = Object.values(config).sort((a, b) => a - b);\\n    if (sorted[Object.keys(config).length - k] === undefined) {\\n        return -1\\n    }\\n    return sorted[Object.keys(config).length - k] || -1;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar kthLargestLevelSum = function (root, k) {\\n    const config = {};\\n    var kthLargestLevelSumHelper = function (root, level = 1) {\\n        if (!root) {\\n            return;\\n        }\\n        const value = root.val || 0;\\n        if (!config[level]) {\\n            config[level] = 0;\\n        }\\n        const prevSum = config[level];\\n        const totalSum = prevSum + value;\\n        config[level] = totalSum;\\n        kthLargestLevelSumHelper(root.left, level + 1);\\n        kthLargestLevelSumHelper(root.right, level + 1);\\n    };\\n    kthLargestLevelSumHelper(root);\\n    const sorted = Object.values(config).sort((a, b) => a - b);\\n    if (sorted[Object.keys(config).length - k] === undefined) {\\n        return -1\\n    }\\n    return sorted[Object.keys(config).length - k] || -1;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3840292,
                "title": "python-3-simple-bfs-with-sorting-beats-100-424ms",
                "content": "```\\nclass Solution:\\n    def kthLargestLevelSum(self, root: Optional[TreeNode], k: int) -> int:\\n        levels, queue = [], deque([root])\\n\\n        while queue and root:\\n            levelSum = 0\\n            for _ in range(len(queue)):\\n                node = queue.popleft()\\n                levelSum += node.val\\n                if node.left: queue.append(node.left)\\n                if node.right: queue.append(node.right)\\n            levels.append(levelSum)\\n        \\n        if len(levels) < k: return -1\\n        \\n        levels.sort(reverse = True)\\n        \\n        return levels[k-1]\\n```\\n![Screenshot 2023-07-31 at 00.14.44.png](https://assets.leetcode.com/users/images/58799f4c-59eb-4479-af86-397059cccdb7_1690751695.0340154.png)\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Tree",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def kthLargestLevelSum(self, root: Optional[TreeNode], k: int) -> int:\\n        levels, queue = [], deque([root])\\n\\n        while queue and root:\\n            levelSum = 0\\n            for _ in range(len(queue)):\\n                node = queue.popleft()\\n                levelSum += node.val\\n                if node.left: queue.append(node.left)\\n                if node.right: queue.append(node.right)\\n            levels.append(levelSum)\\n        \\n        if len(levels) < k: return -1\\n        \\n        levels.sort(reverse = True)\\n        \\n        return levels[k-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3640533,
                "title": "python-simple-and-clean-beats-93-99",
                "content": "### Please upvote if you find this helpful. \\u270C\\n<img src=\"https://assets.leetcode.com/users/images/b8e25620-d320-420a-ae09-94c7453bd033_1678818986.7001078.jpeg\" alt=\"Cute Robot - Stable diffusion\" width=\"200\"/>\\n\\n# Intuition\\nThe problem asks us to find the kth largest level sum in a binary tree. One way to approach this problem is to use a breadth-first search (BFS) algorithm to traverse the tree level by level and keep track of the sum of values of nodes at each level. Then, we can sort the list of sums in descending order and return the kth element.\\n\\n# Approach\\n1. Initialize a list `sums` to store the sum of values of nodes at each level.\\n2. Initialize a queue with the root node.\\n3. While the queue is not empty:\\n    1. Initialize a list `nodes` to store all nodes in the current level.\\n    2. Dequeue all nodes from the queue and add them to `nodes`.\\n    3. Initialize a variable `curr` to store the sum of values of nodes in the current level.\\n    4. For each node in `nodes`, add its value to `curr` and enqueue its left and right children if they exist.\\n    5. Append `curr` to `sums`.\\n4. Sort `sums` in descending order.\\n5. If there are fewer than k levels in the tree, return -1.\\n6. Return the kth element in `sums`.\\n\\n# Complexity\\n- Time complexity: $$O(n + n \\\\log n)$$ where n is the number of nodes in the tree.\\n- Space complexity: $$O(n)$$ where n is the number of nodes in the tree.\\n\\n# Code\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\n\\nclass Solution:\\n    def kthLargestLevelSum(self, root: Optional[TreeNode], k: int) -> int:\\n        # Initialize a list to store the sum of values of nodes at each level\\n        sums = []\\n        # Initialize a queue with the root node\\n        queue = deque([root])\\n        # While the queue is not empty\\n        while queue:\\n            # Initialize a list to store all nodes in the current level\\n            nodes = []\\n            # Dequeue all nodes from the queue and add them to nodes\\n            while queue:\\n                nodes.append(queue.popleft())\\n            # Initialize curr to store the sum of values of nodes in the current level\\n            curr = 0\\n            # For each node in nodes\\n            for node in nodes:\\n                # Add its value to curr\\n                curr += node.val\\n                # Enqueue its left and right children if they exist\\n                if node.left:\\n                    queue.append(node.left)\\n                if node.right:\\n                    queue.append(node.right)\\n            # Append curr to sums\\n            sums.append(curr)\\n        # Sort sums in descending order\\n        sums.sort(reverse=True)\\n        # If there are fewer than k levels in the tree, return -1\\n        if len(sums) - 1 < k - 1:\\n            return -1\\n        # Return the kth element in sums\\n        return sums[k - 1]\\n```",
                "solutionTags": [
                    "Python3",
                    "Tree",
                    "Breadth-First Search",
                    "Queue",
                    "Sorting"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\n\\nclass Solution:\\n    def kthLargestLevelSum(self, root: Optional[TreeNode], k: int) -> int:\\n        # Initialize a list to store the sum of values of nodes at each level\\n        sums = []\\n        # Initialize a queue with the root node\\n        queue = deque([root])\\n        # While the queue is not empty\\n        while queue:\\n            # Initialize a list to store all nodes in the current level\\n            nodes = []\\n            # Dequeue all nodes from the queue and add them to nodes\\n            while queue:\\n                nodes.append(queue.popleft())\\n            # Initialize curr to store the sum of values of nodes in the current level\\n            curr = 0\\n            # For each node in nodes\\n            for node in nodes:\\n                # Add its value to curr\\n                curr += node.val\\n                # Enqueue its left and right children if they exist\\n                if node.left:\\n                    queue.append(node.left)\\n                if node.right:\\n                    queue.append(node.right)\\n            # Append curr to sums\\n            sums.append(curr)\\n        # Sort sums in descending order\\n        sums.sort(reverse=True)\\n        # If there are fewer than k levels in the tree, return -1\\n        if len(sums) - 1 < k - 1:\\n            return -1\\n        # Return the kth element in sums\\n        return sums[k - 1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3592387,
                "title": "typescript-javascript-bfs-quick-select-easy-to-understand",
                "content": "#### Complexity\\nTime O(n) | Space O(n)\\n```\\nfunction kthLargestLevelSum(root: TreeNode | null, k: number): number {\\n    const nums = bfs(root);\\n    return quickSelect(nums, k);\\n};\\n\\nfunction bfs(root: TreeNode | null): number[] {\\n    const result: number[] = []\\n    const queue = [root];\\n    \\n    while (queue.length) {\\n        const n = queue.length;\\n        let levelSum = 0;\\n        \\n        for (let i = 0; i < n; i++) {\\n            const node = queue.shift();\\n            levelSum += node.val;\\n            if (node.left) queue.push(node.left);\\n            if (node.right) queue.push(node.right);\\n        }\\n        \\n        result.push(levelSum);\\n    }\\n    \\n    return result;\\n}\\n\\nfunction quickSelect(nums: number[], k: number): number {\\n    const targetIdx = nums.length - k;\\n    let leftIdx = 0;\\n    let rightIdx = nums.length - 1;\\n    \\n    while (leftIdx <= rightIdx) {\\n        const randomIdx = getRandomIdx(leftIdx, rightIdx);\\n        const partitionIdx = getPartitionIdx(nums, leftIdx, rightIdx, randomIdx);\\n        \\n        if (partitionIdx === targetIdx) {\\n            return nums[partitionIdx];\\n        } else if (partitionIdx < targetIdx) {\\n            leftIdx = partitionIdx + 1;\\n        } else {\\n            rightIdx = partitionIdx - 1;\\n        }\\n    }\\n    \\n    return -1;\\n}\\n\\nfunction getPartitionIdx(nums: number[], leftIdx: number, rightIdx: number, randomIdx: number): number {\\n    let partitionIdx = leftIdx;\\n    const randomVal = nums[randomIdx];\\n    swap(nums, randomIdx, rightIdx);\\n    \\n    for (let i = leftIdx; i < rightIdx; i++) {\\n        const currVal = nums[i];\\n        if (currVal < randomVal) {\\n            swap(nums, i, partitionIdx);\\n            partitionIdx++;\\n        }\\n    }\\n    \\n    swap(nums, partitionIdx, rightIdx);\\n    return partitionIdx;\\n};\\n\\nfunction getRandomIdx(leftIdx: number, rightIdx: number): number {\\n    return Math.floor(Math.random() * (rightIdx - leftIdx + 1)) + leftIdx;\\n}\\n\\nfunction swap(arr: number[], i: number, j: number): void {\\n    [arr[i], arr[j]] = [arr[j], arr[i]]\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript",
                    "Breadth-First Search",
                    "Quickselect"
                ],
                "code": "```\\nfunction kthLargestLevelSum(root: TreeNode | null, k: number): number {\\n    const nums = bfs(root);\\n    return quickSelect(nums, k);\\n};\\n\\nfunction bfs(root: TreeNode | null): number[] {\\n    const result: number[] = []\\n    const queue = [root];\\n    \\n    while (queue.length) {\\n        const n = queue.length;\\n        let levelSum = 0;\\n        \\n        for (let i = 0; i < n; i++) {\\n            const node = queue.shift();\\n            levelSum += node.val;\\n            if (node.left) queue.push(node.left);\\n            if (node.right) queue.push(node.right);\\n        }\\n        \\n        result.push(levelSum);\\n    }\\n    \\n    return result;\\n}\\n\\nfunction quickSelect(nums: number[], k: number): number {\\n    const targetIdx = nums.length - k;\\n    let leftIdx = 0;\\n    let rightIdx = nums.length - 1;\\n    \\n    while (leftIdx <= rightIdx) {\\n        const randomIdx = getRandomIdx(leftIdx, rightIdx);\\n        const partitionIdx = getPartitionIdx(nums, leftIdx, rightIdx, randomIdx);\\n        \\n        if (partitionIdx === targetIdx) {\\n            return nums[partitionIdx];\\n        } else if (partitionIdx < targetIdx) {\\n            leftIdx = partitionIdx + 1;\\n        } else {\\n            rightIdx = partitionIdx - 1;\\n        }\\n    }\\n    \\n    return -1;\\n}\\n\\nfunction getPartitionIdx(nums: number[], leftIdx: number, rightIdx: number, randomIdx: number): number {\\n    let partitionIdx = leftIdx;\\n    const randomVal = nums[randomIdx];\\n    swap(nums, randomIdx, rightIdx);\\n    \\n    for (let i = leftIdx; i < rightIdx; i++) {\\n        const currVal = nums[i];\\n        if (currVal < randomVal) {\\n            swap(nums, i, partitionIdx);\\n            partitionIdx++;\\n        }\\n    }\\n    \\n    swap(nums, partitionIdx, rightIdx);\\n    return partitionIdx;\\n};\\n\\nfunction getRandomIdx(leftIdx: number, rightIdx: number): number {\\n    return Math.floor(Math.random() * (rightIdx - leftIdx + 1)) + leftIdx;\\n}\\n\\nfunction swap(arr: number[], i: number, j: number): void {\\n    [arr[i], arr[j]] = [arr[j], arr[i]]\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3293234,
                "title": "easy-java-solution-level-order-beginner-friendly",
                "content": "**If you really found my solution helpful please upvote it, as it motivates me to post such kind of codes and help the coding community, if you have some queries or some improvements please feel free to comment and share your views.**\\n# Code\\n```\\nclass Solution {\\n    public long kthLargestLevelSum(TreeNode root, int k) {\\n        ArrayList<Long> al = new ArrayList<Long>();\\n        Queue<TreeNode> queue = new LinkedList<>();\\n        queue.add(root);\\n        while(!queue.isEmpty()){\\n            int n = queue.size();\\n            Long sum = (long)0;\\n            for(int i = 0 ; i < n; i ++){\\n                TreeNode node = queue.poll();\\n                sum += node.val;\\n                if(node.left != null){\\n                    queue.add(node.left);\\n                }\\n                if(node.right != null){\\n                    queue.add(node.right);\\n                } \\n            }\\n            al.add(sum);\\n        }\\n        Collections.sort(al);\\n        if(al.size() >= k){\\n            return al.get(al.size()-k);\\n        }\\n        return -1;\\n    }\\n}\\n```\\n![42b90dac-a6e9-4f9d-99f5-d07a676b1819_1676256247.436845.jpeg](https://assets.leetcode.com/users/images/6acc45d2-1cf9-4623-b564-bff25a6bacb9_1678731135.6722653.jpeg)\\n",
                "solutionTags": [
                    "Java",
                    "Tree"
                ],
                "code": "```\\nclass Solution {\\n    public long kthLargestLevelSum(TreeNode root, int k) {\\n        ArrayList<Long> al = new ArrayList<Long>();\\n        Queue<TreeNode> queue = new LinkedList<>();\\n        queue.add(root);\\n        while(!queue.isEmpty()){\\n            int n = queue.size();\\n            Long sum = (long)0;\\n            for(int i = 0 ; i < n; i ++){\\n                TreeNode node = queue.poll();\\n                sum += node.val;\\n                if(node.left != null){\\n                    queue.add(node.left);\\n                }\\n                if(node.right != null){\\n                    queue.add(node.right);\\n                } \\n            }\\n            al.add(sum);\\n        }\\n        Collections.sort(al);\\n        if(al.size() >= k){\\n            return al.get(al.size()-k);\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3279304,
                "title": "kth-largest-sum-in-a-binary-tree-using-bfs-max-heap",
                "content": "\\n\\n# Complexity\\n- Time complexity: O(n)\\n\\n- Space complexity:O(n)\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\npublic class Solution {\\n    public long kthLargestLevelSum(TreeNode root, int k) {\\n        if (root == null) return -1;\\n        Queue<TreeNode> q = new LinkedList<>();\\n        PriorityQueue<Long> pq = new PriorityQueue<>(Collections.reverseOrder());\\n        q.add(root);\\n        while (!q.isEmpty()) {\\n            int size = q.size();\\n            long sum = 0;\\n            for (int i = 0; i < size; i++) {\\n                TreeNode curr = q.poll();\\n                if (curr != null)\\n                    sum += curr.val;\\n                if (curr.left != null) q.add(curr.left);\\n                if (curr.right != null) q.add(curr.right);\\n\\n            }\\n            pq.add(sum);\\n        }\\n        if (k > pq.size()) return -1;\\n        while (!pq.isEmpty() && k-- > 1) {\\n            pq.poll();\\n        }\\n        return pq.peek();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\npublic class Solution {\\n    public long kthLargestLevelSum(TreeNode root, int k) {\\n        if (root == null) return -1;\\n        Queue<TreeNode> q = new LinkedList<>();\\n        PriorityQueue<Long> pq = new PriorityQueue<>(Collections.reverseOrder());\\n        q.add(root);\\n        while (!q.isEmpty()) {\\n            int size = q.size();\\n            long sum = 0;\\n            for (int i = 0; i < size; i++) {\\n                TreeNode curr = q.poll();\\n                if (curr != null)\\n                    sum += curr.val;\\n                if (curr.left != null) q.add(curr.left);\\n                if (curr.right != null) q.add(curr.right);\\n\\n            }\\n            pq.add(sum);\\n        }\\n        if (k > pq.size()) return -1;\\n        while (!pq.isEmpty() && k-- > 1) {\\n            pq.poll();\\n        }\\n        return pq.peek();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3265046,
                "title": "c-simple-code-easy-to-understand",
                "content": "# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    void levelOrder(TreeNode* root, int n, map<long long, long long> &m)\\n    {\\n        if(!root) return;\\n        m[n]+=root->val;\\n        levelOrder(root->left, n+1, m);\\n        levelOrder(root->right, n+1, m);\\n    }\\n    long long kthLargestLevelSum(TreeNode* root, int k) {\\n        vector<long long> ans;\\n        map<long long, long long> m;\\n        levelOrder(root, 0, m);\\n        for(auto i:m){\\n            cout<<i.first<<\" \"<<i.second<<endl;\\n            ans.push_back(i.second);\\n        }\\n            \\n        \\n        if(ans.size()<k) return -1;\\n        \\n        sort(ans.begin(), ans.end(),greater<long long>());\\n        return ans[k-1];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    void levelOrder(TreeNode* root, int n, map<long long, long long> &m)\\n    {\\n        if(!root) return;\\n        m[n]+=root->val;\\n        levelOrder(root->left, n+1, m);\\n        levelOrder(root->right, n+1, m);\\n    }\\n    long long kthLargestLevelSum(TreeNode* root, int k) {\\n        vector<long long> ans;\\n        map<long long, long long> m;\\n        levelOrder(root, 0, m);\\n        for(auto i:m){\\n            cout<<i.first<<\" \"<<i.second<<endl;\\n            ans.push_back(i.second);\\n        }\\n            \\n        \\n        if(ans.size()<k) return -1;\\n        \\n        sort(ans.begin(), ans.end(),greater<long long>());\\n        return ans[k-1];\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3263373,
                "title": "100-fastetst-100-less-memeory-cpp-solution",
                "content": "![image](https://assets.leetcode.com/users/images/6b4963f4-f82b-491b-9b5e-2252f70e6af4_1678088672.3978004.png)\\n\\n```\\n\\n```",
                "solutionTags": [
                    "Array",
                    "Sorting"
                ],
                "code": "```\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3259478,
                "title": "easy-to-understand-c-breadth-first-search-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nAt each level keep the sum of that level, that can be done usinig bfs to store the sum i have taken a vector of size 10^5 with -1 as value this can be optimized and last sorted the array and then reversed from that easy to return kth element. \\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(nlog(n)) for sorting the vector\\nO(n) for reverse ,overall O(nlog(n));\\n\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n);\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    long long kthLargestLevelSum(TreeNode* root, int k) {\\n        if(root==NULL)\\n        return -1;\\n\\n        queue<pair<TreeNode*,int>> q;\\n        q.push({root,0});\\n\\n        vector<long long> ans(1000000,-1);\\n        while(!q.empty())\\n        {\\n           \\n            TreeNode* node = q.front().first;\\n             int currlevel = q.front().second;\\n            q.pop();\\n            if(ans[currlevel] != -1)\\n            {\\n                ans[currlevel] += node->val;\\n            }\\n            else\\n                ans[currlevel] = node->val;\\n            \\n            if(node->left) q.push({node->left,currlevel+1});\\n            if(node->right)  q.push({node->right,currlevel+1});\\n            \\n        }\\n        sort(ans.begin(),ans.end());\\n        reverse(ans.begin(),ans.end());\\n        return ans[k-1];\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Breadth-First Search"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    long long kthLargestLevelSum(TreeNode* root, int k) {\\n        if(root==NULL)\\n        return -1;\\n\\n        queue<pair<TreeNode*,int>> q;\\n        q.push({root,0});\\n\\n        vector<long long> ans(1000000,-1);\\n        while(!q.empty())\\n        {\\n           \\n            TreeNode* node = q.front().first;\\n             int currlevel = q.front().second;\\n            q.pop();\\n            if(ans[currlevel] != -1)\\n            {\\n                ans[currlevel] += node->val;\\n            }\\n            else\\n                ans[currlevel] = node->val;\\n            \\n            if(node->left) q.push({node->left,currlevel+1});\\n            if(node->right)  q.push({node->right,currlevel+1});\\n            \\n        }\\n        sort(ans.begin(),ans.end());\\n        reverse(ans.begin(),ans.end());\\n        return ans[k-1];\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3258956,
                "title": "easy-to-understand-c-solution-using-bfs",
                "content": "# Code\\n```\\npublic class Solution \\n{\\n    public long KthLargestLevelSum(TreeNode root, int k)\\n    {\\n        var level = 0;\\n        var result = BFS(root, ref level);\\n\\n        result.Sort();\\n\\n        if (k >= 0 && k <= level)\\n        {\\n            return result[^k];\\n        }\\n\\n        return -1;\\n    }\\n\\n    private List<long> BFS(TreeNode root, ref int level)\\n    {\\n        var result = new List<long>();\\n\\n        if (root == null)\\n        {\\n            return result;\\n        }\\n\\n        var queue = new Queue<TreeNode>();\\n        queue.Enqueue(root);\\n\\n        while (queue.Count != 0)\\n        {\\n            var size = queue.Count;\\n            var sum = 0L;\\n\\n            for (var i = 0; i < size; i++)\\n            {\\n                var current = queue.Dequeue();\\n                sum += current.val;\\n\\n                if (current.left != null)\\n                {\\n                    queue.Enqueue(current.left);\\n                }\\n\\n                if (current.right != null)\\n                {\\n                    queue.Enqueue(current.right);\\n                }\\n            }\\n\\n            result.Add(sum);\\n            level++;\\n        }\\n\\n        return result;\\n    }\\n}\\n```\\n\\n![pleaseupvote.jpg](https://assets.leetcode.com/users/images/b6dca9e0-f7a9-4cb6-8a0c-2389093a7bf5_1677997884.975703.jpeg)\\n",
                "solutionTags": [
                    "C#",
                    "Breadth-First Search",
                    "Binary Tree"
                ],
                "code": "```\\npublic class Solution \\n{\\n    public long KthLargestLevelSum(TreeNode root, int k)\\n    {\\n        var level = 0;\\n        var result = BFS(root, ref level);\\n\\n        result.Sort();\\n\\n        if (k >= 0 && k <= level)\\n        {\\n            return result[^k];\\n        }\\n\\n        return -1;\\n    }\\n\\n    private List<long> BFS(TreeNode root, ref int level)\\n    {\\n        var result = new List<long>();\\n\\n        if (root == null)\\n        {\\n            return result;\\n        }\\n\\n        var queue = new Queue<TreeNode>();\\n        queue.Enqueue(root);\\n\\n        while (queue.Count != 0)\\n        {\\n            var size = queue.Count;\\n            var sum = 0L;\\n\\n            for (var i = 0; i < size; i++)\\n            {\\n                var current = queue.Dequeue();\\n                sum += current.val;\\n\\n                if (current.left != null)\\n                {\\n                    queue.Enqueue(current.left);\\n                }\\n\\n                if (current.right != null)\\n                {\\n                    queue.Enqueue(current.right);\\n                }\\n            }\\n\\n            result.Add(sum);\\n            level++;\\n        }\\n\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3258809,
                "title": "python-solution-with-best-level-order-traversal-template",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nUsed Level Order Traversal Template\\n\\n```\\nq = [root]\\n\\nwhile q:\\n    level_order_values = [i.val for i in q]\\n    q = [child for p in q for child in [p.left, p.right] if child]\\n\\n```\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- Find Level Order Sum\\n- Put Sum in heap\\n- Find Kth largest Sum\\n\\n# Complexity\\n### Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n- O(N) To find Level Sum and O(N log N) to find Kth Largest \\n- Total Time Complexity : O ( N (1+ log N))\\n\\n### Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n- O(N) - To store Level Sum in heap\\n\\n# Code\\n```\\n# Definition for a binary tree node.\\nclass TreeNode:\\n    def __init__(self, val=0, left=None, right=None):\\n        self.val = val\\n        self.left = left\\n        self.right = right\\n        \\nclass Solution:\\n    def kthLargestLevelSum(self, root: Optional[TreeNode], k: int) -> int:\\n\\n        q = [root]\\n        heap = []\\n\\n        while q:\\n            level_sum = sum([i.val for i in q])\\n            heapq.heappush(heap, -level_sum)\\n            q = [child for p in q for child in [p.left, p.right] if child]\\n\\n        result = -1\\n        while k :\\n            result = -heapq.heappop(heap) if heap else -1\\n            k-=1\\n\\n        return result\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nq = [root]\\n\\nwhile q:\\n    level_order_values = [i.val for i in q]\\n    q = [child for p in q for child in [p.left, p.right] if child]\\n\\n```\n```\\n# Definition for a binary tree node.\\nclass TreeNode:\\n    def __init__(self, val=0, left=None, right=None):\\n        self.val = val\\n        self.left = left\\n        self.right = right\\n        \\nclass Solution:\\n    def kthLargestLevelSum(self, root: Optional[TreeNode], k: int) -> int:\\n\\n        q = [root]\\n        heap = []\\n\\n        while q:\\n            level_sum = sum([i.val for i in q])\\n            heapq.heappush(heap, -level_sum)\\n            q = [child for p in q for child in [p.left, p.right] if child]\\n\\n        result = -1\\n        while k :\\n            result = -heapq.heappop(heap) if heap else -1\\n            k-=1\\n\\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3258437,
                "title": "100-faster-cpp-level-order-traversal-vector-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nint this question we are asked to return the k maximum sum of level.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nwe simply do level order traversal and for every level we store the sum of the level in the vector and at last we sort the vector in reverse order and return [k-1] index of vector as the answer\\n\\n\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\ntypedef long long ll;\\n    long long kthLargestLevelSum(TreeNode* root, int k) {\\n        if(root==NULL)\\n        return -1;\\n\\n        vector<ll> v;\\n        queue<TreeNode*> q;\\n        q.push(root);\\n        while(q.size()!=0)\\n        {\\n            ll cnt = q.size();\\n           ll sum = 0;\\n            for(ll i=0; i<cnt; i++)\\n            {\\n                auto temp = q.front();\\n                q.pop();\\n                sum += temp->val;\\n                if(temp->left!=NULL)\\n                q.push(temp->left);\\n                if(temp->right!=NULL)\\n                q.push(temp->right);\\n            }\\n            v.push_back(sum);\\n        }\\n        sort(v.rbegin(),v.rend());\\n        return v[k-1];\\n    }\\n```\\n![PLEASE UPVOTE.jpg](https://assets.leetcode.com/users/images/db404046-801c-45bf-bbc5-d2bed9030cd0_1677990752.590999.jpeg)\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\ntypedef long long ll;\\n    long long kthLargestLevelSum(TreeNode* root, int k) {\\n        if(root==NULL)\\n        return -1;\\n\\n        vector<ll> v;\\n        queue<TreeNode*> q;\\n        q.push(root);\\n        while(q.size()!=0)\\n        {\\n            ll cnt = q.size();\\n           ll sum = 0;\\n            for(ll i=0; i<cnt; i++)\\n            {\\n                auto temp = q.front();\\n                q.pop();\\n                sum += temp->val;\\n                if(temp->left!=NULL)\\n                q.push(temp->left);\\n                if(temp->right!=NULL)\\n                q.push(temp->right);\\n            }\\n            v.push_back(sum);\\n        }\\n        sort(v.rbegin(),v.rend());\\n        return v[k-1];\\n    }\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3258415,
                "title": "level-sum-bfs-c",
                "content": "```\\nclass Solution {\\npublic:\\n    long long kthLargestLevelSum(TreeNode* root, int k) {\\n        // priority_queue<long long int,vector<long long int>,greater<long long int>> pq;\\n        queue<TreeNode*> q;\\n        int n;\\n        long long int sum = 0;\\n        q.push(root);\\n        TreeNode* p;\\n        vector<long long int> v;\\n        while(!q.empty()){\\n            n = q.size();\\n            sum = 0;\\n            while(n--){\\n                p = q.front();\\n                q.pop();\\n                sum += p->val;\\n                // cout<<root->val<<\" \";\\n                if(p->left){\\n                    q.push(p->left);\\n                    \\n                }\\n                if(p->right){\\n                    q.push(p->right);\\n                }\\n            }\\n            v.push_back(sum);\\n        }\\n        if(v.size()<k)return -1;\\n        sort(v.begin(),v.end());\\n        return v[v.size()-k];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Breadth-First Search",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long kthLargestLevelSum(TreeNode* root, int k) {\\n        // priority_queue<long long int,vector<long long int>,greater<long long int>> pq;\\n        queue<TreeNode*> q;\\n        int n;\\n        long long int sum = 0;\\n        q.push(root);\\n        TreeNode* p;\\n        vector<long long int> v;\\n        while(!q.empty()){\\n            n = q.size();\\n            sum = 0;\\n            while(n--){\\n                p = q.front();\\n                q.pop();\\n                sum += p->val;\\n                // cout<<root->val<<\" \";\\n                if(p->left){\\n                    q.push(p->left);\\n                    \\n                }\\n                if(p->right){\\n                    q.push(p->right);\\n                }\\n            }\\n            v.push_back(sum);\\n        }\\n        if(v.size()<k)return -1;\\n        sort(v.begin(),v.end());\\n        return v[v.size()-k];\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3258185,
                "title": "java-bfs-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n log n )\\n- where n=level of tree\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public long kthLargestLevelSum(TreeNode root, int k) {\\n        Queue<TreeNode> queue=new LinkedList<>();\\n        //PriorityQueue<Long> maxheap=new PriorityQueue<>((a,b)->(b-a));\\n        ArrayList<Long> arr=new ArrayList<>();\\n        queue.add(root);\\n        while(!queue.isEmpty())\\n        {\\n            long sum=0;\\n            int len=queue.size();\\n            for(int i=0;i<len;i++)\\n            {\\n                TreeNode node=queue.poll();\\n                if(node.left != null)\\n                    queue.add(node.left);\\n                if(node.right != null)\\n                    queue.add(node.right);\\n                sum+=node.val;\\n                //queue.poll();\\n            }\\n            arr.add(sum);\\n        }\\n        //System.out.println(maxheap);\\n        Collections.sort(arr);\\n        if(k>arr.size())\\n            return -1;\\n        return arr.get(arr.size()-k);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search",
                    "Queue"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public long kthLargestLevelSum(TreeNode root, int k) {\\n        Queue<TreeNode> queue=new LinkedList<>();\\n        //PriorityQueue<Long> maxheap=new PriorityQueue<>((a,b)->(b-a));\\n        ArrayList<Long> arr=new ArrayList<>();\\n        queue.add(root);\\n        while(!queue.isEmpty())\\n        {\\n            long sum=0;\\n            int len=queue.size();\\n            for(int i=0;i<len;i++)\\n            {\\n                TreeNode node=queue.poll();\\n                if(node.left != null)\\n                    queue.add(node.left);\\n                if(node.right != null)\\n                    queue.add(node.right);\\n                sum+=node.val;\\n                //queue.poll();\\n            }\\n            arr.add(sum);\\n        }\\n        //System.out.println(maxheap);\\n        Collections.sort(arr);\\n        if(k>arr.size())\\n            return -1;\\n        return arr.get(arr.size()-k);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3258162,
                "title": "bfs-pq-c",
                "content": "```\\nclass Solution {\\npublic:\\n    long long kthLargestLevelSum(TreeNode* root, int k) {\\n        priority_queue<long long, vector<long long>, greater<long long>> pq;\\n        \\n        queue<TreeNode*> q;\\n        q.push(root);\\n        int cnt = 0;\\n        \\n        while(!q.empty()) {\\n            long long n = q.size(), s = 0;\\n            \\n            while(n--) {\\n                TreeNode* temp = q.front(); q.pop();\\n                s += temp -> val;\\n                \\n                if(temp -> left) q.push(temp -> left);\\n                if(temp -> right) q.push(temp -> right);\\n            }\\n            cnt++;\\n            pq.push(s);\\n            if(pq.size() > k) pq.pop();\\n        }\\n        \\n        return cnt < k ? -1 : pq.top();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Breadth-First Search",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long kthLargestLevelSum(TreeNode* root, int k) {\\n        priority_queue<long long, vector<long long>, greater<long long>> pq;\\n        \\n        queue<TreeNode*> q;\\n        q.push(root);\\n        int cnt = 0;\\n        \\n        while(!q.empty()) {\\n            long long n = q.size(), s = 0;\\n            \\n            while(n--) {\\n                TreeNode* temp = q.front(); q.pop();\\n                s += temp -> val;\\n                \\n                if(temp -> left) q.push(temp -> left);\\n                if(temp -> right) q.push(temp -> right);\\n            }\\n            cnt++;\\n            pq.push(s);\\n            if(pq.size() > k) pq.pop();\\n        }\\n        \\n        return cnt < k ? -1 : pq.top();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3868657,
                "title": "simple-java-solution-using-level-order-traversal-and-priority-queue",
                "content": "\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe approach is based on cioncept of level order traversal and getting the kth largest element using priority queues.\\n# Complexity\\n- Time complexity:O(n) where n: number of nodes.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n) \\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public long kthLargestLevelSum(TreeNode root, int k) {\\n        Queue<TreeNode>q = new LinkedList<>();\\n        if(root == null) {\\n            return -1;\\n        }\\n        q.add(root);\\n        int level = 0;\\n        Queue<Long>pq = new PriorityQueue<>();\\n        while(!q.isEmpty()) {\\n            int n = q.size();\\n            level++;\\n            long sum = 0;\\n            for(int i=1; i<=n;i++) {\\n                TreeNode curr = q.poll();\\n                sum+=curr.val;\\n                if(curr.left!=null) {\\n                    q.add(curr.left);\\n                }\\n                if(curr.right!=null) {\\n                    q.add(curr.right);\\n                }\\n            }\\n            if(pq.size()<k) {\\n                pq.add(sum);\\n                System.out.println(sum);\\n            } else {\\n                if(sum>pq.peek()) {\\n                    pq.poll();\\n                    pq.add(sum);\\n                }\\n            }\\n        }\\n        if(level<k) {\\n            return -1;\\n        }\\n        return pq.peek();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public long kthLargestLevelSum(TreeNode root, int k) {\\n        Queue<TreeNode>q = new LinkedList<>();\\n        if(root == null) {\\n            return -1;\\n        }\\n        q.add(root);\\n        int level = 0;\\n        Queue<Long>pq = new PriorityQueue<>();\\n        while(!q.isEmpty()) {\\n            int n = q.size();\\n            level++;\\n            long sum = 0;\\n            for(int i=1; i<=n;i++) {\\n                TreeNode curr = q.poll();\\n                sum+=curr.val;\\n                if(curr.left!=null) {\\n                    q.add(curr.left);\\n                }\\n                if(curr.right!=null) {\\n                    q.add(curr.right);\\n                }\\n            }\\n            if(pq.size()<k) {\\n                pq.add(sum);\\n                System.out.println(sum);\\n            } else {\\n                if(sum>pq.peek()) {\\n                    pq.poll();\\n                    pq.add(sum);\\n                }\\n            }\\n        }\\n        if(level<k) {\\n            return -1;\\n        }\\n        return pq.peek();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3795164,
                "title": "kth-largest-sum-in-a-binary-tree",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n![image.png](https://assets.leetcode.com/users/images/22b9e4b8-e437-417a-877d-8b8fa7c8de68_1689914446.3691285.png)\\n\\n# Code\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def kthLargestLevelSum(self, root: Optional[TreeNode], k: int) -> int:\\n        l=defaultdict(list)\\n        def traversal(root,h):\\n            if root is None:\\n                return\\n            l[h].append(root.val)\\n            traversal(root.left,h+1)\\n            traversal(root.right,h+1)\\n        traversal(root,1)\\n        res=[]\\n        for i in l.values():\\n            res.append(sum(i))\\n        res.sort(reverse=True)\\n        if k>len(res):\\n            return -1\\n        return res[k-1]\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def kthLargestLevelSum(self, root: Optional[TreeNode], k: int) -> int:\\n        l=defaultdict(list)\\n        def traversal(root,h):\\n            if root is None:\\n                return\\n            l[h].append(root.val)\\n            traversal(root.left,h+1)\\n            traversal(root.right,h+1)\\n        traversal(root,1)\\n        res=[]\\n        for i in l.values():\\n            res.append(sum(i))\\n        res.sort(reverse=True)\\n        if k>len(res):\\n            return -1\\n        return res[k-1]\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3642867,
                "title": "simple-bfs-priority-queue",
                "content": "# \\uD83D\\uDE09Don\\'t just watch & move away, also give an Upvote.\\uD83D\\uDE09\\n\\n# Complexity\\n- Time complexity: $$O(n.log(n))$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    long long kthLargestLevelSum(TreeNode* root, int k) {\\n        priority_queue<long long> pq;\\n\\n        queue<TreeNode*> q;\\n        q.push(root);\\n\\n        while(!q.empty())\\n        {\\n            int size = q.size();\\n            long long sum = 0;\\n            for(int i=0; i<size; i++)\\n            {\\n                TreeNode* curr = q.front();\\n                q.pop();\\n\\n                sum+=curr->val;\\n\\n                if(curr->left)\\n                {\\n                    q.push(curr->left);\\n                }\\n\\n                if(curr->right)\\n                {\\n                    q.push(curr->right);\\n                }\\n            }\\n\\n            pq.push(sum);\\n        }\\n\\n        long long ans = 0;\\n        while(!pq.empty() && k--)\\n        {\\n            ans = pq.top();\\n            pq.pop();\\n        }\\n\\n<!-- \\u2705Well before returning answer don\\'t forget to UPVOTE.\\u2705 -->\\n        return k>0?-1:ans;\\n    }\\n};\\n```\\n![Leetcode Upvote.gif](https://assets.leetcode.com/users/images/35c41a3c-b2e4-49d4-a940-18b862ae0b6f_1686854441.9093616.gif)\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "C",
                    "Breadth-First Search",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    long long kthLargestLevelSum(TreeNode* root, int k) {\\n        priority_queue<long long> pq;\\n\\n        queue<TreeNode*> q;\\n        q.push(root);\\n\\n        while(!q.empty())\\n        {\\n            int size = q.size();\\n            long long sum = 0;\\n            for(int i=0; i<size; i++)\\n            {\\n                TreeNode* curr = q.front();\\n                q.pop();\\n\\n                sum+=curr->val;\\n\\n                if(curr->left)\\n                {\\n                    q.push(curr->left);\\n                }\\n\\n                if(curr->right)\\n                {\\n                    q.push(curr->right);\\n                }\\n            }\\n\\n            pq.push(sum);\\n        }\\n\\n        long long ans = 0;\\n        while(!pq.empty() && k--)\\n        {\\n            ans = pq.top();\\n            pq.pop();\\n        }\\n\\n<!-- \\u2705Well before returning answer don\\'t forget to UPVOTE.\\u2705 -->\\n        return k>0?-1:ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3641427,
                "title": "simple-bfs",
                "content": "\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\n#define ll long long\\nclass Solution {\\npublic:\\n    long long kthLargestLevelSum(TreeNode* root, int k) {\\n        vector<ll> level;\\n        queue<TreeNode*> q;\\n        q.push(root);\\n        while(!q.empty()){\\n            ll sum=0;\\n            int s=q.size();\\n            for(int i=0;i<s;i++){\\n                TreeNode* temp=q.front();\\n                q.pop();\\n                sum+=temp->val;\\n                if(temp->left) q.push(temp->left);\\n                if(temp->right) q.push(temp->right);\\n            }\\n            level.push_back(sum);\\n        }\\n        if(level.size()<k) return -1;\\n        sort(level.begin(),level.end(),greater<ll>());\\n        return level[k-1];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Breadth-First Search",
                    "Sorting"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\n#define ll long long\\nclass Solution {\\npublic:\\n    long long kthLargestLevelSum(TreeNode* root, int k) {\\n        vector<ll> level;\\n        queue<TreeNode*> q;\\n        q.push(root);\\n        while(!q.empty()){\\n            ll sum=0;\\n            int s=q.size();\\n            for(int i=0;i<s;i++){\\n                TreeNode* temp=q.front();\\n                q.pop();\\n                sum+=temp->val;\\n                if(temp->left) q.push(temp->left);\\n                if(temp->right) q.push(temp->right);\\n            }\\n            level.push_back(sum);\\n        }\\n        if(level.size()<k) return -1;\\n        sort(level.begin(),level.end(),greater<ll>());\\n        return level[k-1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3640797,
                "title": "c-bfs-max-heap-clean",
                "content": "# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    long long kthLargestLevelSum(TreeNode* root, int k) {\\n        priority_queue<long long> PQ;\\n        queue<TreeNode*> Q;\\n        Q.push(root);\\n\\n        while (!Q.empty()) {\\n            size_t size = Q.size();\\n            long long sum = 0;\\n            for (int i = 0; i < size; i++) {\\n                TreeNode* curr = Q.front();\\n                Q.pop();\\n                sum += curr->val;\\n                if (curr->left) Q.push(curr->left);\\n                if (curr->right) Q.push(curr->right);\\n            }\\n            PQ.push(sum);\\n        }\\n\\n        if (PQ.size() < k) return -1; \\n        while (--k > 0) PQ.pop();\\n        return PQ.top();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search",
                    "Tree",
                    "Breadth-First Search",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    long long kthLargestLevelSum(TreeNode* root, int k) {\\n        priority_queue<long long> PQ;\\n        queue<TreeNode*> Q;\\n        Q.push(root);\\n\\n        while (!Q.empty()) {\\n            size_t size = Q.size();\\n            long long sum = 0;\\n            for (int i = 0; i < size; i++) {\\n                TreeNode* curr = Q.front();\\n                Q.pop();\\n                sum += curr->val;\\n                if (curr->left) Q.push(curr->left);\\n                if (curr->right) Q.push(curr->right);\\n            }\\n            PQ.push(sum);\\n        }\\n\\n        if (PQ.size() < k) return -1; \\n        while (--k > 0) PQ.pop();\\n        return PQ.top();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3581349,
                "title": "i-have-provided-you-one-of-the-easiest-way-to-solve-this-question",
                "content": "We will take help of priority queue . We will use min heap priority queue and insert k element in it .Once total k element is inserted that we will start comparing the upcoming element with the top Most element if top most element is less than the upcoming element . Then we will replace it otherwise leave it.                                                   ***HERE SUM OF LEVEL IS REPRESENTED AS ELEMENT***\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\n\\n\\n\\nclass Solution {\\npublic:\\n    long long kthLargestLevelSum(TreeNode* root, int k) {\\n        if (root == nullptr) {\\n            return 0;\\n        }\\n        \\n        priority_queue<long long, vector<long long>, greater<long long>> helper;\\n        queue<TreeNode*> pq;\\n        pq.push(root);\\n\\n        while (!pq.empty()) {\\n            int size = pq.size();\\n            long long sum = 0;\\n\\n            for (int i = 0; i < size; i++) {\\n                TreeNode* curr = pq.front();\\n                pq.pop();\\n\\n                if (curr->left) {\\n                    pq.push(curr->left);\\n                }\\n                if (curr->right) {\\n                    pq.push(curr->right);\\n                }\\n\\n                sum += curr->val;\\n            }\\n\\n            helper.push(sum);\\n            if (helper.size() > k) {\\n                helper.pop();\\n            }\\n        }\\nif(helper.size()<k) return -1;\\n        return helper.top();\\n    }\\n};\\n\\n\\n\\n\\n\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Tree",
                    "Queue",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\n\\n\\n\\nclass Solution {\\npublic:\\n    long long kthLargestLevelSum(TreeNode* root, int k) {\\n        if (root == nullptr) {\\n            return 0;\\n        }\\n        \\n        priority_queue<long long, vector<long long>, greater<long long>> helper;\\n        queue<TreeNode*> pq;\\n        pq.push(root);\\n\\n        while (!pq.empty()) {\\n            int size = pq.size();\\n            long long sum = 0;\\n\\n            for (int i = 0; i < size; i++) {\\n                TreeNode* curr = pq.front();\\n                pq.pop();\\n\\n                if (curr->left) {\\n                    pq.push(curr->left);\\n                }\\n                if (curr->right) {\\n                    pq.push(curr->right);\\n                }\\n\\n                sum += curr->val;\\n            }\\n\\n            helper.push(sum);\\n            if (helper.size() > k) {\\n                helper.pop();\\n            }\\n        }\\nif(helper.size()<k) return -1;\\n        return helper.top();\\n    }\\n};\\n\\n\\n\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3562459,
                "title": "dfs-bfs-using-priority-queue-max-heap-most-efficient-with-comment-explanation",
                "content": "\\uD83D\\uDE0A \\uD835\\uDE4E\\uD835\\uDE5A\\uD835\\uDE61\\uD835\\uDE5B \\uD835\\uDE3E\\uD835\\uDE67\\uD835\\uDE5A\\uD835\\uDE56\\uD835\\uDE69\\uD835\\uDE5A\\uD835\\uDE59 \\uD835\\uDE47\\uD835\\uDE64\\uD835\\uDE5C\\uD835\\uDE5E\\uD835\\uDE58 ~ \\uD835\\uDE52\\uD835\\uDE5E\\uD835\\uDE69\\uD835\\uDE5D \\u2764\\uFE0F \\uD835\\uDE57\\uD835\\uDE6E \\uD835\\uDE43\\uD835\\uDE5E\\uD835\\uDE67\\uD835\\uDE5A\\uD835\\uDE63\\n# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nTake A Look At The Code And Comments Within It, You\\'ll Get It.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nOur Easy :- \\n1. DFS + Priority Queue (Using MaxHeap)\\n2. BFS + Priority Queue (Using MaxHeap)\\n\\n- Tell your doubts on the comment section, I will definitely reply! \\n\\n# Complexity\\n- Time complexity: O(NLogN)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\nApproach 1 : Using DFS + Max Heap\\n```\\n// #1 Method Helper\\nvoid dfs(node* root, int currLevel, vector<long long>& levelSum) {\\n    // Edge case\\n    if(!root)\\n        return;\\n\\n    if(currLevel == levelSum.size())\\n        levelSum.push_back(root->val); // If current level is seen for the first time\\n    else\\n        levelSum[currLevel] += root->val; // Else it means current level is seen again \\n\\n    dfs(root->left, currLevel+1, levelSum);\\n    dfs(root->right, currLevel+1, levelSum);\\n}\\n\\n// #1 Method to find the Kth largest level sum using DFS - O(NLogN) & O(N)\\nlong long kthLargestLevelSum(node* root, int k) {\\n    vector<long long> levelSum; // Require to store the sum of each level\\n    dfs(root, 0, levelSum);\\n\\n    priority_queue<long long> maxHeap(begin(levelSum), end(levelSum));\\n\\n    while(--k) {maxHeap.pop(); if(maxHeap.empty()) return -1;}\\n    \\n    return maxHeap.top();\\n}\\n// Note: Brute force can make by sorting the vector\\n```\\nApproach 2 : Using BFS + Max Heap\\n```\\n// #2 Method to find the Kth largest level sum using BFS - O(NLogN) & O(N)\\nlong long kthLargestLevelSum(node* root, int k) {\\n    // Edge case\\n    if(!root)\\n        return -1;\\n\\n    queue<node*> q;\\n    q.push(root);\\n\\n    vector<long long> levelSum; // Require to store the sum of each level\\n\\n    while(!q.empty()) {\\n        int qSize = q.size();\\n        long long currLevelSum = 0; // Require to store the sum of current level\\n\\n        while(qSize--) {\\n            node* curr = q.front(); q.pop();\\n            currLevelSum += curr->val;\\n            if(curr->left) q.push(curr->left);\\n            if(curr->right) q.push(curr->right);\\n        }\\n        levelSum.push_back(currLevelSum); // Store the sum of current level\\n    }\\n\\n    priority_queue<long long> maxHeap(begin(levelSum), end(levelSum));\\n\\n    while(--k) {maxHeap.pop(); if(maxHeap.empty()) return -1;}\\n    \\n    return maxHeap.top();\\n}\\n// Note: Brute force can make by sorting the vector\\n```\\n\\uD835\\uDDE8\\uD835\\uDDE3\\uD835\\uDDE9\\uD835\\uDDE2\\uD835\\uDDE7\\uD835\\uDDD8 \\uD835\\uDDDC\\uD835\\uDDD9 \\uD835\\uDDEC\\uD835\\uDDE2\\uD835\\uDDE8 \\uD835\\uDDDF\\uD835\\uDDDC\\uD835\\uDDDE\\uD835\\uDDD8 \\uD835\\uDDE7\\uD835\\uDDDB\\uD835\\uDDD8 \\uD835\\uDDE6\\uD835\\uDDE2\\uD835\\uDDDF\\uD835\\uDDE8\\uD835\\uDDE7\\uD835\\uDDDC\\uD835\\uDDE2\\uD835\\uDDE1 \\uD83D\\uDC4D",
                "solutionTags": [
                    "C++",
                    "Binary Search",
                    "Tree",
                    "Breadth-First Search",
                    "Recursion"
                ],
                "code": "```\\n// #1 Method Helper\\nvoid dfs(node* root, int currLevel, vector<long long>& levelSum) {\\n    // Edge case\\n    if(!root)\\n        return;\\n\\n    if(currLevel == levelSum.size())\\n        levelSum.push_back(root->val); // If current level is seen for the first time\\n    else\\n        levelSum[currLevel] += root->val; // Else it means current level is seen again \\n\\n    dfs(root->left, currLevel+1, levelSum);\\n    dfs(root->right, currLevel+1, levelSum);\\n}\\n\\n// #1 Method to find the Kth largest level sum using DFS - O(NLogN) & O(N)\\nlong long kthLargestLevelSum(node* root, int k) {\\n    vector<long long> levelSum; // Require to store the sum of each level\\n    dfs(root, 0, levelSum);\\n\\n    priority_queue<long long> maxHeap(begin(levelSum), end(levelSum));\\n\\n    while(--k) {maxHeap.pop(); if(maxHeap.empty()) return -1;}\\n    \\n    return maxHeap.top();\\n}\\n// Note: Brute force can make by sorting the vector\\n```\n```\\n// #2 Method to find the Kth largest level sum using BFS - O(NLogN) & O(N)\\nlong long kthLargestLevelSum(node* root, int k) {\\n    // Edge case\\n    if(!root)\\n        return -1;\\n\\n    queue<node*> q;\\n    q.push(root);\\n\\n    vector<long long> levelSum; // Require to store the sum of each level\\n\\n    while(!q.empty()) {\\n        int qSize = q.size();\\n        long long currLevelSum = 0; // Require to store the sum of current level\\n\\n        while(qSize--) {\\n            node* curr = q.front(); q.pop();\\n            currLevelSum += curr->val;\\n            if(curr->left) q.push(curr->left);\\n            if(curr->right) q.push(curr->right);\\n        }\\n        levelSum.push_back(currLevelSum); // Store the sum of current level\\n    }\\n\\n    priority_queue<long long> maxHeap(begin(levelSum), end(levelSum));\\n\\n    while(--k) {maxHeap.pop(); if(maxHeap.empty()) return -1;}\\n    \\n    return maxHeap.top();\\n}\\n// Note: Brute force can make by sorting the vector\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3435316,
                "title": "kth-largest-sum-in-a-binary-tree-java",
                "content": "# Complexity\\n- Time complexity: O(nlogn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public long kthLargestLevelSum(TreeNode root, int k) {\\n        List<Long> list = new ArrayList<>();\\n        Queue<TreeNode> qu = new LinkedList<>();\\n        qu.add(root);\\n        while(!qu.isEmpty()){\\n            int len = qu.size();\\n            long sum = 0;\\n            for(int i=0; i<len; i++){\\n                TreeNode curr = qu.poll();\\n                sum += (long)curr.val;\\n                if(curr.left != null){\\n                    qu.add(curr.left);\\n                }\\n                if(curr.right != null){\\n                    qu.add(curr.right);\\n                }\\n            }\\n            list.add(sum);\\n        }\\n        return getLargestValue(list, k);   \\n    }\\n    public long getLargestValue(List<Long> list, int k){\\n        Collections.sort(list);\\n        if(list.size() < k) return -1;\\n        return list.get(list.size() - k);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Tree",
                    "Queue",
                    "Hash Function"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public long kthLargestLevelSum(TreeNode root, int k) {\\n        List<Long> list = new ArrayList<>();\\n        Queue<TreeNode> qu = new LinkedList<>();\\n        qu.add(root);\\n        while(!qu.isEmpty()){\\n            int len = qu.size();\\n            long sum = 0;\\n            for(int i=0; i<len; i++){\\n                TreeNode curr = qu.poll();\\n                sum += (long)curr.val;\\n                if(curr.left != null){\\n                    qu.add(curr.left);\\n                }\\n                if(curr.right != null){\\n                    qu.add(curr.right);\\n                }\\n            }\\n            list.add(sum);\\n        }\\n        return getLargestValue(list, k);   \\n    }\\n    public long getLargestValue(List<Long> list, int k){\\n        Collections.sort(list);\\n        if(list.size() < k) return -1;\\n        return list.get(list.size() - k);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3411231,
                "title": "100-working-solution-in-java-bfs-tree-level-order-traversal",
                "content": "```\\nclass Solution {\\n    public long kthLargestLevelSum(TreeNode root, int k) {\\n        PriorityQueue<Long> pq= new PriorityQueue<Long>();\\n        \\n        Queue<TreeNode> q= new LinkedList<>();\\n        q.add(root);\\n        while(!q.isEmpty()){\\n            long sum=0;\\n            int size= q.size();\\n            for(int i=0; i<size; i++){\\n                TreeNode cur= q.poll();\\n                sum+= cur.val;\\n                if(cur.left!=null){\\n                    q.add(cur.left);\\n                }\\n                if(cur.right!=null){\\n                    q.add(cur.right);\\n                }\\n            }\\n            pq.add(sum);\\n        }\\n        \\n        if(pq.size()<k){\\n            return -1;\\n        }\\n        \\n        while(pq.size()>k){\\n            pq.poll();\\n        }\\n        \\n        return pq.peek();\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Tree",
                    "Breadth-First Search",
                    "Queue",
                    "Heap (Priority Queue)",
                    "Binary Tree"
                ],
                "code": "class Solution {\\n    public long kthLargestLevelSum(TreeNode root, int k) {\\n        PriorityQueue<Long> pq= new PriorityQueue<Long>();\\n        \\n        Queue<TreeNode> q= new LinkedList<>();\\n        q.add(root);\\n        while(!q.isEmpty()){\\n            long sum=0;\\n            int size= q.size();\\n            for(int i=0; i<size; i++){\\n                TreeNode cur= q.poll();\\n                sum+= cur.val;\\n                if(cur.left!=null){\\n                    q.add(cur.left);\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 3363616,
                "title": "python3-bfs-easy-understanding",
                "content": "\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def kthLargestLevelSum(self, root: Optional[TreeNode], k: int) -> int:\\n        dq = collections.deque([root])\\n        a = []\\n        lvl = 1\\n        while dq:\\n            lvlsum = 0\\n            for i in range(len(dq)):\\n               n = dq.popleft()\\n               lvlsum += n.val\\n               if n.left: dq.append(n.left)\\n               if n.right: dq.append(n.right)\\n            a.append(lvlsum)\\n            lvl += 1\\n        a.sort(reverse=True)\\n        return a[k-1] if len(a) >= k else -1\\n```",
                "solutionTags": [
                    "Python3",
                    "Binary Search",
                    "Tree",
                    "Breadth-First Search"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def kthLargestLevelSum(self, root: Optional[TreeNode], k: int) -> int:\\n        dq = collections.deque([root])\\n        a = []\\n        lvl = 1\\n        while dq:\\n            lvlsum = 0\\n            for i in range(len(dq)):\\n               n = dq.popleft()\\n               lvlsum += n.val\\n               if n.left: dq.append(n.left)\\n               if n.right: dq.append(n.right)\\n            a.append(lvlsum)\\n            lvl += 1\\n        a.sort(reverse=True)\\n        return a[k-1] if len(a) >= k else -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3356694,
                "title": "easiest-approach",
                "content": "\\nclass Solution {\\npublic:\\n    long long kthLargestLevelSum(TreeNode* root, int k) {\\n        vector<long long>v;\\n        queue<TreeNode*>q;\\n        q.push(root);\\n        while(!q.empty())\\n        {\\n            int size=q.size();\\n            long long sum=0;\\n            for(int i=0;i<size;i++)\\n            {\\n                TreeNode* front=q.front();\\n                q.pop();\\n                sum+=front->val;\\n                if(front->left)\\n                q.push(front->left);\\n                if(front->right)\\n                q.push(front->right);\\n            }\\n            v.push_back(sum);\\n        }\\n        sort(v.begin(),v.end());\\n        reverse(v.begin(),v.end());\\n        if(v.size()<k)\\n        return -1;\\n        return v[k-1];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\npublic:\\n    long long kthLargestLevelSum(TreeNode* root, int k) {\\n        vector<long long>v;\\n        queue<TreeNode*>q;\\n        q.push(root);\\n        while(!q.empty())\\n        {\\n            int size=q.size();\\n            long long sum=0;\\n            for(int i=0;i<size;i++)\\n            {\\n                TreeNode* front=q.front();\\n                q.pop();\\n                sum+=front->val;\\n                if(front->left)\\n                q.push(front->left);\\n                if(front->right)\\n                q.push(front->right);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3314424,
                "title": "java-easy-and-understandable-solution",
                "content": "**Time complexity : O(h)**\\n```\\nclass Solution {\\n    public long kthLargestLevelSum(TreeNode root, int k) {\\n        List<Long> list=new ArrayList<>();\\n        Queue<TreeNode> qu=new LinkedList<>();\\n        qu.offer(root);\\n        while(!qu.isEmpty())\\n        {\\n            int p=qu.size();\\n            long s=0;\\n            for(int i=0;i<p;i++)\\n            {\\n                if(qu.peek().left!=null)\\n                    qu.offer(qu.peek().left);\\n                if(qu.peek().right!=null)\\n                    qu.offer(qu.peek().right);\\n                s+=(long)qu.poll().val;\\n            }\\n            list.add(s);\\n        }\\n        Collections.sort(list);\\n        return k > list.size() ? -1 : list.get(list.size()-k);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Tree",
                    "Queue"
                ],
                "code": "```\\nclass Solution {\\n    public long kthLargestLevelSum(TreeNode root, int k) {\\n        List<Long> list=new ArrayList<>();\\n        Queue<TreeNode> qu=new LinkedList<>();\\n        qu.offer(root);\\n        while(!qu.isEmpty())\\n        {\\n            int p=qu.size();\\n            long s=0;\\n            for(int i=0;i<p;i++)\\n            {\\n                if(qu.peek().left!=null)\\n                    qu.offer(qu.peek().left);\\n                if(qu.peek().right!=null)\\n                    qu.offer(qu.peek().right);\\n                s+=(long)qu.poll().val;\\n            }\\n            list.add(s);\\n        }\\n        Collections.sort(list);\\n        return k > list.size() ? -1 : list.get(list.size()-k);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3309307,
                "title": "swift-bfs-7-sloc",
                "content": "**BFS (accepted answer)**\\n```\\nclass Solution {\\n    func kthLargestLevelSum(_ root: TreeNode?, _ k: Int) -> Int {\\n        var bfs = [root].compactMap {$0}\\n\\t\\tvar levelSums = [Int]()\\n\\t\\t\\n        while !bfs.isEmpty {\\n            levelSums.append(bfs.lazy.map(\\\\.val).reduce(0,+))\\n            bfs = bfs.flatMap {[$0.left, $0.right]}.compactMap{$0}\\n        }\\n\\t\\t\\n        return levelSums.count >= k ? levelSums.sorted(by: >)[k-1] : -1\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func kthLargestLevelSum(_ root: TreeNode?, _ k: Int) -> Int {\\n        var bfs = [root].compactMap {$0}\\n\\t\\tvar levelSums = [Int]()\\n\\t\\t\\n        while !bfs.isEmpty {\\n            levelSums.append(bfs.lazy.map(\\\\.val).reduce(0,+))\\n            bfs = bfs.flatMap {[$0.left, $0.right]}.compactMap{$0}\\n        }\\n\\t\\t\\n        return levelSums.count >= k ? levelSums.sorted(by: >)[k-1] : -1\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3304038,
                "title": "very-easy-solution-using-bfs-max-heap-in-c",
                "content": "```\\nlong long kthLargestLevelSum(TreeNode* root, int k) {\\n        queue<TreeNode*>q;\\n        q.push(root);\\n        priority_queue<long long>pq;\\n        while(!q.empty()){\\n            int n=q.size();\\n            long long sum=0;\\n            for(int i=0;i<n;i++){\\n                TreeNode* temp=q.front();\\n                q.pop();\\n                sum+=temp->val;\\n                \\n                if(temp->left) q.push(temp->left);\\n                if(temp->right) q.push(temp->right);\\n            }\\n            \\n            pq.push(sum);\\n        }\\n        if(pq.size()<k) return -1;\\n        while(--k) pq.pop();\\n        return pq.top();\\n    }\\n```\\n\\nPlease Upvote if Found usefull",
                "solutionTags": [
                    "C",
                    "Breadth-First Search",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nlong long kthLargestLevelSum(TreeNode* root, int k) {\\n        queue<TreeNode*>q;\\n        q.push(root);\\n        priority_queue<long long>pq;\\n        while(!q.empty()){\\n            int n=q.size();\\n            long long sum=0;\\n            for(int i=0;i<n;i++){\\n                TreeNode* temp=q.front();\\n                q.pop();\\n                sum+=temp->val;\\n                \\n                if(temp->left) q.push(temp->left);\\n                if(temp->right) q.push(temp->right);\\n            }\\n            \\n            pq.push(sum);\\n        }\\n        if(pq.size()<k) return -1;\\n        while(--k) pq.pop();\\n        return pq.top();\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3291675,
                "title": "levelordertraversal-priority-queue-beats-100-runtime",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n# **Please upvote this solution if you like it.**\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe kthLargestLevelSum method calls a private method levelOrder, which performs a level-order traversal of the binary tree and calculates the sum of each level. The level sums are stored in a priority_queue<long long> data structure in decreasing order of value.\\n\\nAfter the levelOrder method has finished processing the binary tree, the kthLargestLevelSum method iterates over the priority queue, popping the top element (which has the highest level sum) k times. The k-th popped element is returned as the result. If there are fewer than k elements in the priority queue, the method returns -1.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(nlogn)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\nprivate:\\n    priority_queue<long long> priority;\\n    void levelOrder(TreeNode* root){\\n        queue<TreeNode*> q;\\n        q.push(root);\\n        q.push(NULL);\\n        long long sum=0;\\n        while(!q.empty()){\\n            TreeNode* node = q.front();\\n            q.pop();\\n            if(node==NULL){\\n                priority.push(sum);\\n                sum=0;\\n                if(!q.empty()){\\n                    q.push(NULL);\\n                }\\n            }\\n            else{\\n                sum+=(node->val);\\n                if(node->left!=NULL){\\n                    q.push(node->left);\\n                }\\n                if(node->right!=NULL){\\n                    q.push(node->right);\\n                }\\n            }\\n        }\\n    }\\npublic:\\n    long long kthLargestLevelSum(TreeNode* root, int k) {\\n        ios_base::sync_with_stdio(false);\\n        levelOrder(root);\\n        while(!priority.empty()){\\n            k--;\\n            if(k==0){\\n                return priority.top();\\n            }\\n            priority.pop();\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\nprivate:\\n    priority_queue<long long> priority;\\n    void levelOrder(TreeNode* root){\\n        queue<TreeNode*> q;\\n        q.push(root);\\n        q.push(NULL);\\n        long long sum=0;\\n        while(!q.empty()){\\n            TreeNode* node = q.front();\\n            q.pop();\\n            if(node==NULL){\\n                priority.push(sum);\\n                sum=0;\\n                if(!q.empty()){\\n                    q.push(NULL);\\n                }\\n            }\\n            else{\\n                sum+=(node->val);\\n                if(node->left!=NULL){\\n                    q.push(node->left);\\n                }\\n                if(node->right!=NULL){\\n                    q.push(node->right);\\n                }\\n            }\\n        }\\n    }\\npublic:\\n    long long kthLargestLevelSum(TreeNode* root, int k) {\\n        ios_base::sync_with_stdio(false);\\n        levelOrder(root);\\n        while(!priority.empty()){\\n            k--;\\n            if(k==0){\\n                return priority.top();\\n            }\\n            priority.pop();\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3277367,
                "title": "java-bfs-level-order-traversal-easy-to-understand-hindi-english",
                "content": "# Intuition\\nIt\\'s Simple to use a BFS we just have to sum all the Nodes when we go to the new level and store it somewhere so You can use List,Queue,Priority Queue any of it , I used queue. because i\\'ve learned approach using queue so...\\n\\n# Approach\\n# In Order to understand approach graphically You can watch this video here\\n- Start The video from `30:38` minutes (Video is in hindi)\\n\\n[https://youtu.be/-DzowlcaUmE]()\\n\\n\\n# Code\\n```\\nclass Solution {\\n    public long kthLargestLevelSum(TreeNode root, int k) \\n    {\\n        if(root == null) return 0;\\n        // use \"Long\" not \"int\" the size of sum might exceed int size.\\n        long sum = 0;\\n        Queue<TreeNode> q = new LinkedList<>();\\n        q.add(root);\\n        q.add(null);\\n        List<Long> list = new ArrayList<>();\\n        // While queue is not empty add it\\'s child into the queue\\n        while(!q.isEmpty()) {\\n            TreeNode node = q.remove();\\n            // if the removed node is null it means the Level ended\\n            // Now add the sum to the list and set sum = 0\\n            // if the queue becomes empty it means that it was the last level end.\\n            if(node == null) {\\n                list.add(sum);\\n                sum = 0;\\n                if(q.isEmpty()) break;\\n                // if not empty then it means there exists some more levels  \\n                else q.add(null);\\n            }\\n            else\\n            {\\n                // add all the values of nodes at same level\\n                sum += node.val;\\n                // add their left and right child to the queue.\\n                if(node.left != null) {\\n                    q.add(node.left);\\n                }\\n                if(node.right != null){\\n                    q.add(node.right);\\n                }\\n            }\\n        }\\n        // Sort the list \\n        // The list will contains all the sums.\\n        Collections.sort(list);\\n        // if given k will be greater then size of the list it will throw IndexOutOfBoundException so return -1\\n        if (k>list.size())\\n        {\\n            return -1;\\n        }else{\\n        // return the last k\\'th largest value\\n        // As the list contains sums in sorted manner obviously the 2nd largest sum will be stored at (length of list) - 2.\\n        return list.get(list.size()-k);\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long kthLargestLevelSum(TreeNode root, int k) \\n    {\\n        if(root == null) return 0;\\n        // use \"Long\" not \"int\" the size of sum might exceed int size.\\n        long sum = 0;\\n        Queue<TreeNode> q = new LinkedList<>();\\n        q.add(root);\\n        q.add(null);\\n        List<Long> list = new ArrayList<>();\\n        // While queue is not empty add it\\'s child into the queue\\n        while(!q.isEmpty()) {\\n            TreeNode node = q.remove();\\n            // if the removed node is null it means the Level ended\\n            // Now add the sum to the list and set sum = 0\\n            // if the queue becomes empty it means that it was the last level end.\\n            if(node == null) {\\n                list.add(sum);\\n                sum = 0;\\n                if(q.isEmpty()) break;\\n                // if not empty then it means there exists some more levels  \\n                else q.add(null);\\n            }\\n            else\\n            {\\n                // add all the values of nodes at same level\\n                sum += node.val;\\n                // add their left and right child to the queue.\\n                if(node.left != null) {\\n                    q.add(node.left);\\n                }\\n                if(node.right != null){\\n                    q.add(node.right);\\n                }\\n            }\\n        }\\n        // Sort the list \\n        // The list will contains all the sums.\\n        Collections.sort(list);\\n        // if given k will be greater then size of the list it will throw IndexOutOfBoundException so return -1\\n        if (k>list.size())\\n        {\\n            return -1;\\n        }else{\\n        // return the last k\\'th largest value\\n        // As the list contains sums in sorted manner obviously the 2nd largest sum will be stored at (length of list) - 2.\\n        return list.get(list.size()-k);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3269646,
                "title": "easy-to-understand-must-see",
                "content": "# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    priority_queue<long long int,vector<long long int>,greater<long long int>>pq;\\n    long long kthLargestLevelSum(TreeNode* root, int k) \\n    {\\n         vector<long long int>v;\\n\\n         queue<TreeNode*>q;\\n         q.push(root);\\n\\n         while(!q.empty())\\n         {\\n             long long int size = q.size();\\n             long long int sum = 0;\\n             for(int i=0;i<size;i++)\\n             {\\n                 TreeNode* temp = q.front();\\n                 q.pop();\\n                 \\n                 sum = sum + (temp->val);\\n\\n                 if(temp -> left != NULL)\\n                 q.push(temp->left);\\n\\n                 if(temp->right != NULL)\\n                 q.push(temp->right);\\n             }\\n             //cout<<\"sum = \"<<sum<<endl;\\n            //  v.push_back(sum);\\n            if(pq.size() < k)\\n            {\\n                pq.push(sum);\\n            }\\n            else if(pq.size() == k)\\n            {\\n                if(pq.top() < sum)\\n                {\\n                    pq.pop();\\n                    pq.push(sum);\\n                }\\n            }\\n         }\\n         if(pq.size() < k)\\n         return -1;\\n\\n         return pq.top();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search",
                    "Tree",
                    "Breadth-First Search"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    priority_queue<long long int,vector<long long int>,greater<long long int>>pq;\\n    long long kthLargestLevelSum(TreeNode* root, int k) \\n    {\\n         vector<long long int>v;\\n\\n         queue<TreeNode*>q;\\n         q.push(root);\\n\\n         while(!q.empty())\\n         {\\n             long long int size = q.size();\\n             long long int sum = 0;\\n             for(int i=0;i<size;i++)\\n             {\\n                 TreeNode* temp = q.front();\\n                 q.pop();\\n                 \\n                 sum = sum + (temp->val);\\n\\n                 if(temp -> left != NULL)\\n                 q.push(temp->left);\\n\\n                 if(temp->right != NULL)\\n                 q.push(temp->right);\\n             }\\n             //cout<<\"sum = \"<<sum<<endl;\\n            //  v.push_back(sum);\\n            if(pq.size() < k)\\n            {\\n                pq.push(sum);\\n            }\\n            else if(pq.size() == k)\\n            {\\n                if(pq.top() < sum)\\n                {\\n                    pq.pop();\\n                    pq.push(sum);\\n                }\\n            }\\n         }\\n         if(pq.size() < k)\\n         return -1;\\n\\n         return pq.top();\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3265918,
                "title": "very-simple-bfs-and-priority-queue-solution",
                "content": "\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    long long kthLargestLevelSum(TreeNode* root, int k) {\\n        long long ans;\\n        priority_queue<long long,vector<long long>,greater<long long>>pq;\\n        queue<TreeNode*>q;\\n        int level=0;\\n        q.push(root);\\n        while(!q.empty()){\\n            int n=q.size();\\n            level++;\\n            long long sum=0;\\n            for(int i=0;i<n;i++){\\n                TreeNode *temp=q.front();q.pop();\\n                sum+=temp->val;\\n                if(temp->left){\\n                    q.push(temp->left);\\n                }\\n                if(temp->right){\\n                    q.push(temp->right);\\n                }\\n            }\\n            pq.push(sum);\\n            if(pq.size()>k){\\n                pq.pop();\\n            }\\n        }\\n        if(level<k)return -1;\\n        return pq.top();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Queue",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    long long kthLargestLevelSum(TreeNode* root, int k) {\\n        long long ans;\\n        priority_queue<long long,vector<long long>,greater<long long>>pq;\\n        queue<TreeNode*>q;\\n        int level=0;\\n        q.push(root);\\n        while(!q.empty()){\\n            int n=q.size();\\n            level++;\\n            long long sum=0;\\n            for(int i=0;i<n;i++){\\n                TreeNode *temp=q.front();q.pop();\\n                sum+=temp->val;\\n                if(temp->left){\\n                    q.push(temp->left);\\n                }\\n                if(temp->right){\\n                    q.push(temp->right);\\n                }\\n            }\\n            pq.push(sum);\\n            if(pq.size()>k){\\n                pq.pop();\\n            }\\n        }\\n        if(level<k)return -1;\\n        return pq.top();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3264681,
                "title": "c-easy-bfs-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    long long kthLargestLevelSum(TreeNode* root, int k) {\\n        vector<long long> lvlsum;\\n        queue<TreeNode*> q;\\n        q.push(root);\\n        while(!q.empty()){\\n            int n = q.size();\\n            long long sum = 0;\\n            for (int i = 0 ; i < n ; i++){\\n                auto curr = q.front();\\n                q.pop();\\n                sum += curr->val;\\n                if(curr->left)q.push(curr->left);\\n                if(curr->right)q.push(curr->right);\\n            }\\n            lvlsum.push_back(sum);\\n        }\\n        // for(auto it : lvlsum) cout << it << \" \";\\n        // cout << endl;\\n        sort(lvlsum.begin(),lvlsum.end());\\n        reverse(lvlsum.begin(),lvlsum.end());\\n        if(lvlsum.size() < k) return -1;\\n        return lvlsum [k-1];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Tree",
                    "Breadth-First Search",
                    "Queue"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long kthLargestLevelSum(TreeNode* root, int k) {\\n        vector<long long> lvlsum;\\n        queue<TreeNode*> q;\\n        q.push(root);\\n        while(!q.empty()){\\n            int n = q.size();\\n            long long sum = 0;\\n            for (int i = 0 ; i < n ; i++){\\n                auto curr = q.front();\\n                q.pop();\\n                sum += curr->val;\\n                if(curr->left)q.push(curr->left);\\n                if(curr->right)q.push(curr->right);\\n            }\\n            lvlsum.push_back(sum);\\n        }\\n        // for(auto it : lvlsum) cout << it << \" \";\\n        // cout << endl;\\n        sort(lvlsum.begin(),lvlsum.end());\\n        reverse(lvlsum.begin(),lvlsum.end());\\n        if(lvlsum.size() < k) return -1;\\n        return lvlsum [k-1];\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3264550,
                "title": "beats-100-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    long long kthLargestLevelSum(TreeNode* root, int k)\\n    {\\n        vector<long long int > v ; \\n        queue<TreeNode* > q ; \\n        q.push(root);\\n        while(q.size())\\n        {\\n            int k = q.size(); \\n            long long int sum  = 0; \\n            for(int i = 0; i<k;i++)\\n            {\\n                TreeNode* temp = q.front();\\n                q.pop();\\n                sum += temp->val;\\n                if(temp->left)\\n                q.push(temp->left);\\n                if(temp->right)\\n                q.push(temp->right);\\n            }\\n            v.push_back(sum);\\n        }\\n        \\n        \\n        \\n        \\n        sort(v.begin(),v.end(),greater<>());\\n        if(v.size()<k)\\n        return -1 ; \\n        else return v[k-1];\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    long long kthLargestLevelSum(TreeNode* root, int k)\\n    {\\n        vector<long long int > v ; \\n        queue<TreeNode* > q ; \\n        q.push(root);\\n        while(q.size())\\n        {\\n            int k = q.size(); \\n            long long int sum  = 0; \\n            for(int i = 0; i<k;i++)\\n            {\\n                TreeNode* temp = q.front();\\n                q.pop();\\n                sum += temp->val;\\n                if(temp->left)\\n                q.push(temp->left);\\n                if(temp->right)\\n                q.push(temp->right);\\n            }\\n            v.push_back(sum);\\n        }\\n        \\n        \\n        \\n        \\n        sort(v.begin(),v.end(),greater<>());\\n        if(v.size()<k)\\n        return -1 ; \\n        else return v[k-1];\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3264206,
                "title": "beats-100-using-level-order-traversal-and-priority-queue",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nMaintaining sum of elements of the same level in a vector while traversing the tree in level order then using priority queue to find Kth largest element from that vector.\\n\\n# Complexity\\n- Time complexity: O(N^2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    long long kthLargestLevelSum(TreeNode* root, int k) {\\n        if(!root) return 0;\\n        queue<TreeNode*>q;\\n        vector<long long>ans;\\n        priority_queue<long long,vector<long long>,greater<long long>>pq;\\n        q.push(root);\\n        while(q.size()){\\n            long long n=q.size();\\n            vector<long long>vec;\\n            long long r=0;\\n            for(int i=0;i<n;i++){\\n                TreeNode* node=q.front();\\n                q.pop();\\n                r+=node->val;\\n                if(node->left) q.push(node->left);\\n                if(node->right) q.push(node->right);\\n            }\\n            ans.push_back(r);\\n        }\\n        for(int i=0;i<ans.size();i++){\\n            pq.push(ans[i]);\\n            if(pq.size()>k) pq.pop();\\n        }\\n        return k>ans.size()?-1:pq.top();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Heap (Priority Queue)",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    long long kthLargestLevelSum(TreeNode* root, int k) {\\n        if(!root) return 0;\\n        queue<TreeNode*>q;\\n        vector<long long>ans;\\n        priority_queue<long long,vector<long long>,greater<long long>>pq;\\n        q.push(root);\\n        while(q.size()){\\n            long long n=q.size();\\n            vector<long long>vec;\\n            long long r=0;\\n            for(int i=0;i<n;i++){\\n                TreeNode* node=q.front();\\n                q.pop();\\n                r+=node->val;\\n                if(node->left) q.push(node->left);\\n                if(node->right) q.push(node->right);\\n            }\\n            ans.push_back(r);\\n        }\\n        for(int i=0;i<ans.size();i++){\\n            pq.push(ans[i]);\\n            if(pq.size()>k) pq.pop();\\n        }\\n        return k>ans.size()?-1:pq.top();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3263378,
                "title": "java-simple-solution-using-map-and-levelorder-beats-100-in-space-and-time",
                "content": "# Intuition\\nTraverse through the tree while also checking their level and all the values of that level to the map, then make a list of the values of the map and reverse sort it then return the kth element if possible.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n\\n# Complexity\\n- Time complexity: O(nlogn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    Map<Integer, Long> map = new HashMap<>();\\n    public long kthLargestLevelSum(TreeNode root, int k) {\\n        levelOrder(root, 0);\\n        List<Long> list = new ArrayList<>();\\n        for(long i : map.values()) list.add(i);\\n        Collections.sort(list, Collections.reverseOrder());\\n        if(k > list.size()) return -1;\\n        return list.get(k-1);\\n    }\\n    public void levelOrder(TreeNode root, int level){\\n        if(root == null) return;\\n        map.merge(level, (long)root.val, Long :: sum);\\n        levelOrder(root.left, level+1);\\n        levelOrder(root.right, level+1);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    Map<Integer, Long> map = new HashMap<>();\\n    public long kthLargestLevelSum(TreeNode root, int k) {\\n        levelOrder(root, 0);\\n        List<Long> list = new ArrayList<>();\\n        for(long i : map.values()) list.add(i);\\n        Collections.sort(list, Collections.reverseOrder());\\n        if(k > list.size()) return -1;\\n        return list.get(k-1);\\n    }\\n    public void levelOrder(TreeNode root, int level){\\n        if(root == null) return;\\n        map.merge(level, (long)root.val, Long :: sum);\\n        levelOrder(root.left, level+1);\\n        levelOrder(root.right, level+1);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3261287,
                "title": "python-dfs-defaultdict-int",
                "content": "```\\nclass Solution:\\n    def kthLargestLevelSum(self, root: Optional[TreeNode], k: int) -> int:\\n        \\n        def dfs(node, d):\\n            if not node:\\n                return\\n            levels[d] += node.val\\n            dfs(node.left, d + 1)\\n            dfs(node.right, d + 1)\\n            \\n        levels = defaultdict(int)\\n        dfs(root, 0)\\n\\n        if k > len(levels):\\n            return -1\\n        return sorted(levels.values())[-k]\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def kthLargestLevelSum(self, root: Optional[TreeNode], k: int) -> int:\\n        \\n        def dfs(node, d):\\n            if not node:\\n                return\\n            levels[d] += node.val\\n            dfs(node.left, d + 1)\\n            dfs(node.right, d + 1)\\n            \\n        levels = defaultdict(int)\\n        dfs(root, 0)\\n\\n        if k > len(levels):\\n            return -1\\n        return sorted(levels.values())[-k]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3260517,
                "title": "c-bfs-level-order",
                "content": "```\\nlong long kthLargestLevelSum(TreeNode* root, int k) {\\n        vector<long long>ans;\\n        queue<TreeNode*>pq;\\n        pq.push(root);\\n        while(!pq.empty())\\n        {\\n            int len=pq.size();\\n            long long sum=0;\\n            for(int i=0;i<len;i++)\\n            {\\n                // int sum=0;\\n                TreeNode* node=pq.front(); pq.pop();\\n                if(node->left) pq.push(node->left);\\n                if(node->right) pq.push(node->right);\\n                sum+=node->val;\\n            }\\n            ans.push_back(sum);\\n        }\\n       \\n        sort(ans.rbegin(),ans.rend());\\n        if(k>ans.size()) return -1;\\n        return ans[k-1];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Breadth-First Search",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nlong long kthLargestLevelSum(TreeNode* root, int k) {\\n        vector<long long>ans;\\n        queue<TreeNode*>pq;\\n        pq.push(root);\\n        while(!pq.empty())\\n        {\\n            int len=pq.size();\\n            long long sum=0;\\n            for(int i=0;i<len;i++)\\n            {\\n                // int sum=0;\\n                TreeNode* node=pq.front(); pq.pop();\\n                if(node->left) pq.push(node->left);\\n                if(node->right) pq.push(node->right);\\n                sum+=node->val;\\n            }\\n            ans.push_back(sum);\\n        }\\n       \\n        sort(ans.rbegin(),ans.rend());\\n        if(k>ans.size()) return -1;\\n        return ans[k-1];\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3260085,
                "title": "c-0ms-runtime-using-level-order-traversal",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long kthLargestLevelSum(TreeNode* root, int k) {\\n        \\n        vector<long long int>nodesum;\\n        queue<TreeNode*>q;\\n        q.push(root); \\n        while(!q.empty()){\\n            long long int sum=0;\\n            vector<int>data;\\n            int size = q.size();\\n            for(int i=0;i<size;i++){\\n                TreeNode*temp = q.front();\\n                q.pop();\\n                data.push_back(temp->val);\\n                if(temp->left!=NULL){\\n                    q.push(temp->left);\\n                }\\n                if(temp->right!=NULL){\\n                    q.push(temp->right);\\n                }\\n            }\\n            \\n            for(auto it:data){\\n                sum+=it;\\n            }\\n            nodesum.push_back(sum);\\n           \\n        }\\n        sort(nodesum.begin(),nodesum.end());\\n        if(k>nodesum.size())return -1;\\n        return nodesum[nodesum.size()-k];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long kthLargestLevelSum(TreeNode* root, int k) {\\n        \\n        vector<long long int>nodesum;\\n        queue<TreeNode*>q;\\n        q.push(root); \\n        while(!q.empty()){\\n            long long int sum=0;\\n            vector<int>data;\\n            int size = q.size();\\n            for(int i=0;i<size;i++){\\n                TreeNode*temp = q.front();\\n                q.pop();\\n                data.push_back(temp->val);\\n                if(temp->left!=NULL){\\n                    q.push(temp->left);\\n                }\\n                if(temp->right!=NULL){\\n                    q.push(temp->right);\\n                }\\n            }\\n            \\n            for(auto it:data){\\n                sum+=it;\\n            }\\n            nodesum.push_back(sum);\\n           \\n        }\\n        sort(nodesum.begin(),nodesum.end());\\n        if(k>nodesum.size())return -1;\\n        return nodesum[nodesum.size()-k];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3260074,
                "title": "c-solution-level-order-traversal-priority-queue",
                "content": "# Intuition\\n**Please Upvote the Solution if you liked it.**\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    long long kthLargestLevelSum(TreeNode* root, int k) {\\n        queue<TreeNode*> q;\\n        priority_queue<long long> pq;\\n        long long sum = 0;\\n      \\n       \\n        q.push(root);\\n        pq.push(root->val);\\n      \\n       \\n        while(!q.empty()){\\n          \\n          int n = q.size();\\n          \\n          for(int i=0;i<n;i++){\\n             TreeNode* top = q.front();\\n             q.pop();\\n            \\n            if(top->right != NULL){\\n              sum += top->right->val;\\n              q.push(top->right);\\n            } \\n            \\n            if(top->left != NULL){\\n              sum += top->left->val;\\n              q.push(top->left);\\n            } \\n          }\\n      \\n         if(sum != 0) pq.push(sum);\\n          sum = 0;\\n        }\\n      \\n//        while(!pq.empty()){\\n//          cout << pq.top() << endl;\\n//          pq.pop();\\n         \\n//        }\\n       \\n       if(pq.size() < k) return -1;\\n      \\n       while(k != 1){\\n         pq.pop();\\n         k--;\\n       }\\n      \\n      return pq.top();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    long long kthLargestLevelSum(TreeNode* root, int k) {\\n        queue<TreeNode*> q;\\n        priority_queue<long long> pq;\\n        long long sum = 0;\\n      \\n       \\n        q.push(root);\\n        pq.push(root->val);\\n      \\n       \\n        while(!q.empty()){\\n          \\n          int n = q.size();\\n          \\n          for(int i=0;i<n;i++){\\n             TreeNode* top = q.front();\\n             q.pop();\\n            \\n            if(top->right != NULL){\\n              sum += top->right->val;\\n              q.push(top->right);\\n            } \\n            \\n            if(top->left != NULL){\\n              sum += top->left->val;\\n              q.push(top->left);\\n            } \\n          }\\n      \\n         if(sum != 0) pq.push(sum);\\n          sum = 0;\\n        }\\n      \\n//        while(!pq.empty()){\\n//          cout << pq.top() << endl;\\n//          pq.pop();\\n         \\n//        }\\n       \\n       if(pq.size() < k) return -1;\\n      \\n       while(k != 1){\\n         pq.pop();\\n         k--;\\n       }\\n      \\n      return pq.top();\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3259059,
                "title": "easy-python-solution-bfs",
                "content": "# Code\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def kthLargestLevelSum(self, root: Optional[TreeNode], k: int) -> int:\\n        \\n        ans = []\\n\\n        def levelOrder(root):\\n\\n            queue = []\\n            queue.append(root)\\n            temp = []\\n            ans.append(root.val)\\n\\n            while queue:\\n\\n                node = queue.pop(0)\\n\\n                if node.left:\\n                    temp.append(node.left)\\n                if node.right:\\n                    temp.append(node.right)\\n                if len(queue) == 0:\\n\\n                    sums = []\\n\\n                    for i in temp:\\n                        sums.append(i.val)\\n\\n                    ans.append(sum(sums))\\n                    queue = temp\\n                    temp = []\\n\\n        levelOrder(root)\\n\\n        ans = list(ans)\\n        ans.sort(reverse=True)\\n\\n        if len(ans) > k:\\n            return ans[k-1]\\n\\n        return -1\\n\\n\\n```\\nDo upvote if you like the Solution :)",
                "solutionTags": [
                    "Python3",
                    "Breadth-First Search"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def kthLargestLevelSum(self, root: Optional[TreeNode], k: int) -> int:\\n        \\n        ans = []\\n\\n        def levelOrder(root):\\n\\n            queue = []\\n            queue.append(root)\\n            temp = []\\n            ans.append(root.val)\\n\\n            while queue:\\n\\n                node = queue.pop(0)\\n\\n                if node.left:\\n                    temp.append(node.left)\\n                if node.right:\\n                    temp.append(node.right)\\n                if len(queue) == 0:\\n\\n                    sums = []\\n\\n                    for i in temp:\\n                        sums.append(i.val)\\n\\n                    ans.append(sum(sums))\\n                    queue = temp\\n                    temp = []\\n\\n        levelOrder(root)\\n\\n        ans = list(ans)\\n        ans.sort(reverse=True)\\n\\n        if len(ans) > k:\\n            return ans[k-1]\\n\\n        return -1\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3258849,
                "title": "easy-to-understand-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    long long kthLargestLevelSum(TreeNode* root, int k) {\\n        queue<TreeNode*>q;\\n        priority_queue<long long>pq;\\n        q.push(root);\\n        vector<int>vec;\\n        while(!q.empty()){\\n            long long sum=0;\\n            int s=q.size();\\n            while(s--){\\n                TreeNode*toot=q.front();\\n                q.pop();\\n                 sum+=(toot->val);\\n                 if(toot->left){\\n                     q.push(toot->left);\\n                 }\\n                 if(toot->right){\\n                     q.push(toot->right);\\n                 }\\n            }\\n            pq.push(sum);\\n        }\\n         if(k > pq.size()){\\n            return -1;\\n        }\\n        \\n        while(--k){\\n            pq.pop();\\n        }\\n      return pq.top();    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Tree",
                    "Queue",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    long long kthLargestLevelSum(TreeNode* root, int k) {\\n        queue<TreeNode*>q;\\n        priority_queue<long long>pq;\\n        q.push(root);\\n        vector<int>vec;\\n        while(!q.empty()){\\n            long long sum=0;\\n            int s=q.size();\\n            while(s--){\\n                TreeNode*toot=q.front();\\n                q.pop();\\n                 sum+=(toot->val);\\n                 if(toot->left){\\n                     q.push(toot->left);\\n                 }\\n                 if(toot->right){\\n                     q.push(toot->right);\\n                 }\\n            }\\n            pq.push(sum);\\n        }\\n         if(k > pq.size()){\\n            return -1;\\n        }\\n        \\n        while(--k){\\n            pq.pop();\\n        }\\n      return pq.top();    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3258622,
                "title": "c-easy-solution-priority-queue",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    long long kthLargestLevelSum(TreeNode* root, int k) {\\n        queue<TreeNode *> q;\\n        priority_queue<long long> pq;\\n        q.push(root);\\n        \\n        while(!q.empty()){\\n            long long sum = 0;\\n            int n = q.size();\\n            \\n            while(n--){\\n                TreeNode *temp = q.front();\\n                q.pop();\\n                \\n                sum += (temp->val);\\n                \\n                if(temp->left)\\n                    q.push(temp->left);\\n                \\n                if(temp->right)\\n                    q.push(temp->right);\\n            }\\n            pq.push(sum);\\n        }\\n        \\n        if(k > pq.size()){\\n            return -1;\\n        }\\n        \\n        while(--k){\\n            pq.pop();\\n        }\\n        \\n        return pq.top();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    long long kthLargestLevelSum(TreeNode* root, int k) {\\n        queue<TreeNode *> q;\\n        priority_queue<long long> pq;\\n        q.push(root);\\n        \\n        while(!q.empty()){\\n            long long sum = 0;\\n            int n = q.size();\\n            \\n            while(n--){\\n                TreeNode *temp = q.front();\\n                q.pop();\\n                \\n                sum += (temp->val);\\n                \\n                if(temp->left)\\n                    q.push(temp->left);\\n                \\n                if(temp->right)\\n                    q.push(temp->right);\\n            }\\n            pq.push(sum);\\n        }\\n        \\n        if(k > pq.size()){\\n            return -1;\\n        }\\n        \\n        while(--k){\\n            pq.pop();\\n        }\\n        \\n        return pq.top();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3258604,
                "title": "c-level-order-simple",
                "content": "\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    long long kthLargestLevelSum(TreeNode* root, int k) {\\n        queue<TreeNode*>q;\\n        vector<long long>v;\\n        q.push(root);\\n        int ans=0;\\n        long long sum=-1;\\n        while(!q.empty()){\\n            int size=q.size();\\n            ans++;\\n            long long tsum=0;\\n            for(int i=0;i<size;i++){\\n                TreeNode* t=q.front();\\n                q.pop();\\n                if(t->left) q.push(t->left);\\n                if(t->right) q.push(t->right);\\n                tsum+=t->val;\\n            }\\n            v.push_back(tsum);\\n        }\\n        sort(v.begin(),v.end(),greater<long long>());\\n        if(ans>=k){\\n            return v[k-1];\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Queue"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    long long kthLargestLevelSum(TreeNode* root, int k) {\\n        queue<TreeNode*>q;\\n        vector<long long>v;\\n        q.push(root);\\n        int ans=0;\\n        long long sum=-1;\\n        while(!q.empty()){\\n            int size=q.size();\\n            ans++;\\n            long long tsum=0;\\n            for(int i=0;i<size;i++){\\n                TreeNode* t=q.front();\\n                q.pop();\\n                if(t->left) q.push(t->left);\\n                if(t->right) q.push(t->right);\\n                tsum+=t->val;\\n            }\\n            v.push_back(tsum);\\n        }\\n        sort(v.begin(),v.end(),greater<long long>());\\n        if(ans>=k){\\n            return v[k-1];\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3258588,
                "title": "java-100",
                "content": "# Approach\\nWe can maintain a map that maps the level number to the sum of that level.\\n\\nWe descend through the tree and add each node\\'s value to the sum of the level it is on.\\n\\nIf we have at least k levels, we can extract and return the k\\'th largest level sum.\\n\\n# Complexity\\n- Time complexity: O(n)\\n- Space complexity: O(log2 n)\\n\\n# Code\\n```\\nclass Solution\\n{\\n    HashMap<Integer,Long> h;\\n    \\n    public long kthLargestLevelSum(TreeNode root, int k)\\n    {\\n        h = new HashMap<>();\\n\\n        get(root,0);\\n\\n        if(h.size()<k)\\n            return -1;\\n\\n        ArrayList<Long> a = new ArrayList<>(h.values());\\n        Collections.sort(a,Collections.reverseOrder());\\n\\n        return a.get(k-1);\\n    }\\n\\n    private void get(TreeNode t, int d)\\n    {\\n        if(t==null)\\n            return;\\n\\n        h.put(d,h.getOrDefault(d,0L)+(long)t.val);\\n\\n        get(t.left,d+1);\\n        get(t.right,d+1);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion",
                    "Ordered Map"
                ],
                "code": "```\\nclass Solution\\n{\\n    HashMap<Integer,Long> h;\\n    \\n    public long kthLargestLevelSum(TreeNode root, int k)\\n    {\\n        h = new HashMap<>();\\n\\n        get(root,0);\\n\\n        if(h.size()<k)\\n            return -1;\\n\\n        ArrayList<Long> a = new ArrayList<>(h.values());\\n        Collections.sort(a,Collections.reverseOrder());\\n\\n        return a.get(k-1);\\n    }\\n\\n    private void get(TreeNode t, int d)\\n    {\\n        if(t==null)\\n            return;\\n\\n        h.put(d,h.getOrDefault(d,0L)+(long)t.val);\\n\\n        get(t.left,d+1);\\n        get(t.right,d+1);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3258467,
                "title": "java-super-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public long kthLargestLevelSum(TreeNode root, int k) {\\n        Queue<TreeNode>q=new LinkedList<>();\\n        q.add(root);\\n        //long maxSum=0;\\n        \\n        ArrayList<Long>maxArray=new ArrayList<>();\\n        while(!q.isEmpty()){\\n            \\n            List<Integer>list=new ArrayList<>();\\n            int count=q.size();\\n            \\n            for(int i=0;i<count;i++){\\n                TreeNode cur=q.poll();\\n                list.add(cur.val);\\n                if(cur.left!=null){\\n                    q.add(cur.left);\\n                }\\n                if(cur.right!=null){\\n                    q.add(cur.right);\\n                }   \\n            }\\n            \\n            long sum=0;\\n            for(int i=0;i<list.size();i++){\\n                sum+=list.get(i);\\n            }\\n            maxArray.add(sum);\\n            \\n            \\n        }\\n        if(k>maxArray.size()) return -1;\\n        Collections.sort(maxArray);\\n        return maxArray.get(maxArray.size()-k);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public long kthLargestLevelSum(TreeNode root, int k) {\\n        Queue<TreeNode>q=new LinkedList<>();\\n        q.add(root);\\n        //long maxSum=0;\\n        \\n        ArrayList<Long>maxArray=new ArrayList<>();\\n        while(!q.isEmpty()){\\n            \\n            List<Integer>list=new ArrayList<>();\\n            int count=q.size();\\n            \\n            for(int i=0;i<count;i++){\\n                TreeNode cur=q.poll();\\n                list.add(cur.val);\\n                if(cur.left!=null){\\n                    q.add(cur.left);\\n                }\\n                if(cur.right!=null){\\n                    q.add(cur.right);\\n                }   \\n            }\\n            \\n            long sum=0;\\n            for(int i=0;i<list.size();i++){\\n                sum+=list.get(i);\\n            }\\n            maxArray.add(sum);\\n            \\n            \\n        }\\n        if(k>maxArray.size()) return -1;\\n        Collections.sort(maxArray);\\n        return maxArray.get(maxArray.size()-k);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3258432,
                "title": "faster-than-100-c-level-order-traversal-priority-queue",
                "content": "class Solution {\\npublic:\\n    long long kthLargestLevelSum(TreeNode* root, int k) {\\n    priority_queue<long long> pq;\\n        if(root==NULL)\\n        {\\n            return 0;\\n        }\\n        queue<TreeNode*> q;\\n        q.push(root);\\n        while(!q.empty())\\n        {\\n            int sz=q.size();\\n            long long soln=0;\\n            for(int i=0;i<sz;i++)\\n            {\\n                TreeNode* temp=q.front();\\n                q.pop();\\n                soln+=temp->val;\\n                if(temp->left)\\n                {\\n                    q.push(temp->left);\\n                }\\n                if(temp->right)\\n                {\\n                    q.push(temp->right);\\n                }\\n            }\\n            pq.push(soln);\\n        }\\n        if(k>pq.size())\\n        {\\n            return -1;\\n        }\\n        int m=1;\\n        while(m<k && !pq.empty())\\n        {\\n            pq.pop();\\n            m++;\\n        }\\n        return pq.top();\\n    }    \\n};",
                "solutionTags": [
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "class Solution {\\npublic:\\n    long long kthLargestLevelSum(TreeNode* root, int k) {\\n    priority_queue<long long> pq;\\n        if(root==NULL)\\n        {\\n            return 0;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3258420,
                "title": "level-traversal-python-explained",
                "content": "# Intuition\\nPerform Level Traversal and find the value of all nodes values in current level and store in array\\nSort the array in reverse order. why?\\n`We are asked to return kth largest`\\nReturn the val present at k - 1 in array (as array is 0-indexed based)\\n\\n# Code\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def kthLargestLevelSum(self, root: Optional[TreeNode], k: int) -> int:\\n        levelMap  = defaultdict(list)\\n        def dfs(node, level):\\n            if not node:\\n                return levelMap\\n            levelMap[level].append(node.val)\\n            dfs(node.left, level + 1)\\n            dfs(node.right, level + 1)\\n        dfs(root, 0)\\n        ans = []\\n        for i, v in levelMap.items():\\n            ans.append((sum(v)))\\n        \\n        ans = sorted(ans, reverse=True)\\n        # print(ans)\\n        if len(ans) < k:\\n            return -1\\n        return ans[k - 1]\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def kthLargestLevelSum(self, root: Optional[TreeNode], k: int) -> int:\\n        levelMap  = defaultdict(list)\\n        def dfs(node, level):\\n            if not node:\\n                return levelMap\\n            levelMap[level].append(node.val)\\n            dfs(node.left, level + 1)\\n            dfs(node.right, level + 1)\\n        dfs(root, 0)\\n        ans = []\\n        for i, v in levelMap.items():\\n            ans.append((sum(v)))\\n        \\n        ans = sorted(ans, reverse=True)\\n        # print(ans)\\n        if len(ans) < k:\\n            return -1\\n        return ans[k - 1]\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3258360,
                "title": "c-preorder-traversal-using-recursion-easy-with-explanation",
                "content": "# Intuition\\nwe need to keep track of sum of element level wise so we will use map to store sum level wise.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nfirst we will use a map to store sum level wise, and then put all sum of elements levelwise in priority queue and then we can easily find kth maximum element.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    void traverse(TreeNode* root,map<int,long long int>& mp,int level){\\n        if(root==NULL){\\n            return;\\n        }\\n        mp[level]+=root->val;\\n        traverse(root->left,mp,level+1);\\n        traverse(root->right,mp,level+1);\\n    }\\n    \\n    long long kthLargestLevelSum(TreeNode* root, int k) {\\n        map<int,long long int>mp;\\n        traverse(root,mp,1);\\n        priority_queue<long long int>pq;\\n        for(auto it:mp){\\n            pq.push(it.second);\\n        }\\n        while(--k ){\\n            pq.pop();\\n            if(pq.empty()){\\n                return -1;\\n            }\\n        }\\n        return pq.top();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    void traverse(TreeNode* root,map<int,long long int>& mp,int level){\\n        if(root==NULL){\\n            return;\\n        }\\n        mp[level]+=root->val;\\n        traverse(root->left,mp,level+1);\\n        traverse(root->right,mp,level+1);\\n    }\\n    \\n    long long kthLargestLevelSum(TreeNode* root, int k) {\\n        map<int,long long int>mp;\\n        traverse(root,mp,1);\\n        priority_queue<long long int>pq;\\n        for(auto it:mp){\\n            pq.push(it.second);\\n        }\\n        while(--k ){\\n            pq.pop();\\n            if(pq.empty()){\\n                return -1;\\n            }\\n        }\\n        return pq.top();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3258260,
                "title": "level-order-traversal-priority-queue",
                "content": "# class Solution {\\n    public long kthLargestLevelSum(TreeNode root, int k) {\\n        Queue<TreeNode> q=new LinkedList<>();\\n        PriorityQueue<Long> pq=new PriorityQueue<>(Collections.reverseOrder());\\n        q.add(root);\\n        int c=0;\\n        while(!q.isEmpty())\\n        {\\n            int count=q.size();\\n            long ans=0;\\n            for(int i=0;i<count;i++)\\n            {\\n                TreeNode curr=q.poll();\\n                ans+=curr.val;\\n                if(curr.left!=null)\\n                {\\n                    q.add(curr.left);\\n                }\\n                if(curr.right!=null)\\n                {\\n                    q.add(curr.right);\\n                }\\n            }\\n            c++;\\n            //System.out.println(ans);\\n            pq.add(ans);\\n        }\\n        if(c<k)\\n        {\\n            return -1;\\n        }\\n        while(k!=1)\\n        {\\n            pq.poll();\\n            k--;\\n        }\\n        return pq.peek();\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search"
                ],
                "code": "class Solution {\\n    public long kthLargestLevelSum(TreeNode root, int k) {\\n        Queue<TreeNode> q=new LinkedList<>();\\n        PriorityQueue<Long> pq=new PriorityQueue<>(Collections.reverseOrder());\\n        q.add(root);\\n        int c=0;\\n        while(!q.isEmpty())\\n        {\\n            int count=q.size();\\n            long ans=0;\\n            for(int i=0;i<count;i++)\\n            {\\n                TreeNode curr=q.poll();\\n                ans+=curr.val;\\n                if(curr.left!=null)\\n                {\\n                    q.add(curr.left);\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 3258168,
                "title": "python-java-bfs-heap",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def kthLargestLevelSum(self, root: Optional[TreeNode], k: int) -> int:\\n        minHeap = []\\n        curLevel = [root]\\n        while curLevel:\\n            nextLevel = []\\n            s = 0\\n            for node in curLevel:\\n                if node.left:\\n                    nextLevel.append(node.left)\\n                if node.right:\\n                    nextLevel.append(node.right)\\n                s += node.val\\n            heapq.heappush(minHeap, s)\\n            if len(minHeap) > k:\\n                heapq.heappop(minHeap)\\n            curLevel = nextLevel\\n        return minHeap[0] if len(minHeap) == k else -1\\n\\n\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public long kthLargestLevelSum(TreeNode root, int k) {\\n        Queue<Long> minHeap = new PriorityQueue<>();\\n        List<TreeNode> curLevel = new ArrayList<>();\\n        curLevel.add(root);\\n        while (!curLevel.isEmpty()) {\\n            List<TreeNode> nextLevel = new ArrayList<>();\\n            long s = 0;\\n            for (TreeNode node: curLevel) {\\n                if (node.left != null) {\\n                    nextLevel.add(node.left);\\n                }\\n                if (node.right != null) {\\n                    nextLevel.add(node.right);\\n                }\\n                s += node.val;\\n            }\\n            minHeap.offer(s);\\n            if (minHeap.size() > k) {\\n                minHeap.poll();\\n            }\\n            curLevel = nextLevel;\\n        }\\n        return minHeap.size() == k ? minHeap.peek() : -1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Python3"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def kthLargestLevelSum(self, root: Optional[TreeNode], k: int) -> int:\\n        minHeap = []\\n        curLevel = [root]\\n        while curLevel:\\n            nextLevel = []\\n            s = 0\\n            for node in curLevel:\\n                if node.left:\\n                    nextLevel.append(node.left)\\n                if node.right:\\n                    nextLevel.append(node.right)\\n                s += node.val\\n            heapq.heappush(minHeap, s)\\n            if len(minHeap) > k:\\n                heapq.heappop(minHeap)\\n            curLevel = nextLevel\\n        return minHeap[0] if len(minHeap) == k else -1\\n\\n\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public long kthLargestLevelSum(TreeNode root, int k) {\\n        Queue<Long> minHeap = new PriorityQueue<>();\\n        List<TreeNode> curLevel = new ArrayList<>();\\n        curLevel.add(root);\\n        while (!curLevel.isEmpty()) {\\n            List<TreeNode> nextLevel = new ArrayList<>();\\n            long s = 0;\\n            for (TreeNode node: curLevel) {\\n                if (node.left != null) {\\n                    nextLevel.add(node.left);\\n                }\\n                if (node.right != null) {\\n                    nextLevel.add(node.right);\\n                }\\n                s += node.val;\\n            }\\n            minHeap.offer(s);\\n            if (minHeap.size() > k) {\\n                minHeap.poll();\\n            }\\n            curLevel = nextLevel;\\n        }\\n        return minHeap.size() == k ? minHeap.peek() : -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3258108,
                "title": "easy-c-solution-10-line-code-dfs",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    \\nvoid dfs(TreeNode* r, size_t lvl, vector<long long>& sums) {\\n  if (r != nullptr) {\\n    sums.resize(max(sums.size(), lvl));\\n    sums[lvl - 1] += r->val;\\n    dfs(r->left, lvl + 1,sums);\\n    dfs(r->right, lvl + 1,sums);\\n  }\\n    else\\n        return;\\n}\\n    long long kthLargestLevelSum(TreeNode* root, int k) {\\n        vector<long long> sums;\\n       dfs(root, 1,sums);\\n        sort(sums.begin(),sums.end());\\n        if(sums.size()>=k)\\n        return sums[sums.size()-k];\\n        else\\n            return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    \\nvoid dfs(TreeNode* r, size_t lvl, vector<long long>& sums) {\\n  if (r != nullptr) {\\n    sums.resize(max(sums.size(), lvl));\\n    sums[lvl - 1] += r->val;\\n    dfs(r->left, lvl + 1,sums);\\n    dfs(r->right, lvl + 1,sums);\\n  }\\n    else\\n        return;\\n}\\n    long long kthLargestLevelSum(TreeNode* root, int k) {\\n        vector<long long> sums;\\n       dfs(root, 1,sums);\\n        sort(sums.begin(),sums.end());\\n        if(sums.size()>=k)\\n        return sums[sums.size()-k];\\n        else\\n            return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3258105,
                "title": "c-bfs-and-priority-queue",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    long long kthLargestLevelSum(TreeNode* root, int k) {\\n        priority_queue<long long> q;\\n        queue<TreeNode *> que;\\n        que.push(root);\\n        while(que.size()){\\n            long long sum=0;\\n            int size = que.size();\\n            for(int i=0;i<size;i++){\\n                TreeNode *x = que.front();\\n                if(x->left) que.push(x->left);\\n                if(x->right) que.push(x->right);\\n                sum += x->val;\\n                que.pop();\\n            }\\n            q.push(sum);\\n        }\\n        if(q.size()<(k)) return -1;\\n        while(k-->1) q.pop();\\n        return q.top();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    long long kthLargestLevelSum(TreeNode* root, int k) {\\n        priority_queue<long long> q;\\n        queue<TreeNode *> que;\\n        que.push(root);\\n        while(que.size()){\\n            long long sum=0;\\n            int size = que.size();\\n            for(int i=0;i<size;i++){\\n                TreeNode *x = que.front();\\n                if(x->left) que.push(x->left);\\n                if(x->right) que.push(x->right);\\n                sum += x->val;\\n                que.pop();\\n            }\\n            q.push(sum);\\n        }\\n        if(q.size()<(k)) return -1;\\n        while(k-->1) q.pop();\\n        return q.top();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4080888,
                "title": "very-easy-solution-using-level-order",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\n    void inorder(vector<long long>&a,TreeNode*root)\\n    {\\n        if(root==nullptr)\\n        return ;\\n        queue<TreeNode*>q;\\n        q.push(root);\\n        while(!q.empty())\\n        {\\n            int size=q.size();\\n            long long sum=0;\\n            for(int i=0;i<size;i++)\\n            {\\n            TreeNode*p=q.front();\\n             sum=sum+p->val;\\n                q.pop();\\n            if(p->left!=nullptr)\\n            {\\n                q.push(p->left);\\n            }\\n            if(p->right)\\n            {\\n                q.push(p->right);\\n            }\\n            }\\n            a.push_back(sum);\\n        }\\n    }\\npublic:\\n    long long kthLargestLevelSum(TreeNode* root, int k) {\\n        vector<long long>a;\\n        inorder(a,root);\\n        sort(a.begin(),a.end());\\n        if(k>a.size())\\n        return -1;\\n        return a[a.size()-k];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\n    void inorder(vector<long long>&a,TreeNode*root)\\n    {\\n        if(root==nullptr)\\n        return ;\\n        queue<TreeNode*>q;\\n        q.push(root);\\n        while(!q.empty())\\n        {\\n            int size=q.size();\\n            long long sum=0;\\n            for(int i=0;i<size;i++)\\n            {\\n            TreeNode*p=q.front();\\n             sum=sum+p->val;\\n                q.pop();\\n            if(p->left!=nullptr)\\n            {\\n                q.push(p->left);\\n            }\\n            if(p->right)\\n            {\\n                q.push(p->right);\\n            }\\n            }\\n            a.push_back(sum);\\n        }\\n    }\\npublic:\\n    long long kthLargestLevelSum(TreeNode* root, int k) {\\n        vector<long long>a;\\n        inorder(a,root);\\n        sort(a.begin(),a.end());\\n        if(k>a.size())\\n        return -1;\\n        return a[a.size()-k];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4076020,
                "title": "javascript-using-map",
                "content": "\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * function TreeNode(val, left, right) {\\n *     this.val = (val===undefined ? 0 : val)\\n *     this.left = (left===undefined ? null : left)\\n *     this.right = (right===undefined ? null : right)\\n * }\\n */\\n/**\\n * @param {TreeNode} root\\n * @param {number} k\\n * @return {number}\\n */\\nvar kthLargestLevelSum = function (root, k, level = 1) {\\n\\n    const resMap = new Map();\\n    const result = []\\n    let c = resMap.get(level)\\n    c ? resMap.set(level, c + root.val) : resMap.set(level, root.val);\\n    sumLevel(root, 2, resMap);\\n\\n    resMap.forEach((val, key) => result.push(val));\\n    result.sort((a, b) => b - a);\\n    return (result[k - 1]) || -1\\n\\n};\\n\\nconst sumLevel = (root, lvl, map) => {\\n    let c = map.get(lvl)\\n    if (root && root.left && root.right) {\\n        c ? map.set(lvl, c + root.left.val + root.right.val) : map.set(lvl, root.left.val + root.right.val);\\n        sumLevel(root.left, lvl + 1, map); sumLevel(root.right, lvl + 1, map)\\n    }\\n    if (root && root.left && !root.right) {\\n        c ? map.set(lvl, c + root.left.val) : map.set(lvl, root.left.val);\\n        sumLevel(root.left, lvl + 1, map);\\n    }\\n    if (root && !root.left && root.right) {\\n        c ? map.set(lvl, c + root.right.val) : map.set(lvl, root.right.val);\\n        sumLevel(root.right, lvl + 1, map)\\n    }\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * function TreeNode(val, left, right) {\\n *     this.val = (val===undefined ? 0 : val)\\n *     this.left = (left===undefined ? null : left)\\n *     this.right = (right===undefined ? null : right)\\n * }\\n */\\n/**\\n * @param {TreeNode} root\\n * @param {number} k\\n * @return {number}\\n */\\nvar kthLargestLevelSum = function (root, k, level = 1) {\\n\\n    const resMap = new Map();\\n    const result = []\\n    let c = resMap.get(level)\\n    c ? resMap.set(level, c + root.val) : resMap.set(level, root.val);\\n    sumLevel(root, 2, resMap);\\n\\n    resMap.forEach((val, key) => result.push(val));\\n    result.sort((a, b) => b - a);\\n    return (result[k - 1]) || -1\\n\\n};\\n\\nconst sumLevel = (root, lvl, map) => {\\n    let c = map.get(lvl)\\n    if (root && root.left && root.right) {\\n        c ? map.set(lvl, c + root.left.val + root.right.val) : map.set(lvl, root.left.val + root.right.val);\\n        sumLevel(root.left, lvl + 1, map); sumLevel(root.right, lvl + 1, map)\\n    }\\n    if (root && root.left && !root.right) {\\n        c ? map.set(lvl, c + root.left.val) : map.set(lvl, root.left.val);\\n        sumLevel(root.left, lvl + 1, map);\\n    }\\n    if (root && !root.left && root.right) {\\n        c ? map.set(lvl, c + root.right.val) : map.set(lvl, root.right.val);\\n        sumLevel(root.right, lvl + 1, map)\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4070893,
                "title": "java-level-order-traversal-and-heap",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSo first when i saw the question  first thing that came into my mind is to use a Max Heap since using a max heap will be a easy  and efficient way to retireve the maximum sum, since all we have to do is a poping from the back.\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nFirst maintain a variable to track the level wise sum in my case its \"cs\" in the code, just do the level order traversal or bfs using a queue and every time while adding root to the queue add it to our cs  variable\\n* Add the level sum i.e cs to the heap\\n* After adding all the sum to the heap just pop the heap k times and return the peek\\n\\n# Complexity\\n**Time Complexity:**\\nL**evel Order Traversal:** The code performs a level-order traversal of the binary tree using a queue. In the worst case, it visits all nodes once, so the level order traversal has a time complexity of O(N), where N is the number of nodes in the binary tree.\\n\\n**Heap Operations:** The code adds each level\\'s sum to a max heap. Each insertion or removal operation in a priority queue (heap) takes O(log N) time, where N is the number of elements in the heap. In this case, there can be at most N levels in the binary tree. Therefore, the total time complexity of heap operations is O(N * log N).\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n**Overall, the space complexity of this code is O(N) due to the space required for the queue and the max heap.\\n**\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public long kthLargestLevelSum(TreeNode root, int k) {\\n        \\n        PriorityQueue<Long> heap = new PriorityQueue<Long>(Collections.reverseOrder());\\n\\n      \\n\\n        Queue<TreeNode> q = new LinkedList<>();\\n\\n        q.add(root);\\n\\n        while(!q.isEmpty()){\\n\\n            int n = q.size();\\n            long cs = 0;\\n\\n            while(n -->0 ){\\n\\n            TreeNode temp = q.poll();\\n\\n                cs += temp.val;\\n\\n                if(temp.left != null){\\n                    q.add(temp.left);\\n                }\\n                if(temp.right != null){\\n                    q.add(temp.right);\\n                }\\n        \\n\\n            }\\n            heap.add(cs);\\n        }\\n\\n        if(heap.size() < k){\\n            return -1;\\n        }\\n        while(k-- !=1){\\n            heap.poll();\\n        }\\n        return  heap.peek();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search",
                    "Queue",
                    "Heap (Priority Queue)",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public long kthLargestLevelSum(TreeNode root, int k) {\\n        \\n        PriorityQueue<Long> heap = new PriorityQueue<Long>(Collections.reverseOrder());\\n\\n      \\n\\n        Queue<TreeNode> q = new LinkedList<>();\\n\\n        q.add(root);\\n\\n        while(!q.isEmpty()){\\n\\n            int n = q.size();\\n            long cs = 0;\\n\\n            while(n -->0 ){\\n\\n            TreeNode temp = q.poll();\\n\\n                cs += temp.val;\\n\\n                if(temp.left != null){\\n                    q.add(temp.left);\\n                }\\n                if(temp.right != null){\\n                    q.add(temp.right);\\n                }\\n        \\n\\n            }\\n            heap.add(cs);\\n        }\\n\\n        if(heap.size() < k){\\n            return -1;\\n        }\\n        while(k-- !=1){\\n            heap.poll();\\n        }\\n        return  heap.peek();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4069220,
                "title": "python-dfs-dictionary",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nKey: level\\nValue: sum of node.val of same level\\n\\n# Code\\n```\\nfrom collections import defaultdict\\nclass Solution:\\n    def kthLargestLevelSum(self, root: Optional[TreeNode], k: int) -> int:\\n        level_sum = defaultdict(int)\\n        def dfs(node, level):\\n            if not node:\\n                return \\n            \\n            level_sum[level] += node.val\\n            dfs(node.left, level+1)\\n            dfs(node.right, level+1)\\n\\n        dfs(root, 1)\\n        s = sorted(level_sum.values(), reverse = True)\\n        if k > len(s):\\n            return -1\\n        else:\\n            return s[k-1]\\n```",
                "solutionTags": [
                    "Python3",
                    "Depth-First Search"
                ],
                "code": "```\\nfrom collections import defaultdict\\nclass Solution:\\n    def kthLargestLevelSum(self, root: Optional[TreeNode], k: int) -> int:\\n        level_sum = defaultdict(int)\\n        def dfs(node, level):\\n            if not node:\\n                return \\n            \\n            level_sum[level] += node.val\\n            dfs(node.left, level+1)\\n            dfs(node.right, level+1)\\n\\n        dfs(root, 1)\\n        s = sorted(level_sum.values(), reverse = True)\\n        if k > len(s):\\n            return -1\\n        else:\\n            return s[k-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4061044,
                "title": "easy-c-code-using-level-order-traversal",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    long long kthLargestLevelSum(TreeNode* root, int k) {\\n        vector<long long> ansArray;\\n        if(root == NULL){\\n            return 0;\\n        }\\n        queue<TreeNode*> q;\\n        q.push(root);\\n\\n        while(!q.empty()){\\n            int levelSize = q.size();\\n            long long ans = 0;\\n\\n            for(int i=0;i<levelSize;i++){\\n                TreeNode* frontNode = q.front();\\n                q.pop();\\n\\n                ans += frontNode->val;\\n\\n                if(frontNode->left){\\n                    q.push(frontNode->left);\\n                }\\n                if(frontNode->right){\\n                    q.push(frontNode->right);\\n                }\\n            }\\n            ansArray.push_back(ans);\\n        }\\n\\n        if(ansArray.size() < k){\\n            return -1;\\n        }\\n        sort(ansArray.begin(),ansArray.end());\\n        return ansArray[ansArray.size()-k];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Tree",
                    "Queue",
                    "Sorting",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long kthLargestLevelSum(TreeNode* root, int k) {\\n        vector<long long> ansArray;\\n        if(root == NULL){\\n            return 0;\\n        }\\n        queue<TreeNode*> q;\\n        q.push(root);\\n\\n        while(!q.empty()){\\n            int levelSize = q.size();\\n            long long ans = 0;\\n\\n            for(int i=0;i<levelSize;i++){\\n                TreeNode* frontNode = q.front();\\n                q.pop();\\n\\n                ans += frontNode->val;\\n\\n                if(frontNode->left){\\n                    q.push(frontNode->left);\\n                }\\n                if(frontNode->right){\\n                    q.push(frontNode->right);\\n                }\\n            }\\n            ansArray.push_back(ans);\\n        }\\n\\n        if(ansArray.size() < k){\\n            return -1;\\n        }\\n        sort(ansArray.begin(),ansArray.end());\\n        return ansArray[ansArray.size()-k];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4059712,
                "title": "easy-java-iterative-method-to-overcome-time-limit-exceeds",
                "content": "\\n\\n# Code\\n```\\n// /**\\n//  * Definition for a binary tree node.\\n//  * public class TreeNode {\\n//  *     int val;\\n//  *     TreeNode left;\\n//  *     TreeNode right;\\n//  *     TreeNode() {}\\n//  *     TreeNode(int val) { this.val = val; }\\n//  *     TreeNode(int val, TreeNode left, TreeNode right) {\\n//  *         this.val = val;\\n//  *         this.left = left;\\n//  *         this.right = right;\\n//  *     }\\n//  * }\\n//  */\\nclass Solution {\\n    // public int height(TreeNode node){\\n    //     if(node == null) return 0;\\n    //     return Math.max(height(node.left), height(node.right))+1;\\n    // }\\n    // long sum = 0;\\n\\n    // public void kthLargestLevelSumUtil(TreeNode node, int l){\\n    //     if(node == null) return;\\n    //     if(l==1){\\n    //         sum+=node.val;\\n    //     }\\n    //     kthLargestLevelSumUtil(node.left,l-1);\\n    //     kthLargestLevelSumUtil(node.right, l-1);\\n\\n    // }\\n\\n    public long kthLargestLevelSum(TreeNode root, int k) {\\n        Queue<TreeNode> q = new LinkedList<>();\\n        q.add(root);\\n        List<Long> temp = new  ArrayList<>();\\n        while(!q.isEmpty()){\\n            int c = q.size();\\n            long sum =0;\\n            for(int i=0;i<c;i++){\\n                TreeNode node = q.poll();\\n                sum+= node.val;\\n                if(node.left!=null){\\n                    q.add(node.left);\\n                }if(node.right!=null){\\n                    q.add(node.right);\\n                }\\n            }\\n            temp.add(sum);\\n        }\\n        if(temp.size()<k){\\n            return -1;\\n        }\\n        Collections.sort(temp);\\n        return temp.get(temp.size()-k);\\n\\n\\n        // PriorityQueue<Long> pq = new PriorityQueue<>(k);\\n        // int h = height(root);\\n        // for(int i=1;i<=h;i++){\\n        //     kthLargestLevelSumUtil(root, i);\\n        //     if(pq.isEmpty() || pq.size()<k){\\n        //         pq.add(sum);\\n        //     }else{\\n        //         if(pq.peek()<sum){\\n        //             pq.remove();\\n        //             pq.add(sum);\\n        //         }\\n        //     }\\n\\n        //     sum = 0;\\n        // }\\n        // if(pq.size()<k){\\n        //     return -1;\\n        // }\\n        // return pq.peek();\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n// /**\\n//  * Definition for a binary tree node.\\n//  * public class TreeNode {\\n//  *     int val;\\n//  *     TreeNode left;\\n//  *     TreeNode right;\\n//  *     TreeNode() {}\\n//  *     TreeNode(int val) { this.val = val; }\\n//  *     TreeNode(int val, TreeNode left, TreeNode right) {\\n//  *         this.val = val;\\n//  *         this.left = left;\\n//  *         this.right = right;\\n//  *     }\\n//  * }\\n//  */\\nclass Solution {\\n    // public int height(TreeNode node){\\n    //     if(node == null) return 0;\\n    //     return Math.max(height(node.left), height(node.right))+1;\\n    // }\\n    // long sum = 0;\\n\\n    // public void kthLargestLevelSumUtil(TreeNode node, int l){\\n    //     if(node == null) return;\\n    //     if(l==1){\\n    //         sum+=node.val;\\n    //     }\\n    //     kthLargestLevelSumUtil(node.left,l-1);\\n    //     kthLargestLevelSumUtil(node.right, l-1);\\n\\n    // }\\n\\n    public long kthLargestLevelSum(TreeNode root, int k) {\\n        Queue<TreeNode> q = new LinkedList<>();\\n        q.add(root);\\n        List<Long> temp = new  ArrayList<>();\\n        while(!q.isEmpty()){\\n            int c = q.size();\\n            long sum =0;\\n            for(int i=0;i<c;i++){\\n                TreeNode node = q.poll();\\n                sum+= node.val;\\n                if(node.left!=null){\\n                    q.add(node.left);\\n                }if(node.right!=null){\\n                    q.add(node.right);\\n                }\\n            }\\n            temp.add(sum);\\n        }\\n        if(temp.size()<k){\\n            return -1;\\n        }\\n        Collections.sort(temp);\\n        return temp.get(temp.size()-k);\\n\\n\\n        // PriorityQueue<Long> pq = new PriorityQueue<>(k);\\n        // int h = height(root);\\n        // for(int i=1;i<=h;i++){\\n        //     kthLargestLevelSumUtil(root, i);\\n        //     if(pq.isEmpty() || pq.size()<k){\\n        //         pq.add(sum);\\n        //     }else{\\n        //         if(pq.peek()<sum){\\n        //             pq.remove();\\n        //             pq.add(sum);\\n        //         }\\n        //     }\\n\\n        //     sum = 0;\\n        // }\\n        // if(pq.size()<k){\\n        //     return -1;\\n        // }\\n        // return pq.peek();\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4055940,
                "title": "easy-solution-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    long long kthLargestLevelSum(TreeNode* root, int k) {\\n         vector<long long int>arr;\\n        long long int sum=0;\\n         queue<TreeNode*>q;\\n         q.push(root);\\n         q.push(NULL);\\n         while(!q.empty())\\n         {\\n             TreeNode* temp=q.front();\\n             q.pop();\\n             if(temp==NULL)\\n             {\\n                 arr.push_back(sum);\\n                 if(!q.empty())\\n                 {\\n                     q.push(NULL);\\n                 }\\n                 sum=0;\\n             }\\n             else\\n             {\\n                 sum=sum+temp->val;\\n                 if(temp->left)\\n                     q.push(temp->left);\\n                 if(temp->right)\\n                     q.push(temp->right);  \\n             }\\n         }\\n         sort(arr.begin(),arr.end());\\n         reverse(arr.begin(),arr.end());\\n         for(int i=0;i<arr.size();i++)\\n         {\\n             if(i==k-1)\\n             {\\n                 return arr[i];\\n             }\\n         }\\n         return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    long long kthLargestLevelSum(TreeNode* root, int k) {\\n         vector<long long int>arr;\\n        long long int sum=0;\\n         queue<TreeNode*>q;\\n         q.push(root);\\n         q.push(NULL);\\n         while(!q.empty())\\n         {\\n             TreeNode* temp=q.front();\\n             q.pop();\\n             if(temp==NULL)\\n             {\\n                 arr.push_back(sum);\\n                 if(!q.empty())\\n                 {\\n                     q.push(NULL);\\n                 }\\n                 sum=0;\\n             }\\n             else\\n             {\\n                 sum=sum+temp->val;\\n                 if(temp->left)\\n                     q.push(temp->left);\\n                 if(temp->right)\\n                     q.push(temp->right);  \\n             }\\n         }\\n         sort(arr.begin(),arr.end());\\n         reverse(arr.begin(),arr.end());\\n         for(int i=0;i<arr.size();i++)\\n         {\\n             if(i==k-1)\\n             {\\n                 return arr[i];\\n             }\\n         }\\n         return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4049441,
                "title": "c-level-order-traverse-linkedlist",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nI wrote a solution by applying level order traversal. The queue is implemented using C# LinkedList<TreeNode>. \\n\\nWhat I learn is to apply overload API C# LinkedList.AddFirst<T>() instead of calling LinkedList.AddFrist<LinkedListNode<T>>. \\n\\nDeclare \\n```\\nlong sum = 0;\\n```\\nInstead of \\n```\\nvar sum = 0; \\n```\\nlong data type should be applied to local variable sum instead of integer. \\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     public int val;\\n *     public TreeNode left;\\n *     public TreeNode right;\\n *     public TreeNode(int val=0, TreeNode left=null, TreeNode right=null) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\npublic class Solution {\\n    /// <summary>\\n        /// 2583 kth largest sum in a binary tree\\n        /// </summary>\\n        /// <param name=\"root\"></param>\\n        /// <param name=\"k\"></param>\\n        /// <returns></returns>\\n        public long KthLargestLevelSum(TreeNode root, int k)\\n        {\\n            if (root == null)\\n            {\\n                return -1; \\n            }\\n\\n            var list = new List<long>();\\n            var queue = new LinkedList<TreeNode>();\\n\\n            queue.AddFirst(root);\\n\\n            while (queue.Any())\\n            {\\n                var next = new LinkedList<TreeNode>();\\n                long sum = 0; \\n\\n                while (queue.Any())\\n                {\\n                    var node = queue.First.Value;\\n                    queue.RemoveFirst();\\n\\n                    sum = sum + node.val;\\n\\n                    if (node.left != null)\\n                    {\\n                        next.AddLast(node.left); \\n                    }\\n\\n                    if (node.right != null)\\n                    {\\n                        next.AddLast(node.right);\\n                    }\\n                }\\n\\n                list.Add(sum); \\n                queue = next; \\n            }\\n\\n            list.Sort();\\n\\n            if (list.Count < k)\\n            {\\n                return -1; \\n            }\\n\\n            // kth largest one \\n            return list[list.Count - k ]; \\n        }\\n\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\nlong sum = 0;\\n```\n```\\nvar sum = 0; \\n```\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     public int val;\\n *     public TreeNode left;\\n *     public TreeNode right;\\n *     public TreeNode(int val=0, TreeNode left=null, TreeNode right=null) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\npublic class Solution {\\n    /// <summary>\\n        /// 2583 kth largest sum in a binary tree\\n        /// </summary>\\n        /// <param name=\"root\"></param>\\n        /// <param name=\"k\"></param>\\n        /// <returns></returns>\\n        public long KthLargestLevelSum(TreeNode root, int k)\\n        {\\n            if (root == null)\\n            {\\n                return -1; \\n            }\\n\\n            var list = new List<long>();\\n            var queue = new LinkedList<TreeNode>();\\n\\n            queue.AddFirst(root);\\n\\n            while (queue.Any())\\n            {\\n                var next = new LinkedList<TreeNode>();\\n                long sum = 0; \\n\\n                while (queue.Any())\\n                {\\n                    var node = queue.First.Value;\\n                    queue.RemoveFirst();\\n\\n                    sum = sum + node.val;\\n\\n                    if (node.left != null)\\n                    {\\n                        next.AddLast(node.left); \\n                    }\\n\\n                    if (node.right != null)\\n                    {\\n                        next.AddLast(node.right);\\n                    }\\n                }\\n\\n                list.Add(sum); \\n                queue = next; \\n            }\\n\\n            list.Sort();\\n\\n            if (list.Count < k)\\n            {\\n                return -1; \\n            }\\n\\n            // kth largest one \\n            return list[list.Count - k ]; \\n        }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4045368,
                "title": "bfs-priority-queue-vector-and-sorting",
                "content": "# Intuition\\nThe question was asking to print the kth largest level sum i.e go on a particular level using traversal add up all the node values you have at that particular level and print the kth largest sum from the level sum.\\n\\n# Approach\\nThe implementation was revolving around basic bfs and the choice of data structure you want there were two ways by which I got the solution.\\n1) using priority queue and storing only k largest elements(this is the one you\\'ll find down in the code)\\n2) use of vector or array to store the sum values sort them and print the (totalsize-k)th element.\\n\\nThe one with priority is storing elements until the size of priority queue is strictly less than k. After that we compare as the priority queue here implements min heap i.e the smallest element is the top one. So if the size of the queue is restricted to k then guess which element would be at the top in the end.. yeah right it\\'s kth largest one.\\nOkay so when the size of the queue is k then we comapre if the current sum is greater than the top most element of the queue if yes pop the top element and insert the current sum. Repeat this process till the intial queue becomes empty.\\n\\nAt last give the top element as the return value only if we get the k as the argument is greater than the queue size otherwise give -1. \\n\\n# Complexity\\n- Time complexity:\\nInsertion in priority queue takes log(n) time so mantaining the k size would mean inserting k elements and then deleting some elements so roughly let\\'s take it O(nlogn) now the bfs we are visiting every node and edge so it\\'ll count to O(V+E) V the number of vertices and E the number of edges.\\nSo total it would go upto O(V+VlogV+E);\\n\\n- Space complexity:\\nO(V) as we are using two auxillary spaces a priority queue to give out the kth largest sum and a simple queue for traversal.\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    long long kthLargestLevelSum(TreeNode* root, int k) {\\n        priority_queue<long long ,vector<long long >, greater<long long >> pq;\\n        queue<TreeNode*> q;\\n        q.push(root);\\n        while(!q.empty()){           \\n            int szz=q.size();\\n            long long cur_sum=0;\\n            while(szz--){\\n                TreeNode* curr=q.front();\\n                q.pop();\\n                cur_sum+=curr->val;\\n                if(curr->left)q.push(curr->left);\\n                if(curr->right)q.push(curr->right);\\n            }\\n            if(pq.size()<k) pq.push(cur_sum);\\n            else{\\n                if(pq.top()<cur_sum){\\n                    pq.pop();\\n                    pq.push(cur_sum);\\n                }\\n            }\\n        }\\n        return (k>pq.size()?-1:pq.top());\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Greedy",
                    "Queue",
                    "Sorting",
                    "Heap (Priority Queue)",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    long long kthLargestLevelSum(TreeNode* root, int k) {\\n        priority_queue<long long ,vector<long long >, greater<long long >> pq;\\n        queue<TreeNode*> q;\\n        q.push(root);\\n        while(!q.empty()){           \\n            int szz=q.size();\\n            long long cur_sum=0;\\n            while(szz--){\\n                TreeNode* curr=q.front();\\n                q.pop();\\n                cur_sum+=curr->val;\\n                if(curr->left)q.push(curr->left);\\n                if(curr->right)q.push(curr->right);\\n            }\\n            if(pq.size()<k) pq.push(cur_sum);\\n            else{\\n                if(pq.top()<cur_sum){\\n                    pq.pop();\\n                    pq.push(cur_sum);\\n                }\\n            }\\n        }\\n        return (k>pq.size()?-1:pq.top());\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4031347,
                "title": "python3-solution-using-bfs",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nThis code computes the k-th largest level sum in a binary tree by performing a breadth-first traversal. It stores the level sums in a list, sorts it, and returns the k-th largest sum. If k exceeds the number of levels, it returns -1.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def kthLargestLevelSum(self, root: Optional[TreeNode], k: int) -> int:\\n        res=[]\\n        if not root:\\n            return\\n        q=deque([root])\\n        while q:\\n            curr=0\\n            for _ in range(len(q)):\\n                node=q.popleft()\\n                curr=curr+node.val\\n                if node.left:\\n                    q.append(node.left)\\n                if node.right:\\n                    q.append(node.right)\\n            res.append(curr)\\n        res.sort()\\n        if k<=len(res):\\n            return res[len(res)-k]\\n        else:\\n            return -1\\n        \\n```",
                "solutionTags": [
                    "Python3",
                    "Tree",
                    "Breadth-First Search"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def kthLargestLevelSum(self, root: Optional[TreeNode], k: int) -> int:\\n        res=[]\\n        if not root:\\n            return\\n        q=deque([root])\\n        while q:\\n            curr=0\\n            for _ in range(len(q)):\\n                node=q.popleft()\\n                curr=curr+node.val\\n                if node.left:\\n                    q.append(node.left)\\n                if node.right:\\n                    q.append(node.right)\\n            res.append(curr)\\n        res.sort()\\n        if k<=len(res):\\n            return res[len(res)-k]\\n        else:\\n            return -1\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 4028363,
                "title": "cpp-solution",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    long long kthLargestLevelSum(TreeNode* root, int k) \\n    {\\n        if(!root) return -1;\\n        queue<TreeNode*> store;\\n        store.push(root);\\n        store.push(NULL);\\n        vector<long long> answer;\\n        long long count = 0;\\n        while(!store.empty())\\n        {\\n            TreeNode *front = store.front();\\n            store.pop();\\n            count += front->val;\\n            if(front->left) store.push(front->left);\\n            if(front->right) store.push(front->right);\\n            if(!store.front())\\n            {\\n                store.pop();\\n                if(!store.empty()) store.push(NULL);\\n                answer.push_back(count);\\n                count = 0;\\n            }\\n        }    \\n        if(answer.size() < k) return -1;\\n        sort(answer.begin() , answer.end());\\n        return answer[answer.size() - k];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long kthLargestLevelSum(TreeNode* root, int k) \\n    {\\n        if(!root) return -1;\\n        queue<TreeNode*> store;\\n        store.push(root);\\n        store.push(NULL);\\n        vector<long long> answer;\\n        long long count = 0;\\n        while(!store.empty())\\n        {\\n            TreeNode *front = store.front();\\n            store.pop();\\n            count += front->val;\\n            if(front->left) store.push(front->left);\\n            if(front->right) store.push(front->right);\\n            if(!store.front())\\n            {\\n                store.pop();\\n                if(!store.empty()) store.push(NULL);\\n                answer.push_back(count);\\n                count = 0;\\n            }\\n        }    \\n        if(answer.size() < k) return -1;\\n        sort(answer.begin() , answer.end());\\n        return answer[answer.size() - k];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4022661,
                "title": "java-rookie-coder",
                "content": "# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public long kthLargestLevelSum(TreeNode root, int k) {\\n        Queue<TreeNode> q=new LinkedList<TreeNode>();\\n        ArrayList<Long> ans=new ArrayList<Long>();\\n        \\n        q.add(root);\\n        while(!q.isEmpty()){\\n            ArrayList<Integer> temp=new ArrayList<Integer>();\\n            int size=q.size();\\n            for(int i=0;i<size;i++){\\n                TreeNode node=q.poll();\\n                temp.add(node.val);\\n                if(node.left!=null) q.add(node.left);\\n                if(node.right!=null) q.add(node.right);\\n                \\n            }\\n            long sum=sum(temp);\\n             ans.add(sum);    \\n        }\\n        Collections.sort(ans,Collections.reverseOrder());\\n        if(ans.size()<k) return -1;\\n        else\\n            return ans.get(k-1);\\n    }\\n    public long sum(ArrayList<Integer> arr){\\n        long sum=0;\\n        for(long i:arr){\\n            sum+=i;\\n        }\\n        return sum;\\n    }\\n}\\n```\\n~rookie coder",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public long kthLargestLevelSum(TreeNode root, int k) {\\n        Queue<TreeNode> q=new LinkedList<TreeNode>();\\n        ArrayList<Long> ans=new ArrayList<Long>();\\n        \\n        q.add(root);\\n        while(!q.isEmpty()){\\n            ArrayList<Integer> temp=new ArrayList<Integer>();\\n            int size=q.size();\\n            for(int i=0;i<size;i++){\\n                TreeNode node=q.poll();\\n                temp.add(node.val);\\n                if(node.left!=null) q.add(node.left);\\n                if(node.right!=null) q.add(node.right);\\n                \\n            }\\n            long sum=sum(temp);\\n             ans.add(sum);    \\n        }\\n        Collections.sort(ans,Collections.reverseOrder());\\n        if(ans.size()<k) return -1;\\n        else\\n            return ans.get(k-1);\\n    }\\n    public long sum(ArrayList<Integer> arr){\\n        long sum=0;\\n        for(long i:arr){\\n            sum+=i;\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4018083,
                "title": "priority-queue-level-order-traversal-easy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nUsing level order traversal.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nFind the sum of node values at each level and push them in a vector of long long. If the k is greater than the vector size then return -1 else sort a vector in decreasing order and return k-1 th\\nindex element.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(nlog(n))\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    void levelorder(TreeNode* root,vector<long long>& ans){\\n        queue<TreeNode*>q;\\n        long long sum=0;\\n        q.push(root);\\n        q.push(NULL);\\n        while(!q.empty()){\\n            TreeNode* temp=q.front();\\n            q.pop();\\n            if(temp==NULL){\\n                ans.push_back(sum);\\n                if(!q.empty()){\\n                    q.push(NULL);\\n                    sum=0;\\n                }\\n            }\\n            else{\\n                sum+=temp->val;\\n                if(temp->left)\\n                    q.push(temp->left);\\n                if(temp->right)\\n                    q.push(temp->right);\\n            }\\n        }\\n    }\\n    long long kthLargestLevelSum(TreeNode* root, int k) {\\n        vector<long long>ans;\\n        levelorder(root,ans);\\n        sort(ans.begin(),ans.end(),greater<long long>());\\n        if(k>ans.size())\\n            return -1;\\n        else\\n            return ans[k-1];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Sort",
                    "Tree",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    void levelorder(TreeNode* root,vector<long long>& ans){\\n        queue<TreeNode*>q;\\n        long long sum=0;\\n        q.push(root);\\n        q.push(NULL);\\n        while(!q.empty()){\\n            TreeNode* temp=q.front();\\n            q.pop();\\n            if(temp==NULL){\\n                ans.push_back(sum);\\n                if(!q.empty()){\\n                    q.push(NULL);\\n                    sum=0;\\n                }\\n            }\\n            else{\\n                sum+=temp->val;\\n                if(temp->left)\\n                    q.push(temp->left);\\n                if(temp->right)\\n                    q.push(temp->right);\\n            }\\n        }\\n    }\\n    long long kthLargestLevelSum(TreeNode* root, int k) {\\n        vector<long long>ans;\\n        levelorder(root,ans);\\n        sort(ans.begin(),ans.end(),greater<long long>());\\n        if(k>ans.size())\\n            return -1;\\n        else\\n            return ans[k-1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4016678,
                "title": "simple-level-order",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public long kthLargestLevelSum(TreeNode root, int k) {\\n        if (root == null) {\\n            return -1; // Handle the case of an empty tree\\n        }\\n\\n        Queue<TreeNode> queue = new LinkedList<>();\\n        queue.add(root);\\n\\n        List<Long> levelSums = new ArrayList<>();\\n\\n        while (!queue.isEmpty()) {\\n            int size = queue.size();\\n            long sum = 0;\\n\\n            for (int i = 0; i < size; i++) {\\n                TreeNode node = queue.poll();\\n\\n                if (node != null) {\\n                    sum += node.val;\\n\\n                    if (node.left != null) {\\n                        queue.add(node.left);\\n                    }\\n\\n                    if (node.right != null) {\\n                        queue.add(node.right);\\n                    }\\n                }\\n            }\\n\\n            levelSums.add(sum);\\n        }\\n\\n        // Sort the level sums in descending order\\n        Collections.sort(levelSums, Collections.reverseOrder());\\n\\n        if (k <= levelSums.size()) {\\n            return levelSums.get(k - 1); // kth largest is at index k-1\\n        } else {\\n            return -1; // Return -1 if k is out of range\\n        }\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long kthLargestLevelSum(TreeNode root, int k) {\\n        if (root == null) {\\n            return -1; // Handle the case of an empty tree\\n        }\\n\\n        Queue<TreeNode> queue = new LinkedList<>();\\n        queue.add(root);\\n\\n        List<Long> levelSums = new ArrayList<>();\\n\\n        while (!queue.isEmpty()) {\\n            int size = queue.size();\\n            long sum = 0;\\n\\n            for (int i = 0; i < size; i++) {\\n                TreeNode node = queue.poll();\\n\\n                if (node != null) {\\n                    sum += node.val;\\n\\n                    if (node.left != null) {\\n                        queue.add(node.left);\\n                    }\\n\\n                    if (node.right != null) {\\n                        queue.add(node.right);\\n                    }\\n                }\\n            }\\n\\n            levelSums.add(sum);\\n        }\\n\\n        // Sort the level sums in descending order\\n        Collections.sort(levelSums, Collections.reverseOrder());\\n\\n        if (k <= levelSums.size()) {\\n            return levelSums.get(k - 1); // kth largest is at index k-1\\n        } else {\\n            return -1; // Return -1 if k is out of range\\n        }\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4002127,
                "title": "golang-dfs-solution",
                "content": "# Code\\n```go\\nfunc kthLargestLevelSum(root *TreeNode, k int) int64 {\\n\\thash := make(map[int]int, 16)\\n\\tdfs(root, 0, hash)\\n\\tif k > len(hash) {\\n\\t\\treturn -1\\n\\t}\\n\\tsums := make([]int, 0, len(hash))\\n\\tfor _, v := range hash {\\n\\t\\tsums = append(sums, v)\\n\\t}\\n\\tsort.Sort(sort.Reverse(sort.IntSlice(sums)))\\n\\treturn int64(sums[k-1])\\n}\\n\\nfunc dfs(node *TreeNode, level int, hash map[int]int) {\\n\\tif node == nil {\\n\\t\\treturn\\n\\t}\\n\\thash[level] += node.Val\\n\\tdfs(node.Left, level+1, hash)\\n\\tdfs(node.Right, level+1, hash)\\n}\\n\\n```",
                "solutionTags": [
                    "Go",
                    "Depth-First Search"
                ],
                "code": "```go\\nfunc kthLargestLevelSum(root *TreeNode, k int) int64 {\\n\\thash := make(map[int]int, 16)\\n\\tdfs(root, 0, hash)\\n\\tif k > len(hash) {\\n\\t\\treturn -1\\n\\t}\\n\\tsums := make([]int, 0, len(hash))\\n\\tfor _, v := range hash {\\n\\t\\tsums = append(sums, v)\\n\\t}\\n\\tsort.Sort(sort.Reverse(sort.IntSlice(sums)))\\n\\treturn int64(sums[k-1])\\n}\\n\\nfunc dfs(node *TreeNode, level int, hash map[int]int) {\\n\\tif node == nil {\\n\\t\\treturn\\n\\t}\\n\\thash[level] += node.Val\\n\\tdfs(node.Left, level+1, hash)\\n\\tdfs(node.Right, level+1, hash)\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3998996,
                "title": "two-solutions-bfs-and-dfs-runtime-100",
                "content": "![\\u0421\\u043D\\u0438\\u043C\\u043E\\u043A \\u044D\\u043A\\u0440\\u0430\\u043D\\u0430 2023-09-04 \\u0432 02.38.17.png](https://assets.leetcode.com/users/images/4bf93397-8fe6-46d2-86cc-085ccd6d0f5c_1693784347.2070656.png)\\n```\\nclass Solution:\\n    def kthLargestLevelSum(self, root: Optional[TreeNode], k: int) -> int:\\n        queue = [root]\\n        list_sum = []\\n        while queue:\\n            new_queue = []\\n            sum_node = 0\\n            for node in queue:\\n                sum_node += node.val\\n                if node.left:\\n                    new_queue.append(node.left)\\n                if node.right:\\n                    new_queue.append(node.right)\\n            list_sum.append(sum_node)\\n            queue = new_queue\\n        return sorted(list_sum, reverse= True)[k-1] if len(list_sum) >= k else -1\\n```\\n```\\nclass Solution:\\n    def kthLargestLevelSum(self, root: Optional[TreeNode], k: int) -> int:\\n        list_sum = self.level_sum(root, 0, [])\\n        return sorted(list_sum, reverse= True)[k-1] if len(list_sum) >= k else -1\\n\\n    def level_sum(self, root, level, list_sum):\\n        if not root:\\n            return list_sum\\n        if level == len(list_sum):\\n            list_sum.append(root.val)\\n        else:\\n            list_sum[level] += root.val\\n        self.level_sum(root.left, level+1, list_sum)\\n        self.level_sum(root.right, level+1, list_sum)\\n        return list_sum   \\n```",
                "solutionTags": [
                    "Python3",
                    "Tree",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution:\\n    def kthLargestLevelSum(self, root: Optional[TreeNode], k: int) -> int:\\n        queue = [root]\\n        list_sum = []\\n        while queue:\\n            new_queue = []\\n            sum_node = 0\\n            for node in queue:\\n                sum_node += node.val\\n                if node.left:\\n                    new_queue.append(node.left)\\n                if node.right:\\n                    new_queue.append(node.right)\\n            list_sum.append(sum_node)\\n            queue = new_queue\\n        return sorted(list_sum, reverse= True)[k-1] if len(list_sum) >= k else -1\\n```\n```\\nclass Solution:\\n    def kthLargestLevelSum(self, root: Optional[TreeNode], k: int) -> int:\\n        list_sum = self.level_sum(root, 0, [])\\n        return sorted(list_sum, reverse= True)[k-1] if len(list_sum) >= k else -1\\n\\n    def level_sum(self, root, level, list_sum):\\n        if not root:\\n            return list_sum\\n        if level == len(list_sum):\\n            list_sum.append(root.val)\\n        else:\\n            list_sum[level] += root.val\\n        self.level_sum(root.left, level+1, list_sum)\\n        self.level_sum(root.right, level+1, list_sum)\\n        return list_sum   \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3997600,
                "title": "using-level-order-traversal-and-maxheap",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    long long kthLargestLevelSum(TreeNode* root, int k) {\\n        if(root == NULL)\\n            return -1;\\n\\n        // initially \\n        priority_queue<long long> pq;\\n        queue<TreeNode*> q;\\n        q.push(root);\\n        q.push(NULL);\\n        long long sum = 0;\\n\\n        while(!q.empty()){\\n            // take out front and pop it\\n            auto front = q.front();\\n            q.pop();\\n\\n            // if front is nulll its maens level is changed\\n            if(front == NULL){\\n                // push sum and make sum as 0\\n                pq.push(sum);\\n                sum = 0;\\n                if(!q.empty())\\n                    q.push(NULL);\\n            }\\n            // else push ans in array\\n            else{\\n                // update sum level wise\\n                sum += front->val;\\n                // if further left or right exists then push them in queue\\n                if(front->left != NULL)\\n                    q.push(front->left);\\n                if(front->right != NULL)\\n                    q.push(front->right);\\n            }\\n        }\\n        // if heap size is less than k means there no such kth largest sum exits so return -1;\\n        if(pq.size() < k)\\n            return -1;\\n\\n        // pop k times and return top as kth largest sum\\n        k--;\\n        while(k--)\\n            pq.pop();\\n        \\n        return pq.top();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    long long kthLargestLevelSum(TreeNode* root, int k) {\\n        if(root == NULL)\\n            return -1;\\n\\n        // initially \\n        priority_queue<long long> pq;\\n        queue<TreeNode*> q;\\n        q.push(root);\\n        q.push(NULL);\\n        long long sum = 0;\\n\\n        while(!q.empty()){\\n            // take out front and pop it\\n            auto front = q.front();\\n            q.pop();\\n\\n            // if front is nulll its maens level is changed\\n            if(front == NULL){\\n                // push sum and make sum as 0\\n                pq.push(sum);\\n                sum = 0;\\n                if(!q.empty())\\n                    q.push(NULL);\\n            }\\n            // else push ans in array\\n            else{\\n                // update sum level wise\\n                sum += front->val;\\n                // if further left or right exists then push them in queue\\n                if(front->left != NULL)\\n                    q.push(front->left);\\n                if(front->right != NULL)\\n                    q.push(front->right);\\n            }\\n        }\\n        // if heap size is less than k means there no such kth largest sum exits so return -1;\\n        if(pq.size() < k)\\n            return -1;\\n\\n        // pop k times and return top as kth largest sum\\n        k--;\\n        while(k--)\\n            pq.pop();\\n        \\n        return pq.top();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3997445,
                "title": "java-easy-solution",
                "content": "\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public long kthLargestLevelSum(TreeNode root, int k) {\\n        Queue<TreeNode> q = new LinkedList<>();\\n        List<Long> list = new ArrayList<>();\\n        q.add(root);\\n        while(!q.isEmpty())\\n        {\\n            int size=q.size();\\n            long sum=0;\\n            for (int i=0;i<size;i++)\\n            {\\n                TreeNode temp =q.poll();\\n                sum+=temp.val;\\n                if (temp.left!=null)\\n                q.add(temp.left);\\n                if (temp.right!=null)\\n                q.add(temp.right);\\n            }\\n            list.add(sum);\\n        }\\n        Collections.sort(list);\\n        return k>list.size() ? -1 : list.get(list.size()-k);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Tree",
                    "Breadth-First Search",
                    "Queue"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public long kthLargestLevelSum(TreeNode root, int k) {\\n        Queue<TreeNode> q = new LinkedList<>();\\n        List<Long> list = new ArrayList<>();\\n        q.add(root);\\n        while(!q.isEmpty())\\n        {\\n            int size=q.size();\\n            long sum=0;\\n            for (int i=0;i<size;i++)\\n            {\\n                TreeNode temp =q.poll();\\n                sum+=temp.val;\\n                if (temp.left!=null)\\n                q.add(temp.left);\\n                if (temp.right!=null)\\n                q.add(temp.right);\\n            }\\n            list.add(sum);\\n        }\\n        Collections.sort(list);\\n        return k>list.size() ? -1 : list.get(list.size()-k);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3991218,
                "title": "easy-cpp-solution-using-vector-and-sorting",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\ndo bfs and find sum at each level and use a heap or vector to store and sort them and find the kth largest;\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\ndo bfs and find sum at each level and use a heap or vector to store and sort them and find the kth largest;\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(nlogn)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\no(n)\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    long long kthLargestLevelSum(TreeNode* root, int k) {\\n  //       queue<TreeNode*>q;\\n  //       vector<long long>v;\\n  //       if(root==NULL)return 0;\\n  //       q.push(root);\\n  //       while(!q.empty()){\\n  //         int size=q.size();\\n  //         vector<long long>m;\\n  //         while(size!=0){\\n  //              TreeNode* x=q.front();\\n  //              m.push_back(x->val);\\n  //              q.pop();\\n  //              if(x->left!=nullptr)q.push(x->left);\\n  //              if(x->right!=nullptr)q.push(x->right);\\n  //             size--;\\n  //         }\\n  //         v.push_back(accumulate(m.begin(),m.end(),0));\\n       \\n  //       }\\n  //        sort(v.begin(),v.end() );\\n  //        if(k > v.size()){\\n  //          return -1;\\n  //        }\\n  //  return v[v.size()-k];\\n\\n      queue<pair<TreeNode*, long long>> q;\\n      q.push({root,1});\\n      long long sum = 0;\\n      vector<long long> v;\\n      long long level = 1;\\n      while(!q.empty()){\\n        pair<TreeNode*,long long> front = q.front();\\n        q.pop();\\n\\n        if(level < front.second){\\n          v.push_back(sum);\\n          sum = 0;\\n          level++;\\n        }\\n        sum += front.first->val;\\n\\n        if(front.first->left != NULL){\\n          q.push({front.first->left,front.second+1});\\n        }\\n        if(front.first->right != NULL){\\n          q.push({front.first->right,front.second+1});\\n        }\\n      }\\n      v.push_back(sum);\\n\\n      if(k > v.size()) return -1;\\n      sort(v.begin(),v.end());\\n      return v[v.size() - k];\\n  }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Breadth-First Search",
                    "Sorting",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    long long kthLargestLevelSum(TreeNode* root, int k) {\\n  //       queue<TreeNode*>q;\\n  //       vector<long long>v;\\n  //       if(root==NULL)return 0;\\n  //       q.push(root);\\n  //       while(!q.empty()){\\n  //         int size=q.size();\\n  //         vector<long long>m;\\n  //         while(size!=0){\\n  //              TreeNode* x=q.front();\\n  //              m.push_back(x->val);\\n  //              q.pop();\\n  //              if(x->left!=nullptr)q.push(x->left);\\n  //              if(x->right!=nullptr)q.push(x->right);\\n  //             size--;\\n  //         }\\n  //         v.push_back(accumulate(m.begin(),m.end(),0));\\n       \\n  //       }\\n  //        sort(v.begin(),v.end() );\\n  //        if(k > v.size()){\\n  //          return -1;\\n  //        }\\n  //  return v[v.size()-k];\\n\\n      queue<pair<TreeNode*, long long>> q;\\n      q.push({root,1});\\n      long long sum = 0;\\n      vector<long long> v;\\n      long long level = 1;\\n      while(!q.empty()){\\n        pair<TreeNode*,long long> front = q.front();\\n        q.pop();\\n\\n        if(level < front.second){\\n          v.push_back(sum);\\n          sum = 0;\\n          level++;\\n        }\\n        sum += front.first->val;\\n\\n        if(front.first->left != NULL){\\n          q.push({front.first->left,front.second+1});\\n        }\\n        if(front.first->right != NULL){\\n          q.push({front.first->right,front.second+1});\\n        }\\n      }\\n      v.push_back(sum);\\n\\n      if(k > v.size()) return -1;\\n      sort(v.begin(),v.end());\\n      return v[v.size() - k];\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3984629,
                "title": "min-heap-bfs-basic",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public long kthLargestLevelSum(TreeNode root, int k) {\\n        Queue<TreeNode> q = new LinkedList<>() ; \\n        PriorityQueue<Long> pq = new PriorityQueue<>();\\n        int level=0 ; \\n        q.offer(root);\\n        int size=q.size();\\n        while(q.size()>0){\\n            int s=q.size();\\n            long sum= 0 ;\\n            level++; \\n            while(s>0){\\n                TreeNode t=q.poll();\\n                sum=sum+t.val;                      \\n                if(t.left!=null)q.offer(t.left);\\n                if(t.right!=null)q.offer(t.right);\\n                s--;\\n            }\\n            pq.offer(sum);\\n            if(pq.size()>k){pq.poll();}\\n            \\n        }\\n        if(level<k)return -1;\\n        return pq.peek();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public long kthLargestLevelSum(TreeNode root, int k) {\\n        Queue<TreeNode> q = new LinkedList<>() ; \\n        PriorityQueue<Long> pq = new PriorityQueue<>();\\n        int level=0 ; \\n        q.offer(root);\\n        int size=q.size();\\n        while(q.size()>0){\\n            int s=q.size();\\n            long sum= 0 ;\\n            level++; \\n            while(s>0){\\n                TreeNode t=q.poll();\\n                sum=sum+t.val;                      \\n                if(t.left!=null)q.offer(t.left);\\n                if(t.right!=null)q.offer(t.right);\\n                s--;\\n            }\\n            pq.offer(sum);\\n            if(pq.size()>k){pq.poll();}\\n            \\n        }\\n        if(level<k)return -1;\\n        return pq.peek();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3975474,
                "title": "solution-to-the-program-using-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public long kthLargestLevelSum(TreeNode root, int k) \\n    {\\n         List<Long> L =new ArrayList<>();\\n        Queue<TreeNode> Q1 =new LinkedList<>();\\n        Q1.offer(root);\\n        while(!Q1.isEmpty())\\n        {\\n            long len = Q1.size();\\n            long sum=0;\\n            for(int i=0;i<len;i++)\\n            {\\n                if(Q1.peek().left!=null)\\n                {\\n                    Q1.offer(Q1.peek().left);\\n                }   \\n                if(Q1.peek().right!=null)\\n                {\\n                    Q1.offer(Q1.peek().right);\\n                }\\n                sum+=Q1.poll().val;\\n            }\\n            L.add(sum);\\n        }\\n        Collections.sort(L);\\n        if(L.size()<k)\\n        {\\n            return -1;\\n        }\\n        return L.get(L.size()-k);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Tree",
                    "Breadth-First Search",
                    "Queue"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public long kthLargestLevelSum(TreeNode root, int k) \\n    {\\n         List<Long> L =new ArrayList<>();\\n        Queue<TreeNode> Q1 =new LinkedList<>();\\n        Q1.offer(root);\\n        while(!Q1.isEmpty())\\n        {\\n            long len = Q1.size();\\n            long sum=0;\\n            for(int i=0;i<len;i++)\\n            {\\n                if(Q1.peek().left!=null)\\n                {\\n                    Q1.offer(Q1.peek().left);\\n                }   \\n                if(Q1.peek().right!=null)\\n                {\\n                    Q1.offer(Q1.peek().right);\\n                }\\n                sum+=Q1.poll().val;\\n            }\\n            L.add(sum);\\n        }\\n        Collections.sort(L);\\n        if(L.size()<k)\\n        {\\n            return -1;\\n        }\\n        return L.get(L.size()-k);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3966307,
                "title": "cpp-priorityqueue-orderleveltraversal",
                "content": "# Approach\\nUsing Priority Queue & OrderlevelTraversal\\n\\n# Complexity\\n- Time complexity:\\n- O(n);\\n- where n is number Node in tree;\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    long long kthLargestLevelSum(TreeNode* root, int k) {\\n        long long count = 0;\\n        queue<TreeNode*>q;\\n        priority_queue<long long ,vector<long long>,greater<long>>klargestElement;\\n        q.push(root);\\n        q.push(NULL);\\n        while(!q.empty()){\\n            TreeNode * node = q.front();\\n            q.pop();\\n            if(node!=NULL)\\n            {\\n                count+=node->val;\\n                if(node->left)\\n                  q.push(node->left);\\n                if(node->right)\\n                  q.push(node->right);\\n            }\\n            else if(!q.empty()){\\n                klargestElement.push(count);\\n                count = 0;\\n                q.push(NULL);\\n            }\\n        }\\n        klargestElement.push(count);\\n        if(k > klargestElement.size())\\n           return -1;\\n        while(klargestElement.size() != k)\\n            klargestElement.pop();\\n        return klargestElement.top();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    long long kthLargestLevelSum(TreeNode* root, int k) {\\n        long long count = 0;\\n        queue<TreeNode*>q;\\n        priority_queue<long long ,vector<long long>,greater<long>>klargestElement;\\n        q.push(root);\\n        q.push(NULL);\\n        while(!q.empty()){\\n            TreeNode * node = q.front();\\n            q.pop();\\n            if(node!=NULL)\\n            {\\n                count+=node->val;\\n                if(node->left)\\n                  q.push(node->left);\\n                if(node->right)\\n                  q.push(node->right);\\n            }\\n            else if(!q.empty()){\\n                klargestElement.push(count);\\n                count = 0;\\n                q.push(NULL);\\n            }\\n        }\\n        klargestElement.push(count);\\n        if(k > klargestElement.size())\\n           return -1;\\n        while(klargestElement.size() != k)\\n            klargestElement.pop();\\n        return klargestElement.top();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3963156,
                "title": "simple-level-order-traversing-min-priority-queue-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    long long kthLargestLevelSum(TreeNode* root, int k) {\\n        if(root==NULL || k<1) return 0;\\n        priority_queue <long long , vector<long long >, greater<long long >> pq;\\n        queue<TreeNode*>q;\\n        q.push(root);\\n        while(!q.empty())\\n        {\\n            int n=q.size();\\n            long long sum=0;\\n            for(int i=0;i<n;i++)\\n            {\\n                TreeNode* temp=q.front();\\n                q.pop();\\n                sum+=temp->val;\\n                if(temp->left) q.push(temp->left);\\n                if(temp->right) q.push(temp->right);\\n            }\\n            pq.push(sum);\\n            if(pq.size()>k) pq.pop();\\n        }\\n        return pq.size()<k ?-1 :pq.top();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    long long kthLargestLevelSum(TreeNode* root, int k) {\\n        if(root==NULL || k<1) return 0;\\n        priority_queue <long long , vector<long long >, greater<long long >> pq;\\n        queue<TreeNode*>q;\\n        q.push(root);\\n        while(!q.empty())\\n        {\\n            int n=q.size();\\n            long long sum=0;\\n            for(int i=0;i<n;i++)\\n            {\\n                TreeNode* temp=q.front();\\n                q.pop();\\n                sum+=temp->val;\\n                if(temp->left) q.push(temp->left);\\n                if(temp->right) q.push(temp->right);\\n            }\\n            pq.push(sum);\\n            if(pq.size()>k) pq.pop();\\n        }\\n        return pq.size()<k ?-1 :pq.top();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3960597,
                "title": "python-easy-bfs-solution",
                "content": "```\\nclass Solution:\\n    def kthLargestLevelSum(self, root: Optional[TreeNode], k: int) -> int:\\n        q = deque([root])\\n        level_sums = []\\n        while q:\\n            level_sum = 0\\n            for _ in range(len(q)):\\n                n = q.popleft()\\n                level_sum += n.val\\n                if n.left:\\n                    q.append(n.left)\\n                if n.right:\\n                    q.append(n.right)\\n            level_sums.append(level_sum)\\n        return sorted(level_sums, reverse=True)[k - 1] if len(level_sums) >= k else -1\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def kthLargestLevelSum(self, root: Optional[TreeNode], k: int) -> int:\\n        q = deque([root])\\n        level_sums = []\\n        while q:\\n            level_sum = 0\\n            for _ in range(len(q)):\\n                n = q.popleft()\\n                level_sum += n.val\\n                if n.left:\\n                    q.append(n.left)\\n                if n.right:\\n                    q.append(n.right)\\n            level_sums.append(level_sum)\\n        return sorted(level_sums, reverse=True)[k - 1] if len(level_sums) >= k else -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3951498,
                "title": "easy-to-understand-c-code-using-level-wise-sum",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nUse the level to store the sum of the particular level in vector and then return the k largest level.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nFirst find the levels in the tree.\\nThen make the level_sum vector or array to store the level wise sum.\\nThen sort the vector and return the k largest level sum.\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\nint height(TreeNode* root)\\n{\\n    if(root->left==NULL and root->right==NULL)return 0;\\n    int left=0,right=0;\\n    if(root->left)left=height(root->left);\\n    if(root->right)right=height(root->right);\\n    return max(left,right)+1;\\n}\\nvoid help(TreeNode *root,vector<long long>&sum,int level)\\n{\\n    if(root==NULL)return;\\n    sum[level]+=(long long)root->val;\\n    help(root->left,sum,level+1);\\n    help(root->right,sum,level+1);\\n}\\n    long long kthLargestLevelSum(TreeNode* root, int k) {\\n        int level=height(root);\\n        if(k>level+1)return -1;\\n        vector<long long>sum(level+1,0);\\n        help(root,sum,0);\\n        sort(sum.begin(),sum.end());\\n        return sum[level-k+1];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\nint height(TreeNode* root)\\n{\\n    if(root->left==NULL and root->right==NULL)return 0;\\n    int left=0,right=0;\\n    if(root->left)left=height(root->left);\\n    if(root->right)right=height(root->right);\\n    return max(left,right)+1;\\n}\\nvoid help(TreeNode *root,vector<long long>&sum,int level)\\n{\\n    if(root==NULL)return;\\n    sum[level]+=(long long)root->val;\\n    help(root->left,sum,level+1);\\n    help(root->right,sum,level+1);\\n}\\n    long long kthLargestLevelSum(TreeNode* root, int k) {\\n        int level=height(root);\\n        if(k>level+1)return -1;\\n        vector<long long>sum(level+1,0);\\n        help(root,sum,0);\\n        sort(sum.begin(),sum.end());\\n        return sum[level-k+1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3939209,
                "title": "level-order-traversal-priority-queue",
                "content": "<!-- # Intuition -->\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n<!-- # Approach -->\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n*logk)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    long long kthLargestLevelSum(TreeNode* root, int k) {\\n        priority_queue<long long,vector<long long>,greater<long long>> ans;\\n        queue<TreeNode*> q;\\n        q.push(root);\\n        while(!q.empty()){\\n            int n = q.size();\\n            long long sum = 0;\\n            while(n!=0){\\n                TreeNode* top = q.front();\\n                q.pop();\\n                sum += top->val;\\n                if(top->left)\\n                    q.push(top->left);\\n                if(top->right)\\n                    q.push(top->right);\\n                n--;\\n            }\\n            ans.push(sum);\\n            if(ans.size()>k){\\n                ans.pop();\\n            }\\n        }\\n\\n        if(ans.size()<k)\\n            return -1;\\n\\n        return ans.top();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    long long kthLargestLevelSum(TreeNode* root, int k) {\\n        priority_queue<long long,vector<long long>,greater<long long>> ans;\\n        queue<TreeNode*> q;\\n        q.push(root);\\n        while(!q.empty()){\\n            int n = q.size();\\n            long long sum = 0;\\n            while(n!=0){\\n                TreeNode* top = q.front();\\n                q.pop();\\n                sum += top->val;\\n                if(top->left)\\n                    q.push(top->left);\\n                if(top->right)\\n                    q.push(top->right);\\n                n--;\\n            }\\n            ans.push(sum);\\n            if(ans.size()>k){\\n                ans.pop();\\n            }\\n        }\\n\\n        if(ans.size()<k)\\n            return -1;\\n\\n        return ans.top();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3938664,
                "title": "clean-code-simple-bfs-priorityqueue",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    \\n    public long kthLargestLevelSum(TreeNode root, int k) {\\n        // min heap\\n        PriorityQueue<Long> pq = new PriorityQueue<>(k);\\n        Queue<TreeNode> q = new ArrayDeque<>();\\n        q.add(root);\\n\\n        while (!q.isEmpty()) {\\n            int size = q.size();\\n            Long sum = 0l;\\n            for (int i = 0; i < size; i++) {\\n                TreeNode cur = q.poll();\\n                sum += cur.val;\\n                if(cur.left != null)\\n                    q.add(cur.left);\\n                if (cur.right != null)\\n                    q.add(cur.right);\\n            }\\n            if (pq.size() < k)\\n                pq.add(sum);\\n            else if (pq.size() == k && pq.peek() < sum) {\\n                pq.remove();\\n                pq.add(sum);\\n            }\\n        }\\n        if (pq.size() == k)\\n            return pq.peek();\\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    \\n    public long kthLargestLevelSum(TreeNode root, int k) {\\n        // min heap\\n        PriorityQueue<Long> pq = new PriorityQueue<>(k);\\n        Queue<TreeNode> q = new ArrayDeque<>();\\n        q.add(root);\\n\\n        while (!q.isEmpty()) {\\n            int size = q.size();\\n            Long sum = 0l;\\n            for (int i = 0; i < size; i++) {\\n                TreeNode cur = q.poll();\\n                sum += cur.val;\\n                if(cur.left != null)\\n                    q.add(cur.left);\\n                if (cur.right != null)\\n                    q.add(cur.right);\\n            }\\n            if (pq.size() < k)\\n                pq.add(sum);\\n            else if (pq.size() == k && pq.peek() < sum) {\\n                pq.remove();\\n                pq.add(sum);\\n            }\\n        }\\n        if (pq.size() == k)\\n            return pq.peek();\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3933618,
                "title": "ruby-bfs",
                "content": "```ruby\\n# @param {TreeNode} root\\n# @param {Integer} k\\n# @return {Integer}\\ndef kth_largest_level_sum(root, k)\\n  queue, res = Queue.new, []\\n  queue.push(root)\\n  while queue.length > 0\\n    level_sum = 0\\n    for _ in 0...queue.length\\n      cur = queue.pop\\n      queue.push(cur.left) if cur.left\\n      queue.push(cur.right) if cur.right\\n      level_sum += cur.val\\n    end\\n    res << level_sum\\n  end\\n  k <= res.length ? res.sort[-k] : -1\\nend\\n```",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```ruby\\n# @param {TreeNode} root\\n# @param {Integer} k\\n# @return {Integer}\\ndef kth_largest_level_sum(root, k)\\n  queue, res = Queue.new, []\\n  queue.push(root)\\n  while queue.length > 0\\n    level_sum = 0\\n    for _ in 0...queue.length\\n      cur = queue.pop\\n      queue.push(cur.left) if cur.left\\n      queue.push(cur.right) if cur.right\\n      level_sum += cur.val\\n    end\\n    res << level_sum\\n  end\\n  k <= res.length ? res.sort[-k] : -1\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3924770,
                "title": "java-dfs-list-of-longs",
                "content": "# Complexity\\n- Time complexity: O(N + logN * log(logN))\\n\\n# Code\\n```\\nclass Solution {\\n    public long kthLargestLevelSum(TreeNode root, int k) {\\n        List<Long> list = new ArrayList<>();\\n        dfs(root, list, 0);\\n\\n        if (k > list.size()) return -1;\\n        Collections.sort(list);\\n        return list.get(list.size() - k);\\n    }\\n\\n    private void dfs(TreeNode node, List<Long> list, int lvl) {\\n        if (node == null) return;\\n\\n        if (lvl >= list.size()) list.add(0L);\\n\\n        list.set(lvl, list.get(lvl) + node.val);\\n\\n        dfs(node.left, list, lvl + 1);\\n        dfs(node.right, list, lvl + 1);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long kthLargestLevelSum(TreeNode root, int k) {\\n        List<Long> list = new ArrayList<>();\\n        dfs(root, list, 0);\\n\\n        if (k > list.size()) return -1;\\n        Collections.sort(list);\\n        return list.get(list.size() - k);\\n    }\\n\\n    private void dfs(TreeNode node, List<Long> list, int lvl) {\\n        if (node == null) return;\\n\\n        if (lvl >= list.size()) list.add(0L);\\n\\n        list.set(lvl, list.get(lvl) + node.val);\\n\\n        dfs(node.left, list, lvl + 1);\\n        dfs(node.right, list, lvl + 1);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3923657,
                "title": "java-bfs-quickselect-12ms-beats-100",
                "content": "# Approach\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n1. Perform a Breadth-First search on the binary tree with n nodes and add the sum of each level into a list of long values.\\n2. With this completed list, we perform the quickselection method to find the kth highest value in the array (see: https://leetcode.com/problems/kth-largest-element-in-an-array/description/)\\n3. \\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nThe Breadth-First search takes O(n) time as it traverses through each node once. Since the resulted list contains the sum for each height and the height of the binary tree is logn, the quick selection method takes O(logn) time if n represents the total number of nodes in the tree.\\nSo we have O(n) + O(logn) time which gives us O(n) time\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nBoth the list of longs and the queue takes up n auxillary space, so we used O(2n) space which is still O(n) space\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public long kthLargestLevelSum(TreeNode root, int k) {\\n        List<Long> ans = new ArrayList<>();\\n        Queue<TreeNode> q = new LinkedList<>();\\n        q.add(root);\\n\\n//BFS starts\\n        while (!q.isEmpty()) {\\n            long sum = 0;\\n            int size = q.size();\\n            for (int i = 0; i < size; i++) {\\n                TreeNode curr = q.remove();\\n                sum += curr.val;\\n                if (curr.left != null) {q.add(curr.left);}\\n                if (curr.right != null) {q.add(curr.right);}\\n            }\\n            ans.add(sum);\\n        }\\n//deals with the edgecase of k being larger then the number of levels\\n        if (k > ans.size()) {\\n            return -1;\\n        }\\n//quickselect starts\\n        k = ans.size() - k;\\n        int start = 0;\\n        int idx = 0;\\n        int end = ans.size() - 1;\\n\\n        while (true) {\\n            idx = new Random().nextInt(end - start + 1) + start;\\n            Long piv = ans.get(idx);\\n            Collections.swap(ans, idx, end);\\n            idx = start;\\n            for (int i = start; i <= end; i++) {\\n                if (ans.get(i) <= piv) {\\n                    Collections.swap(ans, i, idx++);\\n                }\\n            }\\n            idx--;\\n            if (idx < k) {\\n                start = idx + 1;\\n            }\\n            else if (idx > k) {\\n                end = idx - 1;\\n            }\\n            else {\\n                break;\\n            }\\n        }\\n        return ans.get(idx);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public long kthLargestLevelSum(TreeNode root, int k) {\\n        List<Long> ans = new ArrayList<>();\\n        Queue<TreeNode> q = new LinkedList<>();\\n        q.add(root);\\n\\n//BFS starts\\n        while (!q.isEmpty()) {\\n            long sum = 0;\\n            int size = q.size();\\n            for (int i = 0; i < size; i++) {\\n                TreeNode curr = q.remove();\\n                sum += curr.val;\\n                if (curr.left != null) {q.add(curr.left);}\\n                if (curr.right != null) {q.add(curr.right);}\\n            }\\n            ans.add(sum);\\n        }\\n//deals with the edgecase of k being larger then the number of levels\\n        if (k > ans.size()) {\\n            return -1;\\n        }\\n//quickselect starts\\n        k = ans.size() - k;\\n        int start = 0;\\n        int idx = 0;\\n        int end = ans.size() - 1;\\n\\n        while (true) {\\n            idx = new Random().nextInt(end - start + 1) + start;\\n            Long piv = ans.get(idx);\\n            Collections.swap(ans, idx, end);\\n            idx = start;\\n            for (int i = start; i <= end; i++) {\\n                if (ans.get(i) <= piv) {\\n                    Collections.swap(ans, i, idx++);\\n                }\\n            }\\n            idx--;\\n            if (idx < k) {\\n                start = idx + 1;\\n            }\\n            else if (idx > k) {\\n                end = idx - 1;\\n            }\\n            else {\\n                break;\\n            }\\n        }\\n        return ans.get(idx);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3917340,
                "title": "easy-dfs-implementation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def kthLargestLevelSum(self, root: Optional[TreeNode], k: int) -> int:\\n        l = {}\\n        def dfs(node,rank):\\n            if not node:\\n                return \\n            if rank in l:\\n                l[rank].append(node.val)\\n            else:\\n                l[rank] = [node.val]\\n            dfs(node.left,rank+1)\\n            dfs(node.right,rank+1)\\n        dfs(root,0)\\n        ans= []\\n        for value in l.values():\\n            ans.append(sum(value))\\n        ans.sort()\\n\\n        return ans[-k] if len(ans)>=k else -1\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def kthLargestLevelSum(self, root: Optional[TreeNode], k: int) -> int:\\n        l = {}\\n        def dfs(node,rank):\\n            if not node:\\n                return \\n            if rank in l:\\n                l[rank].append(node.val)\\n            else:\\n                l[rank] = [node.val]\\n            dfs(node.left,rank+1)\\n            dfs(node.right,rank+1)\\n        dfs(root,0)\\n        ans= []\\n        for value in l.values():\\n            ans.append(sum(value))\\n        ans.sort()\\n\\n        return ans[-k] if len(ans)>=k else -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3911323,
                "title": "python-level-traversal-using-deque-ez-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nUse deque as a TEMPORARY STORAGE to store all nodes on each level. \\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nTraverse the tree by level, everytime we reach a new level, we sum up all the values in this level. Then assign the new q (deque) with a list of all children of current level nodes. This way nodes on the same level will be in the same q (deque)\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(nLog(n)) if we have total n nodes. Traversal takes O(n) time and sorting takes O(nlog(n))\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n) the varaible q deque() is the extra space here.\\n# Leave a like if you think this is helpful! It motivates me as a programmer :)\\n# Code\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def kthLargestLevelSum(self, root: Optional[TreeNode], k: int) -> int:\\n        q = deque()\\n        q.append(root)\\n        level_sum = []\\n\\n        while q:\\n            val = sum([node.val for node in q])\\n            level_sum.append(val)\\n            children = []\\n            for each in q:\\n                if each.left:\\n                    children.append(each.left)\\n                if each.right:\\n                    children.append(each.right)\\n            q = deque(children)\\n        \\n        level_sum.sort(reverse=True)\\n        return level_sum[k-1] if len(level_sum) >= k else -1\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def kthLargestLevelSum(self, root: Optional[TreeNode], k: int) -> int:\\n        q = deque()\\n        q.append(root)\\n        level_sum = []\\n\\n        while q:\\n            val = sum([node.val for node in q])\\n            level_sum.append(val)\\n            children = []\\n            for each in q:\\n                if each.left:\\n                    children.append(each.left)\\n                if each.right:\\n                    children.append(each.right)\\n            q = deque(children)\\n        \\n        level_sum.sort(reverse=True)\\n        return level_sum[k-1] if len(level_sum) >= k else -1\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3895977,
                "title": "simple-c-solution-using-queues-and-null-as-separator-to-determine-where-the-level-ends",
                "content": "\\n\\n# Complexity\\n- Time complexity: O(n) where n is the number of nodes in tree\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n) where n is the number of nodes in tree\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    long long kthLargestLevelSum(TreeNode* root, int k) {\\n        vector<long long> s;\\n        queue<TreeNode*> q;\\n        q.push(root);\\n        q.push(NULL);\\n        long long sum = 0;\\n        while(!q.empty())\\n        {\\n            TreeNode* curr = q.front();\\n            q.pop();\\n            if(curr == NULL)\\n            {                \\n                s.push_back(sum);\\n                sum = 0;\\n                if(!q.empty())\\n                    q.push(NULL);\\n            }\\n            else\\n            {\\n                sum+=curr->val;\\n                if(curr->left)\\n                    q.push(curr->left);\\n                if(curr->right)\\n                    q.push(curr->right);\\n            }\\n\\n        }\\n        sort(s.begin(),s.end(),greater<long>());\\n        if(k>s.size())\\n            return -1;\\n        return s[k-1];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    long long kthLargestLevelSum(TreeNode* root, int k) {\\n        vector<long long> s;\\n        queue<TreeNode*> q;\\n        q.push(root);\\n        q.push(NULL);\\n        long long sum = 0;\\n        while(!q.empty())\\n        {\\n            TreeNode* curr = q.front();\\n            q.pop();\\n            if(curr == NULL)\\n            {                \\n                s.push_back(sum);\\n                sum = 0;\\n                if(!q.empty())\\n                    q.push(NULL);\\n            }\\n            else\\n            {\\n                sum+=curr->val;\\n                if(curr->left)\\n                    q.push(curr->left);\\n                if(curr->right)\\n                    q.push(curr->right);\\n            }\\n\\n        }\\n        sort(s.begin(),s.end(),greater<long>());\\n        if(k>s.size())\\n            return -1;\\n        return s[k-1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3894323,
                "title": "beginners-simplest-and-easiest-beats-99-explained",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\njust make one min heap using priority queue and store sums at each level order traversal.\\n\\nkeep deleteing sums less then kth smallest using pq.pop();\\n\\n```\\npriority_queue<long long,vector<long long>,greater<long long>>pq;\\n```\\n\\nit means Let\\'s say\\n\\npq  =  []\\nbottom => [  ] <= top\\n```\\n\\npq.push(10);\\n[10]\\n\\npq.push(5);\\n[10 5]\\n\\npq.push(99);\\n[99 10 5]\\n\\npq.push(1)\\n\\n[99 10 5 1]\\n```\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    long long kthLargestLevelSum(TreeNode* root, int k) {\\n        priority_queue<long long,vector<long long>,greater<long long>>pq; // min heap to store values in Ascending order\\n\\n        if(root==NULL) return -1;\\n\\n        queue<TreeNode*>q;\\n        q.push(root);\\n        int level=0;\\n\\n        while(!q.empty())\\n        {\\n            level+=1;           // saving number of levels\\n            int size=q.size();\\n            long long sum=0;\\n            for(int i=0;i<size;i++)\\n            {\\n                TreeNode* node=q.front();\\n                q.pop();\\n                sum+=(long long)node->val;\\n                if(node->left)\\n                q.push(node->left);\\n                if(node->right)\\n                q.push(node->right);\\n            }\\n            pq.push(sum);\\n            if(pq.size()>k)     // Just popping out extra small sums because smaller is at top\\n            pq.pop();\\n        }\\n        if(k>level)    //  If there are fewer than k levels in the tree, return -1. (GIVEN)\\n        return -1;\\n\\n        return pq.top();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\npriority_queue<long long,vector<long long>,greater<long long>>pq;\\n```\n```\\n\\npq.push(10);\\n[10]\\n\\npq.push(5);\\n[10 5]\\n\\npq.push(99);\\n[99 10 5]\\n\\npq.push(1)\\n\\n[99 10 5 1]\\n```\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    long long kthLargestLevelSum(TreeNode* root, int k) {\\n        priority_queue<long long,vector<long long>,greater<long long>>pq; // min heap to store values in Ascending order\\n\\n        if(root==NULL) return -1;\\n\\n        queue<TreeNode*>q;\\n        q.push(root);\\n        int level=0;\\n\\n        while(!q.empty())\\n        {\\n            level+=1;           // saving number of levels\\n            int size=q.size();\\n            long long sum=0;\\n            for(int i=0;i<size;i++)\\n            {\\n                TreeNode* node=q.front();\\n                q.pop();\\n                sum+=(long long)node->val;\\n                if(node->left)\\n                q.push(node->left);\\n                if(node->right)\\n                q.push(node->right);\\n            }\\n            pq.push(sum);\\n            if(pq.size()>k)     // Just popping out extra small sums because smaller is at top\\n            pq.pop();\\n        }\\n        if(k>level)    //  If there are fewer than k levels in the tree, return -1. (GIVEN)\\n        return -1;\\n\\n        return pq.top();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3889836,
                "title": "easy-bfs-in-javascript",
                "content": "# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * function TreeNode(val, left, right) {\\n *     this.val = (val===undefined ? 0 : val)\\n *     this.left = (left===undefined ? null : left)\\n *     this.right = (right===undefined ? null : right)\\n * }\\n */\\n/**\\n * @param {TreeNode} root\\n * @param {number} k\\n * @return {number}\\n */\\nvar kthLargestLevelSum = function(root, k) {\\n    let levelSumArr = [], queue = [root];\\n    while(queue.length > 0) {\\n        let sum = 0, size = queue.length;\\n        while(size > 0) {\\n            let q = queue.shift()\\n            sum += q.val;\\n            if(q.left) queue.push(q.left);\\n            if(q.right) queue.push(q.right);\\n            size--;\\n        }\\n        levelSumArr.push(sum);\\n    }\\n    levelSumArr = levelSumArr.sort((a,b) => a-b)\\n    return levelSumArr[levelSumArr.length - k] || -1;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Breadth-First Search",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * function TreeNode(val, left, right) {\\n *     this.val = (val===undefined ? 0 : val)\\n *     this.left = (left===undefined ? null : left)\\n *     this.right = (right===undefined ? null : right)\\n * }\\n */\\n/**\\n * @param {TreeNode} root\\n * @param {number} k\\n * @return {number}\\n */\\nvar kthLargestLevelSum = function(root, k) {\\n    let levelSumArr = [], queue = [root];\\n    while(queue.length > 0) {\\n        let sum = 0, size = queue.length;\\n        while(size > 0) {\\n            let q = queue.shift()\\n            sum += q.val;\\n            if(q.left) queue.push(q.left);\\n            if(q.right) queue.push(q.right);\\n            size--;\\n        }\\n        levelSumArr.push(sum);\\n    }\\n    levelSumArr = levelSumArr.sort((a,b) => a-b)\\n    return levelSumArr[levelSumArr.length - k] || -1;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3871963,
                "title": "beats-91-in-terms-of-runtime-c-beginner-friendly",
                "content": "\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Storing each level sum in unordered map.\\n2. Adding the values to priority queue.\\n# Complexity\\n- Time complexity:\\n- **O(n)**\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n- **O(n^2)** space for Priority Queue and Level map.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void helper(TreeNode *root,unordered_map<int,long long> &mp,int level)\\n    {\\n        if(root==NULL)\\n        return;\\n        mp[level]+=root->val;\\n        helper(root->left,mp,level+1);\\n        helper(root->right,mp,level+1);\\n    }\\n    long long kthLargestLevelSum(TreeNode* root, int k) {\\n        unordered_map<int,long long> mp;\\n        helper(root,mp,0);\\n        if(k>mp.size())\\n        return -1;\\n        priority_queue<long long int> pq;\\n        for(auto a : mp)\\n        pq.push(a.second);\\n        long long int temp;\\n        while(k--)\\n        {\\n            temp= pq.top();\\n            pq.pop();\\n        }\\n        return temp;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void helper(TreeNode *root,unordered_map<int,long long> &mp,int level)\\n    {\\n        if(root==NULL)\\n        return;\\n        mp[level]+=root->val;\\n        helper(root->left,mp,level+1);\\n        helper(root->right,mp,level+1);\\n    }\\n    long long kthLargestLevelSum(TreeNode* root, int k) {\\n        unordered_map<int,long long> mp;\\n        helper(root,mp,0);\\n        if(k>mp.size())\\n        return -1;\\n        priority_queue<long long int> pq;\\n        for(auto a : mp)\\n        pq.push(a.second);\\n        long long int temp;\\n        while(k--)\\n        {\\n            temp= pq.top();\\n            pq.pop();\\n        }\\n        return temp;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3855077,
                "title": "easy-solution",
                "content": "# Intuition\\nUse level order traversal\\n# Approach\\nlevel order traversal\\n\\n# Complexity\\n- Time complexity:****O(N)****\\n\\n\\n- Space complexity:**O(N)**\\n\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    long long solve(TreeNode* root, int k){\\n        vector<long long> ans;\\n        if(!root) return 0;\\n        queue<TreeNode*> q;\\n        q.push(root);\\n        while(!q.empty()){\\n            long long sum=0;\\n            long long n=q.size();\\n            for(long long i=0;i<n;i++){\\n                TreeNode* node=q.front();\\n                q.pop();\\n                sum+=node->val;\\n                if(node->left) q.push(node->left);\\n                if(node->right) q.push(node->right);\\n            }\\n            ans.push_back(sum);\\n        }\\n        sort(ans.begin(), ans.end());\\n        if(ans.size()>=k){\\n            long long p=ans[ans.size()-k];\\n            return p;\\n        }\\n        return -1;\\n    }\\n    long long kthLargestLevelSum(TreeNode* root, int k) {\\n        long long ans=solve(root, k);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Breadth-First Search"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    long long solve(TreeNode* root, int k){\\n        vector<long long> ans;\\n        if(!root) return 0;\\n        queue<TreeNode*> q;\\n        q.push(root);\\n        while(!q.empty()){\\n            long long sum=0;\\n            long long n=q.size();\\n            for(long long i=0;i<n;i++){\\n                TreeNode* node=q.front();\\n                q.pop();\\n                sum+=node->val;\\n                if(node->left) q.push(node->left);\\n                if(node->right) q.push(node->right);\\n            }\\n            ans.push_back(sum);\\n        }\\n        sort(ans.begin(), ans.end());\\n        if(ans.size()>=k){\\n            long long p=ans[ans.size()-k];\\n            return p;\\n        }\\n        return -1;\\n    }\\n    long long kthLargestLevelSum(TreeNode* root, int k) {\\n        long long ans=solve(root, k);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3853741,
                "title": "bfs-priority-queue-very-hard-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\n #define ll long long\\nclass Solution {\\npublic:\\n    long long kthLargestLevelSum(TreeNode* root, int k) {\\n        priority_queue<ll,vector<ll>,greater<ll>>pq;\\n        queue<TreeNode*>q;\\n        q.push(root);\\n        while(q.empty()==false){\\n            int size = q.size();\\n            long long sum = 0 ;\\n            while(size>0){\\n                auto node = q.front();\\n                q.pop();\\n                sum+=node->val;\\n                if(node->left)q.push(node->left);\\n                if(node->right)q.push(node->right);\\n                size--;\\n            }\\n\\n            pq.push(sum);\\n            if(pq.size()>k)pq.pop();\\n            \\n        }\\n\\n       if(pq.size()<k)return -1;\\n       return pq.top();\\n\\n    }\\n\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\n #define ll long long\\nclass Solution {\\npublic:\\n    long long kthLargestLevelSum(TreeNode* root, int k) {\\n        priority_queue<ll,vector<ll>,greater<ll>>pq;\\n        queue<TreeNode*>q;\\n        q.push(root);\\n        while(q.empty()==false){\\n            int size = q.size();\\n            long long sum = 0 ;\\n            while(size>0){\\n                auto node = q.front();\\n                q.pop();\\n                sum+=node->val;\\n                if(node->left)q.push(node->left);\\n                if(node->right)q.push(node->right);\\n                size--;\\n            }\\n\\n            pq.push(sum);\\n            if(pq.size()>k)pq.pop();\\n            \\n        }\\n\\n       if(pq.size()<k)return -1;\\n       return pq.top();\\n\\n    }\\n\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3850755,
                "title": "min-heap-python3-o-n-log-k",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe intuition behind the optimized solution is to efficiently find the kth largest level sum without sorting the entire list of level sums.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nHere\\'s the intuition step by step:\\n\\nWe perform a level-order traversal of the binary tree using a queue. During the traversal, we calculate the sum of node values at each level.\\n\\nInstead of storing all the level sums in a list and sorting it afterward, we maintain a min-heap (priority queue) called k_largest_sums to keep track of the k largest level sums encountered so far.\\n\\nAs we traverse each level, we add the level sum to the k_largest_sums heap. If the size of the heap exceeds k, we remove the smallest element from the heap, ensuring that the heap always contains the k largest level sums seen so far.\\n\\nOnce the traversal is complete, the top element of the k_largest_sums heap will be the kth largest level sum.\\n# Complexity\\nThe advantage of using a min-heap is that it efficiently keeps track of the k largest elements encountered during the traversal. It avoids sorting the entire list of level sums, which would be less efficient, especially when k is small compared to the total number of nodes in the binary tree.\\n\\nBy employing this approach, the optimized solution reduces the time complexity to O(nlog(k)), where n is the number of nodes in the binary tree. This is a significant improvement compared to the O(nlog(n)) time complexity required for sorting the entire list.\\n# Code\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def kthLargestLevelSum(self, root: Optional[TreeNode], k: int) -> int:\\n        if not root:\\n            return -1\\n\\n        # Initialize a min-heap (priority queue) to store the k largest level sums.\\n        k_largest_sums = []\\n\\n        queue = deque([(root, 0)])\\n\\n        while queue:\\n            level_sum = 0\\n            for _ in range(len(queue)):\\n                node, _ = queue.popleft()\\n                level_sum += node.val\\n                if node.left:\\n                    queue.append((node.left, 0))\\n                if node.right:\\n                    queue.append((node.right, 0))\\n\\n            # Add the current level sum to the min-heap.\\n            heapq.heappush(k_largest_sums, level_sum)\\n\\n            # If the size of the min-heap exceeds k, remove the smallest element.\\n            if len(k_largest_sums) > k:\\n                heapq.heappop(k_largest_sums)\\n\\n        # The kth largest level sum will be at the top of the min-heap.\\n        return k_largest_sums[0] if len(k_largest_sums) == k else -1\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def kthLargestLevelSum(self, root: Optional[TreeNode], k: int) -> int:\\n        if not root:\\n            return -1\\n\\n        # Initialize a min-heap (priority queue) to store the k largest level sums.\\n        k_largest_sums = []\\n\\n        queue = deque([(root, 0)])\\n\\n        while queue:\\n            level_sum = 0\\n            for _ in range(len(queue)):\\n                node, _ = queue.popleft()\\n                level_sum += node.val\\n                if node.left:\\n                    queue.append((node.left, 0))\\n                if node.right:\\n                    queue.append((node.right, 0))\\n\\n            # Add the current level sum to the min-heap.\\n            heapq.heappush(k_largest_sums, level_sum)\\n\\n            # If the size of the min-heap exceeds k, remove the smallest element.\\n            if len(k_largest_sums) > k:\\n                heapq.heappop(k_largest_sums)\\n\\n        # The kth largest level sum will be at the top of the min-heap.\\n        return k_largest_sums[0] if len(k_largest_sums) == k else -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3844708,
                "title": "simple-bfs-solution-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    long long kthLargestLevelSum(TreeNode* root, int k) {\\n        queue<TreeNode*>q;\\n        if(root==NULL)\\n        return 0;\\n        long long int sum=0;\\n        priority_queue<long long int>pq;\\n        q.push(root);\\n        q.push(NULL);\\n\\n        while(q.size()>0){\\n            TreeNode* curr=q.front();\\n            q.pop();\\n            if(curr!=NULL){\\n              sum+=curr->val;\\n            }\\n\\n            if(curr==NULL){\\n                if(q.size()>0){\\n                    q.push(NULL);\\n                    pq.push(sum);\\n                    sum=0;\\n                }\\n            }else{\\n                if(curr->left)\\n                q.push(curr->left);\\n\\n                if(curr->right)\\n                q.push(curr->right);\\n            }\\n             \\n        }\\n        if(sum>0)\\n        pq.push(sum);\\n        if(pq.size()<k)\\n        return -1;\\n        while(k>1)\\n        {\\n            cout<<pq.top()<<endl;\\n         pq.pop();\\n         k--;\\n        }\\n        return pq.top();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    long long kthLargestLevelSum(TreeNode* root, int k) {\\n        queue<TreeNode*>q;\\n        if(root==NULL)\\n        return 0;\\n        long long int sum=0;\\n        priority_queue<long long int>pq;\\n        q.push(root);\\n        q.push(NULL);\\n\\n        while(q.size()>0){\\n            TreeNode* curr=q.front();\\n            q.pop();\\n            if(curr!=NULL){\\n              sum+=curr->val;\\n            }\\n\\n            if(curr==NULL){\\n                if(q.size()>0){\\n                    q.push(NULL);\\n                    pq.push(sum);\\n                    sum=0;\\n                }\\n            }else{\\n                if(curr->left)\\n                q.push(curr->left);\\n\\n                if(curr->right)\\n                q.push(curr->right);\\n            }\\n             \\n        }\\n        if(sum>0)\\n        pq.push(sum);\\n        if(pq.size()<k)\\n        return -1;\\n        while(k>1)\\n        {\\n            cout<<pq.top()<<endl;\\n         pq.pop();\\n         k--;\\n        }\\n        return pq.top();\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3844647,
                "title": "kthlargestlevelsum",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$ : 282 m\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * function TreeNode(val, left, right) {\\n *     this.val = (val===undefined ? 0 : val)\\n *     this.left = (left===undefined ? null : left)\\n *     this.right = (right===undefined ? null : right)\\n * }\\n */\\n/**\\n * @param {TreeNode} root\\n * @param {number} k\\n * @return {number}\\n */\\nvar kthLargestLevelSum = function(root, k) {\\n    const data = []\\n    const dfs = (node,level)=>{\\n        if(node == null)return;\\n        data[level]?data[level] += node.val:data[level] =  node.val\\n        dfs(node.left,level+1)\\n        dfs(node.right,level+1)\\n    }\\n    dfs(root,0);\\n    if(k>data.length)return -1;\\n    data.sort((a,b) => b-a)\\n    return data[k-1]\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Breadth-First Search"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * function TreeNode(val, left, right) {\\n *     this.val = (val===undefined ? 0 : val)\\n *     this.left = (left===undefined ? null : left)\\n *     this.right = (right===undefined ? null : right)\\n * }\\n */\\n/**\\n * @param {TreeNode} root\\n * @param {number} k\\n * @return {number}\\n */\\nvar kthLargestLevelSum = function(root, k) {\\n    const data = []\\n    const dfs = (node,level)=>{\\n        if(node == null)return;\\n        data[level]?data[level] += node.val:data[level] =  node.val\\n        dfs(node.left,level+1)\\n        dfs(node.right,level+1)\\n    }\\n    dfs(root,0);\\n    if(k>data.length)return -1;\\n    data.sort((a,b) => b-a)\\n    return data[k-1]\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3834545,
                "title": "c-priority-queue-hash",
                "content": "class Solution {\\npublic:\\n    void stepsum(TreeNode *root,unordered_map<int, long long> &map,int step){\\n        map[step]+=root->val;\\n        if(root->left) stepsum(root->left,map,step+1);\\n        if(root->right) stepsum(root->right,map,step+1);\\n    }\\n    long long kthLargestLevelSum(TreeNode* root, int k) {\\n        unordered_map<int,long long> map;\\n        priority_queue<long long> pq;\\n        stepsum(root,map,0);\\n\\n        for(auto element:map){\\n            pq.push(element.second);\\n        }\\n        long long result;\\n        if(pq.size()<k) return -1;\\n        while(k){\\n            result=pq.top();\\n            pq.pop();\\n            k--;\\n        }\\n        return result;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Heap (Priority Queue)"
                ],
                "code": "class Solution {\\npublic:\\n    void stepsum(TreeNode *root,unordered_map<int, long long> &map,int step){\\n        map[step]+=root->val;\\n        if(root->left) stepsum(root->left,map,step+1);\\n        if(root->right) stepsum(root->right,map,step+1);\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 3834187,
                "title": "level-order-traversal",
                "content": "```\\nclass Solution {\\n    public long kthLargestLevelSum(TreeNode root, int k) {\\n        Queue<TreeNode>q = new LinkedList<>();\\n        ArrayList<Long>ans = new ArrayList<>();\\n        q.add(root);\\n        while(!q.isEmpty()){\\n            int n = q.size();\\n            long sum = 0;\\n            TreeNode x;\\n            for(int i=0; i<n; i++){\\n                x = q.remove();\\n                sum += x.val;\\n                if(x.left!=null) q.add(x.left);\\n                if(x.right!=null) q.add(x.right);\\n            }\\n            ans.add(sum);\\n        }\\n        Collections.sort(ans);\\n        return ans.size() < k ? -1 : ans.get(ans.size()-k);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Tree",
                    "Breadth-First Search",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    public long kthLargestLevelSum(TreeNode root, int k) {\\n        Queue<TreeNode>q = new LinkedList<>();\\n        ArrayList<Long>ans = new ArrayList<>();\\n        q.add(root);\\n        while(!q.isEmpty()){\\n            int n = q.size();\\n            long sum = 0;\\n            TreeNode x;\\n            for(int i=0; i<n; i++){\\n                x = q.remove();\\n                sum += x.val;\\n                if(x.left!=null) q.add(x.left);\\n                if(x.right!=null) q.add(x.right);\\n            }\\n            ans.add(sum);\\n        }\\n        Collections.sort(ans);\\n        return ans.size() < k ? -1 : ans.get(ans.size()-k);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3822926,
                "title": "easy-java-solution-level-order-traversal",
                "content": "\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public long kthLargestLevelSum(TreeNode root, int k) {\\n        Queue<TreeNode> q = new LinkedList<>();\\n        List< Long > list = new ArrayList<>();\\n        q.add(root);\\n\\n        while( ! q.isEmpty() ){\\n            long count = q.size();\\n            long sum = 0;\\n\\n            for( int i = 0 ; i < count ; i++ ){\\n                TreeNode curr = q.poll();\\n                assert curr != null;\\n                sum = sum + curr.val;\\n\\n                if( curr.left != null ){\\n                    q.add( curr.left );\\n                }\\n                if( curr.right != null ){\\n                    q.add( curr.right );\\n                }\\n            }\\n            list.add(sum);\\n        }\\n\\n        list.sort(Collections.reverseOrder());\\n        if( k > list.size()){\\n            return -1;\\n        }\\n        return list.get(k-1);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Tree",
                    "Breadth-First Search",
                    "Queue"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public long kthLargestLevelSum(TreeNode root, int k) {\\n        Queue<TreeNode> q = new LinkedList<>();\\n        List< Long > list = new ArrayList<>();\\n        q.add(root);\\n\\n        while( ! q.isEmpty() ){\\n            long count = q.size();\\n            long sum = 0;\\n\\n            for( int i = 0 ; i < count ; i++ ){\\n                TreeNode curr = q.poll();\\n                assert curr != null;\\n                sum = sum + curr.val;\\n\\n                if( curr.left != null ){\\n                    q.add( curr.left );\\n                }\\n                if( curr.right != null ){\\n                    q.add( curr.right );\\n                }\\n            }\\n            list.add(sum);\\n        }\\n\\n        list.sort(Collections.reverseOrder());\\n        if( k > list.size()){\\n            return -1;\\n        }\\n        return list.get(k-1);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3818100,
                "title": "beginner-friendly-easy-c-using-level-order-traversal-beats-98-75-memory",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(Nlogk)\\n\\n- Space complexity:\\nO(N+K)\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    long long kthLargestLevelSum(TreeNode* root, int k) {\\n        priority_queue< long long int, vector<long long int >, greater<long long int > >pq;\\n        long long int ans=0;\\n        // performing level order traversal\\n        queue<TreeNode * > q;\\n        q.push(root);\\n        while(!q.empty()){\\n            int n=q.size();\\n            long long int  ans=0;\\n            while(n>0){\\n                TreeNode * front = q.front();\\n                q.pop();\\n                ans+= front->val;\\n                if(front->left) q.push(front->left);\\n                if(front->right) q.push(front->right);\\n                n--;\\n            }\\n            if(pq.size()<k){\\n                pq.push(ans);\\n            }\\n            else{\\n                if(pq.top()<ans){\\n                    pq.pop();\\n                    pq.push(ans);\\n                }\\n            }\\n        }\\n        if(k>pq.size()){\\n            return -1;\\n        }\\n        return pq.top();\\n\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    long long kthLargestLevelSum(TreeNode* root, int k) {\\n        priority_queue< long long int, vector<long long int >, greater<long long int > >pq;\\n        long long int ans=0;\\n        // performing level order traversal\\n        queue<TreeNode * > q;\\n        q.push(root);\\n        while(!q.empty()){\\n            int n=q.size();\\n            long long int  ans=0;\\n            while(n>0){\\n                TreeNode * front = q.front();\\n                q.pop();\\n                ans+= front->val;\\n                if(front->left) q.push(front->left);\\n                if(front->right) q.push(front->right);\\n                n--;\\n            }\\n            if(pq.size()<k){\\n                pq.push(ans);\\n            }\\n            else{\\n                if(pq.top()<ans){\\n                    pq.pop();\\n                    pq.push(ans);\\n                }\\n            }\\n        }\\n        if(k>pq.size()){\\n            return -1;\\n        }\\n        return pq.top();\\n\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3817270,
                "title": "level-order-traversal-sorting-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    long long kthLargestLevelSum(TreeNode* root, int k) {\\n       queue<TreeNode*>q;\\n       q.push(root);\\n       long long sum;\\n       vector<long long> level_sum;\\n       while(!q.empty()){\\n           int sz=q.size();\\n           sum=0;\\n           for(int i=0;i<sz;i++){\\n               TreeNode* node=q.front();\\n               q.pop();\\n               sum+=node->val;\\n               if(node->left) q.push(node->left);\\n               if(node->right) q.push(node->right);\\n           }\\n           level_sum.push_back(sum);\\n       }\\n       int n=level_sum.size();\\n       if(n<k) return -1;\\n       sort(level_sum.begin(),level_sum.end());\\n       return level_sum[n-k]; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    long long kthLargestLevelSum(TreeNode* root, int k) {\\n       queue<TreeNode*>q;\\n       q.push(root);\\n       long long sum;\\n       vector<long long> level_sum;\\n       while(!q.empty()){\\n           int sz=q.size();\\n           sum=0;\\n           for(int i=0;i<sz;i++){\\n               TreeNode* node=q.front();\\n               q.pop();\\n               sum+=node->val;\\n               if(node->left) q.push(node->left);\\n               if(node->right) q.push(node->right);\\n           }\\n           level_sum.push_back(sum);\\n       }\\n       int n=level_sum.size();\\n       if(n<k) return -1;\\n       sort(level_sum.begin(),level_sum.end());\\n       return level_sum[n-k]; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3811485,
                "title": "python-easy-to-understand-solution-with-recursive-traversal",
                "content": "```\\n    def kthLargestLevelSum(self, root: Optional[TreeNode], k: int) -> int:\\n        level_sums = collections.defaultdict(int)\\n        k = k - 1\\n        max_level = 0\\n        \\n        def traverse(node, level):\\n            nonlocal max_level\\n            if not node:\\n                return\\n            max_level = max(max_level, level)\\n            level_sums[level] += node.val\\n            traverse(node.left, level + 1)\\n            traverse(node.right, level + 1)\\n        \\n        traverse(root, 0)\\n        return -1 if max_level < k else sorted(level_sums.items(), key=lambda item: item[1], reverse=True)[k][1]\\n\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\n    def kthLargestLevelSum(self, root: Optional[TreeNode], k: int) -> int:\\n        level_sums = collections.defaultdict(int)\\n        k = k - 1\\n        max_level = 0\\n        \\n        def traverse(node, level):\\n            nonlocal max_level\\n            if not node:\\n                return\\n            max_level = max(max_level, level)\\n            level_sums[level] += node.val\\n            traverse(node.left, level + 1)\\n            traverse(node.right, level + 1)\\n        \\n        traverse(root, 0)\\n        return -1 if max_level < k else sorted(level_sums.items(), key=lambda item: item[1], reverse=True)[k][1]\\n\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3805615,
                "title": "easy-c-solution-using-level-order-traversal",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    void solve(TreeNode*root,vector<long long>&ans){\\n        queue<TreeNode*>q;\\n        q.push(root);\\n        q.push(NULL); // Seperator between two levels;\\n        long long sum = 0;\\n        while(!q.empty()){\\n            TreeNode*front = q.front() ;\\n            q.pop();\\n\\n            if(front ==NULL){\\n                ans .push_back(sum);\\n                sum = 0;\\n                if(!q.empty()){\\n                    q.push(NULL);//For next levels.\\n                }\\n            }\\n            else{\\n                sum += front->val;\\n                if(front->left){\\n                    q.push(front->left);\\n                }\\n                if(front ->right){\\n                    q.push(front->right);\\n                }\\n            }\\n        }\\n    }\\n    long long kthLargestLevelSum(TreeNode* root, int k) {\\n        vector<long long>ans;\\n        solve(root,ans);\\n        if(ans.size() < k){\\n            return -1;\\n        }\\n        sort(ans.begin(),ans.end());\\n        return ans[ans.size()-k];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    void solve(TreeNode*root,vector<long long>&ans){\\n        queue<TreeNode*>q;\\n        q.push(root);\\n        q.push(NULL); // Seperator between two levels;\\n        long long sum = 0;\\n        while(!q.empty()){\\n            TreeNode*front = q.front() ;\\n            q.pop();\\n\\n            if(front ==NULL){\\n                ans .push_back(sum);\\n                sum = 0;\\n                if(!q.empty()){\\n                    q.push(NULL);//For next levels.\\n                }\\n            }\\n            else{\\n                sum += front->val;\\n                if(front->left){\\n                    q.push(front->left);\\n                }\\n                if(front ->right){\\n                    q.push(front->right);\\n                }\\n            }\\n        }\\n    }\\n    long long kthLargestLevelSum(TreeNode* root, int k) {\\n        vector<long long>ans;\\n        solve(root,ans);\\n        if(ans.size() < k){\\n            return -1;\\n        }\\n        sort(ans.begin(),ans.end());\\n        return ans[ans.size()-k];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3800163,
                "title": "readable-no-queues-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def kthLargestLevelSum(self, root: TreeNode | None, k: int) -> int:\\n        levelNodes: list[TreeNode] = [root]\\n        levelSums: list[int] = []\\n\\n        while levelNodes:\\n            levelSum = sum([node.val for node in levelNodes])\\n            levelSums.append(levelSum)\\n            levelNodes = self.getChildNodes(levelNodes)\\n\\n        if len(levelSums) < k:\\n            return -1\\n\\n        levelSums.sort(reverse=True)\\n\\n        return levelSums[k - 1]\\n\\n    def getChildNodes(self, parents: list[TreeNode]) -> list[TreeNode]:\\n        children: list[TreeNode] = []\\n\\n        for parent in parents:\\n            if parent.left is not None:\\n                children.append(parent.left)\\n            \\n            if parent.right is not None:\\n                children.append(parent.right)\\n\\n        return children\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def kthLargestLevelSum(self, root: TreeNode | None, k: int) -> int:\\n        levelNodes: list[TreeNode] = [root]\\n        levelSums: list[int] = []\\n\\n        while levelNodes:\\n            levelSum = sum([node.val for node in levelNodes])\\n            levelSums.append(levelSum)\\n            levelNodes = self.getChildNodes(levelNodes)\\n\\n        if len(levelSums) < k:\\n            return -1\\n\\n        levelSums.sort(reverse=True)\\n\\n        return levelSums[k - 1]\\n\\n    def getChildNodes(self, parents: list[TreeNode]) -> list[TreeNode]:\\n        children: list[TreeNode] = []\\n\\n        for parent in parents:\\n            if parent.left is not None:\\n                children.append(parent.left)\\n            \\n            if parent.right is not None:\\n                children.append(parent.right)\\n\\n        return children\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3795308,
                "title": "python-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nfrom collections import deque\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def kthLargestLevelSum(self, root: Optional[TreeNode], k: int) -> int:\\n        q = deque()\\n        q.append(root)\\n        res = []\\n\\n        while q:\\n            size = len(q)\\n            currLevel = []\\n\\n            for _ in range(size):\\n                curr = q.popleft()\\n                currLevel.append(curr.val)\\n\\n                if curr.left:\\n                    q.append(curr.left)\\n                if curr.right:\\n                    q.append(curr.right)\\n            res.append(sum(currLevel))\\n        \\n        res.sort()\\n        return res[-k] if len(res) >= k else -1\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nfrom collections import deque\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def kthLargestLevelSum(self, root: Optional[TreeNode], k: int) -> int:\\n        q = deque()\\n        q.append(root)\\n        res = []\\n\\n        while q:\\n            size = len(q)\\n            currLevel = []\\n\\n            for _ in range(size):\\n                curr = q.popleft()\\n                currLevel.append(curr.val)\\n\\n                if curr.left:\\n                    q.append(curr.left)\\n                if curr.right:\\n                    q.append(curr.right)\\n            res.append(sum(currLevel))\\n        \\n        res.sort()\\n        return res[-k] if len(res) >= k else -1\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3791697,
                "title": "kth-largest-sum-in-a-binary-tree-easiest-with-c",
                "content": "\\n# Complexity\\n- Time complexity:$$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(h)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    long long kthLargestLevelSum(TreeNode* root, int k) {\\n        priority_queue<long long int>pq;\\n        queue<TreeNode*>q;\\n        q.push(root);\\n\\n        while(!q.empty())\\n        {\\n            long long int sum=0;\\n            int size = q.size();\\n            // LEVEL ACCESS\\n            for(int i=0; i<size; i++)\\n            {\\n                TreeNode* frontNode = q.front();\\n                q.pop();\\n\\n                sum += frontNode->val;\\n                if(frontNode->left)\\n                    q.push(frontNode->left);\\n                if(frontNode->right)\\n                    q.push(frontNode->right);\\n            }\\n            pq.push(sum);\\n        }\\n        if(pq.size() < k)\\n            return -1;\\n        k--;\\n        while(k--)\\n            pq.pop();\\n        return pq.top();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    long long kthLargestLevelSum(TreeNode* root, int k) {\\n        priority_queue<long long int>pq;\\n        queue<TreeNode*>q;\\n        q.push(root);\\n\\n        while(!q.empty())\\n        {\\n            long long int sum=0;\\n            int size = q.size();\\n            // LEVEL ACCESS\\n            for(int i=0; i<size; i++)\\n            {\\n                TreeNode* frontNode = q.front();\\n                q.pop();\\n\\n                sum += frontNode->val;\\n                if(frontNode->left)\\n                    q.push(frontNode->left);\\n                if(frontNode->right)\\n                    q.push(frontNode->right);\\n            }\\n            pq.push(sum);\\n        }\\n        if(pq.size() < k)\\n            return -1;\\n        k--;\\n        while(k--)\\n            pq.pop();\\n        return pq.top();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3767674,
                "title": "easy-java-solution-using-bfs",
                "content": "\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public long kthLargestLevelSum(TreeNode root, int k) {\\n        Queue<TreeNode> q= new LinkedList<>();\\n        long ans=0;\\n        q.add(root);\\n        q.add(null);\\n        ArrayList<Long> sum= new ArrayList<>();\\n        ArrayList<Integer> a= new ArrayList<>();\\n        while(!q.isEmpty()){\\n            TreeNode cur= q.remove();\\n            if(cur==null) {\\n                if(q.isEmpty()){\\n                    long s=0;\\n                    for(int x:a){\\n                        s+=x;\\n                    }\\n                    sum.add(s);\\n                    break;\\n                }\\n                else{ \\n                    q.add(null);\\n                    long s=0;\\n                    for(long x:a){\\n                        s+=x;\\n                    }\\n                    sum.add(s);\\n                    a=new ArrayList<>();\\n                }\\n            }\\n            else{\\n                a.add(cur.val);\\n                if(cur.left!=null)q.add(cur.left);\\n                if(cur.right!=null){\\n                    q.add(cur.right);\\n                }\\n            }\\n        }\\n        Collections.sort(sum);\\n        if(sum.size()-k<0) return -1;\\n        return sum.get(sum.size()-k);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public long kthLargestLevelSum(TreeNode root, int k) {\\n        Queue<TreeNode> q= new LinkedList<>();\\n        long ans=0;\\n        q.add(root);\\n        q.add(null);\\n        ArrayList<Long> sum= new ArrayList<>();\\n        ArrayList<Integer> a= new ArrayList<>();\\n        while(!q.isEmpty()){\\n            TreeNode cur= q.remove();\\n            if(cur==null) {\\n                if(q.isEmpty()){\\n                    long s=0;\\n                    for(int x:a){\\n                        s+=x;\\n                    }\\n                    sum.add(s);\\n                    break;\\n                }\\n                else{ \\n                    q.add(null);\\n                    long s=0;\\n                    for(long x:a){\\n                        s+=x;\\n                    }\\n                    sum.add(s);\\n                    a=new ArrayList<>();\\n                }\\n            }\\n            else{\\n                a.add(cur.val);\\n                if(cur.left!=null)q.add(cur.left);\\n                if(cur.right!=null){\\n                    q.add(cur.right);\\n                }\\n            }\\n        }\\n        Collections.sort(sum);\\n        if(sum.size()-k<0) return -1;\\n        return sum.get(sum.size()-k);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3758964,
                "title": "easy-to-get-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public long kthLargestLevelSum(TreeNode root, int k) {\\n        Queue<Long> heap = new PriorityQueue<>();\\n        Queue<TreeNode> q=new LinkedList<TreeNode>();\\n        q.add(root);\\n        \\n        while(!q.isEmpty()){\\n            long sum=0;\\n            int size=q.size();\\n            \\n            for(int i=0;i<size;i++){\\n                TreeNode curr=q.remove();\\n                sum+=curr.val;\\n                if(curr.left!=null)q.add(curr.left);\\n                if(curr.right!=null)q.add(curr.right);\\n            }\\n            if (heap.size() < k) {\\n                heap.offer(sum);\\n            } else if (heap.peek() < sum) {\\n                heap.poll();\\n                heap.offer(sum);\\n            }\\n        }\\n        return heap.size() < k ? -1 : heap.peek();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public long kthLargestLevelSum(TreeNode root, int k) {\\n        Queue<Long> heap = new PriorityQueue<>();\\n        Queue<TreeNode> q=new LinkedList<TreeNode>();\\n        q.add(root);\\n        \\n        while(!q.isEmpty()){\\n            long sum=0;\\n            int size=q.size();\\n            \\n            for(int i=0;i<size;i++){\\n                TreeNode curr=q.remove();\\n                sum+=curr.val;\\n                if(curr.left!=null)q.add(curr.left);\\n                if(curr.right!=null)q.add(curr.right);\\n            }\\n            if (heap.size() < k) {\\n                heap.offer(sum);\\n            } else if (heap.peek() < sum) {\\n                heap.poll();\\n                heap.offer(sum);\\n            }\\n        }\\n        return heap.size() < k ? -1 : heap.peek();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3754658,
                "title": "level-order-traversal-priority-queue-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    long long kthLargestLevelSum(TreeNode* root, int k) {\\n        queue <TreeNode *> q;\\n        q.push(root);\\n        priority_queue<long long , vector<long long >, greater<long long > > pq;\\n        while(!q.empty())\\n        {\\n            int s=q.size();\\n            long long  val=0;\\n            while(s--)\\n            {\\n                auto it=q.front();\\n                q.pop();\\n                val+=it->val;\\n                if(it->left)\\n                {\\n                    q.push(it->left);\\n                }\\n                if(it->right)\\n                {\\n                    q.push(it->right);\\n                }\\n            }\\n            if(pq.size()<k)\\n            {\\n                pq.push(val);\\n            }\\n            else if(pq.size()==k)\\n            {\\n                if(val>pq.top())\\n                {\\n                    pq.pop();\\n                    pq.push(val);\\n                }\\n            }\\n        }\\n        if(pq.size()<k){\\n            return -1;\\n        }\\n        return pq.top();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Tree",
                    "Breadth-First Search"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    long long kthLargestLevelSum(TreeNode* root, int k) {\\n        queue <TreeNode *> q;\\n        q.push(root);\\n        priority_queue<long long , vector<long long >, greater<long long > > pq;\\n        while(!q.empty())\\n        {\\n            int s=q.size();\\n            long long  val=0;\\n            while(s--)\\n            {\\n                auto it=q.front();\\n                q.pop();\\n                val+=it->val;\\n                if(it->left)\\n                {\\n                    q.push(it->left);\\n                }\\n                if(it->right)\\n                {\\n                    q.push(it->right);\\n                }\\n            }\\n            if(pq.size()<k)\\n            {\\n                pq.push(val);\\n            }\\n            else if(pq.size()==k)\\n            {\\n                if(val>pq.top())\\n                {\\n                    pq.pop();\\n                    pq.push(val);\\n                }\\n            }\\n        }\\n        if(pq.size()<k){\\n            return -1;\\n        }\\n        return pq.top();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3754042,
                "title": "c-dfs",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n  int maxi = 0;\\n  void dfs(TreeNode* root, int l, vector<long long>&ans) {\\n    if (root == NULL)return;\\n    int level = l;\\n    ans[level] += root->val;\\n    if (root->left != NULL) {\\n      dfs(root->left, l + 1, ans);\\n      maxi = max(maxi, l + 1);\\n    }\\n    if (root->right != NULL) {\\n      dfs(root->right, l + 1, ans);\\n      maxi = max(maxi, l + 1);\\n    }\\n  }\\n  long long kthLargestLevelSum(TreeNode* root, int k) {\\n    int l = 0;\\n    int kk = k;\\n    vector<long long>ans(100005, 0);\\n    dfs(root, l, ans);\\n    sort(ans.begin(), ans.end());\\n    long long sum = 0;\\n    for (int i = ans.size() - 1; i >= 0; i--) {\\n      if (k == 0)break;\\n      sum = ans[i];\\n      k--;\\n    }\\n    if (kk - 1 > maxi)sum = -1;\\n    return sum;\\n  }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n  int maxi = 0;\\n  void dfs(TreeNode* root, int l, vector<long long>&ans) {\\n    if (root == NULL)return;\\n    int level = l;\\n    ans[level] += root->val;\\n    if (root->left != NULL) {\\n      dfs(root->left, l + 1, ans);\\n      maxi = max(maxi, l + 1);\\n    }\\n    if (root->right != NULL) {\\n      dfs(root->right, l + 1, ans);\\n      maxi = max(maxi, l + 1);\\n    }\\n  }\\n  long long kthLargestLevelSum(TreeNode* root, int k) {\\n    int l = 0;\\n    int kk = k;\\n    vector<long long>ans(100005, 0);\\n    dfs(root, l, ans);\\n    sort(ans.begin(), ans.end());\\n    long long sum = 0;\\n    for (int i = ans.size() - 1; i >= 0; i--) {\\n      if (k == 0)break;\\n      sum = ans[i];\\n      k--;\\n    }\\n    if (kk - 1 > maxi)sum = -1;\\n    return sum;\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3745680,
                "title": "java-bfs-min-heap-solution",
                "content": "# Approach\\nUsual bfs approach. Try to solve [kth largest element in an array](https://leetcode.com/problems/kth-largest-element-in-an-array/) before attempting this if you haven\\'t.\\n\\n# Complexity\\nn = number of nodes in the tree\\n- Time complexity: O(nlogk)\\n\\n- Space complexity: O(n)\\n\\n# Code\\n```\\nclass Solution {\\n    public long kthLargestLevelSum(TreeNode root, int k) {\\n        Queue<TreeNode> queue = new LinkedList<>();\\n        queue.offer(root);\\n        // we\\'ll maintain a min heap of size k with the level sums\\n        // the kth largest level sum would be at the head of the queue after our bfs \\n        PriorityQueue<Long> minHeap = new PriorityQueue<>(k);\\n        while(!queue.isEmpty()) {\\n            long levelSum = 0;\\n            for(int i=queue.size(); i>=1; i--) {\\n                TreeNode curr = queue.poll();\\n                levelSum += curr.val;\\n                if(curr.left != null) {\\n                    queue.offer(curr.left);\\n                }\\n                if(curr.right != null) {\\n                    queue.offer(curr.right);\\n                }\\n            }\\n            minHeap.offer(levelSum);\\n            if(minHeap.size() > k) {\\n                minHeap.poll();\\n            }\\n        }\\n        return minHeap.size() < k ? -1 : minHeap.peek();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\n    public long kthLargestLevelSum(TreeNode root, int k) {\\n        Queue<TreeNode> queue = new LinkedList<>();\\n        queue.offer(root);\\n        // we\\'ll maintain a min heap of size k with the level sums\\n        // the kth largest level sum would be at the head of the queue after our bfs \\n        PriorityQueue<Long> minHeap = new PriorityQueue<>(k);\\n        while(!queue.isEmpty()) {\\n            long levelSum = 0;\\n            for(int i=queue.size(); i>=1; i--) {\\n                TreeNode curr = queue.poll();\\n                levelSum += curr.val;\\n                if(curr.left != null) {\\n                    queue.offer(curr.left);\\n                }\\n                if(curr.right != null) {\\n                    queue.offer(curr.right);\\n                }\\n            }\\n            minHeap.offer(levelSum);\\n            if(minHeap.size() > k) {\\n                minHeap.poll();\\n            }\\n        }\\n        return minHeap.size() < k ? -1 : minHeap.peek();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3736476,
                "title": "python-3-80-faster-simple-bfs-easy-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving !-->\\n- Start by checking if the root is None. If it is, return 0 since there are no nodes in the tree.\\n- Create a deque called queue to perform level-order traversal. Add the root node to the queue.\\n- Initialize a variable called level to keep track of the current level.\\n- Create an empty list called maxi to store the sums of each level in descending order.\\n- Start a while loop that continues until the queue is empty. This loop will traverse the tree level by level.\\n- Inside the loop, initialize two variables: level_sum to keep track of the sum of nodes at the current level, and level_size to store the number of nodes at the current level.\\n- Use a for loop to iterate level_size times. This loop processes all nodes at the current level.\\n- Remove a node from the left side of the queue using popleft() and add its value to the level_sum.\\n- If the node has a left child, append it to the queue.\\n- If the node has a right child, append it to the queue.\\n- Increment the level by 1 since we have finished processing all nodes at the current level.Add the negative of level_sum to the maxi list using heappush() from the heapq module. This ensures that the sums are stored in descending order.\\n- After the while loop ends, check if the value of level is less than k. If it is, there are fewer than k levels in the tree, so return -1.\\n- Initialize two variables: i to keep track of the current count of extracted sums, and ans to store the kth largest sum.\\n\\nStart another while loop that continues until the maxi list is empty,Inside the loop, check if i is equal to k. If it is, break the loop since we have found the kth largest sum.\\n\\n\\n\\n\\n# Code\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nimport heapq\\nclass Solution:\\n    def kthLargestLevelSum(self, root: Optional[TreeNode], k: int) -> int:\\n        if root is None:\\n            return 0\\n        queue = collections.deque()\\n        queue.append(root)\\n        # ans = []\\n        level=0\\n        maxi=[]\\n        while queue:\\n            level_sum=0\\n            level_size = len(queue)\\n            for _ in range(level_size):\\n                node = queue.popleft()\\n                level_sum+=node.val\\n                if node.left:\\n                    queue.append(node.left)\\n                if node.right:\\n                    queue.append(node.right)\\n            level=level+1\\n            heapq.heappush(maxi,-level_sum)\\n            \\n        # print(maxi)\\n        print(level)\\n        if level<k:\\n            return -1\\n        i=0\\n        ans=-1\\n        while maxi:\\n            if i==k:\\n                break\\n            ans=-heapq.heappop(maxi)\\n            i=i+1\\n        return ans\\n        \\n```",
                "solutionTags": [
                    "Python3",
                    "Tree",
                    "Depth-First Search",
                    "Breadth-First Search"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nimport heapq\\nclass Solution:\\n    def kthLargestLevelSum(self, root: Optional[TreeNode], k: int) -> int:\\n        if root is None:\\n            return 0\\n        queue = collections.deque()\\n        queue.append(root)\\n        # ans = []\\n        level=0\\n        maxi=[]\\n        while queue:\\n            level_sum=0\\n            level_size = len(queue)\\n            for _ in range(level_size):\\n                node = queue.popleft()\\n                level_sum+=node.val\\n                if node.left:\\n                    queue.append(node.left)\\n                if node.right:\\n                    queue.append(node.right)\\n            level=level+1\\n            heapq.heappush(maxi,-level_sum)\\n            \\n        # print(maxi)\\n        print(level)\\n        if level<k:\\n            return -1\\n        i=0\\n        ans=-1\\n        while maxi:\\n            if i==k:\\n                break\\n            ans=-heapq.heappop(maxi)\\n            i=i+1\\n        return ans\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3736311,
                "title": "easiest-c-solution-level-order-traversal",
                "content": "\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    long long kthLargestLevelSum(TreeNode* root, int k) {\\n\\n        if (root==NULL){\\n            return 0;\\n        }\\n\\n        queue<TreeNode*> q;\\n        q.push(root);\\n        q.push(NULL);\\n        long long sum=0;\\n        vector<long long> levelSum;\\n        while (!q.empty()){\\n            TreeNode* temp = q.front();\\n            q.pop();\\n\\n            if (temp != NULL){\\n                sum += temp->val;\\n                if (temp->left) q.push(temp->left);\\n                if (temp->right) q.push(temp->right);     \\n            }\\n\\n            if (temp==NULL && !q.empty()){\\n                q.push(NULL);\\n                levelSum.push_back(sum);\\n                sum=0;\\n            }\\n        }\\n\\n        if (sum!=0) levelSum.push_back(sum);\\n        int n=levelSum.size();\\n\\n        if (k > n){\\n            return -1;\\n        }\\n\\n        sort(levelSum.begin(), levelSum.end());\\n        return levelSum[n-k];\\n    }\\n};\\n\\n\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Queue"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    long long kthLargestLevelSum(TreeNode* root, int k) {\\n\\n        if (root==NULL){\\n            return 0;\\n        }\\n\\n        queue<TreeNode*> q;\\n        q.push(root);\\n        q.push(NULL);\\n        long long sum=0;\\n        vector<long long> levelSum;\\n        while (!q.empty()){\\n            TreeNode* temp = q.front();\\n            q.pop();\\n\\n            if (temp != NULL){\\n                sum += temp->val;\\n                if (temp->left) q.push(temp->left);\\n                if (temp->right) q.push(temp->right);     \\n            }\\n\\n            if (temp==NULL && !q.empty()){\\n                q.push(NULL);\\n                levelSum.push_back(sum);\\n                sum=0;\\n            }\\n        }\\n\\n        if (sum!=0) levelSum.push_back(sum);\\n        int n=levelSum.size();\\n\\n        if (k > n){\\n            return -1;\\n        }\\n\\n        sort(levelSum.begin(), levelSum.end());\\n        return levelSum[n-k];\\n    }\\n};\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3729701,
                "title": "golang-level-order-traversal-min-heap",
                "content": "# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * type TreeNode struct {\\n *     Val int\\n *     Left *TreeNode\\n *     Right *TreeNode\\n * }\\n */\\n\\ntype PriorityQueue []int64\\n\\nfunc (pq PriorityQueue) Len() int           { return len(pq) }\\nfunc (pq PriorityQueue) Less(i, j int) bool {\\n  return pq[i] < pq[j]\\n}\\nfunc (pq PriorityQueue) Swap(i, j int)      { pq[i], pq[j] = pq[j], pq[i] }\\n\\nfunc (pq *PriorityQueue) Push(x interface{}) {\\n  item := x.(int64)\\n  *pq = append(*pq, item)\\n}\\n\\nfunc (pq *PriorityQueue) Pop() interface{} {\\n  old := *pq\\n  n := len(old)\\n  item := old[n-1]\\n  *pq = old[:n-1]\\n  return item\\n}\\n\\nfunc kthLargestLevelSum(root *TreeNode, k int) int64 {\\n  var queue []*TreeNode\\n  queue = append(queue, root)\\n  var pq PriorityQueue\\n  for len(queue) > 0 {\\n    var newQueue []*TreeNode\\n    var sum int64\\n    for _, node := range queue {\\n      sum += int64(node.Val)\\n      if node.Left != nil {\\n        newQueue = append(newQueue, node.Left)\\n      }\\n      if node.Right != nil {\\n        newQueue = append(newQueue, node.Right)\\n      }\\n    }\\n    heap.Push(&pq, sum)\\n    if pq.Len() > k {\\n      heap.Pop(&pq)\\n    }\\n    queue = newQueue\\n  }\\n  if pq.Len() < k {\\n    return -1\\n  }\\n  return heap.Pop(&pq).(int64)\\n}\\n```",
                "solutionTags": [
                    "Go",
                    "Tree",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * type TreeNode struct {\\n *     Val int\\n *     Left *TreeNode\\n *     Right *TreeNode\\n * }\\n */\\n\\ntype PriorityQueue []int64\\n\\nfunc (pq PriorityQueue) Len() int           { return len(pq) }\\nfunc (pq PriorityQueue) Less(i, j int) bool {\\n  return pq[i] < pq[j]\\n}\\nfunc (pq PriorityQueue) Swap(i, j int)      { pq[i], pq[j] = pq[j], pq[i] }\\n\\nfunc (pq *PriorityQueue) Push(x interface{}) {\\n  item := x.(int64)\\n  *pq = append(*pq, item)\\n}\\n\\nfunc (pq *PriorityQueue) Pop() interface{} {\\n  old := *pq\\n  n := len(old)\\n  item := old[n-1]\\n  *pq = old[:n-1]\\n  return item\\n}\\n\\nfunc kthLargestLevelSum(root *TreeNode, k int) int64 {\\n  var queue []*TreeNode\\n  queue = append(queue, root)\\n  var pq PriorityQueue\\n  for len(queue) > 0 {\\n    var newQueue []*TreeNode\\n    var sum int64\\n    for _, node := range queue {\\n      sum += int64(node.Val)\\n      if node.Left != nil {\\n        newQueue = append(newQueue, node.Left)\\n      }\\n      if node.Right != nil {\\n        newQueue = append(newQueue, node.Right)\\n      }\\n    }\\n    heap.Push(&pq, sum)\\n    if pq.Len() > k {\\n      heap.Pop(&pq)\\n    }\\n    queue = newQueue\\n  }\\n  if pq.Len() < k {\\n    return -1\\n  }\\n  return heap.Pop(&pq).(int64)\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3726940,
                "title": "python3-o-nlogk-bfs-minheap",
                "content": "Use a queue for level order traversal. Maintain two variables:\\n1. `level_sum` to count the level\\'s sum\\n2.  `last` tracks if the current node is the level\\'s last node (in which case store `level_sum` and reset it to 0)\\n\\nInstead of sort, which is `nlogn`, we can use a min heap of size `k` (because `k <= n`).\\n\\n# Complexity\\nTime: $$O(nlogk)$$\\nSpace: $$O(n+k)$$\\n\\n# Code\\n```\\nimport heapq\\nfrom collections import deque\\n\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def kthLargestLevelSum(self, root: Optional[TreeNode], k: int) -> int:\\n        heap = []\\n        q = deque()\\n        q.append(root)\\n        last = root\\n        lsum = 0\\n        while q:\\n            node = q.popleft()\\n            lsum += node.val\\n            if node.left:\\n                q.append(node.left)\\n            if node.right:\\n                q.append(node.right)\\n            if node is last:\\n                if len(heap) < k:\\n                    heapq.heappush(heap, lsum)\\n                else:\\n                    heapq.heappushpop(heap, lsum)\\n                if q:\\n                    last = q[-1]\\n                lsum = 0\\n        if len(heap) < k:\\n            return -1\\n        return heapq.heappop(heap)\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nimport heapq\\nfrom collections import deque\\n\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def kthLargestLevelSum(self, root: Optional[TreeNode], k: int) -> int:\\n        heap = []\\n        q = deque()\\n        q.append(root)\\n        last = root\\n        lsum = 0\\n        while q:\\n            node = q.popleft()\\n            lsum += node.val\\n            if node.left:\\n                q.append(node.left)\\n            if node.right:\\n                q.append(node.right)\\n            if node is last:\\n                if len(heap) < k:\\n                    heapq.heappush(heap, lsum)\\n                else:\\n                    heapq.heappushpop(heap, lsum)\\n                if q:\\n                    last = q[-1]\\n                lsum = 0\\n        if len(heap) < k:\\n            return -1\\n        return heapq.heappop(heap)\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3725195,
                "title": "beats-90-runtime-python-detailed-solution-using-min-heap-bfs",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nTree Traversal Problem with use of heap for sorting to get the best time complexity \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nDo level order traversal, maintain the levelSum and levelCount and then use heap for getting the kth largest sum (make a min hesap of size k)\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n) + O (nlogk)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(k) for the heap + O(n) for q\\n\\n# Code\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def kthLargestLevelSum(self, root: Optional[TreeNode], k: int) -> int:\\n        if not root or root is None:\\n            return -1\\n        q=collections.deque()\\n        q.append(root)\\n        heap=[]\\n        levels=0\\n        while q:\\n            levelSum=0\\n            levels+=1\\n            for _ in range(len(q)):\\n                root = q.popleft()\\n                levelSum+=root.val\\n                if root.left:\\n                    q.append(root.left)\\n                if root.right:\\n                    q.append(root.right)\\n            heapq.heappush(heap, levelSum)\\n            if len(heap)>k:\\n                heapq.heappop(heap)\\n        \\n        if levels<k:\\n            return -1\\n\\n\\n        return heapq.heappop(heap)\\n\\n\\n```",
                "solutionTags": [
                    "Python3",
                    "Heap (Priority Queue)",
                    "Binary Tree"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def kthLargestLevelSum(self, root: Optional[TreeNode], k: int) -> int:\\n        if not root or root is None:\\n            return -1\\n        q=collections.deque()\\n        q.append(root)\\n        heap=[]\\n        levels=0\\n        while q:\\n            levelSum=0\\n            levels+=1\\n            for _ in range(len(q)):\\n                root = q.popleft()\\n                levelSum+=root.val\\n                if root.left:\\n                    q.append(root.left)\\n                if root.right:\\n                    q.append(root.right)\\n            heapq.heappush(heap, levelSum)\\n            if len(heap)>k:\\n                heapq.heappop(heap)\\n        \\n        if levels<k:\\n            return -1\\n\\n\\n        return heapq.heappop(heap)\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3722456,
                "title": "easiest-solution-in-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public long kthLargestLevelSum(TreeNode root, int k) {\\n        \\n        ArrayList<Long> arr = new ArrayList<>();\\n        Queue<TreeNode> q = new LinkedList<>();\\n        q.add( root );\\n\\n        while( !q.isEmpty() ) \\n        {\\n            long sum = 0 ;\\n            int n = q.size();\\n            for( int i = 0 ; i<n ; i++ )\\n            {\\n                TreeNode cur = q.poll();\\n\\n                if( cur.left!=null ) q.add( cur.left );\\n                if( cur.right!=null ) q.add( cur.right );\\n                System.out.println( cur.val );\\n                sum += cur.val ;\\n            }\\n            arr.add( sum );\\n        }\\n        System.out.println( arr );\\n        Collections.sort( arr );\\n        long t = arr.size();\\n\\n\\n        if( t>=k  ) return arr.get( arr.size()-k ) ;\\n        else return -1 ;\\n\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public long kthLargestLevelSum(TreeNode root, int k) {\\n        \\n        ArrayList<Long> arr = new ArrayList<>();\\n        Queue<TreeNode> q = new LinkedList<>();\\n        q.add( root );\\n\\n        while( !q.isEmpty() ) \\n        {\\n            long sum = 0 ;\\n            int n = q.size();\\n            for( int i = 0 ; i<n ; i++ )\\n            {\\n                TreeNode cur = q.poll();\\n\\n                if( cur.left!=null ) q.add( cur.left );\\n                if( cur.right!=null ) q.add( cur.right );\\n                System.out.println( cur.val );\\n                sum += cur.val ;\\n            }\\n            arr.add( sum );\\n        }\\n        System.out.println( arr );\\n        Collections.sort( arr );\\n        long t = arr.size();\\n\\n\\n        if( t>=k  ) return arr.get( arr.size()-k ) ;\\n        else return -1 ;\\n\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3719903,
                "title": "using-minheap-and-level-order-traversal",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    long long kthLargestLevelSum(TreeNode* root, int k) {\\n        queue<TreeNode*> qu;\\n        int levels = 0;\\n        priority_queue<long long,vector<long long>,greater<long long>> pq;\\n        qu.push(root);\\n        while(!qu.empty())\\n        {\\n            int size = qu.size();\\n            levels++;\\n            long long sum = 0;\\n            for(int i=0;i<size;i++)\\n            {\\n                TreeNode* node = qu.front();\\n                qu.pop();\\n                sum+=node->val;\\n                if(node->left)\\n                qu.push(node->left);\\n                if(node->right)\\n                qu.push(node->right);\\n            }\\n            if(pq.size()<k)\\n            {\\n                pq.push(sum);\\n            }\\n            else\\n            {\\n               if(sum>pq.top())\\n               {\\n                   pq.pop();\\n                   pq.push(sum);\\n               }\\n            }\\n        }\\n        if(levels<k)\\n        return -1;\\n        else\\n        return pq.top();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    long long kthLargestLevelSum(TreeNode* root, int k) {\\n        queue<TreeNode*> qu;\\n        int levels = 0;\\n        priority_queue<long long,vector<long long>,greater<long long>> pq;\\n        qu.push(root);\\n        while(!qu.empty())\\n        {\\n            int size = qu.size();\\n            levels++;\\n            long long sum = 0;\\n            for(int i=0;i<size;i++)\\n            {\\n                TreeNode* node = qu.front();\\n                qu.pop();\\n                sum+=node->val;\\n                if(node->left)\\n                qu.push(node->left);\\n                if(node->right)\\n                qu.push(node->right);\\n            }\\n            if(pq.size()<k)\\n            {\\n                pq.push(sum);\\n            }\\n            else\\n            {\\n               if(sum>pq.top())\\n               {\\n                   pq.pop();\\n                   pq.push(sum);\\n               }\\n            }\\n        }\\n        if(levels<k)\\n        return -1;\\n        else\\n        return pq.top();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3709456,
                "title": "cpp-easy-implementation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    long long kthLargestLevelSum(TreeNode* root, int k) {\\n        if(root==NULL) return -1;\\n        queue<TreeNode*>q;\\n        q.push(root);\\n       vector<long long>m;\\n        while(!q.empty()){\\n            int n=q.size();\\n            long long ans=0;\\n            for(int i=0;i<n;i++){\\n                TreeNode *cur=q.front();\\n                q.pop();\\n                ans+=cur->val;\\n                if(cur->left)q.push(cur->left);\\n                if(cur->right)q.push(cur->right);\\n            }\\n            m.push_back(ans);\\n        }\\n        if(m.size()<k)return -1;\\n        sort(m.begin(),m.end());\\n        int j=1;\\n        for(int i=m.size()-1;i>=m.size()-k;i--){\\n            if(j==k)return m[i];\\n            j++;\\n        }\\n            \\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Sort",
                    "Breadth-First Search"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    long long kthLargestLevelSum(TreeNode* root, int k) {\\n        if(root==NULL) return -1;\\n        queue<TreeNode*>q;\\n        q.push(root);\\n       vector<long long>m;\\n        while(!q.empty()){\\n            int n=q.size();\\n            long long ans=0;\\n            for(int i=0;i<n;i++){\\n                TreeNode *cur=q.front();\\n                q.pop();\\n                ans+=cur->val;\\n                if(cur->left)q.push(cur->left);\\n                if(cur->right)q.push(cur->right);\\n            }\\n            m.push_back(ans);\\n        }\\n        if(m.size()<k)return -1;\\n        sort(m.begin(),m.end());\\n        int j=1;\\n        for(int i=m.size()-1;i>=m.size()-k;i--){\\n            if(j==k)return m[i];\\n            j++;\\n        }\\n            \\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3707148,
                "title": "beats-99-dfs-solution",
                "content": "# Intuition\\nFirst find out the maximum depth of the tree. Then create a vector to store the sum at each level. Traverse the tree and add the sum at each level\\n\\n```\\nstatic auto speedup = []()\\n{\\n    std::ios_base::sync_with_stdio(false);\\n    std::cout.tie(NULL);\\n    std::cin.tie(NULL);\\n    return NULL;\\n}();\\n\\nclass Solution {\\npublic:\\n    int depthtree;\\n    int maxd=0;\\n    vector<long> level;\\n    void depth(TreeNode* root)\\n    {\\n        depthtree++;\\n        maxd=max(maxd,depthtree);\\n        if(root->left) depth(root->left);\\n        if(root->right) depth(root->right);\\n        depthtree--;\\n        return;\\n    } \\n    void solve(TreeNode* root,int lv)\\n    {\\n        level[lv]+=root->val;\\n        if(root->left) solve(root->left,lv+1);\\n        if(root->right) solve(root->right,lv+1);\\n    }\\n    long long kthLargestLevelSum(TreeNode* root, int k) \\n    {\\n        depth(root);\\n        if(maxd < k) return -1;\\n        level.resize(maxd,0);\\n        solve(root,0);\\n        sort(level.begin(),level.end());\\n        return level[maxd-k];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nstatic auto speedup = []()\\n{\\n    std::ios_base::sync_with_stdio(false);\\n    std::cout.tie(NULL);\\n    std::cin.tie(NULL);\\n    return NULL;\\n}();\\n\\nclass Solution {\\npublic:\\n    int depthtree;\\n    int maxd=0;\\n    vector<long> level;\\n    void depth(TreeNode* root)\\n    {\\n        depthtree++;\\n        maxd=max(maxd,depthtree);\\n        if(root->left) depth(root->left);\\n        if(root->right) depth(root->right);\\n        depthtree--;\\n        return;\\n    } \\n    void solve(TreeNode* root,int lv)\\n    {\\n        level[lv]+=root->val;\\n        if(root->left) solve(root->left,lv+1);\\n        if(root->right) solve(root->right,lv+1);\\n    }\\n    long long kthLargestLevelSum(TreeNode* root, int k) \\n    {\\n        depth(root);\\n        if(maxd < k) return -1;\\n        level.resize(maxd,0);\\n        solve(root,0);\\n        sort(level.begin(),level.end());\\n        return level[maxd-k];\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3696414,
                "title": "c-easy-solution-using-bfs-traversal",
                "content": "# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    long long kthLargestLevelSum(TreeNode* root, int k) {\\n        queue<TreeNode*>q;\\n        q.push(root);\\n        vector<long long>Level_sum;\\n        while(!q.empty()){\\n            int size = q.size();\\n            long long sum = 0;\\n            for(int i = 0 ; i<size ; i++){\\n            TreeNode* node = q.front() ;\\n            q.pop();\\n                sum+=node->val;\\n                if(node->left != NULL) q.push(node->left);\\n                if(node->right != NULL) q.push(node->right);\\n            }\\n            Level_sum.push_back(sum);\\n        }\\n\\n        sort(Level_sum.begin(),Level_sum.end(),greater<long long>());\\n        if(Level_sum.size() < k ) return -1;\\n        return (Level_sum[k-1]);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Tree",
                    "Breadth-First Search"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    long long kthLargestLevelSum(TreeNode* root, int k) {\\n        queue<TreeNode*>q;\\n        q.push(root);\\n        vector<long long>Level_sum;\\n        while(!q.empty()){\\n            int size = q.size();\\n            long long sum = 0;\\n            for(int i = 0 ; i<size ; i++){\\n            TreeNode* node = q.front() ;\\n            q.pop();\\n                sum+=node->val;\\n                if(node->left != NULL) q.push(node->left);\\n                if(node->right != NULL) q.push(node->right);\\n            }\\n            Level_sum.push_back(sum);\\n        }\\n\\n        sort(Level_sum.begin(),Level_sum.end(),greater<long long>());\\n        if(Level_sum.size() < k ) return -1;\\n        return (Level_sum[k-1]);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3695599,
                "title": "c-level-order",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long kthLargestLevelSum(TreeNode* root, int k) {\\n        priority_queue<long long int,vector<long long int>,greater<long long int>> pq;\\n        long long int ans = 0;\\n        queue<TreeNode*> q;\\n        TreeNode* p;\\n        q.push(root);\\n        int n;\\n        while(!q.empty()){\\n            n = q.size();\\n            ans = 0;\\n            while(n--){\\n                p = q.front();\\n                q.pop();\\n                ans += p->val;\\n                if(p->left)q.push(p->left);\\n                if(p->right)q.push(p->right); \\n            }\\n            pq.push(ans);\\n            if(pq.size()>k){\\n                pq.pop();\\n            }\\n        }\\n        if(pq.size()<k)return -1;\\n        return pq.top();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long kthLargestLevelSum(TreeNode* root, int k) {\\n        priority_queue<long long int,vector<long long int>,greater<long long int>> pq;\\n        long long int ans = 0;\\n        queue<TreeNode*> q;\\n        TreeNode* p;\\n        q.push(root);\\n        int n;\\n        while(!q.empty()){\\n            n = q.size();\\n            ans = 0;\\n            while(n--){\\n                p = q.front();\\n                q.pop();\\n                ans += p->val;\\n                if(p->left)q.push(p->left);\\n                if(p->right)q.push(p->right); \\n            }\\n            pq.push(ans);\\n            if(pq.size()>k){\\n                pq.pop();\\n            }\\n        }\\n        if(pq.size()<k)return -1;\\n        return pq.top();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3693567,
                "title": "easy-c-solution-bfs",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    long long kthLargestLevelSum(TreeNode* root, int k) {\\n        queue <TreeNode*> q;\\n        q.push(root);\\n        vector <long long> res;\\n        priority_queue <long long, vector<long long>> pq;\\n\\n        while(q.empty() == false)\\n        {\\n            int size = q.size();\\n            long long sum = 0;\\n            for(int i = 0; i < size; i++)\\n            {\\n                TreeNode *temp = q.front();\\n                sum += q.front()->val;\\n                q.pop();\\n\\n                if(i == size - 1)\\n                pq.push(sum);\\n\\n                if(temp->left)\\n                q.push(temp->left);\\n\\n                if(temp->right)\\n                q.push(temp->right);\\n            }\\n        }\\n\\n        if(pq.size() < k)\\n        return -1;\\n        \\n        for(int i = 0; i < k-1; i++)\\n        pq.pop();\\n\\n        return pq.top();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Breadth-First Search"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    long long kthLargestLevelSum(TreeNode* root, int k) {\\n        queue <TreeNode*> q;\\n        q.push(root);\\n        vector <long long> res;\\n        priority_queue <long long, vector<long long>> pq;\\n\\n        while(q.empty() == false)\\n        {\\n            int size = q.size();\\n            long long sum = 0;\\n            for(int i = 0; i < size; i++)\\n            {\\n                TreeNode *temp = q.front();\\n                sum += q.front()->val;\\n                q.pop();\\n\\n                if(i == size - 1)\\n                pq.push(sum);\\n\\n                if(temp->left)\\n                q.push(temp->left);\\n\\n                if(temp->right)\\n                q.push(temp->right);\\n            }\\n        }\\n\\n        if(pq.size() < k)\\n        return -1;\\n        \\n        for(int i = 0; i < k-1; i++)\\n        pq.pop();\\n\\n        return pq.top();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3693330,
                "title": "kth-largest-level-sum-in-a-binary-tree",
                "content": "# Intuition\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\n\\nclass Solution\\n{\\nprivate:\\n    void getLevelSum(TreeNode *root, vector<long long> &sum, int level)\\n    {\\n        if (root == NULL)\\n            return;\\n\\n        sum[level] += root->val;\\n        getLevelSum(root->left,sum, level + 1);\\n        getLevelSum(root->right,sum, level + 1);\\n    }\\n\\n    int getHeight(TreeNode* root)\\n    {\\n        if (root->left == NULL && root->right == NULL)\\n            return 1;\\n    \\n        int left = 0;\\n        if (root->left != NULL)\\n            left = getHeight(root->left);\\n    \\n        int right = 0;\\n        if (root->right != NULL)\\n            right = getHeight(root->right);\\n    \\n        return (max(left, right) + 1);\\n    }\\n\\npublic:\\n    long long kthLargestLevelSum(TreeNode *root, int k)\\n    {\\n        int height = getHeight(root);\\n        vector<long long> sumArray(height+1);\\n        getLevelSum(root,sumArray,0);\\n        sort(sumArray.begin(), sumArray.end());\\n        reverse(sumArray.begin(), sumArray.end());\\n        cout<<height<<\" \";\\n        if (k > height)\\n            return -1;\\n        return sumArray[k-1];\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\n\\nclass Solution\\n{\\nprivate:\\n    void getLevelSum(TreeNode *root, vector<long long> &sum, int level)\\n    {\\n        if (root == NULL)\\n            return;\\n\\n        sum[level] += root->val;\\n        getLevelSum(root->left,sum, level + 1);\\n        getLevelSum(root->right,sum, level + 1);\\n    }\\n\\n    int getHeight(TreeNode* root)\\n    {\\n        if (root->left == NULL && root->right == NULL)\\n            return 1;\\n    \\n        int left = 0;\\n        if (root->left != NULL)\\n            left = getHeight(root->left);\\n    \\n        int right = 0;\\n        if (root->right != NULL)\\n            right = getHeight(root->right);\\n    \\n        return (max(left, right) + 1);\\n    }\\n\\npublic:\\n    long long kthLargestLevelSum(TreeNode *root, int k)\\n    {\\n        int height = getHeight(root);\\n        vector<long long> sumArray(height+1);\\n        getLevelSum(root,sumArray,0);\\n        sort(sumArray.begin(), sumArray.end());\\n        reverse(sumArray.begin(), sumArray.end());\\n        cout<<height<<\" \";\\n        if (k > height)\\n            return -1;\\n        return sumArray[k-1];\\n    }\\n};\\n\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3687587,
                "title": "java-runtime-faster-than-95-level-order-traversal-priority-queue",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public long kthLargestLevelSum(TreeNode root, int k) {\\n        Queue<Long> heap = new PriorityQueue<>();\\n        Queue<TreeNode> levels = new ArrayDeque<>();\\n        levels.offer(root);\\n\\n        while (!levels.isEmpty()) {\\n            long sum = 0;\\n            int size = levels.size();\\n\\n            for (int i = 0; i < size; i++) {\\n                TreeNode node = levels.poll();\\n                sum += node.val;\\n\\n                if (node.left != null) levels.offer(node.left);\\n                if (node.right != null) levels.offer(node.right);\\n            }\\n\\n            if (heap.size() < k) {\\n                heap.offer(sum);\\n            } else if (heap.peek() < sum) {\\n                heap.poll();\\n                heap.offer(sum);\\n            }\\n        }\\n\\n        return heap.size() < k ? -1 : heap.peek();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public long kthLargestLevelSum(TreeNode root, int k) {\\n        Queue<Long> heap = new PriorityQueue<>();\\n        Queue<TreeNode> levels = new ArrayDeque<>();\\n        levels.offer(root);\\n\\n        while (!levels.isEmpty()) {\\n            long sum = 0;\\n            int size = levels.size();\\n\\n            for (int i = 0; i < size; i++) {\\n                TreeNode node = levels.poll();\\n                sum += node.val;\\n\\n                if (node.left != null) levels.offer(node.left);\\n                if (node.right != null) levels.offer(node.right);\\n            }\\n\\n            if (heap.size() < k) {\\n                heap.offer(sum);\\n            } else if (heap.peek() < sum) {\\n                heap.poll();\\n                heap.offer(sum);\\n            }\\n        }\\n\\n        return heap.size() < k ? -1 : heap.peek();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3687149,
                "title": "c-level-order-and-priority-queue",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    long long kthLargestLevelSum(TreeNode* root, int k) {\\n        queue<TreeNode*>q;\\n        q.push(root);\\n        priority_queue<long,vector<long>,greater<>>pq;\\n        while(!q.empty()){\\n            long n=size(q),sm=0;\\n            while(n--){\\n                TreeNode* c=q.front();\\n                q.pop();\\n                if(c->left)q.push(c->left);\\n                if(c->right)q.push(c->right);\\n                sm+=c->val;\\n            }\\n            pq.push(sm);\\n            if(size(pq)>k)pq.pop();\\n        }\\n        return (size(pq)==k)?pq.top():-1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    long long kthLargestLevelSum(TreeNode* root, int k) {\\n        queue<TreeNode*>q;\\n        q.push(root);\\n        priority_queue<long,vector<long>,greater<>>pq;\\n        while(!q.empty()){\\n            long n=size(q),sm=0;\\n            while(n--){\\n                TreeNode* c=q.front();\\n                q.pop();\\n                if(c->left)q.push(c->left);\\n                if(c->right)q.push(c->right);\\n                sm+=c->val;\\n            }\\n            pq.push(sm);\\n            if(size(pq)>k)pq.pop();\\n        }\\n        return (size(pq)==k)?pq.top():-1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3685375,
                "title": "c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(nlogn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(Height)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    long long kthLargestLevelSum(TreeNode* root, int k) {\\n        queue<TreeNode*>q;\\n        q.push(root);\\n        if(root==NULL){\\n            return -1;\\n        }\\n        vector<long long>ans;\\n        while(!q.empty()){\\n            int size=q.size();\\n            long long sum=0;\\n            for(int i=0;i<size;i++){\\n              TreeNode*temp=q.front();\\n              sum+=temp->val;\\n              q.pop();\\n              if(temp->left!=NULL){\\n                  q.push(temp->left);\\n              }\\n              if(temp->right!=NULL){\\n                  q.push(temp->right);\\n              }\\n            }\\n            ans.push_back(sum);\\n        }\\n        if(ans.size()<k){\\n            return -1;\\n        }\\n        sort(ans.begin(),ans.end());\\n        long long solution=ans[ans.size()-k];\\n        return solution;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    long long kthLargestLevelSum(TreeNode* root, int k) {\\n        queue<TreeNode*>q;\\n        q.push(root);\\n        if(root==NULL){\\n            return -1;\\n        }\\n        vector<long long>ans;\\n        while(!q.empty()){\\n            int size=q.size();\\n            long long sum=0;\\n            for(int i=0;i<size;i++){\\n              TreeNode*temp=q.front();\\n              sum+=temp->val;\\n              q.pop();\\n              if(temp->left!=NULL){\\n                  q.push(temp->left);\\n              }\\n              if(temp->right!=NULL){\\n                  q.push(temp->right);\\n              }\\n            }\\n            ans.push_back(sum);\\n        }\\n        if(ans.size()<k){\\n            return -1;\\n        }\\n        sort(ans.begin(),ans.end());\\n        long long solution=ans[ans.size()-k];\\n        return solution;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3681369,
                "title": "c-bfs-and-minheap-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\nprivate:\\n    using LargeNumber = long long int;\\n\\npublic:\\n    long long kthLargestLevelSum(TreeNode* root, int k) {\\n        queue<TreeNode*> levelQueue{};\\n        levelQueue.push(root);\\n        levelQueue.push(nullptr);\\n\\n        priority_queue<LargeNumber, vector<LargeNumber>, greater<LargeNumber>> minimumHeap{};\\n\\n        LargeNumber levelSum{};\\n        while (!levelQueue.empty())\\n        {\\n            auto levelTop = levelQueue.front();\\n            levelQueue.pop();\\n\\n            if (!levelTop)\\n            {\\n                minimumHeap.push(levelSum);\\n                if (minimumHeap.size() > k)\\n                    minimumHeap.pop();\\n                levelQueue.push(nullptr);\\n                if (!levelQueue.front())\\n                    break;\\n                levelSum = 0;\\n                continue;\\n            }\\n\\n            levelSum += levelTop->val;\\n            if (levelTop->left)\\n                levelQueue.push(levelTop->left);\\n            if (levelTop->right)\\n                levelQueue.push(levelTop->right);\\n        }\\n\\n        return minimumHeap.size() < k ? -1 : minimumHeap.top();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\nprivate:\\n    using LargeNumber = long long int;\\n\\npublic:\\n    long long kthLargestLevelSum(TreeNode* root, int k) {\\n        queue<TreeNode*> levelQueue{};\\n        levelQueue.push(root);\\n        levelQueue.push(nullptr);\\n\\n        priority_queue<LargeNumber, vector<LargeNumber>, greater<LargeNumber>> minimumHeap{};\\n\\n        LargeNumber levelSum{};\\n        while (!levelQueue.empty())\\n        {\\n            auto levelTop = levelQueue.front();\\n            levelQueue.pop();\\n\\n            if (!levelTop)\\n            {\\n                minimumHeap.push(levelSum);\\n                if (minimumHeap.size() > k)\\n                    minimumHeap.pop();\\n                levelQueue.push(nullptr);\\n                if (!levelQueue.front())\\n                    break;\\n                levelSum = 0;\\n                continue;\\n            }\\n\\n            levelSum += levelTop->val;\\n            if (levelTop->left)\\n                levelQueue.push(levelTop->left);\\n            if (levelTop->right)\\n                levelQueue.push(levelTop->right);\\n        }\\n\\n        return minimumHeap.size() < k ? -1 : minimumHeap.top();\\n    }\\n};\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1822428,
                "content": [
                    {
                        "username": "aeroabrar_31",
                        "content": "Who all got a penalty for not taking the return -1 condition into consideration ? \\uD83D\\uDE02"
                    },
                    {
                        "username": "larachicharo",
                        "content": "This problem should be marked as easy."
                    },
                    {
                        "username": "KOCMOHABT",
                        "content": "Pls, add more examples next time or make description is more clear. k_th largest sum was very unclear for me. Should it be largest level sum from first k levels, or should it be the largest sum from last levels after k_th level.\\nBut it turns out that it was necessary to find the k_th sum in ascending order. Why didn\\'t you write it like that?"
                    },
                    {
                        "username": "mochiball",
                        "content": "Easy level question "
                    },
                    {
                        "username": "psionl0",
                        "content": "44 of 45 test cases passed. But the 45th test case returned the wrong answer. Unfortunately, the 45th test case has such a massive tree (with massive numbers) that I can't trace through the code to see what went wrong. My algorithm must be sound or else a lot fewer than 44 test cases would have passed.\n\nWhat to do?\nhttps://leetcode.com/problems/kth-largest-sum-in-a-binary-tree/submissions/942514722/\n\nEDIT\nI am officially out of ideas. I had been using the min-heap method of getting the kth largest sum and theorized that duplicate values might be gumming the works (if the current sum is equal to the top of the heap then it won't get inserted even if it is part of the k largest sums).\n\nSo I switched over to the fast partition method and guess what? Identical answer!\nhttps://leetcode.com/problems/kth-largest-sum-in-a-binary-tree/submissions/943069088/"
                    },
                    {
                        "username": "santoshkumar15841",
                        "content": "simple level order traversal\\n\\nclass Solution {\\npublic:\\n    long long kthLargestLevelSum(TreeNode* root, int k) {\\n        \\n        queue<TreeNode*> q;\\n        q.push(root);\\n\\n        vector<long long> lvlsum;\\n\\n        while(!q.empty()){\\n\\n            long long sum = 0;\\n            int size = q.size();\\n\\n            for(int  i = 0; i < size; i++){\\n\\n                TreeNode* temp = q.front();\\n                q.pop();\\n\\n                sum += temp -> val;\\n                if(temp -> left) q.push(temp -> left);\\n                if(temp -> right) q.push(temp -> right);\\n            }\\n\\n            lvlsum.push_back(sum);\\n        }\\n        sort(lvlsum.begin(), lvlsum.end(), greater<long long>());\\n\\n        if(lvlsum.size() < k){\\n            return -1;\\n        }\\n\\n        return lvlsum[k-1];\\n    }\\n};"
                    },
                    {
                        "username": "nkarthik3092",
                        "content": "I am attempting to solve this problem using C++. I notice that the size of an uninitialized vector is set to an arbitrarily large number, whereas it should be zero based on the C++ standard. May I know why this is the case?"
                    },
                    {
                        "username": "palkeshjain06",
                        "content": "Why is this question tagged with binary search ?Anyone solved using binary search  in contest ?"
                    },
                    {
                        "username": "utkarsh_2237",
                        "content": "Could anyone please explain why this code is failing\n```\n#define ll long long int\nclass Solution {\npublic:\n    long long kthLargestLevelSum(TreeNode* root, int k) {\n        queue<TreeNode*>q;\n        q.push(root);\n        vector<ll>ans;\n        while(q.size()){\n            ll sum=0;\n            int c=q.size();\n            for(int i=0;i<c;i++){\n                TreeNode* f=q.front();\n                if(f->left)q.push(f->left);\n                if(f->right)q.push(f->right);\n                sum+=f->val;\n                q.pop();\n            }\n            ans.push_back(sum);\n        }\n        int n=ans.size();\n        if(n<k)return -1;\n        sort(ans.begin(),ans.end(),greater<int>());\n        if(ans.size()<k)return -1;\n        return ans[k-1];\n    }\n};\n```"
                    },
                    {
                        "username": "UVSinghK",
                        "content": "[@utkarsh_2237](/utkarsh_2237) No worries Bro\\uD83D\\uDE00"
                    },
                    {
                        "username": "utkarsh_2237",
                        "content": "actually i got it\nI should have used this\n```\ngreater<long long int>() in sort function\ninstead of greater<int>()\n```\n\n"
                    },
                    {
                        "username": "utkarsh_2237",
                        "content": "[@UVSinghK](/UVSinghK) \\nthank you so much\\nfor replying"
                    },
                    {
                        "username": "UVSinghK",
                        "content": "You poped element from q after pushing left and right elements if exists, pop it just after retrieving the front element;"
                    },
                    {
                        "username": "aeroabrar_31",
                        "content": "Simple BFS and clean code in java \\uD83D\\uDC47\\uD83C\\uDFFB\\n\\nhttps://leetcode.com/problems/kth-largest-sum-in-a-binary-tree/solutions/3258164/simple-bfs-clean-code-well-explained/?orderBy=most_votes"
                    }
                ]
            },
            {
                "id": 1880670,
                "content": [
                    {
                        "username": "aeroabrar_31",
                        "content": "Who all got a penalty for not taking the return -1 condition into consideration ? \\uD83D\\uDE02"
                    },
                    {
                        "username": "larachicharo",
                        "content": "This problem should be marked as easy."
                    },
                    {
                        "username": "KOCMOHABT",
                        "content": "Pls, add more examples next time or make description is more clear. k_th largest sum was very unclear for me. Should it be largest level sum from first k levels, or should it be the largest sum from last levels after k_th level.\\nBut it turns out that it was necessary to find the k_th sum in ascending order. Why didn\\'t you write it like that?"
                    },
                    {
                        "username": "mochiball",
                        "content": "Easy level question "
                    },
                    {
                        "username": "psionl0",
                        "content": "44 of 45 test cases passed. But the 45th test case returned the wrong answer. Unfortunately, the 45th test case has such a massive tree (with massive numbers) that I can't trace through the code to see what went wrong. My algorithm must be sound or else a lot fewer than 44 test cases would have passed.\n\nWhat to do?\nhttps://leetcode.com/problems/kth-largest-sum-in-a-binary-tree/submissions/942514722/\n\nEDIT\nI am officially out of ideas. I had been using the min-heap method of getting the kth largest sum and theorized that duplicate values might be gumming the works (if the current sum is equal to the top of the heap then it won't get inserted even if it is part of the k largest sums).\n\nSo I switched over to the fast partition method and guess what? Identical answer!\nhttps://leetcode.com/problems/kth-largest-sum-in-a-binary-tree/submissions/943069088/"
                    },
                    {
                        "username": "santoshkumar15841",
                        "content": "simple level order traversal\\n\\nclass Solution {\\npublic:\\n    long long kthLargestLevelSum(TreeNode* root, int k) {\\n        \\n        queue<TreeNode*> q;\\n        q.push(root);\\n\\n        vector<long long> lvlsum;\\n\\n        while(!q.empty()){\\n\\n            long long sum = 0;\\n            int size = q.size();\\n\\n            for(int  i = 0; i < size; i++){\\n\\n                TreeNode* temp = q.front();\\n                q.pop();\\n\\n                sum += temp -> val;\\n                if(temp -> left) q.push(temp -> left);\\n                if(temp -> right) q.push(temp -> right);\\n            }\\n\\n            lvlsum.push_back(sum);\\n        }\\n        sort(lvlsum.begin(), lvlsum.end(), greater<long long>());\\n\\n        if(lvlsum.size() < k){\\n            return -1;\\n        }\\n\\n        return lvlsum[k-1];\\n    }\\n};"
                    },
                    {
                        "username": "nkarthik3092",
                        "content": "I am attempting to solve this problem using C++. I notice that the size of an uninitialized vector is set to an arbitrarily large number, whereas it should be zero based on the C++ standard. May I know why this is the case?"
                    },
                    {
                        "username": "palkeshjain06",
                        "content": "Why is this question tagged with binary search ?Anyone solved using binary search  in contest ?"
                    },
                    {
                        "username": "utkarsh_2237",
                        "content": "Could anyone please explain why this code is failing\n```\n#define ll long long int\nclass Solution {\npublic:\n    long long kthLargestLevelSum(TreeNode* root, int k) {\n        queue<TreeNode*>q;\n        q.push(root);\n        vector<ll>ans;\n        while(q.size()){\n            ll sum=0;\n            int c=q.size();\n            for(int i=0;i<c;i++){\n                TreeNode* f=q.front();\n                if(f->left)q.push(f->left);\n                if(f->right)q.push(f->right);\n                sum+=f->val;\n                q.pop();\n            }\n            ans.push_back(sum);\n        }\n        int n=ans.size();\n        if(n<k)return -1;\n        sort(ans.begin(),ans.end(),greater<int>());\n        if(ans.size()<k)return -1;\n        return ans[k-1];\n    }\n};\n```"
                    },
                    {
                        "username": "UVSinghK",
                        "content": "[@utkarsh_2237](/utkarsh_2237) No worries Bro\\uD83D\\uDE00"
                    },
                    {
                        "username": "utkarsh_2237",
                        "content": "actually i got it\nI should have used this\n```\ngreater<long long int>() in sort function\ninstead of greater<int>()\n```\n\n"
                    },
                    {
                        "username": "utkarsh_2237",
                        "content": "[@UVSinghK](/UVSinghK) \\nthank you so much\\nfor replying"
                    },
                    {
                        "username": "UVSinghK",
                        "content": "You poped element from q after pushing left and right elements if exists, pop it just after retrieving the front element;"
                    },
                    {
                        "username": "aeroabrar_31",
                        "content": "Simple BFS and clean code in java \\uD83D\\uDC47\\uD83C\\uDFFB\\n\\nhttps://leetcode.com/problems/kth-largest-sum-in-a-binary-tree/solutions/3258164/simple-bfs-clean-code-well-explained/?orderBy=most_votes"
                    }
                ]
            },
            {
                "id": 1822311,
                "content": [
                    {
                        "username": "aeroabrar_31",
                        "content": "Who all got a penalty for not taking the return -1 condition into consideration ? \\uD83D\\uDE02"
                    },
                    {
                        "username": "larachicharo",
                        "content": "This problem should be marked as easy."
                    },
                    {
                        "username": "KOCMOHABT",
                        "content": "Pls, add more examples next time or make description is more clear. k_th largest sum was very unclear for me. Should it be largest level sum from first k levels, or should it be the largest sum from last levels after k_th level.\\nBut it turns out that it was necessary to find the k_th sum in ascending order. Why didn\\'t you write it like that?"
                    },
                    {
                        "username": "mochiball",
                        "content": "Easy level question "
                    },
                    {
                        "username": "psionl0",
                        "content": "44 of 45 test cases passed. But the 45th test case returned the wrong answer. Unfortunately, the 45th test case has such a massive tree (with massive numbers) that I can't trace through the code to see what went wrong. My algorithm must be sound or else a lot fewer than 44 test cases would have passed.\n\nWhat to do?\nhttps://leetcode.com/problems/kth-largest-sum-in-a-binary-tree/submissions/942514722/\n\nEDIT\nI am officially out of ideas. I had been using the min-heap method of getting the kth largest sum and theorized that duplicate values might be gumming the works (if the current sum is equal to the top of the heap then it won't get inserted even if it is part of the k largest sums).\n\nSo I switched over to the fast partition method and guess what? Identical answer!\nhttps://leetcode.com/problems/kth-largest-sum-in-a-binary-tree/submissions/943069088/"
                    },
                    {
                        "username": "santoshkumar15841",
                        "content": "simple level order traversal\\n\\nclass Solution {\\npublic:\\n    long long kthLargestLevelSum(TreeNode* root, int k) {\\n        \\n        queue<TreeNode*> q;\\n        q.push(root);\\n\\n        vector<long long> lvlsum;\\n\\n        while(!q.empty()){\\n\\n            long long sum = 0;\\n            int size = q.size();\\n\\n            for(int  i = 0; i < size; i++){\\n\\n                TreeNode* temp = q.front();\\n                q.pop();\\n\\n                sum += temp -> val;\\n                if(temp -> left) q.push(temp -> left);\\n                if(temp -> right) q.push(temp -> right);\\n            }\\n\\n            lvlsum.push_back(sum);\\n        }\\n        sort(lvlsum.begin(), lvlsum.end(), greater<long long>());\\n\\n        if(lvlsum.size() < k){\\n            return -1;\\n        }\\n\\n        return lvlsum[k-1];\\n    }\\n};"
                    },
                    {
                        "username": "nkarthik3092",
                        "content": "I am attempting to solve this problem using C++. I notice that the size of an uninitialized vector is set to an arbitrarily large number, whereas it should be zero based on the C++ standard. May I know why this is the case?"
                    },
                    {
                        "username": "palkeshjain06",
                        "content": "Why is this question tagged with binary search ?Anyone solved using binary search  in contest ?"
                    },
                    {
                        "username": "utkarsh_2237",
                        "content": "Could anyone please explain why this code is failing\n```\n#define ll long long int\nclass Solution {\npublic:\n    long long kthLargestLevelSum(TreeNode* root, int k) {\n        queue<TreeNode*>q;\n        q.push(root);\n        vector<ll>ans;\n        while(q.size()){\n            ll sum=0;\n            int c=q.size();\n            for(int i=0;i<c;i++){\n                TreeNode* f=q.front();\n                if(f->left)q.push(f->left);\n                if(f->right)q.push(f->right);\n                sum+=f->val;\n                q.pop();\n            }\n            ans.push_back(sum);\n        }\n        int n=ans.size();\n        if(n<k)return -1;\n        sort(ans.begin(),ans.end(),greater<int>());\n        if(ans.size()<k)return -1;\n        return ans[k-1];\n    }\n};\n```"
                    },
                    {
                        "username": "UVSinghK",
                        "content": "[@utkarsh_2237](/utkarsh_2237) No worries Bro\\uD83D\\uDE00"
                    },
                    {
                        "username": "utkarsh_2237",
                        "content": "actually i got it\nI should have used this\n```\ngreater<long long int>() in sort function\ninstead of greater<int>()\n```\n\n"
                    },
                    {
                        "username": "utkarsh_2237",
                        "content": "[@UVSinghK](/UVSinghK) \\nthank you so much\\nfor replying"
                    },
                    {
                        "username": "UVSinghK",
                        "content": "You poped element from q after pushing left and right elements if exists, pop it just after retrieving the front element;"
                    },
                    {
                        "username": "aeroabrar_31",
                        "content": "Simple BFS and clean code in java \\uD83D\\uDC47\\uD83C\\uDFFB\\n\\nhttps://leetcode.com/problems/kth-largest-sum-in-a-binary-tree/solutions/3258164/simple-bfs-clean-code-well-explained/?orderBy=most_votes"
                    }
                ]
            },
            {
                "id": 1938730,
                "content": [
                    {
                        "username": "aeroabrar_31",
                        "content": "Who all got a penalty for not taking the return -1 condition into consideration ? \\uD83D\\uDE02"
                    },
                    {
                        "username": "larachicharo",
                        "content": "This problem should be marked as easy."
                    },
                    {
                        "username": "KOCMOHABT",
                        "content": "Pls, add more examples next time or make description is more clear. k_th largest sum was very unclear for me. Should it be largest level sum from first k levels, or should it be the largest sum from last levels after k_th level.\\nBut it turns out that it was necessary to find the k_th sum in ascending order. Why didn\\'t you write it like that?"
                    },
                    {
                        "username": "mochiball",
                        "content": "Easy level question "
                    },
                    {
                        "username": "psionl0",
                        "content": "44 of 45 test cases passed. But the 45th test case returned the wrong answer. Unfortunately, the 45th test case has such a massive tree (with massive numbers) that I can't trace through the code to see what went wrong. My algorithm must be sound or else a lot fewer than 44 test cases would have passed.\n\nWhat to do?\nhttps://leetcode.com/problems/kth-largest-sum-in-a-binary-tree/submissions/942514722/\n\nEDIT\nI am officially out of ideas. I had been using the min-heap method of getting the kth largest sum and theorized that duplicate values might be gumming the works (if the current sum is equal to the top of the heap then it won't get inserted even if it is part of the k largest sums).\n\nSo I switched over to the fast partition method and guess what? Identical answer!\nhttps://leetcode.com/problems/kth-largest-sum-in-a-binary-tree/submissions/943069088/"
                    },
                    {
                        "username": "santoshkumar15841",
                        "content": "simple level order traversal\\n\\nclass Solution {\\npublic:\\n    long long kthLargestLevelSum(TreeNode* root, int k) {\\n        \\n        queue<TreeNode*> q;\\n        q.push(root);\\n\\n        vector<long long> lvlsum;\\n\\n        while(!q.empty()){\\n\\n            long long sum = 0;\\n            int size = q.size();\\n\\n            for(int  i = 0; i < size; i++){\\n\\n                TreeNode* temp = q.front();\\n                q.pop();\\n\\n                sum += temp -> val;\\n                if(temp -> left) q.push(temp -> left);\\n                if(temp -> right) q.push(temp -> right);\\n            }\\n\\n            lvlsum.push_back(sum);\\n        }\\n        sort(lvlsum.begin(), lvlsum.end(), greater<long long>());\\n\\n        if(lvlsum.size() < k){\\n            return -1;\\n        }\\n\\n        return lvlsum[k-1];\\n    }\\n};"
                    },
                    {
                        "username": "nkarthik3092",
                        "content": "I am attempting to solve this problem using C++. I notice that the size of an uninitialized vector is set to an arbitrarily large number, whereas it should be zero based on the C++ standard. May I know why this is the case?"
                    },
                    {
                        "username": "palkeshjain06",
                        "content": "Why is this question tagged with binary search ?Anyone solved using binary search  in contest ?"
                    },
                    {
                        "username": "utkarsh_2237",
                        "content": "Could anyone please explain why this code is failing\n```\n#define ll long long int\nclass Solution {\npublic:\n    long long kthLargestLevelSum(TreeNode* root, int k) {\n        queue<TreeNode*>q;\n        q.push(root);\n        vector<ll>ans;\n        while(q.size()){\n            ll sum=0;\n            int c=q.size();\n            for(int i=0;i<c;i++){\n                TreeNode* f=q.front();\n                if(f->left)q.push(f->left);\n                if(f->right)q.push(f->right);\n                sum+=f->val;\n                q.pop();\n            }\n            ans.push_back(sum);\n        }\n        int n=ans.size();\n        if(n<k)return -1;\n        sort(ans.begin(),ans.end(),greater<int>());\n        if(ans.size()<k)return -1;\n        return ans[k-1];\n    }\n};\n```"
                    },
                    {
                        "username": "UVSinghK",
                        "content": "[@utkarsh_2237](/utkarsh_2237) No worries Bro\\uD83D\\uDE00"
                    },
                    {
                        "username": "utkarsh_2237",
                        "content": "actually i got it\nI should have used this\n```\ngreater<long long int>() in sort function\ninstead of greater<int>()\n```\n\n"
                    },
                    {
                        "username": "utkarsh_2237",
                        "content": "[@UVSinghK](/UVSinghK) \\nthank you so much\\nfor replying"
                    },
                    {
                        "username": "UVSinghK",
                        "content": "You poped element from q after pushing left and right elements if exists, pop it just after retrieving the front element;"
                    },
                    {
                        "username": "aeroabrar_31",
                        "content": "Simple BFS and clean code in java \\uD83D\\uDC47\\uD83C\\uDFFB\\n\\nhttps://leetcode.com/problems/kth-largest-sum-in-a-binary-tree/solutions/3258164/simple-bfs-clean-code-well-explained/?orderBy=most_votes"
                    }
                ]
            },
            {
                "id": 1879067,
                "content": [
                    {
                        "username": "aeroabrar_31",
                        "content": "Who all got a penalty for not taking the return -1 condition into consideration ? \\uD83D\\uDE02"
                    },
                    {
                        "username": "larachicharo",
                        "content": "This problem should be marked as easy."
                    },
                    {
                        "username": "KOCMOHABT",
                        "content": "Pls, add more examples next time or make description is more clear. k_th largest sum was very unclear for me. Should it be largest level sum from first k levels, or should it be the largest sum from last levels after k_th level.\\nBut it turns out that it was necessary to find the k_th sum in ascending order. Why didn\\'t you write it like that?"
                    },
                    {
                        "username": "mochiball",
                        "content": "Easy level question "
                    },
                    {
                        "username": "psionl0",
                        "content": "44 of 45 test cases passed. But the 45th test case returned the wrong answer. Unfortunately, the 45th test case has such a massive tree (with massive numbers) that I can't trace through the code to see what went wrong. My algorithm must be sound or else a lot fewer than 44 test cases would have passed.\n\nWhat to do?\nhttps://leetcode.com/problems/kth-largest-sum-in-a-binary-tree/submissions/942514722/\n\nEDIT\nI am officially out of ideas. I had been using the min-heap method of getting the kth largest sum and theorized that duplicate values might be gumming the works (if the current sum is equal to the top of the heap then it won't get inserted even if it is part of the k largest sums).\n\nSo I switched over to the fast partition method and guess what? Identical answer!\nhttps://leetcode.com/problems/kth-largest-sum-in-a-binary-tree/submissions/943069088/"
                    },
                    {
                        "username": "santoshkumar15841",
                        "content": "simple level order traversal\\n\\nclass Solution {\\npublic:\\n    long long kthLargestLevelSum(TreeNode* root, int k) {\\n        \\n        queue<TreeNode*> q;\\n        q.push(root);\\n\\n        vector<long long> lvlsum;\\n\\n        while(!q.empty()){\\n\\n            long long sum = 0;\\n            int size = q.size();\\n\\n            for(int  i = 0; i < size; i++){\\n\\n                TreeNode* temp = q.front();\\n                q.pop();\\n\\n                sum += temp -> val;\\n                if(temp -> left) q.push(temp -> left);\\n                if(temp -> right) q.push(temp -> right);\\n            }\\n\\n            lvlsum.push_back(sum);\\n        }\\n        sort(lvlsum.begin(), lvlsum.end(), greater<long long>());\\n\\n        if(lvlsum.size() < k){\\n            return -1;\\n        }\\n\\n        return lvlsum[k-1];\\n    }\\n};"
                    },
                    {
                        "username": "nkarthik3092",
                        "content": "I am attempting to solve this problem using C++. I notice that the size of an uninitialized vector is set to an arbitrarily large number, whereas it should be zero based on the C++ standard. May I know why this is the case?"
                    },
                    {
                        "username": "palkeshjain06",
                        "content": "Why is this question tagged with binary search ?Anyone solved using binary search  in contest ?"
                    },
                    {
                        "username": "utkarsh_2237",
                        "content": "Could anyone please explain why this code is failing\n```\n#define ll long long int\nclass Solution {\npublic:\n    long long kthLargestLevelSum(TreeNode* root, int k) {\n        queue<TreeNode*>q;\n        q.push(root);\n        vector<ll>ans;\n        while(q.size()){\n            ll sum=0;\n            int c=q.size();\n            for(int i=0;i<c;i++){\n                TreeNode* f=q.front();\n                if(f->left)q.push(f->left);\n                if(f->right)q.push(f->right);\n                sum+=f->val;\n                q.pop();\n            }\n            ans.push_back(sum);\n        }\n        int n=ans.size();\n        if(n<k)return -1;\n        sort(ans.begin(),ans.end(),greater<int>());\n        if(ans.size()<k)return -1;\n        return ans[k-1];\n    }\n};\n```"
                    },
                    {
                        "username": "UVSinghK",
                        "content": "[@utkarsh_2237](/utkarsh_2237) No worries Bro\\uD83D\\uDE00"
                    },
                    {
                        "username": "utkarsh_2237",
                        "content": "actually i got it\nI should have used this\n```\ngreater<long long int>() in sort function\ninstead of greater<int>()\n```\n\n"
                    },
                    {
                        "username": "utkarsh_2237",
                        "content": "[@UVSinghK](/UVSinghK) \\nthank you so much\\nfor replying"
                    },
                    {
                        "username": "UVSinghK",
                        "content": "You poped element from q after pushing left and right elements if exists, pop it just after retrieving the front element;"
                    },
                    {
                        "username": "aeroabrar_31",
                        "content": "Simple BFS and clean code in java \\uD83D\\uDC47\\uD83C\\uDFFB\\n\\nhttps://leetcode.com/problems/kth-largest-sum-in-a-binary-tree/solutions/3258164/simple-bfs-clean-code-well-explained/?orderBy=most_votes"
                    }
                ]
            },
            {
                "id": 1850047,
                "content": [
                    {
                        "username": "aeroabrar_31",
                        "content": "Who all got a penalty for not taking the return -1 condition into consideration ? \\uD83D\\uDE02"
                    },
                    {
                        "username": "larachicharo",
                        "content": "This problem should be marked as easy."
                    },
                    {
                        "username": "KOCMOHABT",
                        "content": "Pls, add more examples next time or make description is more clear. k_th largest sum was very unclear for me. Should it be largest level sum from first k levels, or should it be the largest sum from last levels after k_th level.\\nBut it turns out that it was necessary to find the k_th sum in ascending order. Why didn\\'t you write it like that?"
                    },
                    {
                        "username": "mochiball",
                        "content": "Easy level question "
                    },
                    {
                        "username": "psionl0",
                        "content": "44 of 45 test cases passed. But the 45th test case returned the wrong answer. Unfortunately, the 45th test case has such a massive tree (with massive numbers) that I can't trace through the code to see what went wrong. My algorithm must be sound or else a lot fewer than 44 test cases would have passed.\n\nWhat to do?\nhttps://leetcode.com/problems/kth-largest-sum-in-a-binary-tree/submissions/942514722/\n\nEDIT\nI am officially out of ideas. I had been using the min-heap method of getting the kth largest sum and theorized that duplicate values might be gumming the works (if the current sum is equal to the top of the heap then it won't get inserted even if it is part of the k largest sums).\n\nSo I switched over to the fast partition method and guess what? Identical answer!\nhttps://leetcode.com/problems/kth-largest-sum-in-a-binary-tree/submissions/943069088/"
                    },
                    {
                        "username": "santoshkumar15841",
                        "content": "simple level order traversal\\n\\nclass Solution {\\npublic:\\n    long long kthLargestLevelSum(TreeNode* root, int k) {\\n        \\n        queue<TreeNode*> q;\\n        q.push(root);\\n\\n        vector<long long> lvlsum;\\n\\n        while(!q.empty()){\\n\\n            long long sum = 0;\\n            int size = q.size();\\n\\n            for(int  i = 0; i < size; i++){\\n\\n                TreeNode* temp = q.front();\\n                q.pop();\\n\\n                sum += temp -> val;\\n                if(temp -> left) q.push(temp -> left);\\n                if(temp -> right) q.push(temp -> right);\\n            }\\n\\n            lvlsum.push_back(sum);\\n        }\\n        sort(lvlsum.begin(), lvlsum.end(), greater<long long>());\\n\\n        if(lvlsum.size() < k){\\n            return -1;\\n        }\\n\\n        return lvlsum[k-1];\\n    }\\n};"
                    },
                    {
                        "username": "nkarthik3092",
                        "content": "I am attempting to solve this problem using C++. I notice that the size of an uninitialized vector is set to an arbitrarily large number, whereas it should be zero based on the C++ standard. May I know why this is the case?"
                    },
                    {
                        "username": "palkeshjain06",
                        "content": "Why is this question tagged with binary search ?Anyone solved using binary search  in contest ?"
                    },
                    {
                        "username": "utkarsh_2237",
                        "content": "Could anyone please explain why this code is failing\n```\n#define ll long long int\nclass Solution {\npublic:\n    long long kthLargestLevelSum(TreeNode* root, int k) {\n        queue<TreeNode*>q;\n        q.push(root);\n        vector<ll>ans;\n        while(q.size()){\n            ll sum=0;\n            int c=q.size();\n            for(int i=0;i<c;i++){\n                TreeNode* f=q.front();\n                if(f->left)q.push(f->left);\n                if(f->right)q.push(f->right);\n                sum+=f->val;\n                q.pop();\n            }\n            ans.push_back(sum);\n        }\n        int n=ans.size();\n        if(n<k)return -1;\n        sort(ans.begin(),ans.end(),greater<int>());\n        if(ans.size()<k)return -1;\n        return ans[k-1];\n    }\n};\n```"
                    },
                    {
                        "username": "UVSinghK",
                        "content": "[@utkarsh_2237](/utkarsh_2237) No worries Bro\\uD83D\\uDE00"
                    },
                    {
                        "username": "utkarsh_2237",
                        "content": "actually i got it\nI should have used this\n```\ngreater<long long int>() in sort function\ninstead of greater<int>()\n```\n\n"
                    },
                    {
                        "username": "utkarsh_2237",
                        "content": "[@UVSinghK](/UVSinghK) \\nthank you so much\\nfor replying"
                    },
                    {
                        "username": "UVSinghK",
                        "content": "You poped element from q after pushing left and right elements if exists, pop it just after retrieving the front element;"
                    },
                    {
                        "username": "aeroabrar_31",
                        "content": "Simple BFS and clean code in java \\uD83D\\uDC47\\uD83C\\uDFFB\\n\\nhttps://leetcode.com/problems/kth-largest-sum-in-a-binary-tree/solutions/3258164/simple-bfs-clean-code-well-explained/?orderBy=most_votes"
                    }
                ]
            },
            {
                "id": 1825688,
                "content": [
                    {
                        "username": "aeroabrar_31",
                        "content": "Who all got a penalty for not taking the return -1 condition into consideration ? \\uD83D\\uDE02"
                    },
                    {
                        "username": "larachicharo",
                        "content": "This problem should be marked as easy."
                    },
                    {
                        "username": "KOCMOHABT",
                        "content": "Pls, add more examples next time or make description is more clear. k_th largest sum was very unclear for me. Should it be largest level sum from first k levels, or should it be the largest sum from last levels after k_th level.\\nBut it turns out that it was necessary to find the k_th sum in ascending order. Why didn\\'t you write it like that?"
                    },
                    {
                        "username": "mochiball",
                        "content": "Easy level question "
                    },
                    {
                        "username": "psionl0",
                        "content": "44 of 45 test cases passed. But the 45th test case returned the wrong answer. Unfortunately, the 45th test case has such a massive tree (with massive numbers) that I can't trace through the code to see what went wrong. My algorithm must be sound or else a lot fewer than 44 test cases would have passed.\n\nWhat to do?\nhttps://leetcode.com/problems/kth-largest-sum-in-a-binary-tree/submissions/942514722/\n\nEDIT\nI am officially out of ideas. I had been using the min-heap method of getting the kth largest sum and theorized that duplicate values might be gumming the works (if the current sum is equal to the top of the heap then it won't get inserted even if it is part of the k largest sums).\n\nSo I switched over to the fast partition method and guess what? Identical answer!\nhttps://leetcode.com/problems/kth-largest-sum-in-a-binary-tree/submissions/943069088/"
                    },
                    {
                        "username": "santoshkumar15841",
                        "content": "simple level order traversal\\n\\nclass Solution {\\npublic:\\n    long long kthLargestLevelSum(TreeNode* root, int k) {\\n        \\n        queue<TreeNode*> q;\\n        q.push(root);\\n\\n        vector<long long> lvlsum;\\n\\n        while(!q.empty()){\\n\\n            long long sum = 0;\\n            int size = q.size();\\n\\n            for(int  i = 0; i < size; i++){\\n\\n                TreeNode* temp = q.front();\\n                q.pop();\\n\\n                sum += temp -> val;\\n                if(temp -> left) q.push(temp -> left);\\n                if(temp -> right) q.push(temp -> right);\\n            }\\n\\n            lvlsum.push_back(sum);\\n        }\\n        sort(lvlsum.begin(), lvlsum.end(), greater<long long>());\\n\\n        if(lvlsum.size() < k){\\n            return -1;\\n        }\\n\\n        return lvlsum[k-1];\\n    }\\n};"
                    },
                    {
                        "username": "nkarthik3092",
                        "content": "I am attempting to solve this problem using C++. I notice that the size of an uninitialized vector is set to an arbitrarily large number, whereas it should be zero based on the C++ standard. May I know why this is the case?"
                    },
                    {
                        "username": "palkeshjain06",
                        "content": "Why is this question tagged with binary search ?Anyone solved using binary search  in contest ?"
                    },
                    {
                        "username": "utkarsh_2237",
                        "content": "Could anyone please explain why this code is failing\n```\n#define ll long long int\nclass Solution {\npublic:\n    long long kthLargestLevelSum(TreeNode* root, int k) {\n        queue<TreeNode*>q;\n        q.push(root);\n        vector<ll>ans;\n        while(q.size()){\n            ll sum=0;\n            int c=q.size();\n            for(int i=0;i<c;i++){\n                TreeNode* f=q.front();\n                if(f->left)q.push(f->left);\n                if(f->right)q.push(f->right);\n                sum+=f->val;\n                q.pop();\n            }\n            ans.push_back(sum);\n        }\n        int n=ans.size();\n        if(n<k)return -1;\n        sort(ans.begin(),ans.end(),greater<int>());\n        if(ans.size()<k)return -1;\n        return ans[k-1];\n    }\n};\n```"
                    },
                    {
                        "username": "UVSinghK",
                        "content": "[@utkarsh_2237](/utkarsh_2237) No worries Bro\\uD83D\\uDE00"
                    },
                    {
                        "username": "utkarsh_2237",
                        "content": "actually i got it\nI should have used this\n```\ngreater<long long int>() in sort function\ninstead of greater<int>()\n```\n\n"
                    },
                    {
                        "username": "utkarsh_2237",
                        "content": "[@UVSinghK](/UVSinghK) \\nthank you so much\\nfor replying"
                    },
                    {
                        "username": "UVSinghK",
                        "content": "You poped element from q after pushing left and right elements if exists, pop it just after retrieving the front element;"
                    },
                    {
                        "username": "aeroabrar_31",
                        "content": "Simple BFS and clean code in java \\uD83D\\uDC47\\uD83C\\uDFFB\\n\\nhttps://leetcode.com/problems/kth-largest-sum-in-a-binary-tree/solutions/3258164/simple-bfs-clean-code-well-explained/?orderBy=most_votes"
                    }
                ]
            },
            {
                "id": 1825104,
                "content": [
                    {
                        "username": "aeroabrar_31",
                        "content": "Who all got a penalty for not taking the return -1 condition into consideration ? \\uD83D\\uDE02"
                    },
                    {
                        "username": "larachicharo",
                        "content": "This problem should be marked as easy."
                    },
                    {
                        "username": "KOCMOHABT",
                        "content": "Pls, add more examples next time or make description is more clear. k_th largest sum was very unclear for me. Should it be largest level sum from first k levels, or should it be the largest sum from last levels after k_th level.\\nBut it turns out that it was necessary to find the k_th sum in ascending order. Why didn\\'t you write it like that?"
                    },
                    {
                        "username": "mochiball",
                        "content": "Easy level question "
                    },
                    {
                        "username": "psionl0",
                        "content": "44 of 45 test cases passed. But the 45th test case returned the wrong answer. Unfortunately, the 45th test case has such a massive tree (with massive numbers) that I can't trace through the code to see what went wrong. My algorithm must be sound or else a lot fewer than 44 test cases would have passed.\n\nWhat to do?\nhttps://leetcode.com/problems/kth-largest-sum-in-a-binary-tree/submissions/942514722/\n\nEDIT\nI am officially out of ideas. I had been using the min-heap method of getting the kth largest sum and theorized that duplicate values might be gumming the works (if the current sum is equal to the top of the heap then it won't get inserted even if it is part of the k largest sums).\n\nSo I switched over to the fast partition method and guess what? Identical answer!\nhttps://leetcode.com/problems/kth-largest-sum-in-a-binary-tree/submissions/943069088/"
                    },
                    {
                        "username": "santoshkumar15841",
                        "content": "simple level order traversal\\n\\nclass Solution {\\npublic:\\n    long long kthLargestLevelSum(TreeNode* root, int k) {\\n        \\n        queue<TreeNode*> q;\\n        q.push(root);\\n\\n        vector<long long> lvlsum;\\n\\n        while(!q.empty()){\\n\\n            long long sum = 0;\\n            int size = q.size();\\n\\n            for(int  i = 0; i < size; i++){\\n\\n                TreeNode* temp = q.front();\\n                q.pop();\\n\\n                sum += temp -> val;\\n                if(temp -> left) q.push(temp -> left);\\n                if(temp -> right) q.push(temp -> right);\\n            }\\n\\n            lvlsum.push_back(sum);\\n        }\\n        sort(lvlsum.begin(), lvlsum.end(), greater<long long>());\\n\\n        if(lvlsum.size() < k){\\n            return -1;\\n        }\\n\\n        return lvlsum[k-1];\\n    }\\n};"
                    },
                    {
                        "username": "nkarthik3092",
                        "content": "I am attempting to solve this problem using C++. I notice that the size of an uninitialized vector is set to an arbitrarily large number, whereas it should be zero based on the C++ standard. May I know why this is the case?"
                    },
                    {
                        "username": "palkeshjain06",
                        "content": "Why is this question tagged with binary search ?Anyone solved using binary search  in contest ?"
                    },
                    {
                        "username": "utkarsh_2237",
                        "content": "Could anyone please explain why this code is failing\n```\n#define ll long long int\nclass Solution {\npublic:\n    long long kthLargestLevelSum(TreeNode* root, int k) {\n        queue<TreeNode*>q;\n        q.push(root);\n        vector<ll>ans;\n        while(q.size()){\n            ll sum=0;\n            int c=q.size();\n            for(int i=0;i<c;i++){\n                TreeNode* f=q.front();\n                if(f->left)q.push(f->left);\n                if(f->right)q.push(f->right);\n                sum+=f->val;\n                q.pop();\n            }\n            ans.push_back(sum);\n        }\n        int n=ans.size();\n        if(n<k)return -1;\n        sort(ans.begin(),ans.end(),greater<int>());\n        if(ans.size()<k)return -1;\n        return ans[k-1];\n    }\n};\n```"
                    },
                    {
                        "username": "UVSinghK",
                        "content": "[@utkarsh_2237](/utkarsh_2237) No worries Bro\\uD83D\\uDE00"
                    },
                    {
                        "username": "utkarsh_2237",
                        "content": "actually i got it\nI should have used this\n```\ngreater<long long int>() in sort function\ninstead of greater<int>()\n```\n\n"
                    },
                    {
                        "username": "utkarsh_2237",
                        "content": "[@UVSinghK](/UVSinghK) \\nthank you so much\\nfor replying"
                    },
                    {
                        "username": "UVSinghK",
                        "content": "You poped element from q after pushing left and right elements if exists, pop it just after retrieving the front element;"
                    },
                    {
                        "username": "aeroabrar_31",
                        "content": "Simple BFS and clean code in java \\uD83D\\uDC47\\uD83C\\uDFFB\\n\\nhttps://leetcode.com/problems/kth-largest-sum-in-a-binary-tree/solutions/3258164/simple-bfs-clean-code-well-explained/?orderBy=most_votes"
                    }
                ]
            },
            {
                "id": 1822419,
                "content": [
                    {
                        "username": "aeroabrar_31",
                        "content": "Who all got a penalty for not taking the return -1 condition into consideration ? \\uD83D\\uDE02"
                    },
                    {
                        "username": "larachicharo",
                        "content": "This problem should be marked as easy."
                    },
                    {
                        "username": "KOCMOHABT",
                        "content": "Pls, add more examples next time or make description is more clear. k_th largest sum was very unclear for me. Should it be largest level sum from first k levels, or should it be the largest sum from last levels after k_th level.\\nBut it turns out that it was necessary to find the k_th sum in ascending order. Why didn\\'t you write it like that?"
                    },
                    {
                        "username": "mochiball",
                        "content": "Easy level question "
                    },
                    {
                        "username": "psionl0",
                        "content": "44 of 45 test cases passed. But the 45th test case returned the wrong answer. Unfortunately, the 45th test case has such a massive tree (with massive numbers) that I can't trace through the code to see what went wrong. My algorithm must be sound or else a lot fewer than 44 test cases would have passed.\n\nWhat to do?\nhttps://leetcode.com/problems/kth-largest-sum-in-a-binary-tree/submissions/942514722/\n\nEDIT\nI am officially out of ideas. I had been using the min-heap method of getting the kth largest sum and theorized that duplicate values might be gumming the works (if the current sum is equal to the top of the heap then it won't get inserted even if it is part of the k largest sums).\n\nSo I switched over to the fast partition method and guess what? Identical answer!\nhttps://leetcode.com/problems/kth-largest-sum-in-a-binary-tree/submissions/943069088/"
                    },
                    {
                        "username": "santoshkumar15841",
                        "content": "simple level order traversal\\n\\nclass Solution {\\npublic:\\n    long long kthLargestLevelSum(TreeNode* root, int k) {\\n        \\n        queue<TreeNode*> q;\\n        q.push(root);\\n\\n        vector<long long> lvlsum;\\n\\n        while(!q.empty()){\\n\\n            long long sum = 0;\\n            int size = q.size();\\n\\n            for(int  i = 0; i < size; i++){\\n\\n                TreeNode* temp = q.front();\\n                q.pop();\\n\\n                sum += temp -> val;\\n                if(temp -> left) q.push(temp -> left);\\n                if(temp -> right) q.push(temp -> right);\\n            }\\n\\n            lvlsum.push_back(sum);\\n        }\\n        sort(lvlsum.begin(), lvlsum.end(), greater<long long>());\\n\\n        if(lvlsum.size() < k){\\n            return -1;\\n        }\\n\\n        return lvlsum[k-1];\\n    }\\n};"
                    },
                    {
                        "username": "nkarthik3092",
                        "content": "I am attempting to solve this problem using C++. I notice that the size of an uninitialized vector is set to an arbitrarily large number, whereas it should be zero based on the C++ standard. May I know why this is the case?"
                    },
                    {
                        "username": "palkeshjain06",
                        "content": "Why is this question tagged with binary search ?Anyone solved using binary search  in contest ?"
                    },
                    {
                        "username": "utkarsh_2237",
                        "content": "Could anyone please explain why this code is failing\n```\n#define ll long long int\nclass Solution {\npublic:\n    long long kthLargestLevelSum(TreeNode* root, int k) {\n        queue<TreeNode*>q;\n        q.push(root);\n        vector<ll>ans;\n        while(q.size()){\n            ll sum=0;\n            int c=q.size();\n            for(int i=0;i<c;i++){\n                TreeNode* f=q.front();\n                if(f->left)q.push(f->left);\n                if(f->right)q.push(f->right);\n                sum+=f->val;\n                q.pop();\n            }\n            ans.push_back(sum);\n        }\n        int n=ans.size();\n        if(n<k)return -1;\n        sort(ans.begin(),ans.end(),greater<int>());\n        if(ans.size()<k)return -1;\n        return ans[k-1];\n    }\n};\n```"
                    },
                    {
                        "username": "UVSinghK",
                        "content": "[@utkarsh_2237](/utkarsh_2237) No worries Bro\\uD83D\\uDE00"
                    },
                    {
                        "username": "utkarsh_2237",
                        "content": "actually i got it\nI should have used this\n```\ngreater<long long int>() in sort function\ninstead of greater<int>()\n```\n\n"
                    },
                    {
                        "username": "utkarsh_2237",
                        "content": "[@UVSinghK](/UVSinghK) \\nthank you so much\\nfor replying"
                    },
                    {
                        "username": "UVSinghK",
                        "content": "You poped element from q after pushing left and right elements if exists, pop it just after retrieving the front element;"
                    },
                    {
                        "username": "aeroabrar_31",
                        "content": "Simple BFS and clean code in java \\uD83D\\uDC47\\uD83C\\uDFFB\\n\\nhttps://leetcode.com/problems/kth-largest-sum-in-a-binary-tree/solutions/3258164/simple-bfs-clean-code-well-explained/?orderBy=most_votes"
                    }
                ]
            },
            {
                "id": 1822300,
                "content": [
                    {
                        "username": "aeroabrar_31",
                        "content": "Who all got a penalty for not taking the return -1 condition into consideration ? \\uD83D\\uDE02"
                    },
                    {
                        "username": "larachicharo",
                        "content": "This problem should be marked as easy."
                    },
                    {
                        "username": "KOCMOHABT",
                        "content": "Pls, add more examples next time or make description is more clear. k_th largest sum was very unclear for me. Should it be largest level sum from first k levels, or should it be the largest sum from last levels after k_th level.\\nBut it turns out that it was necessary to find the k_th sum in ascending order. Why didn\\'t you write it like that?"
                    },
                    {
                        "username": "mochiball",
                        "content": "Easy level question "
                    },
                    {
                        "username": "psionl0",
                        "content": "44 of 45 test cases passed. But the 45th test case returned the wrong answer. Unfortunately, the 45th test case has such a massive tree (with massive numbers) that I can't trace through the code to see what went wrong. My algorithm must be sound or else a lot fewer than 44 test cases would have passed.\n\nWhat to do?\nhttps://leetcode.com/problems/kth-largest-sum-in-a-binary-tree/submissions/942514722/\n\nEDIT\nI am officially out of ideas. I had been using the min-heap method of getting the kth largest sum and theorized that duplicate values might be gumming the works (if the current sum is equal to the top of the heap then it won't get inserted even if it is part of the k largest sums).\n\nSo I switched over to the fast partition method and guess what? Identical answer!\nhttps://leetcode.com/problems/kth-largest-sum-in-a-binary-tree/submissions/943069088/"
                    },
                    {
                        "username": "santoshkumar15841",
                        "content": "simple level order traversal\\n\\nclass Solution {\\npublic:\\n    long long kthLargestLevelSum(TreeNode* root, int k) {\\n        \\n        queue<TreeNode*> q;\\n        q.push(root);\\n\\n        vector<long long> lvlsum;\\n\\n        while(!q.empty()){\\n\\n            long long sum = 0;\\n            int size = q.size();\\n\\n            for(int  i = 0; i < size; i++){\\n\\n                TreeNode* temp = q.front();\\n                q.pop();\\n\\n                sum += temp -> val;\\n                if(temp -> left) q.push(temp -> left);\\n                if(temp -> right) q.push(temp -> right);\\n            }\\n\\n            lvlsum.push_back(sum);\\n        }\\n        sort(lvlsum.begin(), lvlsum.end(), greater<long long>());\\n\\n        if(lvlsum.size() < k){\\n            return -1;\\n        }\\n\\n        return lvlsum[k-1];\\n    }\\n};"
                    },
                    {
                        "username": "nkarthik3092",
                        "content": "I am attempting to solve this problem using C++. I notice that the size of an uninitialized vector is set to an arbitrarily large number, whereas it should be zero based on the C++ standard. May I know why this is the case?"
                    },
                    {
                        "username": "palkeshjain06",
                        "content": "Why is this question tagged with binary search ?Anyone solved using binary search  in contest ?"
                    },
                    {
                        "username": "utkarsh_2237",
                        "content": "Could anyone please explain why this code is failing\n```\n#define ll long long int\nclass Solution {\npublic:\n    long long kthLargestLevelSum(TreeNode* root, int k) {\n        queue<TreeNode*>q;\n        q.push(root);\n        vector<ll>ans;\n        while(q.size()){\n            ll sum=0;\n            int c=q.size();\n            for(int i=0;i<c;i++){\n                TreeNode* f=q.front();\n                if(f->left)q.push(f->left);\n                if(f->right)q.push(f->right);\n                sum+=f->val;\n                q.pop();\n            }\n            ans.push_back(sum);\n        }\n        int n=ans.size();\n        if(n<k)return -1;\n        sort(ans.begin(),ans.end(),greater<int>());\n        if(ans.size()<k)return -1;\n        return ans[k-1];\n    }\n};\n```"
                    },
                    {
                        "username": "UVSinghK",
                        "content": "[@utkarsh_2237](/utkarsh_2237) No worries Bro\\uD83D\\uDE00"
                    },
                    {
                        "username": "utkarsh_2237",
                        "content": "actually i got it\nI should have used this\n```\ngreater<long long int>() in sort function\ninstead of greater<int>()\n```\n\n"
                    },
                    {
                        "username": "utkarsh_2237",
                        "content": "[@UVSinghK](/UVSinghK) \\nthank you so much\\nfor replying"
                    },
                    {
                        "username": "UVSinghK",
                        "content": "You poped element from q after pushing left and right elements if exists, pop it just after retrieving the front element;"
                    },
                    {
                        "username": "aeroabrar_31",
                        "content": "Simple BFS and clean code in java \\uD83D\\uDC47\\uD83C\\uDFFB\\n\\nhttps://leetcode.com/problems/kth-largest-sum-in-a-binary-tree/solutions/3258164/simple-bfs-clean-code-well-explained/?orderBy=most_votes"
                    }
                ]
            },
            {
                "id": 1822428,
                "content": [
                    {
                        "username": "aeroabrar_31",
                        "content": "Who all got a penalty for not taking the return -1 condition into consideration ? \\uD83D\\uDE02"
                    },
                    {
                        "username": "larachicharo",
                        "content": "This problem should be marked as easy."
                    },
                    {
                        "username": "KOCMOHABT",
                        "content": "Pls, add more examples next time or make description is more clear. k_th largest sum was very unclear for me. Should it be largest level sum from first k levels, or should it be the largest sum from last levels after k_th level.\\nBut it turns out that it was necessary to find the k_th sum in ascending order. Why didn\\'t you write it like that?"
                    },
                    {
                        "username": "mochiball",
                        "content": "Easy level question "
                    },
                    {
                        "username": "psionl0",
                        "content": "44 of 45 test cases passed. But the 45th test case returned the wrong answer. Unfortunately, the 45th test case has such a massive tree (with massive numbers) that I can't trace through the code to see what went wrong. My algorithm must be sound or else a lot fewer than 44 test cases would have passed.\n\nWhat to do?\nhttps://leetcode.com/problems/kth-largest-sum-in-a-binary-tree/submissions/942514722/\n\nEDIT\nI am officially out of ideas. I had been using the min-heap method of getting the kth largest sum and theorized that duplicate values might be gumming the works (if the current sum is equal to the top of the heap then it won't get inserted even if it is part of the k largest sums).\n\nSo I switched over to the fast partition method and guess what? Identical answer!\nhttps://leetcode.com/problems/kth-largest-sum-in-a-binary-tree/submissions/943069088/"
                    },
                    {
                        "username": "santoshkumar15841",
                        "content": "simple level order traversal\\n\\nclass Solution {\\npublic:\\n    long long kthLargestLevelSum(TreeNode* root, int k) {\\n        \\n        queue<TreeNode*> q;\\n        q.push(root);\\n\\n        vector<long long> lvlsum;\\n\\n        while(!q.empty()){\\n\\n            long long sum = 0;\\n            int size = q.size();\\n\\n            for(int  i = 0; i < size; i++){\\n\\n                TreeNode* temp = q.front();\\n                q.pop();\\n\\n                sum += temp -> val;\\n                if(temp -> left) q.push(temp -> left);\\n                if(temp -> right) q.push(temp -> right);\\n            }\\n\\n            lvlsum.push_back(sum);\\n        }\\n        sort(lvlsum.begin(), lvlsum.end(), greater<long long>());\\n\\n        if(lvlsum.size() < k){\\n            return -1;\\n        }\\n\\n        return lvlsum[k-1];\\n    }\\n};"
                    },
                    {
                        "username": "nkarthik3092",
                        "content": "I am attempting to solve this problem using C++. I notice that the size of an uninitialized vector is set to an arbitrarily large number, whereas it should be zero based on the C++ standard. May I know why this is the case?"
                    },
                    {
                        "username": "palkeshjain06",
                        "content": "Why is this question tagged with binary search ?Anyone solved using binary search  in contest ?"
                    },
                    {
                        "username": "utkarsh_2237",
                        "content": "Could anyone please explain why this code is failing\n```\n#define ll long long int\nclass Solution {\npublic:\n    long long kthLargestLevelSum(TreeNode* root, int k) {\n        queue<TreeNode*>q;\n        q.push(root);\n        vector<ll>ans;\n        while(q.size()){\n            ll sum=0;\n            int c=q.size();\n            for(int i=0;i<c;i++){\n                TreeNode* f=q.front();\n                if(f->left)q.push(f->left);\n                if(f->right)q.push(f->right);\n                sum+=f->val;\n                q.pop();\n            }\n            ans.push_back(sum);\n        }\n        int n=ans.size();\n        if(n<k)return -1;\n        sort(ans.begin(),ans.end(),greater<int>());\n        if(ans.size()<k)return -1;\n        return ans[k-1];\n    }\n};\n```"
                    },
                    {
                        "username": "UVSinghK",
                        "content": "[@utkarsh_2237](/utkarsh_2237) No worries Bro\\uD83D\\uDE00"
                    },
                    {
                        "username": "utkarsh_2237",
                        "content": "actually i got it\nI should have used this\n```\ngreater<long long int>() in sort function\ninstead of greater<int>()\n```\n\n"
                    },
                    {
                        "username": "utkarsh_2237",
                        "content": "[@UVSinghK](/UVSinghK) \\nthank you so much\\nfor replying"
                    },
                    {
                        "username": "UVSinghK",
                        "content": "You poped element from q after pushing left and right elements if exists, pop it just after retrieving the front element;"
                    },
                    {
                        "username": "aeroabrar_31",
                        "content": "Simple BFS and clean code in java \\uD83D\\uDC47\\uD83C\\uDFFB\\n\\nhttps://leetcode.com/problems/kth-largest-sum-in-a-binary-tree/solutions/3258164/simple-bfs-clean-code-well-explained/?orderBy=most_votes"
                    }
                ]
            },
            {
                "id": 1880670,
                "content": [
                    {
                        "username": "aeroabrar_31",
                        "content": "Who all got a penalty for not taking the return -1 condition into consideration ? \\uD83D\\uDE02"
                    },
                    {
                        "username": "larachicharo",
                        "content": "This problem should be marked as easy."
                    },
                    {
                        "username": "KOCMOHABT",
                        "content": "Pls, add more examples next time or make description is more clear. k_th largest sum was very unclear for me. Should it be largest level sum from first k levels, or should it be the largest sum from last levels after k_th level.\\nBut it turns out that it was necessary to find the k_th sum in ascending order. Why didn\\'t you write it like that?"
                    },
                    {
                        "username": "mochiball",
                        "content": "Easy level question "
                    },
                    {
                        "username": "psionl0",
                        "content": "44 of 45 test cases passed. But the 45th test case returned the wrong answer. Unfortunately, the 45th test case has such a massive tree (with massive numbers) that I can't trace through the code to see what went wrong. My algorithm must be sound or else a lot fewer than 44 test cases would have passed.\n\nWhat to do?\nhttps://leetcode.com/problems/kth-largest-sum-in-a-binary-tree/submissions/942514722/\n\nEDIT\nI am officially out of ideas. I had been using the min-heap method of getting the kth largest sum and theorized that duplicate values might be gumming the works (if the current sum is equal to the top of the heap then it won't get inserted even if it is part of the k largest sums).\n\nSo I switched over to the fast partition method and guess what? Identical answer!\nhttps://leetcode.com/problems/kth-largest-sum-in-a-binary-tree/submissions/943069088/"
                    },
                    {
                        "username": "santoshkumar15841",
                        "content": "simple level order traversal\\n\\nclass Solution {\\npublic:\\n    long long kthLargestLevelSum(TreeNode* root, int k) {\\n        \\n        queue<TreeNode*> q;\\n        q.push(root);\\n\\n        vector<long long> lvlsum;\\n\\n        while(!q.empty()){\\n\\n            long long sum = 0;\\n            int size = q.size();\\n\\n            for(int  i = 0; i < size; i++){\\n\\n                TreeNode* temp = q.front();\\n                q.pop();\\n\\n                sum += temp -> val;\\n                if(temp -> left) q.push(temp -> left);\\n                if(temp -> right) q.push(temp -> right);\\n            }\\n\\n            lvlsum.push_back(sum);\\n        }\\n        sort(lvlsum.begin(), lvlsum.end(), greater<long long>());\\n\\n        if(lvlsum.size() < k){\\n            return -1;\\n        }\\n\\n        return lvlsum[k-1];\\n    }\\n};"
                    },
                    {
                        "username": "nkarthik3092",
                        "content": "I am attempting to solve this problem using C++. I notice that the size of an uninitialized vector is set to an arbitrarily large number, whereas it should be zero based on the C++ standard. May I know why this is the case?"
                    },
                    {
                        "username": "palkeshjain06",
                        "content": "Why is this question tagged with binary search ?Anyone solved using binary search  in contest ?"
                    },
                    {
                        "username": "utkarsh_2237",
                        "content": "Could anyone please explain why this code is failing\n```\n#define ll long long int\nclass Solution {\npublic:\n    long long kthLargestLevelSum(TreeNode* root, int k) {\n        queue<TreeNode*>q;\n        q.push(root);\n        vector<ll>ans;\n        while(q.size()){\n            ll sum=0;\n            int c=q.size();\n            for(int i=0;i<c;i++){\n                TreeNode* f=q.front();\n                if(f->left)q.push(f->left);\n                if(f->right)q.push(f->right);\n                sum+=f->val;\n                q.pop();\n            }\n            ans.push_back(sum);\n        }\n        int n=ans.size();\n        if(n<k)return -1;\n        sort(ans.begin(),ans.end(),greater<int>());\n        if(ans.size()<k)return -1;\n        return ans[k-1];\n    }\n};\n```"
                    },
                    {
                        "username": "UVSinghK",
                        "content": "[@utkarsh_2237](/utkarsh_2237) No worries Bro\\uD83D\\uDE00"
                    },
                    {
                        "username": "utkarsh_2237",
                        "content": "actually i got it\nI should have used this\n```\ngreater<long long int>() in sort function\ninstead of greater<int>()\n```\n\n"
                    },
                    {
                        "username": "utkarsh_2237",
                        "content": "[@UVSinghK](/UVSinghK) \\nthank you so much\\nfor replying"
                    },
                    {
                        "username": "UVSinghK",
                        "content": "You poped element from q after pushing left and right elements if exists, pop it just after retrieving the front element;"
                    },
                    {
                        "username": "aeroabrar_31",
                        "content": "Simple BFS and clean code in java \\uD83D\\uDC47\\uD83C\\uDFFB\\n\\nhttps://leetcode.com/problems/kth-largest-sum-in-a-binary-tree/solutions/3258164/simple-bfs-clean-code-well-explained/?orderBy=most_votes"
                    }
                ]
            },
            {
                "id": 1822311,
                "content": [
                    {
                        "username": "aeroabrar_31",
                        "content": "Who all got a penalty for not taking the return -1 condition into consideration ? \\uD83D\\uDE02"
                    },
                    {
                        "username": "larachicharo",
                        "content": "This problem should be marked as easy."
                    },
                    {
                        "username": "KOCMOHABT",
                        "content": "Pls, add more examples next time or make description is more clear. k_th largest sum was very unclear for me. Should it be largest level sum from first k levels, or should it be the largest sum from last levels after k_th level.\\nBut it turns out that it was necessary to find the k_th sum in ascending order. Why didn\\'t you write it like that?"
                    },
                    {
                        "username": "mochiball",
                        "content": "Easy level question "
                    },
                    {
                        "username": "psionl0",
                        "content": "44 of 45 test cases passed. But the 45th test case returned the wrong answer. Unfortunately, the 45th test case has such a massive tree (with massive numbers) that I can't trace through the code to see what went wrong. My algorithm must be sound or else a lot fewer than 44 test cases would have passed.\n\nWhat to do?\nhttps://leetcode.com/problems/kth-largest-sum-in-a-binary-tree/submissions/942514722/\n\nEDIT\nI am officially out of ideas. I had been using the min-heap method of getting the kth largest sum and theorized that duplicate values might be gumming the works (if the current sum is equal to the top of the heap then it won't get inserted even if it is part of the k largest sums).\n\nSo I switched over to the fast partition method and guess what? Identical answer!\nhttps://leetcode.com/problems/kth-largest-sum-in-a-binary-tree/submissions/943069088/"
                    },
                    {
                        "username": "santoshkumar15841",
                        "content": "simple level order traversal\\n\\nclass Solution {\\npublic:\\n    long long kthLargestLevelSum(TreeNode* root, int k) {\\n        \\n        queue<TreeNode*> q;\\n        q.push(root);\\n\\n        vector<long long> lvlsum;\\n\\n        while(!q.empty()){\\n\\n            long long sum = 0;\\n            int size = q.size();\\n\\n            for(int  i = 0; i < size; i++){\\n\\n                TreeNode* temp = q.front();\\n                q.pop();\\n\\n                sum += temp -> val;\\n                if(temp -> left) q.push(temp -> left);\\n                if(temp -> right) q.push(temp -> right);\\n            }\\n\\n            lvlsum.push_back(sum);\\n        }\\n        sort(lvlsum.begin(), lvlsum.end(), greater<long long>());\\n\\n        if(lvlsum.size() < k){\\n            return -1;\\n        }\\n\\n        return lvlsum[k-1];\\n    }\\n};"
                    },
                    {
                        "username": "nkarthik3092",
                        "content": "I am attempting to solve this problem using C++. I notice that the size of an uninitialized vector is set to an arbitrarily large number, whereas it should be zero based on the C++ standard. May I know why this is the case?"
                    },
                    {
                        "username": "palkeshjain06",
                        "content": "Why is this question tagged with binary search ?Anyone solved using binary search  in contest ?"
                    },
                    {
                        "username": "utkarsh_2237",
                        "content": "Could anyone please explain why this code is failing\n```\n#define ll long long int\nclass Solution {\npublic:\n    long long kthLargestLevelSum(TreeNode* root, int k) {\n        queue<TreeNode*>q;\n        q.push(root);\n        vector<ll>ans;\n        while(q.size()){\n            ll sum=0;\n            int c=q.size();\n            for(int i=0;i<c;i++){\n                TreeNode* f=q.front();\n                if(f->left)q.push(f->left);\n                if(f->right)q.push(f->right);\n                sum+=f->val;\n                q.pop();\n            }\n            ans.push_back(sum);\n        }\n        int n=ans.size();\n        if(n<k)return -1;\n        sort(ans.begin(),ans.end(),greater<int>());\n        if(ans.size()<k)return -1;\n        return ans[k-1];\n    }\n};\n```"
                    },
                    {
                        "username": "UVSinghK",
                        "content": "[@utkarsh_2237](/utkarsh_2237) No worries Bro\\uD83D\\uDE00"
                    },
                    {
                        "username": "utkarsh_2237",
                        "content": "actually i got it\nI should have used this\n```\ngreater<long long int>() in sort function\ninstead of greater<int>()\n```\n\n"
                    },
                    {
                        "username": "utkarsh_2237",
                        "content": "[@UVSinghK](/UVSinghK) \\nthank you so much\\nfor replying"
                    },
                    {
                        "username": "UVSinghK",
                        "content": "You poped element from q after pushing left and right elements if exists, pop it just after retrieving the front element;"
                    },
                    {
                        "username": "aeroabrar_31",
                        "content": "Simple BFS and clean code in java \\uD83D\\uDC47\\uD83C\\uDFFB\\n\\nhttps://leetcode.com/problems/kth-largest-sum-in-a-binary-tree/solutions/3258164/simple-bfs-clean-code-well-explained/?orderBy=most_votes"
                    }
                ]
            },
            {
                "id": 1938730,
                "content": [
                    {
                        "username": "aeroabrar_31",
                        "content": "Who all got a penalty for not taking the return -1 condition into consideration ? \\uD83D\\uDE02"
                    },
                    {
                        "username": "larachicharo",
                        "content": "This problem should be marked as easy."
                    },
                    {
                        "username": "KOCMOHABT",
                        "content": "Pls, add more examples next time or make description is more clear. k_th largest sum was very unclear for me. Should it be largest level sum from first k levels, or should it be the largest sum from last levels after k_th level.\\nBut it turns out that it was necessary to find the k_th sum in ascending order. Why didn\\'t you write it like that?"
                    },
                    {
                        "username": "mochiball",
                        "content": "Easy level question "
                    },
                    {
                        "username": "psionl0",
                        "content": "44 of 45 test cases passed. But the 45th test case returned the wrong answer. Unfortunately, the 45th test case has such a massive tree (with massive numbers) that I can't trace through the code to see what went wrong. My algorithm must be sound or else a lot fewer than 44 test cases would have passed.\n\nWhat to do?\nhttps://leetcode.com/problems/kth-largest-sum-in-a-binary-tree/submissions/942514722/\n\nEDIT\nI am officially out of ideas. I had been using the min-heap method of getting the kth largest sum and theorized that duplicate values might be gumming the works (if the current sum is equal to the top of the heap then it won't get inserted even if it is part of the k largest sums).\n\nSo I switched over to the fast partition method and guess what? Identical answer!\nhttps://leetcode.com/problems/kth-largest-sum-in-a-binary-tree/submissions/943069088/"
                    },
                    {
                        "username": "santoshkumar15841",
                        "content": "simple level order traversal\\n\\nclass Solution {\\npublic:\\n    long long kthLargestLevelSum(TreeNode* root, int k) {\\n        \\n        queue<TreeNode*> q;\\n        q.push(root);\\n\\n        vector<long long> lvlsum;\\n\\n        while(!q.empty()){\\n\\n            long long sum = 0;\\n            int size = q.size();\\n\\n            for(int  i = 0; i < size; i++){\\n\\n                TreeNode* temp = q.front();\\n                q.pop();\\n\\n                sum += temp -> val;\\n                if(temp -> left) q.push(temp -> left);\\n                if(temp -> right) q.push(temp -> right);\\n            }\\n\\n            lvlsum.push_back(sum);\\n        }\\n        sort(lvlsum.begin(), lvlsum.end(), greater<long long>());\\n\\n        if(lvlsum.size() < k){\\n            return -1;\\n        }\\n\\n        return lvlsum[k-1];\\n    }\\n};"
                    },
                    {
                        "username": "nkarthik3092",
                        "content": "I am attempting to solve this problem using C++. I notice that the size of an uninitialized vector is set to an arbitrarily large number, whereas it should be zero based on the C++ standard. May I know why this is the case?"
                    },
                    {
                        "username": "palkeshjain06",
                        "content": "Why is this question tagged with binary search ?Anyone solved using binary search  in contest ?"
                    },
                    {
                        "username": "utkarsh_2237",
                        "content": "Could anyone please explain why this code is failing\n```\n#define ll long long int\nclass Solution {\npublic:\n    long long kthLargestLevelSum(TreeNode* root, int k) {\n        queue<TreeNode*>q;\n        q.push(root);\n        vector<ll>ans;\n        while(q.size()){\n            ll sum=0;\n            int c=q.size();\n            for(int i=0;i<c;i++){\n                TreeNode* f=q.front();\n                if(f->left)q.push(f->left);\n                if(f->right)q.push(f->right);\n                sum+=f->val;\n                q.pop();\n            }\n            ans.push_back(sum);\n        }\n        int n=ans.size();\n        if(n<k)return -1;\n        sort(ans.begin(),ans.end(),greater<int>());\n        if(ans.size()<k)return -1;\n        return ans[k-1];\n    }\n};\n```"
                    },
                    {
                        "username": "UVSinghK",
                        "content": "[@utkarsh_2237](/utkarsh_2237) No worries Bro\\uD83D\\uDE00"
                    },
                    {
                        "username": "utkarsh_2237",
                        "content": "actually i got it\nI should have used this\n```\ngreater<long long int>() in sort function\ninstead of greater<int>()\n```\n\n"
                    },
                    {
                        "username": "utkarsh_2237",
                        "content": "[@UVSinghK](/UVSinghK) \\nthank you so much\\nfor replying"
                    },
                    {
                        "username": "UVSinghK",
                        "content": "You poped element from q after pushing left and right elements if exists, pop it just after retrieving the front element;"
                    },
                    {
                        "username": "aeroabrar_31",
                        "content": "Simple BFS and clean code in java \\uD83D\\uDC47\\uD83C\\uDFFB\\n\\nhttps://leetcode.com/problems/kth-largest-sum-in-a-binary-tree/solutions/3258164/simple-bfs-clean-code-well-explained/?orderBy=most_votes"
                    }
                ]
            },
            {
                "id": 1879067,
                "content": [
                    {
                        "username": "aeroabrar_31",
                        "content": "Who all got a penalty for not taking the return -1 condition into consideration ? \\uD83D\\uDE02"
                    },
                    {
                        "username": "larachicharo",
                        "content": "This problem should be marked as easy."
                    },
                    {
                        "username": "KOCMOHABT",
                        "content": "Pls, add more examples next time or make description is more clear. k_th largest sum was very unclear for me. Should it be largest level sum from first k levels, or should it be the largest sum from last levels after k_th level.\\nBut it turns out that it was necessary to find the k_th sum in ascending order. Why didn\\'t you write it like that?"
                    },
                    {
                        "username": "mochiball",
                        "content": "Easy level question "
                    },
                    {
                        "username": "psionl0",
                        "content": "44 of 45 test cases passed. But the 45th test case returned the wrong answer. Unfortunately, the 45th test case has such a massive tree (with massive numbers) that I can't trace through the code to see what went wrong. My algorithm must be sound or else a lot fewer than 44 test cases would have passed.\n\nWhat to do?\nhttps://leetcode.com/problems/kth-largest-sum-in-a-binary-tree/submissions/942514722/\n\nEDIT\nI am officially out of ideas. I had been using the min-heap method of getting the kth largest sum and theorized that duplicate values might be gumming the works (if the current sum is equal to the top of the heap then it won't get inserted even if it is part of the k largest sums).\n\nSo I switched over to the fast partition method and guess what? Identical answer!\nhttps://leetcode.com/problems/kth-largest-sum-in-a-binary-tree/submissions/943069088/"
                    },
                    {
                        "username": "santoshkumar15841",
                        "content": "simple level order traversal\\n\\nclass Solution {\\npublic:\\n    long long kthLargestLevelSum(TreeNode* root, int k) {\\n        \\n        queue<TreeNode*> q;\\n        q.push(root);\\n\\n        vector<long long> lvlsum;\\n\\n        while(!q.empty()){\\n\\n            long long sum = 0;\\n            int size = q.size();\\n\\n            for(int  i = 0; i < size; i++){\\n\\n                TreeNode* temp = q.front();\\n                q.pop();\\n\\n                sum += temp -> val;\\n                if(temp -> left) q.push(temp -> left);\\n                if(temp -> right) q.push(temp -> right);\\n            }\\n\\n            lvlsum.push_back(sum);\\n        }\\n        sort(lvlsum.begin(), lvlsum.end(), greater<long long>());\\n\\n        if(lvlsum.size() < k){\\n            return -1;\\n        }\\n\\n        return lvlsum[k-1];\\n    }\\n};"
                    },
                    {
                        "username": "nkarthik3092",
                        "content": "I am attempting to solve this problem using C++. I notice that the size of an uninitialized vector is set to an arbitrarily large number, whereas it should be zero based on the C++ standard. May I know why this is the case?"
                    },
                    {
                        "username": "palkeshjain06",
                        "content": "Why is this question tagged with binary search ?Anyone solved using binary search  in contest ?"
                    },
                    {
                        "username": "utkarsh_2237",
                        "content": "Could anyone please explain why this code is failing\n```\n#define ll long long int\nclass Solution {\npublic:\n    long long kthLargestLevelSum(TreeNode* root, int k) {\n        queue<TreeNode*>q;\n        q.push(root);\n        vector<ll>ans;\n        while(q.size()){\n            ll sum=0;\n            int c=q.size();\n            for(int i=0;i<c;i++){\n                TreeNode* f=q.front();\n                if(f->left)q.push(f->left);\n                if(f->right)q.push(f->right);\n                sum+=f->val;\n                q.pop();\n            }\n            ans.push_back(sum);\n        }\n        int n=ans.size();\n        if(n<k)return -1;\n        sort(ans.begin(),ans.end(),greater<int>());\n        if(ans.size()<k)return -1;\n        return ans[k-1];\n    }\n};\n```"
                    },
                    {
                        "username": "UVSinghK",
                        "content": "[@utkarsh_2237](/utkarsh_2237) No worries Bro\\uD83D\\uDE00"
                    },
                    {
                        "username": "utkarsh_2237",
                        "content": "actually i got it\nI should have used this\n```\ngreater<long long int>() in sort function\ninstead of greater<int>()\n```\n\n"
                    },
                    {
                        "username": "utkarsh_2237",
                        "content": "[@UVSinghK](/UVSinghK) \\nthank you so much\\nfor replying"
                    },
                    {
                        "username": "UVSinghK",
                        "content": "You poped element from q after pushing left and right elements if exists, pop it just after retrieving the front element;"
                    },
                    {
                        "username": "aeroabrar_31",
                        "content": "Simple BFS and clean code in java \\uD83D\\uDC47\\uD83C\\uDFFB\\n\\nhttps://leetcode.com/problems/kth-largest-sum-in-a-binary-tree/solutions/3258164/simple-bfs-clean-code-well-explained/?orderBy=most_votes"
                    }
                ]
            },
            {
                "id": 1850047,
                "content": [
                    {
                        "username": "aeroabrar_31",
                        "content": "Who all got a penalty for not taking the return -1 condition into consideration ? \\uD83D\\uDE02"
                    },
                    {
                        "username": "larachicharo",
                        "content": "This problem should be marked as easy."
                    },
                    {
                        "username": "KOCMOHABT",
                        "content": "Pls, add more examples next time or make description is more clear. k_th largest sum was very unclear for me. Should it be largest level sum from first k levels, or should it be the largest sum from last levels after k_th level.\\nBut it turns out that it was necessary to find the k_th sum in ascending order. Why didn\\'t you write it like that?"
                    },
                    {
                        "username": "mochiball",
                        "content": "Easy level question "
                    },
                    {
                        "username": "psionl0",
                        "content": "44 of 45 test cases passed. But the 45th test case returned the wrong answer. Unfortunately, the 45th test case has such a massive tree (with massive numbers) that I can't trace through the code to see what went wrong. My algorithm must be sound or else a lot fewer than 44 test cases would have passed.\n\nWhat to do?\nhttps://leetcode.com/problems/kth-largest-sum-in-a-binary-tree/submissions/942514722/\n\nEDIT\nI am officially out of ideas. I had been using the min-heap method of getting the kth largest sum and theorized that duplicate values might be gumming the works (if the current sum is equal to the top of the heap then it won't get inserted even if it is part of the k largest sums).\n\nSo I switched over to the fast partition method and guess what? Identical answer!\nhttps://leetcode.com/problems/kth-largest-sum-in-a-binary-tree/submissions/943069088/"
                    },
                    {
                        "username": "santoshkumar15841",
                        "content": "simple level order traversal\\n\\nclass Solution {\\npublic:\\n    long long kthLargestLevelSum(TreeNode* root, int k) {\\n        \\n        queue<TreeNode*> q;\\n        q.push(root);\\n\\n        vector<long long> lvlsum;\\n\\n        while(!q.empty()){\\n\\n            long long sum = 0;\\n            int size = q.size();\\n\\n            for(int  i = 0; i < size; i++){\\n\\n                TreeNode* temp = q.front();\\n                q.pop();\\n\\n                sum += temp -> val;\\n                if(temp -> left) q.push(temp -> left);\\n                if(temp -> right) q.push(temp -> right);\\n            }\\n\\n            lvlsum.push_back(sum);\\n        }\\n        sort(lvlsum.begin(), lvlsum.end(), greater<long long>());\\n\\n        if(lvlsum.size() < k){\\n            return -1;\\n        }\\n\\n        return lvlsum[k-1];\\n    }\\n};"
                    },
                    {
                        "username": "nkarthik3092",
                        "content": "I am attempting to solve this problem using C++. I notice that the size of an uninitialized vector is set to an arbitrarily large number, whereas it should be zero based on the C++ standard. May I know why this is the case?"
                    },
                    {
                        "username": "palkeshjain06",
                        "content": "Why is this question tagged with binary search ?Anyone solved using binary search  in contest ?"
                    },
                    {
                        "username": "utkarsh_2237",
                        "content": "Could anyone please explain why this code is failing\n```\n#define ll long long int\nclass Solution {\npublic:\n    long long kthLargestLevelSum(TreeNode* root, int k) {\n        queue<TreeNode*>q;\n        q.push(root);\n        vector<ll>ans;\n        while(q.size()){\n            ll sum=0;\n            int c=q.size();\n            for(int i=0;i<c;i++){\n                TreeNode* f=q.front();\n                if(f->left)q.push(f->left);\n                if(f->right)q.push(f->right);\n                sum+=f->val;\n                q.pop();\n            }\n            ans.push_back(sum);\n        }\n        int n=ans.size();\n        if(n<k)return -1;\n        sort(ans.begin(),ans.end(),greater<int>());\n        if(ans.size()<k)return -1;\n        return ans[k-1];\n    }\n};\n```"
                    },
                    {
                        "username": "UVSinghK",
                        "content": "[@utkarsh_2237](/utkarsh_2237) No worries Bro\\uD83D\\uDE00"
                    },
                    {
                        "username": "utkarsh_2237",
                        "content": "actually i got it\nI should have used this\n```\ngreater<long long int>() in sort function\ninstead of greater<int>()\n```\n\n"
                    },
                    {
                        "username": "utkarsh_2237",
                        "content": "[@UVSinghK](/UVSinghK) \\nthank you so much\\nfor replying"
                    },
                    {
                        "username": "UVSinghK",
                        "content": "You poped element from q after pushing left and right elements if exists, pop it just after retrieving the front element;"
                    },
                    {
                        "username": "aeroabrar_31",
                        "content": "Simple BFS and clean code in java \\uD83D\\uDC47\\uD83C\\uDFFB\\n\\nhttps://leetcode.com/problems/kth-largest-sum-in-a-binary-tree/solutions/3258164/simple-bfs-clean-code-well-explained/?orderBy=most_votes"
                    }
                ]
            },
            {
                "id": 1825688,
                "content": [
                    {
                        "username": "aeroabrar_31",
                        "content": "Who all got a penalty for not taking the return -1 condition into consideration ? \\uD83D\\uDE02"
                    },
                    {
                        "username": "larachicharo",
                        "content": "This problem should be marked as easy."
                    },
                    {
                        "username": "KOCMOHABT",
                        "content": "Pls, add more examples next time or make description is more clear. k_th largest sum was very unclear for me. Should it be largest level sum from first k levels, or should it be the largest sum from last levels after k_th level.\\nBut it turns out that it was necessary to find the k_th sum in ascending order. Why didn\\'t you write it like that?"
                    },
                    {
                        "username": "mochiball",
                        "content": "Easy level question "
                    },
                    {
                        "username": "psionl0",
                        "content": "44 of 45 test cases passed. But the 45th test case returned the wrong answer. Unfortunately, the 45th test case has such a massive tree (with massive numbers) that I can't trace through the code to see what went wrong. My algorithm must be sound or else a lot fewer than 44 test cases would have passed.\n\nWhat to do?\nhttps://leetcode.com/problems/kth-largest-sum-in-a-binary-tree/submissions/942514722/\n\nEDIT\nI am officially out of ideas. I had been using the min-heap method of getting the kth largest sum and theorized that duplicate values might be gumming the works (if the current sum is equal to the top of the heap then it won't get inserted even if it is part of the k largest sums).\n\nSo I switched over to the fast partition method and guess what? Identical answer!\nhttps://leetcode.com/problems/kth-largest-sum-in-a-binary-tree/submissions/943069088/"
                    },
                    {
                        "username": "santoshkumar15841",
                        "content": "simple level order traversal\\n\\nclass Solution {\\npublic:\\n    long long kthLargestLevelSum(TreeNode* root, int k) {\\n        \\n        queue<TreeNode*> q;\\n        q.push(root);\\n\\n        vector<long long> lvlsum;\\n\\n        while(!q.empty()){\\n\\n            long long sum = 0;\\n            int size = q.size();\\n\\n            for(int  i = 0; i < size; i++){\\n\\n                TreeNode* temp = q.front();\\n                q.pop();\\n\\n                sum += temp -> val;\\n                if(temp -> left) q.push(temp -> left);\\n                if(temp -> right) q.push(temp -> right);\\n            }\\n\\n            lvlsum.push_back(sum);\\n        }\\n        sort(lvlsum.begin(), lvlsum.end(), greater<long long>());\\n\\n        if(lvlsum.size() < k){\\n            return -1;\\n        }\\n\\n        return lvlsum[k-1];\\n    }\\n};"
                    },
                    {
                        "username": "nkarthik3092",
                        "content": "I am attempting to solve this problem using C++. I notice that the size of an uninitialized vector is set to an arbitrarily large number, whereas it should be zero based on the C++ standard. May I know why this is the case?"
                    },
                    {
                        "username": "palkeshjain06",
                        "content": "Why is this question tagged with binary search ?Anyone solved using binary search  in contest ?"
                    },
                    {
                        "username": "utkarsh_2237",
                        "content": "Could anyone please explain why this code is failing\n```\n#define ll long long int\nclass Solution {\npublic:\n    long long kthLargestLevelSum(TreeNode* root, int k) {\n        queue<TreeNode*>q;\n        q.push(root);\n        vector<ll>ans;\n        while(q.size()){\n            ll sum=0;\n            int c=q.size();\n            for(int i=0;i<c;i++){\n                TreeNode* f=q.front();\n                if(f->left)q.push(f->left);\n                if(f->right)q.push(f->right);\n                sum+=f->val;\n                q.pop();\n            }\n            ans.push_back(sum);\n        }\n        int n=ans.size();\n        if(n<k)return -1;\n        sort(ans.begin(),ans.end(),greater<int>());\n        if(ans.size()<k)return -1;\n        return ans[k-1];\n    }\n};\n```"
                    },
                    {
                        "username": "UVSinghK",
                        "content": "[@utkarsh_2237](/utkarsh_2237) No worries Bro\\uD83D\\uDE00"
                    },
                    {
                        "username": "utkarsh_2237",
                        "content": "actually i got it\nI should have used this\n```\ngreater<long long int>() in sort function\ninstead of greater<int>()\n```\n\n"
                    },
                    {
                        "username": "utkarsh_2237",
                        "content": "[@UVSinghK](/UVSinghK) \\nthank you so much\\nfor replying"
                    },
                    {
                        "username": "UVSinghK",
                        "content": "You poped element from q after pushing left and right elements if exists, pop it just after retrieving the front element;"
                    },
                    {
                        "username": "aeroabrar_31",
                        "content": "Simple BFS and clean code in java \\uD83D\\uDC47\\uD83C\\uDFFB\\n\\nhttps://leetcode.com/problems/kth-largest-sum-in-a-binary-tree/solutions/3258164/simple-bfs-clean-code-well-explained/?orderBy=most_votes"
                    }
                ]
            },
            {
                "id": 1825104,
                "content": [
                    {
                        "username": "aeroabrar_31",
                        "content": "Who all got a penalty for not taking the return -1 condition into consideration ? \\uD83D\\uDE02"
                    },
                    {
                        "username": "larachicharo",
                        "content": "This problem should be marked as easy."
                    },
                    {
                        "username": "KOCMOHABT",
                        "content": "Pls, add more examples next time or make description is more clear. k_th largest sum was very unclear for me. Should it be largest level sum from first k levels, or should it be the largest sum from last levels after k_th level.\\nBut it turns out that it was necessary to find the k_th sum in ascending order. Why didn\\'t you write it like that?"
                    },
                    {
                        "username": "mochiball",
                        "content": "Easy level question "
                    },
                    {
                        "username": "psionl0",
                        "content": "44 of 45 test cases passed. But the 45th test case returned the wrong answer. Unfortunately, the 45th test case has such a massive tree (with massive numbers) that I can't trace through the code to see what went wrong. My algorithm must be sound or else a lot fewer than 44 test cases would have passed.\n\nWhat to do?\nhttps://leetcode.com/problems/kth-largest-sum-in-a-binary-tree/submissions/942514722/\n\nEDIT\nI am officially out of ideas. I had been using the min-heap method of getting the kth largest sum and theorized that duplicate values might be gumming the works (if the current sum is equal to the top of the heap then it won't get inserted even if it is part of the k largest sums).\n\nSo I switched over to the fast partition method and guess what? Identical answer!\nhttps://leetcode.com/problems/kth-largest-sum-in-a-binary-tree/submissions/943069088/"
                    },
                    {
                        "username": "santoshkumar15841",
                        "content": "simple level order traversal\\n\\nclass Solution {\\npublic:\\n    long long kthLargestLevelSum(TreeNode* root, int k) {\\n        \\n        queue<TreeNode*> q;\\n        q.push(root);\\n\\n        vector<long long> lvlsum;\\n\\n        while(!q.empty()){\\n\\n            long long sum = 0;\\n            int size = q.size();\\n\\n            for(int  i = 0; i < size; i++){\\n\\n                TreeNode* temp = q.front();\\n                q.pop();\\n\\n                sum += temp -> val;\\n                if(temp -> left) q.push(temp -> left);\\n                if(temp -> right) q.push(temp -> right);\\n            }\\n\\n            lvlsum.push_back(sum);\\n        }\\n        sort(lvlsum.begin(), lvlsum.end(), greater<long long>());\\n\\n        if(lvlsum.size() < k){\\n            return -1;\\n        }\\n\\n        return lvlsum[k-1];\\n    }\\n};"
                    },
                    {
                        "username": "nkarthik3092",
                        "content": "I am attempting to solve this problem using C++. I notice that the size of an uninitialized vector is set to an arbitrarily large number, whereas it should be zero based on the C++ standard. May I know why this is the case?"
                    },
                    {
                        "username": "palkeshjain06",
                        "content": "Why is this question tagged with binary search ?Anyone solved using binary search  in contest ?"
                    },
                    {
                        "username": "utkarsh_2237",
                        "content": "Could anyone please explain why this code is failing\n```\n#define ll long long int\nclass Solution {\npublic:\n    long long kthLargestLevelSum(TreeNode* root, int k) {\n        queue<TreeNode*>q;\n        q.push(root);\n        vector<ll>ans;\n        while(q.size()){\n            ll sum=0;\n            int c=q.size();\n            for(int i=0;i<c;i++){\n                TreeNode* f=q.front();\n                if(f->left)q.push(f->left);\n                if(f->right)q.push(f->right);\n                sum+=f->val;\n                q.pop();\n            }\n            ans.push_back(sum);\n        }\n        int n=ans.size();\n        if(n<k)return -1;\n        sort(ans.begin(),ans.end(),greater<int>());\n        if(ans.size()<k)return -1;\n        return ans[k-1];\n    }\n};\n```"
                    },
                    {
                        "username": "UVSinghK",
                        "content": "[@utkarsh_2237](/utkarsh_2237) No worries Bro\\uD83D\\uDE00"
                    },
                    {
                        "username": "utkarsh_2237",
                        "content": "actually i got it\nI should have used this\n```\ngreater<long long int>() in sort function\ninstead of greater<int>()\n```\n\n"
                    },
                    {
                        "username": "utkarsh_2237",
                        "content": "[@UVSinghK](/UVSinghK) \\nthank you so much\\nfor replying"
                    },
                    {
                        "username": "UVSinghK",
                        "content": "You poped element from q after pushing left and right elements if exists, pop it just after retrieving the front element;"
                    },
                    {
                        "username": "aeroabrar_31",
                        "content": "Simple BFS and clean code in java \\uD83D\\uDC47\\uD83C\\uDFFB\\n\\nhttps://leetcode.com/problems/kth-largest-sum-in-a-binary-tree/solutions/3258164/simple-bfs-clean-code-well-explained/?orderBy=most_votes"
                    }
                ]
            },
            {
                "id": 1822419,
                "content": [
                    {
                        "username": "aeroabrar_31",
                        "content": "Who all got a penalty for not taking the return -1 condition into consideration ? \\uD83D\\uDE02"
                    },
                    {
                        "username": "larachicharo",
                        "content": "This problem should be marked as easy."
                    },
                    {
                        "username": "KOCMOHABT",
                        "content": "Pls, add more examples next time or make description is more clear. k_th largest sum was very unclear for me. Should it be largest level sum from first k levels, or should it be the largest sum from last levels after k_th level.\\nBut it turns out that it was necessary to find the k_th sum in ascending order. Why didn\\'t you write it like that?"
                    },
                    {
                        "username": "mochiball",
                        "content": "Easy level question "
                    },
                    {
                        "username": "psionl0",
                        "content": "44 of 45 test cases passed. But the 45th test case returned the wrong answer. Unfortunately, the 45th test case has such a massive tree (with massive numbers) that I can't trace through the code to see what went wrong. My algorithm must be sound or else a lot fewer than 44 test cases would have passed.\n\nWhat to do?\nhttps://leetcode.com/problems/kth-largest-sum-in-a-binary-tree/submissions/942514722/\n\nEDIT\nI am officially out of ideas. I had been using the min-heap method of getting the kth largest sum and theorized that duplicate values might be gumming the works (if the current sum is equal to the top of the heap then it won't get inserted even if it is part of the k largest sums).\n\nSo I switched over to the fast partition method and guess what? Identical answer!\nhttps://leetcode.com/problems/kth-largest-sum-in-a-binary-tree/submissions/943069088/"
                    },
                    {
                        "username": "santoshkumar15841",
                        "content": "simple level order traversal\\n\\nclass Solution {\\npublic:\\n    long long kthLargestLevelSum(TreeNode* root, int k) {\\n        \\n        queue<TreeNode*> q;\\n        q.push(root);\\n\\n        vector<long long> lvlsum;\\n\\n        while(!q.empty()){\\n\\n            long long sum = 0;\\n            int size = q.size();\\n\\n            for(int  i = 0; i < size; i++){\\n\\n                TreeNode* temp = q.front();\\n                q.pop();\\n\\n                sum += temp -> val;\\n                if(temp -> left) q.push(temp -> left);\\n                if(temp -> right) q.push(temp -> right);\\n            }\\n\\n            lvlsum.push_back(sum);\\n        }\\n        sort(lvlsum.begin(), lvlsum.end(), greater<long long>());\\n\\n        if(lvlsum.size() < k){\\n            return -1;\\n        }\\n\\n        return lvlsum[k-1];\\n    }\\n};"
                    },
                    {
                        "username": "nkarthik3092",
                        "content": "I am attempting to solve this problem using C++. I notice that the size of an uninitialized vector is set to an arbitrarily large number, whereas it should be zero based on the C++ standard. May I know why this is the case?"
                    },
                    {
                        "username": "palkeshjain06",
                        "content": "Why is this question tagged with binary search ?Anyone solved using binary search  in contest ?"
                    },
                    {
                        "username": "utkarsh_2237",
                        "content": "Could anyone please explain why this code is failing\n```\n#define ll long long int\nclass Solution {\npublic:\n    long long kthLargestLevelSum(TreeNode* root, int k) {\n        queue<TreeNode*>q;\n        q.push(root);\n        vector<ll>ans;\n        while(q.size()){\n            ll sum=0;\n            int c=q.size();\n            for(int i=0;i<c;i++){\n                TreeNode* f=q.front();\n                if(f->left)q.push(f->left);\n                if(f->right)q.push(f->right);\n                sum+=f->val;\n                q.pop();\n            }\n            ans.push_back(sum);\n        }\n        int n=ans.size();\n        if(n<k)return -1;\n        sort(ans.begin(),ans.end(),greater<int>());\n        if(ans.size()<k)return -1;\n        return ans[k-1];\n    }\n};\n```"
                    },
                    {
                        "username": "UVSinghK",
                        "content": "[@utkarsh_2237](/utkarsh_2237) No worries Bro\\uD83D\\uDE00"
                    },
                    {
                        "username": "utkarsh_2237",
                        "content": "actually i got it\nI should have used this\n```\ngreater<long long int>() in sort function\ninstead of greater<int>()\n```\n\n"
                    },
                    {
                        "username": "utkarsh_2237",
                        "content": "[@UVSinghK](/UVSinghK) \\nthank you so much\\nfor replying"
                    },
                    {
                        "username": "UVSinghK",
                        "content": "You poped element from q after pushing left and right elements if exists, pop it just after retrieving the front element;"
                    },
                    {
                        "username": "aeroabrar_31",
                        "content": "Simple BFS and clean code in java \\uD83D\\uDC47\\uD83C\\uDFFB\\n\\nhttps://leetcode.com/problems/kth-largest-sum-in-a-binary-tree/solutions/3258164/simple-bfs-clean-code-well-explained/?orderBy=most_votes"
                    }
                ]
            },
            {
                "id": 1822300,
                "content": [
                    {
                        "username": "aeroabrar_31",
                        "content": "Who all got a penalty for not taking the return -1 condition into consideration ? \\uD83D\\uDE02"
                    },
                    {
                        "username": "larachicharo",
                        "content": "This problem should be marked as easy."
                    },
                    {
                        "username": "KOCMOHABT",
                        "content": "Pls, add more examples next time or make description is more clear. k_th largest sum was very unclear for me. Should it be largest level sum from first k levels, or should it be the largest sum from last levels after k_th level.\\nBut it turns out that it was necessary to find the k_th sum in ascending order. Why didn\\'t you write it like that?"
                    },
                    {
                        "username": "mochiball",
                        "content": "Easy level question "
                    },
                    {
                        "username": "psionl0",
                        "content": "44 of 45 test cases passed. But the 45th test case returned the wrong answer. Unfortunately, the 45th test case has such a massive tree (with massive numbers) that I can't trace through the code to see what went wrong. My algorithm must be sound or else a lot fewer than 44 test cases would have passed.\n\nWhat to do?\nhttps://leetcode.com/problems/kth-largest-sum-in-a-binary-tree/submissions/942514722/\n\nEDIT\nI am officially out of ideas. I had been using the min-heap method of getting the kth largest sum and theorized that duplicate values might be gumming the works (if the current sum is equal to the top of the heap then it won't get inserted even if it is part of the k largest sums).\n\nSo I switched over to the fast partition method and guess what? Identical answer!\nhttps://leetcode.com/problems/kth-largest-sum-in-a-binary-tree/submissions/943069088/"
                    },
                    {
                        "username": "santoshkumar15841",
                        "content": "simple level order traversal\\n\\nclass Solution {\\npublic:\\n    long long kthLargestLevelSum(TreeNode* root, int k) {\\n        \\n        queue<TreeNode*> q;\\n        q.push(root);\\n\\n        vector<long long> lvlsum;\\n\\n        while(!q.empty()){\\n\\n            long long sum = 0;\\n            int size = q.size();\\n\\n            for(int  i = 0; i < size; i++){\\n\\n                TreeNode* temp = q.front();\\n                q.pop();\\n\\n                sum += temp -> val;\\n                if(temp -> left) q.push(temp -> left);\\n                if(temp -> right) q.push(temp -> right);\\n            }\\n\\n            lvlsum.push_back(sum);\\n        }\\n        sort(lvlsum.begin(), lvlsum.end(), greater<long long>());\\n\\n        if(lvlsum.size() < k){\\n            return -1;\\n        }\\n\\n        return lvlsum[k-1];\\n    }\\n};"
                    },
                    {
                        "username": "nkarthik3092",
                        "content": "I am attempting to solve this problem using C++. I notice that the size of an uninitialized vector is set to an arbitrarily large number, whereas it should be zero based on the C++ standard. May I know why this is the case?"
                    },
                    {
                        "username": "palkeshjain06",
                        "content": "Why is this question tagged with binary search ?Anyone solved using binary search  in contest ?"
                    },
                    {
                        "username": "utkarsh_2237",
                        "content": "Could anyone please explain why this code is failing\n```\n#define ll long long int\nclass Solution {\npublic:\n    long long kthLargestLevelSum(TreeNode* root, int k) {\n        queue<TreeNode*>q;\n        q.push(root);\n        vector<ll>ans;\n        while(q.size()){\n            ll sum=0;\n            int c=q.size();\n            for(int i=0;i<c;i++){\n                TreeNode* f=q.front();\n                if(f->left)q.push(f->left);\n                if(f->right)q.push(f->right);\n                sum+=f->val;\n                q.pop();\n            }\n            ans.push_back(sum);\n        }\n        int n=ans.size();\n        if(n<k)return -1;\n        sort(ans.begin(),ans.end(),greater<int>());\n        if(ans.size()<k)return -1;\n        return ans[k-1];\n    }\n};\n```"
                    },
                    {
                        "username": "UVSinghK",
                        "content": "[@utkarsh_2237](/utkarsh_2237) No worries Bro\\uD83D\\uDE00"
                    },
                    {
                        "username": "utkarsh_2237",
                        "content": "actually i got it\nI should have used this\n```\ngreater<long long int>() in sort function\ninstead of greater<int>()\n```\n\n"
                    },
                    {
                        "username": "utkarsh_2237",
                        "content": "[@UVSinghK](/UVSinghK) \\nthank you so much\\nfor replying"
                    },
                    {
                        "username": "UVSinghK",
                        "content": "You poped element from q after pushing left and right elements if exists, pop it just after retrieving the front element;"
                    },
                    {
                        "username": "aeroabrar_31",
                        "content": "Simple BFS and clean code in java \\uD83D\\uDC47\\uD83C\\uDFFB\\n\\nhttps://leetcode.com/problems/kth-largest-sum-in-a-binary-tree/solutions/3258164/simple-bfs-clean-code-well-explained/?orderBy=most_votes"
                    }
                ]
            }
        ]
    }
]