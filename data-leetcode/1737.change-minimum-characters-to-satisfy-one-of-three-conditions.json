[
    {
        "title": "Change Minimum Characters to Satisfy One of Three Conditions",
        "question_content": "You are given two strings a and b that consist of lowercase letters. In one operation, you can change any character in a or b to any lowercase letter.\nYour goal is to satisfy one of the following three conditions:\n\n\tEvery letter in a is strictly less than every letter in b in the alphabet.\n\tEvery letter in b is strictly less than every letter in a in the alphabet.\n\tBoth a and b consist of only one distinct letter.\n\nReturn the minimum number of operations needed to achieve your goal.\n&nbsp;\nExample 1:\n\nInput: a = \"aba\", b = \"caa\"\nOutput: 2\nExplanation: Consider the best way to make each condition true:\n1) Change b to \"ccc\" in 2 operations, then every letter in a is less than every letter in b.\n2) Change a to \"bbb\" and b to \"aaa\" in 3 operations, then every letter in b is less than every letter in a.\n3) Change a to \"aaa\" and b to \"aaa\" in 2 operations, then a and b consist of one distinct letter.\nThe best way was done in 2 operations (either condition 1 or condition 3).\n\nExample 2:\n\nInput: a = \"dabadd\", b = \"cda\"\nOutput: 3\nExplanation: The best way is to make condition 1 true by changing b to \"eee\".\n\n&nbsp;\nConstraints:\n\n\t1 <= a.length, b.length <= 105\n\ta and b consist only of lowercase letters.",
        "solutions": [
            {
                "id": 1032070,
                "title": "java-c-python-clean-solution",
                "content": "# Explanation\\nCount the frequcy of each character in `a` and `b`.\\nFind the most common characters `most_common = max((c1 + c2).values())`,\\nthis help meet the condition 3 with `m + n - most_common`.\\n\\nThe we calculate the accumulate prefix sum of `count`.\\nThis help finding the number of smaller characters in `O(1)` time.\\n\\nEnumerate the character `i` a,b,c...x,y,\\nTo meet condition 1,\\nwhich is a < b,\\nwe need `(m - c1[i]) + c2[i]`\\n\\nTo meet condition 2,\\nwhich is a > b,\\nwe need `n - c2[i] + c1[i]`\\n<br>\\n\\n# **Complexity**\\nTime `O(m + n)`\\nSpace `O(26)`\\n<br>\\n\\n**Java**\\n```java\\n    public int minCharacters(String a, String b) {\\n        int m = a.length(), n = b.length(), res = m + n;\\n        int[] c1 = new int[26], c2 = new int[26];\\n        for (int i = 0; i < m; ++i)\\n            c1[a.charAt(i) - \\'a\\']++;\\n        for (int i = 0; i < n; ++i)\\n            c2[b.charAt(i) - \\'a\\']++;\\n\\n        for (int i = 0; i < 26; ++i) {\\n            res = Math.min(res, m + n - c1[i] - c2[i]); // condition 3\\n            if (i > 0) {\\n                c1[i] += c1[i - 1];\\n                c2[i] += c2[i - 1];\\n            }\\n            if (i < 25) {\\n                res = Math.min(res, m - c1[i] + c2[i]); // condition 1\\n                res = Math.min(res, n - c2[i] + c1[i]); // condition 2\\n            }\\n        }\\n        return res;\\n    }\\n```\\n**C++**\\n```cpp\\n    int minCharacters(string a, string b) {\\n        int m = a.size(), n = b.size(), res = m + n;\\n        vector<int> c1(26), c2(26);\\n        for (char& c: a) c1[c - \\'a\\']++;\\n        for (char& c: b) c2[c - \\'a\\']++;\\n\\n        for (int i = 0; i < 26; ++i) {\\n            res = min(res, m + n - c1[i] - c2[i]); // condition 3\\n            if (i > 0) {\\n                c1[i] += c1[i - 1];\\n                c2[i] += c2[i - 1];\\n            }\\n            if (i < 25) {\\n                res = min(res, m - c1[i] + c2[i]); // condition 1\\n                res = min(res, n - c2[i] + c1[i]); // condition 2\\n            }\\n        }\\n        return res;\\n    }\\n```\\n**Python3**\\n```py\\n    def minCharacters(self, a, b):\\n        m, n = len(a), len(b)\\n        c1 = Counter(ord(c) - 97 for c in a)\\n        c2 = Counter(ord(c) - 97 for c in b)\\n        res = m + n - max((c1 + c2).values()) # condition 3\\n        for i in range(25):\\n            c1[i + 1] += c1[i]\\n            c2[i + 1] += c2[i]\\n            res = min(res, m - c1[i] + c2[i]) # condition 1\\n            res = min(res, n - c2[i] + c1[i]) # condition 2\\n        return res\\n```\\n",
                "solutionTags": [],
                "code": "```java\\n    public int minCharacters(String a, String b) {\\n        int m = a.length(), n = b.length(), res = m + n;\\n        int[] c1 = new int[26], c2 = new int[26];\\n        for (int i = 0; i < m; ++i)\\n            c1[a.charAt(i) - \\'a\\']++;\\n        for (int i = 0; i < n; ++i)\\n            c2[b.charAt(i) - \\'a\\']++;\\n\\n        for (int i = 0; i < 26; ++i) {\\n            res = Math.min(res, m + n - c1[i] - c2[i]); // condition 3\\n            if (i > 0) {\\n                c1[i] += c1[i - 1];\\n                c2[i] += c2[i - 1];\\n            }\\n            if (i < 25) {\\n                res = Math.min(res, m - c1[i] + c2[i]); // condition 1\\n                res = Math.min(res, n - c2[i] + c1[i]); // condition 2\\n            }\\n        }\\n        return res;\\n    }\\n```\n```cpp\\n    int minCharacters(string a, string b) {\\n        int m = a.size(), n = b.size(), res = m + n;\\n        vector<int> c1(26), c2(26);\\n        for (char& c: a) c1[c - \\'a\\']++;\\n        for (char& c: b) c2[c - \\'a\\']++;\\n\\n        for (int i = 0; i < 26; ++i) {\\n            res = min(res, m + n - c1[i] - c2[i]); // condition 3\\n            if (i > 0) {\\n                c1[i] += c1[i - 1];\\n                c2[i] += c2[i - 1];\\n            }\\n            if (i < 25) {\\n                res = min(res, m - c1[i] + c2[i]); // condition 1\\n                res = min(res, n - c2[i] + c1[i]); // condition 2\\n            }\\n        }\\n        return res;\\n    }\\n```\n```py\\n    def minCharacters(self, a, b):\\n        m, n = len(a), len(b)\\n        c1 = Counter(ord(c) - 97 for c in a)\\n        c2 = Counter(ord(c) - 97 for c in b)\\n        res = m + n - max((c1 + c2).values()) # condition 3\\n        for i in range(25):\\n            c1[i + 1] += c1[i]\\n            c2[i + 1] += c2[i]\\n            res = min(res, m - c1[i] + c2[i]) # condition 1\\n            res = min(res, n - c2[i] + c1[i]) # condition 2\\n        return res\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1032042,
                "title": "java-detailed-explanation-find-the-boundary-letter",
                "content": "**Key Notes:**\\n- Condition 1 and condition 2 are symmetrical, so generally we have 2 operations: **make a below b** and **make a and b only one distinct letter**.\\n- **Operation 1** => make a below b:\\n\\t- We don\\'t need to care how we make it, but **there is definately a character, which separates the string a and string b**\\n\\t- We can try this boundaray chararacter from **b to z**, and see how many steps to **make string a below it**, how many steps to **make string b above or equal it**. And just return the **smallest steps** among all boundary characters.\\n- **Operation 2** => make a and b only one distince letter:\\n\\t- We just need to count the **most frequent character of string(a + b)**\\n\\t- The operation we need to take is: a.length() + b.length() - count\\n\\n```java\\npublic int minCharacters(String a, String b) {\\n        \\n\\treturn Math.min(Math.min(operation1(a, b), operation1(b, a)), operation2(a, b));\\n}\\n\\n// operation to make a below b\\nprivate int operation1(String a, String b) {\\n\\n\\tint res = Integer.MAX_VALUE;\\n\\tfor (int i = 1; i < 26; ++i) {  // start from \\'b\\', since no char below \\'a\\'\\n\\n\\t\\tint count = 0;\\n\\t\\tfor (char c : a.toCharArray()) {\\n\\t\\t\\tif ((c - \\'a\\') >= i) ++count;\\n\\t\\t}\\n\\t\\tfor (char c : b.toCharArray()) {\\n\\t\\t\\tif ((c - \\'a\\') < i) ++count;\\n\\t\\t}\\n\\t\\tres = Math.min(res, count);\\n\\t}\\n\\n\\treturn res;\\n}\\n\\n// operation to make only one distinct letter\\nprivate int operation2(String a, String b) {\\n\\n\\tint[] A = new int[26];\\n\\tfor (char c : a.toCharArray()) A[c - \\'a\\']++;\\n\\tfor (char c : b.toCharArray()) A[c - \\'a\\']++;\\n\\n\\tint res = 0;\\n\\tfor (int i = 0; i < 26; ++i) {\\n\\t\\tres = Math.max(res, A[i]);\\n\\t}\\n\\n\\treturn a.length() + b.length() - res;\\n}\\n```",
                "solutionTags": [],
                "code": "```java\\npublic int minCharacters(String a, String b) {\\n        \\n\\treturn Math.min(Math.min(operation1(a, b), operation1(b, a)), operation2(a, b));\\n}\\n\\n// operation to make a below b\\nprivate int operation1(String a, String b) {\\n\\n\\tint res = Integer.MAX_VALUE;\\n\\tfor (int i = 1; i < 26; ++i) {  // start from \\'b\\', since no char below \\'a\\'\\n\\n\\t\\tint count = 0;\\n\\t\\tfor (char c : a.toCharArray()) {\\n\\t\\t\\tif ((c - \\'a\\') >= i) ++count;\\n\\t\\t}\\n\\t\\tfor (char c : b.toCharArray()) {\\n\\t\\t\\tif ((c - \\'a\\') < i) ++count;\\n\\t\\t}\\n\\t\\tres = Math.min(res, count);\\n\\t}\\n\\n\\treturn res;\\n}\\n\\n// operation to make only one distinct letter\\nprivate int operation2(String a, String b) {\\n\\n\\tint[] A = new int[26];\\n\\tfor (char c : a.toCharArray()) A[c - \\'a\\']++;\\n\\tfor (char c : b.toCharArray()) A[c - \\'a\\']++;\\n\\n\\tint res = 0;\\n\\tfor (int i = 0; i < 26; ++i) {\\n\\t\\tres = Math.max(res, A[i]);\\n\\t}\\n\\n\\treturn a.length() + b.length() - res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1032021,
                "title": "python-poor-question-statement",
                "content": "What does **a and b consist of only one distinct letter** mean? Does this require us to use a **UNIQUE** letter or What ?? **Please do not act like this to make us guess!**\\n\\nThere was a very useful discussion under the comment area but it has been deleted by tom0727.\\n\\nHere is the code after I figure it out from this poor problem description:\\n\\n```\\n    def minCharacters(self, a: str, b: str) -> int:\\n        def count(s):\\n            arr = [0 for i in range(26)]\\n            for c in s:\\n                arr[ord(c) - ord(\\'a\\')] += 1\\n            return arr\\n        \\n        c1 = count(a)\\n        c2 = count(b)\\n        \\n        def helper(c1, c2):\\n            res = float(\\'inf\\')\\n            moveC1 = sum(c1) # move all in c1 to be less or equal\\n            moveC2 = 0 # move all in c2 to be greater\\n            for i in range(25):\\n                moveC1 -= c1[i]\\n                moveC2 += c2[i]\\n                res = min(res, moveC1 + moveC2)\\n            return res\\n        \\n        def helper3(c1, c2):\\n            res = float(\\'inf\\')\\n            sum1 = sum(c1)\\n            sum2 = sum(c2)\\n            for i in range(26):\\n                res = min(res, sum1 - c1[i] + sum2 - c2[i])\\n            return res\\n        \\n        res1 = helper(c1, c2)\\n        res2 = helper(c2, c1)\\n        res3 = helper3(c1, c2)\\n        return min([res1, res2, res3])\\n```",
                "solutionTags": [],
                "code": "```\\n    def minCharacters(self, a: str, b: str) -> int:\\n        def count(s):\\n            arr = [0 for i in range(26)]\\n            for c in s:\\n                arr[ord(c) - ord(\\'a\\')] += 1\\n            return arr\\n        \\n        c1 = count(a)\\n        c2 = count(b)\\n        \\n        def helper(c1, c2):\\n            res = float(\\'inf\\')\\n            moveC1 = sum(c1) # move all in c1 to be less or equal\\n            moveC2 = 0 # move all in c2 to be greater\\n            for i in range(25):\\n                moveC1 -= c1[i]\\n                moveC2 += c2[i]\\n                res = min(res, moveC1 + moveC2)\\n            return res\\n        \\n        def helper3(c1, c2):\\n            res = float(\\'inf\\')\\n            sum1 = sum(c1)\\n            sum2 = sum(c2)\\n            for i in range(26):\\n                res = min(res, sum1 - c1[i] + sum2 - c2[i])\\n            return res\\n        \\n        res1 = helper(c1, c2)\\n        res2 = helper(c2, c1)\\n        res3 = helper3(c1, c2)\\n        return min([res1, res2, res3])\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1032339,
                "title": "python-draw-a-simple-graph-to-explain",
                "content": "\\nI have hard time understanding other\\'s solution by sentence, I think this graph will help you understand the apporach most people trying to make.\\n\\n![image](https://assets.leetcode.com/users/images/c5c31fc1-b8c4-42d1-9a85-615a42200686_1611468603.7580383.png)\\n\\nYou can think a to z is a stone spread on a line, from left to right. The goal is to make stones in A all become smaller than stones in B.  So, if I pick a stone (red line in the graph), to make all stones in A to be smaller than B, I will need to move all the piles on the right to red line in A (green circle on top) to left of red line, ALSO, make all the piles in B to the right of the red line.  \\n\\nSo, how do I know how many stones are in the left side of B ? ---> presum, similiarly, I will know # of stones on the red line of A pile will be  total stone - # of stones in the left.\\n\\n\\n\\n```\\ncondition_1 (ith position) = #_stone_at_right_in_A (after ith position) + #_stone_at_left_in_B\\n```\\nTherefore, by choose each stone, and count the cost of moving the left and right stones, we choose the one that is minimum. \\n\\nAs for condition 3, where all stone can only be one distinct character, because you would like to have least cost, so we choose to turn all the charaters to the one that happen most frequent.   \\n\\n```\\ncondition 3 = total - num_of_most_frequent_count\\n```\\n\\nThere is a catch in condition 1, you cant move stones in b to be on the right of z, there is no character greater than z.  Therefore, when you consider every stone as a pivot point, you should not consider z. \\n\\n![image](https://assets.leetcode.com/users/images/f3b50cd3-cb4a-43da-ba0d-cd8e63d485da_1611469328.7326813.png)\\n\\n\\nI hope this helps.\\n\\n```\\nclass Solution:\\n    def minCharacters(self, a: str, b: str) -> int:\\n        presumA = 0\\n        presumB = 0\\n        \\n        counterA = Counter([ch for ch in a])\\n        counterB = Counter([ch for ch in b])\\n        \\n        res = sys.maxsize\\n        \\n        # situation 3\\n        m = len(a)\\n        n = len(b)\\n        \\n        # possibility 1: fulfill condition 3\\n        res = min(res, m - max(counterA.values()) + n - max(counterB.values()))\\n    \\n        presumA = []\\n        sumA = 0\\n        presumB = []\\n        \\n        sumB = 0\\n        for i in range(0, 26):\\n            sumA += counterA[chr(i + 97)]\\n            presumA.append(sumA)\\n            sumB += counterB[chr(i + 97)]\\n            presumB.append(sumB)\\n            \\n        # to make every a smaller than b\\n        for i in range(0, 25):\\n            res = min(m - presumA[i] + presumB[i], res)\\n            \\n        # to make every a smaller than b    \\n        for i in range(0, 25):\\n            res = min(n - presumB[i] + presumA[i], res)\\n            \\n        return res\\n    \\n\\n```\\n\\n\\n\\n\\n",
                "solutionTags": [],
                "code": "```\\ncondition_1 (ith position) = #_stone_at_right_in_A (after ith position) + #_stone_at_left_in_B\\n```\n```\\ncondition 3 = total - num_of_most_frequent_count\\n```\n```\\nclass Solution:\\n    def minCharacters(self, a: str, b: str) -> int:\\n        presumA = 0\\n        presumB = 0\\n        \\n        counterA = Counter([ch for ch in a])\\n        counterB = Counter([ch for ch in b])\\n        \\n        res = sys.maxsize\\n        \\n        # situation 3\\n        m = len(a)\\n        n = len(b)\\n        \\n        # possibility 1: fulfill condition 3\\n        res = min(res, m - max(counterA.values()) + n - max(counterB.values()))\\n    \\n        presumA = []\\n        sumA = 0\\n        presumB = []\\n        \\n        sumB = 0\\n        for i in range(0, 26):\\n            sumA += counterA[chr(i + 97)]\\n            presumA.append(sumA)\\n            sumB += counterB[chr(i + 97)]\\n            presumB.append(sumB)\\n            \\n        # to make every a smaller than b\\n        for i in range(0, 25):\\n            res = min(m - presumA[i] + presumB[i], res)\\n            \\n        # to make every a smaller than b    \\n        for i in range(0, 25):\\n            res = min(n - presumB[i] + presumA[i], res)\\n            \\n        return res\\n    \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1032135,
                "title": "c-easy-to-understand-brute-force-o-a-b-time-o-1-space",
                "content": "## Solution 1.\\n\\n```cpp\\n// OJ: https://leetcode.com/problems/change-minimum-characters-to-satisfy-one-of-three-conditions/\\n// Author: github.com/lzl124631x\\n// Time: O(A + B)\\n// Space: O(1)\\nclass Solution {\\n    int count(string &a, string &b) { // make all chars in `b` strictly greater than `a`.\\n        int ans = INT_MAX; \\n        for (char c = \\'a\\'; c < \\'z\\'; ++c) { // assume `c` is the breakpoint -- make all chars in `a` <= `c` and all chars in `b` > `c`\\n            int cnt = 0;\\n            for (char x : a) cnt += x > c; // all the chars in `a` that `> c` should be changed.\\n            for (char x : b) cnt += x <= c; // all the chars in `b` that `<= c` should be changed.\\n            ans = min(ans, cnt);\\n        }\\n        return ans;\\n    }\\npublic:\\n    int minCharacters(string a, string b) {\\n        int x = count(a, b), y = count(b, a); // try operation 1 and 2.\\n        int ans = INT_MAX;\\n        for (char c = \\'a\\'; c <= \\'z\\'; ++c) { // try operation 3. Assume we change all chars to `c`\\n            int cnt = 0;\\n            for (char x : a) cnt += x != c;\\n            for (char x : b) cnt += x != c;\\n            ans = min(ans, cnt);\\n        }\\n        return min({ x, y, ans});\\n    }\\n};\\n```\\n\\n## Solution 2.\\n\\nUse `ca` and `cb` to store the frequence of characters in `a` and `b` respectively.\\n\\nWe can try each character in `[a, z]` and use it as a break point.\\n\\nTake operation 1 for example, if we use `\\'a\\' + 2 = \\'c\\'` as a break point, that is, changing all `a[i] > \\'c\\'` to `\\'c\\'` and changing all `b[i] <= \\'c\\'` to `\\'d\\'`.\\n\\nThe count of required operations is `op1[2] = SUM(ca, 3, 25) + SUM(cb, 0, 2)` where `SUM(arr, i, j) = arr[i] + arr[i + 1] + ... + arr[j]`.\\n\\nSo `op1[i] = SUM(ca, i + 1, 25) + SUM(cb, 0, i)` where `0 <= i < 25`.\\n\\n`op1[i] - op1[i - 1] = cb[i] - ca[i]`\\n\\nSimilarly `op2[i] = SUM(cb, i + 1, 25) + SUM(ca, 0, i)` where `0 <= i < 25`.\\n\\n`op2[i] - op2[i - 1] = ca[i] - cb[i]`\\n\\nFor operation 3, if we pick `\\'a\\' + i` as the breakpoint, we need to sum all `ca[j]` and `cb[j]` where `j != i`.\\n\\nSo `op3[i] = SUM(ca) + SUM(cb) - ca[i] - cb[i]`\\n\\n```cpp\\n// OJ: https://leetcode.com/problems/change-minimum-characters-to-satisfy-one-of-three-conditions/\\n// Author: github.com/lzl124631x\\n// Time: O(A + B)\\n// Space: O(1)\\nclass Solution {\\npublic:\\n    int minCharacters(string a, string b) {\\n        array<int, 26> ca = {}, cb = {};\\n        for (char c : a) ca[c - \\'a\\']++;\\n        for (char c : b) cb[c - \\'a\\']++;\\n        int M = a.size(), N = b.size(), op1 = M, op2 = N, ans = INT_MAX;\\n        for (int i = 0; i < 26; ++i) {\\n            op1 += cb[i] - ca[i];\\n            op2 += ca[i] - cb[i];\\n            if (i < 25) ans = min({ ans, op1, op2 });\\n            ans = min(ans, M + N - ca[i] - cb[i]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```cpp\\n// OJ: https://leetcode.com/problems/change-minimum-characters-to-satisfy-one-of-three-conditions/\\n// Author: github.com/lzl124631x\\n// Time: O(A + B)\\n// Space: O(1)\\nclass Solution {\\n    int count(string &a, string &b) { // make all chars in `b` strictly greater than `a`.\\n        int ans = INT_MAX; \\n        for (char c = \\'a\\'; c < \\'z\\'; ++c) { // assume `c` is the breakpoint -- make all chars in `a` <= `c` and all chars in `b` > `c`\\n            int cnt = 0;\\n            for (char x : a) cnt += x > c; // all the chars in `a` that `> c` should be changed.\\n            for (char x : b) cnt += x <= c; // all the chars in `b` that `<= c` should be changed.\\n            ans = min(ans, cnt);\\n        }\\n        return ans;\\n    }\\npublic:\\n    int minCharacters(string a, string b) {\\n        int x = count(a, b), y = count(b, a); // try operation 1 and 2.\\n        int ans = INT_MAX;\\n        for (char c = \\'a\\'; c <= \\'z\\'; ++c) { // try operation 3. Assume we change all chars to `c`\\n            int cnt = 0;\\n            for (char x : a) cnt += x != c;\\n            for (char x : b) cnt += x != c;\\n            ans = min(ans, cnt);\\n        }\\n        return min({ x, y, ans});\\n    }\\n};\\n```\n```cpp\\n// OJ: https://leetcode.com/problems/change-minimum-characters-to-satisfy-one-of-three-conditions/\\n// Author: github.com/lzl124631x\\n// Time: O(A + B)\\n// Space: O(1)\\nclass Solution {\\npublic:\\n    int minCharacters(string a, string b) {\\n        array<int, 26> ca = {}, cb = {};\\n        for (char c : a) ca[c - \\'a\\']++;\\n        for (char c : b) cb[c - \\'a\\']++;\\n        int M = a.size(), N = b.size(), op1 = M, op2 = N, ans = INT_MAX;\\n        for (int i = 0; i < 26; ++i) {\\n            op1 += cb[i] - ca[i];\\n            op2 += ca[i] - cb[i];\\n            if (i < 25) ans = min({ ans, op1, op2 });\\n            ans = min(ans, M + N - ca[i] - cb[i]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1032032,
                "title": "clean-python-3-choose-separated-letter",
                "content": "Try every letter to make it as the separated letter.\\nFor example, if we choose `c` as separated letter,\\n`less_a` is the cost to make all letters in `a` be less than `c` and all letters in `b` be larger and equal to `c`.\\n\\nTime: `O(A + B)`\\nSpace: `O(1)`\\n```\\nimport collections\\nimport string\\nclass Solution:\\n    def minCharacters(self, a: str, b: str) -> int:\\n        counter_a = collections.Counter(a)\\n        counter_b = collections.Counter(b)\\n        less_a, less_b, unique = float(\\'inf\\'), float(\\'inf\\'), float(\\'inf\\')\\n        accu_a, accu_b = 0, 0\\n        for c in string.ascii_lowercase:\\n            unique = min(unique, len(a) + len(b) - counter_a[c] - counter_b[c])\\n            if c > \\'a\\':\\n                less_a = min(less_a, len(a) - accu_a + accu_b)\\n                less_b = min(less_b, len(b) - accu_b + accu_a)\\n            accu_a += counter_a[c]\\n            accu_b += counter_b[c]\\n        return min(less_a, less_b, unique)\\n```",
                "solutionTags": [],
                "code": "```\\nimport collections\\nimport string\\nclass Solution:\\n    def minCharacters(self, a: str, b: str) -> int:\\n        counter_a = collections.Counter(a)\\n        counter_b = collections.Counter(b)\\n        less_a, less_b, unique = float(\\'inf\\'), float(\\'inf\\'), float(\\'inf\\')\\n        accu_a, accu_b = 0, 0\\n        for c in string.ascii_lowercase:\\n            unique = min(unique, len(a) + len(b) - counter_a[c] - counter_b[c])\\n            if c > \\'a\\':\\n                less_a = min(less_a, len(a) - accu_a + accu_b)\\n                less_b = min(less_b, len(b) - accu_b + accu_a)\\n            accu_a += counter_a[c]\\n            accu_b += counter_b[c]\\n        return min(less_a, less_b, unique)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1317007,
                "title": "easy-c-solution-commented-fully",
                "content": "```\\nclass Solution {\\npublic:\\n    int minCharacters(string a, string b) {\\n        //calculate the opertions for each condition  and return the  min operations among the conditions\\n        \\n        int m=a.length();\\n        int n=b.length();\\n        \\n        //calculate the freq of every character in a and b\\n        vector<int> freq1(26,0);\\n        vector<int> freq2(26,0);\\n        for(int i=0;i<a.length();i++)\\n        {\\n            freq1[a[i]-\\'a\\']++;\\n        }\\n        for(int j=0;j<b.length();j++)\\n        {\\n            freq2[b[j]-\\'a\\']++;\\n        }\\n        \\n        int res=INT_MAX;\\n        //for every character in alphabets get the number of operations to satisfy each condition\\n        for(int i=0;i<26;i++)\\n        {\\n            //condition 3\\n            //change all the characters to i char in alphabets\\n            //the total characters in both the strings which are different should be changed\\n            res=min(res,m+n-freq1[i]-freq2[i]);\\n            if(i>0)\\n            {\\n                freq1[i]+=freq1[i-1];\\n                freq2[i]+=freq2[i-1];\\n                \\n                  //condition 1\\n                //change all char in string a to strictly less than curr char(i);\\n                //change all char in string b to greater than or equal to curr char i;\\n                //change all the char greater than curr i in a i.e., m-freq[i-1];\\n                res=min(res, m -freq1[i-1] + freq2[i-1]);\\n                    \\n                \\n                //condition 2\\n                //change all the char in b strictly less than the curr character\\n                //change all char in a greater than or equal to curr char (i);\\n                res=min(res,n-freq2[i-1] + freq1[i-1]);\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```\\n**Upvote if this helps you :)**",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minCharacters(string a, string b) {\\n        //calculate the opertions for each condition  and return the  min operations among the conditions\\n        \\n        int m=a.length();\\n        int n=b.length();\\n        \\n        //calculate the freq of every character in a and b\\n        vector<int> freq1(26,0);\\n        vector<int> freq2(26,0);\\n        for(int i=0;i<a.length();i++)\\n        {\\n            freq1[a[i]-\\'a\\']++;\\n        }\\n        for(int j=0;j<b.length();j++)\\n        {\\n            freq2[b[j]-\\'a\\']++;\\n        }\\n        \\n        int res=INT_MAX;\\n        //for every character in alphabets get the number of operations to satisfy each condition\\n        for(int i=0;i<26;i++)\\n        {\\n            //condition 3\\n            //change all the characters to i char in alphabets\\n            //the total characters in both the strings which are different should be changed\\n            res=min(res,m+n-freq1[i]-freq2[i]);\\n            if(i>0)\\n            {\\n                freq1[i]+=freq1[i-1];\\n                freq2[i]+=freq2[i-1];\\n                \\n                  //condition 1\\n                //change all char in string a to strictly less than curr char(i);\\n                //change all char in string b to greater than or equal to curr char i;\\n                //change all the char greater than curr i in a i.e., m-freq[i-1];\\n                res=min(res, m -freq1[i-1] + freq2[i-1]);\\n                    \\n                \\n                //condition 2\\n                //change all the char in b strictly less than the curr character\\n                //change all char in a greater than or equal to curr char (i);\\n                res=min(res,n-freq2[i-1] + freq1[i-1]);\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1032693,
                "title": "js-python-java-c-frequency-map-dp-solution-w-explanation-beats-100-100",
                "content": "*(Note: This is part of a series of Leetcode solution explanations ([**index**](https://dev.to/seanpgallivan/leetcode-solutions-index-57fl)). If you like this solution or find it useful,* ***please upvote*** *this post.)*\\n\\n---\\n\\n***Idea:***\\n\\nThis problem is actually much more simple than it appears. Since we\\'re going to dealing entirely with the counts of different characters, we will obviously need to create **frequency maps** (**fmA**, **fmB**) for both input strings (**A**, **B**).\\n\\nWe can check for the third condition by comparing the frequencies of any given character in both strings. The sum of those two frequencies (**fmA[i] + fmB[i]**) would be the number of characters we would *not* need to shift, so the **best** answer would be the total number of characters in both strings (**lenA + lenB**) minus the largest possible frequency sum.\\n\\nFor the first two conditions we can think logically about the distribution of the values in our frequency maps. Consider the example below:\\n```javascript\\n       fmA =        [<------- C ------->|<--- D --->]\\n               a b c d e f g h i j k l m|n o p q r s t u v w x y z\\n       fmB =                [<--- E --->|<------- F ------->]\\n```\\nFor any border between two characters (in this case \"m\" and \"n\"), we could make condition **A > B** by pushing all the characters in **A** before \"n\" (**sum of range C**) forward and also pushing all the characters in **B** after \"m\" (**sum of range F**) backward. Similarly, we could make condition **B > A** by pushing **E** forward and pushing **D** backward.\\n```javascript\\n       conditionA = sumC + sumF\\n       conditionB = sumE + sumD\\n```\\nWe also can figure out that **sumC + sumD =  lenA** and **sumE + sumF = lenB**, so we can rewrite these as:\\n```javascript\\n       conditionA = sumC + (lenB - sumE) = sumC - sumE + lenB\\n       conditionB = sumE + (lenA - sumC) = sumE - sumC + lenA\\n```\\nThis allows us to iterate in one direction and keep a running sum of **A** and **B** up to that midpoint in order to check these possibilities. As we\\'re checking the boundaries between characters, we only need to iterate through this check **25** times instead of **26**.\\n\\nConveniently, **conditionA** and **conditionB** are also the inverse of each other, as they both sum up to **lenA + lenB**, so they can be used as either the number needing to change, or the number needing to stay the same.\\n```javascript\\n       lenA + lenB - conditionA = conditionB\\n       lenA + lenB - conditionB = conditionA\\n```\\nThat means we can use them with the same **best** from when we checked the third condition to find the maximum value of characters that don\\'t need to be shifted in order to match one of the conditions.\\n\\nThen we just need to find the difference between that number and the total number of characters, so we should **return lenA + lenB - best**.\\n\\n---\\n\\n***Implementation:***\\n\\nIn Javascript, we can use the much more efficient **Uint32Array** for our frequency maps by converting the characters to **0-indexed** integers.\\n\\nPython has the very convenient **Counter()** class, so we can make full use of that.\\n\\nFor Java and C++, the ability to convert characters to **0-indexed** numbers simply by subtracting **\\'a\\'** is very useful. But both languages only allow two arguments for **max()**, which requires nesting them to evaluate three values.\\n\\n---\\n\\n***Javascript Code:***\\n\\nThe best result for the code below is **76ms / 44.0MB** (beats 100% / 100%).\\n```javascript\\nvar minCharacters = function(A, B) {\\n    let lenA = A.length, fmA = new Uint32Array(26),\\n        lenB = B.length, fmB = new Uint32Array(26),\\n        best = sumA = sumB = 0\\n    for (let i = 0; i < lenA; i++) fmA[A.charCodeAt(i)-97]++\\n    for (let i = 0; i < lenB; i++) fmB[B.charCodeAt(i)-97]++\\n    for (let i = 0; i < 26; i++) best = Math.max(best, fmA[i]+fmB[i])\\n    for (let i = 0; i < 25; i++) {\\n        sumA += fmA[i], sumB += fmB[i]\\n        best = Math.max(best, sumA-sumB+lenB, sumB-sumA+lenA)\\n    }\\n    return lenA + lenB - best\\n};\\n```\\n\\n---\\n\\n***Python Code:***\\n\\nThe best result for the code below is **88ms / 14.8MB** (beats 100% / 98%).\\n```python\\nclass Solution:\\n    def minCharacters(self, A: str, B: str) -> int:\\n        lenA, lenB = len(A), len(B)\\n        fmA, fmB = Counter(A), Counter(B)\\n        best, sumA, sumB = 0, 0, 0\\n        for i in string.ascii_lowercase:\\n            best = max(best, fmA[i]+fmB[i])\\n        for i in string.ascii_lowercase[:-1]:\\n            sumA += fmA[i]\\n            sumB += fmB[i]\\n            best = max(best, sumA-sumB+lenB, sumB-sumA+lenA)\\n        return lenA + lenB - best\\n```\\n\\n---\\n\\n***Java Code:***\\n\\nThe best result for the code below is **7ms / 39.8MB** (beats 100% / 67%).\\n```java\\nclass Solution {\\n    public int minCharacters(String A, String B) {\\n        int lenA = A.length(), lenB = B.length();\\n        int[] fmA = new int[26], fmB = new int[26];\\n        int best = 0, sumA = 0, sumB = 0;\\n        for (char c: A.toCharArray()) fmA[c - \\'a\\']++;\\n        for (char c: B.toCharArray()) fmB[c - \\'a\\']++;\\n        for (int i = 0; i < 26; i++) best = Math.max(best, fmA[i]+fmB[i]);\\n        for (int i = 0; i < 25; i++) {\\n            sumA += fmA[i];\\n            sumB += fmB[i];\\n            best = Math.max(best, Math.max(sumA-sumB+lenB, sumB-sumA+lenA));\\n        }\\n        return lenA + lenB - best;\\n    }\\n}\\n```\\n\\n---\\n\\n***C++ Code:***\\n\\nThe best result for the code below is **36ms / 14.7MB** (beats 99% / 71%).\\n```c++\\nclass Solution {\\npublic:\\n    int minCharacters(string A, string B) {\\n        int lenA = A.size(), lenB = B.size();\\n        int fmA [26] = {}, fmB [26] = {};\\n        int best = 0, sumA = 0, sumB = 0;\\n        for (char c: A) fmA[c - \\'a\\']++;\\n        for (char c: B) fmB[c - \\'a\\']++;\\n        for (int i = 0; i < 26; i++) best = max(best, fmA[i]+fmB[i]);\\n        for (int i = 0; i < 25; i++) {\\n            sumA += fmA[i];\\n            sumB += fmB[i];\\n            best = max(best, max(sumA-sumB+lenB, sumB-sumA+lenA));\\n        }\\n        return lenA + lenB - best;\\n    }\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```javascript\\n       fmA =        [<------- C ------->|<--- D --->]\\n               a b c d e f g h i j k l m|n o p q r s t u v w x y z\\n       fmB =                [<--- E --->|<------- F ------->]\\n```\n```javascript\\n       conditionA = sumC + sumF\\n       conditionB = sumE + sumD\\n```\n```javascript\\n       conditionA = sumC + (lenB - sumE) = sumC - sumE + lenB\\n       conditionB = sumE + (lenA - sumC) = sumE - sumC + lenA\\n```\n```javascript\\n       lenA + lenB - conditionA = conditionB\\n       lenA + lenB - conditionB = conditionA\\n```\n```javascript\\nvar minCharacters = function(A, B) {\\n    let lenA = A.length, fmA = new Uint32Array(26),\\n        lenB = B.length, fmB = new Uint32Array(26),\\n        best = sumA = sumB = 0\\n    for (let i = 0; i < lenA; i++) fmA[A.charCodeAt(i)-97]++\\n    for (let i = 0; i < lenB; i++) fmB[B.charCodeAt(i)-97]++\\n    for (let i = 0; i < 26; i++) best = Math.max(best, fmA[i]+fmB[i])\\n    for (let i = 0; i < 25; i++) {\\n        sumA += fmA[i], sumB += fmB[i]\\n        best = Math.max(best, sumA-sumB+lenB, sumB-sumA+lenA)\\n    }\\n    return lenA + lenB - best\\n};\\n```\n```python\\nclass Solution:\\n    def minCharacters(self, A: str, B: str) -> int:\\n        lenA, lenB = len(A), len(B)\\n        fmA, fmB = Counter(A), Counter(B)\\n        best, sumA, sumB = 0, 0, 0\\n        for i in string.ascii_lowercase:\\n            best = max(best, fmA[i]+fmB[i])\\n        for i in string.ascii_lowercase[:-1]:\\n            sumA += fmA[i]\\n            sumB += fmB[i]\\n            best = max(best, sumA-sumB+lenB, sumB-sumA+lenA)\\n        return lenA + lenB - best\\n```\n```java\\nclass Solution {\\n    public int minCharacters(String A, String B) {\\n        int lenA = A.length(), lenB = B.length();\\n        int[] fmA = new int[26], fmB = new int[26];\\n        int best = 0, sumA = 0, sumB = 0;\\n        for (char c: A.toCharArray()) fmA[c - \\'a\\']++;\\n        for (char c: B.toCharArray()) fmB[c - \\'a\\']++;\\n        for (int i = 0; i < 26; i++) best = Math.max(best, fmA[i]+fmB[i]);\\n        for (int i = 0; i < 25; i++) {\\n            sumA += fmA[i];\\n            sumB += fmB[i];\\n            best = Math.max(best, Math.max(sumA-sumB+lenB, sumB-sumA+lenA));\\n        }\\n        return lenA + lenB - best;\\n    }\\n}\\n```\n```c++\\nclass Solution {\\npublic:\\n    int minCharacters(string A, string B) {\\n        int lenA = A.size(), lenB = B.size();\\n        int fmA [26] = {}, fmB [26] = {};\\n        int best = 0, sumA = 0, sumB = 0;\\n        for (char c: A) fmA[c - \\'a\\']++;\\n        for (char c: B) fmB[c - \\'a\\']++;\\n        for (int i = 0; i < 26; i++) best = max(best, fmA[i]+fmB[i]);\\n        for (int i = 0; i < 25; i++) {\\n            sumA += fmA[i];\\n            sumB += fmB[i];\\n            best = max(best, max(sumA-sumB+lenB, sumB-sumA+lenA));\\n        }\\n        return lenA + lenB - best;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1032113,
                "title": "c-40-ms-turning-point",
                "content": "The idea is to pick a character, and calculate moves to make string a (or b) less than that character. We go through all 26 characters and return the smallest amount of moves.\\n\\n```cpp\\nint minCharacters(string a, string b) {\\n    int ca[26] = {}, cb[26] = {}, sza = a.size(), szb = b.size();\\n    for (auto c : a)\\n        ++ca[c - \\'a\\'];\\n    for (auto c : b)\\n        ++cb[c - \\'a\\'];\\n    int suma = ca[0], sumb = cb[0], res = sza - ca[0] + szb - cb[0];\\n    for (auto c = 1; c < 26; ++c) {\\n        res = min({res, suma + szb - sumb, sumb + sza - suma, \\n                   sza - ca[c] + szb - cb[c]});\\n        suma += ca[c];\\n        sumb += cb[c];\\n    }\\n    return res;\\n}\\n```",
                "solutionTags": [],
                "code": "```cpp\\nint minCharacters(string a, string b) {\\n    int ca[26] = {}, cb[26] = {}, sza = a.size(), szb = b.size();\\n    for (auto c : a)\\n        ++ca[c - \\'a\\'];\\n    for (auto c : b)\\n        ++cb[c - \\'a\\'];\\n    int suma = ca[0], sumb = cb[0], res = sza - ca[0] + szb - cb[0];\\n    for (auto c = 1; c < 26; ++c) {\\n        res = min({res, suma + szb - sumb, sumb + sza - suma, \\n                   sza - ca[c] + szb - cb[c]});\\n        suma += ca[c];\\n        sumb += cb[c];\\n    }\\n    return res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1040694,
                "title": "straightforward-python-solution-with-illustration",
                "content": "Below is my python solution. \\n```\\n    def minCharacters(self, a: str, b: str) -> int:\\n        A = [0]*26  # freq of each alphabet in a\\n        B = [0]*26  \\n        for ch in a:\\n            A[ord(ch) - ord(\\'a\\')] += 1\\n        for ch in b:\\n            B[ord(ch) - ord(\\'a\\')] += 1\\n        res = len(a) - max(A) + len(b) - max(B) # condition 3 met\\n        sumA, sumB = len(a), len(b)\\n        runA, runB = 0, 0 # running total\\n        for i in range(25):\\n            runA += A[i]\\n            runB += B[i]\\n            res = min(res, min(runA + sumB - runB, runB + sumA - runA))\\n        return res\\n```\\n- First store frequency of each alphabet in an array of size 26 for each string. \\n- return value *res* set to condition 3, note that the cost of changing a string to containing only 1 unique character is equal to len(s) - maxfreq(s), where we change all characters except one with highest frequency.\\n- updating *res* with regards to condition 1 and 2 is a bit tricky, which is better shown with an example on a graph. See below.\\n\\nIf we use example 2: a = \\'dabadd\\' and b = \\'cda\\', we get counter A and B initialized as below:\\n![image](https://assets.leetcode.com/users/images/076ead37-16ff-44a6-9328-f6be1190ae88_1611936864.8499672.png)\\nNote that since the largest alphabet we have is d, so both array have zero values after index 3.\\nThen, in order to meet condition 1 or 2, we need to draw a line on top of the arrays, having left and right portions with **NON-ZERO length**, like below I drew a red line to separate both arrays:![image](https://assets.leetcode.com/users/images/b1d28370-1d01-4201-9822-75ccea43de4e_1611937000.6363814.png)\\nNow all we need to do is to SHIFT frequencies of A onto one side, and frequencies of B onto the other side of the line! The cost is what I circled in red circles (condition 2, here the cost is 2 + 0 + 1 + 1 = 4) or the part that\\'s not circled in red (condition 1, and the cost is 1 + 1 + 0 + 3 = 5). We update *res* with the minimum, if minimum is less than current *res*.\\nWhen do we find the answer? When the line is shifted to the right of index 3, which is shown as the black line below. You would see to get condition 1, the cost is 1 + 0 + 1 + 1 = 3.\\n![image](https://assets.leetcode.com/users/images/2451e5f5-63c3-4efb-87ef-9dcce58c4a19_1611937291.8301356.png)\\n\\nThe only thing that trapped me when solving this problem is: remember that for condition 1 and 2 you need to make sure the line separates arrays into two non-empty lengths! You cannot have the separation line at either end of the arrays!\\n\\nHope the illustration did help you understand the problem better!\\n\\n",
                "solutionTags": [],
                "code": "```\\n    def minCharacters(self, a: str, b: str) -> int:\\n        A = [0]*26  # freq of each alphabet in a\\n        B = [0]*26  \\n        for ch in a:\\n            A[ord(ch) - ord(\\'a\\')] += 1\\n        for ch in b:\\n            B[ord(ch) - ord(\\'a\\')] += 1\\n        res = len(a) - max(A) + len(b) - max(B) # condition 3 met\\n        sumA, sumB = len(a), len(b)\\n        runA, runB = 0, 0 # running total\\n        for i in range(25):\\n            runA += A[i]\\n            runB += B[i]\\n            res = min(res, min(runA + sumB - runB, runB + sumA - runA))\\n        return res\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1032921,
                "title": "simple-efficient-c-solution",
                "content": "**IF FIND IT HELPFUL PLEASE UPVOTE***\\n```\\nclass Solution {\\npublic:\\n    int count(string &a,string &b)\\n    {\\n        int ans=INT_MAX;\\n        for(char c=\\'a\\';c<\\'z\\';c++)\\n        {\\n            int cnt=0;\\n            for(char it:a) cnt+=(it>c);\\n            for(char it:b) cnt+=(it<=c);\\n            ans=min(ans,cnt);\\n        }\\n        return ans;\\n    }\\n    int minCharacters(string a, string b) {\\n        int x=count(a,b),y=count(b,a);\\n        int fans=INT_MAX;\\n        \\n        for(char c=\\'a\\';c<=\\'z\\';c++)\\n        {\\n            int cnt=0;\\n            for(char it:a) cnt+=(it!=c);\\n            for(char it:b) cnt+=(it!=c);\\n            fans=min(fans,cnt);  \\n        }\\n        return min({x,y,fans});\\n    }\\n};\\n```\\n\\n1) For string A,string B fix a breaking point between \\'a\\' & \\'z\\' let it be b_point, and for both string calculate operations required to make string A less than  b_point and for string B greater than b_point. \\n2) The loop for function count for b_point goes from \\'a\\' to less than \\'z\\' because for \\'z\\' we cannot get a operation to make characters greater than \\'z\\'.  \\n3) But for making letters of string A and string B equal breaking point loop goes from \\'a\\' to less than equal to \\'z\\' and the final ans would be minimum of operation1 ,operation2 and operation 3.",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int count(string &a,string &b)\\n    {\\n        int ans=INT_MAX;\\n        for(char c=\\'a\\';c<\\'z\\';c++)\\n        {\\n            int cnt=0;\\n            for(char it:a) cnt+=(it>c);\\n            for(char it:b) cnt+=(it<=c);\\n            ans=min(ans,cnt);\\n        }\\n        return ans;\\n    }\\n    int minCharacters(string a, string b) {\\n        int x=count(a,b),y=count(b,a);\\n        int fans=INT_MAX;\\n        \\n        for(char c=\\'a\\';c<=\\'z\\';c++)\\n        {\\n            int cnt=0;\\n            for(char it:a) cnt+=(it!=c);\\n            for(char it:b) cnt+=(it!=c);\\n            fans=min(fans,cnt);  \\n        }\\n        return min({x,y,fans});\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1032052,
                "title": "count-map-o-n-with-explanation-from-a-to-y-change-a-and-b",
                "content": "The key is that for c from \\'a\\' to \\'y\\', we either change \\nall(a chars) > c && all(b chars) <= c or \\nall(b chars) > c && all(a chars) <= c\\n\\nFor example,\\nSay a = \"aba\", b = \"caa\"\\naMap = [2, 1, 0, 0...]\\nbmap = [2, 0, 1, 0, ...]\\n\\nif we want all characters in `a` to be <= \\'a\\', all characters in `b` to be more than \\'a\\', we need to change 3 - 2 chars in a and 2 chars in b. \\n\\n```\\nclass Solution {\\n    public int minCharacters(String a, String b) {\\n        int[] aCount = new int[26];\\n        int aMax = 0;\\n        for (int i = 0; i < a.length(); i++) {\\n            aCount[a.charAt(i) - \\'a\\']++;\\n            aMax = Math.max(aMax, aCount[a.charAt(i) - \\'a\\']);\\n        }\\n        \\n        int[] bCount = new int[26];\\n        int bMax = 0;\\n        for (int i = 0; i < b.length(); i++) {\\n            bCount[b.charAt(i) - \\'a\\']++;\\n            bMax = Math.max(bMax, bCount[b.charAt(i) - \\'a\\']);\\n        }\\n        int condition3 = a.length() - aMax + b.length() - bMax;\\n        \\n        int globalMin = condition3;\\n        \\n        int aTillCurrent = 0;\\n        int bTillCurrent = 0;\\n        for (int i = 0; i < 25; i++) {\\n            aTillCurrent += aCount[i];\\n            bTillCurrent += bCount[i];\\n            globalMin = Math.min(globalMin, bTillCurrent + a.length() - aTillCurrent);\\n            globalMin = Math.min(globalMin, aTillCurrent + b.length() - bTillCurrent);\\n        }\\n        \\n        \\n        \\n        return globalMin;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minCharacters(String a, String b) {\\n        int[] aCount = new int[26];\\n        int aMax = 0;\\n        for (int i = 0; i < a.length(); i++) {\\n            aCount[a.charAt(i) - \\'a\\']++;\\n            aMax = Math.max(aMax, aCount[a.charAt(i) - \\'a\\']);\\n        }\\n        \\n        int[] bCount = new int[26];\\n        int bMax = 0;\\n        for (int i = 0; i < b.length(); i++) {\\n            bCount[b.charAt(i) - \\'a\\']++;\\n            bMax = Math.max(bMax, bCount[b.charAt(i) - \\'a\\']);\\n        }\\n        int condition3 = a.length() - aMax + b.length() - bMax;\\n        \\n        int globalMin = condition3;\\n        \\n        int aTillCurrent = 0;\\n        int bTillCurrent = 0;\\n        for (int i = 0; i < 25; i++) {\\n            aTillCurrent += aCount[i];\\n            bTillCurrent += bCount[i];\\n            globalMin = Math.min(globalMin, bTillCurrent + a.length() - aTillCurrent);\\n            globalMin = Math.min(globalMin, aTillCurrent + b.length() - bTillCurrent);\\n        }\\n        \\n        \\n        \\n        return globalMin;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1289175,
                "title": "java-boundary-letter-t-c-o-a-b-s-c-o-1",
                "content": "\\n    public int minCharacters(String a, String b) {\\n        \\n        int[] map1 = new int[26], map2 = new int[26];\\n        int count = a.length()+b.length();\\n        \\n        for(char ch : a.toCharArray())\\n            map1[ch - \\'a\\']++;\\n        \\n        for(char ch : b.toCharArray())\\n            map2[ch - \\'a\\']++;\\n        \\n        return Math.min(condition1(map1.clone(), map2.clone()), Math.min(condition1(map2.clone(), map1.clone()), condition3(map1.clone(), map2.clone(), count)));\\n    }\\n    \\n    public int condition1(int[] map1, int[] map2){\\n        \\n        int min = Integer.MAX_VALUE;\\n        for(int i = 1 ; i < 26 ; i++){\\n            \\n            int count = 0;\\n            for(int j = i ; j < 26 ; j++)\\n                count += map1[j];\\n            \\n            for(int j = 0 ; j < i ; j++)\\n                count += map2[j];\\n            \\n            if(count < min)\\n                min = count;\\n        }\\n        return min;\\n    }\\n    \\n    public int condition3(int[] map1, int[] map2, int total){\\n        \\n        int max = Integer.MIN_VALUE, count = 0;\\n        for(int i=0;i<26;i++){\\n            if(map1[i]+map2[i]>max)\\n                max=map1[i]+map2[i];\\n        }\\n        \\n        return total - max;\\n    }",
                "solutionTags": [],
                "code": "\\n    public int minCharacters(String a, String b) {\\n        \\n        int[] map1 = new int[26], map2 = new int[26];\\n        int count = a.length()+b.length();\\n        \\n        for(char ch : a.toCharArray())\\n            map1[ch - \\'a\\']++;\\n        \\n        for(char ch : b.toCharArray())\\n            map2[ch - \\'a\\']++;\\n        \\n        return Math.min(condition1(map1.clone(), map2.clone()), Math.min(condition1(map2.clone(), map1.clone()), condition3(map1.clone(), map2.clone(), count)));\\n    }\\n    \\n    public int condition1(int[] map1, int[] map2){\\n        \\n        int min = Integer.MAX_VALUE;\\n        for(int i = 1 ; i < 26 ; i++){\\n            \\n            int count = 0;\\n            for(int j = i ; j < 26 ; j++)\\n                count += map1[j];\\n            \\n            for(int j = 0 ; j < i ; j++)\\n                count += map2[j];\\n            \\n            if(count < min)\\n                min = count;\\n        }\\n        return min;\\n    }\\n    \\n    public int condition3(int[] map1, int[] map2, int total){\\n        \\n        int max = Integer.MIN_VALUE, count = 0;\\n        for(int i=0;i<26;i++){\\n            if(map1[i]+map2[i]>max)\\n                max=map1[i]+map2[i];\\n        }\\n        \\n        return total - max;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1037117,
                "title": "java-explained-with-images",
                "content": "we first calcuate the Afreq and Bfreq , then calculate the prefix sum of these two arrays.\\nthen do manipultations. \\nWhy ? Below images help to understand what are those manipulations and why we are doing it.\\n![image](https://assets.leetcode.com/users/images/d637347e-6165-4d62-91f4-dffc71e1d023_1611729597.8483527.png)\\n\\nThen we calculate the prefix sum array.\\nSuppose we decide to have character \\u2018a\\u2019 in stringA i.e StringA =\"aaaaaa\", then we need change characters which are greater than \\u2018a\\u2019 in StringA and change characters less than equal to \\u2018a\\u2019 in String B , for example b =\"cdb\" , by doing this StringA will contain only characters less than equal to A and B will contain characters greater than \\u2018a\\u2019 which satisfies the **Every\\xA0letter in\\xA0a\\xA0is\\xA0strictly less\\xA0than\\xA0every\\xA0letter in\\xA0b\\xA0in the alphabet**\\n\\nHow we can calculate the cost , prefix array help us to determine this.\\nNote in the image AprefixSum at C is 3 not zero.\\n![image](https://assets.leetcode.com/users/images/3e4d0c96-7637-42a3-9331-d84ac86f49c3_1611771656.355638.png)\\n\\n\\nLets take another example \\n\\nSuppose we decide to have character less than equal to \\u2018c\\u2019 in stringA i.e StringA = \"**c**aba**cc**\" ( we need change characters which are greater than \\u2018c\\u2019 in StringA, in our case we changed character \\'d\\' to \\'c\\' marked in bold) and at the same time we need to change characters less than equal to \\u2018c\\u2019 in String B, for example StringB = \"**d**d**d**\" , \\nTransformedString A = \"**c**aba**cc**\" inputStringA = \"dabadd\"\\nTransformedString B = \"**d**d**d**\"     inputStringB  = \"cda\"\\nAgain it satisfies  **Every\\xA0letter in\\xA0a\\xA0is\\xA0strictly less\\xA0than\\xA0every\\xA0letter in\\xA0b\\xA0in the alphabet**\\n\\n![image](https://assets.leetcode.com/users/images/4c5d896e-19b6-4c2d-ab08-a5751c47bc28_1611771538.6096194.png)\\n\\nWe can do the other way round to get the second condition **Every\\xA0letter in\\xA0b\\xA0is\\xA0strictly less\\xA0than\\xA0every\\xA0letter in\\xA0a\\xA0in the alphabet**\\n\\nCost to have character \\u2018c\\u2019 in stringB = (lengthb)-prefixB[2] + prefixA[2]\\n\\n```\\nclass Solution {\\n    public int minCharacters(String a, String b) {\\n        \\n         int lengthA = a.length();\\n         int lengthB = b.length();\\n         int[] afreq = new int[26];\\n         int[] bfreq = new int[26];\\n     \\n        \\n         int maxFreqA = 0;\\n         int maxFreqB = 0;\\n\\n         int res = Integer.MAX_VALUE;\\n        \\n         for( int i = 0 ; i < a.length(); i++ )\\n         {\\n            int index = a.charAt(i) -\\'a\\';\\n            afreq[ index ]++;    \\n            maxFreqA = Math.max( maxFreqA,afreq[ index ]); \\n         }\\n        \\n      \\n          for( int i = 0 ; i < b.length(); i++ )\\n          {\\n              int index = b.charAt(i) -\\'a\\';\\n              bfreq[ index ]++;    \\n              maxFreqB = Math.max( maxFreqB,bfreq[ index ]); \\n          }\\n        \\n        res = Math.min( res, lengthA + lengthB - maxFreqA - maxFreqB ); // Both a and b consist of only one distinct letter.\\n        \\n        for( int i = 1; i < 26; i++ )\\n        {\\n             afreq[i] = afreq[i] + afreq[i-1]; // A prefixSum \\n             bfreq[i] = bfreq[i] + bfreq[i-1];// B prefixSum\\n        }   \\n        \\n\\t\\t//Loop only goes till \\'y\\' character because there is no character greater than z. \\n        for( int i =0 ; i < 25; i++ )\\n        {\\n            res = Math.min( lengthA - afreq[i] + bfreq[i],res  );\\n            res = Math.min( lengthB - bfreq[i] + afreq[i],res  );\\n        }\\n    return res;\\n    }\\n}\\n\\n\\n\\n\\n\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public int minCharacters(String a, String b) {\\n        \\n         int lengthA = a.length();\\n         int lengthB = b.length();\\n         int[] afreq = new int[26];\\n         int[] bfreq = new int[26];\\n     \\n        \\n         int maxFreqA = 0;\\n         int maxFreqB = 0;\\n\\n         int res = Integer.MAX_VALUE;\\n        \\n         for( int i = 0 ; i < a.length(); i++ )\\n         {\\n            int index = a.charAt(i) -\\'a\\';\\n            afreq[ index ]++;    \\n            maxFreqA = Math.max( maxFreqA,afreq[ index ]); \\n         }",
                "codeTag": "Java"
            },
            {
                "id": 1032239,
                "title": "java-o-n-solution",
                "content": "Maintain two count array which gives the frequencies of each character.\\nHere we are checking for all three possibilities,\\n\\n1. First possibility is to convert all the characters in both array to some char x. Since operation has to be minimum, \\'x\\' should be the character with maximum frequency in string a and string b.\\noperations  required = a.length + b.length -  frequency of max frequent character\\n2. Second possibility : Try for each character [a,...,y] as thershold x:\\nstring a < string b if all character in **string a is less than or equal to threshold character x** + **all character in string b is greater than threshold character x**\\noperations required = number of characters in string a greater than x + number of characters in string b less than or equal to x.\\n3. Third possibility : Similarly try for string a > string b\\n\\nReturn minimum of all possibilities\\n\\n```\\nclass Solution {\\n    public int minCharacters(String a, String b) {\\n        int []count1 = new int[26];\\n        int []count2 = new int[26];\\n        for(int i=0;i<a.length();i++)\\n            count1[a.charAt(i)-\\'a\\']++;\\n        for(int i=0;i<b.length();i++)\\n            count2[b.charAt(i)-\\'a\\']++;\\n        \\n        int maxFreq = 0;\\n        for(int i=0;i<26;i++)\\n            maxFreq = Math.max(maxFreq,count1[i]+count2[i]);\\n        int ans = a.length()+b.length();\\n        ans = Math.min(ans,(a.length()+b.length())-maxFreq);\\n        \\n        int l = 0;\\n        int r = 0;\\n        for(int i=0;i<25;i++){\\n            // considering each character as threshold\\n            l += count1[i];\\n            r += count2[i];  \\n            if(l+(b.length()-r)==1)\\n                System.out.println(i);  \\n            ans = Math.min(ans,l+(b.length()-r));     \\n        }\\n        l = 0;\\n        r = 0;\\n        for(int i=0;i<25;i++){\\n            l += count1[i];\\n            r += count2[i];    \\n            ans = Math.min(ans,r+(a.length()-l));\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minCharacters(String a, String b) {\\n        int []count1 = new int[26];\\n        int []count2 = new int[26];\\n        for(int i=0;i<a.length();i++)\\n            count1[a.charAt(i)-\\'a\\']++;\\n        for(int i=0;i<b.length();i++)\\n            count2[b.charAt(i)-\\'a\\']++;\\n        \\n        int maxFreq = 0;\\n        for(int i=0;i<26;i++)\\n            maxFreq = Math.max(maxFreq,count1[i]+count2[i]);\\n        int ans = a.length()+b.length();\\n        ans = Math.min(ans,(a.length()+b.length())-maxFreq);\\n        \\n        int l = 0;\\n        int r = 0;\\n        for(int i=0;i<25;i++){\\n            // considering each character as threshold\\n            l += count1[i];\\n            r += count2[i];  \\n            if(l+(b.length()-r)==1)\\n                System.out.println(i);  \\n            ans = Math.min(ans,l+(b.length()-r));     \\n        }\\n        l = 0;\\n        r = 0;\\n        for(int i=0;i<25;i++){\\n            l += count1[i];\\n            r += count2[i];    \\n            ans = Math.min(ans,r+(a.length()-l));\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1032069,
                "title": "c-o-n",
                "content": "```\\nclass Solution {\\npublic:\\n    int minCharacters(string a, string b) {\\n        int ans = a.size() + b.size();\\n        int m = a.size();\\n        int n = b.size();\\n        vector<int> c(26, 0);\\n        vector<int> d(26, 0);\\n        \\n        for (auto &ch : a) {\\n            c[ch-\\'a\\']++;\\n        }\\n        for (auto &ch: b) {\\n            d[ch-\\'a\\']++;\\n        }\\n        \\n        // a == b\\n        for (int i = 0; i < 26; ++i) {\\n            ans = min(ans, -c[i]-d[i]+m+n);\\n        }\\n        \\n        int sum_a = 0;\\n        int sum_b = 0;\\n        for (int i = 0; i < 25; ++i) {\\n            sum_a += c[i];\\n            sum_b += d[i];\\n            ans = min(ans, -sum_a+m+sum_b);// a < b\\n            ans = min(ans, -sum_b+n+sum_a);// a > b\\n            \\n            \\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minCharacters(string a, string b) {\\n        int ans = a.size() + b.size();\\n        int m = a.size();\\n        int n = b.size();\\n        vector<int> c(26, 0);\\n        vector<int> d(26, 0);\\n        \\n        for (auto &ch : a) {\\n            c[ch-\\'a\\']++;\\n        }\\n        for (auto &ch: b) {\\n            d[ch-\\'a\\']++;\\n        }\\n        \\n        // a == b\\n        for (int i = 0; i < 26; ++i) {\\n            ans = min(ans, -c[i]-d[i]+m+n);\\n        }\\n        \\n        int sum_a = 0;\\n        int sum_b = 0;\\n        for (int i = 0; i < 25; ++i) {\\n            sum_a += c[i];\\n            sum_b += d[i];\\n            ans = min(ans, -sum_a+m+sum_b);// a < b\\n            ans = min(ans, -sum_b+n+sum_a);// a > b\\n            \\n            \\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1033687,
                "title": "c-simple-dfs-with-memorization-o-n-dp",
                "content": "Couldn\\'t do it during the contest. \\nUsually when I cannot do the second one, my brain gives up!\\n\\n\\nThe idea is to basically have array called ```a``` (size 26) which is frequencies of \\neach element in ```str1``` and same for ```str2```.\\n\\nNow have two pointers, one points to the beginning of ```a``` and the other one to the end of ```b```.\\n\\nNow answer is the minimum of following two:\\n\\n    frequencyA[curAPointer] + dfs(curAPointer+1, curBPointer),\\n    frequencyB[curBPointer] + dfs(curAPointer, curBPointer-1)\\n\\t\\nOnce ```curApointer``` is greater than ```curBPointer```, \\nit meas that all remaining elements in ```a``` are greater than elemets in ```b```. so halt right there.\\n\\nAlso swap ```a``` and ```b``` run above steps again.\\n\\nAlso calculate how much it cost to change all characters in both strings to be unique.\\nFinal answer is the best of all above 3.\\n\\nhere is the code:\\n\\n```\\n#define MIN(a,b) ((a)<(b)?(a):(b))\\n#define MAX(a,b) ((a)>(b)?(a):(b))\\n\\nclass Solution {\\n    int dp[26][26];\\npublic:\\n    int solve(vector<int> &a, vector<int> &b, int ap, int bp) {\\n        if (ap == 26) {\\n            return b[25];\\n        }\\n        if (bp == -1) {\\n            return a[0];\\n        }\\n        if (ap > bp) {\\n            return 0;\\n        }\\n        if (dp[ap][bp] != -1) {\\n            return dp[ap][bp];\\n        }\\n        int res = MIN(a[ap] + solve(a, b, ap+1, bp),\\n                      b[bp] + solve(a, b, ap, bp-1));\\n        dp[ap][bp] = res;\\n        return res;\\n    }\\n    int minCharacters(string a, string b) {\\n        vector<int> av(26), bv(26);\\n        int mxA = 0, mxB = 0;\\n        for (auto &ch: a) {\\n            av[ch-\\'a\\'] += 1;\\n            mxA = MAX(mxA, av[ch-\\'a\\']);\\n        }\\n        for (auto &ch: b) {\\n            bv[ch-\\'a\\'] += 1;\\n            mxB = MAX(mxB, bv[ch-\\'a\\']);\\n        }\\n        \\n        memset(dp, -1, sizeof dp);\\n        int firstCondition = solve(av, bv, 0, 25);\\n        memset(dp, -1, sizeof dp);\\n        int secondCondition = solve(bv, av , 0, 25);\\n        int thirdCondition = a.size()-mxA+b.size()-mxB;\\n        \\n        return MIN(thirdCondition, MIN(firstCondition, secondCondition));\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```a```\n```str1```\n```str2```\n```a```\n```b```\n```curApointer```\n```curBPointer```\n```a```\n```b```\n```a```\n```b```\n```\\n#define MIN(a,b) ((a)<(b)?(a):(b))\\n#define MAX(a,b) ((a)>(b)?(a):(b))\\n\\nclass Solution {\\n    int dp[26][26];\\npublic:\\n    int solve(vector<int> &a, vector<int> &b, int ap, int bp) {\\n        if (ap == 26) {\\n            return b[25];\\n        }\\n        if (bp == -1) {\\n            return a[0];\\n        }\\n        if (ap > bp) {\\n            return 0;\\n        }\\n        if (dp[ap][bp] != -1) {\\n            return dp[ap][bp];\\n        }\\n        int res = MIN(a[ap] + solve(a, b, ap+1, bp),\\n                      b[bp] + solve(a, b, ap, bp-1));\\n        dp[ap][bp] = res;\\n        return res;\\n    }\\n    int minCharacters(string a, string b) {\\n        vector<int> av(26), bv(26);\\n        int mxA = 0, mxB = 0;\\n        for (auto &ch: a) {\\n            av[ch-\\'a\\'] += 1;\\n            mxA = MAX(mxA, av[ch-\\'a\\']);\\n        }\\n        for (auto &ch: b) {\\n            bv[ch-\\'a\\'] += 1;\\n            mxB = MAX(mxB, bv[ch-\\'a\\']);\\n        }\\n        \\n        memset(dp, -1, sizeof dp);\\n        int firstCondition = solve(av, bv, 0, 25);\\n        memset(dp, -1, sizeof dp);\\n        int secondCondition = solve(bv, av , 0, 25);\\n        int thirdCondition = a.size()-mxA+b.size()-mxB;\\n        \\n        return MIN(thirdCondition, MIN(firstCondition, secondCondition));\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1032544,
                "title": "python-with-explanation",
                "content": "Key idea here for satisfying condition 1 and 2 is to try out all the lowercase letters.\\nFor example, let\\'s choose \"b\" as the boundary letter. Then cost of converting1st word to consists of letters less than and equal to \"b\" would be\\n`cost_a = len(a) - counter_a[\"b\"]`\\nNote counter here is acting like a prefix sum of frequencies. and cost of converting word b to consists of characters only gt than b would be to convert all characters less than equal to \"b\"\\n`cost_b = counter_b[\"b\"]`\\nso total cost for using b as the boundary letter and making a less than b would be:\\n` a_less_than_b = len(a) - counter_a[\"b\"] + counter_b[\"b\"]`\\nsimilar argument applies for `b_less_than_a`\\n`b_less_than_a = len(b) - counter_b[\"b\"] + counter_a[\"b\"]`\\n\\n\\nUnique is relatively easier.\\n`unique_a = len(a) - max(counter_a.values())`\\n`unique_b = len(b) - max(counter_b.values())`\\n\\n```\\nclass Solution:\\n    def minCharacters(self, a: str, b: str) -> int:\\n        counter_a = Counter(ord(ch) - ord(\\'a\\') for ch in a)\\n        counter_b = Counter(ord(ch) - ord(\\'a\\') for ch in b)\\n        # keys will go from 0 to 25\\n        \\n        # condition 3\\n        # min cost to turn a consisting of single character only is len(a) - max_freq_of_character\\n        unique = len(a) - max(counter_a.values()) + len(b) - max(counter_b.values())\\n        \\n        a_less_than_b = b_less_than_a = len(a) + len(b)\\n        \\n        # counter maintains a prefix sum and it adds up the frequency of all previous letters upto the letter being tried as boundary letter.\\n        for i in range(1,26):\\n            counter_a[i] += counter_a[i-1]\\n            counter_b[i] += counter_b[i-1]\\n            # cost to turn a less than b\\n            a_less_than_b = min(a_less_than_b, len(a) - counter_a[i] + counter_b[i])\\n            b_less_than_a = min(b_less_than_a, len(b) - counter_b[i] + counter_a[i])\\n        \\n        \\n\\n        return min(a_less_than_b, b_less_than_a, unique)\\n            \\n        ```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minCharacters(self, a: str, b: str) -> int:\\n        counter_a = Counter(ord(ch) - ord(\\'a\\') for ch in a)\\n        counter_b = Counter(ord(ch) - ord(\\'a\\') for ch in b)\\n        # keys will go from 0 to 25\\n        \\n        # condition 3\\n        # min cost to turn a consisting of single character only is len(a) - max_freq_of_character\\n        unique = len(a) - max(counter_a.values()) + len(b) - max(counter_b.values())\\n        \\n        a_less_than_b = b_less_than_a = len(a) + len(b)\\n        \\n        # counter maintains a prefix sum and it adds up the frequency of all previous letters upto the letter being tried as boundary letter.\\n        for i in range(1,26):\\n            counter_a[i] += counter_a[i-1]\\n            counter_b[i] += counter_b[i-1]\\n            # cost to turn a less than b\\n            a_less_than_b = min(a_less_than_b, len(a) - counter_a[i] + counter_b[i])\\n            b_less_than_a = min(b_less_than_a, len(b) - counter_b[i] + counter_a[i])\\n        \\n        \\n\\n        return min(a_less_than_b, b_less_than_a, unique)\\n            \\n        ```",
                "codeTag": "Java"
            },
            {
                "id": 1032094,
                "title": "java-solution-using-two-count-array",
                "content": "```\\nclass Solution {\\n    public int minCharacters(String a, String b) {\\n\\n        return minChange(a, b, a.length(), b.length());\\n    }\\n    \\n    public static int minChange(String a,String b,\\n                                int s1, int s2)\\n    {\\n \\n      \\n        int count1[] = new int[26];\\n        int count2[] = new int[26];\\n \\n        // Find count map for s1\\n        for (int i = 0; i < s1; i++) {\\n            char ch = a.charAt(i);\\n            count1[ch - \\'a\\']++;\\n        }\\n \\n        // Find count map for s2\\n        for (int i = 0; i < s2; i++) {\\n            char ch = b.charAt(i);\\n            count2[ch - \\'a\\']++;\\n        }\\n        int count = s1 + s2;\\n        int n = count;\\n \\n        // case1: all char equal\\n        // to the replacement\\n        for (char ch = \\'a\\'; ch <= \\'z\\'; ch++) {\\n\\n            count = Math.min(\\n                count,\\n                n - count1[ch - \\'a\\']\\n                    - count2[ch - \\'a\\']);\\n        }\\n \\n        // Case 2: For s1[i] < s2[j]\\n        // note change is accumulative from a to z\\n        int change = s1; // maximum possible\\n        for (int d = 0; d + 1 < 26; d++) {\\n \\n            // Subtract all the characters\\n            // on left side that less than this replacement\\n            change -= count1[d];\\n \\n            // Adding all characters on the\\n            // right side that same as this replacement, those less already accumulated in last iteration of the for loop\\n            change += count2[d];\\n \\n            // Find minimum value of count\\n            count = Math.min(count, change);\\n        }\\n \\n        // Similarly for Case 3: s1[i] > s2[j]\\n        change = s2; //maximum possible\\n \\n        for (int d = 0; d + 1 < 26; d++) {\\n            change -= count2[d];\\n            change += count1[d];\\n            count = Math.min(change, count);\\n        }\\n \\n        \\n        return count;\\n    }\\n \\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minCharacters(String a, String b) {\\n\\n        return minChange(a, b, a.length(), b.length());\\n    }\\n    \\n    public static int minChange(String a,String b,\\n                                int s1, int s2)\\n    {\\n \\n      \\n        int count1[] = new int[26];\\n        int count2[] = new int[26];\\n \\n        // Find count map for s1\\n        for (int i = 0; i < s1; i++) {\\n            char ch = a.charAt(i);\\n            count1[ch - \\'a\\']++;\\n        }\\n \\n        // Find count map for s2\\n        for (int i = 0; i < s2; i++) {\\n            char ch = b.charAt(i);\\n            count2[ch - \\'a\\']++;\\n        }\\n        int count = s1 + s2;\\n        int n = count;\\n \\n        // case1: all char equal\\n        // to the replacement\\n        for (char ch = \\'a\\'; ch <= \\'z\\'; ch++) {\\n\\n            count = Math.min(\\n                count,\\n                n - count1[ch - \\'a\\']\\n                    - count2[ch - \\'a\\']);\\n        }\\n \\n        // Case 2: For s1[i] < s2[j]\\n        // note change is accumulative from a to z\\n        int change = s1; // maximum possible\\n        for (int d = 0; d + 1 < 26; d++) {\\n \\n            // Subtract all the characters\\n            // on left side that less than this replacement\\n            change -= count1[d];\\n \\n            // Adding all characters on the\\n            // right side that same as this replacement, those less already accumulated in last iteration of the for loop\\n            change += count2[d];\\n \\n            // Find minimum value of count\\n            count = Math.min(count, change);\\n        }\\n \\n        // Similarly for Case 3: s1[i] > s2[j]\\n        change = s2; //maximum possible\\n \\n        for (int d = 0; d + 1 < 26; d++) {\\n            change -= count2[d];\\n            change += count1[d];\\n            count = Math.min(change, count);\\n        }\\n \\n        \\n        return count;\\n    }\\n \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1032073,
                "title": "c-prefix-sum-44-ms-faster-than-100-00",
                "content": "Use the prefix sum and consider all possible partition point.\\n```\\nclass Solution {\\npublic:\\n    int minCharacters(string a, string b) {\\n        if(a == b) return 0;\\n        const int n = a.length(), m = b.length();\\n        vector<int> ca(26);\\n        vector<int> cb(26);\\n        int mosta = 0, mostb = 0;\\n        for(char c : a)  mosta = max(mosta, ++ca[c - \\'a\\']);\\n        for(char c : b)  mostb = max(mostb, ++cb[c - \\'a\\']);\\n        // prefix\\n        for(int i = 1; i < 26; ++i) {\\n            ca[i] += ca[i - 1];\\n            cb[i] += cb[i - 1];\\n        }\\n        \\n        int ans = min(strictlyLess(ca, cb), strictlyLess(cb, ca));  // compare condition 1 and 2\\n        ans = min(ans, n - mosta + m - mostb);  // compare with condition 3\\n        \\n        return ans;\\n    }\\nprivate:\\n    int strictlyLess(vector<int>& lo, vector<int>& hi) { \\n        int ans = INT_MAX;\\n        for(int i = 0; i < 25; ++i) {   // all chars in lo less or equal to char(i + \\'a\\'),  all chars in hi are greater than char(i + \\'a\\')\\n            int cur = lo[25] - lo[i] + hi[i];\\n            ans = min(cur, ans);\\n        }\\n        return ans;\\n    }\\n};\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minCharacters(string a, string b) {\\n        if(a == b) return 0;\\n        const int n = a.length(), m = b.length();\\n        vector<int> ca(26);\\n        vector<int> cb(26);\\n        int mosta = 0, mostb = 0;\\n        for(char c : a)  mosta = max(mosta, ++ca[c - \\'a\\']);\\n        for(char c : b)  mostb = max(mostb, ++cb[c - \\'a\\']);\\n        // prefix\\n        for(int i = 1; i < 26; ++i) {\\n            ca[i] += ca[i - 1];\\n            cb[i] += cb[i - 1];\\n        }\\n        \\n        int ans = min(strictlyLess(ca, cb), strictlyLess(cb, ca));  // compare condition 1 and 2\\n        ans = min(ans, n - mosta + m - mostb);  // compare with condition 3\\n        \\n        return ans;\\n    }\\nprivate:\\n    int strictlyLess(vector<int>& lo, vector<int>& hi) { \\n        int ans = INT_MAX;\\n        for(int i = 0; i < 25; ++i) {   // all chars in lo less or equal to char(i + \\'a\\'),  all chars in hi are greater than char(i + \\'a\\')\\n            int cur = lo[25] - lo[i] + hi[i];\\n            ans = min(cur, ans);\\n        }\\n        return ans;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2014832,
                "title": "python-clean-and-o-n",
                "content": "Just count different character frequencies,\\nThen calculate the minimum of 3 conditions.\\n\\n```\\nclass Solution:\\n    def minCharacters(self, a: str, b: str) -> int:\\n        c1, c2 =  [0]*26, [0]*26\\n        for ch in a:\\n            c1[ord(ch)-97] += 1\\n        \\n        for ch in b:\\n            c2[ord(ch)-97] += 1\\n        \\n        return min(\\n            min(sum(c2[:i])+sum(c1[i:]) for i in range(1, 26)),\\n            min(sum(c1[:i])+sum(c2[i:]) for i in range(1,26)),\\n            sum(c1)-max(c1)+sum(c2)-max(c2)\\n        )\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minCharacters(self, a: str, b: str) -> int:\\n        c1, c2 =  [0]*26, [0]*26\\n        for ch in a:\\n            c1[ord(ch)-97] += 1\\n        \\n        for ch in b:\\n            c2[ord(ch)-97] += 1\\n        \\n        return min(\\n            min(sum(c2[:i])+sum(c1[i:]) for i in range(1, 26)),\\n            min(sum(c1[:i])+sum(c2[i:]) for i in range(1,26)),\\n            sum(c1)-max(c1)+sum(c2)-max(c2)\\n        )\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1973560,
                "title": "java-o-n-easy-to-understand",
                "content": "```\\n\\nclass Solution {\\n    public int minCharacters(String a, String b) {\\n        // strictly smaller or bigger means for each letter i, either all a smaller than i and b bigger than i, or b smaller than i and a bigger than i, if we record count for each letter in a, b we just need to add up the count bigger or smaller\\n        // for all a and b equal we just need to remove count of i\\n        \\n        int[] countsA = new int[26];\\n        int[] countsB = new int[26];\\n        \\n        for(int i = 0; i < a.length(); i++) countsA[a.charAt(i) - \\'a\\']++;\\n        for(int i = 0; i < b.length(); i++) countsB[b.charAt(i) - \\'a\\']++;\\n        \\n        int m = a.length();\\n        int n = b.length();\\n        int res = Integer.MAX_VALUE;\\n        int aSum = 0;\\n        int bSum = 0;\\n        \\n        for(int i = 0; i < 25; i++) {\\n            aSum += countsA[i];\\n            bSum += countsB[i];\\n            // make a >= i, b smaller than i\\n            int aBiggerOps = aSum + n - bSum;\\n            // make b >= i,\\n            int aSmallerOps = bSum + m - aSum;\\n            // all equal to i\\n            int equal = m + n - countsA[i] - countsB[i];\\n            \\n            res = Math.min(res, Math.min(aBiggerOps, Math.min(equal, aSmallerOps)));\\n            \\n\\n        }\\n        \\n        return Math.min(res, m + n - countsA[25] - countsB[25]);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n\\nclass Solution {\\n    public int minCharacters(String a, String b) {\\n        // strictly smaller or bigger means for each letter i, either all a smaller than i and b bigger than i, or b smaller than i and a bigger than i, if we record count for each letter in a, b we just need to add up the count bigger or smaller\\n        // for all a and b equal we just need to remove count of i\\n        \\n        int[] countsA = new int[26];\\n        int[] countsB = new int[26];\\n        \\n        for(int i = 0; i < a.length(); i++) countsA[a.charAt(i) - \\'a\\']++;\\n        for(int i = 0; i < b.length(); i++) countsB[b.charAt(i) - \\'a\\']++;\\n        \\n        int m = a.length();\\n        int n = b.length();\\n        int res = Integer.MAX_VALUE;\\n        int aSum = 0;\\n        int bSum = 0;\\n        \\n        for(int i = 0; i < 25; i++) {\\n            aSum += countsA[i];\\n            bSum += countsB[i];\\n            // make a >= i, b smaller than i\\n            int aBiggerOps = aSum + n - bSum;\\n            // make b >= i,\\n            int aSmallerOps = bSum + m - aSum;\\n            // all equal to i\\n            int equal = m + n - countsA[i] - countsB[i];\\n            \\n            res = Math.min(res, Math.min(aBiggerOps, Math.min(equal, aSmallerOps)));\\n            \\n\\n        }\\n        \\n        return Math.min(res, m + n - countsA[25] - countsB[25]);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1032576,
                "title": "python3-min-cost-when-each-letter-as-the-smallest",
                "content": "\\n```python\\nclass Solution:\\n    def minCharacters(self, a: str, b: str) -> int:\\n        freqsA, freqsB = Counter(a), Counter(b)\\n\\t\\t# cond3\\n        res = len(a) + len(b) - (freqsA + freqsB).most_common(1)[0][1]\\n        for c in string.ascii_lowercase[1:]:\\n            cond1 = sum(freqsB[k] for k in freqsB if k < c) + sum(freqsA[k] for k in freqsA if k >= c)\\n            cond2 = sum(freqsA[k] for k in freqsA if k < c) + sum(freqsB[k] for k in freqsB if k >= c)\\n            res = min(res, cond1, cond2)\\n        return res\\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def minCharacters(self, a: str, b: str) -> int:\\n        freqsA, freqsB = Counter(a), Counter(b)\\n\\t\\t# cond3\\n        res = len(a) + len(b) - (freqsA + freqsB).most_common(1)[0][1]\\n        for c in string.ascii_lowercase[1:]:\\n            cond1 = sum(freqsB[k] for k in freqsB if k < c) + sum(freqsA[k] for k in freqsA if k >= c)\\n            cond2 = sum(freqsA[k] for k in freqsA if k < c) + sum(freqsB[k] for k in freqsB if k >= c)\\n            res = min(res, cond1, cond2)\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1032066,
                "title": "python-loop-one-less",
                "content": "The third condition is trivial to check.\\n\\nFor the first condition, we loop thru each possible character, so at first we consider making all elements in first string less than `b` (so all should be `a`). Then all elements in second string less than `b` should be converted. This requires `len(a) - ha[1] + hb[1]` changes, and so on. (Characters are mapped to their occurrence locations in the code, so `a` is 1, `b` is 2, etc.)\\n\\nRemember to skip last entry, so loop runs from `1,...,25` and not `1,...26`. If you got an error during testing in the contest, this is probably the reason (and hidden test cases do not help ;)).\\n\\nSecond condition is symmetric.\\n\\nAt the end return minimum operations to reach any of three conditions.\\n\\n```python\\nfrom collections import defaultdict\\nclass Solution:\\n    def minCharacters(self, a, b):\\n        ha, hb = defaultdict(int), defaultdict(int)\\n        for c in a:\\n            ha[ord(c)-96] += 1\\n        for c in b:\\n            hb[ord(c)-96] += 1\\n            \\n        c1 = float(\\'inf\\')\\n        ca = len(a)\\n        cb = 0\\n        for i in range(1,26):\\n            ca -= ha[i]\\n            cb += hb[i]\\n            c1 = min(c1, ca+cb)\\n        \\n        c2 = float(\\'inf\\')\\n        cb = len(b)\\n        ca = 0\\n        for i in range(1,26):\\n            cb -= hb[i]\\n            ca += ha[i]\\n            c2 = min(c2, ca+cb)\\n        \\n        c3 = float(\\'inf\\')\\n        for i in range(1,27):\\n            c3 = min(c3, len(a) + len(b) - ha[i] - hb[i])\\n        \\n        return min(c1, c2, c3)\\n```",
                "solutionTags": [],
                "code": "```python\\nfrom collections import defaultdict\\nclass Solution:\\n    def minCharacters(self, a, b):\\n        ha, hb = defaultdict(int), defaultdict(int)\\n        for c in a:\\n            ha[ord(c)-96] += 1\\n        for c in b:\\n            hb[ord(c)-96] += 1\\n            \\n        c1 = float(\\'inf\\')\\n        ca = len(a)\\n        cb = 0\\n        for i in range(1,26):\\n            ca -= ha[i]\\n            cb += hb[i]\\n            c1 = min(c1, ca+cb)\\n        \\n        c2 = float(\\'inf\\')\\n        cb = len(b)\\n        ca = 0\\n        for i in range(1,26):\\n            cb -= hb[i]\\n            ca += ha[i]\\n            c2 = min(c2, ca+cb)\\n        \\n        c3 = float(\\'inf\\')\\n        for i in range(1,27):\\n            c3 = min(c3, len(a) + len(b) - ha[i] - hb[i])\\n        \\n        return min(c1, c2, c3)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1032015,
                "title": "detailed-o-n-c",
                "content": "1. Let\\u2019s count occurrences of 26 lowercase letters in string a (cnt1) and string b (cnt2). This could be achieved in a single pass for each string.\\n2. The minimum number of operations to satisfy condition 3 could be computed by checking each of 26 characters as a potential distinct character, and easily done in a constant time. \\n3. For minimum number of operation to satisfy condition 1, we observe that after replacement all characters in string `a` are below `i`th character for some `i`, and all characters in string `b` are above the same character. So, for each `i` we could compute the number of replacements needed as the number of characters in string `a` above `i`th character plus the number of characters in string `b` below `i`th character (cur_res2 in the code). Similarly to 2, it is done in a constant time.\\n4. Condition 2 is similarly analyzed (cur_res1 in the code). \\n\\n```\\nclass Solution {\\npublic:\\n    int minCharacters(string a, string b) {\\n        vector<int> cnt1(26, 0);\\n        vector<int> cnt2(26, 0);\\n        int n1 = a.length();\\n        int n2 = b.length();\\n        \\n        for (int i = 0; i != n1; ++i) {\\n            ++cnt1[a[i] - \\'a\\'];\\n        }\\n        \\n        for (int i = 0; i != n2; ++i) {\\n            ++cnt2[b[i] - \\'a\\'];\\n        }\\n        \\n        int res = INT_MAX;\\n        //condition 3\\n        for (int i = 0; i != 26; ++i) {\\n            res = min(res, n1 - cnt1[i] + n2 - cnt2[i]);\\n        }\\n        \\n        //condition 1 and 2\\n        for (int i = 1; i != 26; ++i) {\\n            // below i -> s1 -> 25\\n            // above i -> s2 -> 0\\n            int cur_res1 = 0;\\n            int cur_res2 = 0;\\n            for (int i1 = 0; i1 != i; ++i1) {\\n                cur_res1 += cnt1[i1];\\n                cur_res2 += cnt2[i1]; \\n            }\\n            for (int i2 = i; i2 < 26; ++i2) {\\n                cur_res1 += cnt2[i2];\\n                cur_res2 += cnt1[i2];\\n            }\\n            res = min(res, cur_res1);\\n            res = min(res, cur_res2);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minCharacters(string a, string b) {\\n        vector<int> cnt1(26, 0);\\n        vector<int> cnt2(26, 0);\\n        int n1 = a.length();\\n        int n2 = b.length();\\n        \\n        for (int i = 0; i != n1; ++i) {\\n            ++cnt1[a[i] - \\'a\\'];\\n        }\\n        \\n        for (int i = 0; i != n2; ++i) {\\n            ++cnt2[b[i] - \\'a\\'];\\n        }\\n        \\n        int res = INT_MAX;\\n        //condition 3\\n        for (int i = 0; i != 26; ++i) {\\n            res = min(res, n1 - cnt1[i] + n2 - cnt2[i]);\\n        }\\n        \\n        //condition 1 and 2\\n        for (int i = 1; i != 26; ++i) {\\n            // below i -> s1 -> 25\\n            // above i -> s2 -> 0\\n            int cur_res1 = 0;\\n            int cur_res2 = 0;\\n            for (int i1 = 0; i1 != i; ++i1) {\\n                cur_res1 += cnt1[i1];\\n                cur_res2 += cnt2[i1]; \\n            }\\n            for (int i2 = i; i2 < 26; ++i2) {\\n                cur_res1 += cnt2[i2];\\n                cur_res2 += cnt1[i2];\\n            }\\n            res = min(res, cur_res1);\\n            res = min(res, cur_res2);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3428523,
                "title": "c-hash-map-greedy-compare-commented-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. find frequencies all of alphabet in both strings as `mpa & mpb`.\\n2. compute the prefix sum of each alphabet for both mpa & mpb as `prefixA & prefixB.`\\n3. Check making string a smaller than string b for all alphabet from \\'a\\' to \\'y\\', as `val1`.\\n4. Check making string a larger than string b for all alphabet from \\'a\\' to \\'y\\', as `val2`.\\n5. Check making string a eqaul to string b for all alphabet from \\'a\\' to \\'z\\', as `val3`.\\n6. Return the `min of val1, val2 and val3`.\\n\\n\\n![download (1).jfif](https://assets.leetcode.com/users/images/789bc3de-842b-460c-93cf-a5a78727a0ef_1681765804.2764263.jpeg)\\n\\n\\n# Complexity\\n- Time complexity : O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity  : O(4*26) => O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minCharacters(string a, string b) {\\n        int n1 = a.size();\\n        int n2 = b.size();\\n\\n        vector<int> mpa (26,0);\\n        vector<int> mpb (26,0);\\n\\n        vector<int> prefixA, prefixB;\\n\\n        //finding frequency of each aplhabet in Asring & Bstring\\n        for(auto i : a) \\n            mpa[i-\\'a\\']++;\\n        for(auto i : b) \\n            mpb[i-\\'a\\']++;\\n\\n        //evaluating the prefix Sum for both mpa & mpb\\n        int al=0, bl=0;\\n        for(int i=0; i<26; i++) {\\n            al += mpa[i];\\n            bl += mpb[i];\\n            prefixA.push_back(al);\\n            prefixB.push_back(bl);\\n        } \\n\\n        //making Astring smaller than Bstring for all a->y (can\\'t do that on z)\\n        int val1 = n1+n2;\\n        for(int i=0; i<25; i++) {\\n            int achange = n1 - prefixA[i];\\n            int bchange = prefixB[i];\\n            int curr = achange + bchange; \\n            val1 = min(curr,val1);\\n        } \\n\\n        //making Bstring smaller than Astring for all a->y (can\\'t do that on z)\\n        int val2 = n1+n2;\\n        for(int i=0; i<25; i++) {\\n            int achange = prefixA[i];\\n            int bchange = n2 - prefixB[i];\\n            int curr = achange + bchange; \\n            val2 = min(curr,val2);\\n        } \\n\\n        //making Astring equal to Bstring for all a->z\\n        int val3 = n1+n2;\\n        for(int i=0; i<26; i++) {\\n            int achange = n1 - mpa[i];\\n            int bchange = n2 - mpb[i];\\n            int curr = achange + bchange; \\n            val3 = min(curr,val3);\\n        }\\n        \\n        return min(val3, min(val1,val2)); \\n    }\\n};\\n```\\n\\n![images.jfif](https://assets.leetcode.com/users/images/727a4e16-9163-4ab6-8ad6-e8dbd716f592_1681765815.9481475.jpeg)\\n",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "String",
                    "Greedy",
                    "Counting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minCharacters(string a, string b) {\\n        int n1 = a.size();\\n        int n2 = b.size();\\n\\n        vector<int> mpa (26,0);\\n        vector<int> mpb (26,0);\\n\\n        vector<int> prefixA, prefixB;\\n\\n        //finding frequency of each aplhabet in Asring & Bstring\\n        for(auto i : a) \\n            mpa[i-\\'a\\']++;\\n        for(auto i : b) \\n            mpb[i-\\'a\\']++;\\n\\n        //evaluating the prefix Sum for both mpa & mpb\\n        int al=0, bl=0;\\n        for(int i=0; i<26; i++) {\\n            al += mpa[i];\\n            bl += mpb[i];\\n            prefixA.push_back(al);\\n            prefixB.push_back(bl);\\n        } \\n\\n        //making Astring smaller than Bstring for all a->y (can\\'t do that on z)\\n        int val1 = n1+n2;\\n        for(int i=0; i<25; i++) {\\n            int achange = n1 - prefixA[i];\\n            int bchange = prefixB[i];\\n            int curr = achange + bchange; \\n            val1 = min(curr,val1);\\n        } \\n\\n        //making Bstring smaller than Astring for all a->y (can\\'t do that on z)\\n        int val2 = n1+n2;\\n        for(int i=0; i<25; i++) {\\n            int achange = prefixA[i];\\n            int bchange = n2 - prefixB[i];\\n            int curr = achange + bchange; \\n            val2 = min(curr,val2);\\n        } \\n\\n        //making Astring equal to Bstring for all a->z\\n        int val3 = n1+n2;\\n        for(int i=0; i<26; i++) {\\n            int achange = n1 - mpa[i];\\n            int bchange = n2 - mpb[i];\\n            int curr = achange + bchange; \\n            val3 = min(curr,val3);\\n        }\\n        \\n        return min(val3, min(val1,val2)); \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2684071,
                "title": "c-easy-short",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minCharacters(string a, string b) {\\n        int m = a.size(), n = b.size(), res = m + n;\\n        vector<int> c1(26), c2(26);\\n        for (char& c: a) c1[c - \\'a\\']++;\\n        for (char& c: b) c2[c - \\'a\\']++;\\n\\n        for (int i = 0; i < 26; ++i) {\\n            res = min(res, m + n - c1[i] - c2[i]); \\n            if (i > 0) {\\n                c1[i] += c1[i - 1];\\n                c2[i] += c2[i - 1];\\n            }\\n            if (i < 25) {\\n                res = min(res, m - c1[i] + c2[i]);\\n                res = min(res, n - c2[i] + c1[i]); \\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minCharacters(string a, string b) {\\n        int m = a.size(), n = b.size(), res = m + n;\\n        vector<int> c1(26), c2(26);\\n        for (char& c: a) c1[c - \\'a\\']++;\\n        for (char& c: b) c2[c - \\'a\\']++;\\n\\n        for (int i = 0; i < 26; ++i) {\\n            res = min(res, m + n - c1[i] - c2[i]); \\n            if (i > 0) {\\n                c1[i] += c1[i - 1];\\n                c2[i] += c2[i - 1];\\n            }\\n            if (i < 25) {\\n                res = min(res, m - c1[i] + c2[i]);\\n                res = min(res, n - c2[i] + c1[i]); \\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2297330,
                "title": "python-simple-maths",
                "content": "\\n    def minCharacters(self, a, b):\\n        ans1, ans2 = [0]*26, [0]*26\\n        \\n        for ch in a:\\n            ans1[ord(ch)-97] += 1\\n            \\n        for ch in b:\\n            ans2[ord(ch)-97] += 1\\n            \\n        r1 = min(sum(ans2[:i]) + sum(ans1[i:]) for i in range(1,26))\\n        r2 = min(sum(ans1[:i]) + sum(ans2[i:]) for i in range(1,26))\\n        r3 = sum(ans1) + sum(ans2) - max(ans1) - max(ans2)\\n            \\n        return min(r1, r2, r3)",
                "solutionTags": [],
                "code": "\\n    def minCharacters(self, a, b):\\n        ans1, ans2 = [0]*26, [0]*26\\n        \\n        for ch in a:\\n            ans1[ord(ch)-97] += 1\\n            \\n        for ch in b:\\n            ans2[ord(ch)-97] += 1\\n            \\n        r1 = min(sum(ans2[:i]) + sum(ans1[i:]) for i in range(1,26))\\n        r2 = min(sum(ans1[:i]) + sum(ans2[i:]) for i in range(1,26))\\n        r3 = sum(ans1) + sum(ans2) - max(ans1) - max(ans2)\\n            \\n        return min(r1, r2, r3)",
                "codeTag": "Python3"
            },
            {
                "id": 1495239,
                "title": "o-n-simple-and-intutive",
                "content": "```\\nclass Solution {\\n    int ans,fa[26],fb[26];\\npublic:\\n    int minCharacters(string a, string b) {\\n        int i;\\n        for(i=0;i<26;i++){\\n            fa[i]=0;\\n            fb[i]=0;\\n        }\\n        int mxa=0,mxb=0;\\n        for(auto c:a){\\n            fa[c-\\'a\\']++;\\n            mxa=max(mxa,fa[c-\\'a\\']);\\n        }\\n        for(auto c:b){\\n            fb[c-\\'a\\']++;\\n            mxb=max(mxb,fb[c-\\'a\\']);\\n        }\\n\\t\\t\\n\\t\\t// converting a and b such that both a and b only have 1 uniqe alphabet\\n        ans=(a.length()-mxa)+(b.length()-mxb);\\n        \\n\\t\\tfor(i=1;i<26;i++){\\n            fa[i]=fa[i-1]+fa[i];\\n            fb[i]=fb[i-1]+fb[i];\\n        }\\n        \\n        for(i=0;i<25;i++){\\n            // if all alphabets in string a are less than equal to (\\'a\\'+i)\\n\\t\\t\\t// and all alphabets in string b are greater than (\\'a\\'+i)\\n            int ca=fa[25]-fa[i],cb=fb[i];\\n            ans=min(ans,ca+cb);\\n            \\n            // if all alphabets in string b are less than equal to (\\'a\\'+i)\\n\\t\\t\\t// and all alphabets in string a are greater than (\\'a\\'+i)\\n            ca=fa[i],cb=fb[25]-fb[i];\\n            ans=min(ans,ca+cb);\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\n    int ans,fa[26],fb[26];\\npublic:\\n    int minCharacters(string a, string b) {\\n        int i;\\n        for(i=0;i<26;i++){\\n            fa[i]=0;\\n            fb[i]=0;\\n        }\\n        int mxa=0,mxb=0;\\n        for(auto c:a){\\n            fa[c-\\'a\\']++;\\n            mxa=max(mxa,fa[c-\\'a\\']);\\n        }\\n        for(auto c:b){\\n            fb[c-\\'a\\']++;\\n            mxb=max(mxb,fb[c-\\'a\\']);\\n        }\\n\\t\\t\\n\\t\\t// converting a and b such that both a and b only have 1 uniqe alphabet\\n        ans=(a.length()-mxa)+(b.length()-mxb);\\n        \\n\\t\\tfor(i=1;i<26;i++){\\n            fa[i]=fa[i-1]+fa[i];\\n            fb[i]=fb[i-1]+fb[i];\\n        }\\n        \\n        for(i=0;i<25;i++){\\n            // if all alphabets in string a are less than equal to (\\'a\\'+i)\\n\\t\\t\\t// and all alphabets in string b are greater than (\\'a\\'+i)\\n            int ca=fa[25]-fa[i],cb=fb[i];\\n            ans=min(ans,ca+cb);\\n            \\n            // if all alphabets in string b are less than equal to (\\'a\\'+i)\\n\\t\\t\\t// and all alphabets in string a are greater than (\\'a\\'+i)\\n            ca=fa[i],cb=fb[25]-fb[i];\\n            ans=min(ans,ca+cb);\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1358849,
                "title": "short-c-with-comments",
                "content": "```\\nclass Solution {\\npublic:\\nint minCharacters(string a, string b)\\n{\\n    int n=a.size(),m=b.size(),ans=n+m;\\n    vector<int> aFq(26,0),bFq(26,0);\\n    for(auto it:a) aFq[it-\\'a\\']++;\\n    for(auto it:b) bFq[it-\\'a\\']++;\\n    for(int i=0;i<26;i++){\\n        // to make characters of both strings equal to \\'a\\'+i, every character not equal to \\'a\\'+i MUST be changed.\\n        ans=min(ans,n-aFq[i]+m-bFq[i]);\\n        if(i) aFq[i]+=aFq[i-1],bFq[i]+=bFq[i-1];\\n        // After doing above operation, aFq[i] contains prefix frequency of \\'a\\'+i \\n        // aFq[i]-> number of characters in string a <= \\'a\\'+i\\n        // bFq[i]-> number of characters in string b <= \\'a\\'+i\\n        // To make every character of string a greater than b, all characters <= \\'a\\'+i is changed to \\'z\\'. Number of changes = aFq[i]\\n        // and all characters > \\'a\\'+i is changed to \\'a\\' in string b. Number of changes = m-bFq[i] \\n        if(i<25) ans=min({ans,aFq[i]+m-bFq[i],bFq[i]+n-aFq[i]});\\n        // Similarly, exchanging (a<->b) and (m<->n) in the above line, we satisfy the other condition too\\n        // i<25 because we assume that aFq[i] or bFq[i] is increased to \\'z\\' and if i is already 25, then there\\'s no increment at all\\n    }\\n    return ans;\\n}\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\nint minCharacters(string a, string b)\\n{\\n    int n=a.size(),m=b.size(),ans=n+m;\\n    vector<int> aFq(26,0),bFq(26,0);\\n    for(auto it:a) aFq[it-\\'a\\']++;\\n    for(auto it:b) bFq[it-\\'a\\']++;\\n    for(int i=0;i<26;i++){\\n        // to make characters of both strings equal to \\'a\\'+i, every character not equal to \\'a\\'+i MUST be changed.\\n        ans=min(ans,n-aFq[i]+m-bFq[i]);\\n        if(i) aFq[i]+=aFq[i-1],bFq[i]+=bFq[i-1];\\n        // After doing above operation, aFq[i] contains prefix frequency of \\'a\\'+i \\n        // aFq[i]-> number of characters in string a <= \\'a\\'+i\\n        // bFq[i]-> number of characters in string b <= \\'a\\'+i\\n        // To make every character of string a greater than b, all characters <= \\'a\\'+i is changed to \\'z\\'. Number of changes = aFq[i]\\n        // and all characters > \\'a\\'+i is changed to \\'a\\' in string b. Number of changes = m-bFq[i] \\n        if(i<25) ans=min({ans,aFq[i]+m-bFq[i],bFq[i]+n-aFq[i]});\\n        // Similarly, exchanging (a<->b) and (m<->n) in the above line, we satisfy the other condition too\\n        // i<25 because we assume that aFq[i] or bFq[i] is increased to \\'z\\' and if i is already 25, then there\\'s no increment at all\\n    }\\n    return ans;\\n}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1248946,
                "title": "c-o-n-time-o-1-memory-concise-and-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    int minCharacters(string a, string b) {\\n        int ans=2000000000, n1=a.size(), n2=b.size(), sum1=0, sum2=0;\\n        vector<int> v1(26, 0), v2(26, 0);\\n        for(char ch: a){\\n            v1[ch-\\'a\\']++;\\n        }\\n        for(char ch: b){\\n            v2[ch-\\'a\\']++;\\n        }\\n        ans=min(ans, n1-*max_element(v1.begin(), v1.end())+n2-*max_element(v2.begin(), v2.end())); // 3rd condition\\n        for(char ch=\\'a\\'; ch<\\'z\\'; ch++){\\n            sum1+=v1[ch-\\'a\\'];\\n            sum2+=v2[ch-\\'a\\'];\\n            ans=min(ans, n1-sum1+sum2); // 1st condition\\n            ans=min(ans, n2-sum2+sum1); // 2nd condition\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minCharacters(string a, string b) {\\n        int ans=2000000000, n1=a.size(), n2=b.size(), sum1=0, sum2=0;\\n        vector<int> v1(26, 0), v2(26, 0);\\n        for(char ch: a){\\n            v1[ch-\\'a\\']++;\\n        }\\n        for(char ch: b){\\n            v2[ch-\\'a\\']++;\\n        }\\n        ans=min(ans, n1-*max_element(v1.begin(), v1.end())+n2-*max_element(v2.begin(), v2.end())); // 3rd condition\\n        for(char ch=\\'a\\'; ch<\\'z\\'; ch++){\\n            sum1+=v1[ch-\\'a\\'];\\n            sum2+=v2[ch-\\'a\\'];\\n            ans=min(ans, n1-sum1+sum2); // 1st condition\\n            ans=min(ans, n2-sum2+sum1); // 2nd condition\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1221572,
                "title": "python3-case-by-case-brainstormed-code",
                "content": "\\tclass Solution:\\n\\t\\tdef minCharacters(self, a: str, b: str) -> int:\\n\\t\\t\\t\\'\\'\\'\\n\\t\\t\\ta,b contain only lower case letters\\n\\t\\t\\tchanges within lowercase letters\\n\\t\\t\\tsatisfy one of the 3 conditions (1 or 2 or 3)\\n\\t\\t\\t\\t- all letters in a < letters in b alphabetically\\n\\t\\t\\t\\t- all letters in b < letters in a alphabetically\\n\\t\\t\\t\\t- a or b is unique\\n\\t\\t\\treturn minimun number of moves\\n\\n\\t\\t\\tIdea:\\n\\t\\t\\t\\t- case 1 and 2 are cumsums\\n\\t\\t\\t\\t- case 3 is to find the mode\\n\\t\\t\\t\\'\\'\\'\\n\\n\\t\\t\\t# get sorted representation (sorted count dict)\\n\\t\\t\\tla, lb = [0] * 26, [0] * 26\\n\\t\\t\\tfor c in a: la[ord(c)-ord(\\'a\\')] += 1\\n\\t\\t\\tfor c in b: lb[ord(c)-ord(\\'a\\')] += 1\\n\\t\\t\\tcase3 = len(a) + len(b)  -max(la) - max(lb)\\n\\n\\t\\t\\t# cumsum\\n\\t\\t\\tfor i in range(1,26):\\n\\t\\t\\t\\tla[i] += la[i-1]\\n\\t\\t\\t\\tlb[i] += lb[i-1]\\n\\n\\t\\t\\t# find case1: all a <b\\n\\t\\t\\tcase1 = float(\\'inf\\')\\n\\t\\t\\tfor i in range(25):\\n\\t\\t\\t\\tfor j in range(i+1, 26):\\n\\t\\t\\t\\t\\tmove_a = la[-1] - la[i] # move all to <= char(ord(\\'a\\')+i)\\n\\t\\t\\t\\t\\tmove_b = lb[j-1] # move all to >= char(ord(\\'a\\')+j)\\n\\t\\t\\t\\t\\tcase1 = min(case1, move_a + move_b)\\n\\n\\t\\t\\t# find case2: all b < a\\n\\t\\t\\tcase2 = float(\\'inf\\')\\n\\t\\t\\tfor i in range(25):\\n\\t\\t\\t\\tfor j in range(i+1, 26):\\n\\t\\t\\t\\t\\tmove_b = lb[-1] - lb[i] # move all to <= char(ord(\\'a\\')+i)\\n\\t\\t\\t\\t\\tmove_a = la[j-1] # move all to >= char(ord(\\'a\\')+j)\\n\\t\\t\\t\\t\\tcase2 = min(case2, move_a + move_b)\\n\\n\\t\\t\\t# return\\n\\t\\t\\treturn min(case1, case2, case3)\\n\\n\\n\\n",
                "solutionTags": [],
                "code": "\\tclass Solution:\\n\\t\\tdef minCharacters(self, a: str, b: str) -> int:\\n\\t\\t\\t\\'\\'\\'\\n\\t\\t\\ta,b contain only lower case letters\\n\\t\\t\\tchanges within lowercase letters\\n\\t\\t\\tsatisfy one of the 3 conditions (1 or 2 or 3)\\n\\t\\t\\t\\t- all letters in a < letters in b alphabetically\\n\\t\\t\\t\\t- all letters in b < letters in a alphabetically\\n\\t\\t\\t\\t- a or b is unique\\n\\t\\t\\treturn minimun number of moves\\n\\n\\t\\t\\tIdea:\\n\\t\\t\\t\\t- case 1 and 2 are cumsums\\n\\t\\t\\t\\t- case 3 is to find the mode\\n\\t\\t\\t\\'\\'\\'\\n\\n\\t\\t\\t# get sorted representation (sorted count dict)\\n\\t\\t\\tla, lb = [0] * 26, [0] * 26\\n\\t\\t\\tfor c in a: la[ord(c)-ord(\\'a\\')] += 1\\n\\t\\t\\tfor c in b: lb[ord(c)-ord(\\'a\\')] += 1\\n\\t\\t\\tcase3 = len(a) + len(b)  -max(la) - max(lb)\\n\\n\\t\\t\\t# cumsum\\n\\t\\t\\tfor i in range(1,26):\\n\\t\\t\\t\\tla[i] += la[i-1]\\n\\t\\t\\t\\tlb[i] += lb[i-1]\\n\\n\\t\\t\\t# find case1: all a <b\\n\\t\\t\\tcase1 = float(\\'inf\\')\\n\\t\\t\\tfor i in range(25):\\n\\t\\t\\t\\tfor j in range(i+1, 26):\\n\\t\\t\\t\\t\\tmove_a = la[-1] - la[i] # move all to <= char(ord(\\'a\\')+i)\\n\\t\\t\\t\\t\\tmove_b = lb[j-1] # move all to >= char(ord(\\'a\\')+j)\\n\\t\\t\\t\\t\\tcase1 = min(case1, move_a + move_b)\\n\\n\\t\\t\\t# find case2: all b < a\\n\\t\\t\\tcase2 = float(\\'inf\\')\\n\\t\\t\\tfor i in range(25):\\n\\t\\t\\t\\tfor j in range(i+1, 26):\\n\\t\\t\\t\\t\\tmove_b = lb[-1] - lb[i] # move all to <= char(ord(\\'a\\')+i)\\n\\t\\t\\t\\t\\tmove_a = la[j-1] # move all to >= char(ord(\\'a\\')+j)\\n\\t\\t\\t\\t\\tcase2 = min(case2, move_a + move_b)\\n\\n\\t\\t\\t# return\\n\\t\\t\\treturn min(case1, case2, case3)\\n\\n\\n\\n",
                "codeTag": "Java"
            },
            {
                "id": 1033187,
                "title": "java-7-ms-beats-100",
                "content": "```\\npublic int minCharacters(String a, String b) {\\n        char[] str1 = a.toCharArray();\\n        char[] str2 = b.toCharArray();\\n        int n = str1.length;\\n        int m = str2.length;\\n        int[] count1 = new int[26];\\n        int[] count2= new int[26];\\n        for(int i = 0;i< str1.length;i++){\\n            count1[str1[i] - \\'a\\']++;\\n        }\\n        for(int i = 0;i< str2.length;i++){\\n            count2[str2[i] - \\'a\\']++;\\n        }\\n        int min= Integer.MAX_VALUE;\\n        int sum1 = 0;\\n        int sum2 = 0;\\n        for(int i = 0;i < 25;i++){\\n            sum1 += count1[i];\\n            sum2 += count2[i];\\n            min = Math.min(min, sum1 + m - sum2);\\n            min = Math.min(min, sum2 + n - sum1);\\n        }\\n        int max = 0;\\n        for(int i =0; i< 26;i++){\\n            max = Math.max(max, count1[i]+count2[i]);\\n        }\\n        return Math.min(min, m+n- max);\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic int minCharacters(String a, String b) {\\n        char[] str1 = a.toCharArray();\\n        char[] str2 = b.toCharArray();\\n        int n = str1.length;\\n        int m = str2.length;\\n        int[] count1 = new int[26];\\n        int[] count2= new int[26];\\n        for(int i = 0;i< str1.length;i++){\\n            count1[str1[i] - \\'a\\']++;\\n        }\\n        for(int i = 0;i< str2.length;i++){\\n            count2[str2[i] - \\'a\\']++;\\n        }\\n        int min= Integer.MAX_VALUE;\\n        int sum1 = 0;\\n        int sum2 = 0;\\n        for(int i = 0;i < 25;i++){\\n            sum1 += count1[i];\\n            sum2 += count2[i];\\n            min = Math.min(min, sum1 + m - sum2);\\n            min = Math.min(min, sum2 + n - sum1);\\n        }\\n        int max = 0;\\n        for(int i =0; i< 26;i++){\\n            max = Math.max(max, count1[i]+count2[i]);\\n        }\\n        return Math.min(min, m+n- max);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1032414,
                "title": "javascript-compare-3-conditions",
                "content": "```\\n/**\\n * 1737-change-minimum-characters-to-satisfy-one-of-three-conditions.js\\n */\\nvar minCharacters = function (a, b) {\\n  const A = Array(26).fill(0);\\n  const B = Array(26).fill(0);\\n  let maxA = 0;\\n  let maxB = 0;\\n\\n  for (let c of a) {\\n    const idx = c.charCodeAt() - \"a\".charCodeAt();\\n    A[idx]++;\\n    maxA = Math.max(maxA, A[idx]);\\n  }\\n  for (let c of b) {\\n    const idx = c.charCodeAt() - \"a\".charCodeAt();\\n    B[idx]++;\\n    maxB = Math.max(maxB, B[idx]);\\n  }\\n\\n  // Condition 1: A < B\\n  let res = Infinity;\\n  // Only to 25 because z is not possible !!!\\n  for (let i = 0; i < 25; i++) {\\n    let [operationA, operationB] = [0, 0];\\n    for (let j = i + 1; j < 26; j++) operationA += A[j];\\n    for (let j = 0; j <= i; j++) operationB += B[j];\\n    res = Math.min(res, operationA + operationB);\\n  }\\n  // Condition 2: A > B\\n  for (let i = 0; i < 25; i++) {\\n    let [operationA, operationB] = [0, 0];\\n    for (let j = i + 1; j < 26; j++) operationB += B[j];\\n    for (let j = 0; j <= i; j++) operationA += A[j];\\n    res = Math.min(res, operationA + operationB);\\n  }\\n\\n  // Condition 3:\\n  return Math.min(res, a.length - maxA + b.length - maxB);\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * 1737-change-minimum-characters-to-satisfy-one-of-three-conditions.js\\n */\\nvar minCharacters = function (a, b) {\\n  const A = Array(26).fill(0);\\n  const B = Array(26).fill(0);\\n  let maxA = 0;\\n  let maxB = 0;\\n\\n  for (let c of a) {\\n    const idx = c.charCodeAt() - \"a\".charCodeAt();\\n    A[idx]++;\\n    maxA = Math.max(maxA, A[idx]);\\n  }\\n  for (let c of b) {\\n    const idx = c.charCodeAt() - \"a\".charCodeAt();\\n    B[idx]++;\\n    maxB = Math.max(maxB, B[idx]);\\n  }\\n\\n  // Condition 1: A < B\\n  let res = Infinity;\\n  // Only to 25 because z is not possible !!!\\n  for (let i = 0; i < 25; i++) {\\n    let [operationA, operationB] = [0, 0];\\n    for (let j = i + 1; j < 26; j++) operationA += A[j];\\n    for (let j = 0; j <= i; j++) operationB += B[j];\\n    res = Math.min(res, operationA + operationB);\\n  }\\n  // Condition 2: A > B\\n  for (let i = 0; i < 25; i++) {\\n    let [operationA, operationB] = [0, 0];\\n    for (let j = i + 1; j < 26; j++) operationB += B[j];\\n    for (let j = 0; j <= i; j++) operationA += A[j];\\n    res = Math.min(res, operationA + operationB);\\n  }\\n\\n  // Condition 3:\\n  return Math.min(res, a.length - maxA + b.length - maxB);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1032271,
                "title": "c-order-of-n-m-m-26",
                "content": "The intution behin the soltuion is as we know that every char of a should be less then every char of b\\nso finding the maximum char of a and then deleting all those chars of b which are less then a;\\nBut (point which I missed during my first submission ) we can also decrease the maximum char of a so for that what we can do is apply a loop from last maximum char of a upto the first char and in every case deleting all the char of b which are less then that.\\nSimilar thing can be done for b and a too.\\nand for one char same we can easily brute force and make every char of a and b equal to the \\'a\\',\\'b\\',\\'c\\',.... and so on and chechk where we can get minimum ans\\n\\nclass Solution {\\npublic:\\n    int minCharacters(string a, string b) {\\n        int ans=1e9;\\n        int cnt=0;\\n        int n=a.size();\\n        int m=b.size();\\n        vector<int>cnta(26,0);\\n        vector<int>cntb(26,0);\\n        for(auto j:a)\\n            cnta[j-\\'a\\']++;\\n         for(auto j:b)\\n            cntb[j-\\'a\\']++;\\n        \\n        int br=-1;\\n        for(int i=0;i<26;i++)\\n        {\\n            if(cnta[i]>0)\\n                br=i;\\n        }\\n        if(br<25)\\n        {\\n            for(int i=0;i<=br;i++)\\n                cnt+=cntb[i];\\n            \\n            ans=min(ans,cnt);\\n        }\\n            cnt=0;\\n            for(int i=br;i>=1;i--)\\n            {\\n                cnt+=cnta[i];\\n                 int br2=-1;\\n                for(int j=0;j<i;j++)\\n                {\\n                    if(cnta[j]>0)\\n                    br2=j;\\n                }\\n                if(br2<25)\\n                {\\n                    int cnt2=cnt;\\n                for(int j=0;j<=br2;j++)\\n                cnt2+=cntb[j];\\n                \\n                ans=min(ans,cnt2);\\n                } \\n            }\\n        // checking for b and a \\n        br=0;\\n        cnt=0;\\n        for(int i=0;i<26;i++)\\n        {\\n            if(cntb[i]>0)\\n                br=i;\\n        }\\n        if(br<25)\\n        {\\n            for(int i=0;i<=br;i++)\\n                cnt+=cnta[i];\\n            ans=min(ans,cnt);\\n        }\\n        cnt=0;\\n            for(int i=br;i>=1;i--)\\n            {\\n                cnt+=cntb[i];\\n                 int br2=-1;\\n                for(int j=0;j<i;j++)\\n                {\\n                    if(cntb[j]>0)\\n                    br2=j;\\n                }\\n                if(br2<25)\\n                {\\n                    int cnt2=cnt;\\n                for(int j=0;j<=br2;j++)\\n                cnt2+=cnta[j];\\n                \\n                ans=min(ans,cnt2);\\n                } \\n            }\\n        // third case\\n        for(char c=\\'a\\';c<=\\'z\\';c++)\\n        {\\n            cnt=0;\\n            for(auto j:a)\\n                if(j!=c) cnt++;\\n            for(auto j:b)\\n                if(j!=c) cnt++;\\n            ans=min(ans,cnt);\\n        }\\n        \\n        return ans;\\n        \\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int minCharacters(string a, string b) {\\n        int ans=1e9;\\n        int cnt=0;\\n        int n=a.size();\\n        int m=b.size();\\n        vector<int>cnta(26,0);\\n        vector<int>cntb(26,0);\\n        for(auto j:a)\\n            cnta[j-\\'a\\']++;\\n         for(auto j:b)\\n            cntb[j-\\'a\\']++;\\n        \\n        int br=-1;\\n        for(int i=0;i<26;i++)\\n        {\\n            if(cnta[i]>0)\\n                br=i;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1032176,
                "title": "easy-c-solution",
                "content": "1) First two conditions are equivalent so we only require one function for them.\\n2) We require another function for 3rd condition.\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    int solve(string a,string b){\\n        int res=INT_MAX;\\n        for(int i=1;i<26;i++){\\n            int cnt=0;\\n            for(auto c:a){\\n                if(c-\\'a\\'>=i)cnt++;\\n            }\\n            for(auto c:b){\\n                if(c-\\'a\\'<i)cnt++;\\n            }\\n            res=min(res,cnt);\\n        }\\n        return res;   \\n    }\\n    \\n    int solve1(string a,string b){\\n        int cnt[26]={0};\\n        for(auto c:a)cnt[c-\\'a\\']++;\\n        for(auto c:b)cnt[c-\\'a\\']++;\\n        int maxx=0;\\n        for(auto v:cnt)maxx=max(v,maxx);\\n        return a.size()+b.size()-maxx;\\n    }\\n    \\n    int minCharacters(string a, string b) {\\n        \\n        return min(solve1(a,b),min(solve(a,b),solve(b,a)));\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int solve(string a,string b){\\n        int res=INT_MAX;\\n        for(int i=1;i<26;i++){\\n            int cnt=0;\\n            for(auto c:a){\\n                if(c-\\'a\\'>=i)cnt++;\\n            }\\n            for(auto c:b){\\n                if(c-\\'a\\'<i)cnt++;\\n            }\\n            res=min(res,cnt);\\n        }\\n        return res;   \\n    }\\n    \\n    int solve1(string a,string b){\\n        int cnt[26]={0};\\n        for(auto c:a)cnt[c-\\'a\\']++;\\n        for(auto c:b)cnt[c-\\'a\\']++;\\n        int maxx=0;\\n        for(auto v:cnt)maxx=max(v,maxx);\\n        return a.size()+b.size()-maxx;\\n    }\\n    \\n    int minCharacters(string a, string b) {\\n        \\n        return min(solve1(a,b),min(solve(a,b),solve(b,a)));\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1032171,
                "title": "java-o-n-solution",
                "content": "```\\nclass Solution {\\n    public int minCharacters(String a, String b) {\\n        int min = case3(a) + case3(b);\\n        int min2 = case2(a, b);\\n        int min3 = case2(b, a);\\n        \\n        // System.out.println(min + \" \" + min2 + \" \" + min3);\\n        return Math.min(min, Math.min(min2, min3));\\n    }\\n    \\n    private int case2(String a, String b) { // a < b\\n        int[] mapa = new int[26];\\n        int[] mapb = new int[26];\\n        for (char c : a.toCharArray()) {\\n            mapa[c-\\'a\\']++;\\n        }\\n        for (char c : b.toCharArray()) {\\n            mapb[c-\\'a\\']++;\\n        }\\n        int min = Integer.MAX_VALUE;\\n        int aCount = 0;\\n        int moveToEnd = 0;\\n        if (mapb[0] != 0) {  // convert all a\\'s in string b to z\\'s\\n            moveToEnd = mapb[0];\\n            mapb[25] = moveToEnd;\\n            mapb[0] = 0;\\n        } \\n        \\n        for (int i = 0; i < 26; i++) {\\n            int aa = mapa[i];\\n            int bb = mapb[i];\\n            if (aa == 0 && bb == 0) {\\n                continue;\\n            }\\n            if (bb != 0) { // if we move all of a\\'s character at i and > i to beggining\\n                min = Math.min(min, a.length() - aCount + moveToEnd);\\n                moveToEnd += bb; \\n            }\\n            aCount += aa; \\n        }\\n        min = Math.min(min, moveToEnd); // if we can achieve min conversion by moving all elements in b to z\\n        return min;\\n    }\\n    \\n    private int case3(String a) {\\n        int[] map = new int[26];\\n        int max = 0;\\n        for (char c : a.toCharArray()) {\\n            map[c-\\'a\\']++;\\n            max = Math.max(max, map[c-\\'a\\']);\\n        }\\n        return a.length() - max;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minCharacters(String a, String b) {\\n        int min = case3(a) + case3(b);\\n        int min2 = case2(a, b);\\n        int min3 = case2(b, a);\\n        \\n        // System.out.println(min + \" \" + min2 + \" \" + min3);\\n        return Math.min(min, Math.min(min2, min3));\\n    }\\n    \\n    private int case2(String a, String b) { // a < b\\n        int[] mapa = new int[26];\\n        int[] mapb = new int[26];\\n        for (char c : a.toCharArray()) {\\n            mapa[c-\\'a\\']++;\\n        }\\n        for (char c : b.toCharArray()) {\\n            mapb[c-\\'a\\']++;\\n        }\\n        int min = Integer.MAX_VALUE;\\n        int aCount = 0;\\n        int moveToEnd = 0;\\n        if (mapb[0] != 0) {  // convert all a\\'s in string b to z\\'s\\n            moveToEnd = mapb[0];\\n            mapb[25] = moveToEnd;\\n            mapb[0] = 0;\\n        } \\n        \\n        for (int i = 0; i < 26; i++) {\\n            int aa = mapa[i];\\n            int bb = mapb[i];\\n            if (aa == 0 && bb == 0) {\\n                continue;\\n            }\\n            if (bb != 0) { // if we move all of a\\'s character at i and > i to beggining\\n                min = Math.min(min, a.length() - aCount + moveToEnd);\\n                moveToEnd += bb; \\n            }\\n            aCount += aa; \\n        }\\n        min = Math.min(min, moveToEnd); // if we can achieve min conversion by moving all elements in b to z\\n        return min;\\n    }\\n    \\n    private int case3(String a) {\\n        int[] map = new int[26];\\n        int max = 0;\\n        for (char c : a.toCharArray()) {\\n            map[c-\\'a\\']++;\\n            max = Math.max(max, map[c-\\'a\\']);\\n        }\\n        return a.length() - max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1032119,
                "title": "python-clean-solution",
                "content": "```\\nclass Solution(object):\\n    def minCharacters(self, a, b):\\n        \"\"\"\\n        :type a: str\\n        :type b: str\\n        :rtype: int\\n        \"\"\"\\n        import string \\n        dica = collections.Counter(a)\\n        dicb = collections.Counter(b)\\n        na = len(a)\\n        nb = len(b)\\n        ans = na + nb\\n        \\n        lsta = [0 for _ in range(26)] # number of letters smaller than or equal to \"a\", \"b\",... in the string a\\n        lstb = [0 for _ in range(26)]\\n        lsta[0] = dica[\"a\"]\\n        lstb[0] = dicb[\"a\"]\\n  \\n        for i in range(1, 26):\\n            lsta[i] = lsta[i-1] + dica[string.ascii_lowercase[i]]\\n            lstb[i] = lstb[i-1] + dicb[string.ascii_lowercase[i]]\\n \\n        for i in range(25):\\n            ans = min(ans, lsta[i] + nb - lstb[i], lstb[i] + na - lsta[i])\\n\\n  \\n        \\n        for char in string.ascii_lowercase:\\n            ans = min(ans, na+nb-dica[char]-dicb[char])\\n\\n        return ans\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def minCharacters(self, a, b):\\n        \"\"\"\\n        :type a: str\\n        :type b: str\\n        :rtype: int\\n        \"\"\"\\n        import string \\n        dica = collections.Counter(a)\\n        dicb = collections.Counter(b)\\n        na = len(a)\\n        nb = len(b)\\n        ans = na + nb\\n        \\n        lsta = [0 for _ in range(26)] # number of letters smaller than or equal to \"a\", \"b\",... in the string a\\n        lstb = [0 for _ in range(26)]\\n        lsta[0] = dica[\"a\"]\\n        lstb[0] = dicb[\"a\"]\\n  \\n        for i in range(1, 26):\\n            lsta[i] = lsta[i-1] + dica[string.ascii_lowercase[i]]\\n            lstb[i] = lstb[i-1] + dicb[string.ascii_lowercase[i]]\\n \\n        for i in range(25):\\n            ans = min(ans, lsta[i] + nb - lstb[i], lstb[i] + na - lsta[i])\\n\\n  \\n        \\n        for char in string.ascii_lowercase:\\n            ans = min(ans, na+nb-dica[char]-dicb[char])\\n\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1032115,
                "title": "java",
                "content": "```\\nclass Solution {\\n    public int minCharacters(String a, String b) {\\n        int test1 = Math.min(t1(a,b),t1(b,a));\\n        int test3 = t3(a,b);\\n        return Math.min(test1, test3);\\n        \\n    }\\n    \\n    public int t1(String a, String b){\\n        int res = Integer.MAX_VALUE;\\n        for(int i = 1; i < 26; i++){\\n            int count = 0;\\n            for(char c: a.toCharArray()){\\n                if(c-\\'a\\' >= i){\\n                    count++;\\n                }\\n            }\\n            \\n            for(char c: b.toCharArray()){\\n                if(c-\\'a\\' < i){\\n                    count++;\\n                }\\n            }\\n            res = Math.min(res, count);\\n        }\\n        return res;\\n    }\\n    \\n    \\n    public int t3(String a, String b){\\n        int total = a.length()+b.length();\\n        int[] check = new int[26];\\n        for(char c: a.toCharArray()){\\n            check[c-\\'a\\']++;\\n        }\\n        for(char c: b.toCharArray()){\\n            check[c-\\'a\\']++;\\n        }\\n        int max = 0;\\n        int freq = 0;\\n        for(int i : check){\\n            if(i > max){\\n                max = i;\\n                freq = i;\\n            }\\n\\t\\t\\t\\n        }\\n        return total-freq;\\n    }\\n}\\n\\t\\t\\t```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minCharacters(String a, String b) {\\n        int test1 = Math.min(t1(a,b),t1(b,a));\\n        int test3 = t3(a,b);\\n        return Math.min(test1, test3);\\n        \\n    }\\n    \\n    public int t1(String a, String b){\\n        int res = Integer.MAX_VALUE;\\n        for(int i = 1; i < 26; i++){\\n            int count = 0;\\n            for(char c: a.toCharArray()){\\n                if(c-\\'a\\' >= i){\\n                    count++;\\n                }\\n            }\\n            \\n            for(char c: b.toCharArray()){\\n                if(c-\\'a\\' < i){\\n                    count++;\\n                }\\n            }\\n            res = Math.min(res, count);\\n        }\\n        return res;\\n    }\\n    \\n    \\n    public int t3(String a, String b){\\n        int total = a.length()+b.length();\\n        int[] check = new int[26];\\n        for(char c: a.toCharArray()){\\n            check[c-\\'a\\']++;\\n        }\\n        for(char c: b.toCharArray()){\\n            check[c-\\'a\\']++;\\n        }\\n        int max = 0;\\n        int freq = 0;\\n        for(int i : check){\\n            if(i > max){\\n                max = i;\\n                freq = i;\\n            }\\n\\t\\t\\t\\n        }\\n        return total-freq;\\n    }\\n}\\n\\t\\t\\t```",
                "codeTag": "Java"
            },
            {
                "id": 1032100,
                "title": "python-120ms-faster-than-100",
                "content": "```\\nclass Solution:\\n    def minCharacters(self, a: str, b: str) -> int:\\n        ca = Counter(a)\\n        cb = Counter(b)\\n        r1 = min(min(ord(k) for k in ca.keys()), min(ord(k) for k in cb.keys()))\\n        r2 = max(max(ord(k) for k in ca.keys()), max(ord(k) for k in cb.keys()))\\n        if r2 != ord(\\'z\\'): r2 += 1 # edgecase here: the iteration of chi below cannot involve \\'z\\'\\n\\t\\t# chi is the threshold that all ch in a is less than or equal to chi, and all ch in b is larger than chi\\n        def alessb(ca, cb):\\n            res = float(\\'inf\\')\\n            for chi in range(r1, r2):\\n                ch = chr(chi)\\n                if ch not in ca and ch not in cb: continue\\n                res = min(res, sum(v if ord(k) > chi else 0 for k, v in ca.items()) + sum(v if ord(k) <= chi else 0 for k, v in cb.items()))\\n            return res\\n        res = min(alessb(ca, cb), alessb(cb, ca))\\n        return min(res, len(a) + len(b) - max(ca.get(chr(chi), 0) + cb.get(chr(chi), 0) for chi in range(ord(\\'a\\'), ord(\\'z\\') + 1)))\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minCharacters(self, a: str, b: str) -> int:\\n        ca = Counter(a)\\n        cb = Counter(b)\\n        r1 = min(min(ord(k) for k in ca.keys()), min(ord(k) for k in cb.keys()))\\n        r2 = max(max(ord(k) for k in ca.keys()), max(ord(k) for k in cb.keys()))\\n        if r2 != ord(\\'z\\'): r2 += 1 # edgecase here: the iteration of chi below cannot involve \\'z\\'\\n\\t\\t# chi is the threshold that all ch in a is less than or equal to chi, and all ch in b is larger than chi\\n        def alessb(ca, cb):\\n            res = float(\\'inf\\')\\n            for chi in range(r1, r2):\\n                ch = chr(chi)\\n                if ch not in ca and ch not in cb: continue\\n                res = min(res, sum(v if ord(k) > chi else 0 for k, v in ca.items()) + sum(v if ord(k) <= chi else 0 for k, v in cb.items()))\\n            return res\\n        res = min(alessb(ca, cb), alessb(cb, ca))\\n        return min(res, len(a) + len(b) - max(ca.get(chr(chi), 0) + cb.get(chr(chi), 0) for chi in range(ord(\\'a\\'), ord(\\'z\\') + 1)))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1032090,
                "title": "c-bucket",
                "content": "\\tclass Solution {\\n\\tpublic:\\n\\t\\tint minCharacters(string a, string b) {\\n\\n\\t\\t\\tvector<int> arrA(26,0);\\n\\t\\t\\tvector<int> arrB(26,0);\\n\\t\\t\\tint ans = INT_MAX;\\n\\t\\t\\tint lenA = a.size(), curA = 0;\\n\\t\\t\\tint lenB = b.size(), curB = 0;\\n\\t\\t\\tfor(char c : a) arrA[ c - \\'a\\' ]++;\\n\\t\\t\\tfor(char c : b) arrB[ c - \\'a\\' ]++;\\n\\t\\t\\tfor(int i = 0;i < 26; i++){\\n\\t\\t\\t\\tcurA += arrA[i];\\n\\t\\t\\t\\tcurB += arrB[i];\\n\\t\\t\\t\\tif( i != 25 ){\\n\\t\\t\\t\\t\\tans = min( ans, lenA - curA + curB );\\n\\t\\t\\t\\t\\tans = min( ans, lenB - curB + curA );\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tans = min( ans, ( lenA - arrA[i] + lenB - arrB[i] ) );\\n\\t\\t\\t}\\n\\t\\t\\treturn ans;\\n\\t\\t}\\n\\t};",
                "solutionTags": [],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tint minCharacters(string a, string b) {\\n\\n\\t\\t\\tvector<int> arrA(26,0);\\n\\t\\t\\tvector<int> arrB(26,0);\\n\\t\\t\\tint ans = INT_MAX;\\n\\t\\t\\tint lenA = a.size(), curA = 0;\\n\\t\\t\\tint lenB = b.size(), curB = 0;\\n\\t\\t\\tfor(char c : a) arrA[ c - \\'a\\' ]++;\\n\\t\\t\\tfor(char c : b) arrB[ c - \\'a\\' ]++;\\n\\t\\t\\tfor(int i = 0;i < 26; i++){\\n\\t\\t\\t\\tcurA += arrA[i];\\n\\t\\t\\t\\tcurB += arrB[i];\\n\\t\\t\\t\\tif( i != 25 ){\\n\\t\\t\\t\\t\\tans = min( ans, lenA - curA + curB );\\n\\t\\t\\t\\t\\tans = min( ans, lenB - curB + curA );\\n\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1032065,
                "title": "python-beat-100-propagate-from-middle",
                "content": "The idea is to propagate from the concatnation point of a and b, iterate through 26 lowercase letters.\\n```\\nclass Solution:\\n    def minCharacters(self, a: str, b: str) -> int:\\n        m, n = len(a), len(b)\\n        c1 = collections.Counter(a)\\n        c2 = collections.Counter(b)\\n        \\n        a, b = [], []\\n        for i in range(26):\\n            c = chr(i + ord(\\'a\\'))\\n            if c1[c]:\\n                a.append([c, c1[c]])\\n            if c2[c]:\\n                b.append([c, c2[c]])\\n        \\n        #C3:\\n        move = m + n\\n        for i in range(26):\\n            c = chr(i + ord(\\'a\\'))\\n            move = min(move, m + n - c1[c] - c2[c])\\n        \\n        #C1 and C2:\\n        for i in range(1, 26):\\n            c = chr(i + ord(\\'a\\'))\\n            #a + b\\n            ai, bi, m1 = len(a) - 1, 0, 0\\n            while ai >= 0 and a[ai][0] >= c:\\n                m1 += a[ai][1]\\n                ai -= 1\\n            while bi < len(b) and b[bi][0] < c:\\n                m1 += b[bi][1]\\n                bi += 1\\n            move = min(move, m1)\\n            #b + a\\n            ai, bi, m2 = 0, len(b) - 1, 0\\n            while bi >= 0 and b[bi][0] >= c:\\n                m2 += b[bi][1]\\n                bi -= 1\\n            while ai < len(a) and a[ai][0] < c:\\n                m2 += a[ai][1]\\n                ai += 1\\n            move = min(move, m2)\\n        \\n        return move\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minCharacters(self, a: str, b: str) -> int:\\n        m, n = len(a), len(b)\\n        c1 = collections.Counter(a)\\n        c2 = collections.Counter(b)\\n        \\n        a, b = [], []\\n        for i in range(26):\\n            c = chr(i + ord(\\'a\\'))\\n            if c1[c]:\\n                a.append([c, c1[c]])\\n            if c2[c]:\\n                b.append([c, c2[c]])\\n        \\n        #C3:\\n        move = m + n\\n        for i in range(26):\\n            c = chr(i + ord(\\'a\\'))\\n            move = min(move, m + n - c1[c] - c2[c])\\n        \\n        #C1 and C2:\\n        for i in range(1, 26):\\n            c = chr(i + ord(\\'a\\'))\\n            #a + b\\n            ai, bi, m1 = len(a) - 1, 0, 0\\n            while ai >= 0 and a[ai][0] >= c:\\n                m1 += a[ai][1]\\n                ai -= 1\\n            while bi < len(b) and b[bi][0] < c:\\n                m1 += b[bi][1]\\n                bi += 1\\n            move = min(move, m1)\\n            #b + a\\n            ai, bi, m2 = 0, len(b) - 1, 0\\n            while bi >= 0 and b[bi][0] >= c:\\n                m2 += b[bi][1]\\n                bi -= 1\\n            while ai < len(a) and a[ai][0] < c:\\n                m2 += a[ai][1]\\n                ai += 1\\n            move = min(move, m2)\\n        \\n        return move\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1032055,
                "title": "python3-scan-through-a-z-w-prefix",
                "content": "**Algo**\\nAssume character `x` would become the separator for `a <= x < b` or `b <= x < a`. By varing `x` from `\"a\"` to `\"z\"`, we can find the minimum changes. \\n\\n**Implementation**\\n```\\nclass Solution:\\n    def minCharacters(self, a: str, b: str) -> int:\\n        pa, pb = [0]*26, [0]*26\\n        for x in a: pa[ord(x)-97] += 1\\n        for x in b: pb[ord(x)-97] += 1\\n        \\n        ans = len(a) - max(pa) + len(b) - max(pb) # condition 3\\n        for i in range(25): \\n            pa[i+1] += pa[i]\\n            pb[i+1] += pb[i]\\n            ans = min(ans, pa[i] + len(b) - pb[i]) # condition 2\\n            ans = min(ans, len(a) - pa[i] + pb[i]) # condition 1\\n        return ans \\n```\\n\\n**Analysis**\\nTime complexity `O(N)`\\nSpace complexity `O(1)`",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minCharacters(self, a: str, b: str) -> int:\\n        pa, pb = [0]*26, [0]*26\\n        for x in a: pa[ord(x)-97] += 1\\n        for x in b: pb[ord(x)-97] += 1\\n        \\n        ans = len(a) - max(pa) + len(b) - max(pb) # condition 3\\n        for i in range(25): \\n            pa[i+1] += pa[i]\\n            pb[i+1] += pb[i]\\n            ans = min(ans, pa[i] + len(b) - pb[i]) # condition 2\\n            ans = min(ans, len(a) - pa[i] + pb[i]) # condition 1\\n        return ans \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1032044,
                "title": "python-loop-through-separating-letter",
                "content": "**Note that letters can\\'t be smaller than \\'a\\' or bigger than \\'z\\'**\\n\\nIt takes me more than half an hour and several WAs to realize this :(\\n\\n```py\\nclass Solution:\\n    def minCharacters(self, a: str, b: str) -> int:\\n        cn1, cn2 = [0] * 26, [0] * 26\\n        for c in a: cn1[ord(c)-97] += 1\\n        for c in b: cn2[ord(c)-97] += 1\\n        \\n        ans = len(a) + len(b) - max(x + y for x, y in zip(cn1, cn2)) # condition 3\\n        for i in range(1, 26):  # note that letters can\\'t be smaller than \\'a\\' or bigger than \\'z\\'\\n            ans = min(ans, sum(cn1[:i]) + sum(cn2[i:]), sum(cn1[i:]) + sum(cn2[:i]))\\n        return ans\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```py\\nclass Solution:\\n    def minCharacters(self, a: str, b: str) -> int:\\n        cn1, cn2 = [0] * 26, [0] * 26\\n        for c in a: cn1[ord(c)-97] += 1\\n        for c in b: cn2[ord(c)-97] += 1\\n        \\n        ans = len(a) + len(b) - max(x + y for x, y in zip(cn1, cn2)) # condition 3\\n        for i in range(1, 26):  # note that letters can\\'t be smaller than \\'a\\' or bigger than \\'z\\'\\n            ans = min(ans, sum(cn1[:i]) + sum(cn2[i:]), sum(cn1[i:]) + sum(cn2[:i]))\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3947076,
                "title": "count-and-prefixsum",
                "content": "# Intuition\\nCount and prefixSum\\n\\n# Approach\\nno order related to string a and b\\nlet\\'s cover all possible combination.\\n\\nprecalculate prefix1 and prefix2;\\n\\nif we select one letter in prefix2 as the min char , **prefix1 should\\nconvert any of chars that grater or equal to this char  to strict less than this char(prefix1[26]-prefix1[i-1]) , and any chars less than this char in prefix2 should convert to this char (prefix2[i-1]), so it lead to prefix1[26]-prefix1[i-1]+prefix2[i-1]**\\n\\nit covers all possibilities that any char as min char in prefix2\\n\\nso we caculate twice one for condition 1 , one for condition 2\\n\\nto meet condition 3:\\nwe just to know the max frequency of char in  a plus b\\nwe need to convert other char to this\\n\\n# Complexity\\n- Time complexity:\\nm+n\\n\\n- Space complexity:\\nO(1)  -- 26 chars\\n# Code\\n```\\nclass Solution {\\n    public int minCharacters(String a, String b) {\\n        int[] c1=new int[26];\\n        int[] c2=new int[26];\\n        for(int i=0;i<a.length();i++){\\n            c1[a.charAt(i)-\\'a\\']++;\\n        }\\n        for(int j=0;j<b.length();j++){\\n            c2[b.charAt(j)-\\'a\\']++;\\n        }\\n\\n        int[] prefix1=new int[c1.length+1];\\n        int[] prefix2=new int[c2.length+1];\\n        int max=0;\\n        for(int i=1;i<c1.length+1;i++){\\n            prefix1[i]=prefix1[i-1]+c1[i-1];\\n            prefix2[i]=prefix2[i-1]+c2[i-1];\\n            max=Math.max(c1[i-1]+c2[i-1],max);\\n        }\\n        var res1=min(prefix1,prefix2);\\n        var res2=min(prefix2,prefix1);\\n        var res3=prefix1[26]+prefix2[26]-max;\\n        return Math.min(Math.min(res1,res2),res3);\\n    }\\n\\n    private int min(int[] prefix1,int[] prefix2){\\n        int res=Integer.MAX_VALUE;\\n        for(int i=2;i<prefix2.length;i++){\\n            res=Math.min(res,prefix1[26]-prefix1[i-1]+prefix2[i-1]);\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minCharacters(String a, String b) {\\n        int[] c1=new int[26];\\n        int[] c2=new int[26];\\n        for(int i=0;i<a.length();i++){\\n            c1[a.charAt(i)-\\'a\\']++;\\n        }\\n        for(int j=0;j<b.length();j++){\\n            c2[b.charAt(j)-\\'a\\']++;\\n        }\\n\\n        int[] prefix1=new int[c1.length+1];\\n        int[] prefix2=new int[c2.length+1];\\n        int max=0;\\n        for(int i=1;i<c1.length+1;i++){\\n            prefix1[i]=prefix1[i-1]+c1[i-1];\\n            prefix2[i]=prefix2[i-1]+c2[i-1];\\n            max=Math.max(c1[i-1]+c2[i-1],max);\\n        }\\n        var res1=min(prefix1,prefix2);\\n        var res2=min(prefix2,prefix1);\\n        var res3=prefix1[26]+prefix2[26]-max;\\n        return Math.min(Math.min(res1,res2),res3);\\n    }\\n\\n    private int min(int[] prefix1,int[] prefix2){\\n        int res=Integer.MAX_VALUE;\\n        for(int i=2;i<prefix2.length;i++){\\n            res=Math.min(res,prefix1[26]-prefix1[i-1]+prefix2[i-1]);\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3924923,
                "title": "python-solution-beats-78-41",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def minCharacters(self, a: str, b: str) -> int:\\n        la=[0]*26       \\n        lb=[0]*26\\n        i0=ord(\\'a\\')       \\n        for c in a:\\n            la[ord(c)-i0]+=1\\n        for c in b:\\n            lb[ord(c)-i0]+=1\\n\\n        da=sum(la)\\n        db=sum(lb)\\n        res=da+db-max(la)-max(lb)\\n        for i in range(25):\\n            da+=lb[i]-la[i]\\n            db+=la[i]-lb[i]\\n            res=min(res,da,db)\\n        return res\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minCharacters(self, a: str, b: str) -> int:\\n        la=[0]*26       \\n        lb=[0]*26\\n        i0=ord(\\'a\\')       \\n        for c in a:\\n            la[ord(c)-i0]+=1\\n        for c in b:\\n            lb[ord(c)-i0]+=1\\n\\n        da=sum(la)\\n        db=sum(lb)\\n        res=da+db-max(la)-max(lb)\\n        for i in range(25):\\n            da+=lb[i]-la[i]\\n            db+=la[i]-lb[i]\\n            res=min(res,da,db)\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3924333,
                "title": "python3-o-n-solution-use-two-counter-of-chars",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n#from collections import Counter\\nclass Solution:\\n    def minCharacters(self, a: str, b: str) -> int:\\n        ct1, ct2 = [0] * 26, [0] * 26\\n        def countChars(s, arr):\\n            for c in s:\\n                arr[ord(c) - ord(\\'a\\')] += 1\\n        \\n        countChars(a, ct1)\\n        countChars(b, ct2)\\n        ans = len(a) + len(b)\\n        def makeStrictLess(arr1, arr2):\\n            ans = float(\\'inf\\')\\n            for i in range(26):\\n                # set all char less or equal to i-th char\\n                cnt1 = 0\\n                for k in range(26):\\n                    if k > i:\\n                        cnt1 += arr1[k]\\n                \\n                for j in range(i + 1, 26):\\n                    # # set all char greater or equal to j-th char\\n                    cnt2 = 0\\n                    for k in range(26):\\n                        if k < j:\\n                            cnt2 += arr2[k]\\n                    ans = min(ans, cnt1 + cnt2)\\n            return ans\\n        ans = min(ans, makeStrictLess(ct1, ct2), makeStrictLess(ct2, ct1), len(a) + len(b) - max(ct1) - max(ct2))\\n        return ans\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n#from collections import Counter\\nclass Solution:\\n    def minCharacters(self, a: str, b: str) -> int:\\n        ct1, ct2 = [0] * 26, [0] * 26\\n        def countChars(s, arr):\\n            for c in s:\\n                arr[ord(c) - ord(\\'a\\')] += 1\\n        \\n        countChars(a, ct1)\\n        countChars(b, ct2)\\n        ans = len(a) + len(b)\\n        def makeStrictLess(arr1, arr2):\\n            ans = float(\\'inf\\')\\n            for i in range(26):\\n                # set all char less or equal to i-th char\\n                cnt1 = 0\\n                for k in range(26):\\n                    if k > i:\\n                        cnt1 += arr1[k]\\n                \\n                for j in range(i + 1, 26):\\n                    # # set all char greater or equal to j-th char\\n                    cnt2 = 0\\n                    for k in range(26):\\n                        if k < j:\\n                            cnt2 += arr2[k]\\n                    ans = min(ans, cnt1 + cnt2)\\n            return ans\\n        ans = min(ans, makeStrictLess(ct1, ct2), makeStrictLess(ct2, ct1), len(a) + len(b) - max(ct1) - max(ct2))\\n        return ans\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3719424,
                "title": "simple-solution-with-hashmap",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n# Code\\n```\\nclass Solution:\\n    def minCharacters(self, a: str, b: str) -> int:\\n        counter_a = Counter(ord(ch) - ord(\\'a\\') for ch in a)\\n        counter_b = Counter(ord(ch) - ord(\\'a\\') for ch in b)        \\n        unique = len(a) - max(counter_a.values()) + len(b) - max(counter_b.values())\\n        #print(counter_a,counter_b, unique)\\n        min_a = min_b = len(a) + len(b)\\n        for i in range(25):\\n            counter_a[i] += counter_a[i-1]\\n            counter_b[i] += counter_b[i-1]\\n            min_a = min(min_a , len(a) - counter_a[i] + counter_b[i])\\n            min_b = min(min_b , len(b) - counter_b[i] + counter_a[i])\\n\\n        return min(min_a,min_b,unique)        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minCharacters(self, a: str, b: str) -> int:\\n        counter_a = Counter(ord(ch) - ord(\\'a\\') for ch in a)\\n        counter_b = Counter(ord(ch) - ord(\\'a\\') for ch in b)        \\n        unique = len(a) - max(counter_a.values()) + len(b) - max(counter_b.values())\\n        #print(counter_a,counter_b, unique)\\n        min_a = min_b = len(a) + len(b)\\n        for i in range(25):\\n            counter_a[i] += counter_a[i-1]\\n            counter_b[i] += counter_b[i-1]\\n            min_a = min(min_a , len(a) - counter_a[i] + counter_b[i])\\n            min_b = min(min_b , len(b) - counter_b[i] + counter_a[i])\\n\\n        return min(min_a,min_b,unique)        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3645157,
                "title": "prefix-sum-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minCharacters(string a, string b) {\\n        sort(a.begin(),a.end());\\n        sort(b.begin(),b.end());\\n        int n=a.size(),m=b.size();\\n        vector<int>prefa(26),prefb(26),sufa(26),sufb(26);\\n        vector<int>arr(26),brr(26);\\n        for(int i=0;i<a.size();i++){\\n            arr[a[i]-\\'a\\']++;\\n        }\\n        for(int i=0;i<b.size();i++){\\n            brr[b[i]-\\'a\\']++;\\n        }\\n        int cnt=INT_MAX;\\n        //calculating for third condition\\n        for(int i=0;i<26;i++){\\n            cnt=min(cnt,n+m-arr[i]-brr[i]);\\n        }\\n        //now, for second and third\\n        prefa[0]=arr[0];\\n        prefb[0]=brr[0];\\n        for(int i=1;i<26;i++){\\n            prefa[i]=prefa[i-1]+arr[i];\\n            prefb[i]=prefb[i-1]+brr[i];\\n        }\\n        sufa[25]=arr[25];\\n        sufb[25]=brr[25];\\n        for(int i=24;i>=0;i--){\\n            sufa[i]=arr[i]+sufa[i+1];\\n            sufb[i]=brr[i]+sufb[i+1];\\n        }\\n        //moving b to the right, i.e., b>a\\n        for(int i=25;i>=1;i--){\\n            cnt=min(cnt,prefb[i-1]+sufa[i]);\\n        }\\n        //moving a to the right, i.e., a>b;\\n        for(int i=25;i>=1;i--){\\n            cnt=min(cnt,prefa[i-1]+sufb[i]);\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minCharacters(string a, string b) {\\n        sort(a.begin(),a.end());\\n        sort(b.begin(),b.end());\\n        int n=a.size(),m=b.size();\\n        vector<int>prefa(26),prefb(26),sufa(26),sufb(26);\\n        vector<int>arr(26),brr(26);\\n        for(int i=0;i<a.size();i++){\\n            arr[a[i]-\\'a\\']++;\\n        }\\n        for(int i=0;i<b.size();i++){\\n            brr[b[i]-\\'a\\']++;\\n        }\\n        int cnt=INT_MAX;\\n        //calculating for third condition\\n        for(int i=0;i<26;i++){\\n            cnt=min(cnt,n+m-arr[i]-brr[i]);\\n        }\\n        //now, for second and third\\n        prefa[0]=arr[0];\\n        prefb[0]=brr[0];\\n        for(int i=1;i<26;i++){\\n            prefa[i]=prefa[i-1]+arr[i];\\n            prefb[i]=prefb[i-1]+brr[i];\\n        }\\n        sufa[25]=arr[25];\\n        sufb[25]=brr[25];\\n        for(int i=24;i>=0;i--){\\n            sufa[i]=arr[i]+sufa[i+1];\\n            sufb[i]=brr[i]+sufb[i+1];\\n        }\\n        //moving b to the right, i.e., b>a\\n        for(int i=25;i>=1;i--){\\n            cnt=min(cnt,prefb[i-1]+sufa[i]);\\n        }\\n        //moving a to the right, i.e., a>b;\\n        for(int i=25;i>=1;i--){\\n            cnt=min(cnt,prefa[i-1]+sufb[i]);\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3629856,
                "title": "alternative-binary-search-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def minCharacters(self, a: str, b: str) -> int:\\n        ca, cb = Counter(a), Counter(b)\\n\\n        o3 = (len(a) - ca.most_common()[0][1]) + (len(b) - cb.most_common()[0][1])\\n        a = list(sorted(a))\\n        b = list(sorted(b))\\n        a_rev = list(reversed(a))\\n        b_rev = list(reversed(b))\\n\\n        def find(A, B, order=1, skip=\\'z\\'):\\n            res = inf\\n            for i in range(len(A)- 1,-1,-1):\\n                if A[i] == skip:\\n                    continue\\n\\n                idx = bisect.bisect_right(B, A[i], key=lambda x: order * x)\\n                res = min(res, (len(A) - i - 1) + idx)\\n            return res\\n\\n        return min(\\n                find(a, b),\\n                find(b, a),\\n                find(a_rev, b_rev, -1, \\'a\\'),\\n                find(b_rev, a_rev, -1, \\'a\\'),\\n            o3)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minCharacters(self, a: str, b: str) -> int:\\n        ca, cb = Counter(a), Counter(b)\\n\\n        o3 = (len(a) - ca.most_common()[0][1]) + (len(b) - cb.most_common()[0][1])\\n        a = list(sorted(a))\\n        b = list(sorted(b))\\n        a_rev = list(reversed(a))\\n        b_rev = list(reversed(b))\\n\\n        def find(A, B, order=1, skip=\\'z\\'):\\n            res = inf\\n            for i in range(len(A)- 1,-1,-1):\\n                if A[i] == skip:\\n                    continue\\n\\n                idx = bisect.bisect_right(B, A[i], key=lambda x: order * x)\\n                res = min(res, (len(A) - i - 1) + idx)\\n            return res\\n\\n        return min(\\n                find(a, b),\\n                find(b, a),\\n                find(a_rev, b_rev, -1, \\'a\\'),\\n                find(b_rev, a_rev, -1, \\'a\\'),\\n            o3)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3536438,
                "title": "simple-go-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(N)\\n- Space complexity:\\nO(1)\\n# Code\\n```\\nfunc minCharacters(a string, b string) int {\\n    m, n := len(a), len(b)\\n    ans := m + n\\n    c1, c2 := [26]int{}, [26]int{}\\n    for _,r := range a {\\n        c1[r - \\'a\\']++\\n    }\\n    for _,r := range b {\\n        c2[r - \\'a\\']++\\n    }\\n    for i := 0; i < 26; i++ {\\n        ans = min(ans, m + n - c1[i] - c2[i])\\n        if (i!=0) {\\n            c1[i] += c1[i-1]\\n            c2[i] += c2[i-1]\\n        }\\n        if (i != 25) {\\n            ans = min(ans, m - c1[i] + c2[i])\\n            ans = min(ans, n - c2[i] + c1[i])\\n        }\\n    }\\n    return ans\\n}\\n\\nfunc min(a,b int) int {\\n    if a<b {return a}\\n    return b\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc minCharacters(a string, b string) int {\\n    m, n := len(a), len(b)\\n    ans := m + n\\n    c1, c2 := [26]int{}, [26]int{}\\n    for _,r := range a {\\n        c1[r - \\'a\\']++\\n    }\\n    for _,r := range b {\\n        c2[r - \\'a\\']++\\n    }\\n    for i := 0; i < 26; i++ {\\n        ans = min(ans, m + n - c1[i] - c2[i])\\n        if (i!=0) {\\n            c1[i] += c1[i-1]\\n            c2[i] += c2[i-1]\\n        }\\n        if (i != 25) {\\n            ans = min(ans, m - c1[i] + c2[i])\\n            ans = min(ans, n - c2[i] + c1[i])\\n        }\\n    }\\n    return ans\\n}\\n\\nfunc min(a,b int) int {\\n    if a<b {return a}\\n    return b\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3530690,
                "title": "c-solution-with-explanation",
                "content": "# EXPLANATION\\nThis is an interesting question.\\nAt first we created 2 vector to store frequency of letters in string **a** and **b**.\\nCreated min1 and max1 to store smallest and biggest alphabet in string **a**.\\nCreated min2 and max2 to store smallest and biggest alphabet in string **b**.\\nTraversed in string **a** and **b** and stored frequency in respective vectors and stored smallest and largest letter.\\nIn next loop we stored the frequency sum in t1 and t2 for **b-y**.\\nWe checked every case from left to right then again right to left for conversion to meet the first or second condition only.\\nFinally checked for the 3rd condition of all same letters and finally returned the answer.\\n# SOLUTION\\n```\\nclass Solution {\\npublic:\\n    int minCharacters(string a, string b) {\\n        char min1=a[0],max1=a[0];\\n        char min2=b[0],max2=b[0];\\n        vector<int> l1(26),l2(26);\\n        int ans=0;\\n        for(auto x:a){\\n            min1=min(x,min1);\\n            max1=max(x,max1);\\n            l1[x-97]++;\\n        }\\n        for(auto x:b){\\n            min2=min(x,min2);\\n            max2=max(x,max2);\\n            l2[x-97]++;\\n        }\\n        if(min1>max2 || min2>max1)\\n            return 0;\\n        int t1=0,t2=0;\\n        for(int i=1;i<25;i++){\\n            t1+=l1[i];\\n            t2+=l2[i];\\n        }\\n        int s1=l1[0],s2=t2+l2[25];\\n        int e1=l2[0],e2=t1+l1[25];\\n        ans=min(s1+s2,e1+e2);\\n        for(int i=1;i<25;i++){\\n            s1+=l1[i];\\n            s2-=l2[i];\\n            e1+=l2[i];\\n            e2-=l1[i];\\n            ans=min(ans,s1+s2);\\n            ans=min(ans,e1+e2);\\n        }\\n        s1=l1[0]+t1,s2=l2[25];\\n        e1=l2[0]+t2,e2=l1[25];\\n        ans=min(ans,s1+s2);\\n        ans=min(ans,e1+e2);\\n        for(int i=24;i>0;i--){\\n            s1-=l1[i];\\n            s2+=l2[i];\\n            e1-=l2[i];\\n            e2+=l1[i];\\n            ans=min(ans,s1+s2);\\n            ans=min(ans,e1+e2);\\n        }\\n        int n=a.size()+b.size();\\n        for(int i=0;i<26;i++)\\n            ans=min(ans,n-(l1[i]+l2[i]));\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String",
                    "Counting",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minCharacters(string a, string b) {\\n        char min1=a[0],max1=a[0];\\n        char min2=b[0],max2=b[0];\\n        vector<int> l1(26),l2(26);\\n        int ans=0;\\n        for(auto x:a){\\n            min1=min(x,min1);\\n            max1=max(x,max1);\\n            l1[x-97]++;\\n        }\\n        for(auto x:b){\\n            min2=min(x,min2);\\n            max2=max(x,max2);\\n            l2[x-97]++;\\n        }\\n        if(min1>max2 || min2>max1)\\n            return 0;\\n        int t1=0,t2=0;\\n        for(int i=1;i<25;i++){\\n            t1+=l1[i];\\n            t2+=l2[i];\\n        }\\n        int s1=l1[0],s2=t2+l2[25];\\n        int e1=l2[0],e2=t1+l1[25];\\n        ans=min(s1+s2,e1+e2);\\n        for(int i=1;i<25;i++){\\n            s1+=l1[i];\\n            s2-=l2[i];\\n            e1+=l2[i];\\n            e2-=l1[i];\\n            ans=min(ans,s1+s2);\\n            ans=min(ans,e1+e2);\\n        }\\n        s1=l1[0]+t1,s2=l2[25];\\n        e1=l2[0]+t2,e2=l1[25];\\n        ans=min(ans,s1+s2);\\n        ans=min(ans,e1+e2);\\n        for(int i=24;i>0;i--){\\n            s1-=l1[i];\\n            s2+=l2[i];\\n            e1-=l2[i];\\n            e2+=l1[i];\\n            ans=min(ans,s1+s2);\\n            ans=min(ans,e1+e2);\\n        }\\n        int n=a.size()+b.size();\\n        for(int i=0;i<26;i++)\\n            ans=min(ans,n-(l1[i]+l2[i]));\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3387925,
                "title": "java-clean-code-and-good-explanations",
                "content": "# Approach\\n1. Count the letters of A and B into 2 ints[] countA[] and countB[].\\nFor better performance, also compute the prefixSum of the count and use countA[][] (row0 - count, row1- prefixSum)\\n2. The solution is a min between 3 options: I) make both strings only one distinct letter, II) make a < b or III) b < a.\\n3. Make both string only one distinch letter.\\nKnowing the count of each letter,  aabbcdcdeedc = [2,2,3,3,2....] = total 12 & abcdde = [1,1,1,2,1] = total 6\\n    - iterate over each letter and determine the cost of making all the other letters of string a and b match that letter\\n    - EG: cost to make all letters of str1 to match a = 12 - 2 = 10;\\n    cost to make all letter of str2 to match a = 6 - 1 = 5.\\n    - We can see the min is given by making all letters matching c: (12 - 3) + (6-2) = 13.\\n4. Make a less than b (applicable to b less than a, you just swap the input prefixSum)\\n    - Iterate from 24 to 0 (y to a) and determine the cost of eliminating all letters greater than [24] (y) from strA and all letters lesser or equal to [24] from strB.\\n    - You can find this out by using prefix sum.\\n    - Loop this for each letter Y - A and return the minimum. \\n5. Return the min of all these 3 methods, unless one of them is 0.\\n\\n# Complexity\\n- Time complexity:$$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(26 * 4)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minCharacters(String a, String b) {\\n        int[][] countAndPrefixA = getCountAndPrefix(a);\\n        int[][] countAndPrefixB = getCountAndPrefix(b);\\n        int min = makeOnlyOneDistinct(countAndPrefixA[0], countAndPrefixB[0], countAndPrefixA[1][25] + countAndPrefixB[1][25]);\\n        if (min > 0) {\\n            min = Math.min(min, makeLessThan(countAndPrefixA[1], countAndPrefixB[1]));\\n        }\\n        if (min > 0) {\\n            min = Math.min(min, makeLessThan(countAndPrefixB[1], countAndPrefixA[1]));\\n        }\\n        return min;\\n    }\\n\\n    private int makeOnlyOneDistinct(int[] countA, int[] countB, int total) {\\n        int min = Integer.MAX_VALUE;\\n        for (int i = 0; i < countA.length; i++) {\\n            min = Math.min(min, total - (countA[i] + countB[i]));\\n        }\\n        return min;\\n    }\\n\\n    private int makeLessThan(int[] prefixA, int[] prefixB) {\\n        int min = Integer.MAX_VALUE;\\n        int removeFromA, removeFromB;\\n        for (int i = 24; i >= 0; i--) {\\n            removeFromA = prefixA[25] - prefixA[i];\\n            removeFromB = prefixB[i];\\n            min = Math.min(min, removeFromA + removeFromB);\\n        }\\n        return min;\\n    }\\n\\n    private int[][] getCountAndPrefix(String str) {\\n        int[][] countAndPrefix = new int[2][26];\\n        for (int i = 0; i < str.length(); i++) {\\n            countAndPrefix[0][str.charAt(i) - \\'a\\']++;\\n        }\\n        int prefix = 0;\\n        for (int i = 0; i < countAndPrefix[0].length; i++) {\\n            prefix += countAndPrefix[0][i];\\n            countAndPrefix[1][i] = prefix;\\n        }\\n        return countAndPrefix;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\n    public int minCharacters(String a, String b) {\\n        int[][] countAndPrefixA = getCountAndPrefix(a);\\n        int[][] countAndPrefixB = getCountAndPrefix(b);\\n        int min = makeOnlyOneDistinct(countAndPrefixA[0], countAndPrefixB[0], countAndPrefixA[1][25] + countAndPrefixB[1][25]);\\n        if (min > 0) {\\n            min = Math.min(min, makeLessThan(countAndPrefixA[1], countAndPrefixB[1]));\\n        }\\n        if (min > 0) {\\n            min = Math.min(min, makeLessThan(countAndPrefixB[1], countAndPrefixA[1]));\\n        }\\n        return min;\\n    }\\n\\n    private int makeOnlyOneDistinct(int[] countA, int[] countB, int total) {\\n        int min = Integer.MAX_VALUE;\\n        for (int i = 0; i < countA.length; i++) {\\n            min = Math.min(min, total - (countA[i] + countB[i]));\\n        }\\n        return min;\\n    }\\n\\n    private int makeLessThan(int[] prefixA, int[] prefixB) {\\n        int min = Integer.MAX_VALUE;\\n        int removeFromA, removeFromB;\\n        for (int i = 24; i >= 0; i--) {\\n            removeFromA = prefixA[25] - prefixA[i];\\n            removeFromB = prefixB[i];\\n            min = Math.min(min, removeFromA + removeFromB);\\n        }\\n        return min;\\n    }\\n\\n    private int[][] getCountAndPrefix(String str) {\\n        int[][] countAndPrefix = new int[2][26];\\n        for (int i = 0; i < str.length(); i++) {\\n            countAndPrefix[0][str.charAt(i) - \\'a\\']++;\\n        }\\n        int prefix = 0;\\n        for (int i = 0; i < countAndPrefix[0].length; i++) {\\n            prefix += countAndPrefix[0][i];\\n            countAndPrefix[1][i] = prefix;\\n        }\\n        return countAndPrefix;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3359136,
                "title": "cpp-easy",
                "content": "class Solution \\n{\\npublic:\\n    int minCharacters(string a, string b) \\n    {\\n         vector<int>u1(26,0),u2(26,0);\\n         for(int i=0;i<a.length();++i)\\n         {\\n             ++u1[a[i]-\\'a\\'];\\n         }\\n        \\n        for(int i=0;i<b.length();++i)\\n         {\\n             ++u2[b[i]-\\'a\\'];\\n         }\\n        int l1=accumulate(u1.begin(),u1.end(),0);\\n        int l2=accumulate(u2.begin(),u2.end(),0);\\n        int l=l1+l2;\\n        int s1=0;\\n        int s2=0;\\n        int mv=INT_MAX;\\n        for(int i=0;i<25;++i)\\n        {\\n            s1+=u1[i];\\n            s2+=u2[i];\\n            l1-=u1[i];\\n            l2-=u2[i];\\n           \\n            mv=min(mv,min(s2+l1,min(s1+l2,l-u1[i]-u2[i])));\\n        }\\n        mv=min(mv,l-u1[25]-u2[25]);\\n        return mv; \\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution \\n{\\npublic:\\n    int minCharacters(string a, string b) \\n    {\\n         vector<int>u1(26,0),u2(26,0);\\n         for(int i=0;i<a.length();++i)\\n         {\\n             ++u1[a[i]-\\'a\\'];\\n         }",
                "codeTag": "Java"
            },
            {
                "id": 3355444,
                "title": "c",
                "content": "```\\nclass Solution {\\npublic:\\n    int minCharacters(string a, string b) {\\n        int n = a.size() ;\\n        int m = b.size() ;\\n        vector<int>alphaA(26) ;\\n        vector<int>alphaB(26) ;\\n        \\n        for(auto& c : a) \\n            alphaA[c-\\'a\\']++ ;\\n        for(auto& c : b)\\n            alphaB[c-\\'a\\']++ ;\\n        \\n        int preSumA = 0, preSumB = 0 ;\\n        int ret = INT_MAX ;\\n        for(int i = 0; i < 26; i++){\\n            //case 3\\n            ret = min(ret, m + n - alphaA[i] - alphaB[i]) ;\\n            //case 1 and 2\\n            if(i > 0){\\n                ret = min(ret, n - preSumA + preSumB) ;\\n                ret = min(ret, m - preSumB + preSumA) ;\\n            }\\n            preSumA += alphaA[i] ;\\n            preSumB += alphaB[i] ;\\n        }\\n        return ret ;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minCharacters(string a, string b) {\\n        int n = a.size() ;\\n        int m = b.size() ;\\n        vector<int>alphaA(26) ;\\n        vector<int>alphaB(26) ;\\n        \\n        for(auto& c : a) \\n            alphaA[c-\\'a\\']++ ;\\n        for(auto& c : b)\\n            alphaB[c-\\'a\\']++ ;\\n        \\n        int preSumA = 0, preSumB = 0 ;\\n        int ret = INT_MAX ;\\n        for(int i = 0; i < 26; i++){\\n            //case 3\\n            ret = min(ret, m + n - alphaA[i] - alphaB[i]) ;\\n            //case 1 and 2\\n            if(i > 0){\\n                ret = min(ret, n - preSumA + preSumB) ;\\n                ret = min(ret, m - preSumB + preSumA) ;\\n            }\\n            preSumA += alphaA[i] ;\\n            preSumB += alphaB[i] ;\\n        }\\n        return ret ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3208588,
                "title": "just-a-runnable-solution",
                "content": "# Code\\n```\\nimpl Solution {\\n    pub fn min_characters(a: String, b: String) -> i32 {\\n        let m = a.len();\\n        let n = b.len();\\n        let mut c1 = vec![0; 26];\\n        let mut c2 = vec![0; 26];\\n        for c in a.chars() {\\n            c1[c as usize - \\'a\\' as usize] += 1;\\n        }\\n        for c in b.chars() {\\n            c2[c as usize - \\'a\\' as usize] += 1;\\n        }\\n        let mut res = m + n;\\n        for i in 0..26 {\\n            res = res.min(m + n - c1[i] - c2[i]);\\n            if i > 0 {\\n                c1[i] += c1[i - 1];\\n                c2[i] += c2[i - 1];\\n            }\\n            if i < 25 {\\n                res = res.min(m - c1[i] + c2[i]);\\n                res = res.min(n - c2[i] + c1[i]);\\n            }\\n        }\\n        res as i32\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn min_characters(a: String, b: String) -> i32 {\\n        let m = a.len();\\n        let n = b.len();\\n        let mut c1 = vec![0; 26];\\n        let mut c2 = vec![0; 26];\\n        for c in a.chars() {\\n            c1[c as usize - \\'a\\' as usize] += 1;\\n        }\\n        for c in b.chars() {\\n            c2[c as usize - \\'a\\' as usize] += 1;\\n        }\\n        let mut res = m + n;\\n        for i in 0..26 {\\n            res = res.min(m + n - c1[i] - c2[i]);\\n            if i > 0 {\\n                c1[i] += c1[i - 1];\\n                c2[i] += c2[i - 1];\\n            }\\n            if i < 25 {\\n                res = res.min(m - c1[i] + c2[i]);\\n                res = res.min(n - c2[i] + c1[i]);\\n            }\\n        }\\n        res as i32\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3157509,
                "title": "c-two-pointer-solution-explained",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nTo solve this problem, we can use two pointers to keep track of the characters in the strings and compare them. We will keep track of the number of characters in each string and use this to calculate the minimum number of characters needed to make them identical.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe can use a two-pointer approach to solve this problem. We\\'ll iterate through each string and keep track of the count of each character. We will then use this to calculate the minimum number of characters needed to make the strings identical. We will also keep track of the total number of characters in both strings in order to calculate the minimum number of characters needed to make them identical.\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n- Space complexity: $$O(1)$$\\n\\n# Code\\n```\\n#pragma GCC optimize(\"Ofast\",\"inline\",\"fast-math\",\"unroll-loops\",\"no-stack-protector\")\\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,avx2,tune=native\",\"f16c\")\\nstatic const auto fast = []() {ios_base::sync_with_stdio(false); cin.tie(0); cout.tie(0); return 0; } ();\\nclass Solution {\\npublic:\\n    int minCharacters(string a, string b) {\\n        int n = a.size(), m = b.size();\\n        vector<int> cnta(26, 0), cntb(26, 0);\\n        for (char c : a) cnta[c - \\'a\\']++;\\n        for (char c : b) cntb[c - \\'a\\']++;\\n        int res = n + m;\\n        for (int i = 0; i < 26; i++) {\\n            res = min(res, n + m - cnta[i] - cntb[i]);\\n            if (i > 0) {\\n                cnta[i] += cnta[i - 1];\\n                cntb[i] += cntb[i - 1];\\n            }\\n            if (i < 25) res = min(res, n - cnta[i] + cntb[i]);\\n            if (i < 25) res = min(res, m - cntb[i] + cnta[i]);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Two Pointers",
                    "String",
                    "Counting"
                ],
                "code": "```\\n#pragma GCC optimize(\"Ofast\",\"inline\",\"fast-math\",\"unroll-loops\",\"no-stack-protector\")\\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,avx2,tune=native\",\"f16c\")\\nstatic const auto fast = []() {ios_base::sync_with_stdio(false); cin.tie(0); cout.tie(0); return 0; } ();\\nclass Solution {\\npublic:\\n    int minCharacters(string a, string b) {\\n        int n = a.size(), m = b.size();\\n        vector<int> cnta(26, 0), cntb(26, 0);\\n        for (char c : a) cnta[c - \\'a\\']++;\\n        for (char c : b) cntb[c - \\'a\\']++;\\n        int res = n + m;\\n        for (int i = 0; i < 26; i++) {\\n            res = min(res, n + m - cnta[i] - cntb[i]);\\n            if (i > 0) {\\n                cnta[i] += cnta[i - 1];\\n                cntb[i] += cntb[i - 1];\\n            }\\n            if (i < 25) res = min(res, n - cnta[i] + cntb[i]);\\n            if (i < 25) res = min(res, m - cntb[i] + cnta[i]);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3032609,
                "title": "c-linq",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nFirst, we can group string by characters and get a dictionary with at most `26` entries. Having this dictionary created, we can easily compute steps required to meet each criteria:\\n\\n- Greedy approach if we want to make all characters equal (all symbols must be equal to the most frequent one)\\n- Brute force for `a < b`: if `a < b` then exists a character `middle` such that all chars in `a` a less than `middle`, while all chars in `b` are greater or equal to `middle`. We can just try all symbols in `b..z` range. \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nLinq query\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$ (`GroupBy`), but can be turned into $$O(1)$$ if we create and dictionary without Linq. \\n\\n# Code\\n```\\npublic class Solution {\\n    \\n    private static int StrictlyLess(Dictionary<char, int> a, Dictionary<char, int> b) => Enumerable\\n          .Range(\\'b\\', \\'z\\' - \\'a\\')\\n          .Min(middle => a.Where(pair => pair.Key >= middle).Sum(pair => pair.Value) + \\n                         b.Where(pair => pair.Key < middle).Sum(pair => pair.Value));\\n    \\n    public int MinCharacters(string a, string b) {\\n        Dictionary<char, int> ha = a\\n            .GroupBy(c => c)\\n            .ToDictionary(g => g.Key, g => g.Count());\\n\\n        Dictionary<char, int> hb = b\\n            .GroupBy(c => c)\\n            .ToDictionary(g => g.Key, g => g.Count());\\n\\n        return new int[] {\\n            a.Length - ha.Values.Max() + b.Length - hb.Values.Max(),\\n            StrictlyLess(ha, hb),\\n            StrictlyLess(hb, ha)\\n        }.Min();\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    \\n    private static int StrictlyLess(Dictionary<char, int> a, Dictionary<char, int> b) => Enumerable\\n          .Range(\\'b\\', \\'z\\' - \\'a\\')\\n          .Min(middle => a.Where(pair => pair.Key >= middle).Sum(pair => pair.Value) + \\n                         b.Where(pair => pair.Key < middle).Sum(pair => pair.Value));\\n    \\n    public int MinCharacters(string a, string b) {\\n        Dictionary<char, int> ha = a\\n            .GroupBy(c => c)\\n            .ToDictionary(g => g.Key, g => g.Count());\\n\\n        Dictionary<char, int> hb = b\\n            .GroupBy(c => c)\\n            .ToDictionary(g => g.Key, g => g.Count());\\n\\n        return new int[] {\\n            a.Length - ha.Values.Max() + b.Length - hb.Values.Max(),\\n            StrictlyLess(ha, hb),\\n            StrictlyLess(hb, ha)\\n        }.Min();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2937300,
                "title": "python-prefixsum-o-n",
                "content": "# Code\\n```\\nfrom collections import Counter\\nclass Solution:\\n    def minCharacters(self, a: str, b: str) -> int:\\n        m, n = len(a), len(b)\\n        countera = Counter(a)\\n        counterb = Counter(b)\\n        prefixa = [0]\\n        prefixb = [0]\\n        for c in \\'abcdefghijklmnopqrstuvwxyz\\':\\n            prefixa.append(prefixa[-1]+countera[c])\\n            prefixb.append(prefixb[-1]+counterb[c])\\n        def solveX(prefixa, prefixb):\\n            res = float(\\'inf\\')\\n            for i in range(2,27):\\n                res = min(res, prefixa[-1]-prefixa[i-1]+prefixb[i-1])\\n            return res\\n        def solveZ(a, b):\\n            counter = Counter(a) + Counter(b)\\n            return m+n - max(counter.values())\\n        return min(solveX(prefixa,prefixb), solveX(prefixb,prefixa), solveZ(a,b))\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nfrom collections import Counter\\nclass Solution:\\n    def minCharacters(self, a: str, b: str) -> int:\\n        m, n = len(a), len(b)\\n        countera = Counter(a)\\n        counterb = Counter(b)\\n        prefixa = [0]\\n        prefixb = [0]\\n        for c in \\'abcdefghijklmnopqrstuvwxyz\\':\\n            prefixa.append(prefixa[-1]+countera[c])\\n            prefixb.append(prefixb[-1]+counterb[c])\\n        def solveX(prefixa, prefixb):\\n            res = float(\\'inf\\')\\n            for i in range(2,27):\\n                res = min(res, prefixa[-1]-prefixa[i-1]+prefixb[i-1])\\n            return res\\n        def solveZ(a, b):\\n            counter = Counter(a) + Counter(b)\\n            return m+n - max(counter.values())\\n        return min(solveX(prefixa,prefixb), solveX(prefixb,prefixa), solveZ(a,b))\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2725535,
                "title": "c-prefix-sum-counting",
                "content": "```\\nApply condition 1 and 2 to every character b-z and condition 3 to the char which has max count in each string.\\nSuppose we want to apply condition 1 and 2 on char f.\\nNow for c1 we need all our chars in a to be smaller than f and all chars in b to be greater than f.\\nSo we can just take the count of chars in a which are greater than f and count in b which are smaller than f.\\nFor c2 we do reverse count in a smaller than f and count in b greater than f.\\nWe can do this for each char b-z\\n```\\n**Note : We can\\'t do for a because we won\\'t be able to set the chars smaller than a. So a can\\'t be taken as right bound.**\\n```\\nclass Solution {\\npublic:\\n    int minCharacters(string a, string b) {\\n        int n1 = a.size(), n2 = b.size();\\n        int v1[26] = {0}, v2[26] = {0};\\n        int mx1 = 0, mx2 = 0;\\n        for(auto i:a){\\n            v1[i-\\'a\\']++;\\n            mx1 = max(mx1, v1[i-\\'a\\']);\\n        }\\n        for(auto i:b){\\n            v2[i-\\'a\\']++;\\n            mx2 = max(mx2, v2[i-\\'a\\']);\\n        }\\n        int ans = n1 - mx1 + n2 - mx2;\\n        for(int i=1; i<26; i++){\\n            v1[i] += v1[i-1];\\n            v2[i] += v2[i-1];\\n        }\\n        for(int i=1; i<26; i++){\\n            ans = min(ans, v1[i-1] + n2-v2[i-1]);\\n            ans = min(ans, v2[i-1] + n1-v1[i-1]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Counting",
                    "Prefix Sum"
                ],
                "code": "```\\nApply condition 1 and 2 to every character b-z and condition 3 to the char which has max count in each string.\\nSuppose we want to apply condition 1 and 2 on char f.\\nNow for c1 we need all our chars in a to be smaller than f and all chars in b to be greater than f.\\nSo we can just take the count of chars in a which are greater than f and count in b which are smaller than f.\\nFor c2 we do reverse count in a smaller than f and count in b greater than f.\\nWe can do this for each char b-z\\n```\n```\\nclass Solution {\\npublic:\\n    int minCharacters(string a, string b) {\\n        int n1 = a.size(), n2 = b.size();\\n        int v1[26] = {0}, v2[26] = {0};\\n        int mx1 = 0, mx2 = 0;\\n        for(auto i:a){\\n            v1[i-\\'a\\']++;\\n            mx1 = max(mx1, v1[i-\\'a\\']);\\n        }\\n        for(auto i:b){\\n            v2[i-\\'a\\']++;\\n            mx2 = max(mx2, v2[i-\\'a\\']);\\n        }\\n        int ans = n1 - mx1 + n2 - mx2;\\n        for(int i=1; i<26; i++){\\n            v1[i] += v1[i-1];\\n            v2[i] += v2[i-1];\\n        }\\n        for(int i=1; i<26; i++){\\n            ans = min(ans, v1[i-1] + n2-v2[i-1]);\\n            ans = min(ans, v2[i-1] + n1-v1[i-1]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2685320,
                "title": "python-without-pruning-alphabet",
                "content": "```\\nfrom bisect import bisect_left\\nclass Solution:\\n    def minCharacters(self, a: str, b: str) -> int:\\n        alphabet = \"abcdefghijklmnopqrstuvwxyz\"\\n        cost = float(\\'inf\\')\\n        a = \\'\\'.join(sorted(a))\\n        b = \\'\\'.join(sorted(b))\\n        \\n        for char in alphabet:\\n            # Count how many characters in a and b are less than char\\n            a_lt = bisect_left(a, char)\\n            b_lt = bisect_left(b, char)\\n            \\n            if char != \"a\":\\n                # Make all in a < char and all in b >= char\\n                cost = min(cost, b_lt + len(a) - a_lt)\\n                # Make all in b < char and all in a >= char\\n                cost = min(cost, a_lt + len(b) - b_lt)\\n                \\n            # Make all in a and b equal to char\\n            cost = min(cost, len(a) + len(b) - a.count(char) - b.count(char))\\n            \\n        return cost\\n```",
                "solutionTags": [],
                "code": "```\\nfrom bisect import bisect_left\\nclass Solution:\\n    def minCharacters(self, a: str, b: str) -> int:\\n        alphabet = \"abcdefghijklmnopqrstuvwxyz\"\\n        cost = float(\\'inf\\')\\n        a = \\'\\'.join(sorted(a))\\n        b = \\'\\'.join(sorted(b))\\n        \\n        for char in alphabet:\\n            # Count how many characters in a and b are less than char\\n            a_lt = bisect_left(a, char)\\n            b_lt = bisect_left(b, char)\\n            \\n            if char != \"a\":\\n                # Make all in a < char and all in b >= char\\n                cost = min(cost, b_lt + len(a) - a_lt)\\n                # Make all in b < char and all in a >= char\\n                cost = min(cost, a_lt + len(b) - b_lt)\\n                \\n            # Make all in a and b equal to char\\n            cost = min(cost, len(a) + len(b) - a.count(char) - b.count(char))\\n            \\n        return cost\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2577119,
                "title": "c-dfs",
                "content": "```\\npublic class Solution {\\n    public int MinCharacters(string a, string b) {\\n\\n        // hash table to give me look[a] = 0, look[z] = 25 etc.\\n        Dictionary<char, int> look = new Dictionary<char, int>();\\n        string alphabet = \"abcdefghijklmnopqrstuvwxyz\";\\n\\n        for (int i = 0; i < 26; i++) {\\n            char x = alphabet[i];\\n            look[x] = i;\\n        }\\n\\n        // representing each string as an array of letter frequencies\\n        int[] table1 = AlphaArray(a, look);\\n        int[] table2 = AlphaArray(b, look);\\n\\n        // make a & b homogenous e.g. aaa & aaaaa\\n        int ans = Homogenize(table1, table2);\\n\\n        // dfs to find fewest operations to make a\\'s letters < b\\'s letters\\n        Explore(table1, table2, ref ans, 0, false, 0);\\n\\n        // dfs to find fewest operations to make b\\'s letters < a\\'s letters\\n        Explore(table2, table1, ref ans, 0, false, 0);\\n\\n        return ans;\\n    }\\n\\n    private int[] AlphaArray(string s, Dictionary<char, int> look){\\n\\n        int[] table = new int[26];\\n\\n        foreach (char x in s){\\n            table[look[x]] += 1;\\n        }\\n        return table;\\n    }\\n\\n    private int Homogenize(int[] a, int[] b){\\n\\n        // treat the strings as a shared pool of letters\\n        int best = 0; // frequency of the most common letter\\n        int total = 0; // total letters\\n        for(int i=0; i<26; i++){\\n            best = Math.Max(best, a[i] + b[i]);\\n            total += a[i] + b[i];\\n        }\\n\\n        return total - best;\\n    }\\n\\n    private void Explore(int[] a, int[] b, ref int ans, int i, bool seen, int operations){\\n\\n        if(operations>=ans){\\n            return;\\n        }\\n\\n        if(i==26){\\n            ans = operations;\\n            return;\\n        }\\n\\n        if(!seen && i<25){\\n            b[25] += b[i];\\n            Explore(a, b, ref ans, i+1, false, operations+b[i]);\\n            b[25] -= b[i];\\n        }\\n\\n        if(i>0){\\n            Explore(a, b, ref ans, i+1, true, operations+a[i]);\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int MinCharacters(string a, string b) {\\n\\n        // hash table to give me look[a] = 0, look[z] = 25 etc.\\n        Dictionary<char, int> look = new Dictionary<char, int>();\\n        string alphabet = \"abcdefghijklmnopqrstuvwxyz\";\\n\\n        for (int i = 0; i < 26; i++) {\\n            char x = alphabet[i];\\n            look[x] = i;\\n        }\\n\\n        // representing each string as an array of letter frequencies\\n        int[] table1 = AlphaArray(a, look);\\n        int[] table2 = AlphaArray(b, look);\\n\\n        // make a & b homogenous e.g. aaa & aaaaa\\n        int ans = Homogenize(table1, table2);\\n\\n        // dfs to find fewest operations to make a\\'s letters < b\\'s letters\\n        Explore(table1, table2, ref ans, 0, false, 0);\\n\\n        // dfs to find fewest operations to make b\\'s letters < a\\'s letters\\n        Explore(table2, table1, ref ans, 0, false, 0);\\n\\n        return ans;\\n    }\\n\\n    private int[] AlphaArray(string s, Dictionary<char, int> look){\\n\\n        int[] table = new int[26];\\n\\n        foreach (char x in s){\\n            table[look[x]] += 1;\\n        }\\n        return table;\\n    }\\n\\n    private int Homogenize(int[] a, int[] b){\\n\\n        // treat the strings as a shared pool of letters\\n        int best = 0; // frequency of the most common letter\\n        int total = 0; // total letters\\n        for(int i=0; i<26; i++){\\n            best = Math.Max(best, a[i] + b[i]);\\n            total += a[i] + b[i];\\n        }\\n\\n        return total - best;\\n    }\\n\\n    private void Explore(int[] a, int[] b, ref int ans, int i, bool seen, int operations){\\n\\n        if(operations>=ans){\\n            return;\\n        }\\n\\n        if(i==26){\\n            ans = operations;\\n            return;\\n        }\\n\\n        if(!seen && i<25){\\n            b[25] += b[i];\\n            Explore(a, b, ref ans, i+1, false, operations+b[i]);\\n            b[25] -= b[i];\\n        }\\n\\n        if(i>0){\\n            Explore(a, b, ref ans, i+1, true, operations+a[i]);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2506524,
                "title": "python-3-count-for-each-character",
                "content": "\\tclass Solution:\\n\\t\\tdef minCharacters(self, a: str, b: str) -> int:\\n\\t\\t\\tdef get_smaller(ch,a):\\n\\t\\t\\t\\treturn sum(a[x] for x in a if x<=ch)\\n\\t\\t\\tn,m=len(a),len(b)\\n\\t\\t\\ta,b=Counter(a),Counter(b)\\n\\t\\t\\tres=n-max(a.values())+m-max(b.values())# make 1 letter\\n\\t\\t\\tfor ch in \\'abcdefghijklmnopqrstuvwxy\\':\\n\\t\\t\\t\\tc1,c2=get_smaller(ch,a),get_smaller(ch,b)\\n\\t\\t\\t\\tres=min(res,n-c1+c2,c1+m-c2)\\n\\t\\t\\treturn res",
                "solutionTags": [],
                "code": "\\tclass Solution:\\n\\t\\tdef minCharacters(self, a: str, b: str) -> int:\\n\\t\\t\\tdef get_smaller(ch,a):\\n\\t\\t\\t\\treturn sum(a[x] for x in a if x<=ch)\\n\\t\\t\\tn,m=len(a),len(b)\\n\\t\\t\\ta,b=Counter(a),Counter(b)\\n\\t\\t\\tres=n-max(a.values())+m-max(b.values())# make 1 letter\\n\\t\\t\\tfor ch in \\'abcdefghijklmnopqrstuvwxy\\':\\n\\t\\t\\t\\tc1,c2=get_smaller(ch,a),get_smaller(ch,b)\\n\\t\\t\\t\\tres=min(res,n-c1+c2,c1+m-c2)\\n\\t\\t\\treturn res",
                "codeTag": "Java"
            },
            {
                "id": 2501574,
                "title": "c-easy-solution-vectors-o-n-o-26",
                "content": "```\\nclass Solution {\\npublic:\\n    int minCharacters(string a, string b) {\\n            vector<int> for_a(26,0);\\n            vector<int> for_b(26,0);\\n            for(int i = 0 ; i < a.size() ; i++){\\n                    for_a[a[i] - \\'a\\']++;\\n            }\\n            for(int i = 0 ; i < b.size() ; i++){\\n                    for_b[b[i] - \\'a\\']++;\\n            }\\n            int first = INT_MAX,second = INT_MAX,third = 0;\\n            int a_sum = 0 , b_sum = 0;\\n            int occur = 0;\\n            int n = a.size();\\n            int m = b.size();\\n            for(int i = 0 ; i < 26 ; i++){\\n                    if(i != 0){\\n                            first = min(first,(m - b_sum) + a_sum);\\n                            second = min(second,(n - a_sum) + b_sum);\\n                            \\n                    }\\n                    a_sum += for_a[i];\\n                    b_sum += for_b[i];\\n                    occur = max(occur,for_a[i] + for_b[i]);\\n            }\\n            third = (a.size() + b.size()) - occur;\\n            \\n            return min(first,min(second,third));\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minCharacters(string a, string b) {\\n            vector<int> for_a(26,0);\\n            vector<int> for_b(26,0);\\n            for(int i = 0 ; i < a.size() ; i++){\\n                    for_a[a[i] - \\'a\\']++;\\n            }\\n            for(int i = 0 ; i < b.size() ; i++){\\n                    for_b[b[i] - \\'a\\']++;\\n            }\\n            int first = INT_MAX,second = INT_MAX,third = 0;\\n            int a_sum = 0 , b_sum = 0;\\n            int occur = 0;\\n            int n = a.size();\\n            int m = b.size();\\n            for(int i = 0 ; i < 26 ; i++){\\n                    if(i != 0){\\n                            first = min(first,(m - b_sum) + a_sum);\\n                            second = min(second,(n - a_sum) + b_sum);\\n                            \\n                    }\\n                    a_sum += for_a[i];\\n                    b_sum += for_b[i];\\n                    occur = max(occur,for_a[i] + for_b[i]);\\n            }\\n            third = (a.size() + b.size()) - occur;\\n            \\n            return min(first,min(second,third));\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2328849,
                "title": "counting",
                "content": "**sum and difference histograms**\\n**time: `O(N+M)`; space: `O(1)`**\\n\\n```\\nint minCharacters(string a, string b)\\n{\\n\\tint d[256]{}, D[256]{};   \\n\\tfor(const auto & c : a) ++d[c], ++D[c];\\n\\tfor(const auto & c : b) --d[c], ++D[c];\\n\\n\\tint n(size(a)+size(b)), out{n-D[\\'z\\']}, x(size(b)), y(size(a));\\n\\tfor(auto c{\\'a\\'}; c<\\'z\\'; ++c)\\n\\t\\tout = min({out, x+=d[c], y-=d[c], n-D[c]});\\n\\treturn out;\\n}\\n```\\n`d[c]` - delta of number of occurrences of character `c` in strings `a` and `b`;\\n`D[c]` - sum of number of occurrences of character `c` in strings `a` and `b`.\\n",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nint minCharacters(string a, string b)\\n{\\n\\tint d[256]{}, D[256]{};   \\n\\tfor(const auto & c : a) ++d[c], ++D[c];\\n\\tfor(const auto & c : b) --d[c], ++D[c];\\n\\n\\tint n(size(a)+size(b)), out{n-D[\\'z\\']}, x(size(b)), y(size(a));\\n\\tfor(auto c{\\'a\\'}; c<\\'z\\'; ++c)\\n\\t\\tout = min({out, x+=d[c], y-=d[c], n-D[c]});\\n\\treturn out;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2071748,
                "title": "1737-change-minimum-characters-to-satisfy-one-of-three-conditions",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    int check(string a, string b)\\n    {\\n        int local = INT_MAX;\\n        for(char ch = \\'b\\';ch<=\\'z\\';ch++)\\n        {\\n            int temp=0;\\n            \\n            for(int i=0;i<a.length();i++)\\n            {\\n                if(a[i]>=ch)\\n                    temp++;\\n            }\\n            \\n            for(int i=0;i<b.length();i++)\\n            {\\n                if(b[i]<ch)\\n                    temp++;\\n            }\\n            \\n            local = min(local,temp);\\n            \\n        }\\n        \\n        return local;\\n    }\\n    \\n    int minCharacters(string a, string b) {\\n        \\n        //CASE1 & CASE2\\n        int ans = min(check(a,b),check(b,a));\\n        \\n        //CASE3\\n        vector<int>ha(26),hb(26);\\n        \\n        for(int i=0;i<a.length();i++)\\n        {\\n            ha[a[i]-\\'a\\']++;\\n        }\\n        \\n        for(int i=0;i<b.length();i++)\\n        {\\n            hb[b[i]-\\'a\\']++;\\n        }\\n        \\n        \\n        int case3 = 0;\\n        for(int i=0;i<26;i++){\\n            case3 = max(case3,ha[i]+hb[i]);\\n        }\\n        case3 = a.length() + b.length() - case3;\\n        \\n        return min(ans,case3);\\n    }\\n};\\n```\\n\\n**If you have any doubt ask in discussions below. Upvote if you like it**",
                "solutionTags": [
                    "C++",
                    "C",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int check(string a, string b)\\n    {\\n        int local = INT_MAX;\\n        for(char ch = \\'b\\';ch<=\\'z\\';ch++)\\n        {\\n            int temp=0;\\n            \\n            for(int i=0;i<a.length();i++)\\n            {\\n                if(a[i]>=ch)\\n                    temp++;\\n            }\\n            \\n            for(int i=0;i<b.length();i++)\\n            {\\n                if(b[i]<ch)\\n                    temp++;\\n            }\\n            \\n            local = min(local,temp);\\n            \\n        }\\n        \\n        return local;\\n    }\\n    \\n    int minCharacters(string a, string b) {\\n        \\n        //CASE1 & CASE2\\n        int ans = min(check(a,b),check(b,a));\\n        \\n        //CASE3\\n        vector<int>ha(26),hb(26);\\n        \\n        for(int i=0;i<a.length();i++)\\n        {\\n            ha[a[i]-\\'a\\']++;\\n        }\\n        \\n        for(int i=0;i<b.length();i++)\\n        {\\n            hb[b[i]-\\'a\\']++;\\n        }\\n        \\n        \\n        int case3 = 0;\\n        for(int i=0;i<26;i++){\\n            case3 = max(case3,ha[i]+hb[i]);\\n        }\\n        case3 = a.length() + b.length() - case3;\\n        \\n        return min(ans,case3);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2058943,
                "title": "consider-each-of-the-three-cases",
                "content": "Yes, we might put these three cases into one loop to reduce line-of-code, but I prefer clear logic units.\\n\\n```cpp\\nint m = a.size();\\nint n = b.size();\\nvector<int> ha(26), hb(26);\\n\\n// count the frequency\\nfor (char c : a)\\n\\t++ ha[c - \\'a\\'];\\n\\nfor (char c : b)\\n\\t++ hb[c - \\'a\\'];\\n\\n//------------------------------\\n// a < b\\nint case1 = INT_MAX;  \\n// count_a is indeed sum_a\\ncount_a = m;\\ncount_b = 0;\\n\\nfor (int i = 1; i < 26; ++i)\\n{\\n\\t// for each char i, in order to make all char in a less than all char in b,\\n\\t// those chars in a that are larger than i must be change to i - 1.\\n\\t// those char in b that are smaller than i must be change to i.\\n\\tcount_a -= ha[i - 1];\\n\\tcount_b += hb[i - 1];\\n\\t\\n\\tcase1 = min(case1, count_a + count_b);\\n}\\n\\n//------------------------------\\n// a > b, similar logic\\nint case2 = INT_MAX;  \\nint count_a = 0;\\nint count_b = n;\\n\\nfor (int i = 1; i < 26; ++i)\\n{\\n\\t// change char in a less than i into i\\n\\tcount_a += ha[i - 1];\\n\\t// change char in b larger than i into i - 1\\n\\tcount_b -= hb[i - 1];\\n\\t\\n\\tcase2 = min(case2, count_a + count_b);\\n}\\n\\n//----------------------------\\n// a == b\\nint case3 = 0;\\n\\n// find the char with max frequency in both a and b\\nfor (int i = 0; i < 26; ++i)\\n\\tcase3 = max(case3, ha[i] + hb[i]);\\n\\n// change the rest of a and b into the dominating char\\ncase3 = n + m - case3;\\n\\nreturn min(case1, min(case2, case3));\\n```\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```cpp\\nint m = a.size();\\nint n = b.size();\\nvector<int> ha(26), hb(26);\\n\\n// count the frequency\\nfor (char c : a)\\n\\t++ ha[c - \\'a\\'];\\n\\nfor (char c : b)\\n\\t++ hb[c - \\'a\\'];\\n\\n//------------------------------\\n// a < b\\nint case1 = INT_MAX;  \\n// count_a is indeed sum_a\\ncount_a = m;\\ncount_b = 0;\\n\\nfor (int i = 1; i < 26; ++i)\\n{\\n\\t// for each char i, in order to make all char in a less than all char in b,\\n\\t// those chars in a that are larger than i must be change to i - 1.\\n\\t// those char in b that are smaller than i must be change to i.\\n\\tcount_a -= ha[i - 1];\\n\\tcount_b += hb[i - 1];\\n\\t\\n\\tcase1 = min(case1, count_a + count_b);\\n}\\n\\n//------------------------------\\n// a > b, similar logic\\nint case2 = INT_MAX;  \\nint count_a = 0;\\nint count_b = n;\\n\\nfor (int i = 1; i < 26; ++i)\\n{\\n\\t// change char in a less than i into i\\n\\tcount_a += ha[i - 1];\\n\\t// change char in b larger than i into i - 1\\n\\tcount_b -= hb[i - 1];\\n\\t\\n\\tcase2 = min(case2, count_a + count_b);\\n}\\n\\n//----------------------------\\n// a == b\\nint case3 = 0;\\n\\n// find the char with max frequency in both a and b\\nfor (int i = 0; i < 26; ++i)\\n\\tcase3 = max(case3, ha[i] + hb[i]);\\n\\n// change the rest of a and b into the dominating char\\ncase3 = n + m - case3;\\n\\nreturn min(case1, min(case2, case3));\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2034200,
                "title": "java-o-n-presum-detailed-explanation",
                "content": "```java\\nclass Solution {\\n  /**\\n   * Glossary:\\n   * Split character: the character value to be determined for the final state of\\n   * the two string after update such that:\\n   * 1. option A: (all characters in a) < split char <= (all characters in b)\\n   * 2. option B: (all characters in a) >= split char > (all characters in b)\\n   * 3. option C: (all characters in a) == split char == (all characters in b)\\n   */\\n  public int minCharacters(String a, String b) {\\n    // This problems can be solved efficiently only because the resolute of the\\n    // split character\\'s is limited: from \\'a\\' to \\'z\\'.\\n    int[] cntA = new int[26], cntB = new int[26];\\n    int n = a.length(), m = b.length();\\n    for (int i = 0; i < n; i++) {\\n      cntA[a.charAt(i) - \\'a\\']++;\\n    }\\n    for (int i = 0; i < m; i++) {\\n      cntB[b.charAt(i) - \\'a\\']++;\\n    }\\n    int ret = Integer.MAX_VALUE;\\n    int aTotal = 0, bTotal = 0;\\n    // We\\'re going to enumerate the resolution set to find out the min # of\\n    // operations\\n    for (int i = 0; i < 26; i++) {\\n      // i == 0 is specical because \\'a\\' is the minimum character here, you can\\'t find\\n      // any legitimate character smaller than \\'a\\',\\n      // that leaves us with only 1 choice - make @param a and @param b contain only\\n      // \\'a\\'.\\n      if (i == 0) {\\n        // the only choice is making @param a and @param b only contain \\'a\\'\\n        ret = Math.min(ret, n - cntA[i] + m - cntB[i]);\\n      } else {\\n        // for candidate \\'b\\' to \\'z\\', we attempt for the 3 options documented above\\n        int optionA = bTotal + n - aTotal;\\n        int optionB = aTotal + m - bTotal;\\n        int optionC = n + m - cntA[i] - cntB[i];\\n        ret = min4(ret, optionA, optionB, optionC);\\n      }\\n      // aTotal is the number of characters in @param a with value strictly less than\\n      // the current index + \\'a\\'\\n      // bTotal is the number of characters in @param b with value strictly less than\\n      // the current index + \\'a\\'\\n      aTotal += cntA[i];\\n      bTotal += cntB[i];\\n    }\\n    return ret;\\n  }\\n\\n  int min4(int a, int b, int c, int d) {\\n    a = Math.min(a, b);\\n    c = Math.min(c, d);\\n    return Math.min(a, c);\\n  }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```java\\nclass Solution {\\n  /**\\n   * Glossary:\\n   * Split character: the character value to be determined for the final state of\\n   * the two string after update such that:\\n   * 1. option A: (all characters in a) < split char <= (all characters in b)\\n   * 2. option B: (all characters in a) >= split char > (all characters in b)\\n   * 3. option C: (all characters in a) == split char == (all characters in b)\\n   */\\n  public int minCharacters(String a, String b) {\\n    // This problems can be solved efficiently only because the resolute of the\\n    // split character\\'s is limited: from \\'a\\' to \\'z\\'.\\n    int[] cntA = new int[26], cntB = new int[26];\\n    int n = a.length(), m = b.length();\\n    for (int i = 0; i < n; i++) {\\n      cntA[a.charAt(i) - \\'a\\']++;\\n    }\\n    for (int i = 0; i < m; i++) {\\n      cntB[b.charAt(i) - \\'a\\']++;\\n    }\\n    int ret = Integer.MAX_VALUE;\\n    int aTotal = 0, bTotal = 0;\\n    // We\\'re going to enumerate the resolution set to find out the min # of\\n    // operations\\n    for (int i = 0; i < 26; i++) {\\n      // i == 0 is specical because \\'a\\' is the minimum character here, you can\\'t find\\n      // any legitimate character smaller than \\'a\\',\\n      // that leaves us with only 1 choice - make @param a and @param b contain only\\n      // \\'a\\'.\\n      if (i == 0) {\\n        // the only choice is making @param a and @param b only contain \\'a\\'\\n        ret = Math.min(ret, n - cntA[i] + m - cntB[i]);\\n      } else {\\n        // for candidate \\'b\\' to \\'z\\', we attempt for the 3 options documented above\\n        int optionA = bTotal + n - aTotal;\\n        int optionB = aTotal + m - bTotal;\\n        int optionC = n + m - cntA[i] - cntB[i];\\n        ret = min4(ret, optionA, optionB, optionC);\\n      }\\n      // aTotal is the number of characters in @param a with value strictly less than\\n      // the current index + \\'a\\'\\n      // bTotal is the number of characters in @param b with value strictly less than\\n      // the current index + \\'a\\'\\n      aTotal += cntA[i];\\n      bTotal += cntB[i];\\n    }\\n    return ret;\\n  }\\n\\n  int min4(int a, int b, int c, int d) {\\n    a = Math.min(a, b);\\n    c = Math.min(c, d);\\n    return Math.min(a, c);\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1942284,
                "title": "ruby-solution-beats-100-100",
                "content": "```\\n# @param {String} a\\n# @param {String} b\\n# @return {Integer}\\ndef min_characters(a, b)\\n  n = a.size\\n  m = b.size\\n  a = a.bytes.each_with_object(Array.new(26, 0)) { _2[_1 - 97] += 1 }\\n  b = b.bytes.each_with_object(Array.new(26, 0)) { _2[_1 - 97] += 1 }\\n  d = 0\\n  [\\n     n + m - a.max - b.max,\\n     *a.zip(b).tap(&:pop).flat_map { d += _2 - _1; [n + d, m - d] },\\n  ].min  \\nend\\n```",
                "solutionTags": [],
                "code": "```\\n# @param {String} a\\n# @param {String} b\\n# @return {Integer}\\ndef min_characters(a, b)\\n  n = a.size\\n  m = b.size\\n  a = a.bytes.each_with_object(Array.new(26, 0)) { _2[_1 - 97] += 1 }\\n  b = b.bytes.each_with_object(Array.new(26, 0)) { _2[_1 - 97] += 1 }\\n  d = 0\\n  [\\n     n + m - a.max - b.max,\\n     *a.zip(b).tap(&:pop).flat_map { d += _2 - _1; [n + d, m - d] },\\n  ].min  \\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1908021,
                "title": "python-faster-than-95",
                "content": "\\n\\'\\'\\'\\n\\nclass Solution(object):\\n    def minCharacters(self, a, b):\\n        \\n        \\n        \\n        b_counter=list(b.count(x) for x in \\'abcdefghijklmnopqrstuvwxyz\\')\\n        a_counter=list(a.count(x) for x in \\'abcdefghijklmnopqrstuvwxyz\\')\\n        to_change=len(a)-max(a_counter)+len(b)-max(b_counter)\\n        miny=to_change\\n        for i in range(25):#len(b_counter)):\\n            i=i+1\\n            a_bigger_b=sum(b_counter[i:])+sum(a_counter[0:i])\\n            b_bigger_a=sum(a_counter[i:])+sum(b_counter[0:i])\\n            miny=min(a_bigger_b,b_bigger_a,miny)\\n        return miny\\n\\t\\t\\n\\'\\'\\'",
                "solutionTags": [],
                "code": "\\n\\'\\'\\'\\n\\nclass Solution(object):\\n    def minCharacters(self, a, b):\\n        \\n        \\n        \\n        b_counter=list(b.count(x) for x in \\'abcdefghijklmnopqrstuvwxyz\\')\\n        a_counter=list(a.count(x) for x in \\'abcdefghijklmnopqrstuvwxyz\\')\\n        to_change=len(a)-max(a_counter)+len(b)-max(b_counter)\\n        miny=to_change\\n        for i in range(25):#len(b_counter)):\\n            i=i+1\\n            a_bigger_b=sum(b_counter[i:])+sum(a_counter[0:i])\\n            b_bigger_a=sum(a_counter[i:])+sum(b_counter[0:i])\\n            miny=min(a_bigger_b,b_bigger_a,miny)\\n        return miny\\n\\t\\t\\n\\'\\'\\'",
                "codeTag": "Java"
            },
            {
                "id": 1834113,
                "title": "prefix-array-string-c",
                "content": "\\n\\n\\n\\n\\n\\n\\n\\n\\n\\nclass Solution {\\npublic:\\n    int minCharacters(string a, string b)\\n    {\\n\\n        int m = a.length();\\n        int n = b.length();\\n        vector<int> arr1(26, 0);\\n        vector<int> arr2(26, 0);\\n        for (int i = 0; i < m; i++) {\\n            arr1[a[i] - \\'a\\'] += 1;\\n        }\\n        for (int i = 0; i < n; i++) {\\n            arr2[b[i] - \\'a\\'] += 1;\\n        }\\n        int ans = INT_MAX;\\n\\n        for (int i = 0; i < 26; i++) {\\n\\n            ans = min(ans, m + n - arr1[i] - arr2[i]);\\n        }\\n        // cout<<ans<<endl;\\n\\n        for (int i = 1; i < 26; i++) {\\n            arr1[i] += arr1[i - 1];\\n        }\\n        for (int i = 1; i < 26; i++) {\\n            arr2[i] += arr2[i - 1];\\n        }\\n\\n        for (int i = 0; i < 25; i++) {\\n\\n            ans = min(ans, arr1[i] + n - arr2[i]);\\n            ans = min(ans, m - arr1[i] + arr2[i]);\\n        }\\n\\n        return ans;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int minCharacters(string a, string b)\\n    {\\n\\n        int m = a.length();\\n        int n = b.length();\\n        vector<int> arr1(26, 0);\\n        vector<int> arr2(26, 0);\\n        for (int i = 0; i < m; i++) {\\n            arr1[a[i] - \\'a\\'] += 1;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1690066,
                "title": "o-n-m-26-solution-cpp-with-comments",
                "content": "```\\n\\nclass Solution\\n{\\n    public:\\n        int minCharacters(string a, string b)\\n        {\\n            int cona[26] = {};\\n            int conb[26] = {};\\n            int n = a.size(), m = b.size();\\n            for (auto c: a) cona[c - \\'a\\']++;\\n            for (auto c: b) conb[c - \\'a\\']++;\\n            int res = INT_MAX;\\n            \\n            //   make all letters equals to  1 characters   here checking for all  letters from \\'a to z\\' \\n            //   and taking that characters with minimum change\\n            for (int i = 0; i < 26; i++)\\n            {\\n                res = min(res, n + m - (cona[i] + conb[i]));\\n            }\\n             //     string   a    all letters <=i   for  a<=i<=y   and string b all letters >i;\\n            for (int i = 0; i < 25; i++)\\n            {\\n                int count = 0;\\n                for (int j = 0; j < n; j++)\\n                {\\n                    if (a[j] > \\'a\\' + i)\\n                    {\\n                        count++;\\n                    }\\n                }\\n                for (int j = 0; j < m; j++)\\n                {\\n                    if (b[j] <= \\'a\\' + i)\\n                    {\\n                        count++;\\n                    }\\n                }\\n                res = min(res, count);\\n            }\\n            \\n            //     string   a    all letters >i   for  a<=i<=y   and string b all letters <=i;\\n            for (int i = 0; i < 25; i++)\\n            {\\n                int count = 0;\\n                for (int j = 0; j < m; j++)\\n                {\\n                    if (b[j] > \\'a\\' + i)\\n                    {\\n                        count++;\\n                    }\\n                }\\n                for (int j = 0; j < n; j++)\\n                {\\n                    if (a[j] <= \\'a\\' + i)\\n                    {\\n                        count++;\\n                    }\\n                }\\n                res = min(res, count);\\n            }\\n            \\n            //return minimum change;\\n            return res;\\n        }\\n};\\n\\n```",
                "solutionTags": [],
                "code": "```\\n\\nclass Solution\\n{\\n    public:\\n        int minCharacters(string a, string b)\\n        {\\n            int cona[26] = {};\\n            int conb[26] = {};\\n            int n = a.size(), m = b.size();\\n            for (auto c: a) cona[c - \\'a\\']++;\\n            for (auto c: b) conb[c - \\'a\\']++;\\n            int res = INT_MAX;\\n            \\n            //   make all letters equals to  1 characters   here checking for all  letters from \\'a to z\\' \\n            //   and taking that characters with minimum change\\n            for (int i = 0; i < 26; i++)\\n            {\\n                res = min(res, n + m - (cona[i] + conb[i]));\\n            }\\n             //     string   a    all letters <=i   for  a<=i<=y   and string b all letters >i;\\n            for (int i = 0; i < 25; i++)\\n            {\\n                int count = 0;\\n                for (int j = 0; j < n; j++)\\n                {\\n                    if (a[j] > \\'a\\' + i)\\n                    {\\n                        count++;\\n                    }\\n                }\\n                for (int j = 0; j < m; j++)\\n                {\\n                    if (b[j] <= \\'a\\' + i)\\n                    {\\n                        count++;\\n                    }\\n                }\\n                res = min(res, count);\\n            }\\n            \\n            //     string   a    all letters >i   for  a<=i<=y   and string b all letters <=i;\\n            for (int i = 0; i < 25; i++)\\n            {\\n                int count = 0;\\n                for (int j = 0; j < m; j++)\\n                {\\n                    if (b[j] > \\'a\\' + i)\\n                    {\\n                        count++;\\n                    }\\n                }\\n                for (int j = 0; j < n; j++)\\n                {\\n                    if (a[j] <= \\'a\\' + i)\\n                    {\\n                        count++;\\n                    }\\n                }\\n                res = min(res, count);\\n            }\\n            \\n            //return minimum change;\\n            return res;\\n        }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1391737,
                "title": "c",
                "content": "```\\nclass Solution {\\npublic:\\n    int minCharacters(string a, string b) {\\n    int n = a.length();\\n        int m = b.length();\\n        int dp[n+1][26];\\n        int dp2[m+1][26];\\n        memset(dp,0,sizeof dp);\\n        \\n        memset(dp2,0,sizeof dp2);\\n        for(int i=1;i<=a.length();i++)\\n        {\\n            for(int j=0;j<26;j++)dp[i][j] = dp[i-1][j];\\n            dp[i][a[i-1]-\\'a\\']++;\\n        }\\n\\n        for(int i=1;i<=b.length();i++)\\n        {\\n            for(int j=0;j<26;j++)dp2[i][j] = dp2[i-1][j];\\n            dp2[i][b[i-1]-\\'a\\']++;\\n        }\\n\\n\\n        int conversion_a[26];\\n        int conversion_b[26];\\n\\n\\n        for(int i=0;i<26;i++)\\n        {\\n            conversion_a[i] = a.length() - dp[n][i];\\n        }\\n\\n        for(int i=0;i<26;i++)\\n        {\\n            conversion_b[i] = b.length() - dp2[m][i];\\n        }\\n        \\n        int mx = 1000000000;\\n\\n        for(int i=0;i<26;i++)\\n        {\\n            mx = min(mx,conversion_a[i] + conversion_b[i]);\\n        }\\n        \\n\\n        for(int i=1;i<26;i++)\\n        {\\n       \\n                int x = i;\\n                int xsum = 0;\\n                for(int k=0;k<x;k++)xsum+=dp[n][k];\\n                int ysum = 0;\\n                for(int k=x;k<26;k++)ysum+=dp2[m][k];\\n                mx = min(mx,xsum+ysum);\\n\\n\\n            \\n        }\\n        for(int i=1;i<26;i++)\\n        {\\n       \\n                int x = i;\\n                int xsum = 0;\\n                for(int k=0;k<x;k++)xsum+=dp2[m][k];\\n                int ysum = 0;\\n                for(int k=x;k<26;k++)ysum+=dp[n][k];\\n                mx = min(mx,xsum+ysum);\\n   \\n        }\\n\\n        return mx;\\n\\n        \\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int minCharacters(string a, string b) {\\n    int n = a.length();\\n        int m = b.length();\\n        int dp[n+1][26];\\n        int dp2[m+1][26];\\n        memset(dp,0,sizeof dp);\\n        \\n        memset(dp2,0,sizeof dp2);\\n        for(int i=1;i<=a.length();i++)\\n        {\\n            for(int j=0;j<26;j++)dp[i][j] = dp[i-1][j];\\n            dp[i][a[i-1]-\\'a\\']++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1374157,
                "title": "c-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    int minCharacters(string a, string b) {\\n        int n = a.length();\\n        int m= b.length();\\n        int cnta[26];\\n        int cntb[26];\\n        memset(cnta,0,sizeof cnta);\\n        memset(cntb,0,sizeof cntb);\\n        for(int i=0;i<a.length();i++){\\n            cnta[a[i]-\\'a\\']++;\\n        }\\n        for(int i=0;i<b.length();i++){\\n            cntb[b[i]-\\'a\\']++;\\n        }\\n        int ans=INT_MAX;\\n        // option 1\\n        // every character in a should be strictly less than b\\n        int c=0;\\n        for(int i=25;i>0;i--){\\n            c =c+ cnta[i];\\n            int sum=0;\\n            for(int j=i;j<26;j++){\\n                sum = sum+cntb[j];\\n            }\\n            sum = b.length()-sum;\\n            ans = min(ans,c+sum);\\n        }\\n        // cout<<ans<<endl;\\n        // option 2\\n        // every character in b should be strictly less than a\\n        c=0;\\n        for(int i=25;i>0;i--){\\n            c = c+ cntb[i];\\n            int sum=0;\\n            for(int j=i;j<26;j++){\\n                sum = sum+cnta[j];\\n            }\\n            sum = a.length()-sum;\\n            ans = min(ans,c+sum);\\n        }\\n        // option 3\\n        // both a and b should contain exactly one distinct character\\n        int maxia=0;\\n        for(int i=0;i<26;i++){\\n            maxia = max(maxia,cnta[i]);\\n        }\\n        int maxib =0;\\n        for(int i=0;i<26;i++){\\n            maxib = max(maxib,cntb[i]);\\n        }\\n        ans = min(ans,n+m-maxia-maxib);\\n        return ans;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int minCharacters(string a, string b) {\\n        int n = a.length();\\n        int m= b.length();\\n        int cnta[26];\\n        int cntb[26];\\n        memset(cnta,0,sizeof cnta);\\n        memset(cntb,0,sizeof cntb);\\n        for(int i=0;i<a.length();i++){\\n            cnta[a[i]-\\'a\\']++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1353685,
                "title": "python3-faster-than-100-memory-less-than-97-59",
                "content": "```\\nclass Solution:\\n    def minCharacters(self, a: str, b: str) -> int:\\n        cntA, cntB = [0]*26, [0]*26\\n        for i, c in enumerate(string.ascii_lowercase):\\n            cntA[i] = a.count(c)\\n            cntB[i] = b.count(c)\\n        cumA = list(accumulate(cntA))\\n        cumB = list(accumulate(cntB))\\n        minWay = float(\\'inf\\')\\n        for i in range(1, 26):\\n            ways = min(cumA[-1] - cumA[i-1] + cumB[i-1], cumB[-1] - cumB[i-1] + cumA[i-1])\\n            if ways < minWay:\\n                minWay = ways\\n        way3 = cumA[-1] - max(cntA) + cumB[-1] - max(cntB)\\n        if way3 < minWay:\\n            minWay = way3\\n        return minWay\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minCharacters(self, a: str, b: str) -> int:\\n        cntA, cntB = [0]*26, [0]*26\\n        for i, c in enumerate(string.ascii_lowercase):\\n            cntA[i] = a.count(c)\\n            cntB[i] = b.count(c)\\n        cumA = list(accumulate(cntA))\\n        cumB = list(accumulate(cntB))\\n        minWay = float(\\'inf\\')\\n        for i in range(1, 26):\\n            ways = min(cumA[-1] - cumA[i-1] + cumB[i-1], cumB[-1] - cumB[i-1] + cumA[i-1])\\n            if ways < minWay:\\n                minWay = ways\\n        way3 = cumA[-1] - max(cntA) + cumB[-1] - max(cntB)\\n        if way3 < minWay:\\n            minWay = way3\\n        return minWay\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1254888,
                "title": "easy-c-smart-implementation",
                "content": "```c++\\nclass Solution {\\npublic:\\n    \\n    vector<int>prefixs1;\\n    vector<int>prefixs2;\\n    vector<int>totalf;\\n    \\n    void calcfeq(string &s, vector<int>&feq){\\n        //calc the feq of string \\n        for(int i = 0;i<s.size();i++){\\n            int id = s[i] - \\'a\\';\\n            feq[id]++;\\n        }\\n    }\\n    //prefix part\\n    void calcprefix(){\\n        for(int i = 1;i<26;i++){\\n            prefixs1[i]+=prefixs1[i-1];\\n            prefixs2[i]+=prefixs2[i-1];\\n        }\\n    }\\n    int query(int l,int r,vector<int>&prefix){\\n        if(l==0) return prefix[r];\\n        return prefix[r] - prefix[l-1];\\n    }\\n\\n    void init(){\\n        prefixs1.resize(26,0);\\n        prefixs2.resize(26,0);\\n        totalf.resize(26,0);\\n    }\\n    int secondcase(string &s1,string &s2,vector<int>&p1,vector<int>&p2){\\n        int ans = INT_MAX;\\n        //j is for s2\\n        for(int j = 1;j<=25;j++){\\n            int currans =  query(0,j-1,p2) + query(j,25,p1);\\n            ans = min(currans,ans);\\n        }\\n        return ans;\\n    }\\n    int minCharacters(string s1, string s2) {\\n        if(s1==s2) return 0;\\n        init();\\n        calcfeq(s1,prefixs1);\\n        calcfeq(s2,prefixs2);\\n\\n        //case 3\\n        int minans = INT_MAX; //ans\\n        int total = s1.size() + s2.size();\\n        int maxfeq = 0;\\n        for(int i = 0;i<26;i++){\\n            totalf[i] = prefixs1[i] + prefixs2[i];\\n            maxfeq = max(maxfeq,totalf[i]);\\n        }\\n        minans = min(minans,total - maxfeq);\\n        calcprefix();   \\n\\n        int a1 = secondcase(s1,s2,prefixs1,prefixs2);\\n        int a2 = secondcase(s2,s1,prefixs2,prefixs1);\\n        a1 = min(a1,a2);\\n        minans = min(minans,a1);\\n        return minans;\\n    }\\n};\\n```\\n",
                "solutionTags": [],
                "code": "```c++\\nclass Solution {\\npublic:\\n    \\n    vector<int>prefixs1;\\n    vector<int>prefixs2;\\n    vector<int>totalf;\\n    \\n    void calcfeq(string &s, vector<int>&feq){\\n        //calc the feq of string \\n        for(int i = 0;i<s.size();i++){\\n            int id = s[i] - \\'a\\';\\n            feq[id]++;\\n        }\\n    }\\n    //prefix part\\n    void calcprefix(){\\n        for(int i = 1;i<26;i++){\\n            prefixs1[i]+=prefixs1[i-1];\\n            prefixs2[i]+=prefixs2[i-1];\\n        }\\n    }\\n    int query(int l,int r,vector<int>&prefix){\\n        if(l==0) return prefix[r];\\n        return prefix[r] - prefix[l-1];\\n    }\\n\\n    void init(){\\n        prefixs1.resize(26,0);\\n        prefixs2.resize(26,0);\\n        totalf.resize(26,0);\\n    }\\n    int secondcase(string &s1,string &s2,vector<int>&p1,vector<int>&p2){\\n        int ans = INT_MAX;\\n        //j is for s2\\n        for(int j = 1;j<=25;j++){\\n            int currans =  query(0,j-1,p2) + query(j,25,p1);\\n            ans = min(currans,ans);\\n        }\\n        return ans;\\n    }\\n    int minCharacters(string s1, string s2) {\\n        if(s1==s2) return 0;\\n        init();\\n        calcfeq(s1,prefixs1);\\n        calcfeq(s2,prefixs2);\\n\\n        //case 3\\n        int minans = INT_MAX; //ans\\n        int total = s1.size() + s2.size();\\n        int maxfeq = 0;\\n        for(int i = 0;i<26;i++){\\n            totalf[i] = prefixs1[i] + prefixs2[i];\\n            maxfeq = max(maxfeq,totalf[i]);\\n        }\\n        minans = min(minans,total - maxfeq);\\n        calcprefix();   \\n\\n        int a1 = secondcase(s1,s2,prefixs1,prefixs2);\\n        int a2 = secondcase(s2,s1,prefixs2,prefixs1);\\n        a1 = min(a1,a2);\\n        minans = min(minans,a1);\\n        return minans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1252216,
                "title": "o-m-n-with-kotlin",
                "content": "```\\nclass Solution {\\n    fun minCharacters(a: String, b: String): Int {\\n        var res = Int.MAX_VALUE\\n\\n        val aCounts = getAcounts(a)\\n        val bCounts = getAcounts(b)\\n\\n        for (i in aCounts.indices) {\\n            var tmp = aCounts[i] + b.length - bCounts[i]\\n            if (i == 0) {\\n                tmp += aCounts[1]\\n            }\\n            if (i==26) {\\n                tmp += bCounts[26] - bCounts[25]\\n            }\\n            if (tmp < res) {\\n                res = tmp\\n            }\\n            tmp = a.length - aCounts[i] + bCounts[i]\\n            if (i == 0) {\\n                tmp += bCounts[1]\\n            }\\n            if (i==26) {\\n                tmp += aCounts[26] - aCounts[25]\\n            }\\n            if (tmp < res) {\\n                res = tmp\\n            }\\n        }\\n\\n        var tmp = singlise(a, b)\\n        if (tmp < res) {\\n            res = tmp\\n        }\\n\\n        return  res\\n    }\\n\\n    private fun getAcounts(a: String): IntArray {\\n        var res = IntArray(27) {0}\\n        a.forEach {\\n            for (i in it - \\'a\\' + 1 until res.size) {\\n                res[i]++\\n            }\\n        }\\n        return res\\n    }\\n    \\n    private fun singlise(a: String, b: String): Int {\\n        val counts = IntArray(26) {0}\\n        a.forEach {\\n            counts[it-\\'a\\']++\\n        }\\n        b.forEach {\\n            counts[it-\\'a\\']++\\n        }\\n        return a.length + b.length - counts.max()!!\\n    }\\n}\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    fun minCharacters(a: String, b: String): Int {\\n        var res = Int.MAX_VALUE\\n\\n        val aCounts = getAcounts(a)\\n        val bCounts = getAcounts(b)\\n\\n        for (i in aCounts.indices) {\\n            var tmp = aCounts[i] + b.length - bCounts[i]\\n            if (i == 0) {\\n                tmp += aCounts[1]\\n            }\\n            if (i==26) {\\n                tmp += bCounts[26] - bCounts[25]\\n            }\\n            if (tmp < res) {\\n                res = tmp\\n            }\\n            tmp = a.length - aCounts[i] + bCounts[i]\\n            if (i == 0) {\\n                tmp += bCounts[1]\\n            }\\n            if (i==26) {\\n                tmp += aCounts[26] - aCounts[25]\\n            }\\n            if (tmp < res) {\\n                res = tmp\\n            }\\n        }\\n\\n        var tmp = singlise(a, b)\\n        if (tmp < res) {\\n            res = tmp\\n        }\\n\\n        return  res\\n    }\\n\\n    private fun getAcounts(a: String): IntArray {\\n        var res = IntArray(27) {0}\\n        a.forEach {\\n            for (i in it - \\'a\\' + 1 until res.size) {\\n                res[i]++\\n            }\\n        }\\n        return res\\n    }\\n    \\n    private fun singlise(a: String, b: String): Int {\\n        val counts = IntArray(26) {0}\\n        a.forEach {\\n            counts[it-\\'a\\']++\\n        }\\n        b.forEach {\\n            counts[it-\\'a\\']++\\n        }\\n        return a.length + b.length - counts.max()!!\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1244333,
                "title": "fast-and-concise",
                "content": "Just 9 lines and beats 90%.  \\n\\nIdea is to make prefixSum on both string a and b, so we know the cost of each condition in constant time. \\n\\nfor example, \\n\\npreSumA[2] means the number of elements in string a that are either \\'a\\' or \\'b\\', and therefore it will take \\n( preSumA[26] -  preSumA[2]) steps to convert string a to a string that has maximum char of \\'b\\'\\n\\npreSumB[2] means the number of elements in string-b that are either \\'a\\' or \\'b\\', and therefore it will take \\npreSumB[2] steps to convert string-b to a string that has minimum char of \\'c\\'\\n\\nTo satisfy condition1, we would need to find a char such that the steps to convert string-a that has maximum of that char, plus the steps to convert string-b that has minimum of that char+1. We could iterate \\'a\\' to \\'y\\' to achieve such goal. \\n\\n```\\n        counterA, counterB = Counter(a), Counter(b)\\n        preSumA, preSumB = [0 for i in range(27)], [0 for i in range(27)] # one extra space for padding\\n        for i in range(26):\\n            preSumA[i+1] = preSumA[i] + counterA[chr(ord(\\'a\\')+i)]\\n            preSumB[i+1] = preSumB[i] + counterB[chr(ord(\\'a\\')+i)]\\n        case1Res = min([preSumA[26] - preSumA[i] + preSumB[i] for i in range(1, 26)])  # \\'a\\' to \\'y\\'\\n        case2Res = min([preSumB[26] - preSumB[i] + preSumA[i] for i in range(1, 26)])  # \\'a\\' to \\'y\\'\\n        case3Res = preSumA[26]+preSumB[26] - max([v for v in counterA.values()])  - max([v for v in counterB.values()])\\n        return min([case1Res, case2Res, case3Res])\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\n        counterA, counterB = Counter(a), Counter(b)\\n        preSumA, preSumB = [0 for i in range(27)], [0 for i in range(27)] # one extra space for padding\\n        for i in range(26):\\n            preSumA[i+1] = preSumA[i] + counterA[chr(ord(\\'a\\')+i)]\\n            preSumB[i+1] = preSumB[i] + counterB[chr(ord(\\'a\\')+i)]\\n        case1Res = min([preSumA[26] - preSumA[i] + preSumB[i] for i in range(1, 26)])  # \\'a\\' to \\'y\\'\\n        case2Res = min([preSumB[26] - preSumB[i] + preSumA[i] for i in range(1, 26)])  # \\'a\\' to \\'y\\'\\n        case3Res = preSumA[26]+preSumB[26] - max([v for v in counterA.values()])  - max([v for v in counterB.values()])\\n        return min([case1Res, case2Res, case3Res])\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1225202,
                "title": "simple-go",
                "content": "```\\nfunc minCharacters(a string, b string) int {\\n    aStat := make([]int, 26)\\n    bStat := make([]int, 26)\\n    \\n    aMin, aMax := \\'z\\', \\'a\\'\\n    bMin, bMax := \\'z\\', \\'a\\'\\n    \\n    for _, letter := range a {\\n        aStat[letter-\\'a\\']++\\n        aMin = min(aMin, letter)\\n        aMax = max(aMax, letter)\\n    }\\n    for _, letter := range b {\\n        bStat[letter-\\'a\\']++\\n        bMin = min(bMin, letter)\\n        bMax = max(bMax, letter)\\n    }\\n    \\n    ret := int(1e5) + 1\\n    \\n    //first case\\n    accum := 0\\n    for i:=bMin-\\'a\\'; i<26; i++ { // b\\'s smallest character\\n        if i == 0 {\\n            accum += bStat[i]\\n            continue\\n        }\\n        curRet := accum\\n        \\n        for j:=i; j<26; j++ { // num of operations needed\\n            curRet += aStat[j]\\n        }\\n        ret = intMin(ret, curRet)\\n        accum += bStat[i]\\n    }\\n    \\n    //second case\\n    accum = 0\\n    for i:=aMin-\\'a\\'; i<26; i++ {\\n        if i == 0 {\\n            accum += aStat[i]\\n            continue\\n        }\\n        curRet := accum\\n        \\n        for j:=i; j<26; j++ {\\n            curRet += bStat[j]\\n        }\\n        ret = intMin(ret, curRet)\\n        accum += aStat[i]\\n    }\\n    \\n    //third case\\n    aMaxFreq := 0\\n    bMaxFreq := 0\\n    for i:=0; i<26; i++ {\\n        aMaxFreq = intMax(aMaxFreq, aStat[i])\\n        bMaxFreq = intMax(bMaxFreq, bStat[i])\\n    }\\n    \\n    ret = intMin(ret, len(a)-aMaxFreq + len(b)-bMaxFreq)\\n    return ret\\n    \\n}\\n\\nfunc intMin(a, b int) int {\\n    if a < b {\\n        return a\\n    }\\n    return b\\n}\\n\\nfunc intMax(a, b int) int {\\n    if a > b {\\n        return a\\n    }\\n    return b\\n}\\n\\nfunc max(a, b rune) rune {\\n    if a > b {\\n        return a\\n    }\\n    return b\\n}\\n\\nfunc min(a, b rune) rune {\\n    if a > b {\\n        return b\\n    }\\n    return a\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nfunc minCharacters(a string, b string) int {\\n    aStat := make([]int, 26)\\n    bStat := make([]int, 26)\\n    \\n    aMin, aMax := \\'z\\', \\'a\\'\\n    bMin, bMax := \\'z\\', \\'a\\'\\n    \\n    for _, letter := range a {\\n        aStat[letter-\\'a\\']++\\n        aMin = min(aMin, letter)\\n        aMax = max(aMax, letter)\\n    }\\n    for _, letter := range b {\\n        bStat[letter-\\'a\\']++\\n        bMin = min(bMin, letter)\\n        bMax = max(bMax, letter)\\n    }\\n    \\n    ret := int(1e5) + 1\\n    \\n    //first case\\n    accum := 0\\n    for i:=bMin-\\'a\\'; i<26; i++ { // b\\'s smallest character\\n        if i == 0 {\\n            accum += bStat[i]\\n            continue\\n        }\\n        curRet := accum\\n        \\n        for j:=i; j<26; j++ { // num of operations needed\\n            curRet += aStat[j]\\n        }\\n        ret = intMin(ret, curRet)\\n        accum += bStat[i]\\n    }\\n    \\n    //second case\\n    accum = 0\\n    for i:=aMin-\\'a\\'; i<26; i++ {\\n        if i == 0 {\\n            accum += aStat[i]\\n            continue\\n        }\\n        curRet := accum\\n        \\n        for j:=i; j<26; j++ {\\n            curRet += bStat[j]\\n        }\\n        ret = intMin(ret, curRet)\\n        accum += aStat[i]\\n    }\\n    \\n    //third case\\n    aMaxFreq := 0\\n    bMaxFreq := 0\\n    for i:=0; i<26; i++ {\\n        aMaxFreq = intMax(aMaxFreq, aStat[i])\\n        bMaxFreq = intMax(bMaxFreq, bStat[i])\\n    }\\n    \\n    ret = intMin(ret, len(a)-aMaxFreq + len(b)-bMaxFreq)\\n    return ret\\n    \\n}\\n\\nfunc intMin(a, b int) int {\\n    if a < b {\\n        return a\\n    }\\n    return b\\n}\\n\\nfunc intMax(a, b int) int {\\n    if a > b {\\n        return a\\n    }\\n    return b\\n}\\n\\nfunc max(a, b rune) rune {\\n    if a > b {\\n        return a\\n    }\\n    return b\\n}\\n\\nfunc min(a, b rune) rune {\\n    if a > b {\\n        return b\\n    }\\n    return a\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1196171,
                "title": "javascript-o-m-n",
                "content": "```\\n/**\\n * @param {string} a\\n * @param {string} b\\n * @return {number}\\n */\\nvar minCharacters = function(a, b) {\\n    const aCode = 97\\n    function getInfo(s) {\\n        const len = s.length\\n        const table = new Array(26).fill(0)\\n        \\n        for (let i = 0; i < len; i++) {\\n            const code = s.charCodeAt(i)\\n            const offset = code - aCode\\n            table[offset]++\\n        }\\n        \\n        const countSF = new Array(26)\\n        countSF[-1] = 0\\n        for (const [i, count] of table.entries()) {\\n            countSF[i] = count + countSF[-1 + i]\\n        }\\n        \\n        return { len, countSF, table }\\n    }\\n    \\n    // how many steps to make A < B\\n    function getChangeSize(infoA, infoB) {\\n        const { len: lenA, countSF: countSFA } = infoA\\n        const { len: lenB, countSF: countSFB } = infoB\\n        \\n        let result = Infinity\\n        for (let offset = 0; offset < 25; offset++) {\\n            const stepsA = lenA - countSFA[offset]\\n            const stepsB = countSFB[offset]\\n            \\n            let outcome = stepsA + stepsB\\n            result = Math.min(result, outcome)\\n        }\\n        \\n        return result\\n    }\\n    \\n    \\n    const infoA = getInfo(a), infoB = getInfo(b)\\n    let resultA2B = getChangeSize(infoA, infoB)\\n    let resultB2A = getChangeSize(infoB, infoA)\\n    \\n    const maxCountA = Math.max(...infoA.table)\\n    const maxCountB = Math.max(...infoB.table)\\n    const stepsA = infoA.len - maxCountA\\n    const stepsB = infoB.len - maxCountB\\n    let resultUnique = stepsA + stepsB\\n    \\n    \\n    let result = Math.min(resultA2B, resultB2A, resultUnique)\\n    return result\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * @param {string} a\\n * @param {string} b\\n * @return {number}\\n */\\nvar minCharacters = function(a, b) {\\n    const aCode = 97\\n    function getInfo(s) {\\n        const len = s.length\\n        const table = new Array(26).fill(0)\\n        \\n        for (let i = 0; i < len; i++) {\\n            const code = s.charCodeAt(i)\\n            const offset = code - aCode\\n            table[offset]++\\n        }\\n        \\n        const countSF = new Array(26)\\n        countSF[-1] = 0\\n        for (const [i, count] of table.entries()) {\\n            countSF[i] = count + countSF[-1 + i]\\n        }\\n        \\n        return { len, countSF, table }\\n    }\\n    \\n    // how many steps to make A < B\\n    function getChangeSize(infoA, infoB) {\\n        const { len: lenA, countSF: countSFA } = infoA\\n        const { len: lenB, countSF: countSFB } = infoB\\n        \\n        let result = Infinity\\n        for (let offset = 0; offset < 25; offset++) {\\n            const stepsA = lenA - countSFA[offset]\\n            const stepsB = countSFB[offset]\\n            \\n            let outcome = stepsA + stepsB\\n            result = Math.min(result, outcome)\\n        }\\n        \\n        return result\\n    }\\n    \\n    \\n    const infoA = getInfo(a), infoB = getInfo(b)\\n    let resultA2B = getChangeSize(infoA, infoB)\\n    let resultB2A = getChangeSize(infoB, infoA)\\n    \\n    const maxCountA = Math.max(...infoA.table)\\n    const maxCountB = Math.max(...infoB.table)\\n    const stepsA = infoA.len - maxCountA\\n    const stepsB = infoB.len - maxCountB\\n    let resultUnique = stepsA + stepsB\\n    \\n    \\n    let result = Math.min(resultA2B, resultB2A, resultUnique)\\n    return result\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1173466,
                "title": "easy-c-soln-divided-in-parts",
                "content": "```\\nclass Solution {\\npublic:\\n    int soln(vector<int> &cnt,bool greater,int i){\\n        int res=0;\\n        if(greater){\\n            for(int k=0;k<i;k++){\\n                res+=cnt[k];\\n            }\\n        }\\n        else {\\n             for(int k=i;k<26;k++){\\n                res+=cnt[k];\\n             }\\n        }\\n        return res;\\n            \\n        \\n    }\\n    int minCharacters(string a, string b) {\\n       \\n        vector<int> cnta(26,0),cntb(26,0);\\n        for(int i=0;i<a.length();i++)cnta[a[i]-\\'a\\']++;\\n        for(int i=0;i<b.length();i++)cntb[b[i]-\\'a\\']++;\\n         int rsa=INT_MAX,rsb=INT_MAX;\\n        for(int i=0;i<26;i++){\\n           int tmpa=0,tmpb=0;\\n            for(int j=0;j<26;j++){\\n                if(i!=j){\\n                    tmpa+=cnta[j];\\n                    tmpb+=cntb[j];\\n                }\\n\\n            }\\n            rsa=min(rsa,tmpa);\\n            rsb=min(rsb,tmpb);\\n        }\\n        //for condition 3\\n        int ans3=rsa+rsb;\\n        //for condition 1\\n        int ans1=INT_MAX;\\n        for(int i=1;i<26;i++){\\n            int x=soln(cnta,true,i)+soln(cntb,false,i);\\n            ans1=min(ans1,x);\\n            \\n            \\n        }\\n        //for condition 2;\\n        int ans2=INT_MAX;\\n        for(int i=1;i<26;i++){\\n            int x=soln(cntb,true,i)+soln(cnta,false,i);\\n            ans2=min(ans2,x);\\n        }\\n        return min(ans1,min(ans2,ans3));\\n        \\n        \\n        \\n            \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int soln(vector<int> &cnt,bool greater,int i){\\n        int res=0;\\n        if(greater){\\n            for(int k=0;k<i;k++){\\n                res+=cnt[k];\\n            }\\n        }\\n        else {\\n             for(int k=i;k<26;k++){\\n                res+=cnt[k];\\n             }\\n        }\\n        return res;\\n            \\n        \\n    }\\n    int minCharacters(string a, string b) {\\n       \\n        vector<int> cnta(26,0),cntb(26,0);\\n        for(int i=0;i<a.length();i++)cnta[a[i]-\\'a\\']++;\\n        for(int i=0;i<b.length();i++)cntb[b[i]-\\'a\\']++;\\n         int rsa=INT_MAX,rsb=INT_MAX;\\n        for(int i=0;i<26;i++){\\n           int tmpa=0,tmpb=0;\\n            for(int j=0;j<26;j++){\\n                if(i!=j){\\n                    tmpa+=cnta[j];\\n                    tmpb+=cntb[j];\\n                }\\n\\n            }\\n            rsa=min(rsa,tmpa);\\n            rsb=min(rsb,tmpb);\\n        }\\n        //for condition 3\\n        int ans3=rsa+rsb;\\n        //for condition 1\\n        int ans1=INT_MAX;\\n        for(int i=1;i<26;i++){\\n            int x=soln(cnta,true,i)+soln(cntb,false,i);\\n            ans1=min(ans1,x);\\n            \\n            \\n        }\\n        //for condition 2;\\n        int ans2=INT_MAX;\\n        for(int i=1;i<26;i++){\\n            int x=soln(cntb,true,i)+soln(cnta,false,i);\\n            ans2=min(ans2,x);\\n        }\\n        return min(ans1,min(ans2,ans3));\\n        \\n        \\n        \\n            \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1154806,
                "title": "python-solution-beats-100-using-counter",
                "content": "from collections import Counter\\nclass Solution:\\n\\n    def minCharacters(self, a: str, b: str) -> int:\\n        ca = Counter(a)\\n        cb = Counter(b)\\n        l1 = [ca.get(\"a\",0)] # calculate prefix sum for every letter\\n        l2 = [cb.get(\"a\",0)]\\n        goal1 = goal2 = float(\"inf\")\\n        for i in range(1,26):\\n            l1.append(ca.get(chr(97+i),0)+l1[-1])\\n            l2.append(cb.get(chr(97+i),0)+l2[-1])\\n            goal1 = min(len(a)-l1[i-1]+l2[i-1], goal1) # make every letter in a is strictly less than every letter in b in the alphabet.\\n            goal2 = min(l1[i-1]+len(b)-l2[i-1], goal2) # make every letter in b is strictly less than every letter in a in the alphabet\\n\\n        return min(goal1, goal2, len(a)-max(ca.values())+len(b)-max(cb.values()))",
                "solutionTags": [
                    "Python"
                ],
                "code": "from collections import Counter\\nclass Solution:\\n\\n    def minCharacters(self, a: str, b: str) -> int:\\n        ca = Counter(a)\\n        cb = Counter(b)\\n        l1 = [ca.get(\"a\",0)] # calculate prefix sum for every letter\\n        l2 = [cb.get(\"a\",0)]\\n        goal1 = goal2 = float(\"inf\")\\n        for i in range(1,26):\\n            l1.append(ca.get(chr(97+i),0)+l1[-1])\\n            l2.append(cb.get(chr(97+i),0)+l2[-1])\\n            goal1 = min(len(a)-l1[i-1]+l2[i-1], goal1) # make every letter in a is strictly less than every letter in b in the alphabet.\\n            goal2 = min(l1[i-1]+len(b)-l2[i-1], goal2) # make every letter in b is strictly less than every letter in a in the alphabet\\n\\n        return min(goal1, goal2, len(a)-max(ca.values())+len(b)-max(cb.values()))",
                "codeTag": "Java"
            },
            {
                "id": 1152372,
                "title": "c-easy-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int minCharacters(string a, string b) {\\n        int c1=INT_MAX;\\n        for(int i=1;i<26;i++)\\n        {\\n            char ll=\\'a\\'+i;\\n            int qw=0;\\n            for(int j=0;j<a.size();j++)\\n            {\\n                if(a[j]>=ll)\\n                {\\n                    qw++;\\n                }\\n            }\\n            for(int j=0;j<b.size();j++)\\n            {\\n                if(b[j]<ll)\\n                {\\n                    qw++;\\n                }\\n            }\\n            c1=min(c1,qw);\\n        }\\n        int c2=INT_MAX;\\n        for(int i=1;i<26;i++)\\n        {\\n            char ll=\\'a\\'+i;\\n            int qw=0;\\n            for(int j=0;j<b.size();j++)\\n            {\\n                if(b[j]>=ll)\\n                {\\n                    qw++;\\n                }\\n            }\\n            for(int j=0;j<a.size();j++)\\n            {\\n                if(a[j]<ll)\\n                {\\n                    qw++;\\n                }\\n            }\\n            c2=min(c2,qw);\\n        }\\n        vector<int>alpha(26);\\n        for(int i=0;i<a.size();i++)\\n        {\\n            alpha[a[i]-\\'a\\']++;\\n        }\\n        int yu=*max_element(alpha.begin(),alpha.end());\\n        int er = a.size()-yu;\\n        int ans=0;\\n        vector<int>alpha2(26);\\n        for(int i=0;i<b.size();i++)\\n        {\\n            alpha2[b[i]-\\'a\\']++;\\n        }\\n        int qw=*max_element(alpha2.begin(),alpha2.end());\\n        int zz=b.size()-qw;\\n        int c3=zz+er;\\n        ans=min(c1,c2);\\n        ans=min(ans,c3);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minCharacters(string a, string b) {\\n        int c1=INT_MAX;\\n        for(int i=1;i<26;i++)\\n        {\\n            char ll=\\'a\\'+i;\\n            int qw=0;\\n            for(int j=0;j<a.size();j++)\\n            {\\n                if(a[j]>=ll)\\n                {\\n                    qw++;\\n                }\\n            }\\n            for(int j=0;j<b.size();j++)\\n            {\\n                if(b[j]<ll)\\n                {\\n                    qw++;\\n                }\\n            }\\n            c1=min(c1,qw);\\n        }\\n        int c2=INT_MAX;\\n        for(int i=1;i<26;i++)\\n        {\\n            char ll=\\'a\\'+i;\\n            int qw=0;\\n            for(int j=0;j<b.size();j++)\\n            {\\n                if(b[j]>=ll)\\n                {\\n                    qw++;\\n                }\\n            }\\n            for(int j=0;j<a.size();j++)\\n            {\\n                if(a[j]<ll)\\n                {\\n                    qw++;\\n                }\\n            }\\n            c2=min(c2,qw);\\n        }\\n        vector<int>alpha(26);\\n        for(int i=0;i<a.size();i++)\\n        {\\n            alpha[a[i]-\\'a\\']++;\\n        }\\n        int yu=*max_element(alpha.begin(),alpha.end());\\n        int er = a.size()-yu;\\n        int ans=0;\\n        vector<int>alpha2(26);\\n        for(int i=0;i<b.size();i++)\\n        {\\n            alpha2[b[i]-\\'a\\']++;\\n        }\\n        int qw=*max_element(alpha2.begin(),alpha2.end());\\n        int zz=b.size()-qw;\\n        int c3=zz+er;\\n        ans=min(c1,c2);\\n        ans=min(ans,c3);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1098896,
                "title": "java-7ms-time-100-space-99-74",
                "content": "```\\nclass Solution {\\n    public int minCharacters(String a, String b) {\\n        int[] ca=new int[26], cb=new int[26];\\n        int la=a.length(), lb=b.length();\\n        for(char x:a.toCharArray())ca[x-\\'a\\']++;\\n        for(char x:b.toCharArray())cb[x-\\'a\\']++;\\n        int ret = rule12(ca, cb, la, lb);\\n        ret = Math.min(ret, rule12(cb, ca, lb, la));\\n        if(la+lb<=26)ret = Math.min(ret, rule3(ca,cb,la+lb));\\n        return ret;\\n    }\\n    public int rule12(int[] ca, int[] cb, int la, int lb){\\n        int ret = la-ca[0]+cb[0], tmp = ret;\\n        for(int i=1; i<25; i++){\\n            tmp += cb[i]-ca[i];\\n            if(ret>tmp)ret=tmp;\\n        }\\n        return ret;\\n    }\\n    \\n    public int rule3(int[] ca, int[] cb, int l){\\n        int x = 0;\\n        for(int i=0; i<26; i++)if(x<ca[i]+cb[i])x=ca[i]+cb[i];\\n        return l-x;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minCharacters(String a, String b) {\\n        int[] ca=new int[26], cb=new int[26];\\n        int la=a.length(), lb=b.length();\\n        for(char x:a.toCharArray())ca[x-\\'a\\']++;\\n        for(char x:b.toCharArray())cb[x-\\'a\\']++;\\n        int ret = rule12(ca, cb, la, lb);\\n        ret = Math.min(ret, rule12(cb, ca, lb, la));\\n        if(la+lb<=26)ret = Math.min(ret, rule3(ca,cb,la+lb));\\n        return ret;\\n    }\\n    public int rule12(int[] ca, int[] cb, int la, int lb){\\n        int ret = la-ca[0]+cb[0], tmp = ret;\\n        for(int i=1; i<25; i++){\\n            tmp += cb[i]-ca[i];\\n            if(ret>tmp)ret=tmp;\\n        }\\n        return ret;\\n    }\\n    \\n    public int rule3(int[] ca, int[] cb, int l){\\n        int x = 0;\\n        for(int i=0; i<26; i++)if(x<ca[i]+cb[i])x=ca[i]+cb[i];\\n        return l-x;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1079865,
                "title": "swift-solution",
                "content": "Swift solution\\n```\\nclass Solution {\\n    let alphabet = 26\\n    private func translate(_ s: String) -> [Int] {\\n        Array(s).reduce(into: [Int](repeating: 0, count: alphabet), { $0[Int($1.asciiValue ?? 97) - 97] += 1 })\\n    }\\n    func minCharacters(_ a: String, _ b: String) -> Int {\\n        let a = translate(a), b = translate(b)\\n        var al2r = [Int](repeating: 0, count: alphabet), ar2l = al2r, bl2r = al2r, br2l = al2r, result = Int.max\\n        for i in 1..<alphabet {\\n            al2r[i] = al2r[i - 1] + a[i - 1]\\n            bl2r[i] = bl2r[i - 1] + b[i - 1]\\n            ar2l[alphabet - 1 - i] = ar2l[alphabet - i] + a[alphabet - i]\\n            br2l[alphabet - 1 - i] = br2l[alphabet - i] + b[alphabet - i]\\n        }\\n        for i in 0..<alphabet {\\n            let condition1 = i < alphabet - 1 ? ar2l[i] + bl2r[i + 1] : Int.max\\n            let condition2 = i < alphabet - 1 ? br2l[i] + al2r[i + 1] : Int.max\\n            let condition3 = al2r[i] + ar2l[i] + bl2r[i] + br2l[i]\\n            result = min(result, condition1, condition2, condition3)\\n        }\\n        return result\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    let alphabet = 26\\n    private func translate(_ s: String) -> [Int] {\\n        Array(s).reduce(into: [Int](repeating: 0, count: alphabet), { $0[Int($1.asciiValue ?? 97) - 97] += 1 })\\n    }\\n    func minCharacters(_ a: String, _ b: String) -> Int {\\n        let a = translate(a), b = translate(b)\\n        var al2r = [Int](repeating: 0, count: alphabet), ar2l = al2r, bl2r = al2r, br2l = al2r, result = Int.max\\n        for i in 1..<alphabet {\\n            al2r[i] = al2r[i - 1] + a[i - 1]\\n            bl2r[i] = bl2r[i - 1] + b[i - 1]\\n            ar2l[alphabet - 1 - i] = ar2l[alphabet - i] + a[alphabet - i]\\n            br2l[alphabet - 1 - i] = br2l[alphabet - i] + b[alphabet - i]\\n        }\\n        for i in 0..<alphabet {\\n            let condition1 = i < alphabet - 1 ? ar2l[i] + bl2r[i + 1] : Int.max\\n            let condition2 = i < alphabet - 1 ? br2l[i] + al2r[i + 1] : Int.max\\n            let condition3 = al2r[i] + ar2l[i] + bl2r[i] + br2l[i]\\n            result = min(result, condition1, condition2, condition3)\\n        }\\n        return result\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1077416,
                "title": "c-o-n",
                "content": "```\\nclass Solution {\\npublic:\\n    int minCharacters(string a, string b) {\\n        vector<int> l(26),r(26);\\n        \\n        //most freq char in a and b\\n        int x=0,y=0;\\n        for(char c : a)\\n            l[c-\\'a\\']++,x=max(x,l[c-\\'a\\']);\\n        for(char c : b)\\n            r[c-\\'a\\']++,y=max(y,r[c-\\'a\\']);\\n        \\n        \\n        int ans=a.size()-x+b.size()-y;\\n        \\n        //a<b\\n        for(int k=0;k<2;k++){\\n            for(int i=0;i<25;i++){\\n                int less=0,more=0;\\n                for(int j=i+1;j<26;j++)\\n                    more+=l[j];\\n                for(int j=0;j<i+1;j++)\\n                    less+=r[j];\\n                ans=min(ans,less+more);\\n            }\\n            swap(l,r);\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int minCharacters(string a, string b) {\\n        vector<int> l(26),r(26);\\n        \\n        //most freq char in a and b\\n        int x=0,y=0;\\n        for(char c : a)\\n            l[c-\\'a\\']++,x=max(x,l[c-\\'a\\']);\\n        for(char c : b)\\n            r[c-\\'a\\']++,y=max(y,r[c-\\'a\\']);\\n        \\n        \\n        int ans=a.size()-x+b.size()-y;\\n        \\n        //a<b\\n        for(int k=0;k<2;k++){\\n            for(int i=0;i<25;i++){\\n                int less=0,more=0;\\n                for(int j=i+1;j<26;j++)\\n                    more+=l[j];\\n                for(int j=0;j<i+1;j++)\\n                    less+=r[j];\\n                ans=min(ans,less+more);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1044407,
                "title": "python-just-loop-through-all-the-lowercase-letter",
                "content": "Count and loop through lowercase letters from a to z and compare the 3 cases.  Condition 3 (Both a and b consist of only one distinct letter) is a bit ambiguous but it should be clear once you see WA.\\n```\\nclass Solution:\\n    def minCharacters(self, a: str, b: str) -> int:\\n        cnta = collections.Counter(a)\\n        cntb = collections.Counter(b)\\n        lena, lenb = len(a), len(b)\\n        res = lena + lenb\\n        cuma, cumb = 0, 0\\n        for i in range(26):\\n            x = chr(i+97)\\n            cuma += cnta[x]\\n            cumb += cntb[x]\\n            if i <= 24:\\n                # change every thing in a to be <= x and everything in b to be > x\\n                res = min(res, lena-cuma + cumb)\\n                # change everything in b to be <= x and everything in a to be > x\\n                res = min(res, lenb-cumb + cuma)\\n            # change everthing in a and b to x\\n            res = min(res, lenb-cntb[x]+lena-cnta[x])\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minCharacters(self, a: str, b: str) -> int:\\n        cnta = collections.Counter(a)\\n        cntb = collections.Counter(b)\\n        lena, lenb = len(a), len(b)\\n        res = lena + lenb\\n        cuma, cumb = 0, 0\\n        for i in range(26):\\n            x = chr(i+97)\\n            cuma += cnta[x]\\n            cumb += cntb[x]\\n            if i <= 24:\\n                # change every thing in a to be <= x and everything in b to be > x\\n                res = min(res, lena-cuma + cumb)\\n                # change everything in b to be <= x and everything in a to be > x\\n                res = min(res, lenb-cumb + cuma)\\n            # change everthing in a and b to x\\n            res = min(res, lenb-cntb[x]+lena-cnta[x])\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1043918,
                "title": "c-o-n-concise",
                "content": "```\\nclass Solution {\\npublic:\\n    int minCharacters(string a, string b) {\\n        auto c1 = cnt(a), c2 = cnt(b);\\n        int res = a.size() + b.size() - numMax(c1, c2);\\n        return min({res, numOpToChangStrictlyLess(c1, c2), numOpToChangStrictlyLess(c2, c1)});\\n    }\\n    \\n    vector<int> cnt(const string& s){\\n        vector<int> cnt(26);\\n        for(auto c:s) cnt[c-\\'a\\']++;\\n        return cnt;\\n    }\\n    \\n    int numMax(vector<int>& v1, vector<int>& v2){\\n        int res = 0;\\n        for(int i=0;i<26;i++) res = max(res, v1[i] + v2[i]);\\n        return res;\\n    }\\n    \\n    int numOpToChangStrictlyLess(const vector<int>& v1, const vector<int>& v2){\\n        int res = 99999999;\\n        for(char pivot = \\'b\\'; pivot <= \\'z\\'; pivot++){\\n            const int p = pivot - \\'a\\';\\n            int numToMoveLeftInV1 = accumulate(v1.begin()+p, v1.end(), 0);\\n            int numToMoveRightInV2 = accumulate(v2.begin(), v2.begin()+p, 0);\\n            res = min(res, numToMoveLeftInV1 + numToMoveRightInV2);\\n        }\\n        return res;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int minCharacters(string a, string b) {\\n        auto c1 = cnt(a), c2 = cnt(b);\\n        int res = a.size() + b.size() - numMax(c1, c2);\\n        return min({res, numOpToChangStrictlyLess(c1, c2), numOpToChangStrictlyLess(c2, c1)}",
                "codeTag": "Java"
            },
            {
                "id": 1040646,
                "title": "java-code-with-comments",
                "content": "```\\nclass Solution {\\n    public int minCharacters(String a, String b) {\\n        int ans = Integer.MAX_VALUE;\\n        \\n        //WE call the make method for first two conditions. First call makes a smaller than b and second one makes b smaller than a.\\n        ans = Math.min(make(a,b),make(b,a));\\n        \\n        //This is for the 3rd conditions. We count the steps to make the strings contain only one distinct character.\\n        for(char ch=\\'a\\';ch<=\\'z\\';ch++){\\n            \\n            int total = a.length() + b.length();\\n            \\n            for(char c:a.toCharArray())\\n                if(c==ch)\\n                    total--;\\n            for(char c:b.toCharArray())\\n                if(c==ch)\\n                    total--;\\n            \\n            ans = Math.min(total,ans);\\n            \\n        }\\n        \\n        \\n        return ans;\\n    }\\n    \\n    //This method checks for the first two conditions\\n    //For given string a and b, we try to make a smaller than b . We count the no of steps needed to make a smaller than b . We return the minimum value for it.\\n    public int make(String a, String b){\\n        \\n        int local = Integer.MAX_VALUE;\\n        \\n        for(char ch=\\'b\\';ch<=\\'z\\';ch++){\\n            \\n            int temp = 0;\\n            for(char c:a.toCharArray()){\\n                if(c>=ch)\\n                    temp++;\\n            }\\n            \\n            for(char c:b.toCharArray()){\\n                if(c<ch)\\n                    temp++;\\n            }\\n            local = Math.min(local,temp);\\n            \\n        }\\n        \\n        return local;\\n    }\\n    \\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minCharacters(String a, String b) {\\n        int ans = Integer.MAX_VALUE;\\n        \\n        //WE call the make method for first two conditions. First call makes a smaller than b and second one makes b smaller than a.\\n        ans = Math.min(make(a,b),make(b,a));\\n        \\n        //This is for the 3rd conditions. We count the steps to make the strings contain only one distinct character.\\n        for(char ch=\\'a\\';ch<=\\'z\\';ch++){\\n            \\n            int total = a.length() + b.length();\\n            \\n            for(char c:a.toCharArray())\\n                if(c==ch)\\n                    total--;\\n            for(char c:b.toCharArray())\\n                if(c==ch)\\n                    total--;\\n            \\n            ans = Math.min(total,ans);\\n            \\n        }\\n        \\n        \\n        return ans;\\n    }\\n    \\n    //This method checks for the first two conditions\\n    //For given string a and b, we try to make a smaller than b . We count the no of steps needed to make a smaller than b . We return the minimum value for it.\\n    public int make(String a, String b){\\n        \\n        int local = Integer.MAX_VALUE;\\n        \\n        for(char ch=\\'b\\';ch<=\\'z\\';ch++){\\n            \\n            int temp = 0;\\n            for(char c:a.toCharArray()){\\n                if(c>=ch)\\n                    temp++;\\n            }\\n            \\n            for(char c:b.toCharArray()){\\n                if(c<ch)\\n                    temp++;\\n            }\\n            local = Math.min(local,temp);\\n            \\n        }\\n        \\n        return local;\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1038177,
                "title": "kotlin-1737-change-minimum-characters-to-satisfy-one-of-three-conditions-counting-letters",
                "content": "```\\ninline fun min(a:Int,b:Int, c:Int):Int{\\n    return Math.min(Math.min(a,b), c)\\n}\\n\\ninline fun <T> Map<T,Int>.mergeIntoHashMap(other:Map<T,Int>):Map<T,Int>{\\n    val totoalFreq =  HashMap<T,Int>()\\n    for((chA,freqA) in this){\\n        totoalFreq[chA] = (totoalFreq[chA]?:0) + freqA\\n    }\\n            \\n    for((chB,freqB) in other){\\n       totoalFreq[chB] =  (totoalFreq[chB]?:0) + freqB\\n    }\\n    \\n    return totoalFreq\\n}\\n\\nclass Solution {\\n    fun minCharacters(a: String, b: String): Int {\\n        var aFreq = a.groupingBy{it}.eachCount()\\n        var bFreq = b.groupingBy{it}.eachCount()\\n        \\n        return min(everyLetterIsSmaller(aFreq, bFreq), \\n                   everyLetterIsSmaller(bFreq, aFreq),\\n                   a.length + b.length - (aFreq.mergeIntoHashMap(bFreq).values.max()?:0)\\n        )\\n    }\\n    \\n    // Every letter in a is strictly less than every letter in b in the alphabet.\\n    fun everyLetterIsSmaller(aFreq: Map<Char,Int>, bFreq: Map<Char,Int>):Int{\\n        var res = Int.MAX_VALUE\\n        \\n        for(i in 1 until 26){\\n            var count = 0\\n\\t\\t\\t\\n            for((chA,freqA) in aFreq){\\n                if ((chA - \\'a\\') >= i) count+=freqA\\n            }\\n            \\n            for((chB,freqB) in bFreq){\\n                if ((chB - \\'a\\') < i) count+=freqB\\n            }\\n            \\n\\t\\t    res = Math.min(res, count);\\n        }\\n        \\n        return res\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\ninline fun min(a:Int,b:Int, c:Int):Int{\\n    return Math.min(Math.min(a,b), c)\\n}\\n\\ninline fun <T> Map<T,Int>.mergeIntoHashMap(other:Map<T,Int>):Map<T,Int>{\\n    val totoalFreq =  HashMap<T,Int>()\\n    for((chA,freqA) in this){\\n        totoalFreq[chA] = (totoalFreq[chA]?:0) + freqA\\n    }\\n            \\n    for((chB,freqB) in other){\\n       totoalFreq[chB] =  (totoalFreq[chB]?:0) + freqB\\n    }\\n    \\n    return totoalFreq\\n}\\n\\nclass Solution {\\n    fun minCharacters(a: String, b: String): Int {\\n        var aFreq = a.groupingBy{it}.eachCount()\\n        var bFreq = b.groupingBy{it}.eachCount()\\n        \\n        return min(everyLetterIsSmaller(aFreq, bFreq), \\n                   everyLetterIsSmaller(bFreq, aFreq),\\n                   a.length + b.length - (aFreq.mergeIntoHashMap(bFreq).values.max()?:0)\\n        )\\n    }\\n    \\n    // Every letter in a is strictly less than every letter in b in the alphabet.\\n    fun everyLetterIsSmaller(aFreq: Map<Char,Int>, bFreq: Map<Char,Int>):Int{\\n        var res = Int.MAX_VALUE\\n        \\n        for(i in 1 until 26){\\n            var count = 0\\n\\t\\t\\t\\n            for((chA,freqA) in aFreq){\\n                if ((chA - \\'a\\') >= i) count+=freqA\\n            }\\n            \\n            for((chB,freqB) in bFreq){\\n                if ((chB - \\'a\\') < i) count+=freqB\\n            }\\n            \\n\\t\\t    res = Math.min(res, count);\\n        }\\n        \\n        return res\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1037409,
                "title": "c-o-a-b-time-o-1-space",
                "content": "```\\nclass Solution {\\n    int strictlyLess(vector<int> A, vector<int> B) {\\n        // A < B\\n        for (int i = 24; i >= 0; --i) A[i] += A[i + 1];\\n        for (int j = 1; j < 26; ++j) B[j] += B[j - 1];\\n        \\n        int changes = INT_MAX;\\n        // change A[k....25] to A[0]\\n        // change B[0...k-1] to B[25]\\n        for (int k = 1; k < 26; ++k)\\n            changes = min(changes, A[k] + B[k - 1]);\\n        return changes;\\n    }\\n    \\npublic:\\n    int minCharacters(string a, string b) {\\n        vector<int> A(26, 0), B(26, 0);\\n        for (char c : a) ++A[c - \\'a\\'];\\n        for (char c : b) ++B[c - \\'a\\'];\\n        int k = a.length() - *max_element(begin(A), end(A)) +\\n                b.length() - *max_element(begin(B), end(B));\\n        return min(min(strictlyLess(A, B), strictlyLess(B, A)), k);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    int strictlyLess(vector<int> A, vector<int> B) {\\n        // A < B\\n        for (int i = 24; i >= 0; --i) A[i] += A[i + 1];\\n        for (int j = 1; j < 26; ++j) B[j] += B[j - 1];\\n        \\n        int changes = INT_MAX;\\n        // change A[k....25] to A[0]\\n        // change B[0...k-1] to B[25]\\n        for (int k = 1; k < 26; ++k)\\n            changes = min(changes, A[k] + B[k - 1]);\\n        return changes;\\n    }\\n    \\npublic:\\n    int minCharacters(string a, string b) {\\n        vector<int> A(26, 0), B(26, 0);\\n        for (char c : a) ++A[c - \\'a\\'];\\n        for (char c : b) ++B[c - \\'a\\'];\\n        int k = a.length() - *max_element(begin(A), end(A)) +\\n                b.length() - *max_element(begin(B), end(B));\\n        return min(min(strictlyLess(A, B), strictlyLess(B, A)), k);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1035938,
                "title": "java-easy-solution-o-n",
                "content": "\\tclass Solution {\\n\\t\\tpublic int minCharacters(String a, String b) {\\n\\t\\t\\tint min = Integer.MAX_VALUE, to1 = 0 , to2 = 0;\\n\\t\\t\\tint[] count1 = new int[26];\\n\\t\\t\\tint[] count2 = new int[26];\\n\\n\\t\\t\\tfor(int i =0 ;i<a.length();i++) {\\n\\t\\t\\t\\tint c = a.charAt(i) - \\'a\\';\\n\\t\\t\\t\\tcount1[c]++;\\n\\t\\t\\t\\tto1++;\\n\\t\\t\\t}\\n\\n\\t\\t\\tfor(int i =0;i<b.length();i++) {\\n\\t\\t\\t\\tint c = b.charAt(i) - \\'a\\'; \\n\\t\\t\\t\\tcount2[c]++;\\n\\t\\t\\t\\tto2++;\\n\\t\\t\\t}\\n\\n\\t\\t\\tfor(int i = 0;i<26;i++) \\n\\t\\t\\t\\t min = Math.min(min, to1 - count1[i] + to2 - count2[i]);\\n\\n\\t\\t\\tfor(int i = 1;i<26;i++) {\\n\\t\\t\\t\\tcount1[i] += count1[i-1];\\n\\t\\t\\t\\tcount2[i] += count2[i-1];\\n\\t\\t\\t}\\n\\n\\t\\t\\tfor(int i = 0;i<26;i++) {\\n\\t\\t\\t\\tint su1 = to1 - count1[i];\\n\\t\\t\\t\\tint su2 = to2 - count2[i];\\n\\t\\t\\t\\tfor(int j = i+1;j<26;j++){ \\n\\t\\t\\t\\t\\tmin = Math.min(min, su1 + count2[j-1]);\\n\\t\\t\\t\\t\\tmin = Math.min(min, su2 + count1[j-1]);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn min;\\n\\t\\t}\\n\\t}",
                "solutionTags": [],
                "code": "class Solution {\\n\\t\\tpublic int minCharacters(String a, String b) {\\n\\t\\t\\tint min = Integer.MAX_VALUE, to1 = 0 , to2 = 0;\\n\\t\\t\\tint[] count1 = new int[26];\\n\\t\\t\\tint[] count2 = new int[26];\\n\\n\\t\\t\\tfor(int i =0 ;i<a.length();i++) {\\n\\t\\t\\t\\tint c = a.charAt(i) - \\'a\\';\\n\\t\\t\\t\\tcount1[c]++;\\n\\t\\t\\t\\tto1++;\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1035847,
                "title": "golang",
                "content": "```\\nfunc minCharacters(a string, b string) int {\\n    var countA [26]int\\n    var countB[26]int\\n    for _,v:=range a{\\n        countA[v-\\'a\\']++\\n    }\\n    for _, v:=range b{\\n        countB[v-\\'a\\']++\\n    }\\n    ret:=math.MaxInt32\\n    for th:=0;th<26;th++{\\n        \\n        if th>0{\\n            change:=0\\n            for j:=th;j<26;j++{\\n                change+=countA[j]\\n            }\\n            for j:=0;j<th;j++{\\n                change+=countB[j]\\n            }\\n            ret = int(math.Min(float64(ret), float64(change)))\\n            change = 0\\n            for j:=th;j<26;j++{\\n                change+=countB[j]\\n            }\\n            for j:=0;j<th;j++{\\n                change+=countA[j]\\n            }\\n            ret = int(math.Min(float64(ret), float64(change)))\\n            \\n        }\\n        change:=0\\n        for j:=0;j<26;j++{\\n            if j!=th{\\n                change+=countA[j]\\n                change+=countB[j]\\n            }\\n        }\\n       ret = int(math.Min(float64(ret), float64(change)))\\n        \\n    }\\n    //var countB [26]int\\n \\n    return ret\\n    \\n}\\n```",
                "solutionTags": [],
                "code": "```\\nfunc minCharacters(a string, b string) int {\\n    var countA [26]int\\n    var countB[26]int\\n    for _,v:=range a{\\n        countA[v-\\'a\\']++\\n    }\\n    for _, v:=range b{\\n        countB[v-\\'a\\']++\\n    }\\n    ret:=math.MaxInt32\\n    for th:=0;th<26;th++{\\n        \\n        if th>0{\\n            change:=0\\n            for j:=th;j<26;j++{\\n                change+=countA[j]\\n            }\\n            for j:=0;j<th;j++{\\n                change+=countB[j]\\n            }\\n            ret = int(math.Min(float64(ret), float64(change)))\\n            change = 0\\n            for j:=th;j<26;j++{\\n                change+=countB[j]\\n            }\\n            for j:=0;j<th;j++{\\n                change+=countA[j]\\n            }\\n            ret = int(math.Min(float64(ret), float64(change)))\\n            \\n        }\\n        change:=0\\n        for j:=0;j<26;j++{\\n            if j!=th{\\n                change+=countA[j]\\n                change+=countB[j]\\n            }\\n        }\\n       ret = int(math.Min(float64(ret), float64(change)))\\n        \\n    }\\n    //var countB [26]int\\n \\n    return ret\\n    \\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1035794,
                "title": "why-is-2-expected-answer-for-aaac-and-cca",
                "content": "It looks like we should change three \"c\" letters to \"a\" thus we need 3 operations, but why is expected answer \"2\"?",
                "solutionTags": [],
                "code": "",
                "codeTag": "Unknown"
            },
            {
                "id": 1034298,
                "title": "simple-c-sol-with-comments-faster-than-100",
                "content": "```\\n// Runtime: 40 ms, faster than 100.00% of C++ online submissions for Change Minimum Characters to Satisfy One of Three Conditions.\\n// Memory Usage: 14.9 MB, less than 80.00% of C++ online submissions for Change Minimum Characters to Satisfy One of Three Conditions.\\nclass Solution {\\npublic:\\n    int minCharacters(string A, string B) {\\n        vector<int> s(26,0), t(26,0);\\n        for(int i=0;i<A.length();++i) s[A[i]-\\'a\\']++;  // character count for both strings \\n        for(int i=0;i<B.length();++i) t[B[i]-\\'a\\']++;\\n        \\n        vector<int> x(26,0),y(26,0);    // calculating prefix sum of characters\\n        x[0] = s[0]; y[0] = t[0];\\n        for(int i=1;i<26;++i)\\n        {\\n            x[i]=x[i-1]+s[i];\\n            y[i]=y[i-1]+t[i];\\n        }\\n\\n        int ans=INT_MAX;\\n        \\n        // first condition i.e every character in A is less than every character in B \\n        // we have to start with \\'b\\' as smallest character possible is \\'a\\' itself\\n        // i will vary from 1 to 25 implying characters \\'b\\' to \\'z\\' , with i being the smallest character in B\\n        // so we will have to change all chars greater than i in A and all chars smaller than i in B\\n        for(int i=1;i<26;++i)                  \\n        {                                      \\n                int k = A.length() - x[i-1];  // number of chars in A greater than current choice \\n                k+= y[i-1];                   // number of chars in B smaller than current choice\\n                ans=min(ans,k);\\n        }\\n\\n        // second condition , now A is replaced by B and vice versa\\n        for(int i=1;i<26;++i)   \\n        { \\n                int k = B.length() - y[i-1];\\n                k+= x[i-1];\\n                ans=min(ans,k);\\n        }\\n        \\n        // third condition : making all chars same in both A and B\\n        for(int i=0;i<26;++i)\\n        {\\n            ans= min(ans,(int)A.length()-s[i] + (int)B.length()-t[i]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n// Runtime: 40 ms, faster than 100.00% of C++ online submissions for Change Minimum Characters to Satisfy One of Three Conditions.\\n// Memory Usage: 14.9 MB, less than 80.00% of C++ online submissions for Change Minimum Characters to Satisfy One of Three Conditions.\\nclass Solution {\\npublic:\\n    int minCharacters(string A, string B) {\\n        vector<int> s(26,0), t(26,0);\\n        for(int i=0;i<A.length();++i) s[A[i]-\\'a\\']++;  // character count for both strings \\n        for(int i=0;i<B.length();++i) t[B[i]-\\'a\\']++;\\n        \\n        vector<int> x(26,0),y(26,0);    // calculating prefix sum of characters\\n        x[0] = s[0]; y[0] = t[0];\\n        for(int i=1;i<26;++i)\\n        {\\n            x[i]=x[i-1]+s[i];\\n            y[i]=y[i-1]+t[i];\\n        }\\n\\n        int ans=INT_MAX;\\n        \\n        // first condition i.e every character in A is less than every character in B \\n        // we have to start with \\'b\\' as smallest character possible is \\'a\\' itself\\n        // i will vary from 1 to 25 implying characters \\'b\\' to \\'z\\' , with i being the smallest character in B\\n        // so we will have to change all chars greater than i in A and all chars smaller than i in B\\n        for(int i=1;i<26;++i)                  \\n        {                                      \\n                int k = A.length() - x[i-1];  // number of chars in A greater than current choice \\n                k+= y[i-1];                   // number of chars in B smaller than current choice\\n                ans=min(ans,k);\\n        }\\n\\n        // second condition , now A is replaced by B and vice versa\\n        for(int i=1;i<26;++i)   \\n        { \\n                int k = B.length() - y[i-1];\\n                k+= x[i-1];\\n                ans=min(ans,k);\\n        }\\n        \\n        // third condition : making all chars same in both A and B\\n        for(int i=0;i<26;++i)\\n        {\\n            ans= min(ans,(int)A.length()-s[i] + (int)B.length()-t[i]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1033961,
                "title": "python-dynamic-programming-beats-100-in-time-and-space-complexity",
                "content": "\\n```\\nclass Solution(object):\\n    def minCharacters(self, a, b):\\n        \"\"\"\\n        :type a: str\\n        :type b: str\\n        :rtype: int\\n        \"\"\"\\n        \\n        #ord(\\'a\\') = 97, ord(\\'z\\') == 122\\n        \\n        ab = sorted(a+b)\\n        left, right = ord(ab[0]) - 97, ord(ab[-1]) - 97\\n        \\n        cntA, cntB = collections.Counter(a), collections.Counter(b)\\n        \\n        # sums = [ left_sum_a, left_sum_b, right_sum_a, right_sum_b ]\\n        sums = [ 0, 0, sum(cntA.values()), sum(cntB.values()) ]\\n        ret = sys.maxint\\n        \\n        # if the charset start from \\'b\\' or later, then it\\'s possible that we move all the chars in either a or b to \\'a\\'\\n        if left > 0:\\n\\t\\t    ret = min( ret, min(sums[2:]) )\\n        \\n        for ichar in xrange( left, right + 1 ):\\n                \\n            # update sums\\n            sums[0] += cntA[ chr(ichar+97) ]\\n            sums[1] += cntB[ chr(ichar+97) ]\\n            sums[2] -= cntA[ chr(ichar+97) ]\\n            sums[3] -= cntB[ chr(ichar+97) ]\\n            \\n            # if the charset ends at \\'z\\', then it\\'s not possible that we move all the chars in either a or b to \\'z\\', so we pass\\n            if ichar == 25:\\n                pass\\n            else:\\n            # 1 : all(b) > all(a):\\n            # chars need to move = left_sum_b + right_sum_a\\n                cond1 = sums[1] + sums[2]\\n            \\n            # 2 : all(a) > all(b):\\n            # chars need to move = left_sum_a + right_sum_b\\n                cond2 = sums[0] + sums[3]\\n            \\n            # 3 : all(b) == all(a):\\n            # chars need to move = number of chars other than current one\\n            #                    = sums - cntA[this_char] - cntB[this_char]\\n            cond3 = sum(sums) - cntA[ chr(ichar+97) ] - cntB[ chr(ichar+97) ]\\n            \\n            ret = min( ret, cond1, cond2, cond3 )\\n        \\n        return ret\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def minCharacters(self, a, b):\\n        \"\"\"\\n        :type a: str\\n        :type b: str\\n        :rtype: int\\n        \"\"\"\\n        \\n        #ord(\\'a\\') = 97, ord(\\'z\\') == 122\\n        \\n        ab = sorted(a+b)\\n        left, right = ord(ab[0]) - 97, ord(ab[-1]) - 97\\n        \\n        cntA, cntB = collections.Counter(a), collections.Counter(b)\\n        \\n        # sums = [ left_sum_a, left_sum_b, right_sum_a, right_sum_b ]\\n        sums = [ 0, 0, sum(cntA.values()), sum(cntB.values()) ]\\n        ret = sys.maxint\\n        \\n        # if the charset start from \\'b\\' or later, then it\\'s possible that we move all the chars in either a or b to \\'a\\'\\n        if left > 0:\\n\\t\\t    ret = min( ret, min(sums[2:]) )\\n        \\n        for ichar in xrange( left, right + 1 ):\\n                \\n            # update sums\\n            sums[0] += cntA[ chr(ichar+97) ]\\n            sums[1] += cntB[ chr(ichar+97) ]\\n            sums[2] -= cntA[ chr(ichar+97) ]\\n            sums[3] -= cntB[ chr(ichar+97) ]\\n            \\n            # if the charset ends at \\'z\\', then it\\'s not possible that we move all the chars in either a or b to \\'z\\', so we pass\\n            if ichar == 25:\\n                pass\\n            else:\\n            # 1 : all(b) > all(a):\\n            # chars need to move = left_sum_b + right_sum_a\\n                cond1 = sums[1] + sums[2]\\n            \\n            # 2 : all(a) > all(b):\\n            # chars need to move = left_sum_a + right_sum_b\\n                cond2 = sums[0] + sums[3]\\n            \\n            # 3 : all(b) == all(a):\\n            # chars need to move = number of chars other than current one\\n            #                    = sums - cntA[this_char] - cntB[this_char]\\n            cond3 = sum(sums) - cntA[ chr(ichar+97) ] - cntB[ chr(ichar+97) ]\\n            \\n            ret = min( ret, cond1, cond2, cond3 )\\n        \\n        return ret\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1033897,
                "title": "javascript-brute-force-solution",
                "content": "- JavaScript String cannot directly get the ascii code from `0 - 25`,  use the method to get number value: [charCodeAt()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/charCodeAt)\\nFor example:  \\n\\t```\\n\\t\\'a\\'-\\'b\\'\\n\\t// NaN\\n\\t```\\n- **Edge case:**  \\'a\\' or \\'z\\', because we cannot decrease \\'a\\' any more, or we cannot increase \\'z\\' anymore.\\n\\nJavaScript solution:\\n```\\nvar minCharacters = function(a, b) {\\n    var n1 = a.length;\\n    var n2 = b.length;\\n    var res = n1+n2;\\n    var cnt1 = [...Array(26)].fill(0);\\n    var cnt2 = [...Array(26)].fill(0);\\n    // pre-processing the counting in two strings\\n     for (var aa of [...a]) {\\n        cnt1[aa.charCodeAt(0) - \\'a\\'.charCodeAt(0)]++;\\n     }\\n     for (var bb of [...b]) {\\n        cnt2[bb.charCodeAt(0) - \\'a\\'.charCodeAt(0)]++;\\n         cnt2[bb-\\'a\\']++;\\n    }\\n          \\n    for (var i=0; i<26; i++) {\\n        if(i>0) // only starts from \\'b\\', because we cannot decrease \\'a\\'\\n        {\\n            // case1: a is strictly less than b\\n            // a: the letters < \"i\"\\n            // b: the letters >= \"i\"\\n            var r = 0;\\n            for(var j = 0; j<i; j++)\\n            {\\n                r += cnt1[j];\\n            }\\n            for(var j = i; j<26; j++)\\n            {\\n                r += cnt2[j];\\n            }\\n            res = Math.min(res, r);\\n            // case2: b is strictly less than a\\n            // a: the letters >= \"i\"\\n            // b: the letters < \"i\"\\n            r = 0;\\n            for(var j = i; j<26; j++)\\n            {\\n                r += cnt1[j];\\n            }\\n            for(var j = 0; j<i; j++)\\n            {\\n                r += cnt2[j];\\n            }\\n            res = Math.min(res, r);\\n        }\\n        // case 3: all unique letter equal to \"i\"\\n        r = 0;\\n        for(var j = 0; j<26; j++)\\n        {\\n           if(j !== i)\\n           {\\n               r += cnt1[j];\\n               r += cnt2[j];\\n           }\\n        }\\n         res = Math.min(res, r);\\n    }\\n    return res;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n\\t\\'a\\'-\\'b\\'\\n\\t// NaN\\n\\t```\n```\\nvar minCharacters = function(a, b) {\\n    var n1 = a.length;\\n    var n2 = b.length;\\n    var res = n1+n2;\\n    var cnt1 = [...Array(26)].fill(0);\\n    var cnt2 = [...Array(26)].fill(0);\\n    // pre-processing the counting in two strings\\n     for (var aa of [...a]) {\\n        cnt1[aa.charCodeAt(0) - \\'a\\'.charCodeAt(0)]++;\\n     }\\n     for (var bb of [...b]) {\\n        cnt2[bb.charCodeAt(0) - \\'a\\'.charCodeAt(0)]++;\\n         cnt2[bb-\\'a\\']++;\\n    }\\n          \\n    for (var i=0; i<26; i++) {\\n        if(i>0) // only starts from \\'b\\', because we cannot decrease \\'a\\'\\n        {\\n            // case1: a is strictly less than b\\n            // a: the letters < \"i\"\\n            // b: the letters >= \"i\"\\n            var r = 0;\\n            for(var j = 0; j<i; j++)\\n            {\\n                r += cnt1[j];\\n            }\\n            for(var j = i; j<26; j++)\\n            {\\n                r += cnt2[j];\\n            }\\n            res = Math.min(res, r);\\n            // case2: b is strictly less than a\\n            // a: the letters >= \"i\"\\n            // b: the letters < \"i\"\\n            r = 0;\\n            for(var j = i; j<26; j++)\\n            {\\n                r += cnt1[j];\\n            }\\n            for(var j = 0; j<i; j++)\\n            {\\n                r += cnt2[j];\\n            }\\n            res = Math.min(res, r);\\n        }\\n        // case 3: all unique letter equal to \"i\"\\n        r = 0;\\n        for(var j = 0; j<26; j++)\\n        {\\n           if(j !== i)\\n           {\\n               r += cnt1[j];\\n               r += cnt2[j];\\n           }\\n        }\\n         res = Math.min(res, r);\\n    }\\n    return res;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1033818,
                "title": "cut-from-b-to-z-o-n-26",
                "content": "cut at middle, count letters of a that bigger than cut, count b letter less than cut.\\nDo a global traversal.\\n\\nThen vice versa.\\n\\n```\\nclass Solution:\\n    def minCharacters(self, a: str, b: str) -> int:\\n        # iterate split line from left to right,\\n        # move a to left, move b to right; then vice versa.\\n        # a     |  uuu\\n        #   bbb |      z\\n        af, bf = Counter(a), Counter(b)\\n        ans = float(\"inf\")\\n        \\n        letters = [chr(ord(\"a\")+i) for i in range(26)]\\n        \\n        # a move to back\\n        for c in letters[1:]:\\n            ma = sum([af[k] for k in af if k < c])\\n            mb = sum([bf[k] for k in bf if k >= c])\\n            ans = min(ans, ma + mb)\\n            \\n        # a move to front\\n        for c in letters[:-1]:\\n            ma = sum([af[k] for k in af if k > c])\\n            mb = sum([bf[k] for k in bf if k <= c])\\n            ans = min(ans, ma + mb)\\n        \\n        c = a + b\\n        cf = Counter(c)\\n        dup = max(cf.values())\\n        ans = min(ans, len(c) - dup)\\n\\n        return ans\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minCharacters(self, a: str, b: str) -> int:\\n        # iterate split line from left to right,\\n        # move a to left, move b to right; then vice versa.\\n        # a     |  uuu\\n        #   bbb |      z\\n        af, bf = Counter(a), Counter(b)\\n        ans = float(\"inf\")\\n        \\n        letters = [chr(ord(\"a\")+i) for i in range(26)]\\n        \\n        # a move to back\\n        for c in letters[1:]:\\n            ma = sum([af[k] for k in af if k < c])\\n            mb = sum([bf[k] for k in bf if k >= c])\\n            ans = min(ans, ma + mb)\\n            \\n        # a move to front\\n        for c in letters[:-1]:\\n            ma = sum([af[k] for k in af if k > c])\\n            mb = sum([bf[k] for k in bf if k <= c])\\n            ans = min(ans, ma + mb)\\n        \\n        c = a + b\\n        cf = Counter(c)\\n        dup = max(cf.values())\\n        ans = min(ans, len(c) - dup)\\n\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1033773,
                "title": "python-with-full-explanation-and-example",
                "content": "for first condition we have to calculate:\\nC1. how many chacters in the first string should be change such away  that all character in that string be less than a special character = len(A) - acca\\nC2. how many chacters in the second string should be change such away  that all character in that string be more than a special character = accb\\nres = C1+C2\\nexample:\\n\\nA:\"aba\"   B:\"caa\"\\n-------\\nwe dont calculate for character a because there is no character less than char a\\n\\nfor character ---> b\\nC1: lenght(A) - sum of characters which are less than b (a is less than b) in string (it is not need to change characters less than b) A= 3-2\\nC2: sum of characters which are less than b (a is less than b) in string B= 2\\n\\nfor character ---> c\\nC1: lenght(A) - sum of characters which are less than c (a,b are less than c) in string  A= 3-3\\nC2: sum of characters which are less than b (a is less than c) in string B= 2\\n\\nfor character ---> d\\nC1: lenght(A)- sum of characters which are less than c (a,b are less than d) in string  A= 3-3\\nC2: sum of characters which are less than b (a,c is less than d) in string B= 3\\n\\nfor all other characters res doesnt change because we cover all the characters in both the strings\\n\\nsecond condition is the same except that you have to calculate\\nC1: how many character in B should be change such away  that all character in that string be less than a special character  = len(B) - accb\\nC2:  how many chacters in the A should be change such away  that all character in that string be more than a special character = acca\\n\\n***Let me know if my explanation is not clear***\\n```\\n    def minCharacters(self, a, b):\\n        cnta = collections.Counter()\\n        cntb = collections.Counter()\\n        m,n = len(a), len(b)\\n        res = 0\\n        for i in a:\\n            cnta[i]+=1\\n        for i in b:\\n            cntb[i]+=1\\n        res = m+n-max((cnta+cntb).values()) #Third condition\\n        acca=0\\n        accb=0\\n        for i in string.ascii_lowercase:\\n            if i != \\'a\\':\\n                res = min(res,m-acca+accb) #First condition\\n                res = min(res,n-accb+acca) #Second condition\\n            acca += cnta[i]\\n            accb += cntb[i]\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\n    def minCharacters(self, a, b):\\n        cnta = collections.Counter()\\n        cntb = collections.Counter()\\n        m,n = len(a), len(b)\\n        res = 0\\n        for i in a:\\n            cnta[i]+=1\\n        for i in b:\\n            cntb[i]+=1\\n        res = m+n-max((cnta+cntb).values()) #Third condition\\n        acca=0\\n        accb=0\\n        for i in string.ascii_lowercase:\\n            if i != \\'a\\':\\n                res = min(res,m-acca+accb) #First condition\\n                res = min(res,n-accb+acca) #Second condition\\n            acca += cnta[i]\\n            accb += cntb[i]\\n        return res\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1033720,
                "title": "python-counter-solution-350ms",
                "content": "```\\n    def minCharacters(self, a, b):\\n        \"\"\"\\n        :type a: str\\n        :type b: str\\n        :rtype: int\\n        \"\"\"\\n        l1, l2 = len(a), len(b)\\n        ans = l1 + l2\\n        adict = Counter()\\n        bdict = Counter()\\n        for c in a:\\n            adict[c] += 1\\n        for c in b:\\n            bdict[c] += 1\\n        \\n        # condition 3\\n        for k in adict:\\n            ans = min(ans, l1 + l2 - adict[k] - bdict[k])\\n        \\n        for le in list(string.ascii_lowercase):\\n            if le == \\'a\\':\\n                continue \\n            \\n            # condition 1\\n            opa = 0\\n            for k in adict:\\n                if k >= le:\\n                    opa += adict[k]\\n            for k in bdict:\\n                if k < le:\\n                    opa += bdict[k]\\n            # condition2: l1 + l2 - opa \\n            ans = min(opa,l1+l2-opa,ans)\\n\\n        return ans\\n\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\n    def minCharacters(self, a, b):\\n        \"\"\"\\n        :type a: str\\n        :type b: str\\n        :rtype: int\\n        \"\"\"\\n        l1, l2 = len(a), len(b)\\n        ans = l1 + l2\\n        adict = Counter()\\n        bdict = Counter()\\n        for c in a:\\n            adict[c] += 1\\n        for c in b:\\n            bdict[c] += 1\\n        \\n        # condition 3\\n        for k in adict:\\n            ans = min(ans, l1 + l2 - adict[k] - bdict[k])\\n        \\n        for le in list(string.ascii_lowercase):\\n            if le == \\'a\\':\\n                continue \\n            \\n            # condition 1\\n            opa = 0\\n            for k in adict:\\n                if k >= le:\\n                    opa += adict[k]\\n            for k in bdict:\\n                if k < le:\\n                    opa += bdict[k]\\n            # condition2: l1 + l2 - opa \\n            ans = min(opa,l1+l2-opa,ans)\\n\\n        return ans\\n\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1033582,
                "title": "c-44ms",
                "content": "\\n\\n    int minCharacters(string a, string b) {\\n                vector<int> aa(26, 0);\\n        vector<int> bb(26, 0);\\n        \\n        // aa and bb are alphabate statistic vector for a and b\\n        for(auto& c : a) {\\n            ++aa[(int)(c - \\'a\\')];\\n        }        \\n        for(auto& d : b) {\\n            ++bb[(int)(d - \\'a\\')];\\n        }\\n        \\n        // first, result should be as small as total length - most frequent letter\\n        // a.size + b.size - (times of k)\\n        int res = a.size() + b.size();        \\n        int mx = 0;\\n        for(int i = 0; i < 26; ++i) {\\n            mx = std::max(mx, aa[i] + bb[i]);\\n        }        \\n        res = std::min(res, (int)a.size() + (int)b.size() - mx);\\n        \\n        // then we enumrate from a to y as k\\n        // how many char need change if put all a under k (inclusive), all b after k(exclusive)\\n        // how many char need change if put all b under k (inclusive), all a after k(exclusive)\\n        // due to exclusive after k, we don\\'t need do it for k as z\\n        int a3 = 0;        \\n        int b3 = 0;\\n        int a4 = std::accumulate(aa.begin(), aa.end(), 0); // a4 is all letter count in a\\n        int b4 = std::accumulate(bb.begin(), bb.end(), 0); // b4 is all letter count in b\\n        for(int i = 0; i < 25; ++i) {\\n            \\n            a3 += aa[i];\\n            b3 += bb[i];\\n            \\n            // how many char need change if put all a under k (inclusive), all b after k(exclusive)\\n            int a5 = a4 - a3;\\n            int b5 = b3;            \\n            res = std::min(res, a5 + b5);\\n            \\n            // how many char need change if put all b under k (inclusive), all a after k(exclusive)\\n            a5 = a3;\\n            b5 = b4 - b3;            \\n            res = std::min(res, a5 + b5);            \\n        }\\n        \\n        \\n        return res;\\n    }",
                "solutionTags": [],
                "code": "\\n\\n    int minCharacters(string a, string b) {\\n                vector<int> aa(26, 0);\\n        vector<int> bb(26, 0);\\n        \\n        // aa and bb are alphabate statistic vector for a and b\\n        for(auto& c : a) {\\n            ++aa[(int)(c - \\'a\\')];\\n        }        \\n        for(auto& d : b) {\\n            ++bb[(int)(d - \\'a\\')];\\n        }\\n        \\n        // first, result should be as small as total length - most frequent letter\\n        // a.size + b.size - (times of k)\\n        int res = a.size() + b.size();        \\n        int mx = 0;\\n        for(int i = 0; i < 26; ++i) {\\n            mx = std::max(mx, aa[i] + bb[i]);\\n        }        \\n        res = std::min(res, (int)a.size() + (int)b.size() - mx);\\n        \\n        // then we enumrate from a to y as k\\n        // how many char need change if put all a under k (inclusive), all b after k(exclusive)\\n        // how many char need change if put all b under k (inclusive), all a after k(exclusive)\\n        // due to exclusive after k, we don\\'t need do it for k as z\\n        int a3 = 0;        \\n        int b3 = 0;\\n        int a4 = std::accumulate(aa.begin(), aa.end(), 0); // a4 is all letter count in a\\n        int b4 = std::accumulate(bb.begin(), bb.end(), 0); // b4 is all letter count in b\\n        for(int i = 0; i < 25; ++i) {\\n            \\n            a3 += aa[i];\\n            b3 += bb[i];\\n            \\n            // how many char need change if put all a under k (inclusive), all b after k(exclusive)\\n            int a5 = a4 - a3;\\n            int b5 = b3;            \\n            res = std::min(res, a5 + b5);\\n            \\n            // how many char need change if put all b under k (inclusive), all a after k(exclusive)\\n            a5 = a3;\\n            b5 = b4 - b3;            \\n            res = std::min(res, a5 + b5);            \\n        }\\n        \\n        \\n        return res;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1033495,
                "title": "c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    int count(string a, string b){ // making string a greater than string b\\n        int ans=INT_MAX, c;\\n        for(char x=\\'b\\';x<=\\'z\\';x++){\\n            c=0;\\n            for(int i=0;i<a.size();i++){\\n                if(a[i]<x) c++;\\n            }\\n            for(int i=0;i<b.size();i++){\\n                if(b[i]>=x) c++;\\n            }\\n            ans=min(ans,c);\\n        }\\n        return ans;\\n    }\\n    \\n    \\n    int minCharacters(string a, string b) {\\n        // Ist and 2nd operation\\n        int x=count(a,b); \\n        int y=count(b,a);\\n       \\n        // 3rd operation\\n        int freq[26]={0};\\n        int fa=0, fb=0;\\n        for(int i=0;i<a.size();i++){\\n            freq[a[i]-\\'a\\']++;\\n            fa=max(fa, freq[a[i]-\\'a\\']);\\n        }\\n        fa=a.size()-fa;\\n        int freq2[26]={0};\\n         for(int i=0;i<b.size();i++){\\n            freq2[b[i]-\\'a\\']++;\\n            fb=max(fb, freq2[b[i]-\\'a\\']);\\n        }\\n        fb=b.size()-fb;\\n        int z=fa+fb;\\n       \\n        return min({x,y,z});\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int count(string a, string b){ // making string a greater than string b\\n        int ans=INT_MAX, c;\\n        for(char x=\\'b\\';x<=\\'z\\';x++){\\n            c=0;\\n            for(int i=0;i<a.size();i++){\\n                if(a[i]<x) c++;\\n            }\\n            for(int i=0;i<b.size();i++){\\n                if(b[i]>=x) c++;\\n            }\\n            ans=min(ans,c);\\n        }\\n        return ans;\\n    }\\n    \\n    \\n    int minCharacters(string a, string b) {\\n        // Ist and 2nd operation\\n        int x=count(a,b); \\n        int y=count(b,a);\\n       \\n        // 3rd operation\\n        int freq[26]={0};\\n        int fa=0, fb=0;\\n        for(int i=0;i<a.size();i++){\\n            freq[a[i]-\\'a\\']++;\\n            fa=max(fa, freq[a[i]-\\'a\\']);\\n        }\\n        fa=a.size()-fa;\\n        int freq2[26]={0};\\n         for(int i=0;i<b.size();i++){\\n            freq2[b[i]-\\'a\\']++;\\n            fb=max(fb, freq2[b[i]-\\'a\\']);\\n        }\\n        fb=b.size()-fb;\\n        int z=fa+fb;\\n       \\n        return min({x,y,z});\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1033474,
                "title": "python3-o-a-b-prefix-sum-solution-with-explanation-in-comments",
                "content": "```\\nclass Solution:\\n    def minCharacters(self, a: str, b: str) -> int:\\n        c1 = collections.Counter(a)\\n        c2 = collections.Counter(b)\\n        N1, N2 = len(a), len(b)\\n\\t\\t# check if a and b already fit criteria 1 or 2 without any modifications\\n        if min(c1.keys()) > max(c2.keys()) or min(c2.keys()) > max(c1.keys()):\\n            return 0\\n\\t\\t# set minimum amount to criteria 3\\n\\t\\tc3 = c1 + c2\\n        res = N1 + N2 - max(c3.values())\\n        n, m = 0, 0\\n\\t\\t# iterate over the alphabet using n and m to keep track of prefix sum of a and b respectively\\n\\t\\t# recalculate amount of changes it would take for criteria 1 and 2\\n        for ch in \\'abcdefghijklmnopqrstuvwxy\\':\\n                n += c1[ch]\\n                m += c2[ch] \\n\\t\\t\\t\\t# n is the amount of letters in word a that come before or include ch\\n\\t\\t\\t\\t# this is the amount we want to change to \\'z\\' or any letter after ch\\n\\t\\t\\t\\t# N2 - m is the amount of letters in word b that come after ch\\n\\t\\t\\t\\t# we need to modify all of these to \\'a\\' or any letter before ch\\n                res = min(res, n + (N2 - m), m + (N1 - n))\\n        return res\\n```\\n\\nNote to self: I\\'m only checking ```\\'abcdefghijklmnopqrstuvwxy\\'``` letters up to ```\\'y\\'``` because only can we change those to ```\\'z\\'```, we can\\'t change ```\\'z\\'``` to anything else after it.",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minCharacters(self, a: str, b: str) -> int:\\n        c1 = collections.Counter(a)\\n        c2 = collections.Counter(b)\\n        N1, N2 = len(a), len(b)\\n\\t\\t# check if a and b already fit criteria 1 or 2 without any modifications\\n        if min(c1.keys()) > max(c2.keys()) or min(c2.keys()) > max(c1.keys()):\\n            return 0\\n\\t\\t# set minimum amount to criteria 3\\n\\t\\tc3 = c1 + c2\\n        res = N1 + N2 - max(c3.values())\\n        n, m = 0, 0\\n\\t\\t# iterate over the alphabet using n and m to keep track of prefix sum of a and b respectively\\n\\t\\t# recalculate amount of changes it would take for criteria 1 and 2\\n        for ch in \\'abcdefghijklmnopqrstuvwxy\\':\\n                n += c1[ch]\\n                m += c2[ch] \\n\\t\\t\\t\\t# n is the amount of letters in word a that come before or include ch\\n\\t\\t\\t\\t# this is the amount we want to change to \\'z\\' or any letter after ch\\n\\t\\t\\t\\t# N2 - m is the amount of letters in word b that come after ch\\n\\t\\t\\t\\t# we need to modify all of these to \\'a\\' or any letter before ch\\n                res = min(res, n + (N2 - m), m + (N1 - n))\\n        return res\\n```\n```\\'abcdefghijklmnopqrstuvwxy\\'```\n```\\'y\\'```\n```\\'z\\'```\n```\\'z\\'```",
                "codeTag": "Java"
            },
            {
                "id": 1032781,
                "title": "swift-solution-simple-fast",
                "content": "```\\n\\t func minCharacters(_ a: String, _ b: String) -> Int {\\n        let m = a.count, n = b.count\\n        var res = m + n\\n        var c1 = [Int](repeating: 0, count: 26), c2 = [Int](repeating: 0, count: 26)\\n        for c in a {\\n            c1[Int(c.asciiValue!) - 97] += 1\\n        }\\n        for c in b {\\n            c2[Int(c.asciiValue!) - 97] += 1\\n        }\\n        for i in 0...25 {\\n            res = min(res, m + n - c1[i] - c2[i])\\n            if i > 0 {\\n                c1[i] += c1[i - 1]\\n                c2[i] += c2[i - 1]\\n            }\\n            if i < 25 {\\n                res = min(res, m - c1[i] + c2[i])\\n                res = min(res, n - c2[i] + c1[i])\\n            }\\n        }\\n        return res\\n    }\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\n\\t func minCharacters(_ a: String, _ b: String) -> Int {\\n        let m = a.count, n = b.count\\n        var res = m + n\\n        var c1 = [Int](repeating: 0, count: 26), c2 = [Int](repeating: 0, count: 26)\\n        for c in a {\\n            c1[Int(c.asciiValue!) - 97] += 1\\n        }\\n        for c in b {\\n            c2[Int(c.asciiValue!) - 97] += 1\\n        }\\n        for i in 0...25 {\\n            res = min(res, m + n - c1[i] - c2[i])\\n            if i > 0 {\\n                c1[i] += c1[i - 1]\\n                c2[i] += c2[i - 1]\\n            }\\n            if i < 25 {\\n                res = min(res, m - c1[i] + c2[i])\\n                res = min(res, n - c2[i] + c1[i])\\n            }\\n        }\\n        return res\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1032473,
                "title": "java-clean-code-with-detailed-explanation",
                "content": "We just have to check for three conditions for every character(a..z)\\nfor every Character ->\\nCondition 3 -> totalOperations is = TotalCharacter in  a& b - count of this Character in a& b\\nCondition 1 -> totalOperations is = (TotalCharacter in  a - pefixSum of this Charactercount in a) + pefixSum of this Charactercount in b\\nCondition 2 -> totalOperations is = (TotalCharacter in  b - pefixSum of this Charactercount in b) + pefixSum of this Charactercount in a\\n\\n```\\nclass Solution {\\n    public int minCharacters(String a, String b) {\\n        int[] count_a = new int[27];\\n        int[] count_b = new int[27];\\n        int total_a = a.length();\\n        int total_b = b.length();\\n        int total = total_a+total_b;\\n        int ans = Integer.MAX_VALUE;\\n         for(char c:a.toCharArray()){\\n            count_a[c-\\'a\\'+1]++;\\n        }\\n        for(char c:b.toCharArray()){\\n            count_b[c-\\'a\\'+1]++;\\n        }\\n        for(int i=1;i<=26;i++){\\n            /*\\n            condition 3 -> for making a & b consiting of 1 letter\\n            totalOperation = totalcharacterCount - thisCharacterCount in(a&b)\\n            */\\n            int x = total-(count_a[i]+count_b[i]);\\n            int total_min = Integer.MAX_VALUE;\\n            // For z we can\\'t satisfy condition 1 & 2;\\n            if(i< 26){\\n                //prefixSum of count of character in a\\n                count_a[i]+=count_a[i-1];\\n                //prefixSum of count of character in b\\n                count_b[i]+=count_b[i-1];\\n                /*\\n                condition 1\\n                for everyCharacter in a > thisCharacter we need to change it to lowervalue\\n                for everyCharacter in b <= thisCharacter we need to change it to higherValue\\n                */\\n                int y = (total_a - count_a[i]) + count_b[i];\\n                \\n                /*\\n                condition 2\\n                for everyCharacter in b > thisCharacter we need to change it to lowervalue\\n                for everyCharacter in a <= thisCharacter we need to change it to higherValue\\n                */\\n                int z = (total_b - count_b[i]) + count_a[i];\\n                // minimum operation to satisfy condition 1 & 2\\n                total_min = Math.min(y,z);\\n            }\\n            // absolute minimum to satisfy condition 1 &2 &3\\n            ans = Math.min(ans,Math.min(x,total_min));\\n        }\\n        return ans;\\n    }\\n}\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minCharacters(String a, String b) {\\n        int[] count_a = new int[27];\\n        int[] count_b = new int[27];\\n        int total_a = a.length();\\n        int total_b = b.length();\\n        int total = total_a+total_b;\\n        int ans = Integer.MAX_VALUE;\\n         for(char c:a.toCharArray()){\\n            count_a[c-\\'a\\'+1]++;\\n        }\\n        for(char c:b.toCharArray()){\\n            count_b[c-\\'a\\'+1]++;\\n        }\\n        for(int i=1;i<=26;i++){\\n            /*\\n            condition 3 -> for making a & b consiting of 1 letter\\n            totalOperation = totalcharacterCount - thisCharacterCount in(a&b)\\n            */\\n            int x = total-(count_a[i]+count_b[i]);\\n            int total_min = Integer.MAX_VALUE;\\n            // For z we can\\'t satisfy condition 1 & 2;\\n            if(i< 26){\\n                //prefixSum of count of character in a\\n                count_a[i]+=count_a[i-1];\\n                //prefixSum of count of character in b\\n                count_b[i]+=count_b[i-1];\\n                /*\\n                condition 1\\n                for everyCharacter in a > thisCharacter we need to change it to lowervalue\\n                for everyCharacter in b <= thisCharacter we need to change it to higherValue\\n                */\\n                int y = (total_a - count_a[i]) + count_b[i];\\n                \\n                /*\\n                condition 2\\n                for everyCharacter in b > thisCharacter we need to change it to lowervalue\\n                for everyCharacter in a <= thisCharacter we need to change it to higherValue\\n                */\\n                int z = (total_b - count_b[i]) + count_a[i];\\n                // minimum operation to satisfy condition 1 & 2\\n                total_min = Math.min(y,z);\\n            }\\n            // absolute minimum to satisfy condition 1 &2 &3\\n            ans = Math.min(ans,Math.min(x,total_min));\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1032463,
                "title": "solution-with-explanation-and-easy-to-understand",
                "content": "\\n```\\nint minCharacters(string a, string b) {\\n        int m = a.size(), n = b.size(), res = m + n;\\n        int c1[26];\\n        int c2[26];\\n        memset(c1,0,sizeof c1);\\n        memset(c2,0,sizeof c2);\\n        \\n        for (char c: a) c1[c - \\'a\\']++;\\n        for (char c: b) c2[c - \\'a\\']++;\\n        for (int i = 0; i < 26; ++i) {\\n            res = min(res, m + n - c1[i] - c2[i] ); //condition3\\n        }\\n\\n        /*\\n            since there could not be any alphabet smaller than \\'a\\' that\\'s why i am starting with i = 1 which is \\'b\\'.\\n            consider c1[1] which is \\'b\\', as target character for which all characters  in string b should be smaller hence you have to take sum of two thing :\\n            1. prefix sum of c1 array for all count before current i = 0(current i = 1 so till i-1 = 0).\\n            2. take the remaininng count of characters in b which we want to be smaller that count comes to size of c2 - ps2(n - ps2). Because ps2 we know they are smaller so we ignore and make rest as small.\\n            \\n            \\n            keep repeating this process by trying all alphabets from b to z.\\n        */\\n        \\n        \\n        //condition 1 all lettters in a > b\\n        int ps1 = c1[0];\\n        int ps2 = c2[0];\\n        for (int i = 1; i < 26; ++i) {\\n            res = min(res, ps1 + n - ps2 );\\n            ps1 += c1[i];\\n            ps2 += c2[i];\\n        }\\n\\n        //condition 2 all letters in b < a\\n        ps1 = c1[0];\\n        ps2 = c2[0];\\n        for (int i = 1; i < 26; ++i) {\\n            res = min(res, ps2 + m - ps1 );\\n            ps1 += c1[i];\\n            ps2 += c2[i];\\n        }\\n\\n        return res;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nint minCharacters(string a, string b) {\\n        int m = a.size(), n = b.size(), res = m + n;\\n        int c1[26];\\n        int c2[26];\\n        memset(c1,0,sizeof c1);\\n        memset(c2,0,sizeof c2);\\n        \\n        for (char c: a) c1[c - \\'a\\']++;\\n        for (char c: b) c2[c - \\'a\\']++;\\n        for (int i = 0; i < 26; ++i) {\\n            res = min(res, m + n - c1[i] - c2[i] ); //condition3\\n        }\\n\\n        /*\\n            since there could not be any alphabet smaller than \\'a\\' that\\'s why i am starting with i = 1 which is \\'b\\'.\\n            consider c1[1] which is \\'b\\', as target character for which all characters  in string b should be smaller hence you have to take sum of two thing :\\n            1. prefix sum of c1 array for all count before current i = 0(current i = 1 so till i-1 = 0).\\n            2. take the remaininng count of characters in b which we want to be smaller that count comes to size of c2 - ps2(n - ps2). Because ps2 we know they are smaller so we ignore and make rest as small.\\n            \\n            \\n            keep repeating this process by trying all alphabets from b to z.\\n        */\\n        \\n        \\n        //condition 1 all lettters in a > b\\n        int ps1 = c1[0];\\n        int ps2 = c2[0];\\n        for (int i = 1; i < 26; ++i) {\\n            res = min(res, ps1 + n - ps2 );\\n            ps1 += c1[i];\\n            ps2 += c2[i];\\n        }\\n\\n        //condition 2 all letters in b < a\\n        ps1 = c1[0];\\n        ps2 = c2[0];\\n        for (int i = 1; i < 26; ++i) {\\n            res = min(res, ps2 + m - ps1 );\\n            ps1 += c1[i];\\n            ps2 += c2[i];\\n        }\\n\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1032387,
                "title": "simple-solution",
                "content": "\\n\\nA -- abe\\nB -- ace\\nSteps:\\n1) count the characters in the strings.\\n2) Sweep the count from left to right.\\n3) Iterate over all index, and validate the following condition.\\n![image](https://assets.leetcode.com/users/images/dc69c2a7-8de5-4e5e-9e1f-5c9872cbbbb1_1611470631.7998164.png)\\n\\n```\\nclass Solution {\\n    public int minCharacters(String a, String b) {\\n        \\n        int[] A = new int[26];\\n        int[] B = new int[26];\\n        \\n        int max =0;\\n        int min= Integer.MAX_VALUE;\\n        char[] aChar =a.toCharArray();\\n        char[] bChar =b.toCharArray();\\n        \\n        for(int i=0;i<aChar.length;i++){\\n            ++A[aChar[i]-\\'a\\'];\\n            max=Math.max(max,A[aChar[i]-\\'a\\']);\\n        }\\n        \\n        for(int i=0;i<bChar.length;i++){\\n            ++B[bChar[i]-\\'a\\'];\\n            max=Math.max(max,B[bChar[i]-\\'a\\']+A[bChar[i]-\\'a\\']);\\n        }\\n        \\n        min = Math.min(min,aChar.length+bChar.length-max);\\n        \\n        for(int i=1;i<26;i++){\\n            A[i]+=A[i-1];\\n            B[i]+=B[i-1];\\n        }\\n        \\n         for(int i=1;i<26;i++){\\n            min = Math.min(min, A[i-1]+B[25]-B[i-1]);\\n            min = Math.min(min, B[i-1]+A[25]-A[i-1]);\\n        }\\n        return min;\\n    }\\n}```\\n\\nps: I know it\\'s a simple solution now, but I struggled to solve this under constraint.",
                "solutionTags": [
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\n    public int minCharacters(String a, String b) {\\n        \\n        int[] A = new int[26];\\n        int[] B = new int[26];\\n        \\n        int max =0;\\n        int min= Integer.MAX_VALUE;\\n        char[] aChar =a.toCharArray();\\n        char[] bChar =b.toCharArray();\\n        \\n        for(int i=0;i<aChar.length;i++){\\n            ++A[aChar[i]-\\'a\\'];\\n            max=Math.max(max,A[aChar[i]-\\'a\\']);\\n        }\\n        \\n        for(int i=0;i<bChar.length;i++){\\n            ++B[bChar[i]-\\'a\\'];\\n            max=Math.max(max,B[bChar[i]-\\'a\\']+A[bChar[i]-\\'a\\']);\\n        }\\n        \\n        min = Math.min(min,aChar.length+bChar.length-max);\\n        \\n        for(int i=1;i<26;i++){\\n            A[i]+=A[i-1];\\n            B[i]+=B[i-1];\\n        }\\n        \\n         for(int i=1;i<26;i++){\\n            min = Math.min(min, A[i-1]+B[25]-B[i-1]);\\n            min = Math.min(min, B[i-1]+A[25]-A[i-1]);\\n        }\\n        return min;\\n    }\\n}```",
                "codeTag": "Java"
            },
            {
                "id": 1032313,
                "title": "java-9ms-prefixsum-suffixsum",
                "content": "```\\n    public int minCharacters(String a, String b) {\\n        int[] cnt1 = new int[26];\\n        int[] cnt2 = new int[26];\\n        \\n        int minChar1 = 26;\\n        int minChar2 = 26;\\n        int maxChar1 = -1;\\n        int maxChar2 = -1;\\n\\n        for (char c : a.toCharArray()) {\\n            cnt1[c - \\'a\\']++;\\n            minChar1 = Math.min(minChar1, c - \\'a\\');\\n            maxChar1 = Math.max(maxChar1, c - \\'a\\');\\n            \\n        }\\n        \\n        for (char c : b.toCharArray()) {\\n            cnt2[c - \\'a\\']++;\\n            minChar2 = Math.min(minChar2, c - \\'a\\');\\n            maxChar2 = Math.max(maxChar2, c - \\'a\\');\\n        }\\n        \\n        if (minChar1 > maxChar2 || minChar2 > maxChar1) return 0;\\n        \\n        int min = Integer.MAX_VALUE;\\n        \\n        int[] left1 = new int[26];\\n        int[] left2 = new int[26];\\n        \\n        left1[0] = cnt1[0];\\n        left2[0] = cnt2[0];\\n        \\n        for (int i = 1; i < 26; i++) {\\n            left1[i] += left1[i - 1] + cnt1[i];\\n            left2[i] += left2[i - 1] + cnt2[i];\\n        }\\n        \\n\\n        int[] right1 = new int[26];\\n        int[] right2 = new int[26];\\n        right1[25] = cnt1[25];\\n        right2[25] = cnt2[25];\\n        \\n        for (int i = 24; i >= 0; i--) {\\n            right1[i] += right1[i + 1] + cnt1[i];\\n            right2[i] += right2[i + 1] + cnt2[i];\\n        }\\n        \\n        \\n        for (int i = 0; i < 26; i++) {\\n            min = Math.min(min, a.length() - cnt1[i] + b.length() - cnt2[i]); \\n            \\n            if (i != 0) min = Math.min(min, Math.min(right1[i] + left2[i - 1], right2[i] + left1[i - 1]));\\n            \\n        \\n        }\\n        return min;\\n        \\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public int minCharacters(String a, String b) {\\n        int[] cnt1 = new int[26];\\n        int[] cnt2 = new int[26];\\n        \\n        int minChar1 = 26;\\n        int minChar2 = 26;\\n        int maxChar1 = -1;\\n        int maxChar2 = -1;\\n\\n        for (char c : a.toCharArray()) {\\n            cnt1[c - \\'a\\']++;\\n            minChar1 = Math.min(minChar1, c - \\'a\\');\\n            maxChar1 = Math.max(maxChar1, c - \\'a\\');\\n            \\n        }\\n        \\n        for (char c : b.toCharArray()) {\\n            cnt2[c - \\'a\\']++;\\n            minChar2 = Math.min(minChar2, c - \\'a\\');\\n            maxChar2 = Math.max(maxChar2, c - \\'a\\');\\n        }\\n        \\n        if (minChar1 > maxChar2 || minChar2 > maxChar1) return 0;\\n        \\n        int min = Integer.MAX_VALUE;\\n        \\n        int[] left1 = new int[26];\\n        int[] left2 = new int[26];\\n        \\n        left1[0] = cnt1[0];\\n        left2[0] = cnt2[0];\\n        \\n        for (int i = 1; i < 26; i++) {\\n            left1[i] += left1[i - 1] + cnt1[i];\\n            left2[i] += left2[i - 1] + cnt2[i];\\n        }\\n        \\n\\n        int[] right1 = new int[26];\\n        int[] right2 = new int[26];\\n        right1[25] = cnt1[25];\\n        right2[25] = cnt2[25];\\n        \\n        for (int i = 24; i >= 0; i--) {\\n            right1[i] += right1[i + 1] + cnt1[i];\\n            right2[i] += right2[i + 1] + cnt2[i];\\n        }\\n        \\n        \\n        for (int i = 0; i < 26; i++) {\\n            min = Math.min(min, a.length() - cnt1[i] + b.length() - cnt2[i]); \\n            \\n            if (i != 0) min = Math.min(min, Math.min(right1[i] + left2[i - 1], right2[i] + left1[i - 1]));\\n            \\n        \\n        }\\n        return min;\\n        \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1032311,
                "title": "c-easy-solution-with-comments-time-o-m-n-space-o-1",
                "content": "\\n\\n\\tint minCharacters(string a, string b) {\\n        vector<int> amp(26, 0), bmp(26, 0);\\n        for (auto c : a) \\n            amp[c-\\'a\\']++;\\n        for (auto c : b) \\n            bmp[c-\\'a\\']++;\\n        \\n        int ans = INT_MAX;\\n\\t\\t// condition 1:\\n        // find min cost by making all chars of a less than b\\n        // since we need to make all chars of a less than b, start from idx 1\\n        // so that a can atleast be changed to first char\\n        for (int i = 1; i<26; i++) {\\n            int cost = 0;\\n            // all chars from i to end of a need to be changed\\n            for (int j = i; j<26; j++)\\n                cost += amp[j];\\n            // all chars less than i of b need to be changed\\n            for (int j = 0; j<i; j++)\\n                cost += bmp[j];\\n            ans = min(ans, cost);\\n        }\\n        // condition 2:\\n        // find min cost by making all chars of b less than a\\n        // since we need to make all chars of b less than a, start from idx 1\\n        // so that b can atleast be changed to first char\\n        for (int i = 1; i<26; i++) {\\n            int cost = 0;\\n            // all chars of b from i to end need to be changed\\n            for (int j = i; j<26; j++)\\n                cost += bmp[j];\\n            // all chars of a from 0 to i need to be changed\\n            for (int j = 0; j<i; j++)\\n                cost += amp[j];\\n            ans = min(ans, cost);\\n        }\\n        // condition 3:\\n        // find min cost by making all chars unique\\n        int n = a.size()+b.size();\\n        for (int i = 0; i<26; i++)\\n            ans = min(ans, n-(amp[i] + bmp[i]));\\n        \\n        return ans;\\n    }",
                "solutionTags": [],
                "code": "\\n\\n\\tint minCharacters(string a, string b) {\\n        vector<int> amp(26, 0), bmp(26, 0);\\n        for (auto c : a) \\n            amp[c-\\'a\\']++;\\n        for (auto c : b) \\n            bmp[c-\\'a\\']++;\\n        \\n        int ans = INT_MAX;\\n\\t\\t// condition 1:\\n        // find min cost by making all chars of a less than b\\n        // since we need to make all chars of a less than b, start from idx 1\\n        // so that a can atleast be changed to first char\\n        for (int i = 1; i<26; i++) {\\n            int cost = 0;\\n            // all chars from i to end of a need to be changed\\n            for (int j = i; j<26; j++)\\n                cost += amp[j];\\n            // all chars less than i of b need to be changed\\n            for (int j = 0; j<i; j++)\\n                cost += bmp[j];\\n            ans = min(ans, cost);\\n        }\\n        // condition 2:\\n        // find min cost by making all chars of b less than a\\n        // since we need to make all chars of b less than a, start from idx 1\\n        // so that b can atleast be changed to first char\\n        for (int i = 1; i<26; i++) {\\n            int cost = 0;\\n            // all chars of b from i to end need to be changed\\n            for (int j = i; j<26; j++)\\n                cost += bmp[j];\\n            // all chars of a from 0 to i need to be changed\\n            for (int j = 0; j<i; j++)\\n                cost += amp[j];\\n            ans = min(ans, cost);\\n        }\\n        // condition 3:\\n        // find min cost by making all chars unique\\n        int n = a.size()+b.size();\\n        for (int i = 0; i<26; i++)\\n            ans = min(ans, n-(amp[i] + bmp[i]));\\n        \\n        return ans;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1032298,
                "title": "loop-check-the-char-which-separate-the-two-string-with-min-cost-c-solution",
                "content": "My idea: choose a char to be the max char in string a if a<b or in string b if b<a\\n```\\n    int minCharacters(string a, string b) {\\n        //every letter in a < every letter in b, or vice versa\\n        vector<int> cnta(26),cntb(26);\\n        int mxa=0,mxb=0,nca=0,ncb=0;\\n        for(char c: a) cnta[c-\\'a\\']++,mxa=max(mxa,cnta[c-\\'a\\']);\\n        for(char c: b) cntb[c-\\'a\\']++,mxb=max(mxb,cntb[c-\\'a\\']);\\n\\n        //let a<b: we need change less char in b and greater char in a\\n        //how? only need to worry about the overlap\\n        //assume the separate char\\n        int nmove=INT_MAX;\\n        for(int i=1;i<26;i++){ //assume the separate char\\n            int aa=0;\\n            for(int j=0;j<26;j++){\\n                if(cnta[j] && j>=i) aa+=cnta[j];\\n                if(cntb[j] && j<i) aa+=cntb[j];\\n            }\\n            nmove=min(aa,nmove);\\n        }\\n        \\n        for(int i=1;i<26;i++){ //assume the separate char\\n            int aa=0;\\n            for(int j=0;j<26;j++){\\n                if(cntb[j] && j>=i) aa+=cntb[j];\\n                if(cnta[j] && j<i) aa+=cnta[j];\\n            }\\n            nmove=min(aa,nmove);\\n        }\\n        //cout<<mxa<<\" \"<<mxb<<endl;\\n        return min({nmove,(int)a.size()-mxa+(int)b.size()-mxb});\\n    }\\n\\t```",
                "solutionTags": [],
                "code": "```\\n    int minCharacters(string a, string b) {\\n        //every letter in a < every letter in b, or vice versa\\n        vector<int> cnta(26),cntb(26);\\n        int mxa=0,mxb=0,nca=0,ncb=0;\\n        for(char c: a) cnta[c-\\'a\\']++,mxa=max(mxa,cnta[c-\\'a\\']);\\n        for(char c: b) cntb[c-\\'a\\']++,mxb=max(mxb,cntb[c-\\'a\\']);\\n\\n        //let a<b: we need change less char in b and greater char in a\\n        //how? only need to worry about the overlap\\n        //assume the separate char\\n        int nmove=INT_MAX;\\n        for(int i=1;i<26;i++){ //assume the separate char\\n            int aa=0;\\n            for(int j=0;j<26;j++){\\n                if(cnta[j] && j>=i) aa+=cnta[j];\\n                if(cntb[j] && j<i) aa+=cntb[j];\\n            }\\n            nmove=min(aa,nmove);\\n        }\\n        \\n        for(int i=1;i<26;i++){ //assume the separate char\\n            int aa=0;\\n            for(int j=0;j<26;j++){\\n                if(cntb[j] && j>=i) aa+=cntb[j];\\n                if(cnta[j] && j<i) aa+=cnta[j];\\n            }\\n            nmove=min(aa,nmove);\\n        }\\n        //cout<<mxa<<\" \"<<mxb<<endl;\\n        return min({nmove,(int)a.size()-mxa+(int)b.size()-mxb});\\n    }\\n\\t```",
                "codeTag": "C++"
            },
            {
                "id": 1032293,
                "title": "javascript-solution-772ms",
                "content": "```\\n/////////////////////////////////////// First Version 1112ms //////////////////////////////////\\nconst mi = Math.min;\\nlet res;\\nconst minCharacters = (a, b) => {\\n    res = Number.MAX_SAFE_INTEGER;\\n    for (let k = 0; k < 26; k++) { // operation 3\\n        let cnt = 0;\\n        for (const ac of a) if (ac.charCodeAt() - \\'a\\'.charCodeAt() != k) cnt++;\\n        for (const bc of b) if (bc.charCodeAt() - \\'a\\'.charCodeAt() != k) cnt++;\\n        res = mi(res, cnt);\\n    }\\n    operate(a, b); // operation 1\\n    operate(b, a); // operation 2\\n    return res;\\n};\\n\\nconst operate = (a, b) => {\\n    for (let k = 0; k < 25; k++) {\\n        let cnt = 0;\\n        for (const ac of a) if (ac.charCodeAt() - \\'a\\'.charCodeAt() > k) cnt++;\\n        for (const bc of b) if (bc.charCodeAt() - \\'a\\'.charCodeAt() <= k) cnt++;\\n        res = mi(res, cnt);\\n    }\\n};\\n\\n\\n/////////////////////////////////////// Improved Version of operation 3  772ms //////////////////////////////////\\nconst mi = Math.min;\\nlet res, an, bn, freqA, freqB;\\nconst minCharacters = (a, b) => {\\n    an = a.length;\\n    bn = b.length;\\n    freqA = getRecord2(a); // frequency table of each character, sorted by freq in decreasing order.\\n    freqB = getRecord2(b);\\n    res = Number.MAX_SAFE_INTEGER;\\n    res = mi(res, three(a, b)); // operation 3\\n    operate(a, b);  // operation 1\\n    operate(b, a);  // operation 2\\n    return res;\\n};\\n\\nconst operate = (a, b) => {\\n    for (let k = 0; k < 25; k++) {\\n        let cnt = 0;\\n        for (const ac of a) if (ac.charCodeAt() - \\'a\\'.charCodeAt() > k) cnt++;\\n        for (const bc of b) if (bc.charCodeAt() - \\'a\\'.charCodeAt() <= k) cnt++;\\n        res = mi(res, cnt);\\n    }\\n};\\n\\nconst three = () => {\\n    let aop = freqA.values().next().value; // get the first value of the map (highest freq)\\n    let bop = freqB.values().next().value;\\n    return (an - aop) + (bn - bop); // the min operation is:  the length of string - highest freq character (keep it) for both a and b\\n};\\n\\nconst getRecord2 = (s) => {\\n    let map = new Map();\\n    for (const i of s) {\\n        map.set(i, (map.get(i) + 1) || 1);\\n    }\\n    map = sortMapByValue(map);\\n    return map;\\n};\\n\\nconst sortMapByValue = (map) => {\\n    return new Map([...map].sort((a, b) => b[1] - a[1]));\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/////////////////////////////////////// First Version 1112ms //////////////////////////////////\\nconst mi = Math.min;\\nlet res;\\nconst minCharacters = (a, b) => {\\n    res = Number.MAX_SAFE_INTEGER;\\n    for (let k = 0; k < 26; k++) { // operation 3\\n        let cnt = 0;\\n        for (const ac of a) if (ac.charCodeAt() - \\'a\\'.charCodeAt() != k) cnt++;\\n        for (const bc of b) if (bc.charCodeAt() - \\'a\\'.charCodeAt() != k) cnt++;\\n        res = mi(res, cnt);\\n    }\\n    operate(a, b); // operation 1\\n    operate(b, a); // operation 2\\n    return res;\\n};\\n\\nconst operate = (a, b) => {\\n    for (let k = 0; k < 25; k++) {\\n        let cnt = 0;\\n        for (const ac of a) if (ac.charCodeAt() - \\'a\\'.charCodeAt() > k) cnt++;\\n        for (const bc of b) if (bc.charCodeAt() - \\'a\\'.charCodeAt() <= k) cnt++;\\n        res = mi(res, cnt);\\n    }\\n};\\n\\n\\n/////////////////////////////////////// Improved Version of operation 3  772ms //////////////////////////////////\\nconst mi = Math.min;\\nlet res, an, bn, freqA, freqB;\\nconst minCharacters = (a, b) => {\\n    an = a.length;\\n    bn = b.length;\\n    freqA = getRecord2(a); // frequency table of each character, sorted by freq in decreasing order.\\n    freqB = getRecord2(b);\\n    res = Number.MAX_SAFE_INTEGER;\\n    res = mi(res, three(a, b)); // operation 3\\n    operate(a, b);  // operation 1\\n    operate(b, a);  // operation 2\\n    return res;\\n};\\n\\nconst operate = (a, b) => {\\n    for (let k = 0; k < 25; k++) {\\n        let cnt = 0;\\n        for (const ac of a) if (ac.charCodeAt() - \\'a\\'.charCodeAt() > k) cnt++;\\n        for (const bc of b) if (bc.charCodeAt() - \\'a\\'.charCodeAt() <= k) cnt++;\\n        res = mi(res, cnt);\\n    }\\n};\\n\\nconst three = () => {\\n    let aop = freqA.values().next().value; // get the first value of the map (highest freq)\\n    let bop = freqB.values().next().value;\\n    return (an - aop) + (bn - bop); // the min operation is:  the length of string - highest freq character (keep it) for both a and b\\n};\\n\\nconst getRecord2 = (s) => {\\n    let map = new Map();\\n    for (const i of s) {\\n        map.set(i, (map.get(i) + 1) || 1);\\n    }\\n    map = sortMapByValue(map);\\n    return map;\\n};\\n\\nconst sortMapByValue = (map) => {\\n    return new Map([...map].sort((a, b) => b[1] - a[1]));\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1032259,
                "title": "java-two-count-arrays",
                "content": "Tow count arrays. \\n```\\n    public int minCharacters(String a, String b) {\\n        int[] aCount = new int[26], bCount = new int[26];\\n        for(int i = 0; i < a.length(); i++) aCount[a.charAt(i) - \\'a\\']++;\\n        for(int i = 0; i < b.length(); i++) bCount[b.charAt(i) - \\'a\\']++;\\n        \\n        int min = Integer.MAX_VALUE, maxChar = 0;\\n        int count = 0, count1 = 0;\\n        for(int i = 0; i < 26; i++) {\\n            count += aCount[i];\\n            count1 += bCount[i];\\n            \\n\\t\\t\\tif(i != 25)\\n\\t\\t\\t\\tmin = Math.min(min, Math.min(count + b.length()-count1, count1+a.length()-count));\\n            maxChar = Math.max(maxChar, aCount[i] + bCount[i]);\\n        }\\n        \\n        min = Math.min(min, a.length() + b.length() - maxChar);\\n        \\n        return min;\\n    }\\n```\\n",
                "solutionTags": [],
                "code": "```\\n    public int minCharacters(String a, String b) {\\n        int[] aCount = new int[26], bCount = new int[26];\\n        for(int i = 0; i < a.length(); i++) aCount[a.charAt(i) - \\'a\\']++;\\n        for(int i = 0; i < b.length(); i++) bCount[b.charAt(i) - \\'a\\']++;\\n        \\n        int min = Integer.MAX_VALUE, maxChar = 0;\\n        int count = 0, count1 = 0;\\n        for(int i = 0; i < 26; i++) {\\n            count += aCount[i];\\n            count1 += bCount[i];\\n            \\n\\t\\t\\tif(i != 25)\\n\\t\\t\\t\\tmin = Math.min(min, Math.min(count + b.length()-count1, count1+a.length()-count));\\n            maxChar = Math.max(maxChar, aCount[i] + bCount[i]);\\n        }\\n        \\n        min = Math.min(min, a.length() + b.length() - maxChar);\\n        \\n        return min;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1032243,
                "title": "python-clean-solution",
                "content": "```\\nclass Solution(object):\\n    def minCharacters(self, a, b):\\n        \"\"\"\\n        :type a: str\\n        :type b: str\\n        :rtype: int\\n        \"\"\"\\n        if not a or not b:\\n            return 0\\n        \\n        count_a = collections.Counter(a)\\n        count_b = collections.Counter(b)\\n        \\n        na, nb = len(a), len(b)\\n        \\n        ans = na+nb\\n        \\n        curr_a, curr_b = 0,0\\n        \\n        for i in range(26):\\n            \\n            curr_a += count_a[chr(ord(\"a\")+i)]\\n            curr_b += count_b[chr(ord(\"a\")+i)]\\n            \\n            if i < 25:\\n                ans = min(ans, na + curr_b - curr_a, curr_a + nb - curr_b )\\n            \\n            ans = min(ans, na + nb - count_a[chr(ord(\"a\")+i)] - count_b[chr(ord(\"a\")+i)])\\n        \\n        return ans\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def minCharacters(self, a, b):\\n        \"\"\"\\n        :type a: str\\n        :type b: str\\n        :rtype: int\\n        \"\"\"\\n        if not a or not b:\\n            return 0\\n        \\n        count_a = collections.Counter(a)\\n        count_b = collections.Counter(b)\\n        \\n        na, nb = len(a), len(b)\\n        \\n        ans = na+nb\\n        \\n        curr_a, curr_b = 0,0\\n        \\n        for i in range(26):\\n            \\n            curr_a += count_a[chr(ord(\"a\")+i)]\\n            curr_b += count_b[chr(ord(\"a\")+i)]\\n            \\n            if i < 25:\\n                ans = min(ans, na + curr_b - curr_a, curr_a + nb - curr_b )\\n            \\n            ans = min(ans, na + nb - count_a[chr(ord(\"a\")+i)] - count_b[chr(ord(\"a\")+i)])\\n        \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1032232,
                "title": "c-o-n-solution-using-prefix-sum-with-explanation-and-example",
                "content": "example:\\na: ace\\nb. bdfgh\\nidea:\\n1. turn a and b into number of counts for each character (eg.t1 for a and t2 for b)\\neg.t1[\\'a\\'-\\'a\\']=1, t1[\\'c\\'-\\'a\\']=1, t1[\\'e\\'-\\'a\\']=1\\n->t1: 10101000\\n->t2: 01010111\\n2. find minimum number of moves to make all characters the same for a and b\\n->corresponding to c1 (for moves of string a) and c2 (for moves of string b) below\\n3. generate the prefix sum for number of characters less than or equal to a[index] and b[index]\\n->s1: 11223333\\n->s2: 01122345\\n4. loop the wall from 1~25 and find the minimum number of moves to make c3: max(a)<min(b) or c4: max(b)<min(a)\\n->c3: minimum number of moves to remove those right to wall a and left to wall b for each of 25 walls\\n->c3: minimum number of moves to remove those right to wall b and left to wall a for each of 25 walls\\nwall at index 1:\\n1 | 1223333\\n0 | 1122345\\nmake max(a)<min(b): s1[25]-s1[0]+s2[0]=3-1+0=2\\nmake max(b)<min(a): s2[25]-s2[0]+s1[0]=5-0+1=6\\nwall at index 2:\\n11 | 223333\\n01 | 122345\\nmake max(a)<min(b): s1[25]-s1[1]+s2[1]=3-1+1=3\\nmake max(b)<min(a): s2[25]-s2[1]+s1[1]=5-1+1=5\\n->keep going and find all candidates\\n```\\nint minCharacters(string a, string b) \\n{\\n\\tint m=a.length(),n=b.length(),c1=m,c2=n,c3=m+n,c4=m+n;\\n\\tint t1[26]={0},t2[26]={0};\\n\\t//step 1\\n\\tfor(int i=0;i<m;i++) t1[a[i]-\\'a\\']++;\\n\\tfor(int i=0;i<n;i++) t2[b[i]-\\'a\\']++;\\n\\t//step 2\\n\\tfor(int i=0;i<26;i++) c1=min(c1,m-t1[i]),c2=min(c2,n-t2[i]);\\n\\n\\tint s1[26]={0},s2[26]={0};\\n\\n\\ts1[0]=t1[0],s2[0]=t2[0];\\n\\t//step 3\\n\\tfor(int i=1;i<26;i++) s1[i]=s1[i-1]+t1[i],s2[i]=s2[i-1]+t2[i];\\n\\t//step 4\\n\\tfor(int i=1;i<26;i++)\\n\\t{\\n\\t\\tc3=min(c3,s1[25]-s1[i-1]+s2[i-1]);\\n\\t\\tc4=min(c4,s2[25]-s2[i-1]+s1[i-1]);\\n\\t}\\n\\treturn min(c1+c2,min(c3,c4));\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nint minCharacters(string a, string b) \\n{\\n\\tint m=a.length(),n=b.length(),c1=m,c2=n,c3=m+n,c4=m+n;\\n\\tint t1[26]={0},t2[26]={0};\\n\\t//step 1\\n\\tfor(int i=0;i<m;i++) t1[a[i]-\\'a\\']++;\\n\\tfor(int i=0;i<n;i++) t2[b[i]-\\'a\\']++;\\n\\t//step 2\\n\\tfor(int i=0;i<26;i++) c1=min(c1,m-t1[i]),c2=min(c2,n-t2[i]);\\n\\n\\tint s1[26]={0},s2[26]={0};\\n\\n\\ts1[0]=t1[0],s2[0]=t2[0];\\n\\t//step 3\\n\\tfor(int i=1;i<26;i++) s1[i]=s1[i-1]+t1[i],s2[i]=s2[i-1]+t2[i];\\n\\t//step 4\\n\\tfor(int i=1;i<26;i++)\\n\\t{\\n\\t\\tc3=min(c3,s1[25]-s1[i-1]+s2[i-1]);\\n\\t\\tc4=min(c4,s2[25]-s2[i-1]+s1[i-1]);\\n\\t}\\n\\treturn min(c1+c2,min(c3,c4));\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1032193,
                "title": "java-prefix-sum",
                "content": "```\\nclass Solution {\\n    public int minCharacters(String a, String b) {\\n        int min = a.length() + b.length();\\n        int[] cnt1 = new int[26];\\n        int[] cnt2 = new int[26];\\n        int max1 = -1;\\n        int max2 = -1;\\n        for (char ch : a.toCharArray()) {\\n            cnt1[ch - \\'a\\']++;\\n            max1 = Math.max(max1, ch - \\'a\\');\\n        }\\n        for (char ch : b.toCharArray()) {\\n            cnt2[ch - \\'a\\']++;\\n            max2 = Math.max(max2, ch - \\'a\\');\\n        }\\n        int[] presum1 = new int[27];\\n        int[] presum2 = new int[27];\\n        for (int i = 1; i <= 26; i++) {\\n            presum1[i] = presum1[i - 1] + cnt1[i - 1];\\n            presum2[i] = presum2[i - 1] + cnt2[i - 1];\\n        }\\n        for (int i = 0; i < 26; i++) {\\n            int res1 = presum1[26] + presum2[26] - (cnt1[i] + cnt2[i]);\\n            if (i == 25) {\\n                min = Math.min(min, res1);\\n                continue;\\n            }\\n            int res2 = presum1[26] - presum1[i + 1] + presum2[i + 1];\\n            int res3 = presum2[26] - presum2[i + 1] + presum1[i + 1];\\n            min = Math.min(min, Math.min(res1, Math.min(res2, res3)));\\n        }\\n        return min;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minCharacters(String a, String b) {\\n        int min = a.length() + b.length();\\n        int[] cnt1 = new int[26];\\n        int[] cnt2 = new int[26];\\n        int max1 = -1;\\n        int max2 = -1;\\n        for (char ch : a.toCharArray()) {\\n            cnt1[ch - \\'a\\']++;\\n            max1 = Math.max(max1, ch - \\'a\\');\\n        }\\n        for (char ch : b.toCharArray()) {\\n            cnt2[ch - \\'a\\']++;\\n            max2 = Math.max(max2, ch - \\'a\\');\\n        }\\n        int[] presum1 = new int[27];\\n        int[] presum2 = new int[27];\\n        for (int i = 1; i <= 26; i++) {\\n            presum1[i] = presum1[i - 1] + cnt1[i - 1];\\n            presum2[i] = presum2[i - 1] + cnt2[i - 1];\\n        }\\n        for (int i = 0; i < 26; i++) {\\n            int res1 = presum1[26] + presum2[26] - (cnt1[i] + cnt2[i]);\\n            if (i == 25) {\\n                min = Math.min(min, res1);\\n                continue;\\n            }\\n            int res2 = presum1[26] - presum1[i + 1] + presum2[i + 1];\\n            int res3 = presum2[26] - presum2[i + 1] + presum1[i + 1];\\n            min = Math.min(min, Math.min(res1, Math.min(res2, res3)));\\n        }\\n        return min;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1032187,
                "title": "java-solution",
                "content": "```\\n\\tpublic int minCharacters(String a, String b) {\\n\\t\\tint min = Integer.MAX_VALUE;\\n\\t\\tint[][] arra = new int[26][3];\\n\\t\\tint[][] arrb = new int[26][3];\\n\\t\\tfor (char c = \\'a\\'; c <= \\'z\\'; c++) {\\n\\t\\t\\tarra[c - \\'a\\'] = getOperation(a, c);\\n\\t\\t\\tarrb[c - \\'a\\'] = getOperation(b, c);\\n\\t\\t}\\n\\t\\tfor (char c1 = \\'a\\'; c1 <= \\'z\\'; c1++) {\\n\\t\\t\\tint op1 = arra[c1 - \\'a\\'][0];\\n\\t\\t\\tfor (char c2 = (char) (c1 + 1); c2 <= \\'z\\'; c2++) {\\n\\t\\t\\t\\tint op2 = arrb[c2 - \\'a\\'][1];\\n\\t\\t\\t\\tint total = op1 + op2;\\n\\t\\t\\t\\tif (total < min) {\\n\\t\\t\\t\\t\\tmin = total;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tfor (char c1 = \\'a\\'; c1 <= \\'z\\'; c1++) {\\n\\t\\t\\tint op1 = arrb[c1 - \\'a\\'][0];\\n\\t\\t\\tfor (char c2 = (char) (c1 + 1); c2 <= \\'z\\'; c2++) {\\n\\t\\t\\t\\tint op2 = arra[c2 - \\'a\\'][1];\\n\\t\\t\\t\\tint total = op1 + op2;\\n\\t\\t\\t\\tif (total < min) {\\n\\t\\t\\t\\t\\tmin = total;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tfor (char c = \\'a\\'; c <= \\'z\\'; c++) {\\n\\t\\t\\tint op1 = arra[c - \\'a\\'][2];\\n\\t\\t\\tint op2 = arrb[c - \\'a\\'][2];\\n\\t\\t\\tint total = op1 + op2;\\n\\t\\t\\tif (total < min) {\\n\\t\\t\\t\\tmin = total;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn min;\\n\\t}\\n\\n\\tpublic int[] getOperation(String s, char c) {\\n\\t\\tchar[] ch = s.toCharArray();\\n\\t\\tint[] arr = new int[3];\\n\\t\\tfor (int i = 0; i < ch.length; i++) {\\n\\t\\t\\tif (ch[i] > c) {\\n\\t\\t\\t\\tarr[0]++;\\n\\t\\t\\t\\tarr[2]++;\\n\\t\\t\\t} else if (ch[i] < c) {\\n\\t\\t\\t\\tarr[1]++;\\n\\t\\t\\t\\tarr[2]++;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn arr;\\n\\t}\\n```",
                "solutionTags": [],
                "code": "```\\n\\tpublic int minCharacters(String a, String b) {\\n\\t\\tint min = Integer.MAX_VALUE;\\n\\t\\tint[][] arra = new int[26][3];\\n\\t\\tint[][] arrb = new int[26][3];\\n\\t\\tfor (char c = \\'a\\'; c <= \\'z\\'; c++) {\\n\\t\\t\\tarra[c - \\'a\\'] = getOperation(a, c);\\n\\t\\t\\tarrb[c - \\'a\\'] = getOperation(b, c);\\n\\t\\t}\\n\\t\\tfor (char c1 = \\'a\\'; c1 <= \\'z\\'; c1++) {\\n\\t\\t\\tint op1 = arra[c1 - \\'a\\'][0];\\n\\t\\t\\tfor (char c2 = (char) (c1 + 1); c2 <= \\'z\\'; c2++) {\\n\\t\\t\\t\\tint op2 = arrb[c2 - \\'a\\'][1];\\n\\t\\t\\t\\tint total = op1 + op2;\\n\\t\\t\\t\\tif (total < min) {\\n\\t\\t\\t\\t\\tmin = total;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tfor (char c1 = \\'a\\'; c1 <= \\'z\\'; c1++) {\\n\\t\\t\\tint op1 = arrb[c1 - \\'a\\'][0];\\n\\t\\t\\tfor (char c2 = (char) (c1 + 1); c2 <= \\'z\\'; c2++) {\\n\\t\\t\\t\\tint op2 = arra[c2 - \\'a\\'][1];\\n\\t\\t\\t\\tint total = op1 + op2;\\n\\t\\t\\t\\tif (total < min) {\\n\\t\\t\\t\\t\\tmin = total;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tfor (char c = \\'a\\'; c <= \\'z\\'; c++) {\\n\\t\\t\\tint op1 = arra[c - \\'a\\'][2];\\n\\t\\t\\tint op2 = arrb[c - \\'a\\'][2];\\n\\t\\t\\tint total = op1 + op2;\\n\\t\\t\\tif (total < min) {\\n\\t\\t\\t\\tmin = total;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn min;\\n\\t}\\n\\n\\tpublic int[] getOperation(String s, char c) {\\n\\t\\tchar[] ch = s.toCharArray();\\n\\t\\tint[] arr = new int[3];\\n\\t\\tfor (int i = 0; i < ch.length; i++) {\\n\\t\\t\\tif (ch[i] > c) {\\n\\t\\t\\t\\tarr[0]++;\\n\\t\\t\\t\\tarr[2]++;\\n\\t\\t\\t} else if (ch[i] < c) {\\n\\t\\t\\t\\tarr[1]++;\\n\\t\\t\\t\\tarr[2]++;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn arr;\\n\\t}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1032169,
                "title": "easy-o-n-java-solution-to-find-steps-for-3-operations",
                "content": "\\n```\\nclass Solution {\\n    public int minCharacters(String a, String b) {\\n        \\n        int[] aa = new int[26];\\n        int[] bb = new int[26];\\n        \\n        for (int i = 0; i < a.length(); i++) {\\n            char c = a.charAt(i);\\n            aa[c - \\'a\\']++;\\n        }\\n        \\n        for (int i = 0; i < b.length(); i++) {\\n            char c = b.charAt(i);\\n            bb[c - \\'a\\']++;\\n        }\\n        \\n        int o1 = changeToLess(aa, bb);\\n        int o2 = changeToLess(bb, aa);\\n        int o3 = changeToOne(aa, bb);\\n        \\n        System.out.println(\"o1: \" + o1 + \" o2: \" + o2 + \" o3: \" + o3 );\\n        return Math.min(o1, Math.min(o2, o3));\\n    }\\n    \\n    private int changeToLess(int[] aa, int[] bb) {\\n        int[] aps = new int[27];\\n        int[] bps = new int[27];\\n        \\n        aps[0] = 0;\\n        bps[0] = 0;\\n        \\n        for (int i = 0; i < 26; i++) {\\n            aps[i + 1] = aps[i] + aa[i];\\n            bps[i + 1] = bps[i] + bb[i];\\n        }\\n        \\n        int result = Integer.MAX_VALUE;\\n        \\n        for (int i = 1; i < 26; i++) {\\n            int aRight = aps[26] - aps[i];\\n            int bLeft = bps[i];\\n            \\n            result = Math.min(result, aRight + bLeft);\\n        }\\n        \\n        \\n        \\n        return result;\\n    }\\n    \\n    private int changeToOne(int[] aa, int[] bb) {\\n        int max = 0;\\n        int aLen = 0;\\n        int bLen = 0;\\n        for (int i = 0; i < 26; i++) {\\n            int current = aa[i] + bb[i];\\n            aLen += aa[i];\\n            bLen += bb[i];\\n            max = Math.max(current, max);\\n        }\\n        \\n        return aLen + bLen - max;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minCharacters(String a, String b) {\\n        \\n        int[] aa = new int[26];\\n        int[] bb = new int[26];\\n        \\n        for (int i = 0; i < a.length(); i++) {\\n            char c = a.charAt(i);\\n            aa[c - \\'a\\']++;\\n        }\\n        \\n        for (int i = 0; i < b.length(); i++) {\\n            char c = b.charAt(i);\\n            bb[c - \\'a\\']++;\\n        }\\n        \\n        int o1 = changeToLess(aa, bb);\\n        int o2 = changeToLess(bb, aa);\\n        int o3 = changeToOne(aa, bb);\\n        \\n        System.out.println(\"o1: \" + o1 + \" o2: \" + o2 + \" o3: \" + o3 );\\n        return Math.min(o1, Math.min(o2, o3));\\n    }\\n    \\n    private int changeToLess(int[] aa, int[] bb) {\\n        int[] aps = new int[27];\\n        int[] bps = new int[27];\\n        \\n        aps[0] = 0;\\n        bps[0] = 0;\\n        \\n        for (int i = 0; i < 26; i++) {\\n            aps[i + 1] = aps[i] + aa[i];\\n            bps[i + 1] = bps[i] + bb[i];\\n        }\\n        \\n        int result = Integer.MAX_VALUE;\\n        \\n        for (int i = 1; i < 26; i++) {\\n            int aRight = aps[26] - aps[i];\\n            int bLeft = bps[i];\\n            \\n            result = Math.min(result, aRight + bLeft);\\n        }\\n        \\n        \\n        \\n        return result;\\n    }\\n    \\n    private int changeToOne(int[] aa, int[] bb) {\\n        int max = 0;\\n        int aLen = 0;\\n        int bLen = 0;\\n        for (int i = 0; i < 26; i++) {\\n            int current = aa[i] + bb[i];\\n            aLen += aa[i];\\n            bLen += bb[i];\\n            max = Math.max(current, max);\\n        }\\n        \\n        return aLen + bLen - max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1032147,
                "title": "java-solution-counting",
                "content": "```java\\npublic int minCharacters(String a, String b) {\\n        int[] countA = new int[26], countB = new int[26];\\n        for (char c : a.toCharArray()) {\\n            countA[c - \\'a\\']++;\\n        }\\n        for (char c : b.toCharArray()) {\\n            countB[c - \\'a\\']++;\\n        }\\n        int res = a.length() + b.length();\\n        for (int i = 0; i < 26; i++) {\\n            res = Math.min(res, a.length() + b.length() - countA[i] - countB[i]);\\n        }\\n       \\n        for (int i = 1; i < 26; i++) {\\n            countA[i] += countA[i - 1];\\n            countB[i] += countB[i - 1];\\n            res = Math.min(res, a.length() - countA[i - 1] + countB[i - 1]);\\n            res = Math.min(res, b.length() - countB[i - 1] + countA[i - 1]);\\n            \\n        }\\n        return  res;\\n    }\\n```",
                "solutionTags": [],
                "code": "```java\\npublic int minCharacters(String a, String b) {\\n        int[] countA = new int[26], countB = new int[26];\\n        for (char c : a.toCharArray()) {\\n            countA[c - \\'a\\']++;\\n        }\\n        for (char c : b.toCharArray()) {\\n            countB[c - \\'a\\']++;\\n        }\\n        int res = a.length() + b.length();\\n        for (int i = 0; i < 26; i++) {\\n            res = Math.min(res, a.length() + b.length() - countA[i] - countB[i]);\\n        }\\n       \\n        for (int i = 1; i < 26; i++) {\\n            countA[i] += countA[i - 1];\\n            countB[i] += countB[i - 1];\\n            res = Math.min(res, a.length() - countA[i - 1] + countB[i - 1]);\\n            res = Math.min(res, b.length() - countB[i - 1] + countA[i - 1]);\\n            \\n        }\\n        return  res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1032136,
                "title": "python-solution-faster-than-100",
                "content": "Image this problem in this way, in a 1-d dimensional x-axis, you have two group of points, now you want to find the separate point so that you need to move the least number of point  from left group to right group + the least number of point from right group to left.\\n\\nInstead of the points, here we have 25 characters, from \\'a\\' to \\'z\\'.  Because we only have 25 characters, we leave one out, so that we still have the ability to compare in the case one of the group contains all 25 characters. \\n```\\ndef minCharacters(self, a, b):\\n        \"\"\"\\n        :type a: str\\n        :type b: str\\n        :rtype: int\\n        \"\"\"\\n        from collections import Counter\\n     \\n        a_count = Counter(a)\\n        b_count = Counter(b)\\n        \\n        res = float(\\'inf\\')\\n        s=\\'abcdefghijklmnoprstuvwxy\\'\\n\\n        for i in s:\\n            # check the needed changes that if a is always smaller than b, and the separate character is i\\n            cnt1 = 0\\n            for l in a:\\n                if l>i:\\n                    cnt1 = cnt1+1\\n            cnt2 = 0\\n            for l in b:\\n                if l<=i:\\n                    cnt2 = cnt2+1\\n\\n            # check the opposite\\n            cnt3 = 0\\n            for l in b:\\n                if l>i:\\n                    cnt3 = cnt3+1\\n            cnt4 = 0\\n            for l in a:\\n                if l<=i:\\n                    cnt4 = cnt4+1\\n                    \\n            temp = min(cnt1+cnt2, cnt3+cnt4)\\n            res = min(res, temp)\\n        \\n        # change a so that it contains only 1 distinct letter, and change b so that it contains only 1 distinct letter\\n        a_l = len(a)\\n        min_change_a = a_l\\n        for key, val in a_count.items():\\n            min_change_a = min(min_change_a, a_l-val)\\n        \\n        b_l = len(b)\\n        min_change_b = b_l\\n        for key, val in b_count.items():\\n            min_change_b = min(min_change_b, b_l-val)\\n        res = min(res, min_change_a+min_change_b)\\n            \\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\ndef minCharacters(self, a, b):\\n        \"\"\"\\n        :type a: str\\n        :type b: str\\n        :rtype: int\\n        \"\"\"\\n        from collections import Counter\\n     \\n        a_count = Counter(a)\\n        b_count = Counter(b)\\n        \\n        res = float(\\'inf\\')\\n        s=\\'abcdefghijklmnoprstuvwxy\\'\\n\\n        for i in s:\\n            # check the needed changes that if a is always smaller than b, and the separate character is i\\n            cnt1 = 0\\n            for l in a:\\n                if l>i:\\n                    cnt1 = cnt1+1\\n            cnt2 = 0\\n            for l in b:\\n                if l<=i:\\n                    cnt2 = cnt2+1\\n\\n            # check the opposite\\n            cnt3 = 0\\n            for l in b:\\n                if l>i:\\n                    cnt3 = cnt3+1\\n            cnt4 = 0\\n            for l in a:\\n                if l<=i:\\n                    cnt4 = cnt4+1\\n                    \\n            temp = min(cnt1+cnt2, cnt3+cnt4)\\n            res = min(res, temp)\\n        \\n        # change a so that it contains only 1 distinct letter, and change b so that it contains only 1 distinct letter\\n        a_l = len(a)\\n        min_change_a = a_l\\n        for key, val in a_count.items():\\n            min_change_a = min(min_change_a, a_l-val)\\n        \\n        b_l = len(b)\\n        min_change_b = b_l\\n        for key, val in b_count.items():\\n            min_change_b = min(min_change_b, b_l-val)\\n        res = min(res, min_change_a+min_change_b)\\n            \\n        return res\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1032123,
                "title": "c-o-m-n",
                "content": "```\\nclass Solution {\\npublic:\\n    int minCharacters(string a, string b) {\\n        vector<int> coa(26), cob(26);\\n        for (auto c:a) {\\n            coa[c - \\'a\\']++;\\n        }\\n        for (auto c:b) {\\n            cob[c - \\'a\\']++;\\n        }\\n        int w3 = 0, mx = 0, tmp, la = a.size(), lb = b.size(), suma = 0, sumb = 0;\\n        int cost = 1e5;\\n        for (int i = 0; i < 26; ++i) {\\n            suma += coa[i];\\n            sumb += cob[i];\\n            if(i<25)cost = min(cost, min(sumb + la - suma, suma + lb - sumb));\\n            tmp = coa[i] + cob[i];\\n            w3 += tmp;\\n            mx = max(mx, tmp);\\n        }\\n        return min(cost, w3 - mx);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minCharacters(string a, string b) {\\n        vector<int> coa(26), cob(26);\\n        for (auto c:a) {\\n            coa[c - \\'a\\']++;\\n        }\\n        for (auto c:b) {\\n            cob[c - \\'a\\']++;\\n        }\\n        int w3 = 0, mx = 0, tmp, la = a.size(), lb = b.size(), suma = 0, sumb = 0;\\n        int cost = 1e5;\\n        for (int i = 0; i < 26; ++i) {\\n            suma += coa[i];\\n            sumb += cob[i];\\n            if(i<25)cost = min(cost, min(sumb + la - suma, suma + lb - sumb));\\n            tmp = coa[i] + cob[i];\\n            w3 += tmp;\\n            mx = max(mx, tmp);\\n        }\\n        return min(cost, w3 - mx);\\n    }\\n};\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1565087,
                "content": [
                    {
                        "username": "Just__a__Visitor",
                        "content": "WLOG, assume that we are dealing with `Constraint 1`. The same process can be repeated for `Constraint 2` by swapping both the strings.\\n\\nAn immediate approach that comes to mind is :\\n\\n1) Pick the lowest valued character in string `B`\\n2) Traverse the string `A` and whenever you see a character with value equal to or greater  than that of the lowest character in `B`, you add 1 to your cost.\\n\\nHowever, **This approach is incorrect**, as we are restricting ourselves to only changing either of the strings at a time. What if we could change characters in both the strings as per our desire? It\\'s certainly allowed by the constraints, right?\\n\\nThis brings us to the final trick. Notice that we are only dealing with lower case English letters. Hence, the total number of distinct values that we can see is 26. So, rather than taking a Greedy approach, let\\'s iterate through all possible combinations (in an efficient manner) so that we don\\'t leave anything on luck.\\n\\nWe do not know what should we keep the optimal `lower bound` in string `B`. But, we do know that it would be some character between `b` and `z`. (Think about why not `a`). So, out of these 25 possibilities, let us fix a character to be the lower bound of `B`, say `ch`. Then, we need to add a cost for each character in `B` which is smaller than `ch`  and a cost for each character in `A` which is greater than or equal to `ch`. We sum up both these costs, repeat this for each character and finally take the minimum.\\n\\nHandling the third case is easy, you just need to find the character with the maximum frequency and change all other characters to this value."
                    },
                    {
                        "username": "AnchitPandey1996",
                        "content": "Can someone please explain why the output for the following test case is 2 ?\\n\\na = \"ace\"\\nb =\"abe\"\\n"
                    },
                    {
                        "username": "illdursa",
                        "content": "Change \"e\" in string b to the letter \"a\", then change \"a\" in string a to the letter z. solved in 2 steps"
                    },
                    {
                        "username": "werewolf97",
                        "content": "Why is expected output for a= \"ace\" and b= \"abe\" is 2 not 3?"
                    },
                    {
                        "username": "CodingMission",
                        "content": "\"da\"\\n\"cced\"\\n\\nHow is the answer 1?"
                    },
                    {
                        "username": "alisink",
                        "content": "[@AKASHKUMARPATHAK](/AKASHKUMARPATHAK) man at least read the problem clearly"
                    },
                    {
                        "username": "AKASHKUMARPATHAK",
                        "content": "chane \\'d\\' to \\'a\\' in first string\\n"
                    }
                ]
            },
            {
                "id": 1568513,
                "content": [
                    {
                        "username": "Just__a__Visitor",
                        "content": "WLOG, assume that we are dealing with `Constraint 1`. The same process can be repeated for `Constraint 2` by swapping both the strings.\\n\\nAn immediate approach that comes to mind is :\\n\\n1) Pick the lowest valued character in string `B`\\n2) Traverse the string `A` and whenever you see a character with value equal to or greater  than that of the lowest character in `B`, you add 1 to your cost.\\n\\nHowever, **This approach is incorrect**, as we are restricting ourselves to only changing either of the strings at a time. What if we could change characters in both the strings as per our desire? It\\'s certainly allowed by the constraints, right?\\n\\nThis brings us to the final trick. Notice that we are only dealing with lower case English letters. Hence, the total number of distinct values that we can see is 26. So, rather than taking a Greedy approach, let\\'s iterate through all possible combinations (in an efficient manner) so that we don\\'t leave anything on luck.\\n\\nWe do not know what should we keep the optimal `lower bound` in string `B`. But, we do know that it would be some character between `b` and `z`. (Think about why not `a`). So, out of these 25 possibilities, let us fix a character to be the lower bound of `B`, say `ch`. Then, we need to add a cost for each character in `B` which is smaller than `ch`  and a cost for each character in `A` which is greater than or equal to `ch`. We sum up both these costs, repeat this for each character and finally take the minimum.\\n\\nHandling the third case is easy, you just need to find the character with the maximum frequency and change all other characters to this value."
                    },
                    {
                        "username": "AnchitPandey1996",
                        "content": "Can someone please explain why the output for the following test case is 2 ?\\n\\na = \"ace\"\\nb =\"abe\"\\n"
                    },
                    {
                        "username": "illdursa",
                        "content": "Change \"e\" in string b to the letter \"a\", then change \"a\" in string a to the letter z. solved in 2 steps"
                    },
                    {
                        "username": "werewolf97",
                        "content": "Why is expected output for a= \"ace\" and b= \"abe\" is 2 not 3?"
                    },
                    {
                        "username": "CodingMission",
                        "content": "\"da\"\\n\"cced\"\\n\\nHow is the answer 1?"
                    },
                    {
                        "username": "alisink",
                        "content": "[@AKASHKUMARPATHAK](/AKASHKUMARPATHAK) man at least read the problem clearly"
                    },
                    {
                        "username": "AKASHKUMARPATHAK",
                        "content": "chane \\'d\\' to \\'a\\' in first string\\n"
                    }
                ]
            },
            {
                "id": 1574982,
                "content": [
                    {
                        "username": "Just__a__Visitor",
                        "content": "WLOG, assume that we are dealing with `Constraint 1`. The same process can be repeated for `Constraint 2` by swapping both the strings.\\n\\nAn immediate approach that comes to mind is :\\n\\n1) Pick the lowest valued character in string `B`\\n2) Traverse the string `A` and whenever you see a character with value equal to or greater  than that of the lowest character in `B`, you add 1 to your cost.\\n\\nHowever, **This approach is incorrect**, as we are restricting ourselves to only changing either of the strings at a time. What if we could change characters in both the strings as per our desire? It\\'s certainly allowed by the constraints, right?\\n\\nThis brings us to the final trick. Notice that we are only dealing with lower case English letters. Hence, the total number of distinct values that we can see is 26. So, rather than taking a Greedy approach, let\\'s iterate through all possible combinations (in an efficient manner) so that we don\\'t leave anything on luck.\\n\\nWe do not know what should we keep the optimal `lower bound` in string `B`. But, we do know that it would be some character between `b` and `z`. (Think about why not `a`). So, out of these 25 possibilities, let us fix a character to be the lower bound of `B`, say `ch`. Then, we need to add a cost for each character in `B` which is smaller than `ch`  and a cost for each character in `A` which is greater than or equal to `ch`. We sum up both these costs, repeat this for each character and finally take the minimum.\\n\\nHandling the third case is easy, you just need to find the character with the maximum frequency and change all other characters to this value."
                    },
                    {
                        "username": "AnchitPandey1996",
                        "content": "Can someone please explain why the output for the following test case is 2 ?\\n\\na = \"ace\"\\nb =\"abe\"\\n"
                    },
                    {
                        "username": "illdursa",
                        "content": "Change \"e\" in string b to the letter \"a\", then change \"a\" in string a to the letter z. solved in 2 steps"
                    },
                    {
                        "username": "werewolf97",
                        "content": "Why is expected output for a= \"ace\" and b= \"abe\" is 2 not 3?"
                    },
                    {
                        "username": "CodingMission",
                        "content": "\"da\"\\n\"cced\"\\n\\nHow is the answer 1?"
                    },
                    {
                        "username": "alisink",
                        "content": "[@AKASHKUMARPATHAK](/AKASHKUMARPATHAK) man at least read the problem clearly"
                    },
                    {
                        "username": "AKASHKUMARPATHAK",
                        "content": "chane \\'d\\' to \\'a\\' in first string\\n"
                    }
                ]
            },
            {
                "id": 1574858,
                "content": [
                    {
                        "username": "Just__a__Visitor",
                        "content": "WLOG, assume that we are dealing with `Constraint 1`. The same process can be repeated for `Constraint 2` by swapping both the strings.\\n\\nAn immediate approach that comes to mind is :\\n\\n1) Pick the lowest valued character in string `B`\\n2) Traverse the string `A` and whenever you see a character with value equal to or greater  than that of the lowest character in `B`, you add 1 to your cost.\\n\\nHowever, **This approach is incorrect**, as we are restricting ourselves to only changing either of the strings at a time. What if we could change characters in both the strings as per our desire? It\\'s certainly allowed by the constraints, right?\\n\\nThis brings us to the final trick. Notice that we are only dealing with lower case English letters. Hence, the total number of distinct values that we can see is 26. So, rather than taking a Greedy approach, let\\'s iterate through all possible combinations (in an efficient manner) so that we don\\'t leave anything on luck.\\n\\nWe do not know what should we keep the optimal `lower bound` in string `B`. But, we do know that it would be some character between `b` and `z`. (Think about why not `a`). So, out of these 25 possibilities, let us fix a character to be the lower bound of `B`, say `ch`. Then, we need to add a cost for each character in `B` which is smaller than `ch`  and a cost for each character in `A` which is greater than or equal to `ch`. We sum up both these costs, repeat this for each character and finally take the minimum.\\n\\nHandling the third case is easy, you just need to find the character with the maximum frequency and change all other characters to this value."
                    },
                    {
                        "username": "AnchitPandey1996",
                        "content": "Can someone please explain why the output for the following test case is 2 ?\\n\\na = \"ace\"\\nb =\"abe\"\\n"
                    },
                    {
                        "username": "illdursa",
                        "content": "Change \"e\" in string b to the letter \"a\", then change \"a\" in string a to the letter z. solved in 2 steps"
                    },
                    {
                        "username": "werewolf97",
                        "content": "Why is expected output for a= \"ace\" and b= \"abe\" is 2 not 3?"
                    },
                    {
                        "username": "CodingMission",
                        "content": "\"da\"\\n\"cced\"\\n\\nHow is the answer 1?"
                    },
                    {
                        "username": "alisink",
                        "content": "[@AKASHKUMARPATHAK](/AKASHKUMARPATHAK) man at least read the problem clearly"
                    },
                    {
                        "username": "AKASHKUMARPATHAK",
                        "content": "chane \\'d\\' to \\'a\\' in first string\\n"
                    }
                ]
            }
        ]
    }
]