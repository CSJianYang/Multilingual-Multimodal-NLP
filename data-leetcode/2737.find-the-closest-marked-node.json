[
    {
        "title": "Count the Number of K-Free Subsets",
        "question_content": null,
        "solutions": [],
        "discussions": [
            {
                "id": 1944373,
                "content": [
                    {
                        "username": "feimi",
                        "content": "this is a hard problem."
                    },
                    {
                        "username": "MdoingIt",
                        "content": "this is a hard!!"
                    },
                    {
                        "username": "surajvg93",
                        "content": "Same as question 2597: [https://leetcode.com/problems/the-number-of-beautiful-subsets/](https://leetcode.com/problems/the-number-of-beautiful-subsets/)"
                    },
                    {
                        "username": "sJQpVnXqyHEg",
                        "content": "[2,2,2] is not an accepted test case, but accepted in 2597. "
                    }
                ]
            },
            {
                "id": 1929130,
                "content": [
                    {
                        "username": "feimi",
                        "content": "this is a hard problem."
                    },
                    {
                        "username": "MdoingIt",
                        "content": "this is a hard!!"
                    },
                    {
                        "username": "surajvg93",
                        "content": "Same as question 2597: [https://leetcode.com/problems/the-number-of-beautiful-subsets/](https://leetcode.com/problems/the-number-of-beautiful-subsets/)"
                    },
                    {
                        "username": "sJQpVnXqyHEg",
                        "content": "[2,2,2] is not an accepted test case, but accepted in 2597. "
                    }
                ]
            },
            {
                "id": 1990026,
                "content": [
                    {
                        "username": "feimi",
                        "content": "this is a hard problem."
                    },
                    {
                        "username": "MdoingIt",
                        "content": "this is a hard!!"
                    },
                    {
                        "username": "surajvg93",
                        "content": "Same as question 2597: [https://leetcode.com/problems/the-number-of-beautiful-subsets/](https://leetcode.com/problems/the-number-of-beautiful-subsets/)"
                    },
                    {
                        "username": "sJQpVnXqyHEg",
                        "content": "[2,2,2] is not an accepted test case, but accepted in 2597. "
                    }
                ]
            }
        ]
    },
    {
        "title": "Generate Fibonacci Sequence",
        "question_content": "<p>Write a generator function that returns a generator object which yields the&nbsp;<strong>fibonacci sequence</strong>.</p>\n\n<p>The&nbsp;<strong>fibonacci sequence</strong>&nbsp;is defined by the relation <code>X<sub>n</sub>&nbsp;= X<sub>n-1</sub>&nbsp;+ X<sub>n-2</sub></code>.</p>\n\n<p>The first few numbers&nbsp;of the series are <code>0, 1, 1, 2, 3, 5, 8, 13</code>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> callCount = 5\n<strong>Output:</strong> [0,1,1,2,3]\n<strong>Explanation:</strong>\nconst gen = fibGenerator();\ngen.next().value; // 0\ngen.next().value; // 1\ngen.next().value; // 1\ngen.next().value; // 2\ngen.next().value; // 3\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> callCount = 0\n<strong>Output:</strong> []\n<strong>Explanation:</strong> gen.next() is never called so nothing is outputted\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>0 &lt;= callCount &lt;= 50</code></li>\n</ul>\n",
        "solutions": [
            {
                "id": 3587908,
                "title": "easy-solution-2648-generate-fibonacci-sequence-level-up-your-js-skills-day-29",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe Fibonacci sequence is a series of numbers in which each number is the sum of the two preceding ones, usually starting with 0 and 1. We can use a generator function to generate the Fibonacci sequence one number at a time.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Initialize two variables, `current` and `next`, with values 0 and 1\\nrespectively. These variables represent the current Fibonacci number and the next Fibonacci number in the sequence.\\n2. Use a while loop to generate the Fibonacci sequence indefinitely.\\n3. Inside the loop, yield the value of `current` as the next value of the generator.\\n4. Update the values of `current` and `next` by swapping their values. Set `current` to the value of `next` and `next` to the sum of `current` and `next`.\\n5. Repeat steps 3 and 4 indefinitely to generate the Fibonacci sequence.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nThe time complexity of generating the Fibonacci sequence using a generator function is $O(1)$ per iteration. This is because each Fibonacci number is generated on the fly as requested, without needing to generate the entire sequence in advance.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nThe space complexity is $O(1)$ because we only need a constant amount of space to store the current and next Fibonacci numbers. The generator function does not require any additional space proportional to the size of the sequence.\\n\\n# Code\\n```\\n/**\\n * @return {Generator<number>}\\n */\\nvar fibGenerator = function*() {\\n\\n  let current = 0; \\n  let next = 1;\\n\\n  while (true) {\\n    yield current; \\n\\n    [current, next] = [next, current + next];\\n\\n    // The above line is equivalent to the following:\\n    // let temp = current;\\n    // current = next;\\n    // next = temp + next;\\n  }\\n};\\n\\n/**\\n * const gen = fibGenerator();\\n * gen.next().value; // 0\\n * gen.next().value; // 1\\n */\\n```\\n\\n![image.png](https://assets.leetcode.com/users/images/b427e686-2e5d-469a-8e7a-db5140022a6b_1677715904.0948765.png)\\n\\n\\n# Please Upvote\\uD83D\\uDC4D\\uD83D\\uDC4D\\n```\\nThanks for visiting my solution.\\uD83D\\uDE0A Keep Learning\\nPlease give my solution an upvote! \\uD83D\\uDC4D\\nIt\\'s a simple way to show your appreciation and\\nkeep me motivated. Thank you! \\uD83D\\uDE0A\\n```\\n\\n## There are several ways to implement a Fibonacci generator in JavaScript. Here are a few alternative approaches:\\n- ## Implementation 1: Using a Closure\\n```JS []\\nconst fibGenerator = () => {\\n  let current = 0;\\n  let next = 1;\\n\\n  return () => {\\n    const result = current;\\n    [current, next] = [next, current + next];\\n    return result;\\n  };\\n};\\n\\nconst gen = fibGenerator();\\nconsole.log(gen()); // 0\\nconsole.log(gen()); // 1\\n\\n```\\n>In this approach, we use a closure to create a Fibonacci generator. The `fibGenerator` function returns another function that generates the Fibonacci numbers. The inner function keeps track of the `current` and `next` values using a closure. Each time the inner function is called, it calculates the next Fibonacci number, updates the values, and returns the current one.\\n\\n- ## Implementation 2: Using an Iterator\\n```JS []\\nconst fibGenerator = {\\n  [Symbol.iterator]: function*() {\\n    let current = 0;\\n    let next = 1;\\n\\n    while (true) {\\n      yield current;\\n      [current, next] = [next, current + next];\\n    }\\n  }\\n};\\n\\nconst gen = fibGenerator[Symbol.iterator]();\\nconsole.log(gen.next().value); // 0\\nconsole.log(gen.next().value); // 1\\n\\n```\\n>In this approach, we define `fibGenerator` as an object with a\\n`Symbol.iterator` method. The `Symbol.iterator` method is a generator\\nfunction that generates the Fibonacci sequence. We can then create an iterator by calling `fibGenerator[Symbol.iterator]()` and use it to retrieve the Fibonacci numbers.\\n\\n- ## Implementation 3: Using a Recursive Generator\\n``` JS []\\nfunction* fibGenerator(current = 0, next = 1) {\\n  yield current;\\n  yield* fibGenerator(next, current + next);\\n}\\n\\nconst gen = fibGenerator();\\nconsole.log(gen.next().value); // 0\\nconsole.log(gen.next().value); // 1\\n\\n```\\n>In this approach, we define the `fibGenerator` function as a recursive generator. It takes two parameters, `current` and `next`, representing the current and next Fibonacci numbers. It yields the current number and then delegates to itself with the updated values of `next` and `current + next`. This recursive generator generates the Fibonacci sequence indefinitely.\\n\\n- ## Implementation 4: Without using a generator function\\n``` JS []\\nconst fibGenerator = {\\n  current: 0,\\n  next: 1,\\n  nextNumber: function() {\\n    const result = this.current;\\n    [this.current, this.next] = [this.next, this.current + this.next];\\n    return result;\\n  }\\n};\\n\\nconsole.log(fibGenerator.nextNumber()); // 0\\nconsole.log(fibGenerator.nextNumber()); // 1\\n\\n```\\nIn this approach, we define `fibGenerator` as an object with properties `current` and `next` to store the current and next Fibonacci numbers, respectively. The `nextNumber` method calculates and returns the next Fibonacci number while updating the `current` and `next` properties accordingly.\\nTo generate Fibonacci numbers, you can simply call the `nextNumber` method of the `fibGenerator` object. Each call to `nextNumber` will return the next Fibonacci number in the sequence.\\n>Note: that this approach does not provide the infinite sequence of Fibonacci numbers like a generator function does. Instead, it generates the Fibonacci numbers one at a time upon each method call.\\n\\n\\n\\n# Important topic to Learn \\n\\n| Sr No. | Topic | Sr No. | Topic |\\n|-----|-----|-----|-----|\\n1.|Arrays , Array methods() |2.|Function programming *|\\n3.|Higher-order function|4.|Memoization|\\n5.|Currying|6.|Promises, async/await|\\n7.|Compare Objects|8.|Prototypes, inheritance|\\n9.|Generators, advanced iteration*|10.|----------------\\n>[ Note:- * marked is related to today\\'s problem ]\\n\\n<img src=\"https://media.giphy.com/media/Xd6WrGsyh1su7X0ZGF/giphy.gif\" width=\"40\">\\n\\n# Please Comment\\uD83D\\uDC4D\\uD83D\\uDC4D \\n```\\nThanks for visiting my solution comment below if you like it.\\uD83D\\uDE0A\\n```\\n\\n\\n\\n\\n\\n\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @return {Generator<number>}\\n */\\nvar fibGenerator = function*() {\\n\\n  let current = 0; \\n  let next = 1;\\n\\n  while (true) {\\n    yield current; \\n\\n    [current, next] = [next, current + next];\\n\\n    // The above line is equivalent to the following:\\n    // let temp = current;\\n    // current = next;\\n    // next = temp + next;\\n  }\\n};\\n\\n/**\\n * const gen = fibGenerator();\\n * gen.next().value; // 0\\n * gen.next().value; // 1\\n */\\n```\n```\\nThanks for visiting my solution.\\uD83D\\uDE0A Keep Learning\\nPlease give my solution an upvote! \\uD83D\\uDC4D\\nIt\\'s a simple way to show your appreciation and\\nkeep me motivated. Thank you! \\uD83D\\uDE0A\\n```\n```JS []\\nconst fibGenerator = () => {\\n  let current = 0;\\n  let next = 1;\\n\\n  return () => {\\n    const result = current;\\n    [current, next] = [next, current + next];\\n    return result;\\n  };\\n};\\n\\nconst gen = fibGenerator();\\nconsole.log(gen()); // 0\\nconsole.log(gen()); // 1\\n\\n```\n```JS []\\nconst fibGenerator = {\\n  [Symbol.iterator]: function*() {\\n    let current = 0;\\n    let next = 1;\\n\\n    while (true) {\\n      yield current;\\n      [current, next] = [next, current + next];\\n    }\\n  }\\n};\\n\\nconst gen = fibGenerator[Symbol.iterator]();\\nconsole.log(gen.next().value); // 0\\nconsole.log(gen.next().value); // 1\\n\\n```\n``` JS []\\nfunction* fibGenerator(current = 0, next = 1) {\\n  yield current;\\n  yield* fibGenerator(next, current + next);\\n}\\n\\nconst gen = fibGenerator();\\nconsole.log(gen.next().value); // 0\\nconsole.log(gen.next().value); // 1\\n\\n```\n``` JS []\\nconst fibGenerator = {\\n  current: 0,\\n  next: 1,\\n  nextNumber: function() {\\n    const result = this.current;\\n    [this.current, this.next] = [this.next, this.current + this.next];\\n    return result;\\n  }\\n};\\n\\nconsole.log(fibGenerator.nextNumber()); // 0\\nconsole.log(fibGenerator.nextNumber()); // 1\\n\\n```\n```\\nThanks for visiting my solution comment below if you like it.\\uD83D\\uDE0A\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3439825,
                "title": "yield-solution-with-comments",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @return {Generator<number>}\\n */\\nvar fibGenerator = function*() {\\n    // initialise first 2 sequence numbers\\n    // initialise a loop so that function can return values indefinitely when called\\n    // yield pauses fx execution and returns value, before continuing subsequent steps\\n    // fibonacci sequence is updated in steps after yield\\n        // note: \\n            // third term is the sum of first and second term\\n            // therefore: n term is sum of n-1 term + n-2 term\\n    let a = 0;\\n    let b = 1;\\n\\n    while (true){\\n        yield a;\\n        [a,b] = [b,a+b];\\n    }\\n\\n};\\n\\n/**\\n * const gen = fibGenerator();\\n * gen.next().value; // 0\\n * gen.next().value; // 1\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @return {Generator<number>}\\n */\\nvar fibGenerator = function*() {\\n    // initialise first 2 sequence numbers\\n    // initialise a loop so that function can return values indefinitely when called\\n    // yield pauses fx execution and returns value, before continuing subsequent steps\\n    // fibonacci sequence is updated in steps after yield\\n        // note: \\n            // third term is the sum of first and second term\\n            // therefore: n term is sum of n-1 term + n-2 term\\n    let a = 0;\\n    let b = 1;\\n\\n    while (true){\\n        yield a;\\n        [a,b] = [b,a+b];\\n    }\\n\\n};\\n\\n/**\\n * const gen = fibGenerator();\\n * gen.next().value; // 0\\n * gen.next().value; // 1\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3588028,
                "title": "mastering-generator-functions-learn-with-exciting-examples-beginner-friendly-js-ts",
                "content": "# Generator functions \\uD83D\\uDE80\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n##### Generator functions are a special type of function in JavaScript that can be paused and resumed during execution. \\nYes, you heard it right, these functions can be magically paused during execution and can be resumed later. \\uD83E\\uDE84\\nThey allow you to generate a sequence of values on-the-fly instead of computing and storing them all at once. Here\\'s a simple example to help illustrate the concept:\\n\\n```\\nfunction* countToThree() {\\n  yield 1;\\n  yield 2;\\n  yield 3;\\n}\\n\\nconst generator = countToThree(); // Creating a generator object\\n\\nconsole.log(generator.next().value); // 1\\nconsole.log(generator.next().value); // 2\\nconsole.log(generator.next().value); // 3\\n```\\n\\n- We can then use the `next()` method on the generator object to get the next value in the sequence.\\n- The `value` property of the returned object gives us the yielded value.\\n\\n# Real-life implementations of generator functions can be found in various scenarios, such as:\\n\\n- **Iterating over large or infinite data sets:** Generator functions can be used to iterate over data that is too large to fit in memory all at once. Instead of loading the entire dataset into memory, you can generate and process the data one piece at a time, saving memory resources.\\n- **Asynchronous programming:** Generators can be combined with asynchronous operations to simplify asynchronous code. By using yield with promises or async/await syntax, you can write asynchronous code that looks more like synchronous code, making it easier to understand and maintain.\\n- **Parsing and tokenization:** Generator functions can be used in parsing or tokenization tasks. They can generate a sequence of tokens or parsed elements as needed, allowing you to process large streams of data efficiently.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n1. Define a generator function `fibGenerator`.\\n2. Initialize `current` to 0 and `next` to 1.\\n3. Use a loop to iterate `callCount` times.\\n    - Yield `next`.\\n    - Calculate the next Fibonacci number: `temp = current + next`, `current = next`, `next = temp`.\\n4. Return or yield any remaining Fibonacci numbers.\\n\\n\\n# Complexity\\n- Time complexity: $$O(n)$$ (linear time) where `n` is the number of times the generator function is called.\\n\\n- Space complexity: $$O(1)$$ (constant space)\\n\\n<img src=\"https://assets.leetcode.com/users/images/b93dcc50-7e19-44d3-80ec-c41558d719ba_1684043630.2104852.png\" width=\"50%\">\\n\\n\\n# Code\\n``` javascript []\\nvar fibGenerator = function*() {\\n\\n  let current = 0; \\n  let next = 1;\\n\\n  while (true) {\\n    yield current; \\n    let temp = current + next;\\n    current = next;\\n    next = temp;\\n  }\\n};\\n\\n/**\\n * const gen = fibGenerator();\\n * gen.next().value; // 0\\n * gen.next().value; // 1\\n */\\n```\\n\\n``` Typescript []\\nfunction* fibGenerator(): Generator<number, any, number> {\\n  let current = 0; \\n  let next = 1;\\n\\n  while (true) {\\n    yield current; \\n    // easier way to swap elements\\n    [current, next] = [next, current + next];\\n  }\\n};\\n\\n/**\\n * const gen = fibGenerator();\\n * gen.next().value; // 0\\n * gen.next().value; // 1\\n */\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "```\\nfunction* countToThree() {\\n  yield 1;\\n  yield 2;\\n  yield 3;\\n}\\n\\nconst generator = countToThree(); // Creating a generator object\\n\\nconsole.log(generator.next().value); // 1\\nconsole.log(generator.next().value); // 2\\nconsole.log(generator.next().value); // 3\\n```\n``` javascript []\\nvar fibGenerator = function*() {\\n\\n  let current = 0; \\n  let next = 1;\\n\\n  while (true) {\\n    yield current; \\n    let temp = current + next;\\n    current = next;\\n    next = temp;\\n  }\\n};\\n\\n/**\\n * const gen = fibGenerator();\\n * gen.next().value; // 0\\n * gen.next().value; // 1\\n */\\n```\n``` Typescript []\\nfunction* fibGenerator(): Generator<number, any, number> {\\n  let current = 0; \\n  let next = 1;\\n\\n  while (true) {\\n    yield current; \\n    // easier way to swap elements\\n    [current, next] = [next, current + next];\\n  }\\n};\\n\\n/**\\n * const gen = fibGenerator();\\n * gen.next().value; // 0\\n * gen.next().value; // 1\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3439599,
                "title": "the-best",
                "content": "```js\\nconst fibGenerator = function*() {\\n    let [a, b] = [0, 1]\\n    while (true) {\\n        yield a;\\n        [a, b] = [b, a + b]\\n    }\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```js\\nconst fibGenerator = function*() {\\n    let [a, b] = [0, 1]\\n    while (true) {\\n        yield a;\\n        [a, b] = [b, a + b]\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3439913,
                "title": "javascript-detailed-explanation",
                "content": "Here, fibGenerator is a generator function that produces an infinite sequence of Fibonacci numbers. Each time you call fibGenerator().next().value, it will return the next number in the sequence.\\n\\nThe * symbol is used to denote that this function is a generator function. It allows the function to use the yield keyword to pause the function\\'s execution and return a value to the caller.\\n\\n\\n# Code\\n```\\n/**\\n * @return {Generator<number>}\\n */\\nvar fibGenerator = function*() {\\n    var a=0, b=1\\n    yield a\\n    yield b\\n    while(true){\\n        var c= a+b\\n        yield c\\n        a=b\\n        b=c\\n    }\\n};\\n\\n/**\\n * const gen = fibGenerator();\\n * gen.next().value; // 0\\n * gen.next().value; // 1\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @return {Generator<number>}\\n */\\nvar fibGenerator = function*() {\\n    var a=0, b=1\\n    yield a\\n    yield b\\n    while(true){\\n        var c= a+b\\n        yield c\\n        a=b\\n        b=c\\n    }\\n};\\n\\n/**\\n * const gen = fibGenerator();\\n * gen.next().value; // 0\\n * gen.next().value; // 1\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3587777,
                "title": "java-script-solution-for-generate-fibonacci-sequence-problem",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe intuition behind the fibGenerator function is to generate the Fibonacci sequence using a generator.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nIt follows the approach of calculating the Fibonacci numbers iteratively by keeping track of the previous and current values. The function yields the Fibonacci numbers one by one as it is called\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nThe time complexity of the solution is O(n), where n is the number of Fibonacci numbers to be generated. The loop runs for n iterations, and in each iteration, a constant amount of work is done to calculate the next Fibonacci number.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nThe space complexity of the solution is O(1) because it only requires a constant amount of additional space to store the previous and current values.\\n\\n# Code\\n```\\n/**\\n * @return {Generator<number>}\\n */\\nvar fibGenerator = function*() {\\n  let prev = 0;\\n  let curr = 1;\\n\\n  yield prev; // Yield the initial value 0\\n  yield curr; // Yield the initial value 1\\n\\n  for (let i = 2; i <= 50; i++) {\\n    const next = prev + curr;\\n    yield next; // Yield the next Fibonacci number\\n    prev = curr;\\n    curr = next;\\n  }\\n};\\n\\n/**\\n * const gen = fibGenerator();\\n * gen.next().value; // 0\\n * gen.next().value; // 1\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @return {Generator<number>}\\n */\\nvar fibGenerator = function*() {\\n  let prev = 0;\\n  let curr = 1;\\n\\n  yield prev; // Yield the initial value 0\\n  yield curr; // Yield the initial value 1\\n\\n  for (let i = 2; i <= 50; i++) {\\n    const next = prev + curr;\\n    yield next; // Yield the next Fibonacci number\\n    prev = curr;\\n    curr = next;\\n  }\\n};\\n\\n/**\\n * const gen = fibGenerator();\\n * gen.next().value; // 0\\n * gen.next().value; // 1\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3453650,
                "title": "easy-recursive-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @return {Generator<number>}\\n */\\nvar fibGenerator = function*(a = 0, b=1) {\\n    yield a;\\n    yield* fibGenerator(b, a+b);\\n};\\n\\n/**\\n * const gen = fibGenerator();\\n * gen.next().value; // 0\\n * gen.next().value; // 1\\n */\\n\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Recursion"
                ],
                "code": "```\\n/**\\n * @return {Generator<number>}\\n */\\nvar fibGenerator = function*(a = 0, b=1) {\\n    yield a;\\n    yield* fibGenerator(b, a+b);\\n};\\n\\n/**\\n * const gen = fibGenerator();\\n * gen.next().value; // 0\\n * gen.next().value; // 1\\n */\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3439492,
                "title": "typescript-solution",
                "content": "For simplicity\\'s sake, we hardcode the first two `yield` values for `fib(0)` and `fib(1)`, then after that we use a loop to generate Fibonacci numbers as usual. Space complexity is O(1), and time complexity is O(1) per `next()` call.\\n\\n```typescript\\nfunction* fibGenerator(): Generator<number, any, number> {\\n    // fib(0) === 0\\n    yield 0;\\n    // fib(1) === 1\\n    yield 1;\\n    \\n    let a: number = 0;\\n    let b: number = 1;\\n    \\n    while (true) {\\n        const c: number = a + b;\\n        a = b;\\n        b = c;\\n        yield c;\\n    }\\n};\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```typescript\\nfunction* fibGenerator(): Generator<number, any, number> {\\n    // fib(0) === 0\\n    yield 0;\\n    // fib(1) === 1\\n    yield 1;\\n    \\n    let a: number = 0;\\n    let b: number = 1;\\n    \\n    while (true) {\\n        const c: number = a + b;\\n        a = b;\\n        b = c;\\n        yield c;\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3587979,
                "title": "fibonacci-generator-yield-dp",
                "content": "We define a generator function that yields the Fibonacci sequence. \\n\\nIt initializes an array with the first two Fibonacci numbers, `0` and `1`, and yields them. \\n\\nInside an infinite loop, it calculates the next Fibonacci number by adding the previous two numbers from the array and yields it. The array is then updated with the new values, shifting them to the left. \\n\\nBy reusing the previously calculated numbers, we avoid redundant calculations and improves performance. When the generator is called, it generates Fibonacci numbers lazily on-demand, allowing for efficient memory usage and flexibility.\\n\\n# Code\\n```\\n/**\\n * @return {Generator<number>}\\n */\\nvar fibGenerator = function*() {\\n  let fib = [0, 1];\\n\\n  yield fib[0];\\n  yield fib[1];\\n\\n  while (true) {\\n    let next = fib[0] + fib[1];\\n    yield next;\\n    fib[0] = fib[1];\\n    fib[1] = next;\\n  }\\n};\\n\\n\\n/**\\n * const gen = fibGenerator();\\n * gen.next().value; // 0\\n * gen.next().value; // 1\\n */\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Dynamic Programming"
                ],
                "code": "```\\n/**\\n * @return {Generator<number>}\\n */\\nvar fibGenerator = function*() {\\n  let fib = [0, 1];\\n\\n  yield fib[0];\\n  yield fib[1];\\n\\n  while (true) {\\n    let next = fib[0] + fib[1];\\n    yield next;\\n    fib[0] = fib[1];\\n    fib[1] = next;\\n  }\\n};\\n\\n\\n/**\\n * const gen = fibGenerator();\\n * gen.next().value; // 0\\n * gen.next().value; // 1\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3533474,
                "title": "very-simple-and-easy-solution-in-javascript-wow-super-one-thanks-myself",
                "content": "\\n# Code\\n```\\n/**\\n * @return {Generator<number>}\\n */\\nvar fibGenerator = function*() {\\n    let a = 0, b = 1\\n    yield 0\\n    yield 1\\n    while(true) {\\n        [a,b] = [b, a + b]\\n        yield b\\n    }\\n};\\n\\n/**\\n * const gen = fibGenerator();\\n * gen.next().value; // 0\\n * gen.next().value; // 1\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @return {Generator<number>}\\n */\\nvar fibGenerator = function*() {\\n    let a = 0, b = 1\\n    yield 0\\n    yield 1\\n    while(true) {\\n        [a,b] = [b, a + b]\\n        yield b\\n    }\\n};\\n\\n/**\\n * const gen = fibGenerator();\\n * gen.next().value; // 0\\n * gen.next().value; // 1\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3446097,
                "title": "javascript-solution",
                "content": "\\n```\\n/**\\n * @return {Generator<number>}\\n */\\nvar fibGenerator = function*() {\\n    var x=0,y=1\\n    yield x\\n    yield y\\n    while(true){\\n        var z=x+y\\n        yield z\\n        x=y\\n        y=z\\n    }\\n    \\n};\\n\\n/**\\n * const gen = fibGenerator();\\n * gen.next().value; // 0\\n * gen.next().value; // 1\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @return {Generator<number>}\\n */\\nvar fibGenerator = function*() {\\n    var x=0,y=1\\n    yield x\\n    yield y\\n    while(true){\\n        var z=x+y\\n        yield z\\n        x=y\\n        y=z\\n    }\\n    \\n};\\n\\n/**\\n * const gen = fibGenerator();\\n * gen.next().value; // 0\\n * gen.next().value; // 1\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3587998,
                "title": "understand-generator-function-with-the-help-of-example",
                "content": "What is actually generators ?\\n\\nIn javascript generators are the functions which have special functionality, they can pause and resume during execution. (We define generator function with the help of special syntax , `function * generatorFunctionName() { }`)\\n\\nUnderstand with the help of example -\\n```\\nfunction* generatorFunction() {\\n  console.log(\\'Execution started\\');\\n  yield 1;\\n  console.log(\\'After first yield\\');\\n  yield 2;\\n  console.log(\\'After second yield\\');\\n  yield 3;\\n  console.log(\\'Execution completed\\');\\n}\\n\\nconst generator = generatorFunction(); // Creating an instance of the generator\\n\\nconsole.log(generator.next()); // Output: { value: 1, done: false }\\nconsole.log(generator.next()); // Output: { value: 2, done: false }\\nconsole.log(generator.next()); // Output: { value: 3, done: false }\\nconsole.log(generator.next()); // Output: { value: undefined, done: true }\\n```\\nWhen we call `generatorFunction()` it will not execute the function, instead of this it will return a generator object, which have `next` method, by calling next method we can resume the execution of generator.\\nWhen function see yield in function it will stop the execution and return the object which have to fields which store the yield value and done state of the function.\\n\\nWe can say we use next method to resume the execution of generator function and use yield keyword to pause the execution.\\n# Code\\n```\\nvar fibGenerator = function*() {\\n    let a = 0;\\n    yield a;\\n    let b = 1;\\n    yield b;\\n    while(true){\\n        const fibNumber = a + b;\\n        a = b;\\n        b = fibNumber;\\n        yield fibNumber;\\n    }\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nfunction* generatorFunction() {\\n  console.log(\\'Execution started\\');\\n  yield 1;\\n  console.log(\\'After first yield\\');\\n  yield 2;\\n  console.log(\\'After second yield\\');\\n  yield 3;\\n  console.log(\\'Execution completed\\');\\n}\\n\\nconst generator = generatorFunction(); // Creating an instance of the generator\\n\\nconsole.log(generator.next()); // Output: { value: 1, done: false }\\nconsole.log(generator.next()); // Output: { value: 2, done: false }\\nconsole.log(generator.next()); // Output: { value: 3, done: false }\\nconsole.log(generator.next()); // Output: { value: undefined, done: true }\\n```\n```\\nvar fibGenerator = function*() {\\n    let a = 0;\\n    yield a;\\n    let b = 1;\\n    yield b;\\n    while(true){\\n        const fibNumber = a + b;\\n        a = b;\\n        b = fibNumber;\\n        yield fibNumber;\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3587957,
                "title": "easy-solutions",
                "content": "**Javascript Solution**\\n```\\n/**\\n * @return {Generator<number>}\\n */\\nvar fibGenerator = function*() {\\n\\n    let prev1 = 0, prev2 = 1;\\n\\n    while (true) {\\n      yield prev1;\\n      [prev1, prev2] = [prev2, prev1+prev2];\\n    }\\n\\n};\\n/**\\n * const gen = fibGenerator();\\n * gen.next().value; // 0\\n * gen.next().value; // 1\\n */\\n```\\n**Typescript Solution**\\n```\\nfunction* fibGenerator(): Generator<number, any, number> {\\n     let prev1:number = 0, prev2:number = 1;\\n\\n        while (true) {\\n          yield prev1;\\n          [prev1, prev2] = [prev2, prev1+prev2];\\n        }\\n};\\n\\n/**\\n * const gen = fibGenerator();\\n * gen.next().value; // 0\\n * gen.next().value; // 1\\n */\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "```\\n/**\\n * @return {Generator<number>}\\n */\\nvar fibGenerator = function*() {\\n\\n    let prev1 = 0, prev2 = 1;\\n\\n    while (true) {\\n      yield prev1;\\n      [prev1, prev2] = [prev2, prev1+prev2];\\n    }\\n\\n};\\n/**\\n * const gen = fibGenerator();\\n * gen.next().value; // 0\\n * gen.next().value; // 1\\n */\\n```\n```\\nfunction* fibGenerator(): Generator<number, any, number> {\\n     let prev1:number = 0, prev2:number = 1;\\n\\n        while (true) {\\n          yield prev1;\\n          [prev1, prev2] = [prev2, prev1+prev2];\\n        }\\n};\\n\\n/**\\n * const gen = fibGenerator();\\n * gen.next().value; // 0\\n * gen.next().value; // 1\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3587673,
                "title": "javascript-yield-easy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @return {Generator<number>}\\n */\\nvar fibGenerator = function*() {\\n\\n    let prev1 = 0;\\n    let prev2 = 1;\\n\\n    while (true) {\\n      yield prev1;\\n      [prev1, prev2] = [prev2, prev1+prev2];\\n    }\\n\\n};\\n\\n/**\\n * const gen = fibGenerator();\\n * gen.next().value; // 0\\n * gen.next().value; // 1\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @return {Generator<number>}\\n */\\nvar fibGenerator = function*() {\\n\\n    let prev1 = 0;\\n    let prev2 = 1;\\n\\n    while (true) {\\n      yield prev1;\\n      [prev1, prev2] = [prev2, prev1+prev2];\\n    }\\n\\n};\\n\\n/**\\n * const gen = fibGenerator();\\n * gen.next().value; // 0\\n * gen.next().value; // 1\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3577700,
                "title": "full-simple-explanation-beginner-friendly-introduction",
                "content": "# Approach\\nGenerator functions (indicated by the ```*``` in ```function*()```) is a function that allows you to iterate throughout code in a function to return different values by calling the same function. While this can be done with regular functions, the conveinent thing with generator functions is they allow you to use the keyword ```yield```, which allows you to stop in the middle of the code and return a value, then when you come back to the function with another call, you pick up where you left off. We can do this using the ```.next().value``` method call, which generator functions automatically have.\\n1. Initialize the first two numbers in the Fibonacci sequence with ```a = 0``` and ```b = 1```, of which ```a``` will always be smaller than ```b```.\\n2. Yield value a and value b in succession. When you make the first ```.next().value``` call, it will run into ```yield a``` and return 0, and on the second call will pick off from the ```yield a``` line, run into the ```yield b``` line, and return 1.\\n3. Make a forever running while loop, so we can generate as many numbers in the sequence as we\\'d like. In this sequence, we set ```c``` to ```a + b```, and yield the value ```c```. After the ```yield c``` line, set ```a = b``` and ```b = c```, for the next iteration of calculating ```c```.\\n\\n# Code\\n```\\nvar fibGenerator = function*() {\\n    let a = 0;\\n    let b = 1;\\n    yield a; // first call returns 0\\n    yield b; // second call returns 1\\n\\n    let c;\\n    while (true) { // third call and after enters this loop\\n        c = a + b; // calculate c for current call\\n        yield c; // return c\\n\\n        // when another call is made, set a and b to next iteration to calculate next c value\\n        a = b;\\n        b = c;\\n    }\\n};\\n```\\nUPVOTE if this was helpful \\uD83C\\uDF5E\\uD83C\\uDF5E\\uD83C\\uDF5E",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```*```\n```function*()```\n```yield```\n```.next().value```\n```a = 0```\n```b = 1```\n```a```\n```b```\n```.next().value```\n```yield a```\n```yield a```\n```yield b```\n```c```\n```a + b```\n```c```\n```yield c```\n```a = b```\n```b = c```\n```c```\n```\\nvar fibGenerator = function*() {\\n    let a = 0;\\n    let b = 1;\\n    yield a; // first call returns 0\\n    yield b; // second call returns 1\\n\\n    let c;\\n    while (true) { // third call and after enters this loop\\n        c = a + b; // calculate c for current call\\n        yield c; // return c\\n\\n        // when another call is made, set a and b to next iteration to calculate next c value\\n        a = b;\\n        b = c;\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3457399,
                "title": "my-fibgenerator",
                "content": "<!-- # Intuition -->\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n<!-- # Approach -->\\n<!-- Describe your approach to solving the problem. -->\\n\\n<!-- # Complexity\\n- Time complexity: -->\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n<!-- - Space complexity: -->\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @return {Generator<number>}\\n */\\nvar fibGenerator = function* () {\\n  let count = 0;\\n  let a = 0;\\n  let b = 1;\\n  \\n  while (true) {\\n    if (count === 0) {\\n      yield a;\\n      count++;\\n    } else if (count === 1) {\\n      yield b;\\n      count++;\\n    } else {\\n      yield a + b;\\n      const sum = a + b;\\n      a = b;\\n      b = sum;\\n    }\\n  }\\n};\\n\\n/**\\n * const gen = fibGenerator();\\n * gen.next().value; // 0\\n * gen.next().value; // 1\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @return {Generator<number>}\\n */\\nvar fibGenerator = function* () {\\n  let count = 0;\\n  let a = 0;\\n  let b = 1;\\n  \\n  while (true) {\\n    if (count === 0) {\\n      yield a;\\n      count++;\\n    } else if (count === 1) {\\n      yield b;\\n      count++;\\n    } else {\\n      yield a + b;\\n      const sum = a + b;\\n      a = b;\\n      b = sum;\\n    }\\n  }\\n};\\n\\n/**\\n * const gen = fibGenerator();\\n * gen.next().value; // 0\\n * gen.next().value; // 1\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3451942,
                "title": "one-line-two-variables-without-destructuring-assignment",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIt\\'s like swapping two variables tricks.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(1)$$\\n\\n---\\n* You could find some other extraordinary solutions in my [profile](https://leetcode.com/almostmonday/) on the Solutions tab (I don\\'t post obvious or not interesting solutions at all.)\\n* If this was helpful, please upvote so that others can see this solution too.\\n---\\n\\n# Code\\n```\\nvar fibGenerator = function*() {\\n    for (let a = 0, b = 1; true; b += a, a = b - a) yield a;\\n};\\n\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Math"
                ],
                "code": "```\\nvar fibGenerator = function*() {\\n    for (let a = 0, b = 1; true; b += a, a = b - a) yield a;\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3442514,
                "title": "javascript-solution-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @return {Generator<number>}\\n */\\nvar fibGenerator = function*() {\\n  let a1=0, a2=1;\\n  let next;\\n  while(true){\\n      next = a1+a2;\\n      yield a1;\\n      a1 = a2;\\n      a2 = next;\\n  }\\n\\n};\\n\\n/**\\n * const gen = fibGenerator();\\n * gen.next().value; // 0\\n * gen.next().value; // 1\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @return {Generator<number>}\\n */\\nvar fibGenerator = function*() {\\n  let a1=0, a2=1;\\n  let next;\\n  while(true){\\n      next = a1+a2;\\n      yield a1;\\n      a1 = a2;\\n      a2 = next;\\n  }\\n\\n};\\n\\n/**\\n * const gen = fibGenerator();\\n * gen.next().value; // 0\\n * gen.next().value; // 1\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3588377,
                "title": "typescript-solution",
                "content": "```\\nfunction* fibGenerator(): Generator<number> {\\n    let a = 0, b = 1\\n    \\n    while (true) {\\n        yield a;\\n        [a, b] = [b, a+b]\\n    }\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "```\\nfunction* fibGenerator(): Generator<number> {\\n    let a = 0, b = 1\\n    \\n    while (true) {\\n        yield a;\\n        [a, b] = [b, a+b]\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3565242,
                "title": "easy-solution",
                "content": "# Code\\n```\\n/**\\n * @return {Generator<number>}\\n */\\nvar fibGenerator = function*() {\\n  let pre = -1, cur = 1;\\n\\n  while (true) {\\n    yield pre + cur;\\n    let temp = pre + cur\\n    pre = cur;\\n    cur = temp\\n  }\\n\\n};\\n\\n/**\\n * const gen = fibGenerator();\\n * gen.next().value; // 0\\n * gen.next().value; // 1\\n */\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @return {Generator<number>}\\n */\\nvar fibGenerator = function*() {\\n  let pre = -1, cur = 1;\\n\\n  while (true) {\\n    yield pre + cur;\\n    let temp = pre + cur\\n    pre = cur;\\n    cur = temp\\n  }\\n\\n};\\n\\n/**\\n * const gen = fibGenerator();\\n * gen.next().value; // 0\\n * gen.next().value; // 1\\n */\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3536119,
                "title": "simple-js-solution-following-the-hints",
                "content": "# Code\\n```\\n/**\\n * @return {Generator<number>}\\n */\\nvar fibGenerator = function*() {\\n    yield 0\\n    yield 1\\n    let vals = [0, 1]\\n    while (true) {\\n        vals.push(vals[vals.length -1] + vals[vals.length -2])\\n        yield vals[vals.length - 1]\\n    }\\n\\n};\\n\\n/**\\n * const gen = fibGenerator();\\n * gen.next().value; // 0\\n * gen.next().value; // 1\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @return {Generator<number>}\\n */\\nvar fibGenerator = function*() {\\n    yield 0\\n    yield 1\\n    let vals = [0, 1]\\n    while (true) {\\n        vals.push(vals[vals.length -1] + vals[vals.length -2])\\n        yield vals[vals.length - 1]\\n    }\\n\\n};\\n\\n/**\\n * const gen = fibGenerator();\\n * gen.next().value; // 0\\n * gen.next().value; // 1\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3445298,
                "title": "simple-recursive-solution",
                "content": "```javascript\\nvar fibGenerator = function*(a=0,b=1) {\\nyield* [a,b];\\nyield* fibGenerator(a+b, a+2*b);\\n};\\n```",
                "solutionTags": [
                    "Recursion"
                ],
                "code": "```javascript\\nvar fibGenerator = function*(a=0,b=1) {\\nyield* [a,b];\\nyield* fibGenerator(a+b, a+2*b);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4085263,
                "title": "js-abc",
                "content": "\\n\\n# Code\\n```\\n/**\\n * @return {Generator<number>}\\n */\\nvar fibGenerator = function*() {\\n    let a = 0, b = 1, c;\\n    while(true){\\n        yield a;\\n        c = a+b;\\n        a = b;\\n        b = c;\\n    }\\n};\\n\\n/**\\n * const gen = fibGenerator();\\n * gen.next().value; // 0\\n * gen.next().value; // 1\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @return {Generator<number>}\\n */\\nvar fibGenerator = function*() {\\n    let a = 0, b = 1, c;\\n    while(true){\\n        yield a;\\n        c = a+b;\\n        a = b;\\n        b = c;\\n    }\\n};\\n\\n/**\\n * const gen = fibGenerator();\\n * gen.next().value; // 0\\n * gen.next().value; // 1\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4074485,
                "title": "simple-but-powerful-solution-beats-over-87-of-users-at-runtime-and-over-99-of-users-at-memory",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nbased on array records not variables and yield the current record array[i]\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nsimple array.push() method with loop statement \\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\ntook me about 3 minutes to figure out which path i approach\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n\\n# Code\\n```\\n/**\\n * @return {Generator<number>}\\n */\\nvar fibGenerator = function*() {\\n    let arr=[];\\n    for(i=0;i<=100;i++){\\n        if(i<=1){\\n        arr.push(i);\\n        yield arr[i];\\n        }else{\\n        arr.push(arr[i-1]+arr[i-2]);\\n        yield arr[i];\\n        }\\n    }\\n};\\n\\n/**\\n * const gen = fibGenerator();\\n * gen.next().value; // 0\\n * gen.next().value; // 1\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @return {Generator<number>}\\n */\\nvar fibGenerator = function*() {\\n    let arr=[];\\n    for(i=0;i<=100;i++){\\n        if(i<=1){\\n        arr.push(i);\\n        yield arr[i];\\n        }else{\\n        arr.push(arr[i-1]+arr[i-2]);\\n        yield arr[i];\\n        }\\n    }\\n};\\n\\n/**\\n * const gen = fibGenerator();\\n * gen.next().value; // 0\\n * gen.next().value; // 1\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4070085,
                "title": "using-yield",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @return {Generator<number>}\\n */\\nvar fibGenerator = function*() {\\n    let i=0, j=1;\\n    yield i;\\n    yield j;\\n    while(true){\\n        yield i+j;\\n        let temp = i;\\n        i = j;\\n        j = temp+j;\\n    }\\n};\\n\\n/**\\n * const gen = fibGenerator();\\n * gen.next().value; // 0\\n * gen.next().value; // 1\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @return {Generator<number>}\\n */\\nvar fibGenerator = function*() {\\n    let i=0, j=1;\\n    yield i;\\n    yield j;\\n    while(true){\\n        yield i+j;\\n        let temp = i;\\n        i = j;\\n        j = temp+j;\\n    }\\n};\\n\\n/**\\n * const gen = fibGenerator();\\n * gen.next().value; // 0\\n * gen.next().value; // 1\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4069990,
                "title": "easy-js-solution-yield",
                "content": "# Refernces\\n- [function* and yield](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/function*)\\n- [Fibonacci sequence in JS](https://www.programiz.com/javascript/examples/fibonacci-series)\\n# Code\\n```\\n/**\\n * @return {Generator<number>}\\n */\\nvar fibGenerator = function*() {\\n    let n1 = 0, n2 = 1, nextNum;\\n    while(true){\\n        yield n1\\n        nextNum = n1 + n2 \\n        n1 = n2\\n        n2 = nextNum\\n    }\\n};\\n\\n\\n```\\n# VOTE UP! PLS\\uD83E\\uDD7A\\n![Vote up.jpg](https://assets.leetcode.com/users/images/7f0308f7-724d-4bea-bd2e-713788159bd5_1695239026.7445886.jpeg)\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @return {Generator<number>}\\n */\\nvar fibGenerator = function*() {\\n    let n1 = 0, n2 = 1, nextNum;\\n    while(true){\\n        yield n1\\n        nextNum = n1 + n2 \\n        n1 = n2\\n        n2 = nextNum\\n    }\\n};\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4066203,
                "title": "simple-c-solution",
                "content": "# Code\\n```\\n/**\\n * @return {Generator<number>}\\n */\\nvar fibGenerator = function*() {\\n  yield 0;\\n  yield 1;\\n  let n1 = 0, n2 = 1;\\n    while(true)\\n    {\\n      let n = n1 + n2;\\n      n1 = n2;\\n      n2 = n;\\n      yield n;\\n    }\\n};\\n\\n/**\\n * const gen = fibGenerator();\\n * gen.next().value; // 0\\n * gen.next().value; // 1\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @return {Generator<number>}\\n */\\nvar fibGenerator = function*() {\\n  yield 0;\\n  yield 1;\\n  let n1 = 0, n2 = 1;\\n    while(true)\\n    {\\n      let n = n1 + n2;\\n      n1 = n2;\\n      n2 = n;\\n      yield n;\\n    }\\n};\\n\\n/**\\n * const gen = fibGenerator();\\n * gen.next().value; // 0\\n * gen.next().value; // 1\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4057548,
                "title": "easy-js-solution",
                "content": "# 2648. Generate Fibonacci Sequence\\n\\n## Code\\n```\\nvar fibGenerator = function*() {\\n    let f = [0, 1];\\n    while (true) {\\n        yield f[0];\\n        f = [f[1], f[0]+f[1]];        \\n    }\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar fibGenerator = function*() {\\n    let f = [0, 1];\\n    while (true) {\\n        yield f[0];\\n        f = [f[1], f[0]+f[1]];        \\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4054460,
                "title": "js-easy-solution",
                "content": "# Code\\n```\\n/**\\n * @return {Generator<number>}\\n */\\nvar fibGenerator = function*() {\\n    let current = 0\\n    let next = 1\\n\\n    while (true) {\\n        yield current\\n        let temp = current + next\\n        current = next\\n        next = temp\\n    }\\n};\\n\\n/**\\n * const gen = fibGenerator();\\n * gen.next().value; // 0\\n * gen.next().value; // 1\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @return {Generator<number>}\\n */\\nvar fibGenerator = function*() {\\n    let current = 0\\n    let next = 1\\n\\n    while (true) {\\n        yield current\\n        let temp = current + next\\n        current = next\\n        next = temp\\n    }\\n};\\n\\n/**\\n * const gen = fibGenerator();\\n * gen.next().value; // 0\\n * gen.next().value; // 1\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4050558,
                "title": "simple-solution-with-array-loop-beats-94-93-of-javascrip",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @return {Generator<number>}\\n */\\n\\n\\nvar fibGenerator = function* ()\\n{\\n    let arr = [];\\n    arr.push(0);\\n    for(let i = 1 ; i <= 50; i ++)\\n    {\\n        if(arr.length === 1) arr.push(i);\\n            arr.push(arr[i-1] + arr[i]);\\n    }\\n    let count = 0;\\n    while(true)\\n    {\\n        yield arr[count++];\\n    }\\n\\n}\\n\\n/**\\n * const gen = fibGenerator();\\n * gen.next().value; // 0\\n * gen.next().value; // 1\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @return {Generator<number>}\\n */\\n\\n\\nvar fibGenerator = function* ()\\n{\\n    let arr = [];\\n    arr.push(0);\\n    for(let i = 1 ; i <= 50; i ++)\\n    {\\n        if(arr.length === 1) arr.push(i);\\n            arr.push(arr[i-1] + arr[i]);\\n    }\\n    let count = 0;\\n    while(true)\\n    {\\n        yield arr[count++];\\n    }\\n\\n}\\n\\n/**\\n * const gen = fibGenerator();\\n * gen.next().value; // 0\\n * gen.next().value; // 1\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4027214,
                "title": "simple-js-ts-method",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nfunction* fibGenerator(): Generator<number, any, number> {\\n    let firstNum = 0;\\n    let secondNum = 1;\\n    while (true) {\\n        yield firstNum;\\n        [firstNum, secondNum] = [secondNum, firstNum+secondNum];\\n    }\\n}\\n\\n/**\\n * const gen = fibGenerator();\\n * gen.next().value; // 0\\n * gen.next().value; // 1\\n */\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\nfunction* fibGenerator(): Generator<number, any, number> {\\n    let firstNum = 0;\\n    let secondNum = 1;\\n    while (true) {\\n        yield firstNum;\\n        [firstNum, secondNum] = [secondNum, firstNum+secondNum];\\n    }\\n}\\n\\n/**\\n * const gen = fibGenerator();\\n * gen.next().value; // 0\\n * gen.next().value; // 1\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4013156,
                "title": "javascript-very-simple-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @return {Generator<number>}\\n */\\nfunction* fibGenerator() {\\n    let prev = 0;\\n    let current = 1;\\n\\n    for (let i = 0; i < 50; i++) {\\n        yield prev;\\n        const next = prev + current;\\n        prev = current;\\n        current = next;\\n    }\\n}\\n\\n/**\\n * const gen = fibGenerator();\\n * gen.next().value; // 0\\n * gen.next().value; // 1\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @return {Generator<number>}\\n */\\nfunction* fibGenerator() {\\n    let prev = 0;\\n    let current = 1;\\n\\n    for (let i = 0; i < 50; i++) {\\n        yield prev;\\n        const next = prev + current;\\n        prev = current;\\n        current = next;\\n    }\\n}\\n\\n/**\\n * const gen = fibGenerator();\\n * gen.next().value; // 0\\n * gen.next().value; // 1\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4012623,
                "title": "fibonacci-sequence-generator-in-js",
                "content": "\\n\\n# Code\\n```\\n/**\\n * @return {Generator<number>}\\n */\\nvar fibGenerator = function*() {\\n    let i = 0, j = 1, k = 2;\\n    yield i;\\n    yield j;\\n    while (true) {\\n        k = i + j;\\n        yield k;\\n        i = j;\\n        j = k;\\n    }\\n};\\n\\n/**\\n * const gen = fibGenerator();\\n * gen.next().value; // 0\\n * gen.next().value; // 1\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @return {Generator<number>}\\n */\\nvar fibGenerator = function*() {\\n    let i = 0, j = 1, k = 2;\\n    yield i;\\n    yield j;\\n    while (true) {\\n        k = i + j;\\n        yield k;\\n        i = j;\\n        j = k;\\n    }\\n};\\n\\n/**\\n * const gen = fibGenerator();\\n * gen.next().value; // 0\\n * gen.next().value; // 1\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4011788,
                "title": "fibonacci-sequence-using-yield-keyword",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @return {Generator<number>}\\n */\\nvar fibGenerator = function*() {\\n   let fib=[0,1];\\n   yield fib[0];\\n   yield fib[1];\\n   while(1)\\n   {\\n        let next =fib[0]+fib[1];\\n        yield next;\\n        fib[0]=fib[1];\\n        fib[1]= next;\\n   }\\n};\\n\\n/**\\n * const gen = fibGenerator();\\n * gen.next().value; // 0\\n * gen.next().value; // 1\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @return {Generator<number>}\\n */\\nvar fibGenerator = function*() {\\n   let fib=[0,1];\\n   yield fib[0];\\n   yield fib[1];\\n   while(1)\\n   {\\n        let next =fib[0]+fib[1];\\n        yield next;\\n        fib[0]=fib[1];\\n        fib[1]= next;\\n   }\\n};\\n\\n/**\\n * const gen = fibGenerator();\\n * gen.next().value; // 0\\n * gen.next().value; // 1\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3978836,
                "title": "easy-approach",
                "content": "\\n\\n# Code\\n```\\nfunction* fibGenerator(): Generator<number, any, number> {\\n    let a=0,b=1;\\n    while(1){\\n        yield a;\\n        [a,b] = [b,a+b]\\n    }\\n};\\n\\n/**\\n * const gen = fibGenerator();\\n * gen.next().value; // 0\\n * gen.next().value; // 1\\n */\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "```\\nfunction* fibGenerator(): Generator<number, any, number> {\\n    let a=0,b=1;\\n    while(1){\\n        yield a;\\n        [a,b] = [b,a+b]\\n    }\\n};\\n\\n/**\\n * const gen = fibGenerator();\\n * gen.next().value; // 0\\n * gen.next().value; // 1\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3977023,
                "title": "titan",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @return {Generator<number>}\\n */\\nvar fibGenerator = function*() {\\n    let fib = [0, 1];\\n\\n  yield fib[0];\\n  yield fib[1];\\n\\n  while (true) {\\n    let next = fib[0] + fib[1];\\n    yield next;\\n    fib[0] = fib[1];\\n    fib[1] = next;\\n  }    \\n};\\n\\n/**\\n * const gen = fibGenerator();\\n * gen.next().value; // 0\\n * gen.next().value; // 1\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @return {Generator<number>}\\n */\\nvar fibGenerator = function*() {\\n    let fib = [0, 1];\\n\\n  yield fib[0];\\n  yield fib[1];\\n\\n  while (true) {\\n    let next = fib[0] + fib[1];\\n    yield next;\\n    fib[0] = fib[1];\\n    fib[1] = next;\\n  }    \\n};\\n\\n/**\\n * const gen = fibGenerator();\\n * gen.next().value; // 0\\n * gen.next().value; // 1\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3976322,
                "title": "2648-generate-fibonacci-sequence-using-yield-keyword",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @return {Generator<number>}\\n */  \\n\\n\\nvar fibGenerator = function* (callCount) {\\n  let current = 0; \\n  let next = 1;\\n\\n  while (true) {\\n    yield current; \\n\\n    [current, next] = [next, current + next];\\n\\n  } \\n};\\n\\n\\n/**\\n * const gen = fibGenerator();\\n * gen.next().value; // 0\\n * gen.next().value; // 1\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @return {Generator<number>}\\n */  \\n\\n\\nvar fibGenerator = function* (callCount) {\\n  let current = 0; \\n  let next = 1;\\n\\n  while (true) {\\n    yield current; \\n\\n    [current, next] = [next, current + next];\\n\\n  } \\n};\\n\\n\\n/**\\n * const gen = fibGenerator();\\n * gen.next().value; // 0\\n * gen.next().value; // 1\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3969920,
                "title": "easy-solution",
                "content": "# Intuition\\n\\n# Code\\n```\\n/**\\n * @return {Generator<number>}\\n */\\nvar fibGenerator = function*() {\\n    let [result,sum] = [0,1] //assign two variables for starting two numbers i.e 0,1\\n    while(true){\\n        yield result; // return the current result\\n        [result,sum]= [sum,result+sum] // then add the two preceeding to values to  get suceeding value\\n    }\\n    \\n};\\n\\n/**\\n * const gen = fibGenerator();\\n * gen.next().value; // 0\\n * gen.next().value; // 1\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @return {Generator<number>}\\n */\\nvar fibGenerator = function*() {\\n    let [result,sum] = [0,1] //assign two variables for starting two numbers i.e 0,1\\n    while(true){\\n        yield result; // return the current result\\n        [result,sum]= [sum,result+sum] // then add the two preceeding to values to  get suceeding value\\n    }\\n    \\n};\\n\\n/**\\n * const gen = fibGenerator();\\n * gen.next().value; // 0\\n * gen.next().value; // 1\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3962240,
                "title": "infinite-loop-solution",
                "content": "```\\n/**\\n * @return {Generator<number>}\\n */\\nconst fibGenerator = function*() {\\n    let prev = 0\\n    let curr = 1\\n\\n    while (true) {\\n        yield prev\\n        const next = prev + curr\\n        prev = curr\\n        curr = next\\n    }\\n};\\n\\n/**\\n * const gen = fibGenerator();\\n * gen.next().value; // 0\\n * gen.next().value; // 1\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @return {Generator<number>}\\n */\\nconst fibGenerator = function*() {\\n    let prev = 0\\n    let curr = 1\\n\\n    while (true) {\\n        yield prev\\n        const next = prev + curr\\n        prev = curr\\n        curr = next\\n    }\\n};\\n\\n/**\\n * const gen = fibGenerator();\\n * gen.next().value; // 0\\n * gen.next().value; // 1\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3959435,
                "title": "easy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nfunction* fibGenerator(): Generator<number, any, number> {\\n    let a=0\\n    let b=1\\n\\n    while(true){\\n        yield a\\n        let tmp=a\\n        a=b\\n        b+=tmp\\n    }\\n\\n};\\n\\n/**\\n * const gen = fibGenerator();\\n * gen.next().value; // 0\\n * gen.next().value; // 1\\n */\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\nfunction* fibGenerator(): Generator<number, any, number> {\\n    let a=0\\n    let b=1\\n\\n    while(true){\\n        yield a\\n        let tmp=a\\n        a=b\\n        b+=tmp\\n    }\\n\\n};\\n\\n/**\\n * const gen = fibGenerator();\\n * gen.next().value; // 0\\n * gen.next().value; // 1\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3951927,
                "title": "easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @return {Generator<number>}\\n */\\nvar fibGenerator = function* () {\\n  let count = 0;\\n  while (true) {\\n    const res = fib(count)\\n    count += 1;\\n    yield res\\n  }\\n};\\n\\nfunction fib(count) {\\n  if (count === 0) return 0;\\n  if (count === 1) return 1;\\n  let a = 0;\\n  let b = 1;\\n  for (let i = 2; i <= count; i++) {\\n    let c = a + b;\\n    a = b;\\n    b = c;\\n  }\\n  return b;\\n}\\n\\n\\n/**\\n * const gen = fibGenerator();\\n * gen.next().value; // 0\\n * gen.next().value; // 1\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @return {Generator<number>}\\n */\\nvar fibGenerator = function* () {\\n  let count = 0;\\n  while (true) {\\n    const res = fib(count)\\n    count += 1;\\n    yield res\\n  }\\n};\\n\\nfunction fib(count) {\\n  if (count === 0) return 0;\\n  if (count === 1) return 1;\\n  let a = 0;\\n  let b = 1;\\n  for (let i = 2; i <= count; i++) {\\n    let c = a + b;\\n    a = b;\\n    b = c;\\n  }\\n  return b;\\n}\\n\\n\\n/**\\n * const gen = fibGenerator();\\n * gen.next().value; // 0\\n * gen.next().value; // 1\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3939362,
                "title": "javascript-simple-solution-yield",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @return {Generator<number>}\\n */\\nvar fibGenerator = function*() {\\n    let a = 0;\\n    let b = 1;\\n\\n    while (true){\\n        yield a;\\n        [a,b] = [b,a+b];\\n    }\\n\\n};\\n\\n/**\\n * const gen = fibGenerator();\\n * gen.next().value; // 0\\n * gen.next().value; // 1\\n */\\n```\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @return {Generator<number>}\\n */\\nvar fibGenerator = function*() {\\n    let a = 0;\\n    let b = 1;\\n\\n    while (true){\\n        yield a;\\n        [a,b] = [b,a+b];\\n    }\\n\\n};\\n\\n/**\\n * const gen = fibGenerator();\\n * gen.next().value; // 0\\n * gen.next().value; // 1\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3923198,
                "title": "typescript-simple-solution-clean-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nfunction* fibGenerator(): Generator<number, any, number> {\\n    let prev = 0, curr = 1;\\n    while ( true ) {\\n        yield prev;\\n        curr = curr + prev;\\n        prev = curr - prev;\\n    }\\n};\\n\\n/**\\n * const gen = fibGenerator();\\n * gen.next().value; // 0\\n * gen.next().value; // 1\\n */\\n```",
                "solutionTags": [
                    "TypeScript",
                    "Math"
                ],
                "code": "```\\nfunction* fibGenerator(): Generator<number, any, number> {\\n    let prev = 0, curr = 1;\\n    while ( true ) {\\n        yield prev;\\n        curr = curr + prev;\\n        prev = curr - prev;\\n    }\\n};\\n\\n/**\\n * const gen = fibGenerator();\\n * gen.next().value; // 0\\n * gen.next().value; // 1\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3917108,
                "title": "easy-javascript-solution",
                "content": "> Vote Up If you Like it\\n\\n# Code\\n```\\n/**\\n * @return {Generator<number>}\\n */\\nvar fibGenerator = function*() {\\n    let prev=0\\n    let curr=1\\n    yield prev\\n    yield curr\\n    while(true){\\n        let next_val=prev+curr\\n        yield next_val\\n        prev=curr\\n        curr=next_val\\n    }\\n};\\n\\n/**\\n * const gen = fibGenerator();\\n * gen.next().value; // 0\\n * gen.next().value; // 1\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @return {Generator<number>}\\n */\\nvar fibGenerator = function*() {\\n    let prev=0\\n    let curr=1\\n    yield prev\\n    yield curr\\n    while(true){\\n        let next_val=prev+curr\\n        yield next_val\\n        prev=curr\\n        curr=next_val\\n    }\\n};\\n\\n/**\\n * const gen = fibGenerator();\\n * gen.next().value; // 0\\n * gen.next().value; // 1\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3900801,
                "title": "javascript-solution",
                "content": "\\n# Code\\n```\\n/**\\n * @return {Generator<number>}\\n */\\nvar fibGenerator = function*() {\\n    let a=0;\\n    yield a;\\n    let b=1;\\n    yield b;\\n    while(true){\\n        var c=a+b;\\n        yield c;\\n        a=b;\\n        b=c;\\n    }\\n    \\n};\\n\\n/**\\n * const gen = fibGenerator();\\n * gen.next().value; // 0\\n * gen.next().value; // 1\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @return {Generator<number>}\\n */\\nvar fibGenerator = function*() {\\n    let a=0;\\n    yield a;\\n    let b=1;\\n    yield b;\\n    while(true){\\n        var c=a+b;\\n        yield c;\\n        a=b;\\n        b=c;\\n    }\\n    \\n};\\n\\n/**\\n * const gen = fibGenerator();\\n * gen.next().value; // 0\\n * gen.next().value; // 1\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3897782,
                "title": "fibonacci-sequence-generator-using-generator-function",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe code is intended to generate the Fibonacci sequence using a generator function. The Fibonacci sequence is a series of numbers where each number is the sum of the two preceding ones, usually starting with 0 and 1. The intuition behind the code is to use a generator to create an iterable sequence of Fibonacci numbers.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe code defines a generator function named fibGenerator. Inside this function:\\n\\n- Two variables, a and b, are initialized to 0 and 1 respectively. These variables will keep track of the last two Fibonacci numbers.\\n\\n- The generator function starts by yielding the initial value a, which is 0.\\n\\n- The for loop iterates from 1 to 49 (50 iterations in total). In each iteration, the next Fibonacci number c is calculated as the sum of the previous two numbers a and b.\\n\\n- The current Fibonacci number a is yielded using the yield keyword.\\n\\n- The values of a and b are then updated to prepare for the next iteration.\\n\\n# Complexity\\n**- Time Complexity:**\\nThe time complexity of the generator function mainly depends on the number of iterations in the loop. Since the loop iterates 50 times, the time complexity of generating the first 50 Fibonacci numbers is O(50), which is essentially **O(1)** in terms of practical considerations.\\n\\n**- Space Complexity:** \\nThe space complexity is **O(1)** because the generator function only uses a constant amount of extra space for variables, regardless of the input size.\\n\\n# Code\\n```\\n/**\\n * @return {Generator<number>}\\n */\\nvar fibGenerator = function*() {\\n    let a = 0;\\n    let b =1;\\n\\n    for(let i =1 ; i<=50 ; i++){\\n        let c = a+b ;\\n        yield a;\\n\\n        a =b ;\\n        b =c;\\n\\n    }\\n};\\n\\n/**\\n * const gen = fibGenerator();\\n * gen.next().value; // 0\\n * gen.next().value; // 1\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @return {Generator<number>}\\n */\\nvar fibGenerator = function*() {\\n    let a = 0;\\n    let b =1;\\n\\n    for(let i =1 ; i<=50 ; i++){\\n        let c = a+b ;\\n        yield a;\\n\\n        a =b ;\\n        b =c;\\n\\n    }\\n};\\n\\n/**\\n * const gen = fibGenerator();\\n * gen.next().value; // 0\\n * gen.next().value; // 1\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3894968,
                "title": "easy-solution-javascript",
                "content": "# Code\\n```\\n/**\\n * @return {Generator<number>}\\n */\\nvar fibGenerator = function*() {\\n    let num1 = 0, num2 = 1\\n    yield num1\\n    yield num2\\n    for(;;) {\\n      const next = num1 + num2\\n      yield next\\n      num1 = num2\\n      num2 = next\\n    }\\n};\\n\\n/**\\n * const gen = fibGenerator();\\n * gen.next().value; // 0\\n * gen.next().value; // 1\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @return {Generator<number>}\\n */\\nvar fibGenerator = function*() {\\n    let num1 = 0, num2 = 1\\n    yield num1\\n    yield num2\\n    for(;;) {\\n      const next = num1 + num2\\n      yield next\\n      num1 = num2\\n      num2 = next\\n    }\\n};\\n\\n/**\\n * const gen = fibGenerator();\\n * gen.next().value; // 0\\n * gen.next().value; // 1\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3879002,
                "title": "efficient-fibonacci-generator-on-demand-fibonacci-number-calculation-using-javascript-generator-func",
                "content": "# Intuition\\nThe intuition behind this approach is to use a generator function to generate Fibonacci numbers on-demand. A generator function allows us to calculate and yield the Fibonacci numbers one by one without storing all of them in memory at once. This approach is memory-efficient and suitable for scenarios where we only need a limited number of Fibonacci numbers.\\n\\n# Approach\\nWe define the fibGenerator function as a generator function using the function* syntax in JavaScript.\\nWe initialize mylist with the first two Fibonacci numbers [0, 1].\\nWe use the yield keyword to yield the first two Fibonacci numbers (0 and 1) as base cases.\\nIn the for loop, we start calculating the next Fibonacci numbers using the previous two numbers in the mylist array.\\nWe continuously push the new Fibonacci numbers into the mylist array and yield the calculated Fibonacci number using yield num.\\nThe generator will keep generating Fibonacci numbers indefinitely.\\n# Complexity\\n- Time complexity:\\nTime complexity: O(1) for each next() call on the generator. Calculating each Fibonacci number takes constant time, so the time complexity of generating one Fibonacci number is constant.\\n\\n- Space complexity:\\nSpace complexity: O(n) where n is the number of Fibonacci numbers generated. The generator keeps an internal list mylist to store the generated Fibonacci numbers. The space complexity increases as more Fibonacci numbers are generated, but it grows linearly with the number of generated Fibonacci numbers.\\n\\n# Code\\n```\\n/**\\n * @return {Generator<number>}\\n */\\nvar fibGenerator = function* () {\\n    let mylist = [0, 1];\\n\\n    \\n    yield mylist[0];\\n    yield mylist[1];\\n\\n    for (let i = 2; ; i++) {\\n        let num = mylist[i - 1] + mylist[i - 2];\\n        mylist.push(num);\\n        yield num;\\n    }\\n};\\n\\n/**\\n * const gen = fibGenerator();\\n * gen.next().value; // 0\\n * gen.next().value; // 1\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @return {Generator<number>}\\n */\\nvar fibGenerator = function* () {\\n    let mylist = [0, 1];\\n\\n    \\n    yield mylist[0];\\n    yield mylist[1];\\n\\n    for (let i = 2; ; i++) {\\n        let num = mylist[i - 1] + mylist[i - 2];\\n        mylist.push(num);\\n        yield num;\\n    }\\n};\\n\\n/**\\n * const gen = fibGenerator();\\n * gen.next().value; // 0\\n * gen.next().value; // 1\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3875457,
                "title": "2648-generate-fibonacci-sequence",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @return {Generator<number>}\\n */\\nvar fibGenerator = function*() {\\n     let firstTerm = 0;\\n    yield firstTerm;\\n    let secondTerm = 1;\\n    yield secondTerm;\\n    let nextTerm;\\n    while (true) {\\n        nextTerm = firstTerm + secondTerm;\\n        firstTerm = secondTerm;\\n        secondTerm = nextTerm;\\n        yield nextTerm;\\n    }\\n};\\n\\n/**\\n * const gen = fibGenerator();\\n * gen.next().value; // 0\\n * gen.next().value; // 1\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @return {Generator<number>}\\n */\\nvar fibGenerator = function*() {\\n     let firstTerm = 0;\\n    yield firstTerm;\\n    let secondTerm = 1;\\n    yield secondTerm;\\n    let nextTerm;\\n    while (true) {\\n        nextTerm = firstTerm + secondTerm;\\n        firstTerm = secondTerm;\\n        secondTerm = nextTerm;\\n        yield nextTerm;\\n    }\\n};\\n\\n/**\\n * const gen = fibGenerator();\\n * gen.next().value; // 0\\n * gen.next().value; // 1\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3868238,
                "title": "while-looppppppppp",
                "content": "# Intuition\\nwhat is fibonacci sequence ? \\uD83D\\uDE05\\n\\n# Approach\\nusing while loop\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @return {Generator<number>}\\n */\\nvar fibGenerator = function*() {\\nlet firstOne = -1;\\nlet secondOne = 1;\\nlet start = 0;\\n    while(start<=50){\\n        let val = secondOne + firstOne;\\n         firstOne = secondOne;\\n        secondOne = val;\\n        yield val;\\n        start++\\n    }\\n};\\n\\n\\n const gen = fibGenerator();\\n  gen.next().value; // 0\\n  gen.next().value; // 1\\n \\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @return {Generator<number>}\\n */\\nvar fibGenerator = function*() {\\nlet firstOne = -1;\\nlet secondOne = 1;\\nlet start = 0;\\n    while(start<=50){\\n        let val = secondOne + firstOne;\\n         firstOne = secondOne;\\n        secondOne = val;\\n        yield val;\\n        start++\\n    }\\n};\\n\\n\\n const gen = fibGenerator();\\n  gen.next().value; // 0\\n  gen.next().value; // 1\\n \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3846293,
                "title": "used-generator-function-for-fibonacci-sequence",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @return {Generator<number>}\\n */\\nvar fibGenerator = function*(n) {\\n        let a = 0;\\n        let b = 1;\\n        let c = 0;\\n        yield a;\\n        yield b;\\n        while(true){\\n          c = a + b;\\n          yield c;\\n          a = b;\\n          b = c;\\n        }\\n};\\n\\n//here have kept while true. In gen function \\n- if we have yield more than one. whenever we call gen function it will not execute the previous if it\\'s already executed. Js remembers how many time yield or gen function have been called. \\n\\n\\n/**\\n * const gen = fibGenerator();\\n * gen.next().value; // 0\\n * gen.next().value; // 1\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @return {Generator<number>}\\n */\\nvar fibGenerator = function*(n) {\\n        let a = 0;\\n        let b = 1;\\n        let c = 0;\\n        yield a;\\n        yield b;\\n        while(true){\\n          c = a + b;\\n          yield c;\\n          a = b;\\n          b = c;\\n        }\\n};\\n\\n//here have kept while true. In gen function \\n- if we have yield more than one. whenever we call gen function it will not execute the previous if it\\'s already executed. Js remembers how many time yield or gen function have been called. \\n\\n\\n/**\\n * const gen = fibGenerator();\\n * gen.next().value; // 0\\n * gen.next().value; // 1\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3829253,
                "title": "simple-js-solution",
                "content": "\\n# Code\\n```\\n/**\\n * @return {Generator<number>}\\n */\\nvar fibGenerator = function*() {\\n    const last = [0, 1]\\n    yield 0\\n    yield 1\\n     for (let i = 2; i < 50; i++) {\\n         const curr = last[0] + last[1]\\n         last.push(curr)\\n         last.shift()\\n         yield curr\\n     }\\n};\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "\\n# Code\\n```\\n/**\\n * @return {Generator<number>}\\n */\\nvar fibGenerator = function*() {\\n    const last = [0, 1]\\n    yield 0\\n    yield 1\\n     for (let i = 2; i < 50; i++) {\\n         const curr = last[0] + last[1]\\n         last.push(curr)\\n         last.shift()\\n         yield curr\\n     }\\n};\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 3807257,
                "title": "javascript-generator",
                "content": "Generator function by default will not yield on the first try that\\'s why i made it yield the previous value which will show first value on the second try and so on. while wraping the yield inside a while true loop so it can be useable everytime the generator function is called.\\n```\\n/**\\n * @return {Generator<number>}\\n */\\nvar fibGenerator = function*() {\\n    let [prev,curr] = [0,1]\\n    while(true){\\n        yield prev;\\n        [prev,curr] = [curr,prev+curr]  \\n    }\\n};\\n\\n/**\\n * const gen = fibGenerator();\\n * gen.next().value; // 0\\n * gen.next().value; // 1\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @return {Generator<number>}\\n */\\nvar fibGenerator = function*() {\\n    let [prev,curr] = [0,1]\\n    while(true){\\n        yield prev;\\n        [prev,curr] = [curr,prev+curr]  \\n    }\\n};\\n\\n/**\\n * const gen = fibGenerator();\\n * gen.next().value; // 0\\n * gen.next().value; // 1\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3806920,
                "title": "fibonacci-sequence-optimized",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @return {Generator<number>}\\n */\\nvar fibGenerator = function*() {\\n\\n    let arr = [0,1];\\n\\n    for(let i = 2; i <=50; i++){\\n        arr.push(arr[i-1] + arr[i-2]);\\n    }\\n\\n    for(let val of arr){\\n        yield val;\\n    }\\n};\\n\\n/**\\n * const gen = fibGenerator();\\n * gen.next().value; // 0\\n * gen.next().value; // 1\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @return {Generator<number>}\\n */\\nvar fibGenerator = function*() {\\n\\n    let arr = [0,1];\\n\\n    for(let i = 2; i <=50; i++){\\n        arr.push(arr[i-1] + arr[i-2]);\\n    }\\n\\n    for(let val of arr){\\n        yield val;\\n    }\\n};\\n\\n/**\\n * const gen = fibGenerator();\\n * gen.next().value; // 0\\n * gen.next().value; // 1\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3804225,
                "title": "beats-97-79-in-runtime-and-71-31-in-memory-using-simple-for-loop",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @return {Generator<number>}\\n */\\nvar fibGenerator = function*() {\\n    let arr = [0,1];\\n    yield arr[0];\\n    yield arr[1];\\n    for (let i=2;i<51;i++){\\n           arr.push(arr[i-1]+arr[i-2])\\n            yield arr[i]\\n        }\\n \\n};\\n\\n/**\\n * const gen = fibGenerator();\\n * gen.next().value; // 0\\n * gen.next().value; // 1\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @return {Generator<number>}\\n */\\nvar fibGenerator = function*() {\\n    let arr = [0,1];\\n    yield arr[0];\\n    yield arr[1];\\n    for (let i=2;i<51;i++){\\n           arr.push(arr[i-1]+arr[i-2])\\n            yield arr[i]\\n        }\\n \\n};\\n\\n/**\\n * const gen = fibGenerator();\\n * gen.next().value; // 0\\n * gen.next().value; // 1\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3761391,
                "title": "typescript-following-the-hints",
                "content": "# Code\\n```\\nfunction* fibGenerator(): Generator<number, any, number> {\\n    yield 0\\n    yield 1\\n    let a = 0\\n    let b = 1\\n    while(true) {\\n        yield a+b\\n        let tmp = b\\n        b = a+b\\n        a = tmp\\n    }\\n};\\n\\n/**\\n * const gen = fibGenerator();\\n * gen.next().value; // 0\\n * gen.next().value; // 1\\n */\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\nfunction* fibGenerator(): Generator<number, any, number> {\\n    yield 0\\n    yield 1\\n    let a = 0\\n    let b = 1\\n    while(true) {\\n        yield a+b\\n        let tmp = b\\n        b = a+b\\n        a = tmp\\n    }\\n};\\n\\n/**\\n * const gen = fibGenerator();\\n * gen.next().value; // 0\\n * gen.next().value; // 1\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3760505,
                "title": "javascript-solution-using-closures",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nI tried to think of way in which I can store prev and current value 0 and 1 and new value can be derived from prev and current and shifiting this two pointer \\n```prev = curr``` and ```curr = newValue```\\nSo I tried to implement it using closures.\\none trick was there for starting two calls I don\\'t to perform this operation so conditionally I returned 0 and 1 for first two calls then apply rest logic of fibonacci.\\n\\n# Complexity\\n- Time complexity: constant\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: constant\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @return {Generator<number>}\\n */\\nvar fibGenerator = function() {\\n    let prev = 0;\\n    let curr = 1;\\n    let count = 0;\\n    return {\\n        next : function () {\\n            if(count < 2){\\n                return {\\n                    \"value\" : count++\\n                }\\n            }\\n            let ans = prev + curr;\\n            prev = curr;\\n            curr = ans;\\n            return {\\n                \"value\" : ans\\n            }\\n        }\\n    }\\n};\\n/**\\n * const gen = fibGenerator();\\n * gen.next().value; // 0\\n * gen.next().value; // 1\\n */\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Two Pointers",
                    "Memoization"
                ],
                "code": "```prev = curr```\n```curr = newValue```\n```\\n/**\\n * @return {Generator<number>}\\n */\\nvar fibGenerator = function() {\\n    let prev = 0;\\n    let curr = 1;\\n    let count = 0;\\n    return {\\n        next : function () {\\n            if(count < 2){\\n                return {\\n                    \"value\" : count++\\n                }\\n            }\\n            let ans = prev + curr;\\n            prev = curr;\\n            curr = ans;\\n            return {\\n                \"value\" : ans\\n            }\\n        }\\n    }\\n};\\n/**\\n * const gen = fibGenerator();\\n * gen.next().value; // 0\\n * gen.next().value; // 1\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3750194,
                "title": "simplest-javascript-solution-space-and-time-complexity-o-1",
                "content": "# Intuition\\nSwap and Yield!\\n\\n# Approach\\nInitialize two variables as current and next having values as 0, 1 respectively. It employs a generator function to yield Fibonacci numbers one by one without having to calculate all of them upfront. We are yielding the current value and then swapping current, next with next, current + next respectively.\\n\\n# Complexity\\n- Time complexity: O(1)\\n\\n- Space complexity: O(1)\\n\\n# Code\\n```\\n/**\\n * @return {Generator<number>}\\n */\\nvar fibGenerator = function*() {\\n  let current = 0, next = 1;\\n    \\n  while(true){\\n    yield current;\\n    [current, next] = [next, current + next]\\n  }\\n};\\n\\n/**\\n * const gen = fibGenerator();\\n * gen.next().value; // 0\\n * gen.next().value; // 1\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @return {Generator<number>}\\n */\\nvar fibGenerator = function*() {\\n  let current = 0, next = 1;\\n    \\n  while(true){\\n    yield current;\\n    [current, next] = [next, current + next]\\n  }\\n};\\n\\n/**\\n * const gen = fibGenerator();\\n * gen.next().value; // 0\\n * gen.next().value; // 1\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3749401,
                "title": "the-js-way",
                "content": "# Code\\n```\\n/**\\n * @return {Generator<number>}\\n */\\nvar fibGenerator = function*() {\\n    let num1 = 0;\\n    let num2 = 1;\\n    \\n    yield num1;\\n    yield num2;\\n\\n    while(true) {\\n        const num3 = num1 + num2;\\n\\n        yield num3;\\n\\n        num1 = num2;\\n        num2 = num3;\\n    }\\n};\\n\\n/**\\n * const gen = fibGenerator();\\n * gen.next().value; // 0\\n * gen.next().value; // 1\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @return {Generator<number>}\\n */\\nvar fibGenerator = function*() {\\n    let num1 = 0;\\n    let num2 = 1;\\n    \\n    yield num1;\\n    yield num2;\\n\\n    while(true) {\\n        const num3 = num1 + num2;\\n\\n        yield num3;\\n\\n        num1 = num2;\\n        num2 = num3;\\n    }\\n};\\n\\n/**\\n * const gen = fibGenerator();\\n * gen.next().value; // 0\\n * gen.next().value; // 1\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3726745,
                "title": "fibonacci-sequence-using-generator-function-by-switching-different-variables-in-a-loop",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe code implements a Fibonacci number generator using a generator function. The generator produces an infinite sequence of Fibonacci numbers.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe approach is to use a while loop to generate Fibonacci numbers indefinitely. The generator function maintains three variables: i, j, and k. It starts with i = 0, j = undefined, and k = undefined. Inside the loop, it follows the Fibonacci sequence logic to update the values of i, j, and k and yield the Fibonacci number i.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nThe time complexity is O(\\u221E) or simply as O(1), each Fibonacci number is generated in constant time.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nThe space complexity is O(1).\\n# Code\\n```\\n/**\\n * @return {Generator<number>}\\n */\\nvar fibGenerator = function*() {\\n    let i = 0\\n    let j\\n    let k\\n    \\n    while(true){\\n        if (i == 0){\\n            yield i\\n            i = 1\\n            j = 0\\n        } else if(i == 1 && j == 0){\\n            yield i\\n            i = 1\\n            j = 1\\n        }\\n        yield i\\n        k = j\\n        j = i\\n        i = i + k\\n    }\\n};\\n\\n/**\\n * const gen = fibGenerator();\\n * gen.next().value; // 0\\n * gen.next().value; // 1\\n * 0,1,1,2,3,5,8,13,21,34\\n */\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Math"
                ],
                "code": "```\\n/**\\n * @return {Generator<number>}\\n */\\nvar fibGenerator = function*() {\\n    let i = 0\\n    let j\\n    let k\\n    \\n    while(true){\\n        if (i == 0){\\n            yield i\\n            i = 1\\n            j = 0\\n        } else if(i == 1 && j == 0){\\n            yield i\\n            i = 1\\n            j = 1\\n        }\\n        yield i\\n        k = j\\n        j = i\\n        i = i + k\\n    }\\n};\\n\\n/**\\n * const gen = fibGenerator();\\n * gen.next().value; // 0\\n * gen.next().value; // 1\\n * 0,1,1,2,3,5,8,13,21,34\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3695997,
                "title": "yield-keyword-is-used-to-pause-and-resume-generator-function",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @return {Generator<number>}\\n */\\nvar fibGenerator = function*() {\\n    for (let a = 0, b = 1; true; b += a, a = b - a) yield a;\\n};\\n\\n/**\\n * const gen = fibGenerator();\\n * gen.next().value; // 0\\n * gen.next().value; // 1\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @return {Generator<number>}\\n */\\nvar fibGenerator = function*() {\\n    for (let a = 0, b = 1; true; b += a, a = b - a) yield a;\\n};\\n\\n/**\\n * const gen = fibGenerator();\\n * gen.next().value; // 0\\n * gen.next().value; // 1\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3688908,
                "title": "javascript-solution-for-beginner",
                "content": "# Code\\n```\\nvar fibGenerator = function*() {\\n  let current = 0; \\n  let next = 1;\\n  while (true) {\\n    yield current; \\n    [current, next] = [next, current + next];\\n  }\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar fibGenerator = function*() {\\n  let current = 0; \\n  let next = 1;\\n  while (true) {\\n    yield current; \\n    [current, next] = [next, current + next];\\n  }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3657482,
                "title": "fibonacci-generator-in-js-95-pretty-standard-fare",
                "content": "# Intuition\\nI had heard JS had generator functions, but I\\'ve never found a need to use them, as I also heard they are pretty slow.  It was also my first time coming across function*.  I read up, and it seemed easy enough.\\n\\n# Approach\\nI wrote a version with 3 yield statements, but that was apparently too slow, so I had to take a look again.  I realised posNeg2 was what was always asked for, and I know for loops let you maintain local scope with a let variable, so that might speed it up.  Reorganizing things worked, but although it got 95% faster it could just as easily have 49%; it all varies cause of the testing servers.  It\\'s hard to be confident this would actually be performant unless I did further testing, but I checked mine against most at the top, and it\\'s pretty similar.\\n\\nThe actual submission results:\\nhttps://leetcode.com/problems/generate-fibonacci-sequence/submissions/974828184/\\n\\n# Complexity\\n- Time complexity:\\nO(1)\\n\\n\\n# Code\\n```\\n/**\\n * @return {Generator<number>}\\n */\\nvar fibGenerator = function*() {\\n    let posNeg2 = 0\\n    let posNeg1 = 1\\n    for(let pos=0;true;){\\n        yield posNeg2;\\n        pos = posNeg1+posNeg2;\\n        posNeg2 = posNeg1;\\n        posNeg1 = pos;\\n    }\\n};\\n\\n/**\\n * const gen = fibGenerator();\\n * gen.next().value; // 0\\n * gen.next().value; // 1\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @return {Generator<number>}\\n */\\nvar fibGenerator = function*() {\\n    let posNeg2 = 0\\n    let posNeg1 = 1\\n    for(let pos=0;true;){\\n        yield posNeg2;\\n        pos = posNeg1+posNeg2;\\n        posNeg2 = posNeg1;\\n        posNeg1 = pos;\\n    }\\n};\\n\\n/**\\n * const gen = fibGenerator();\\n * gen.next().value; // 0\\n * gen.next().value; // 1\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3657478,
                "title": "infinity-fibonanchi-you-can-understand-it-too-easy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @return {Generator<number>}\\n */\\nvar fibGenerator = function*() {\\n        let myArr = [0, 1], t=2;\\n\\n    yield myArr[0]\\n    yield myArr[1]\\n\\n    while (true) {\\n        myArr.push(myArr[t - 1] + myArr[t - 2]);\\n        yield myArr[myArr.length - 1];\\n        t++;\\n       \\n    }\\n};\\n\\n/**\\n * const gen = fibGenerator();\\n * gen.next().value; // 0\\n * gen.next().value; // 1\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @return {Generator<number>}\\n */\\nvar fibGenerator = function*() {\\n        let myArr = [0, 1], t=2;\\n\\n    yield myArr[0]\\n    yield myArr[1]\\n\\n    while (true) {\\n        myArr.push(myArr[t - 1] + myArr[t - 2]);\\n        yield myArr[myArr.length - 1];\\n        t++;\\n       \\n    }\\n};\\n\\n/**\\n * const gen = fibGenerator();\\n * gen.next().value; // 0\\n * gen.next().value; // 1\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3640131,
                "title": "easy-way",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @return {Generator<number>}\\n */\\nvar fibGenerator = function*() {\\n    var current = 0;\\n  var next = 1;\\n\\n  while (true) {\\n    yield current;\\n    [current, next] = [next, current + next];\\n  }\\n};\\n\\n/**\\n * const gen = fibGenerator();\\n * gen.next().value; // 0\\n * gen.next().value; // 1\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @return {Generator<number>}\\n */\\nvar fibGenerator = function*() {\\n    var current = 0;\\n  var next = 1;\\n\\n  while (true) {\\n    yield current;\\n    [current, next] = [next, current + next];\\n  }\\n};\\n\\n/**\\n * const gen = fibGenerator();\\n * gen.next().value; // 0\\n * gen.next().value; // 1\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3638034,
                "title": "js-solution-beats-56-in-memory",
                "content": "# Code\\n```\\n/**\\n * @return {Generator<number>}\\n */\\nvar fibGenerator = function*() {\\n    let a = 0, b = 1;\\n    yield a;\\n    yield b;\\n\\n    while (true) {\\n        let c = a + b;\\n        a = b;\\n        b = c;\\n        yield c;\\n    }\\n};\\n\\n/**\\n * const gen = fibGenerator();\\n * gen.next().value; // 0\\n * gen.next().value; // 1\\n */\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Dynamic Programming"
                ],
                "code": "```\\n/**\\n * @return {Generator<number>}\\n */\\nvar fibGenerator = function*() {\\n    let a = 0, b = 1;\\n    yield a;\\n    yield b;\\n\\n    while (true) {\\n        let c = a + b;\\n        a = b;\\n        b = c;\\n        yield c;\\n    }\\n};\\n\\n/**\\n * const gen = fibGenerator();\\n * gen.next().value; // 0\\n * gen.next().value; // 1\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3604751,
                "title": "easy-js-solution",
                "content": "# Code\\n```\\n/**\\n * @return {Generator<number>}\\n */\\nvar fibGenerator = function*() {\\n    let prev1 = 0;\\n    let prev2 = 1;\\n    while(true) {\\n        yield prev1;\\n        const temp = prev1;\\n        prev1 = prev2;\\n        prev2 += temp;\\n    }\\n};\\n\\n/**\\n * const gen = fibGenerator();\\n * gen.next().value; // 0\\n * gen.next().value; // 1\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @return {Generator<number>}\\n */\\nvar fibGenerator = function*() {\\n    let prev1 = 0;\\n    let prev2 = 1;\\n    while(true) {\\n        yield prev1;\\n        const temp = prev1;\\n        prev1 = prev2;\\n        prev2 += temp;\\n    }\\n};\\n\\n/**\\n * const gen = fibGenerator();\\n * gen.next().value; // 0\\n * gen.next().value; // 1\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3594484,
                "title": "easy-self-explainary-day-29",
                "content": "\\n\\n# Code\\n```\\n/**\\n * @return {Generator<number>}\\n */\\nvar fibGenerator = function*() {\\n    let n1= 0, n2 = 1\\n\\n    while(true){\\n        yield n1;\\n        [n1,n2]= [n2, n1+n2]\\n    }\\n};\\n\\n/**\\n * const gen = fibGenerator();\\n * gen.next().value; // 0\\n * gen.next().value; // 1\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @return {Generator<number>}\\n */\\nvar fibGenerator = function*() {\\n    let n1= 0, n2 = 1\\n\\n    while(true){\\n        yield n1;\\n        [n1,n2]= [n2, n1+n2]\\n    }\\n};\\n\\n/**\\n * const gen = fibGenerator();\\n * gen.next().value; // 0\\n * gen.next().value; // 1\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3593572,
                "title": "generator-function-concept-typescript-javascript",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe given problem involves implementing a `Fibonacci` number generator using a generator function. The generator should yield Fibonacci numbers in sequence, starting from 0 and 1, and then generating subsequent Fibonacci numbers by summing the previous two numbers.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Create a generator function `fibGenerator`.\\n2. Initialize two variables, `a` and `b`, to store the first two Fibonacci numbers: 0 and 1, respectively.\\n3. Use the `yield` keyword to yield the value of `a`, which is the first Fibonacci number and the value of `b`, which is the second Fibonacci number.\\n4. Run an infinite loop using `while(true)`. This loop will generate subsequent Fibonacci numbers indefinitely.\\n5. Inside the loop, calculate the next Fibonacci number by adding `a` and `b` and assign it to the variable `c`.\\n6. Update the values of `a` and `b` by shifting `b` to `a` and `c` to `b`, respectively. This prepares the variables for the next iteration.\\n7. Use the `yield` keyword to yield the value of `c`, which is the next Fibonacci number.\\n8. Since the loop is infinite, the generator function will keep yielding Fibonacci numbers as long as it is iterated.\\n\\n# Code\\n``` javascript []\\n/**\\n * @return {Generator<number>}\\n */\\nvar fibGenerator = function*() {\\n    let a = 0, b = 1;\\n    yield a;\\n    yield b;\\n\\n    while(true) {\\n        let c = a + b;\\n        a = b;\\n        b = c;\\n        yield c;\\n    }\\n};\\n\\n/**\\n * const gen = fibGenerator();\\n * gen.next().value; // 0\\n * gen.next().value; // 1\\n */\\n```\\n``` typescript []\\nfunction* fibGenerator(): Generator<number, any, number> {\\n    let a = 0, b = 1;\\n    yield a;\\n    yield b;\\n\\n    while(true) {\\n        let c = a + b;\\n        a = b;\\n        b = c;\\n        yield c;\\n    }\\n};\\n\\n/**\\n * const gen = fibGenerator();\\n * gen.next().value; // 0\\n * gen.next().value; // 1\\n */\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "``` javascript []\\n/**\\n * @return {Generator<number>}\\n */\\nvar fibGenerator = function*() {\\n    let a = 0, b = 1;\\n    yield a;\\n    yield b;\\n\\n    while(true) {\\n        let c = a + b;\\n        a = b;\\n        b = c;\\n        yield c;\\n    }\\n};\\n\\n/**\\n * const gen = fibGenerator();\\n * gen.next().value; // 0\\n * gen.next().value; // 1\\n */\\n```\n``` typescript []\\nfunction* fibGenerator(): Generator<number, any, number> {\\n    let a = 0, b = 1;\\n    yield a;\\n    yield b;\\n\\n    while(true) {\\n        let c = a + b;\\n        a = b;\\n        b = c;\\n        yield c;\\n    }\\n};\\n\\n/**\\n * const gen = fibGenerator();\\n * gen.next().value; // 0\\n * gen.next().value; // 1\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3593432,
                "title": "day-29-javascript-solution",
                "content": "# Code\\n```\\n/**\\n * @return {Generator<number>}\\n */\\nvar fibGenerator = function*() {\\n  let a = 0; yield a;\\n  let b = 1; yield b;\\n\\n  while (true) {\\n    let temp = b;\\n    b += a;\\n    a = temp;\\n    yield b;\\n  }\\n};\\n\\n/**\\n * const gen = fibGenerator();\\n * gen.next().value; // 0\\n * gen.next().value; // 1\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @return {Generator<number>}\\n */\\nvar fibGenerator = function*() {\\n  let a = 0; yield a;\\n  let b = 1; yield b;\\n\\n  while (true) {\\n    let temp = b;\\n    b += a;\\n    a = temp;\\n    yield b;\\n  }\\n};\\n\\n/**\\n * const gen = fibGenerator();\\n * gen.next().value; // 0\\n * gen.next().value; // 1\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3593301,
                "title": "simple-solution-typescript-while-loop",
                "content": "# Code\\n```\\nfunction* fibGenerator(): Generator<number, any, number> {\\n    let first = 0;\\n    let second = 1;\\n    let value = 0;\\n    let count = 0;\\n    while(true){\\n        if(count <= 1){\\n            count++;\\n            yield value++;\\n        }\\n        else{\\n            value = first + second;\\n            first = second;\\n            second = value;\\n            yield value;\\n        }\\n    }\\n};\\n\\n/**\\n * const gen = fibGenerator();\\n * gen.next().value; // 0\\n * gen.next().value; // 1\\n */\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "```\\nfunction* fibGenerator(): Generator<number, any, number> {\\n    let first = 0;\\n    let second = 1;\\n    let value = 0;\\n    let count = 0;\\n    while(true){\\n        if(count <= 1){\\n            count++;\\n            yield value++;\\n        }\\n        else{\\n            value = first + second;\\n            first = second;\\n            second = value;\\n            yield value;\\n        }\\n    }\\n};\\n\\n/**\\n * const gen = fibGenerator();\\n * gen.next().value; // 0\\n * gen.next().value; // 1\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3592810,
                "title": "generators-easiest-solution-javascript",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @return {Generator<number>}\\n */\\nvar fibGenerator = function*() {\\n    let a=0;\\n    let b=1;\\n\\n    while(true){\\n        yield a;\\n        [a,b]=[b,a+b];\\n    }\\n    \\n};\\n\\n/**\\n * const gen = fibGenerator();\\n * gen.next().value; // 0\\n * gen.next().value; // 1\\n */\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "```\\n/**\\n * @return {Generator<number>}\\n */\\nvar fibGenerator = function*() {\\n    let a=0;\\n    let b=1;\\n\\n    while(true){\\n        yield a;\\n        [a,b]=[b,a+b];\\n    }\\n    \\n};\\n\\n/**\\n * const gen = fibGenerator();\\n * gen.next().value; // 0\\n * gen.next().value; // 1\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3592292,
                "title": "javascript-solution",
                "content": "\\n# Code\\n```\\n/**\\n * @return {Generator<number>}\\n */\\nvar fibGenerator = function*() {\\n\\n    let a = 0;\\n     yield a;\\n    let b = 1;\\n     yield b\\n     while(true) {\\n      let c = a+b;\\n      yield c;\\n      a=b;\\n      b=c;\\n     }\\n    \\n};\\n\\n/**\\n * const gen = fibGenerator();\\n * gen.next().value; // 0\\n * gen.next().value; // 1\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @return {Generator<number>}\\n */\\nvar fibGenerator = function*() {\\n\\n    let a = 0;\\n     yield a;\\n    let b = 1;\\n     yield b\\n     while(true) {\\n      let c = a+b;\\n      yield c;\\n      a=b;\\n      b=c;\\n     }\\n    \\n};\\n\\n/**\\n * const gen = fibGenerator();\\n * gen.next().value; // 0\\n * gen.next().value; // 1\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3591865,
                "title": "beginner-friendly-js-solution",
                "content": "> **DISCLAIMER: ** I am not a Pro, Just sharing my solution here to start a healthy discussion, if you feel it could have been better, please feel free to share your solution and thoughts \\uD83D\\uDE4F below\\n\\n# Intuition\\nWhile loop will be useful \\uD83E\\uDD14\\uD83D\\uDE00\\n\\n# Approach\\nAs Fibonacci series is defined by this relation `Xn = Xn-1 + Xn-2`\\nWe need three variables in total a,b & c.\\n\\nFibonacci series starts with 0 and 1, Hence assiging those values to a & b and then `c = a + b`\\n\\nneed to handle yielding of 0 and 1 separately rest of the series will taken care by our `while` loop\\n\\n# Complexity\\n- Time complexity:\\n$$O(1)$$\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n![image.png](https://assets.leetcode.com/users/images/dbe33423-1b15-458a-8d91-e9af0f8079f1_1685774097.9031093.png)\\n\\n# Code\\n```\\n/**\\n * @return {Generator<number>}\\n */\\nvar fibGenerator = function* () {\\n  let a = 0;\\n  let b = 1;\\n  let c = 0;\\n\\n  if (c === 0) {\\n    c = a + b;\\n    yield 0;\\n  }\\n  if (c === 1) {\\n    yield 1;\\n  }\\n\\n  while (true) {\\n    c = a + b;\\n    a = b;\\n    b = c;\\n    yield c;\\n  }\\n};\\n\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @return {Generator<number>}\\n */\\nvar fibGenerator = function* () {\\n  let a = 0;\\n  let b = 1;\\n  let c = 0;\\n\\n  if (c === 0) {\\n    c = a + b;\\n    yield 0;\\n  }\\n  if (c === 1) {\\n    yield 1;\\n  }\\n\\n  while (true) {\\n    c = a + b;\\n    a = b;\\n    b = c;\\n    yield c;\\n  }\\n};\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3591396,
                "title": "javascript-simple-solution",
                "content": "# Code\\n```\\n/**\\n * @return {Generator<number>}\\n */\\nvar fibGenerator = function*() {\\n    let [n1, n2] = [0, 1]\\n\\n    while (true) {\\n        yield n1;\\n        [n1, n2] = [n2, n1 + n2]\\n    }\\n};\\n\\n/**\\n * const gen = fibGenerator();\\n * gen.next().value; // 0\\n * gen.next().value; // 1\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @return {Generator<number>}\\n */\\nvar fibGenerator = function*() {\\n    let [n1, n2] = [0, 1]\\n\\n    while (true) {\\n        yield n1;\\n        [n1, n2] = [n2, n1 + n2]\\n    }\\n};\\n\\n/**\\n * const gen = fibGenerator();\\n * gen.next().value; // 0\\n * gen.next().value; // 1\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3590738,
                "title": "javascript-faster-than-90",
                "content": "# Intuition\\nJust calculate the next value.\\n\\n# Approach\\nJust calculate the next value, use `yield` keyword to return the current value.\\n\\n# Complexity\\n- Time complexity:\\n$$O(1)$$\\n\\n- Space complexity:\\n$$O(1)$$\\n# Code\\n```\\n/**\\n * @return {Generator<number>}\\n */\\nvar fibGenerator = function*() {\\n    let k0 = 0;\\n    let k1 = 1;\\n    let n = 0;\\n    while (true)\\n    {\\n        if (n == 0) yield k0;\\n        if (n == 1) yield k1;\\n        let next = k0 + k1;\\n        k0 = k1;\\n        k1 = next;\\n        n++;\\n        yield k1;\\n    }\\n};\\n\\n/**\\n * const gen = fibGenerator();\\n * gen.next().value; // 0\\n * gen.next().value; // 1\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @return {Generator<number>}\\n */\\nvar fibGenerator = function*() {\\n    let k0 = 0;\\n    let k1 = 1;\\n    let n = 0;\\n    while (true)\\n    {\\n        if (n == 0) yield k0;\\n        if (n == 1) yield k1;\\n        let next = k0 + k1;\\n        k0 = k1;\\n        k1 = next;\\n        n++;\\n        yield k1;\\n    }\\n};\\n\\n/**\\n * const gen = fibGenerator();\\n * gen.next().value; // 0\\n * gen.next().value; // 1\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3590650,
                "title": "simple-but-only-for-the-first-50-numbers",
                "content": "# Intuition\\nThis is a very well known sequence, and it\\'s quite easy to generate 50 numbers.\\n\\n# Approach\\nHardcode the first 50 Fibonacci numbers, and use the `yield*` notation to turn this array into a generator.\\n\\n# Complexity\\n- Time complexity:\\nConstant time per call.\\n\\n- Space complexity:\\nConstant space, although it would take more space if you wanted to be able to call this more than 50 times.\\n\\n# Code\\n```\\n/**\\n * @return {Generator<number>}\\n */\\nvar fibGenerator = function*() {\\n    yield* [0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610, 987, 1597, 2584, 4181, 6765, 10946, 17711, 28657, 46368, 75025, 121393, 196418, 317811, 514229, 832040, 1346269, 2178309, 3524578, 5702887, 9227465, 14930352, 24157817, 39088169, 63245986, 102334155, 165580141, 267914296, 433494437, 701408733, 1134903170, 1836311903, 2971215073, 4807526976, 7778742049, 12586269025, 20365011074]\\n};\\n\\n/**\\n * const gen = fibGenerator();\\n * gen.next().value; // 0\\n * gen.next().value; // 1\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @return {Generator<number>}\\n */\\nvar fibGenerator = function*() {\\n    yield* [0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610, 987, 1597, 2584, 4181, 6765, 10946, 17711, 28657, 46368, 75025, 121393, 196418, 317811, 514229, 832040, 1346269, 2178309, 3524578, 5702887, 9227465, 14930352, 24157817, 39088169, 63245986, 102334155, 165580141, 267914296, 433494437, 701408733, 1134903170, 1836311903, 2971215073, 4807526976, 7778742049, 12586269025, 20365011074]\\n};\\n\\n/**\\n * const gen = fibGenerator();\\n * gen.next().value; // 0\\n * gen.next().value; // 1\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3590472,
                "title": "javascript-beginner-easy-solution",
                "content": "# Intuition\\nIn fibonacci the element is the sum of previous two elements\\n\\n# Approach\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @return {Generator<number>}\\n */\\nvar fibGenerator = function*() {\\n    let a = 0;\\n    let b = 1;\\n    yield a;\\n    yield b;\\n\\n    while(true) {\\n        let c = a+b;\\n        a = b;\\n        b = c;\\n        yield b;\\n    } \\n};\\n\\n/**\\n * const gen = fibGenerator();\\n * gen.next().value; // 0\\n * gen.next().value; // 1\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @return {Generator<number>}\\n */\\nvar fibGenerator = function*() {\\n    let a = 0;\\n    let b = 1;\\n    yield a;\\n    yield b;\\n\\n    while(true) {\\n        let c = a+b;\\n        a = b;\\n        b = c;\\n        yield b;\\n    } \\n};\\n\\n/**\\n * const gen = fibGenerator();\\n * gen.next().value; // 0\\n * gen.next().value; // 1\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3590385,
                "title": "simple-solution-using-array-destructuring-assignment",
                "content": "Inside the function, it initializes a to 0 and b to 1, which are the first two numbers in the Fibonacci sequence. It then enters an infinite loop using while (true).\\nWithin each iteration of the loop, it yields the current value of a, effectively pausing the function and returning the value.\\n After that, it updates the values of a and b by swapping them, where a becomes the previous value of b, and b becomes the sum of the previous values of a and b.\\n\\n# Code\\n```\\n/**\\n * @return {Generator<number>}\\n */\\nvar fibGenerator = function*() {\\n   let a = 0, b = 1;\\n\\n  while (true) {\\n    yield a;\\n    [a, b] = [b, a + b];\\n\\n}\\n};\\n/**\\n * const gen = fibGenerator();\\n * gen.next().value; // 0\\n * gen.next().value; // 1\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @return {Generator<number>}\\n */\\nvar fibGenerator = function*() {\\n   let a = 0, b = 1;\\n\\n  while (true) {\\n    yield a;\\n    [a, b] = [b, a + b];\\n\\n}\\n};\\n/**\\n * const gen = fibGenerator();\\n * gen.next().value; // 0\\n * gen.next().value; // 1\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3590365,
                "title": "day-29-javascript",
                "content": "# Code\\n```\\n/**\\n * @return {Generator<number>}\\n */\\nvar fibGenerator = function*() {\\n    let prev1 = 0;\\n    let prev2 = 1;\\n\\n    while(true) {\\n        yield prev1;\\n        const temp = prev1;\\n        prev1 = prev2;\\n        prev2 += temp;\\n    }\\n};\\n\\n\\n/**\\n * const gen = fibGenerator();\\n * gen.next().value; // 0\\n * gen.next().value; // 1\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @return {Generator<number>}\\n */\\nvar fibGenerator = function*() {\\n    let prev1 = 0;\\n    let prev2 = 1;\\n\\n    while(true) {\\n        yield prev1;\\n        const temp = prev1;\\n        prev1 = prev2;\\n        prev2 += temp;\\n    }\\n};\\n\\n\\n/**\\n * const gen = fibGenerator();\\n * gen.next().value; // 0\\n * gen.next().value; // 1\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3590317,
                "title": "simple-fibonacci-generator",
                "content": "# Intuition\\nHelpful for understanding generators: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Generator\\n\\n\\n# Code\\n```\\n/**\\n * @return {Generator<number>}\\n */\\nvar fibGenerator = function*() {\\n    let a = 0, b = 1, temp;\\n    while(true){\\n        yield a;\\n        yield b;\\n        temp = b;\\n        a = a + b;\\n        b = a + temp;\\n    }\\n};\\n\\n/**\\n * const gen = fibGenerator();\\n * gen.next().value; // 0\\n * gen.next().value; // 1\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @return {Generator<number>}\\n */\\nvar fibGenerator = function*() {\\n    let a = 0, b = 1, temp;\\n    while(true){\\n        yield a;\\n        yield b;\\n        temp = b;\\n        a = a + b;\\n        b = a + temp;\\n    }\\n};\\n\\n/**\\n * const gen = fibGenerator();\\n * gen.next().value; // 0\\n * gen.next().value; // 1\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3590287,
                "title": "easy-javascript-solution",
                "content": "```\\n/**\\n * @return {Generator<number>}\\n */\\nvar fibGenerator = function*() {\\n    let curr = 0;\\n    let next = 1;\\n    \\n    while(true){\\n        yield curr;\\n        [curr, next] = [next, curr + next];\\n    }\\n};\\n\\n/**\\n * const gen = fibGenerator();\\n * gen.next().value; // 0\\n * gen.next().value; // 1\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @return {Generator<number>}\\n */\\nvar fibGenerator = function*() {\\n    let curr = 0;\\n    let next = 1;\\n    \\n    while(true){\\n        yield curr;\\n        [curr, next] = [next, curr + next];\\n    }\\n};\\n\\n/**\\n * const gen = fibGenerator();\\n * gen.next().value; // 0\\n * gen.next().value; // 1\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3589645,
                "title": "simple-solution-easy-to-understand-o-1-time-o-1-space",
                "content": "# Complexity\\n- Time complexity: **O(1)**\\n- Space complexity: **O(1)**\\n\\n# Code\\n```\\nvar fibGenerator = function*() {\\n    yield 0;\\n    yield 1;\\n    let prev = 0;\\n    let current = 1;\\n    \\n    while(true) {\\n        const temp = prev + current;\\n        prev = current;\\n        current = temp;\\n        yield current;\\n    }\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar fibGenerator = function*() {\\n    yield 0;\\n    yield 1;\\n    let prev = 0;\\n    let current = 1;\\n    \\n    while(true) {\\n        const temp = prev + current;\\n        prev = current;\\n        current = temp;\\n        yield current;\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3589565,
                "title": "easy-solution-o-1",
                "content": "```\\n/**\\n * @return {Generator<number>}\\n */\\nvar fibGenerator = function*() {\\n    let [a, b] = [0, 1];\\n    while(true){\\n        yield a;\\n        [a, b] = [b, a+b];\\n    };\\n};\\n\\n/**\\n * const gen = fibGenerator();\\n * gen.next().value; // 0\\n * gen.next().value; // 1\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @return {Generator<number>}\\n */\\nvar fibGenerator = function*() {\\n    let [a, b] = [0, 1];\\n    while(true){\\n        yield a;\\n        [a, b] = [b, a+b];\\n    };\\n};\\n\\n/**\\n * const gen = fibGenerator();\\n * gen.next().value; // 0\\n * gen.next().value; // 1\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3589513,
                "title": "javascript-made-simple",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n\\n- Space complexity: $$O(1)$$\\n\\n# Code\\n```\\n/**\\n * @return {Generator<number>}\\n */\\nvar fibGenerator = function*() {\\n    let a0 = 0;\\n    let a1 = 1;\\n    while(true){\\n        yield a0;\\n        let temp = a0;\\n        a0 = a1;\\n        a1 = temp + a1;\\n    };\\n};\\n\\n/**\\n * const gen = fibGenerator();\\n * gen.next().value; // 0\\n * gen.next().value; // 1\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @return {Generator<number>}\\n */\\nvar fibGenerator = function*() {\\n    let a0 = 0;\\n    let a1 = 1;\\n    while(true){\\n        yield a0;\\n        let temp = a0;\\n        a0 = a1;\\n        a1 = temp + a1;\\n    };\\n};\\n\\n/**\\n * const gen = fibGenerator();\\n * gen.next().value; // 0\\n * gen.next().value; // 1\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3589434,
                "title": "typescript-using-while-loop-and-yielding-runtime-100-memory-60",
                "content": "\\n\\n# Complexity\\n- Time complexity: $$O(1)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```TypeScript\\nfunction* fibGenerator(): Generator<number, any, number> {\\n    let xn_2 = 0;\\n    let xn_1 = 1;\\n    yield xn_2;\\n    yield xn_1;\\n    while(true) {\\n        const sum = xn_1 + xn_2;\\n        yield sum;\\n        xn_2 = xn_1;\\n        xn_1 = sum;\\n    }\\n};\\n\\n/**\\n * const gen = fibGenerator();\\n * gen.next().value; // 0\\n * gen.next().value; // 1\\n */\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```TypeScript\\nfunction* fibGenerator(): Generator<number, any, number> {\\n    let xn_2 = 0;\\n    let xn_1 = 1;\\n    yield xn_2;\\n    yield xn_1;\\n    while(true) {\\n        const sum = xn_1 + xn_2;\\n        yield sum;\\n        xn_2 = xn_1;\\n        xn_1 = sum;\\n    }\\n};\\n\\n/**\\n * const gen = fibGenerator();\\n * gen.next().value; // 0\\n * gen.next().value; // 1\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3589431,
                "title": "simple-javascript-solution",
                "content": "# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @return {Generator<number>}\\n */\\nvar fibGenerator = function*() {\\n    let a = 0, b = 1;\\n    while(1)\\n    {\\n        yield a;\\n        let temp = a;\\n        a = b;\\n        b = temp + b;\\n    }\\n};\\n\\n/**\\n * const gen = fibGenerator();\\n * gen.next().value; // 0\\n * gen.next().value; // 1\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @return {Generator<number>}\\n */\\nvar fibGenerator = function*() {\\n    let a = 0, b = 1;\\n    while(1)\\n    {\\n        yield a;\\n        let temp = a;\\n        a = b;\\n        b = temp + b;\\n    }\\n};\\n\\n/**\\n * const gen = fibGenerator();\\n * gen.next().value; // 0\\n * gen.next().value; // 1\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3589233,
                "title": "solution-typescript-javascript",
                "content": "# Code\\n``` typescript []\\nconst fibGenerator = (): Iterator<number> => {\\n    const lengthOfSequence: number = 50;\\n    const fibonacciSequence: number[] = Array(lengthOfSequence).fill(0);\\n    fibonacciSequence[1] = 1;\\n    for (let i = 2; i < fibonacciSequence.length; i++) {\\n        fibonacciSequence[i] = fibonacciSequence[i - 1] + fibonacciSequence[i - 2];\\n    }\\n    return fibonacciSequence[Symbol.iterator]();\\n};\\n```\\n``` javascript []\\nvar fibGenerator = function() {\\n    const lengthOfSequence = 50;\\n    const fibonacciSequence = Array(lengthOfSequence).fill(0);\\n    fibonacciSequence[1] = 1;\\n    for (let i = 2; i < fibonacciSequence.length; i++) {\\n        fibonacciSequence[i] = fibonacciSequence[i - 1] + fibonacciSequence[i - 2];\\n    }\\n    return fibonacciSequence[Symbol.iterator]();\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "``` typescript []\\nconst fibGenerator = (): Iterator<number> => {\\n    const lengthOfSequence: number = 50;\\n    const fibonacciSequence: number[] = Array(lengthOfSequence).fill(0);\\n    fibonacciSequence[1] = 1;\\n    for (let i = 2; i < fibonacciSequence.length; i++) {\\n        fibonacciSequence[i] = fibonacciSequence[i - 1] + fibonacciSequence[i - 2];\\n    }\\n    return fibonacciSequence[Symbol.iterator]();\\n};\\n```\n``` javascript []\\nvar fibGenerator = function() {\\n    const lengthOfSequence = 50;\\n    const fibonacciSequence = Array(lengthOfSequence).fill(0);\\n    fibonacciSequence[1] = 1;\\n    for (let i = 2; i < fibonacciSequence.length; i++) {\\n        fibonacciSequence[i] = fibonacciSequence[i - 1] + fibonacciSequence[i - 2];\\n    }\\n    return fibonacciSequence[Symbol.iterator]();\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3589174,
                "title": "simple-fibonacci-generator-in-javascript-beats-80",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nJust simple implementation of generator in JavaScript.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Initially declare two variables - a and b. They will be yielded.\\n2. Each call of our generator will produce the next value in Fibonacci series. We did this by creating auxiliary next variable inside while loop.\\n\\n# Complexity\\n- Time complexity: O(1) because it involves a fixed number of mathematical operations. `For each call` of course.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: Constant time - O(n). Only keeps track of two latest numbers - a,b \\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @return {Generator<number>}\\n */\\nvar fibGenerator = function*() {\\n    let a = 0;\\n    let b = 1;\\n\\n    yield a;\\n    yield b;\\n\\n    while (true) {\\n        let next = a + b;\\n        yield next;\\n        a = b;\\n        b = next;\\n    }\\n};\\n\\n/**\\n * const gen = fibGenerator();\\n * gen.next().value; // 0\\n * gen.next().value; // 1\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @return {Generator<number>}\\n */\\nvar fibGenerator = function*() {\\n    let a = 0;\\n    let b = 1;\\n\\n    yield a;\\n    yield b;\\n\\n    while (true) {\\n        let next = a + b;\\n        yield next;\\n        a = b;\\n        b = next;\\n    }\\n};\\n\\n/**\\n * const gen = fibGenerator();\\n * gen.next().value; // 0\\n * gen.next().value; // 1\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3589057,
                "title": "easiest-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n**Generator Function:** \\n- It is defined like a normal function, but when it needs to generate a value, it does it with the *yield* keyword, (not the return keyword).\\n- The *yield* statement suspends the execution of function and sends back a value to the caller, but it retains the state to make the function to resume from where it is left off.\\n- On resuming, the function\\'s execution continues immediately after the last *yield* was executed. \\n\\n# Code\\n``` javaScript []\\nvar fibGenerator = function*() {\\n    var [a, b] = [0, 1];\\n\\n    while (!false){\\n        yield a;\\n        [a, b] = [b, a+b];\\n    }\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "``` javaScript []\\nvar fibGenerator = function*() {\\n    var [a, b] = [0, 1];\\n\\n    while (!false){\\n        yield a;\\n        [a, b] = [b, a+b];\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3588945,
                "title": "javascript-simple-javascript-typescript-solution",
                "content": "# If You like the Solution, Don\\'t Forget To UpVote Me, Please UpVote! \\uD83D\\uDD3C\\uD83D\\uDE4F\\n# Approach 1 Using Javascript :\\n# Runtime: 60 ms, faster than 43.81% of JavaScript online submissions for Generate Fibonacci Sequence.\\n# Memory Usage: 41.6 MB, less than 89.04% of JavaScript online submissions for Generate Fibonacci Sequence.\\n\\tvar fibGenerator = function*() {\\n\\n\\t\\tlet first = 0 , second = 1;\\n\\n\\t\\twhile(true){\\n\\n\\t\\t\\tyield first;\\n\\n\\t\\t\\tlet next_number = first + second;\\n\\n\\t\\t\\tfirst = second;\\n\\n\\t\\t\\tsecond = next_number;\\n\\t\\t}\\n\\t};\\n# Approach 2 Using Typescript :\\n# Runtime: 55 ms, faster than 86.29% of TypeScript online submissions for Generate Fibonacci Sequence.\\n# Memory Usage: 42.9 MB, less than 67.49% of TypeScript online submissions for Generate Fibonacci Sequence.\\n\\tfunction* fibGenerator(): Generator<number, any, number> {\\n\\n\\t\\tlet first = 0 , second = 1;\\n\\n\\t\\twhile(true){\\n\\n\\t\\t\\tyield first;\\n\\n\\t\\t\\tlet next_number = first + second;\\n\\n\\t\\t\\tfirst = second;\\n\\n\\t\\t\\tsecond = next_number;\\n\\t\\t}\\n\\t};\\n# Thank You \\uD83E\\uDD73\\u270C\\uD83D\\uDC4D",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "# If You like the Solution, Don\\'t Forget To UpVote Me, Please UpVote! \\uD83D\\uDD3C\\uD83D\\uDE4F\\n# Approach 1 Using Javascript :\\n# Runtime: 60 ms, faster than 43.81% of JavaScript online submissions for Generate Fibonacci Sequence.\\n# Memory Usage: 41.6 MB, less than 89.04% of JavaScript online submissions for Generate Fibonacci Sequence.\\n\\tvar fibGenerator = function*() {\\n\\n\\t\\tlet first = 0 , second = 1;\\n\\n\\t\\twhile(true){\\n\\n\\t\\t\\tyield first;\\n\\n\\t\\t\\tlet next_number = first + second;\\n\\n\\t\\t\\tfirst = second;\\n\\n\\t\\t\\tsecond = next_number;\\n\\t\\t}\\n\\t};\\n# Approach 2 Using Typescript :\\n# Runtime: 55 ms, faster than 86.29% of TypeScript online submissions for Generate Fibonacci Sequence.\\n# Memory Usage: 42.9 MB, less than 67.49% of TypeScript online submissions for Generate Fibonacci Sequence.\\n\\tfunction* fibGenerator(): Generator<number, any, number> {\\n\\n\\t\\tlet first = 0 , second = 1;\\n\\n\\t\\twhile(true){\\n\\n\\t\\t\\tyield first;\\n\\n\\t\\t\\tlet next_number = first + second;\\n\\n\\t\\t\\tfirst = second;\\n\\n\\t\\t\\tsecond = next_number;\\n\\t\\t}\\n\\t};\\n# Thank You \\uD83E\\uDD73\\u270C\\uD83D\\uDC4D",
                "codeTag": "Unknown"
            },
            {
                "id": 3588800,
                "title": "js-generator-time-50ms-90-space-42mb-56",
                "content": "# Approach\\nWe\\'ll implement the typical fibonacci function, but with `yield` to make it a generator.\\n\\n# Complexity\\n- Time complexity:\\nO(1)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\n/**\\n * @return {Generator<number>}\\n */\\nvar fibGenerator = function*() {\\n    // init\\n    let curr = 0;\\n    let next = 1;\\n\\n    // fibonacci sequence\\n    while(true) {\\n        yield curr;\\n        [curr, next] = [next, curr + next];\\n    }\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @return {Generator<number>}\\n */\\nvar fibGenerator = function*() {\\n    // init\\n    let curr = 0;\\n    let next = 1;\\n\\n    // fibonacci sequence\\n    while(true) {\\n        yield curr;\\n        [curr, next] = [next, curr + next];\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3588633,
                "title": "chatgpt-code-snippet",
                "content": "**Generate Fibonacci Sequence**\\n\\n**Problem Statement:**\\n\\nWrite a generator function that returns a generator object which yields the Fibonacci sequence.\\n\\nThe Fibonacci sequence is defined by the relation Xn = Xn-1 + Xn-2. The first few numbers of the series are 0, 1, 1, 2, 3, 5, 8, 13.\\n\\n**Intuition:**\\n\\nTo generate the Fibonacci sequence, we can use a generator function in JavaScript. The generator function allows us to easily yield the Fibonacci numbers one by one, without the need to calculate and store the entire sequence in memory. By utilizing the generator function\\'s `yield` keyword, we can lazily generate and retrieve Fibonacci numbers on demand.\\n\\n**Approach:**\\n\\n1. Initialize two variables, `a` and `b`, with the initial values of 0 and 1 respectively.\\n2. Yield the initial value `a` (0) using the `yield` keyword.\\n3. Enter an infinite loop.\\n4. Inside the loop, yield the current Fibonacci number `b`.\\n5. Calculate the next Fibonacci number by adding `a` and `b`, and assign it to the variable `next`.\\n6. Update `a` to the value of `b` and `b` to the value of `next` for the next iteration.\\n\\n**Complexity Analysis:**\\n\\nTime complexity: The time complexity of generating each Fibonacci number is O(1) since it only involves simple addition. The total time complexity depends on the number of Fibonacci numbers requested.\\n\\nSpace complexity: The space complexity is O(1) since we are not storing the entire sequence in memory. The generator function generates Fibonacci numbers on the fly, so it requires constant space regardless of the number of Fibonacci numbers generated.\\n\\n**Code:**\\n\\n```javascript\\n/**\\n * @return {Generator<number>}\\n */\\nfunction* fibGenerator() {\\n  let a = 0;\\n  let b = 1;\\n\\n  yield a; // yield the initial value 0\\n\\n  while (true) {\\n    yield b; // yield the current Fibonacci number\\n\\n    const next = a + b;\\n    a = b;\\n    b = next;\\n  }\\n}\\n\\n// Example usage\\nconst gen = fibGenerator();\\nconst callCount = 5;\\nfor (let i = 0; i < callCount; i++) {\\n  const value = gen.next().value;\\n  console.log(value);\\n}\\n```\\n\\nIn this code, the `fibGenerator` function is defined as a generator function using the `function*` syntax. It initializes two variables `a` and `b` to keep track of the previous two Fibonacci numbers. It starts by yielding the initial value (`a`), and then enters an infinite loop. In each iteration, it yields the current Fibonacci number (`b`) and calculates the next Fibonacci number by updating the values of `a` and `b`. The example usage demonstrates how to use the generator function to generate and print the Fibonacci sequence with a specified `callCount`.",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```javascript\\n/**\\n * @return {Generator<number>}\\n */\\nfunction* fibGenerator() {\\n  let a = 0;\\n  let b = 1;\\n\\n  yield a; // yield the initial value 0\\n\\n  while (true) {\\n    yield b; // yield the current Fibonacci number\\n\\n    const next = a + b;\\n    a = b;\\n    b = next;\\n  }\\n}\\n\\n// Example usage\\nconst gen = fibGenerator();\\nconst callCount = 5;\\nfor (let i = 0; i < callCount; i++) {\\n  const value = gen.next().value;\\n  console.log(value);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3588625,
                "title": "javascript-fibonacci-sequence-generator-using-generator-function",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nTo generate the Fibonacci sequence, we can use a generator function that yields each Fibonacci number one by one. I start with the initial values of 0 and 1. Then, in an infinite loop, I calculate the next Fibonacci number by adding the previous two numbers. I yield each Fibonacci number and update the previous and current values accordingly.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Define the generator function `fibGenerator` using the `function*` syntax.\\n2. Initialize the variables `prev` and `curr` with the values 0 and 1.\\n3. Yield the initial value of 0 using `yield prev`.\\n4. Check if `curr` is equal to 1 and yield it if true using `yield curr`.\\n5. Enter an infinite loop using `for (;;)`.\\n6. Calculate the next Fibonacci number by adding `prev` and `curr` and assign it to `next`.\\n7. Yield the value of `next` using `yield next`.\\n8. Update the values of `prev` and `curr` by assigning `curr` to `prev` and `next` to `curr`.\\n9. Outside the generator function, initialize the variable `callCount` to the desired number of Fibonacci numbers to generate.\\n10. Create a generator object `gen` by calling `fibGenerator()`.\\n11. Create an empty array `fibonacciSequence`.\\n12. Iterate `callCount` times using a `for` loop.\\n13. In each iteration, call `gen.next().value` to retrieve the next Fibonacci number and push it to the `fibonacciSequence` array.\\n14. Finally, log the `fibonacciSequence` array to the console.\\n\\n# Complexity\\n- Time complexity: O(n) where n is the `callCount` since I generate n Fibonacci numbes.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n) where n is the `callCount` since I store n Fibonacci numbers in the `fibonacciSequence` array.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @return {Generator<number>}\\n */\\nvar fibGenerator = function*() {\\n    let prev = 0;\\n    let curr = 1;\\n\\n    yield prev;\\n    if (curr === 1) {\\n        yield curr;\\n    }\\n\\n    for (;;) {\\n        const next = prev + curr;\\n        yield next;\\n        prev = curr;\\n        curr = next;\\n    }\\n};\\n\\nconst callCount = 5;\\nconst gen = fibGenerator();\\n\\nconst fibonacciSequence = [];\\nfor (let i = 0; i < callCount; i++) {\\n    fibonacciSequence.push(gen.next().value);\\n}\\nconsole.log(fibonacciSequence);\\n\\n/**\\n * const gen = fibGenerator();\\n * gen.next().value; // 0\\n * gen.next().value; // 1\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @return {Generator<number>}\\n */\\nvar fibGenerator = function*() {\\n    let prev = 0;\\n    let curr = 1;\\n\\n    yield prev;\\n    if (curr === 1) {\\n        yield curr;\\n    }\\n\\n    for (;;) {\\n        const next = prev + curr;\\n        yield next;\\n        prev = curr;\\n        curr = next;\\n    }\\n};\\n\\nconst callCount = 5;\\nconst gen = fibGenerator();\\n\\nconst fibonacciSequence = [];\\nfor (let i = 0; i < callCount; i++) {\\n    fibonacciSequence.push(gen.next().value);\\n}\\nconsole.log(fibonacciSequence);\\n\\n/**\\n * const gen = fibGenerator();\\n * gen.next().value; // 0\\n * gen.next().value; // 1\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3588573,
                "title": "easy-solution-2648-generate-fibonacci-sequence-javascript-day-29",
                "content": "# Code\\n```\\n/**\\n * @return {Generator<number>}\\n */\\nvar fibGenerator = function*() {\\n    n1=0\\n    n2=1\\n    while(true){\\n        yield n1;\\n        [n1,n2]=[n2,n1+n2];\\n    }\\n};\\n\\n/**\\n * const gen = fibGenerator();\\n * gen.next().value; // 0\\n * gen.next().value; // 1\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @return {Generator<number>}\\n */\\nvar fibGenerator = function*() {\\n    n1=0\\n    n2=1\\n    while(true){\\n        yield n1;\\n        [n1,n2]=[n2,n1+n2];\\n    }\\n};\\n\\n/**\\n * const gen = fibGenerator();\\n * gen.next().value; // 0\\n * gen.next().value; // 1\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3588249,
                "title": "day29-2-simple-and-easy-js-solution",
                "content": "\\n\\n# Complexity\\n- Time complexity:\\n$$O(1)$$\\n\\n- Space complexity:\\n$$O(1)$$\\n# Code\\n```\\n\\nvar fibGenerator = function*() {\\n    let [a,b]=[0,1];\\n   while(true){\\n       yield a;\\n       [a,b]=[b,a+b];\\n   }\\n};\\n\\n```\\n\\n\\n```\\n\\nvar fibGenerator = function*() {\\n     let x = 0;\\n    let y = 1;\\n    yield x\\n    yield y;\\n    while(true){\\n        const ans = x+ y;\\n        yield ans;\\n        x=y;\\n        y=ans;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n\\nvar fibGenerator = function*() {\\n    let [a,b]=[0,1];\\n   while(true){\\n       yield a;\\n       [a,b]=[b,a+b];\\n   }\\n};\\n\\n```\n```\\n\\nvar fibGenerator = function*() {\\n     let x = 0;\\n    let y = 1;\\n    yield x\\n    yield y;\\n    while(true){\\n        const ans = x+ y;\\n        yield ans;\\n        x=y;\\n        y=ans;\\n    }\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3588146,
                "title": "javascript-a-typescript-detailed-explanation",
                "content": "* fibGenerator is a generator function that produces an infinite sequence of Fibonacci numbers. Each time you call fibGenerator().next().value, it will return the next number in the sequence.\\n\\n* The * symbol is used to denote that this function is a generator function. It allows the function to use the yield keyword to pause the function\\'s execution and return a value to the\\n\\n\\n# Code\\n```\\n/**\\n * @return {Generator<number>}\\n */\\nvar fibGenerator = function*() {\\n    let a = 0\\n    let b = 1\\n\\n    yield a\\n    yield b\\n\\n    while(true){\\n        let c = a + b\\n        yield c\\n        a = b\\n        b = c\\n    }\\n};\\n\\n/**\\n * const gen = fibGenerator();\\n * gen.next().value; // 0\\n * gen.next().value; // 1\\n */\\n```\\n\\n\\n---\\n\\n\\n---\\n\\n* For simplicity\\'s sake, we hardcode the first two yield values for fib(0) and fib(1), then after that we use a loop to generate Fibonacci numbers as usual. \\n\\n# code\\n\\n```typescript []\\nfunction* fibGenerator(): Generator<number, any, number> {\\n    // fib(0) === 0\\n    yield 0;\\n    // fib(1) === 1\\n    yield 1;\\n    \\n    let a: number = 0;\\n    let b: number = 1;\\n    \\n    while (true) {\\n        const c: number = a + b;\\n        a = b;\\n        b = c;\\n        yield c;\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "```\\n/**\\n * @return {Generator<number>}\\n */\\nvar fibGenerator = function*() {\\n    let a = 0\\n    let b = 1\\n\\n    yield a\\n    yield b\\n\\n    while(true){\\n        let c = a + b\\n        yield c\\n        a = b\\n        b = c\\n    }\\n};\\n\\n/**\\n * const gen = fibGenerator();\\n * gen.next().value; // 0\\n * gen.next().value; // 1\\n */\\n```\n```typescript []\\nfunction* fibGenerator(): Generator<number, any, number> {\\n    // fib(0) === 0\\n    yield 0;\\n    // fib(1) === 1\\n    yield 1;\\n    \\n    let a: number = 0;\\n    let b: number = 1;\\n    \\n    while (true) {\\n        const c: number = a + b;\\n        a = b;\\n        b = c;\\n        yield c;\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3588128,
                "title": "generate-fibonacci-sequence",
                "content": "\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @return {Generator<number>}\\n */\\n\\n\\nvar fibGenerator = function*() {\\n    let a = 0; // first number in the fibonacci sequence\\n    let b = 1; // second number in the fibonacci sequence\\n\\n    for (;;) {\\n        yield a; // yielding\\n        [a, b] = [b, a + b]; \\n    }\\n};\\n\\n\\n\\n/**\\n * const gen = fibGenerator();\\n * gen.next().value; // 0\\n * gen.next().value; // 1\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @return {Generator<number>}\\n */\\n\\n\\nvar fibGenerator = function*() {\\n    let a = 0; // first number in the fibonacci sequence\\n    let b = 1; // second number in the fibonacci sequence\\n\\n    for (;;) {\\n        yield a; // yielding\\n        [a, b] = [b, a + b]; \\n    }\\n};\\n\\n\\n\\n/**\\n * const gen = fibGenerator();\\n * gen.next().value; // 0\\n * gen.next().value; // 1\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3587949,
                "title": "easy-js-solution",
                "content": "var fibGenerator = function*() {\\n \\n  let prev = 0;\\n  let curr = 1;\\n  \\n  yield prev;\\n  yield curr;\\n  \\n  for (let i = 2; i <= 50; i++) {\\n    const next = prev + curr;\\n    yield next;\\n    prev = curr;\\n    curr = next;\\n  }\\n\\n   \\n};",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "var fibGenerator = function*() {\\n \\n  let prev = 0;\\n  let curr = 1;\\n  \\n  yield prev;\\n  yield curr;\\n  \\n  for (let i = 2; i <= 50; i++) {\\n    const next = prev + curr;\\n    yield next;\\n    prev = curr;\\n    curr = next;\\n  }\\n\\n   \\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 3587914,
                "title": "easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @return {Generator<number>}\\n */\\nvar fibGenerator = function*() {\\n    let prev1=0;\\n    let prev2=1;\\n    while(true){\\n        yield prev1;\\n        [prev1 , prev2]=[prev2 , prev1+prev2];\\n    } \\n};\\n\\n/**\\n * const gen = fibGenerator();\\n * gen.next().value; // 0\\n * gen.next().value; // 1\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @return {Generator<number>}\\n */\\nvar fibGenerator = function*() {\\n    let prev1=0;\\n    let prev2=1;\\n    while(true){\\n        yield prev1;\\n        [prev1 , prev2]=[prev2 , prev1+prev2];\\n    } \\n};\\n\\n/**\\n * const gen = fibGenerator();\\n * gen.next().value; // 0\\n * gen.next().value; // 1\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3587911,
                "title": "easy-javascript-solution",
                "content": "# Approach\\nCertainly! Here\\'s an approach to generating the Fibonacci sequence using a generator function:\\n\\n1. Define a generator function called `fibGenerator()`.\\n2. Inside the function, initialize two variables, `prev` and `curr`, to 0 and 1 respectively. These represent the previous and current numbers in the Fibonacci sequence.\\n3. Use the `yield` keyword to yield the initial value of `prev`.\\n4. Create an infinite loop using `while (true)`.\\n5. Inside the loop, yield the current value of `curr`.\\n6. Calculate the next Fibonacci number by adding `prev` and `curr` and store it in a variable called `next`.\\n7. Update `prev` to the current value of `curr`.\\n8. Update `curr` to the value of `next`.\\n9. Repeat steps 5-8 indefinitely, generating the Fibonacci sequence.\\n\\nTo use the generator function and retrieve the Fibonacci sequence, follow these steps:\\n\\n1. Create an empty array called `sequence` to store the Fibonacci sequence elements.\\n2. Create a generator object by calling `fibGenerator()`, and store it in a variable called `gen`.\\n3. Use a loop to call `gen.next().value` the desired number of times, and push each value to the `sequence` array.\\n4. Once the loop is complete, return the `sequence` array.\\n\\nThis approach allows you to generate the Fibonacci sequence dynamically by controlling the number of times you call `gen.next().value`.\\n\\n# Complexity\\n- Time complexity: O(n)\\n\\n- Space complexity: O(1)\\n\\n# Code\\n```\\n/**\\n * @return {Generator<number>}\\n */\\nfunction* fibGenerator() {\\n    let prev = 0;\\n    let curr = 1;\\n\\n    yield prev;\\n\\n    while (true) {\\n      yield curr;\\n      const next = prev + curr;\\n      prev = curr;\\n      curr = next;\\n    }\\n}\\n\\n  function getFibonacciSequence(callCount) {\\n    const sequence = [];\\n    const gen = fibGenerator();\\n\\n    for (let i = 0; i < callCount; i++) {\\n      sequence.push(gen.next().value);\\n    }\\n\\n    return sequence;\\n}\\n\\n/**\\n * const gen = fibGenerator();\\n * gen.next().value; // 0\\n * gen.next().value; // 1\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @return {Generator<number>}\\n */\\nfunction* fibGenerator() {\\n    let prev = 0;\\n    let curr = 1;\\n\\n    yield prev;\\n\\n    while (true) {\\n      yield curr;\\n      const next = prev + curr;\\n      prev = curr;\\n      curr = next;\\n    }\\n}\\n\\n  function getFibonacciSequence(callCount) {\\n    const sequence = [];\\n    const gen = fibGenerator();\\n\\n    for (let i = 0; i < callCount; i++) {\\n      sequence.push(gen.next().value);\\n    }\\n\\n    return sequence;\\n}\\n\\n/**\\n * const gen = fibGenerator();\\n * gen.next().value; // 0\\n * gen.next().value; // 1\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3587816,
                "title": "java-script-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @return {Generator<number>}\\n */\\nvar fibGenerator = function*() {\\n\\n    let prev1 = 0;\\n    let prev2 = 1;\\n\\n    while (true) {\\n      yield prev1;\\n      [prev1, prev2] = [prev2, prev1+prev2];\\n    }\\n\\n};\\n\\n/**\\n * const gen = fibGenerator();\\n * gen.next().value; // 0\\n * gen.next().value; // 1\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @return {Generator<number>}\\n */\\nvar fibGenerator = function*() {\\n\\n    let prev1 = 0;\\n    let prev2 = 1;\\n\\n    while (true) {\\n      yield prev1;\\n      [prev1, prev2] = [prev2, prev1+prev2];\\n    }\\n\\n};\\n\\n/**\\n * const gen = fibGenerator();\\n * gen.next().value; // 0\\n * gen.next().value; // 1\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3587812,
                "title": "day-29-solution-javascript",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @return {Generator<number>}\\n */\\nvar fibGenerator = function*() {\\n    let a = 0;\\n    let b = 1;\\n\\n    while (true){\\n        yield a;\\n        [a,b] = [b, a+b];\\n    }\\n};\\n\\n/**\\n * const gen = fibGenerator();\\n * gen.next().value; // 0\\n * gen.next().value; // 1\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @return {Generator<number>}\\n */\\nvar fibGenerator = function*() {\\n    let a = 0;\\n    let b = 1;\\n\\n    while (true){\\n        yield a;\\n        [a,b] = [b, a+b];\\n    }\\n};\\n\\n/**\\n * const gen = fibGenerator();\\n * gen.next().value; // 0\\n * gen.next().value; // 1\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3587730,
                "title": "my-approach-js",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @return {Generator<number>}\\n */\\nvar fibGenerator = function*() {\\n    let f = 0;\\n    let s = 1;\\n    yield f;\\n    yield s;\\n    while(true){\\n        yield f+s;\\n        let temp = s;\\n        s = f+s;\\n        f = temp;\\n    }\\n};\\n\\n/**\\n * const gen = fibGenerator();\\n * gen.next().value; // 0\\n * gen.next().value; // 1\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @return {Generator<number>}\\n */\\nvar fibGenerator = function*() {\\n    let f = 0;\\n    let s = 1;\\n    yield f;\\n    yield s;\\n    while(true){\\n        yield f+s;\\n        let temp = s;\\n        s = f+s;\\n        f = temp;\\n    }\\n};\\n\\n/**\\n * const gen = fibGenerator();\\n * gen.next().value; // 0\\n * gen.next().value; // 1\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3587715,
                "title": "javascript",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @return {Generator<number>}\\n */\\nvar fibGenerator = function*() {\\n  let a = 0;\\n  let b = 1;\\n  let temp = [0,1]\\n\\n  yield a\\n  yield b\\n\\n  while(true){\\n    let n = temp.length\\n    let c = temp[n-2] + temp[n-1]\\n    temp.push(c)\\n    yield c\\n  }\\n};\\n\\n/**\\n * const gen = fibGenerator();\\n * gen.next().value; // 0\\n * gen.next().value; // 1\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @return {Generator<number>}\\n */\\nvar fibGenerator = function*() {\\n  let a = 0;\\n  let b = 1;\\n  let temp = [0,1]\\n\\n  yield a\\n  yield b\\n\\n  while(true){\\n    let n = temp.length\\n    let c = temp[n-2] + temp[n-1]\\n    temp.push(c)\\n    yield c\\n  }\\n};\\n\\n/**\\n * const gen = fibGenerator();\\n * gen.next().value; // 0\\n * gen.next().value; // 1\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3587683,
                "title": "javascript-typescript-4-lines-time-space-o-1",
                "content": "# Complexity\\n- Time complexity: O(1)\\n- Space complexity: O(1)\\n\\n# Code\\n```\\nconst fibGenerator = function*() {\\n    let i = 0, j = 1\\n    yield i\\n    yield j\\n    while (1) yield j = i + ( i = j )\\n}\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "```\\nconst fibGenerator = function*() {\\n    let i = 0, j = 1\\n    yield i\\n    yield j\\n    while (1) yield j = i + ( i = j )\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3587656,
                "title": "day-29-easy-solution-in-js",
                "content": "\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @return {Generator<number>}\\n */\\nvar fibGenerator = function*() {\\n    for(let a=0,b=1;true;b+=a,a=b-a)yield a;\\n};\\n\\n/**\\n * const gen = fibGenerator();\\n * gen.next().value; // 0\\n * gen.next().value; // 1\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @return {Generator<number>}\\n */\\nvar fibGenerator = function*() {\\n    for(let a=0,b=1;true;b+=a,a=b-a)yield a;\\n};\\n\\n/**\\n * const gen = fibGenerator();\\n * gen.next().value; // 0\\n * gen.next().value; // 1\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3587647,
                "title": "using-js",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @return {Generator<number>}\\n */\\nvar fibGenerator = function*() {\\n    /*\\nIn JavaScript, the yield keyword is used in generator functions to pause and resume the execution of the function. It is part of the generator functionality introduced in ECMAScript 2015 (ES6).\\n    */\\n    let a = 0;\\n    let b = 1;\\n\\n    while(true){\\n        yield a;\\n        // [a,b] = [b,a+b]; using destructuring\\n        let temp = b;\\n        b = a+b;\\n        a = temp;\\n\\n        // console.log(a,b);\\n    }\\n};\\n\\n/**\\n * const gen = fibGenerator();\\n * gen.next().value; // 0\\n * gen.next().value; // 1\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @return {Generator<number>}\\n */\\nvar fibGenerator = function*() {\\n    /*\\nIn JavaScript, the yield keyword is used in generator functions to pause and resume the execution of the function. It is part of the generator functionality introduced in ECMAScript 2015 (ES6).\\n    */\\n    let a = 0;\\n    let b = 1;\\n\\n    while(true){\\n        yield a;\\n        // [a,b] = [b,a+b]; using destructuring\\n        let temp = b;\\n        b = a+b;\\n        a = temp;\\n\\n        // console.log(a,b);\\n    }\\n};\\n\\n/**\\n * const gen = fibGenerator();\\n * gen.next().value; // 0\\n * gen.next().value; // 1\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3587644,
                "title": "typescript-solution-using-shifted-array",
                "content": "\\n```\\nfunction* fibGenerator(): Generator<number, any, number> {\\n  const fib = [0, 1, 1];\\n  while (true) {\\n    yield fib.shift()!;\\n    fib.push(fib[0] + fib[1]);\\n  }\\n}\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\nfunction* fibGenerator(): Generator<number, any, number> {\\n  const fib = [0, 1, 1];\\n  while (true) {\\n    yield fib.shift()!;\\n    fib.push(fib[0] + fib[1]);\\n  }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3587605,
                "title": "js-simple-and-easy-to-understand-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @return {Generator<number>}\\n */\\nvar fibGenerator = function*() {\\n    yield 0;\\n    yield 1;\\n    let a=1,b=0,c=0;\\n    while(true){\\n      c=a+b;\\n      b=a;\\n      a=c;\\n      yield c;\\n    }\\n};\\n\\n/**\\n * const gen = fibGenerator();\\n * gen.next().value; // 0\\n * gen.next().value; // 1\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @return {Generator<number>}\\n */\\nvar fibGenerator = function*() {\\n    yield 0;\\n    yield 1;\\n    let a=1,b=0,c=0;\\n    while(true){\\n      c=a+b;\\n      b=a;\\n      a=c;\\n      yield c;\\n    }\\n};\\n\\n/**\\n * const gen = fibGenerator();\\n * gen.next().value; // 0\\n * gen.next().value; // 1\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3587567,
                "title": "shortest-code",
                "content": "# Complexity\\n- Time complexity: O(1) for each `next` operation\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @return {Generator<number>}\\n */\\nvar fibGenerator = function*() {\\n    let a=0, b=1;\\n    while(true) {\\n        yield a;\\n        b += a;\\n        a = b-a;\\n    }\\n};\\n\\n/**\\n * const gen = fibGenerator();\\n * gen.next().value; // 0\\n * gen.next().value; // 1\\n */\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Math"
                ],
                "code": "```\\n/**\\n * @return {Generator<number>}\\n */\\nvar fibGenerator = function*() {\\n    let a=0, b=1;\\n    while(true) {\\n        yield a;\\n        b += a;\\n        a = b-a;\\n    }\\n};\\n\\n/**\\n * const gen = fibGenerator();\\n * gen.next().value; // 0\\n * gen.next().value; // 1\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3587554,
                "title": "javascript-yield-2-state-dp",
                "content": "```\\n/**\\n * @return {Generator<number>}\\n */\\n\\nvar fibGenerator = function*() {\\n\\n    let last1 = 0\\n    let last2 = 1\\n\\n    yield 0\\n    yield 1\\n    \\n    while (true) {\\n        let res = last1 + last2\\n        last1 = last2\\n        last2 = res\\n        yield res\\n    }\\n\\n};",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @return {Generator<number>}\\n */\\n\\nvar fibGenerator = function*() {\\n\\n    let last1 = 0\\n    let last2 = 1\\n\\n    yield 0\\n    yield 1\\n    \\n    while (true) {\\n        let res = last1 + last2\\n        last1 = last2\\n        last2 = res\\n        yield res\\n    }\\n\\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 3587542,
                "title": "day-29",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @return {Generator<number>}\\n */\\nvar fibGenerator = function*() {\\n  let x1 = 0, x2 = 1;\\n  while (true) {\\n    yield x1;\\n    [x1, x2] = [x2, x1 + x2];\\n  }\\n};\\n\\n/**\\n * const gen = fibGenerator();\\n * gen.next().value; // 0\\n * gen.next().value; // 1\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @return {Generator<number>}\\n */\\nvar fibGenerator = function*() {\\n  let x1 = 0, x2 = 1;\\n  while (true) {\\n    yield x1;\\n    [x1, x2] = [x2, x1 + x2];\\n  }\\n};\\n\\n/**\\n * const gen = fibGenerator();\\n * gen.next().value; // 0\\n * gen.next().value; // 1\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3583796,
                "title": "2648-generate-fibonacci-sequence",
                "content": "# Code\\n```\\n/**\\n * @return {Generator<number>}\\n */\\nvar fibGenerator = function*() {\\n    let a = 0;\\n    let b = 1;\\n    let temp = 0;\\n    while(true) {\\n        yield a;\\n        temp = a + b\\n        a = b;\\n        b = temp;\\n    }\\n};\\n\\n/**\\n * const gen = fibGenerator();\\n * gen.next().value; // 0\\n * gen.next().value; // 1\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @return {Generator<number>}\\n */\\nvar fibGenerator = function*() {\\n    let a = 0;\\n    let b = 1;\\n    let temp = 0;\\n    while(true) {\\n        yield a;\\n        temp = a + b\\n        a = b;\\n        b = temp;\\n    }\\n};\\n\\n/**\\n * const gen = fibGenerator();\\n * gen.next().value; // 0\\n * gen.next().value; // 1\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3575089,
                "title": "easy-js-solution-using-while-loop",
                "content": "# Code\\n```\\n/**\\n * @return {Generator<number>}\\n */\\nvar fibGenerator = function*() {\\n    yield x = 0; \\n    yield y = 1;\\n    while(true) {\\n        const next = x + y\\n        x = y\\n        y = next\\n        yield next\\n    }\\n};\\n\\n/**\\n * const gen = fibGenerator();\\n * gen.next().value; // 0\\n * gen.next().value; // 1\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @return {Generator<number>}\\n */\\nvar fibGenerator = function*() {\\n    yield x = 0; \\n    yield y = 1;\\n    while(true) {\\n        const next = x + y\\n        x = y\\n        y = next\\n        yield next\\n    }\\n};\\n\\n/**\\n * const gen = fibGenerator();\\n * gen.next().value; // 0\\n * gen.next().value; // 1\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3557659,
                "title": "javascript-very-easy-solution-o-n-beats-100",
                "content": "# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @return {Generator<number>}\\n */\\nvar fibGenerator = function*() {\\n    let x = 0, y = 1;\\n    while(true) {\\n        yield x;\\n        yield y;\\n        x = x + y;\\n        y = x + y;\\n    }\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @return {Generator<number>}\\n */\\nvar fibGenerator = function*() {\\n    let x = 0, y = 1;\\n    while(true) {\\n        yield x;\\n        yield y;\\n        x = x + y;\\n        y = x + y;\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3553476,
                "title": "javascript-with-comments-begineer-friendly",
                "content": "# Intuition\\nIn JavaScript, yield is used to pause the execution of a function. When the function is invoked again, the execution continues from the last yield statement. A generator returns a generator object, which is an iterator. This object generates one value at a time and then pauses execution.\\n\\n# Code\\n```\\nvar fibGenerator = function*() {\\n    let a = 0, b = 1;\\n    while(true) {\\n        yield a; // Gives value of a and pause the function\\n        [a, b] = [b, a+b]; // Get next value of Fibonacci Sequence\\n    }\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar fibGenerator = function*() {\\n    let a = 0, b = 1;\\n    while(true) {\\n        yield a; // Gives value of a and pause the function\\n        [a, b] = [b, a+b]; // Get next value of Fibonacci Sequence\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3551850,
                "title": "yield-simplest-solution-in-js",
                "content": "# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\n/**\\n * @return {Generator<number>}\\n */\\nvar fibGenerator = function*() {\\n\\n    var a = 0;\\n    var b = 1;\\n\\n    while(true) {\\n        yield a;\\n        var temp = a;\\n        a = b;\\n        b = temp+b;\\n    }\\n    \\n};\\n\\n/**\\n * const gen = fibGenerator();\\n * gen.next().value; // 0\\n * gen.next().value; // 1\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @return {Generator<number>}\\n */\\nvar fibGenerator = function*() {\\n\\n    var a = 0;\\n    var b = 1;\\n\\n    while(true) {\\n        yield a;\\n        var temp = a;\\n        a = b;\\n        b = temp+b;\\n    }\\n    \\n};\\n\\n/**\\n * const gen = fibGenerator();\\n * gen.next().value; // 0\\n * gen.next().value; // 1\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3526432,
                "title": "js-using-only-2-variables",
                "content": "\\n# Code\\n```\\n/**\\n * @return {Generator<number>}\\n */\\nvar fibGenerator = function*() {\\n    let a = 0\\n    let b = 1 \\n\\n    while(true) {\\n        if (b === 1) {\\n            yield a ? 1 : 0\\n        }\\n\\n        b = a + b;\\n        a = b - a;\\n        yield b \\n    }\\n};\\n\\n/**\\n * const gen = fibGenerator();\\n * gen.next().value; // 0\\n * gen.next().value; // 1\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @return {Generator<number>}\\n */\\nvar fibGenerator = function*() {\\n    let a = 0\\n    let b = 1 \\n\\n    while(true) {\\n        if (b === 1) {\\n            yield a ? 1 : 0\\n        }\\n\\n        b = a + b;\\n        a = b - a;\\n        yield b \\n    }\\n};\\n\\n/**\\n * const gen = fibGenerator();\\n * gen.next().value; // 0\\n * gen.next().value; // 1\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3519908,
                "title": "javascript-1line-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @return {Generator<number>}\\n */\\n    var fibGenerator = function*() {\\n    for (let a = 0, b = 1; true; b += a, a = b - a) yield a;\\n};\\n\\n/**\\n * const gen = fibGenerator();\\n * gen.next().value; // 0\\n * gen.next().value; // 1\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @return {Generator<number>}\\n */\\n    var fibGenerator = function*() {\\n    for (let a = 0, b = 1; true; b += a, a = b - a) yield a;\\n};\\n\\n/**\\n * const gen = fibGenerator();\\n * gen.next().value; // 0\\n * gen.next().value; // 1\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3513744,
                "title": "js-easy-solution",
                "content": "# Code\\n```\\n\\nvar fibGenerator = function*() {\\n    let a = 0;\\n    let b = 1;\\n    while (true){\\n        yield a;\\n        [a,b] = [b,a+b]\\n    } \\n};\\n // Note : The yield operator is used to pause and resume a generator function.",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "# Code\\n```\\n\\nvar fibGenerator = function*() {\\n    let a = 0;\\n    let b = 1;\\n    while (true){\\n        yield a;\\n        [a,b] = [b,a+b]\\n    } \\n};\\n // Note : The yield operator is used to pause and resume a generator function.",
                "codeTag": "Unknown"
            },
            {
                "id": 3508663,
                "title": "fibonacci-generator",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @return {Generator<number>}\\n */\\nvar fibGenerator = function* () {\\n  let a = 0,\\n    b = 1,\\n    c\\n  yield a\\n  yield b\\n  while (true) {\\n    yield (c = a + b)\\n    a = b\\n    b = c\\n  }\\n}\\n\\n/**\\n * const gen = fibGenerator();\\n * gen.next().value; // 0\\n * gen.next().value; // 1\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @return {Generator<number>}\\n */\\nvar fibGenerator = function* () {\\n  let a = 0,\\n    b = 1,\\n    c\\n  yield a\\n  yield b\\n  while (true) {\\n    yield (c = a + b)\\n    a = b\\n    b = c\\n  }\\n}\\n\\n/**\\n * const gen = fibGenerator();\\n * gen.next().value; // 0\\n * gen.next().value; // 1\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3508497,
                "title": "javascript-solution-easy-to-understand",
                "content": "\\n# Code\\n```\\n/**\\n * @return {Generator<number>}\\n */\\nvar fibGenerator = function*() {\\n    var i = 1, fb = [0, 1];\\n    yield 0;\\n    while (true) {\\n        yield fb[i++ % 2] = fb[i % 2] + fb[(i + 1) % 2];\\n    }\\n};\\n\\n/**\\n * const gen = fibGenerator();\\n * gen.next().value; // 0\\n * gen.next().value; // 1\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @return {Generator<number>}\\n */\\nvar fibGenerator = function*() {\\n    var i = 1, fb = [0, 1];\\n    yield 0;\\n    while (true) {\\n        yield fb[i++ % 2] = fb[i % 2] + fb[(i + 1) % 2];\\n    }\\n};\\n\\n/**\\n * const gen = fibGenerator();\\n * gen.next().value; // 0\\n * gen.next().value; // 1\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3505665,
                "title": "simple-js-solution",
                "content": "# Code\\n```\\n/**\\n * @return {Generator<number>}\\n */\\nvar fibGenerator = function*() {\\n    let a = 0, b = 1, c = 0;\\n    yield a;\\n    yield b;\\n    while (true) {\\n        c = a + b;\\n        a = b;\\n        b = c;\\n        yield c;\\n    }\\n};\\n\\n/**\\n * const gen = fibGenerator();\\n * gen.next().value; // 0\\n * gen.next().value; // 1\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @return {Generator<number>}\\n */\\nvar fibGenerator = function*() {\\n    let a = 0, b = 1, c = 0;\\n    yield a;\\n    yield b;\\n    while (true) {\\n        c = a + b;\\n        a = b;\\n        b = c;\\n        yield c;\\n    }\\n};\\n\\n/**\\n * const gen = fibGenerator();\\n * gen.next().value; // 0\\n * gen.next().value; // 1\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3501454,
                "title": "yield",
                "content": "# Code\\n```\\n/**\\n * @return {Generator<number>}\\n */\\nvar fibGenerator = function*() {\\n    yield 0;\\n    yield 1;\\n    let a = 0 ,b = 1;\\n    while(true){\\n        yield a + b;\\n        [a,b] = [b,a+b];\\n    }\\n};\\n\\n/**\\n * const gen = fibGenerator();\\n * gen.next().value; // 0\\n * gen.next().value; // 1\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @return {Generator<number>}\\n */\\nvar fibGenerator = function*() {\\n    yield 0;\\n    yield 1;\\n    let a = 0 ,b = 1;\\n    while(true){\\n        yield a + b;\\n        [a,b] = [b,a+b];\\n    }\\n};\\n\\n/**\\n * const gen = fibGenerator();\\n * gen.next().value; // 0\\n * gen.next().value; // 1\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3498678,
                "title": "javascript-solution-s-per-easy-to-understand",
                "content": "```javascript\\n/**\\n * @return {Generator<number>}\\n */\\nvar fibGenerator = function*() {\\n    let a = 0, b = 1;\\n    while (true) {\\n        yield a;\\n        [a, b] = [b, a + b];\\n    }\\n};\\n\\n/**\\n * const gen = fibGenerator();\\n * gen.next().value; // 0\\n * gen.next().value; // 1\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```javascript\\n/**\\n * @return {Generator<number>}\\n */\\nvar fibGenerator = function*() {\\n    let a = 0, b = 1;\\n    while (true) {\\n        yield a;\\n        [a, b] = [b, a + b];\\n    }\\n};\\n\\n/**\\n * const gen = fibGenerator();\\n * gen.next().value; // 0\\n * gen.next().value; // 1\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3497333,
                "title": "easy-solution-with-for",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @return {Generator<number>}\\n */\\nvar fibGenerator = function* () {\\n    let a = 1;\\n    let b = 0;\\n\\n    for (let i = 3; ; i++) {\\n        let c = a + b;\\n        a = b;\\n        b = c;\\n        yield a;\\n    }\\n};\\n\\n/**\\n * const gen = fibGenerator();\\n * gen.next().value; // 0\\n * gen.next().value; // 1\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @return {Generator<number>}\\n */\\nvar fibGenerator = function* () {\\n    let a = 1;\\n    let b = 0;\\n\\n    for (let i = 3; ; i++) {\\n        let c = a + b;\\n        a = b;\\n        b = c;\\n        yield a;\\n    }\\n};\\n\\n/**\\n * const gen = fibGenerator();\\n * gen.next().value; // 0\\n * gen.next().value; // 1\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3496762,
                "title": "easy-to-understand-solution-using-yield",
                "content": "Please Upvote if it helps you!\\n# Code\\n```\\nfunction* fibGenerator(): Generator<number, any, number> {\\n    yield 0;\\n    yield 1;\\n    \\n    let previous = 0;\\n    let current = 1;\\n    let next = 0;\\n\\n    while(true) {\\n        next = previous + current;\\n        previous = current;\\n        current = next;\\n        yield next;\\n    }\\n};\\n\\n/**\\n * const gen = fibGenerator();\\n * gen.next().value; // 0\\n * gen.next().value; // 1\\n */\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\nfunction* fibGenerator(): Generator<number, any, number> {\\n    yield 0;\\n    yield 1;\\n    \\n    let previous = 0;\\n    let current = 1;\\n    let next = 0;\\n\\n    while(true) {\\n        next = previous + current;\\n        previous = current;\\n        current = next;\\n        yield next;\\n    }\\n};\\n\\n/**\\n * const gen = fibGenerator();\\n * gen.next().value; // 0\\n * gen.next().value; // 1\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3491744,
                "title": "javascript-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @return {Generator<number>}\\n */\\nvar fibGenerator = function*() {\\n    let x = 0;\\n    let y = 1;\\n    yield x;\\n    yield y;\\n    while(true){\\n        let z= x+y;\\n        yield z\\n        x=y\\n        y=z\\n    }\\n};\\n\\n/**\\n * const gen = fibGenerator();\\n * gen.next().value; // 0\\n * gen.next().value; // 1\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @return {Generator<number>}\\n */\\nvar fibGenerator = function*() {\\n    let x = 0;\\n    let y = 1;\\n    yield x;\\n    yield y;\\n    while(true){\\n        let z= x+y;\\n        yield z\\n        x=y\\n        y=z\\n    }\\n};\\n\\n/**\\n * const gen = fibGenerator();\\n * gen.next().value; // 0\\n * gen.next().value; // 1\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3489863,
                "title": "js-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(1)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\n/**\\n * @return {Generator<number>}\\n */\\n\\nvar fibGenerator = function*() {\\n    let x= 0;\\n    let y= 1;\\n\\n    while (true){\\n        yield x;\\n        let t = x;\\n        x = y;\\n        y = t + y;\\n    }\\n};\\n\\n/**\\n * const gen = fibGenerator();\\n * gen.next().value; // 0\\n * gen.next().value; // 1\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @return {Generator<number>}\\n */\\n\\nvar fibGenerator = function*() {\\n    let x= 0;\\n    let y= 1;\\n\\n    while (true){\\n        yield x;\\n        let t = x;\\n        x = y;\\n        y = t + y;\\n    }\\n};\\n\\n/**\\n * const gen = fibGenerator();\\n * gen.next().value; // 0\\n * gen.next().value; // 1\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3486235,
                "title": "js-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @return {Generator<number>}\\n */\\nvar fibGenerator = function*() {\\n    let first = 0;\\n    let second = 1;\\n\\n    yield first;\\n    yield second;\\n\\n    while(true){\\n\\n        let newNum = first + second;\\n        yield newNum;\\n\\n        first = second;\\n        second = newNum;\\n\\n    }\\n    \\n};\\n\\n/**\\n * const gen = fibGenerator();\\n * gen.next().value; // 0\\n * gen.next().value; // 1\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @return {Generator<number>}\\n */\\nvar fibGenerator = function*() {\\n    let first = 0;\\n    let second = 1;\\n\\n    yield first;\\n    yield second;\\n\\n    while(true){\\n\\n        let newNum = first + second;\\n        yield newNum;\\n\\n        first = second;\\n        second = newNum;\\n\\n    }\\n    \\n};\\n\\n/**\\n * const gen = fibGenerator();\\n * gen.next().value; // 0\\n * gen.next().value; // 1\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3483755,
                "title": "easy-javascript-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @return {Generator<number>}\\n */\\nvar fibGenerator = function* () {\\n    let x = 0, y = 1\\n    yield x\\n    yield y\\n    while (true) {\\n        let z = x + y\\n        yield z\\n        x = y\\n        y = z\\n    }\\n};\\n\\n/**\\n * const gen = fibGenerator();\\n * gen.next().value; // 0\\n * gen.next().value; // 1\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @return {Generator<number>}\\n */\\nvar fibGenerator = function* () {\\n    let x = 0, y = 1\\n    yield x\\n    yield y\\n    while (true) {\\n        let z = x + y\\n        yield z\\n        x = y\\n        y = z\\n    }\\n};\\n\\n/**\\n * const gen = fibGenerator();\\n * gen.next().value; // 0\\n * gen.next().value; // 1\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3483091,
                "title": "typescript",
                "content": "# Intuition\\nMy first thoughts on solving this problem were to use a generator function to create an iterable object that yields the Fibonacci sequence one number at a time. This way, we can efficiently generate the sequence without calculating and storing all values at once.\\n\\n# Approach\\n1. Create a generator function `fibGenerator` that yields the Fibonacci sequence.\\n2. Initialize two variables `a` and `b` with the first two numbers of the Fibonacci sequence (0 and 1).\\n3. Use an infinite loop to continually generate the next numbers in the sequence.\\n4. In each iteration, yield the current value of `a`, then update the values of `a` and `b` to generate the next number in the sequence.\\n\\n# Complexity\\n- Time complexity: $$O(n)$$, where `n` is the number of calls to the generator\\'s `next` method. The generator only computes the next number in the sequence when requested, so the time complexity for each call to `next` is $$O(1)$$.\\n\\n- Space complexity: $$O(1)$$, as the generator only stores two numbers (`a` and `b`) at a time, regardless of the number of calls to the `next` method.\\n\\n# Code\\n```\\nfunction* fibGenerator(): Generator<number, any, number> {\\n    let a = 0;\\n    let b = 1;\\n    \\n    while (true) {\\n        yield a;\\n        [a, b] = [b, a + b];\\n    }\\n};\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\nfunction* fibGenerator(): Generator<number, any, number> {\\n    let a = 0;\\n    let b = 1;\\n    \\n    while (true) {\\n        yield a;\\n        [a, b] = [b, a + b];\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3483088,
                "title": "easiest-solution-for-beginners",
                "content": "\\n\\n# Code\\n```\\n/**\\n * @return {Generator<number>}\\n */\\nvar fibGenerator = function*() {\\n    var value1 = 0;\\n    var value2 = 1;\\n    \\n    while(true) {\\n        yield value1;\\n        value2 +=value1;\\n        value1 = value2-value1;\\n    }\\n};\\n\\n/**\\n * const gen = fibGenerator();\\n * gen.next().value; // 0\\n * gen.next().value; // 1\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @return {Generator<number>}\\n */\\nvar fibGenerator = function*() {\\n    var value1 = 0;\\n    var value2 = 1;\\n    \\n    while(true) {\\n        yield value1;\\n        value2 +=value1;\\n        value1 = value2-value1;\\n    }\\n};\\n\\n/**\\n * const gen = fibGenerator();\\n * gen.next().value; // 0\\n * gen.next().value; // 1\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3477378,
                "title": "array-based-3-liner",
                "content": "# Intuition\\nI choose an array as a datastructure to hold the results, as it provides fast access to adding and removing elements on it\\'s ends.\\n\\n# Approach\\nThe most non-trivial thing here was the meaning of generaror function. It was not obvious for me that on *yield* the current execution of *next()* is paused and *.value* available as an value next to *yield*. On subsequent *next()* calls, execution is started from the next line of previous *yield*.\\n\\n# Complexity\\n- Time complexity: $$O(1)$$\\n\\n- Space complexity: $$O(1)$$\\n\\n# Code\\n```\\nfunction* fibGenerator(): Generator<number, any, number> {\\n    const fib = [0, 1];\\n    while (true) {\\n        fib.push(fib[0] + fib[1]);\\n        yield fib.shift();\\n    }\\n};\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\nfunction* fibGenerator(): Generator<number, any, number> {\\n    const fib = [0, 1];\\n    while (true) {\\n        fib.push(fib[0] + fib[1]);\\n        yield fib.shift();\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3466420,
                "title": "easy-solution",
                "content": "# Code\\n```\\n/**\\n * @return {Generator<number>}\\n */\\nvar fibGenerator = function*() {\\n    let a = 0;\\n    let b = 1;\\n    while(true) {\\n        yield a;\\n        let c = a + b;\\n        a = b;\\n        b = c;\\n    }\\n};\\n\\n/**\\n * const gen = fibGenerator();\\n * gen.next().value; // 0\\n * gen.next().value; // 1\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @return {Generator<number>}\\n */\\nvar fibGenerator = function*() {\\n    let a = 0;\\n    let b = 1;\\n    while(true) {\\n        yield a;\\n        let c = a + b;\\n        a = b;\\n        b = c;\\n    }\\n};\\n\\n/**\\n * const gen = fibGenerator();\\n * gen.next().value; // 0\\n * gen.next().value; // 1\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3462105,
                "title": "easy-solution-ts",
                "content": "\\n# Code\\n```\\nfunction* fibGenerator(): Generator<number, any, number> {\\n    yield* generator();\\n};\\n\\nfunction* generator () {\\n    let f_0 = 0, f_1 = 1;\\n\\n    yield f_0;\\n    yield f_1;\\n\\n    while (true) {\\n        yield f_0 + f_1;\\n\\n        let temp = f_0;\\n        f_0 = f_1;\\n        f_1 = temp + f_1;\\n    }\\n}",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "\\n# Code\\n```\\nfunction* fibGenerator(): Generator<number, any, number> {\\n    yield* generator();\\n};\\n\\nfunction* generator () {\\n    let f_0 = 0, f_1 = 1;\\n\\n    yield f_0;\\n    yield f_1;\\n\\n    while (true) {\\n        yield f_0 + f_1;\\n\\n        let temp = f_0;\\n        f_0 = f_1;\\n        f_1 = temp + f_1;\\n    }\\n}",
                "codeTag": "Unknown"
            },
            {
                "id": 3460679,
                "title": "accepted-javascript",
                "content": "```\\nvar fibGenerator = function*() {\\n\\n    var prev = 0;\\n    var cur = 1;\\n\\n    while (true) {\\n        yield prev;\\n        [prev, cur] = [cur, prev + cur];\\n    }\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar fibGenerator = function*() {\\n\\n    var prev = 0;\\n    var cur = 1;\\n\\n    while (true) {\\n        yield prev;\\n        [prev, cur] = [cur, prev + cur];\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3460191,
                "title": "simple-ts-js-solutions",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @return {Generator<number>}\\n */\\nvar fibGenerator = function*() {\\n    yield 0;\\n    yield 1;\\n    const list= [0,1];\\n    for(let i=0; i<list.length; i++){\\n        const value=list[list.length-1] + list[list.length-2];\\n        list.push(value)\\n        yield value\\n    }\\n};\\n\\n/**\\n * const gen = fibGenerator();\\n * gen.next().value; // 0\\n * gen.next().value; // 1\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @return {Generator<number>}\\n */\\nvar fibGenerator = function*() {\\n    yield 0;\\n    yield 1;\\n    const list= [0,1];\\n    for(let i=0; i<list.length; i++){\\n        const value=list[list.length-1] + list[list.length-2];\\n        list.push(value)\\n        yield value\\n    }\\n};\\n\\n/**\\n * const gen = fibGenerator();\\n * gen.next().value; // 0\\n * gen.next().value; // 1\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3459691,
                "title": "easy-to-understand-using-array",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @return {Generator<number>}\\n */\\nvar fibGenerator = function*() {\\n    let arr = [0,1];\\n    let i = 0;\\n    let k = 0;\\n    let m = 1;\\n    while (true) {\\n        yield arr[i];\\n        arr.push(arr[k]+arr[m]);\\n        k++;\\n        m++;\\n        i++;\\n    }\\n};\\n\\n\\n/**\\nThis is more efficient \\nlet [prev, curr] = [0, 1];\\n  while (true) {\\n    yield prev;\\n    [prev, curr] = [curr, prev + curr];\\n  }\\n*/\\n\\n/**\\n * const gen = fibGenerator();\\n * gen.next().value; // 0\\n * gen.next().value; // 1\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @return {Generator<number>}\\n */\\nvar fibGenerator = function*() {\\n    let arr = [0,1];\\n    let i = 0;\\n    let k = 0;\\n    let m = 1;\\n    while (true) {\\n        yield arr[i];\\n        arr.push(arr[k]+arr[m]);\\n        k++;\\n        m++;\\n        i++;\\n    }\\n};\\n\\n\\n/**\\nThis is more efficient \\nlet [prev, curr] = [0, 1];\\n  while (true) {\\n    yield prev;\\n    [prev, curr] = [curr, prev + curr];\\n  }\\n*/\\n\\n/**\\n * const gen = fibGenerator();\\n * gen.next().value; // 0\\n * gen.next().value; // 1\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3459677,
                "title": "easy-to-understand-using-array",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @return {Generator<number>}\\n */\\nvar fibGenerator = function*() {\\n    let arr = [0,1];\\n    let i = 0;\\n    let k = 0;\\n    let m = 1;\\n    while (true) {\\n        yield arr[i];\\n        arr.push(arr[k]+arr[m]);\\n        k++;\\n        m++;\\n        i++;\\n    }\\n};\\n\\n/**\\n * const gen = fibGenerator();\\n * gen.next().value; // 0\\n * gen.next().value; // 1\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @return {Generator<number>}\\n */\\nvar fibGenerator = function*() {\\n    let arr = [0,1];\\n    let i = 0;\\n    let k = 0;\\n    let m = 1;\\n    while (true) {\\n        yield arr[i];\\n        arr.push(arr[k]+arr[m]);\\n        k++;\\n        m++;\\n        i++;\\n    }\\n};\\n\\n/**\\n * const gen = fibGenerator();\\n * gen.next().value; // 0\\n * gen.next().value; // 1\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3456343,
                "title": "simple-and-easy-solution-typescript-js",
                "content": "# Code\\n```\\nfunction* fibGenerator(): Generator<number, any, number> {\\n    let prev_num = 0;\\n    let curr_num = 1;\\n    yield prev_num; // first next\\n    yield curr_num; // second next\\n\\n    // inifinite loop\\n    // next seconds, many nexts\\n    while (true){\\n        const temp_num = curr_num;\\n        curr_num += prev_num;\\n        prev_num = temp_num;\\n        yield curr_num;\\n    }\\n\\n};\\n\\n/**\\n * const gen = fibGenerator();\\n * gen.next().value; // 0\\n * gen.next().value; // 1\\n */\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "```\\nfunction* fibGenerator(): Generator<number, any, number> {\\n    let prev_num = 0;\\n    let curr_num = 1;\\n    yield prev_num; // first next\\n    yield curr_num; // second next\\n\\n    // inifinite loop\\n    // next seconds, many nexts\\n    while (true){\\n        const temp_num = curr_num;\\n        curr_num += prev_num;\\n        prev_num = temp_num;\\n        yield curr_num;\\n    }\\n\\n};\\n\\n/**\\n * const gen = fibGenerator();\\n * gen.next().value; // 0\\n * gen.next().value; // 1\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3453841,
                "title": "100-short-typesrcipt-click",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @return {Generator<number>}\\n */\\nvar fibGenerator = function*() {\\n    let i = 2;\\n    let mem = {0: 0, 1: 1};\\n    yield mem[0];\\n    yield mem[1];\\n    while(true) {\\n        mem[i] = mem[i-1] + mem[i-2];\\n        yield mem[i];\\n        i++;\\n    }\\n};\\n\\n/**\\n * const gen = fibGenerator();\\n * gen.next().value; // 0\\n * gen.next().value; // 1\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @return {Generator<number>}\\n */\\nvar fibGenerator = function*() {\\n    let i = 2;\\n    let mem = {0: 0, 1: 1};\\n    yield mem[0];\\n    yield mem[1];\\n    while(true) {\\n        mem[i] = mem[i-1] + mem[i-2];\\n        yield mem[i];\\n        i++;\\n    }\\n};\\n\\n/**\\n * const gen = fibGenerator();\\n * gen.next().value; // 0\\n * gen.next().value; // 1\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3453657,
                "title": "2648-generate-fibonacci-sequence-javascript-accepted",
                "content": "\\n When a function is marked as a generator using the  function* syntax, it can use the yield keyword to produce a value that can be retrieved by the caller. \\n\\nThe generator function will pause its execution at the yield statement and return the value specified in the statement to the caller. The generator function can then be resumed by calling the next() method on the generator object.\\n\\n\\n# Code\\n```\\n/**\\n * @return {Generator<number>}\\n */\\nvar fibGenerator = function*() {\\nlet prev = 0;\\nlet curr = 1;\\nyield prev;\\nyield curr;\\nwhile(true) {\\n  let val = prev + curr;\\n  yield val;\\n  prev = curr;\\n  curr = val;\\n  }\\n};\\n\\n/**\\n * const gen = fibGenerator();\\n * gen.next().value; // 0\\n * gen.next().value; // 1\\n */\\n```\\nif u want any explanation ,please comment below , **HAPPY to HELP YOU!!**\\nif u Like\\uD83E\\uDD70 Please **UPVOTE** !!\\nThank You \\nHappy Coding!\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @return {Generator<number>}\\n */\\nvar fibGenerator = function*() {\\nlet prev = 0;\\nlet curr = 1;\\nyield prev;\\nyield curr;\\nwhile(true) {\\n  let val = prev + curr;\\n  yield val;\\n  prev = curr;\\n  curr = val;\\n  }\\n};\\n\\n/**\\n * const gen = fibGenerator();\\n * gen.next().value; // 0\\n * gen.next().value; // 1\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3453528,
                "title": "ts-lazy-tabulation-approach-98-time-50ms-80-space-42-7mb",
                "content": "Ah, good old Fibonacci, the father of Dynamic Programming in the mind of many students. Also, a Tuscan like Leonardo da Vinci, Niccol\\xF2 Macchiavelli... and me \\uD83D\\uDE06!\\n\\nBut enough with the trivia bit; assuming we all encountered before, let\\'s go straight to the point, by initially declaring:\\n* `i`, our pointer, initially set to `0`;\\n* `fibs`, our collections of Fibonacci numbers.\\n\\nOur main loop will forever (`while (true)`, since we know the number of calls will never overflow):\\n* check if `i` is now pointing outside the current boundaries of `fibs` (ie: `i == fibs.length`) and in case append an element given by the sum of the last two to it;\\n* `yield` `fibs[i]`;\\n* increase `i` by `1`.\\n\\n# Complexity\\n- Time complexity: $$O(1)$$ (for each call)\\n- Space complexity: $$O(n)$$\\n\\n# Code\\n```ts\\nfunction* fibGenerator(): Generator<number, any, number> {\\n    let i = 0, fibs = [0, 1];\\n    while (true) {\\n        if (i == fibs.length) fibs.push(fibs[i - 1] + fibs[i - 2]);\\n        yield fibs[i++];\\n    }\\n};\\n```\\n\\nCan we do better? Well, since we do not need to store the whole sequence, but just the last two values, definitely so!\\n\\nWe will just declare `a` and `b` initially set to be `0` and `1` respectively, `return` `i` for the first `2` iterations and then `return` `b` computed as the sum of the previous two values, updating `a` to take the previous `b` value a we go.\\n\\nSo, for example:\\n\\n```ts\\ni = 0, a = 0, b = 1 => i // which is 0 - initial run\\ni = 1, a = 0, b = 1 => i // which is 1 - second run\\ni = 2, a = 1, b = 1 => b // which is 1 - third run\\ni = 2, a = 1, b = 2 => b // which is 2 - fourth run\\ni = 2, a = 2, b = 3 => b // which is 3 - fifth run\\ni = 2, a = 3, b = 5 => b // which is 5 - sixth run\\ni = 2, a = 5, b = 8 => b // which is 5 - seventh run\\n...\\n```\\n\\nNotice we do not even waste computation updating `i` once it reaches the threshold of `2`, just computing the next Fibonacci number in a lazy way.\\n\\n# Complexity\\n- Time complexity: $$O(1)$$ (for each call)\\n- Space complexity: $$O(1)$$\\n\\n# Code\\n```ts\\nfunction* fibGenerator(): Generator<number, any, number> {\\n    let i = 0, [a, b] = [0, 1];\\n    while (true) {\\n        if (i >= 2) [b, a] = [a + b, b]; \\n        yield i < 2 ? i++ : b;\\n    }\\n};\\n```",
                "solutionTags": [
                    "TypeScript",
                    "Array",
                    "Dynamic Programming"
                ],
                "code": "```ts\\nfunction* fibGenerator(): Generator<number, any, number> {\\n    let i = 0, fibs = [0, 1];\\n    while (true) {\\n        if (i == fibs.length) fibs.push(fibs[i - 1] + fibs[i - 2]);\\n        yield fibs[i++];\\n    }\\n};\\n```\n```ts\\ni = 0, a = 0, b = 1 => i // which is 0 - initial run\\ni = 1, a = 0, b = 1 => i // which is 1 - second run\\ni = 2, a = 1, b = 1 => b // which is 1 - third run\\ni = 2, a = 1, b = 2 => b // which is 2 - fourth run\\ni = 2, a = 2, b = 3 => b // which is 3 - fifth run\\ni = 2, a = 3, b = 5 => b // which is 5 - sixth run\\ni = 2, a = 5, b = 8 => b // which is 5 - seventh run\\n...\\n```\n```ts\\nfunction* fibGenerator(): Generator<number, any, number> {\\n    let i = 0, [a, b] = [0, 1];\\n    while (true) {\\n        if (i >= 2) [b, a] = [a + b, b]; \\n        yield i < 2 ? i++ : b;\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3453085,
                "title": "using-while-loop-and-yield-keyword",
                "content": "# Code\\n```\\nconst fibGenerator = function*() {\\n    let [a,b] = [0,1];\\n    while(1){\\n        yield a;\\n        [a,b] = [b, a+b];\\n\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nconst fibGenerator = function*() {\\n    let [a,b] = [0,1];\\n    while(1){\\n        yield a;\\n        [a,b] = [b, a+b];\\n\\n\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3453009,
                "title": "javascript-ez-solution",
                "content": "# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(1)$$\\n# Code\\n```\\n/**\\n * @return {Generator<number>}\\n */\\nvar fibGenerator = function*() {\\n    let a = 0;\\n    let b = 1;\\n    while (true) {\\n        yield a;\\n        [a, b] = [b, a + b];\\n    }\\n};\\n\\n/**\\n * const gen = fibGenerator();\\n * gen.next().value; // 0\\n * gen.next().value; // 1\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @return {Generator<number>}\\n */\\nvar fibGenerator = function*() {\\n    let a = 0;\\n    let b = 1;\\n    while (true) {\\n        yield a;\\n        [a, b] = [b, a + b];\\n    }\\n};\\n\\n/**\\n * const gen = fibGenerator();\\n * gen.next().value; // 0\\n * gen.next().value; // 1\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3453002,
                "title": "javascript-beat-92-in-space-beat-88-in-time",
                "content": "# CODE \\n```\\nvar fibGenerator = function*() {\\n    let x = 0;\\n    let y = 1;\\n    yield x;\\n    yield y;\\n    \\n    while (true) {\\n        let temp = x + y;\\n        yield temp;\\n        x = y;\\n        y = temp;\\n    }\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar fibGenerator = function*() {\\n    let x = 0;\\n    let y = 1;\\n    yield x;\\n    yield y;\\n    \\n    while (true) {\\n        let temp = x + y;\\n        yield temp;\\n        x = y;\\n        y = temp;\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3451145,
                "title": "js-code-with-c-solution-too",
                "content": "\\n```\\nvar fibGenerator = function*() {\\n     for(fib=[-1,1]; ;yield (fib=[fib[1],fib[0]+fib[1]])[1]);       \\n};\\n```\\n\\nThe C++ solution for the same:\\n\\nstruct FibGenerator {\\n    int f[2] = {-1, 1};\\n    int operator() () {\\n        int temp = f[0];\\n        f[0] = f[1];\\n        f[1] += temp;\\n        return f[1];\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "JavaScript"
                ],
                "code": "```\\nvar fibGenerator = function*() {\\n     for(fib=[-1,1]; ;yield (fib=[fib[1],fib[0]+fib[1]])[1]);       \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3450170,
                "title": "answer-use-yield",
                "content": "# Code\\n```\\nfunction* fibGenerator(): Generator<number, any, number> {\\n    yield 0;\\n    yield 1;\\n    \\n    let a = 0, b = 1;\\n    \\n    while (1) {\\n        const c = a + b;\\n        [a, b] = [b, c];\\n        \\n        yield c;\\n    }\\n}\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\nfunction* fibGenerator(): Generator<number, any, number> {\\n    yield 0;\\n    yield 1;\\n    \\n    let a = 0, b = 1;\\n    \\n    while (1) {\\n        const c = a + b;\\n        [a, b] = [b, c];\\n        \\n        yield c;\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            }
        ],
        "discussions": [
            {
                "id": 1914243,
                "content": [
                    {
                        "username": "Selithrarion",
                        "content": "hmm i needed to add `;` (semicolon) after `yield a` \\uD83D\\uDE2F"
                    },
                    {
                        "username": "almostmonday",
                        "content": "If you\\'re looking for one line solution without destructuring assignment, it\\'s [here](https://leetcode.com/problems/generate-fibonacci-sequence/solutions/3451942/one-line-two-variables-without-destructuring-assignment/)."
                    },
                    {
                        "username": "I_AM_JD",
                        "content": "Why there is a need to add semi-colon  `;` after yield a"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "Cool to know that yield and generators exist in JS too, brings back Python memories "
                    },
                    {
                        "username": "Code_Sagar",
                        "content": "#Day29 : Done Solving Today\\'s Question \\uD83D\\uDE01\\n\\n\\nTip : You can use yield keyword in generator functions "
                    },
                    {
                        "username": "ildarum21",
                        "content": "My solution works in the browser, bit doesn\\'t work on leetcode. Returned nulls. Can someone explain?"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "It\\'s hard for anyone to help without seeing your code."
                    },
                    {
                        "username": "FrontEndDeveloping",
                        "content": "Why I can\\'t create solution from my code? Can someone explain?"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "To creat a solution you need to submit your code, when you then go to solutions and click on add solution it should automatically grab your last submission. It\\'s hard to say why it didn\\'t work for you without knowing what you did exactly."
                    }
                ]
            },
            {
                "id": 1873110,
                "content": [
                    {
                        "username": "Selithrarion",
                        "content": "hmm i needed to add `;` (semicolon) after `yield a` \\uD83D\\uDE2F"
                    },
                    {
                        "username": "almostmonday",
                        "content": "If you\\'re looking for one line solution without destructuring assignment, it\\'s [here](https://leetcode.com/problems/generate-fibonacci-sequence/solutions/3451942/one-line-two-variables-without-destructuring-assignment/)."
                    },
                    {
                        "username": "I_AM_JD",
                        "content": "Why there is a need to add semi-colon  `;` after yield a"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "Cool to know that yield and generators exist in JS too, brings back Python memories "
                    },
                    {
                        "username": "Code_Sagar",
                        "content": "#Day29 : Done Solving Today\\'s Question \\uD83D\\uDE01\\n\\n\\nTip : You can use yield keyword in generator functions "
                    },
                    {
                        "username": "ildarum21",
                        "content": "My solution works in the browser, bit doesn\\'t work on leetcode. Returned nulls. Can someone explain?"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "It\\'s hard for anyone to help without seeing your code."
                    },
                    {
                        "username": "FrontEndDeveloping",
                        "content": "Why I can\\'t create solution from my code? Can someone explain?"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "To creat a solution you need to submit your code, when you then go to solutions and click on add solution it should automatically grab your last submission. It\\'s hard to say why it didn\\'t work for you without knowing what you did exactly."
                    }
                ]
            },
            {
                "id": 1914475,
                "content": [
                    {
                        "username": "Selithrarion",
                        "content": "hmm i needed to add `;` (semicolon) after `yield a` \\uD83D\\uDE2F"
                    },
                    {
                        "username": "almostmonday",
                        "content": "If you\\'re looking for one line solution without destructuring assignment, it\\'s [here](https://leetcode.com/problems/generate-fibonacci-sequence/solutions/3451942/one-line-two-variables-without-destructuring-assignment/)."
                    },
                    {
                        "username": "I_AM_JD",
                        "content": "Why there is a need to add semi-colon  `;` after yield a"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "Cool to know that yield and generators exist in JS too, brings back Python memories "
                    },
                    {
                        "username": "Code_Sagar",
                        "content": "#Day29 : Done Solving Today\\'s Question \\uD83D\\uDE01\\n\\n\\nTip : You can use yield keyword in generator functions "
                    },
                    {
                        "username": "ildarum21",
                        "content": "My solution works in the browser, bit doesn\\'t work on leetcode. Returned nulls. Can someone explain?"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "It\\'s hard for anyone to help without seeing your code."
                    },
                    {
                        "username": "FrontEndDeveloping",
                        "content": "Why I can\\'t create solution from my code? Can someone explain?"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "To creat a solution you need to submit your code, when you then go to solutions and click on add solution it should automatically grab your last submission. It\\'s hard to say why it didn\\'t work for you without knowing what you did exactly."
                    }
                ]
            },
            {
                "id": 1913831,
                "content": [
                    {
                        "username": "Selithrarion",
                        "content": "hmm i needed to add `;` (semicolon) after `yield a` \\uD83D\\uDE2F"
                    },
                    {
                        "username": "almostmonday",
                        "content": "If you\\'re looking for one line solution without destructuring assignment, it\\'s [here](https://leetcode.com/problems/generate-fibonacci-sequence/solutions/3451942/one-line-two-variables-without-destructuring-assignment/)."
                    },
                    {
                        "username": "I_AM_JD",
                        "content": "Why there is a need to add semi-colon  `;` after yield a"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "Cool to know that yield and generators exist in JS too, brings back Python memories "
                    },
                    {
                        "username": "Code_Sagar",
                        "content": "#Day29 : Done Solving Today\\'s Question \\uD83D\\uDE01\\n\\n\\nTip : You can use yield keyword in generator functions "
                    },
                    {
                        "username": "ildarum21",
                        "content": "My solution works in the browser, bit doesn\\'t work on leetcode. Returned nulls. Can someone explain?"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "It\\'s hard for anyone to help without seeing your code."
                    },
                    {
                        "username": "FrontEndDeveloping",
                        "content": "Why I can\\'t create solution from my code? Can someone explain?"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "To creat a solution you need to submit your code, when you then go to solutions and click on add solution it should automatically grab your last submission. It\\'s hard to say why it didn\\'t work for you without knowing what you did exactly."
                    }
                ]
            },
            {
                "id": 1913817,
                "content": [
                    {
                        "username": "Selithrarion",
                        "content": "hmm i needed to add `;` (semicolon) after `yield a` \\uD83D\\uDE2F"
                    },
                    {
                        "username": "almostmonday",
                        "content": "If you\\'re looking for one line solution without destructuring assignment, it\\'s [here](https://leetcode.com/problems/generate-fibonacci-sequence/solutions/3451942/one-line-two-variables-without-destructuring-assignment/)."
                    },
                    {
                        "username": "I_AM_JD",
                        "content": "Why there is a need to add semi-colon  `;` after yield a"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "Cool to know that yield and generators exist in JS too, brings back Python memories "
                    },
                    {
                        "username": "Code_Sagar",
                        "content": "#Day29 : Done Solving Today\\'s Question \\uD83D\\uDE01\\n\\n\\nTip : You can use yield keyword in generator functions "
                    },
                    {
                        "username": "ildarum21",
                        "content": "My solution works in the browser, bit doesn\\'t work on leetcode. Returned nulls. Can someone explain?"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "It\\'s hard for anyone to help without seeing your code."
                    },
                    {
                        "username": "FrontEndDeveloping",
                        "content": "Why I can\\'t create solution from my code? Can someone explain?"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "To creat a solution you need to submit your code, when you then go to solutions and click on add solution it should automatically grab your last submission. It\\'s hard to say why it didn\\'t work for you without knowing what you did exactly."
                    }
                ]
            },
            {
                "id": 1886056,
                "content": [
                    {
                        "username": "Selithrarion",
                        "content": "hmm i needed to add `;` (semicolon) after `yield a` \\uD83D\\uDE2F"
                    },
                    {
                        "username": "almostmonday",
                        "content": "If you\\'re looking for one line solution without destructuring assignment, it\\'s [here](https://leetcode.com/problems/generate-fibonacci-sequence/solutions/3451942/one-line-two-variables-without-destructuring-assignment/)."
                    },
                    {
                        "username": "I_AM_JD",
                        "content": "Why there is a need to add semi-colon  `;` after yield a"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "Cool to know that yield and generators exist in JS too, brings back Python memories "
                    },
                    {
                        "username": "Code_Sagar",
                        "content": "#Day29 : Done Solving Today\\'s Question \\uD83D\\uDE01\\n\\n\\nTip : You can use yield keyword in generator functions "
                    },
                    {
                        "username": "ildarum21",
                        "content": "My solution works in the browser, bit doesn\\'t work on leetcode. Returned nulls. Can someone explain?"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "It\\'s hard for anyone to help without seeing your code."
                    },
                    {
                        "username": "FrontEndDeveloping",
                        "content": "Why I can\\'t create solution from my code? Can someone explain?"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "To creat a solution you need to submit your code, when you then go to solutions and click on add solution it should automatically grab your last submission. It\\'s hard to say why it didn\\'t work for you without knowing what you did exactly."
                    }
                ]
            },
            {
                "id": 1870304,
                "content": [
                    {
                        "username": "Selithrarion",
                        "content": "hmm i needed to add `;` (semicolon) after `yield a` \\uD83D\\uDE2F"
                    },
                    {
                        "username": "almostmonday",
                        "content": "If you\\'re looking for one line solution without destructuring assignment, it\\'s [here](https://leetcode.com/problems/generate-fibonacci-sequence/solutions/3451942/one-line-two-variables-without-destructuring-assignment/)."
                    },
                    {
                        "username": "I_AM_JD",
                        "content": "Why there is a need to add semi-colon  `;` after yield a"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "Cool to know that yield and generators exist in JS too, brings back Python memories "
                    },
                    {
                        "username": "Code_Sagar",
                        "content": "#Day29 : Done Solving Today\\'s Question \\uD83D\\uDE01\\n\\n\\nTip : You can use yield keyword in generator functions "
                    },
                    {
                        "username": "ildarum21",
                        "content": "My solution works in the browser, bit doesn\\'t work on leetcode. Returned nulls. Can someone explain?"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "It\\'s hard for anyone to help without seeing your code."
                    },
                    {
                        "username": "FrontEndDeveloping",
                        "content": "Why I can\\'t create solution from my code? Can someone explain?"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "To creat a solution you need to submit your code, when you then go to solutions and click on add solution it should automatically grab your last submission. It\\'s hard to say why it didn\\'t work for you without knowing what you did exactly."
                    }
                ]
            }
        ]
    },
    {
        "title": "Maximum Number of Fish in a Grid",
        "question_content": "<p>You are given a <strong>0-indexed</strong> 2D matrix <code>grid</code> of size <code>m x n</code>, where <code>(r, c)</code> represents:</p>\n\n<ul>\n\t<li>A <strong>land</strong> cell if <code>grid[r][c] = 0</code>, or</li>\n\t<li>A <strong>water</strong> cell containing <code>grid[r][c]</code> fish, if <code>grid[r][c] &gt; 0</code>.</li>\n</ul>\n\n<p>A fisher can start at any <strong>water</strong> cell <code>(r, c)</code> and can do the following operations any number of times:</p>\n\n<ul>\n\t<li>Catch all the fish at cell <code>(r, c)</code>, or</li>\n\t<li>Move to any adjacent <strong>water</strong> cell.</li>\n</ul>\n\n<p>Return <em>the <strong>maximum</strong> number of fish the fisher can catch if he chooses his starting cell optimally, or </em><code>0</code> if no water cell exists.</p>\n\n<p>An <strong>adjacent</strong> cell of the cell <code>(r, c)</code>, is one of the cells <code>(r, c + 1)</code>, <code>(r, c - 1)</code>, <code>(r + 1, c)</code> or <code>(r - 1, c)</code> if it exists.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2023/03/29/example.png\" style=\"width: 241px; height: 161px;\" />\n<pre>\n<strong>Input:</strong> grid = [[0,2,1,0],[4,0,0,3],[1,0,0,4],[0,3,2,0]]\n<strong>Output:</strong> 7\n<strong>Explanation:</strong> The fisher can start at cell <code>(1,3)</code> and collect 3 fish, then move to cell <code>(2,3)</code>&nbsp;and collect 4 fish.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2023/03/29/example2.png\" />\n<pre>\n<strong>Input:</strong> grid = [[1,0,0,0],[0,0,0,0],[0,0,0,0],[0,0,0,1]]\n<strong>Output:</strong> 1\n<strong>Explanation:</strong> The fisher can start at cells (0,0) or (3,3) and collect a single fish. \n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>m == grid.length</code></li>\n\t<li><code>n == grid[i].length</code></li>\n\t<li><code>1 &lt;= m, n &lt;= 10</code></li>\n\t<li><code>0 &lt;= grid[i][j] &lt;= 10</code></li>\n</ul>\n",
        "solutions": [
            {
                "id": 3466724,
                "title": "explained-dfs-with-node-sum-very-simple-easy-to-understand-solution",
                "content": "<b> Up vote if you like the solution </b>\\n\\n# Approach\\nTrick is to keep traversing the grid from (0,0) with dfs & adding the values of each dfs traverse.\\nKeep adding all non-zero value traversed is the total no of fish possible on that connected cells.\\nSo keep taking the maximum of each dfs run and return it as the answer.\\n\\nNote : Set the node value to 0 once we traversed a node, to avoid retraversing the same node again.\\n\\n# Code \\n\\n```\\nclass Solution {\\npublic:\\n    int dir[4][2] = {{1,0}, {0,1}, {-1, 0}, {0,-1}};\\n\\n    int dfs(vector<vector<int>>& grid, int r, int c){\\n        if(r < 0 || c < 0 || r >= grid.size() || c >= grid[0].size() || grid[r][c] == 0) return 0;\\n        int res = grid[r][c];\\n        grid[r][c] = 0;\\n        for(auto d: dir)  res += dfs(grid, r+d[0], c+d[1]);\\n        return res;\\n    }\\n\\n    int findMaxFish(vector<vector<int>>& grid) {\\n        int ans = 0;\\n        for(int i = 0; i< grid.size(); ++i){\\n            for(int j =0; j < grid[0].size(); ++j){\\n                ans = max(ans, dfs(grid, i, j));\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n<b>Here is an article of my last interview experience - A Journey to FAANG Company, I recomand you to go through this to know which all resources I have used & how I cracked interview at Amazon:\\nhttps://leetcode.com/discuss/interview-experience/3171859/Journey-to-a-FAANG-Company-Amazon-or-SDE2-(L5)-or-Bangalore-or-Oct-2022-Accepted",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dir[4][2] = {{1,0}, {0,1}, {-1, 0}, {0,-1}};\\n\\n    int dfs(vector<vector<int>>& grid, int r, int c){\\n        if(r < 0 || c < 0 || r >= grid.size() || c >= grid[0].size() || grid[r][c] == 0) return 0;\\n        int res = grid[r][c];\\n        grid[r][c] = 0;\\n        for(auto d: dir)  res += dfs(grid, r+d[0], c+d[1]);\\n        return res;\\n    }\\n\\n    int findMaxFish(vector<vector<int>>& grid) {\\n        int ans = 0;\\n        for(int i = 0; i< grid.size(); ++i){\\n            for(int j =0; j < grid[0].size(); ++j){\\n                ans = max(ans, dfs(grid, i, j));\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3466649,
                "title": "day-394-dfs-vs-bfs-100-0ms-python-java-c-explained-approach",
                "content": "# Please Upvote as it really motivates me \\uD83C\\uDD99\\uD83C\\uDD99\\uD83C\\uDD99\\n# Intuition & Approach\\n<!-- Describe your approach to solving the problem. -->\\n##### \\u2022\\tWe are given a 2D matrix grid representing land cells and water cells containing fish.\\n##### \\u2022\\tWe need to find the maximum number of fish that can be caught by a fisher starting from any water cell.\\n##### \\u2022\\tWe can start by iterating over all water cells in the grid and using a depth-first search (DFS) to explore all adjacent water cells and calculate the maximum number of fish that can be caught starting from that cell.\\n##### \\u2022\\tIn the DFS, we start with the current water cell and explore all adjacent water cells using a 2D array  dr that contains the four possible directions. For each adjacent water cell, we calculate the total number of fish that can be caught starting from the current cell and add it to the maximum number of fish caught so far. We also remove each water cell from the map as we visit it to avoid visiting the same cell twice.\\n##### \\u2022\\tWe keep track of the maximum number of fish caught so far and return it as the answer.\\n##### \\u2022\\tSince we explore each water cell in the grid only once and perform constant time operations for each cell, the time complexity of this solution is O(n), where n is the total number of cells in the grid.\\n##### \\u2022\\tWe can also optimize the solution by using memoization to avoid recomputing the maximum number of fish caught starting from a water cell that has already been visited.\\n\\n\\n\\n# Code\\n```java []\\npublic int findFish(int[][] grid) {\\n    int n = grid.length;\\n    int m = grid[0].length;\\n    int maxFish = 0; // variable to store the maximum number of fish caught\\n    for(int i = 0; i < n; i++) {\\n        for(int j = 0; j < m; j++) {\\n            if(grid[i][j] > 0) { // if the current cell contains fish\\n                maxFish = Math.max(maxFish, dfs(i, j, grid, n, m)); // update the maximum number of fish caught\\n            }\\n        }\\n    }\\n    return maxFish; // return the maximum number of fish caught\\n}\\n\\n// array to store the four possible directions\\nprivate final int[] dr = {0, 1, 0, -1, 0};\\n\\n// function to perform DFS and count the number of fish caught\\nint dfs(int i, int j, int[][] grid, int n, int m) {\\n    int fish = grid[i][j]; // count the number of fish caught in the current cell\\n    grid[i][j] = 0; // mark the current cell as visited by setting its value to 0\\n    for(int k = 0; k < 4; k++) { // iterate over the four possible directions\\n        int nr = i + dr[k], nc = j + dr[k + 1]; // calculate the coordinates of the adjacent cell\\n        if(nr < n && nr >= 0 && nc < m && nc >= 0 && grid[nr][nc] > 0) { // if the adjacent cell contains fish and is within the grid\\n            fish += dfs(nr, nc, grid, n, m); // count the number of fish caught in the adjacent cell\\n        }\\n    }\\n    return fish; // return the total number of fish caught\\n}\\n```\\n```c++ []\\nint findMaxFish(vector<vector<int>>& grid) {\\n    int n = grid.size();\\n    int m = grid[0].size();\\n    int ans = 0;\\n    for(int i = 0; i < n; i++) {\\n        for(int j = 0; j < m; j++) {\\n            if(grid[i][j] > 0) {\\n                ans = max(ans, dfs(i, j, grid, n, m));\\n            }\\n        }\\n    }\\n    return ans;\\n}\\nint dfs(int i, int j, vector<vector<int>>& grid, int n, int m) {\\n    int f = grid[i][j];\\n    grid[i][j] = 0;\\n    int dr[] = {0, 1, 0, -1, 0};\\n    for(int k = 0; k < 4; k++) {\\n        int nr = i + dr[k];\\n        int nc = j + dr[k + 1];\\n        if(nr >= 0 && nr < n && nc >= 0 && nc < m && grid[nr][nc] > 0) {\\n            f += dfs(nr, nc, grid, n, m);\\n        }\\n    }\\n    return f;\\n}\\n```\\n```python []\\ndef findMaxFish(self, grid: List[List[int]]) -> int:\\n    n = len(grid)\\n    m = len(grid[0])\\n    ans = 0\\n    for i in range(n):\\n        for j in range(m):\\n            if grid[i][j] > 0:\\n                ans = max(ans, self.dfs(i, j, grid, n, m))\\n    return ans\\n\\ndef dfs(self, i: int, j: int, grid: List[List[int]], n: int, m: int) -> int:\\n    f = grid[i][j]\\n    grid[i][j] = 0\\n    dr = [0, 1, 0, -1, 0]\\n    for k in range(4):\\n        nr = i + dr[k]\\n        nc = j + dr[k + 1]\\n        if nr >= 0 and nr < n and nc >= 0 and nc < m and grid[nr][nc] > 0:\\n            f += self.dfs(nr, nc, grid, n, m)\\n    return f\\n```\\n\\n# Please Upvote as it really motivates me \\uD83C\\uDD99\\uD83C\\uDD99\\uD83C\\uDD99\\n\\n\\n# BFS \\n\\nWe start by iterating over all water cells in the grid and checking if they contain fish. If a water cell contains fish, we add it to a queue and start the BFS. We also set the value of the current water cell to 0 to mark it as visited.\\n\\nIn the BFS, we explore all adjacent water cells using two arrays  dr and  dc that contain the four possible directions. For each adjacent water cell, we add the number of fish it contains to the total number of fish caught so far and mark it as visited by setting its value to 0. We also add it to the queue to explore its adjacent water cells in the next iteration.\\n\\nAfter the BFS is complete, we update the maximum number of fish caught so far and continue iterating over the remaining water cells.\\n\\nSince we explore each water cell in the grid only once and perform constant time operations for each cell, the time complexity of this solution is O(n), where n is the total number of cells in the grid.\\n```java []\\nint findMaxFish[][] grid) {\\n    int n = grid.length;\\n    int m = grid[0].length;\\n    int ans = 0; // variable to store the maximum number of fish caught\\n    int[] dr = {0, 1, 0, -1}; // array to store the four possible directions\\n    int[] dc = {1, 0, -1, 0};\\n    for(int i = 0; i < n; i++) {\\n        for(int j = 0; j < m; j++) {\\n            if(grid[i][j] > 0) { // if the current cell contains fish\\n                Queue<int[]> q = new LinkedList<>(); // create a queue to perform BFS\\n                q.offer(new int[]{i, j}); // add the current cell to the queue\\n                int f = grid[i][j]; // count the number of fish caught in the current cell\\n                grid[i][j] = 0; // mark the current cell as visited by setting its value to 0\\n                while(!q.isEmpty()) { // while there are cells in the queue\\n                    int[] curr = q.poll(); // remove the first cell from the queue\\n                    for(int k = 0; k < 4; k++) { // iterate over the four possible directions\\n                        int nr = curr[0] + dr[k]; // calculate the coordinates of the adjacent cell\\n                        int nc = curr[1] + dc[k];\\n                        if(nr >= 0 && nr < n && nc >= 0 && nc < m && grid[nr][nc] > 0) { // if the adjacent cell contains fish and is within the grid\\n                            f += grid[nr][nc]; // count the number of fish caught in the adjacent cell\\n                            grid[nr][nc] = 0; // mark the adjacent cell as visited by setting its value to 0\\n                            q.offer(new int[]{nr, nc}); // add the adjacent cell to the queue\\n                        }\\n                    }\\n                }\\n                ans = Math.max(ans, f); // update the maximum number of fish caught so far\\n            }\\n        }\\n    }\\n    return ans; // return the maximum number of fish caught\\n}\\n```\\n```c++ []\\nclass Solutionpublic:\\n    int findMaxFish(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        int ans = 0;\\n        vector<int> dr = {0, 1, 0, -1};\\n        vector<int> dc = {1, 0, -1, 0};\\n        for(int i = 0; i < n; i++) {\\n            for(int j = 0; j < m; j++) {\\n                if(grid[i][j] > 0) {\\n                    queue<pair<int, int>> q;\\n                    q.push({i, j});\\n                    int f = grid[i][j];\\n                    grid[i][j] = 0;\\n                    while(!q.empty()) {\\n                        auto curr = q.front();\\n                        q.pop();\\n                        for(int k = 0; k < 4; k++) {\\n                            int nr = curr.first + dr[k];\\n                            int nc = curr.second + dc[k];\\n                            if(nr >= 0 && nr < n && nc >= 0 && nc < m && grid[nr][nc] > 0) {\\n                                f += grid[nr][nc];\\n                                grid[nr][nc] = 0;\\n                                q.push({nr, nc});\\n                            }\\n                        }\\n                    }\\n                    ans = max(ans, f);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n```python []\\nclass Solution:\\n    def findMaxFish(self, grid: List[List[int]]) -> int:\\n        n = len(grid)\\n        m = len(grid[0])\\n        ans = 0\\n        dr = [0, 1, 0, -1]\\n        dc = [1, 0, -1, 0]\\n        for i in range(n):\\n            for j in range(m):\\n                if grid[i][j] > 0:\\n                    q = deque()\\n                    q.append((i, j))\\n                    f = grid[i][j]\\n                    grid[i][j] = 0\\n                    while q:\\n                        curr = q.popleft()\\n                        for k in range(4):\\n                            nr = curr[0] + dr[k]\\n                            nc = curr[1] + dc[k]\\n                            if nr >= 0 and nr < n and nc >= 0 and nc < m and grid[nr][nc] > 0:\\n                                f += grid[nr][nc]\\n                                grid[nr][nc] = 0\\n                                q.append((nr, nc))\\n                    ans = max(ans, f)\\n        return ans\\n```\\n\\n![BREUSELEE.webp](https://assets.leetcode.com/users/images/062630f0-ef80-4e74-abdb-302827b99235_1680054012.5054147.webp)\\n![image.png](https://assets.leetcode.com/users/images/303fa18d-281d-49f0-87ef-1a018fc9a488_1681355186.0923774.png)\\n\\n\\n# Please Upvote\\uD83D\\uDC4D\\uD83D\\uDC4D\\nThanks for visiting my solution.\\uD83D\\uDE0A Keep Learning\\nPlease give my solution an upvote! \\uD83D\\uDC4D \\uD83C\\uDD99\\uD83C\\uDD99\\uD83C\\uDD99\\nhttps://leetcode.com/problems/maximum-number-of-fish-in-a-grid/solutions/3466649/day-394-100-0ms-python-java-c-explained-approach/\\nIt\\'s a simple way to show your appreciation and\\nkeep me motivated. Thank you! \\uD83D\\uDE0A",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Python3",
                    "Depth-First Search"
                ],
                "code": "```java []\\npublic int findFish(int[][] grid) {\\n    int n = grid.length;\\n    int m = grid[0].length;\\n    int maxFish = 0; // variable to store the maximum number of fish caught\\n    for(int i = 0; i < n; i++) {\\n        for(int j = 0; j < m; j++) {\\n            if(grid[i][j] > 0) { // if the current cell contains fish\\n                maxFish = Math.max(maxFish, dfs(i, j, grid, n, m)); // update the maximum number of fish caught\\n            }\\n        }\\n    }\\n    return maxFish; // return the maximum number of fish caught\\n}\\n\\n// array to store the four possible directions\\nprivate final int[] dr = {0, 1, 0, -1, 0};\\n\\n// function to perform DFS and count the number of fish caught\\nint dfs(int i, int j, int[][] grid, int n, int m) {\\n    int fish = grid[i][j]; // count the number of fish caught in the current cell\\n    grid[i][j] = 0; // mark the current cell as visited by setting its value to 0\\n    for(int k = 0; k < 4; k++) { // iterate over the four possible directions\\n        int nr = i + dr[k], nc = j + dr[k + 1]; // calculate the coordinates of the adjacent cell\\n        if(nr < n && nr >= 0 && nc < m && nc >= 0 && grid[nr][nc] > 0) { // if the adjacent cell contains fish and is within the grid\\n            fish += dfs(nr, nc, grid, n, m); // count the number of fish caught in the adjacent cell\\n        }\\n    }\\n    return fish; // return the total number of fish caught\\n}\\n```\n```c++ []\\nint findMaxFish(vector<vector<int>>& grid) {\\n    int n = grid.size();\\n    int m = grid[0].size();\\n    int ans = 0;\\n    for(int i = 0; i < n; i++) {\\n        for(int j = 0; j < m; j++) {\\n            if(grid[i][j] > 0) {\\n                ans = max(ans, dfs(i, j, grid, n, m));\\n            }\\n        }\\n    }\\n    return ans;\\n}\\nint dfs(int i, int j, vector<vector<int>>& grid, int n, int m) {\\n    int f = grid[i][j];\\n    grid[i][j] = 0;\\n    int dr[] = {0, 1, 0, -1, 0};\\n    for(int k = 0; k < 4; k++) {\\n        int nr = i + dr[k];\\n        int nc = j + dr[k + 1];\\n        if(nr >= 0 && nr < n && nc >= 0 && nc < m && grid[nr][nc] > 0) {\\n            f += dfs(nr, nc, grid, n, m);\\n        }\\n    }\\n    return f;\\n}\\n```\n```python []\\ndef findMaxFish(self, grid: List[List[int]]) -> int:\\n    n = len(grid)\\n    m = len(grid[0])\\n    ans = 0\\n    for i in range(n):\\n        for j in range(m):\\n            if grid[i][j] > 0:\\n                ans = max(ans, self.dfs(i, j, grid, n, m))\\n    return ans\\n\\ndef dfs(self, i: int, j: int, grid: List[List[int]], n: int, m: int) -> int:\\n    f = grid[i][j]\\n    grid[i][j] = 0\\n    dr = [0, 1, 0, -1, 0]\\n    for k in range(4):\\n        nr = i + dr[k]\\n        nc = j + dr[k + 1]\\n        if nr >= 0 and nr < n and nc >= 0 and nc < m and grid[nr][nc] > 0:\\n            f += self.dfs(nr, nc, grid, n, m)\\n    return f\\n```\n```java []\\nint findMaxFish[][] grid) {\\n    int n = grid.length;\\n    int m = grid[0].length;\\n    int ans = 0; // variable to store the maximum number of fish caught\\n    int[] dr = {0, 1, 0, -1}; // array to store the four possible directions\\n    int[] dc = {1, 0, -1, 0};\\n    for(int i = 0; i < n; i++) {\\n        for(int j = 0; j < m; j++) {\\n            if(grid[i][j] > 0) { // if the current cell contains fish\\n                Queue<int[]> q = new LinkedList<>(); // create a queue to perform BFS\\n                q.offer(new int[]{i, j}); // add the current cell to the queue\\n                int f = grid[i][j]; // count the number of fish caught in the current cell\\n                grid[i][j] = 0; // mark the current cell as visited by setting its value to 0\\n                while(!q.isEmpty()) { // while there are cells in the queue\\n                    int[] curr = q.poll(); // remove the first cell from the queue\\n                    for(int k = 0; k < 4; k++) { // iterate over the four possible directions\\n                        int nr = curr[0] + dr[k]; // calculate the coordinates of the adjacent cell\\n                        int nc = curr[1] + dc[k];\\n                        if(nr >= 0 && nr < n && nc >= 0 && nc < m && grid[nr][nc] > 0) { // if the adjacent cell contains fish and is within the grid\\n                            f += grid[nr][nc]; // count the number of fish caught in the adjacent cell\\n                            grid[nr][nc] = 0; // mark the adjacent cell as visited by setting its value to 0\\n                            q.offer(new int[]{nr, nc}); // add the adjacent cell to the queue\\n                        }\\n                    }\\n                }\\n                ans = Math.max(ans, f); // update the maximum number of fish caught so far\\n            }\\n        }\\n    }\\n    return ans; // return the maximum number of fish caught\\n}\\n```\n```c++ []\\nclass Solutionpublic:\\n    int findMaxFish(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        int ans = 0;\\n        vector<int> dr = {0, 1, 0, -1};\\n        vector<int> dc = {1, 0, -1, 0};\\n        for(int i = 0; i < n; i++) {\\n            for(int j = 0; j < m; j++) {\\n                if(grid[i][j] > 0) {\\n                    queue<pair<int, int>> q;\\n                    q.push({i, j});\\n                    int f = grid[i][j];\\n                    grid[i][j] = 0;\\n                    while(!q.empty()) {\\n                        auto curr = q.front();\\n                        q.pop();\\n                        for(int k = 0; k < 4; k++) {\\n                            int nr = curr.first + dr[k];\\n                            int nc = curr.second + dc[k];\\n                            if(nr >= 0 && nr < n && nc >= 0 && nc < m && grid[nr][nc] > 0) {\\n                                f += grid[nr][nc];\\n                                grid[nr][nc] = 0;\\n                                q.push({nr, nc});\\n                            }\\n                        }\\n                    }\\n                    ans = max(ans, f);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\n```python []\\nclass Solution:\\n    def findMaxFish(self, grid: List[List[int]]) -> int:\\n        n = len(grid)\\n        m = len(grid[0])\\n        ans = 0\\n        dr = [0, 1, 0, -1]\\n        dc = [1, 0, -1, 0]\\n        for i in range(n):\\n            for j in range(m):\\n                if grid[i][j] > 0:\\n                    q = deque()\\n                    q.append((i, j))\\n                    f = grid[i][j]\\n                    grid[i][j] = 0\\n                    while q:\\n                        curr = q.popleft()\\n                        for k in range(4):\\n                            nr = curr[0] + dr[k]\\n                            nc = curr[1] + dc[k]\\n                            if nr >= 0 and nr < n and nc >= 0 and nc < m and grid[nr][nc] > 0:\\n                                f += grid[nr][nc]\\n                                grid[nr][nc] = 0\\n                                q.append((nr, nc))\\n                    ans = max(ans, f)\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3466627,
                "title": "695-max-area-of-island",
                "content": "This is similar to [695. Max Area of Island](https://leetcode.com/problems/max-area-of-island/).\\n\\nFor each \"island\" of water, it does not matter where fisherman starts. We just need to mark a visited cell by setting it to zero.\\n\\n```cpp    \\nint dfs(int r, int c, vector<vector<int>>& g) {\\n    if (min(r, c) < 0 || r == g.size() || c == g[r].size() || g[r][c] == 0)\\n        return 0;\\n    return exchange(g[r][c], 0) + dfs(r + 1, c, g) + dfs(r, c + 1, g) + dfs(r - 1, c, g) + dfs(r, c - 1, g);\\n}\\nint findMaxFish(vector<vector<int>>& g) {\\n    int res = 0;\\n    for (int r = 0; r < g.size(); ++r)\\n        for (int c = 0; c < g[r].size(); ++c)\\n            res = max(res, dfs(r, c, g));\\n    return res;\\n}\\n```",
                "solutionTags": [],
                "code": "```cpp    \\nint dfs(int r, int c, vector<vector<int>>& g) {\\n    if (min(r, c) < 0 || r == g.size() || c == g[r].size() || g[r][c] == 0)\\n        return 0;\\n    return exchange(g[r][c], 0) + dfs(r + 1, c, g) + dfs(r, c + 1, g) + dfs(r - 1, c, g) + dfs(r, c - 1, g);\\n}\\nint findMaxFish(vector<vector<int>>& g) {\\n    int res = 0;\\n    for (int r = 0; r < g.size(); ++r)\\n        for (int c = 0; c < g[r].size(); ++c)\\n            res = max(res, dfs(r, c, g));\\n    return res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3466637,
                "title": "explained-c-java-dfs-bfs-beginner-friendly-code",
                "content": "**DFS Approach**\\n\\n```\\n1. Define a helper function dfs that takes the grid, the row index r, and the column index c as arguments. The function returns the total number of fish caught starting from the cell (r, c).\\n2. In the dfs function, check if the current cell is out of bounds or a land cell. If so, return 0 (base case).\\n3. Otherwise, catch the fish at the current cell by storing its value in a variable fishCaught.\\n4. Mark the current cell as caught by setting its value to 0 in the grid.\\n5. Define an array moves that contains the possible movements of the fisherman. Each movement is defined as an array of two integers, representing the change in row and column indices, respectively.\\n6. For each possible movement in moves, calculate the new cell coordinates by adding the movement to the current cell coordinates.\\n7. Recursively call the dfs function with the new cell coordinates, and add the result to fishCaught.\\n8. Return fishCaught.\\n9. In the findMaxFish function, initialize a variable maxFish to 0 to keep track of the maximum number of fish caught by the fisherman.\\n10. Iterate over every cell in the grid.\\n11. For each water cell (i.e., cells with a positive value), start a DFS search using the dfs function to find the maximum number of fish that can be caught starting from this cell.\\n12. Update maxFish to the maximum value between maxFish and the number of fish caught starting from the current water cell.\\n13. Return maxFish.\\n```\\n\\n**C++ Code For DFS Approach**\\n```\\nint dfs(vector<vector<int>>& grid, int r, int c) {\\n    if (r < 0 || r >= grid.size() || c < 0 || c >= grid[0].size() || grid[r][c] == 0) {\\n        return 0; // Base case: out of bounds or land cell\\n    }\\n    int fishCaught = grid[r][c]; // Catch fish at current cell\\n    grid[r][c] = 0; // Mark cell as caught\\n    int moves[4][2] = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}}; // Possible movements\\n    for (int i = 0; i < 4; i++) {\\n        int newR = r + moves[i][0];\\n        int newC = c + moves[i][1];\\n        fishCaught += dfs(grid, newR, newC); // Recursively search adjacent cells\\n    }\\n    return fishCaught;\\n}\\n\\nint findMaxFish(vector<vector<int>>& grid) {\\n    int maxFish = 0;\\n    for (int i = 0; i < grid.size(); i++) {\\n        for (int j = 0; j < grid[0].size(); j++) {\\n            if (grid[i][j] > 0) { // Start DFS search from water cell\\n                int fishCaught = dfs(grid, i, j);\\n                maxFish = max(maxFish, fishCaught);\\n            }\\n        }\\n    }\\n    return maxFish;\\n}\\n```\\n\\n**Java Code For DFS Approach**\\n```\\npublic int dfs(int[][] grid, int r, int c) {\\n    if (r < 0 || r >= grid.length || c < 0 || c >= grid[0].length || grid[r][c] == 0) {\\n        return 0; // Base case: out of bounds or land cell\\n    }\\n    int fishCaught = grid[r][c]; // Catch fish at current cell\\n    grid[r][c] = 0; // Mark cell as caught\\n    int[][] moves = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}}; // Possible movements\\n    for (int[] move : moves) {\\n        int newR = r + move[0];\\n        int newC = c + move[1];\\n        fishCaught += dfs(grid, newR, newC); // Recursively search adjacent cells\\n    }\\n    return fishCaught;\\n}\\n\\npublic int findMaxFish(int[][] grid) {\\n    int maxFish = 0;\\n    for (int i = 0; i < grid.length; i++) {\\n        for (int j = 0; j < grid[0].length; j++) {\\n            if (grid[i][j] > 0) { // Start DFS search from water cell\\n                int fishCaught = dfs(grid, i, j);\\n                maxFish = Math.max(maxFish, fishCaught);\\n            }\\n        }\\n    }\\n    return maxFish;\\n}\\n```\\n\\n**BFS Approach:**\\n```\\n1. Initialize a variable maxFish to 0 to keep track of the maximum number of fish caught by the fisherman.\\n2. Get the size of the grid m x n.\\n3. Define a 2D array moves that contains the possible movements of the fisherman. Each movement is defined as an array of two integers, representing the change in row and column indices, respectively.\\n4. Iterate over every cell in the grid.\\n5. For each water cell (i.e., cells with a positive value), start a BFS search to find the maximum number of fish that can be caught starting from this cell.\\n6. Initialize a queue and add the current water cell coordinates to the queue.\\n7. Initialize a variable fishCaught to 0 to keep track of the number of fish caught starting from the current water cell.\\n8. While the queue is not empty, do the following:\\n\\ta. Dequeue the front element of the queue, representing the current water cell coordinates.\\n\\tb. If the current cell contains fish (i.e., has a positive value), catch the fish and add its value to fishCaught. Set the     cell value to 0 to mark it as caught.\\n\\tc. Iterate over every possible movement in the moves array.\\n\\td. Calculate the new cell coordinates by adding the movement to the current cell coordinates.\\n\\te. If the new cell is within the bounds of the grid and is a water cell (i.e., has a positive value), add its coordinates     to the queue.\\n9. Update maxFish to the maximum value between maxFish and fishCaught.\\n10. Return maxFish.\\n```\\n\\n**C++ Code For BFS Approach**\\n```\\nint findMaxFish(vector<vector<int>>& grid) {\\n    int maxFish = 0;\\n    int m = grid.size();\\n    int n = grid[0].size();\\n    \\n    vector<vector<int>> moves = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}}; // Possible moves\\n    \\n    for (int i = 0; i < m; i++) {\\n        for (int j = 0; j < n; j++) {\\n            if (grid[i][j] > 0) { // Start at a water cell\\n                queue<pair<int, int>> q;\\n                q.push({i, j});\\n                int fishCaught = 0;\\n                while (!q.empty()) {\\n                    int r = q.front().first;\\n                    int c = q.front().second;\\n                    q.pop();\\n                    if (grid[r][c] > 0) { // Catch fish at current cell\\n                        fishCaught += grid[r][c];\\n                        grid[r][c] = 0; // Mark cell as caught\\n                    }\\n                    for (auto& move : moves) { // Iterate over possible moves\\n                        int newR = r + move[0];\\n                        int newC = c + move[1];\\n                        if (newR >= 0 && newR < m && newC >= 0 && newC < n && grid[newR][newC] > 0) {\\n                            q.push({newR, newC}); // Add new water cell to queue\\n                        }\\n                    }\\n                }\\n                maxFish = max(maxFish, fishCaught);\\n            }\\n        }\\n    }\\n    \\n    return maxFish;\\n}\\n```\\n\\n**Java Code For BFS Approach**\\n\\n```\\npublic int findMaxFish(int[][] grid) {\\n    int maxFish = 0;\\n    int[][] moves = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}}; // Possible movements\\n    for (int i = 0; i < grid.length; i++) {\\n        for (int j = 0; j < grid[0].length; j++) {\\n            if (grid[i][j] > 0) { // Start BFS search from water cell\\n                int fishCaught = 0;\\n                Queue<int[]> queue = new LinkedList<>(); // Queue for BFS\\n                queue.offer(new int[]{i, j}); // Enqueue current cell\\n                while (!queue.isEmpty()) {\\n                    int[] curr = queue.poll(); // Dequeue first cell\\n                    int r = curr[0];\\n                    int c = curr[1];\\n                    if (grid[r][c] > 0) { // Catch fish at current cell\\n                        fishCaught += grid[r][c];\\n                        grid[r][c] = 0; // Mark cell as caught\\n                    }\\n                    for (int[] move : moves) {\\n                        int newR = r + move[0];\\n                        int newC = c + move[1];\\n                        if (newR >= 0 && newR < grid.length && newC >= 0 && newC < grid[0].length && grid[newR][newC] > 0) {\\n                            queue.offer(new int[]{newR, newC}); // Enqueue adjacent water cell\\n                        }\\n                    }\\n                }\\n                maxFish = Math.max(maxFish, fishCaught);\\n            }\\n        }\\n    }\\n    return maxFish;\\n}\\n```\\n\\n**PLEASE DO UPVOTE**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search",
                    "Breadth-First Search"
                ],
                "code": "```\\n1. Define a helper function dfs that takes the grid, the row index r, and the column index c as arguments. The function returns the total number of fish caught starting from the cell (r, c).\\n2. In the dfs function, check if the current cell is out of bounds or a land cell. If so, return 0 (base case).\\n3. Otherwise, catch the fish at the current cell by storing its value in a variable fishCaught.\\n4. Mark the current cell as caught by setting its value to 0 in the grid.\\n5. Define an array moves that contains the possible movements of the fisherman. Each movement is defined as an array of two integers, representing the change in row and column indices, respectively.\\n6. For each possible movement in moves, calculate the new cell coordinates by adding the movement to the current cell coordinates.\\n7. Recursively call the dfs function with the new cell coordinates, and add the result to fishCaught.\\n8. Return fishCaught.\\n9. In the findMaxFish function, initialize a variable maxFish to 0 to keep track of the maximum number of fish caught by the fisherman.\\n10. Iterate over every cell in the grid.\\n11. For each water cell (i.e., cells with a positive value), start a DFS search using the dfs function to find the maximum number of fish that can be caught starting from this cell.\\n12. Update maxFish to the maximum value between maxFish and the number of fish caught starting from the current water cell.\\n13. Return maxFish.\\n```\n```\\nint dfs(vector<vector<int>>& grid, int r, int c) {\\n    if (r < 0 || r >= grid.size() || c < 0 || c >= grid[0].size() || grid[r][c] == 0) {\\n        return 0; // Base case: out of bounds or land cell\\n    }\\n    int fishCaught = grid[r][c]; // Catch fish at current cell\\n    grid[r][c] = 0; // Mark cell as caught\\n    int moves[4][2] = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}}; // Possible movements\\n    for (int i = 0; i < 4; i++) {\\n        int newR = r + moves[i][0];\\n        int newC = c + moves[i][1];\\n        fishCaught += dfs(grid, newR, newC); // Recursively search adjacent cells\\n    }\\n    return fishCaught;\\n}\\n\\nint findMaxFish(vector<vector<int>>& grid) {\\n    int maxFish = 0;\\n    for (int i = 0; i < grid.size(); i++) {\\n        for (int j = 0; j < grid[0].size(); j++) {\\n            if (grid[i][j] > 0) { // Start DFS search from water cell\\n                int fishCaught = dfs(grid, i, j);\\n                maxFish = max(maxFish, fishCaught);\\n            }\\n        }\\n    }\\n    return maxFish;\\n}\\n```\n```\\npublic int dfs(int[][] grid, int r, int c) {\\n    if (r < 0 || r >= grid.length || c < 0 || c >= grid[0].length || grid[r][c] == 0) {\\n        return 0; // Base case: out of bounds or land cell\\n    }\\n    int fishCaught = grid[r][c]; // Catch fish at current cell\\n    grid[r][c] = 0; // Mark cell as caught\\n    int[][] moves = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}}; // Possible movements\\n    for (int[] move : moves) {\\n        int newR = r + move[0];\\n        int newC = c + move[1];\\n        fishCaught += dfs(grid, newR, newC); // Recursively search adjacent cells\\n    }\\n    return fishCaught;\\n}\\n\\npublic int findMaxFish(int[][] grid) {\\n    int maxFish = 0;\\n    for (int i = 0; i < grid.length; i++) {\\n        for (int j = 0; j < grid[0].length; j++) {\\n            if (grid[i][j] > 0) { // Start DFS search from water cell\\n                int fishCaught = dfs(grid, i, j);\\n                maxFish = Math.max(maxFish, fishCaught);\\n            }\\n        }\\n    }\\n    return maxFish;\\n}\\n```\n```\\n1. Initialize a variable maxFish to 0 to keep track of the maximum number of fish caught by the fisherman.\\n2. Get the size of the grid m x n.\\n3. Define a 2D array moves that contains the possible movements of the fisherman. Each movement is defined as an array of two integers, representing the change in row and column indices, respectively.\\n4. Iterate over every cell in the grid.\\n5. For each water cell (i.e., cells with a positive value), start a BFS search to find the maximum number of fish that can be caught starting from this cell.\\n6. Initialize a queue and add the current water cell coordinates to the queue.\\n7. Initialize a variable fishCaught to 0 to keep track of the number of fish caught starting from the current water cell.\\n8. While the queue is not empty, do the following:\\n\\ta. Dequeue the front element of the queue, representing the current water cell coordinates.\\n\\tb. If the current cell contains fish (i.e., has a positive value), catch the fish and add its value to fishCaught. Set the     cell value to 0 to mark it as caught.\\n\\tc. Iterate over every possible movement in the moves array.\\n\\td. Calculate the new cell coordinates by adding the movement to the current cell coordinates.\\n\\te. If the new cell is within the bounds of the grid and is a water cell (i.e., has a positive value), add its coordinates     to the queue.\\n9. Update maxFish to the maximum value between maxFish and fishCaught.\\n10. Return maxFish.\\n```\n```\\nint findMaxFish(vector<vector<int>>& grid) {\\n    int maxFish = 0;\\n    int m = grid.size();\\n    int n = grid[0].size();\\n    \\n    vector<vector<int>> moves = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}}; // Possible moves\\n    \\n    for (int i = 0; i < m; i++) {\\n        for (int j = 0; j < n; j++) {\\n            if (grid[i][j] > 0) { // Start at a water cell\\n                queue<pair<int, int>> q;\\n                q.push({i, j});\\n                int fishCaught = 0;\\n                while (!q.empty()) {\\n                    int r = q.front().first;\\n                    int c = q.front().second;\\n                    q.pop();\\n                    if (grid[r][c] > 0) { // Catch fish at current cell\\n                        fishCaught += grid[r][c];\\n                        grid[r][c] = 0; // Mark cell as caught\\n                    }\\n                    for (auto& move : moves) { // Iterate over possible moves\\n                        int newR = r + move[0];\\n                        int newC = c + move[1];\\n                        if (newR >= 0 && newR < m && newC >= 0 && newC < n && grid[newR][newC] > 0) {\\n                            q.push({newR, newC}); // Add new water cell to queue\\n                        }\\n                    }\\n                }\\n                maxFish = max(maxFish, fishCaught);\\n            }\\n        }\\n    }\\n    \\n    return maxFish;\\n}\\n```\n```\\npublic int findMaxFish(int[][] grid) {\\n    int maxFish = 0;\\n    int[][] moves = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}}; // Possible movements\\n    for (int i = 0; i < grid.length; i++) {\\n        for (int j = 0; j < grid[0].length; j++) {\\n            if (grid[i][j] > 0) { // Start BFS search from water cell\\n                int fishCaught = 0;\\n                Queue<int[]> queue = new LinkedList<>(); // Queue for BFS\\n                queue.offer(new int[]{i, j}); // Enqueue current cell\\n                while (!queue.isEmpty()) {\\n                    int[] curr = queue.poll(); // Dequeue first cell\\n                    int r = curr[0];\\n                    int c = curr[1];\\n                    if (grid[r][c] > 0) { // Catch fish at current cell\\n                        fishCaught += grid[r][c];\\n                        grid[r][c] = 0; // Mark cell as caught\\n                    }\\n                    for (int[] move : moves) {\\n                        int newR = r + move[0];\\n                        int newC = c + move[1];\\n                        if (newR >= 0 && newR < grid.length && newC >= 0 && newC < grid[0].length && grid[newR][newC] > 0) {\\n                            queue.offer(new int[]{newR, newC}); // Enqueue adjacent water cell\\n                        }\\n                    }\\n                }\\n                maxFish = Math.max(maxFish, fishCaught);\\n            }\\n        }\\n    }\\n    return maxFish;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3466794,
                "title": "easy-peasy-dfs",
                "content": "```\\nclass Solution {\\n    \\n    private int solve(int i, int j, int m, int n, int[][] grid, boolean[][] vis){\\n       // return if wrong position\\n\\t   if(i < 0 || j < 0 || i == m || j == n || vis[i][j] || grid[i][j] == 0){\\n            return 0;\\n        }\\n\\t\\t\\n\\t\\t// mark visited\\n        vis[i][j] = true;\\n\\t\\t\\n        // call 4 directions\\n        int total = grid[i][j];\\n        total += solve(i+1, j, m, n, grid, vis);\\n        total += solve(i, j+1, m, n, grid, vis);\\n        total += solve(i, j-1, m, n, grid, vis);\\n        total += solve(i-1, j, m, n, grid, vis);\\n        return total;\\n    }    \\n\\t\\n    public int findMaxFish(int[][] grid) {\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        int max = 0;\\n        boolean[][] vis = new boolean[m][n];\\n\\t\\t\\n        for(int i = 0; i < m; i++){\\n            for(int j = 0; j < n; j++){\\n                if(!vis[i][j] && grid[i][j] > 0){\\n                    max = Math.max(max, solve(i, j, m, n, grid, vis));\\n                }\\n            }\\n        }\\n        \\n        return max;\\n    }\\n}\\n```\\n\\n![image](https://assets.leetcode.com/users/images/60965b38-0d54-43b0-bf48-49629fbf0e73_1682785742.352511.png)\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    \\n    private int solve(int i, int j, int m, int n, int[][] grid, boolean[][] vis){\\n       // return if wrong position\\n\\t   if(i < 0 || j < 0 || i == m || j == n || vis[i][j] || grid[i][j] == 0){\\n            return 0;\\n        }\\n\\t\\t\\n\\t\\t// mark visited\\n        vis[i][j] = true;\\n\\t\\t\\n        // call 4 directions\\n        int total = grid[i][j];\\n        total += solve(i+1, j, m, n, grid, vis);\\n        total += solve(i, j+1, m, n, grid, vis);\\n        total += solve(i, j-1, m, n, grid, vis);\\n        total += solve(i-1, j, m, n, grid, vis);\\n        return total;\\n    }    \\n\\t\\n    public int findMaxFish(int[][] grid) {\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        int max = 0;\\n        boolean[][] vis = new boolean[m][n];\\n\\t\\t\\n        for(int i = 0; i < m; i++){\\n            for(int j = 0; j < n; j++){\\n                if(!vis[i][j] && grid[i][j] > 0){\\n                    max = Math.max(max, solve(i, j, m, n, grid, vis));\\n                }\\n            }\\n        }\\n        \\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3466685,
                "title": "c-dfs-bfs-union-find-maximum-of-water-components",
                "content": "# Intuition\\nWe can traverse only one complete component of water cells and catch all the fishes in it. Do a DFS/BFS traversal on every water component and count total number of fishes in that component. Take maximum of all possible water components.\\n\\n# Recursive DFS\\n```\\nclass Solution {\\nprivate:\\n    int countFishes(vector<vector<int>>& grid, vector<vector<bool>>& visited, int r, int c) {\\n        if (r == -1 || r == grid.size() || c == -1 || c == grid[0].size() || !grid[r][c] || visited[r][c]) {\\n            return 0;\\n        }\\n        visited[r][c] = true;\\n        return grid[r][c] +\\n            countFishes(grid, visited, r, c + 1) +\\n            countFishes(grid, visited, r, c - 1) +\\n            countFishes(grid, visited, r + 1, c) +\\n            countFishes(grid, visited, r - 1, c);\\n    }\\n    \\npublic:\\n    int findMaxFish(vector<vector<int>>& grid) {\\n        int m = grid.size(), n = grid[0].size(), result = 0;\\n        vector visited(m, vector<bool>(n));\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (grid[i][j] && !visited[i][j]) {\\n                    result = max(result, countFishes(grid, visited, i, j));\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n};\\n```\\n\\n# Iterative DFS\\n```\\nclass Solution {\\nprivate:\\n    vector<int> dr, dc;\\n\\n    int countFishes(vector<vector<int>>& grid, vector<vector<bool>>& visited, int r, int c) {\\n        int m = grid.size(), n = grid[0].size(), count = 0;\\n        stack<pair<int, int>> s;\\n        s.push({r, c});\\n        visited[r][c] = true;\\n        while (!s.empty()) {\\n            r = s.top().first, c = s.top().second; s.pop();\\n            count += grid[r][c];\\n            for (int i = 0; i < 4; i++) {\\n                int r1 = r + dr[i], c1 = c + dc[i];\\n                if (0 <= r1 && r1 < m && 0 <= c1 && c1 < n && grid[r1][c1] && !visited[r1][c1]) {\\n                    s.push({r1, c1});\\n                    visited[r1][c1] = true;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n    \\npublic:\\n    int findMaxFish(vector<vector<int>>& grid) {\\n        dr = vector<int>{0, 0, 1, -1};\\n        dc = vector<int>{1, -1, 0, 0};\\n        int m = grid.size(), n = grid[0].size(), result = 0;\\n        vector visited(m, vector<bool>(n));\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (grid[i][j] && !visited[i][j]) {\\n                    result = max(result, countFishes(grid, visited, i, j));\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n};\\n```\\n\\n# Iterative BFS\\n```\\nclass Solution {\\nprivate:\\n    vector<int> dr, dc;\\n\\n    int countFishes(vector<vector<int>>& grid, vector<vector<bool>>& visited, int r, int c) {\\n        int m = grid.size(), n = grid[0].size(), count = 0;\\n        queue<pair<int, int>> q;\\n        q.push({r, c});\\n        visited[r][c] = true;\\n        while (!q.empty()) {\\n            r = q.front().first, c = q.front().second; q.pop();\\n            count += grid[r][c];\\n            for (int i = 0; i < 4; i++) {\\n                int r1 = r + dr[i], c1 = c + dc[i];\\n                if (0 <= r1 && r1 < m && 0 <= c1 && c1 < n && grid[r1][c1] && !visited[r1][c1]) {\\n                    q.push({r1, c1});\\n                    visited[r1][c1] = true;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n    \\npublic:\\n    int findMaxFish(vector<vector<int>>& grid) {\\n        dr = vector<int>{0, 0, 1, -1};\\n        dc = vector<int>{1, -1, 0, 0};\\n        int m = grid.size(), n = grid[0].size(), result = 0;\\n        vector visited(m, vector<bool>(n));\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (grid[i][j] && !visited[i][j]) {\\n                    result = max(result, countFishes(grid, visited, i, j));\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n};\\n```\\n\\n# Union Find\\n```\\nclass UnionFind {\\nprivate:\\n    vector<int> parent, compSize, fishes;\\n\\npublic:\\n    UnionFind(vector<vector<int>>& grid) {\\n        int m = grid.size(), n = grid[0].size(), mn = m * n;\\n        parent.resize(mn);\\n        compSize.resize(mn, 1);\\n        fishes.resize(mn);\\n        iota(parent.begin(), parent.end(), 0);\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                fishes[n * i + j] = grid[i][j];\\n            }\\n        }\\n    }\\n\\n    int getParent(int x) {\\n        if (x == parent[x]) {\\n            return x;\\n        }\\n        return parent[x] = getParent(parent[x]);\\n    }\\n\\n    void unionSet(int x, int y) {\\n        int parx = getParent(x), pary = getParent(y);\\n        if (parx != pary) {\\n            if (compSize[parx] < compSize[pary]) {\\n                swap(parx, pary);\\n            }\\n            parent[pary] = parx;\\n            compSize[parx] += compSize[pary];\\n            fishes[parx] += fishes[pary];\\n        }\\n    }\\n\\n    int getFishes(int x) {\\n        return fishes[getParent(x)];\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    int findMaxFish(vector<vector<int>>& grid) {\\n        int m = grid.size(), n = grid[0].size(), result = 0;\\n        vector<int> dr{0, 0, 1, -1}, dc{1, -1, 0, 0};\\n        UnionFind dsu(grid);\\n        for (int r = 0; r < m; r++) {\\n            for (int c = 0; c < n; c++) {\\n                if (grid[r][c]) {\\n                    for (int k = 0; k < 4; k++) {\\n                        int r1 = r + dr[k], c1 = c + dc[k];\\n                        if (0 <= r1 && r1 < m && 0 <= c1 && c1 < n && grid[r1][c1]) {\\n                            dsu.unionSet(n * r + c, n * r1 + c1);\\n                        }\\n                    }\\n                    result = max(result, dsu.getFishes(n * r + c));\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n};\\n```\\n\\n\\n# Complexity\\n- Time complexity: $O(mn)$\\n- Space complexity: $O(mn)$",
                "solutionTags": [
                    "C++",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Union Find"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    int countFishes(vector<vector<int>>& grid, vector<vector<bool>>& visited, int r, int c) {\\n        if (r == -1 || r == grid.size() || c == -1 || c == grid[0].size() || !grid[r][c] || visited[r][c]) {\\n            return 0;\\n        }\\n        visited[r][c] = true;\\n        return grid[r][c] +\\n            countFishes(grid, visited, r, c + 1) +\\n            countFishes(grid, visited, r, c - 1) +\\n            countFishes(grid, visited, r + 1, c) +\\n            countFishes(grid, visited, r - 1, c);\\n    }\\n    \\npublic:\\n    int findMaxFish(vector<vector<int>>& grid) {\\n        int m = grid.size(), n = grid[0].size(), result = 0;\\n        vector visited(m, vector<bool>(n));\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (grid[i][j] && !visited[i][j]) {\\n                    result = max(result, countFishes(grid, visited, i, j));\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n};\\n```\n```\\nclass Solution {\\nprivate:\\n    vector<int> dr, dc;\\n\\n    int countFishes(vector<vector<int>>& grid, vector<vector<bool>>& visited, int r, int c) {\\n        int m = grid.size(), n = grid[0].size(), count = 0;\\n        stack<pair<int, int>> s;\\n        s.push({r, c});\\n        visited[r][c] = true;\\n        while (!s.empty()) {\\n            r = s.top().first, c = s.top().second; s.pop();\\n            count += grid[r][c];\\n            for (int i = 0; i < 4; i++) {\\n                int r1 = r + dr[i], c1 = c + dc[i];\\n                if (0 <= r1 && r1 < m && 0 <= c1 && c1 < n && grid[r1][c1] && !visited[r1][c1]) {\\n                    s.push({r1, c1});\\n                    visited[r1][c1] = true;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n    \\npublic:\\n    int findMaxFish(vector<vector<int>>& grid) {\\n        dr = vector<int>{0, 0, 1, -1};\\n        dc = vector<int>{1, -1, 0, 0};\\n        int m = grid.size(), n = grid[0].size(), result = 0;\\n        vector visited(m, vector<bool>(n));\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (grid[i][j] && !visited[i][j]) {\\n                    result = max(result, countFishes(grid, visited, i, j));\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n};\\n```\n```\\nclass Solution {\\nprivate:\\n    vector<int> dr, dc;\\n\\n    int countFishes(vector<vector<int>>& grid, vector<vector<bool>>& visited, int r, int c) {\\n        int m = grid.size(), n = grid[0].size(), count = 0;\\n        queue<pair<int, int>> q;\\n        q.push({r, c});\\n        visited[r][c] = true;\\n        while (!q.empty()) {\\n            r = q.front().first, c = q.front().second; q.pop();\\n            count += grid[r][c];\\n            for (int i = 0; i < 4; i++) {\\n                int r1 = r + dr[i], c1 = c + dc[i];\\n                if (0 <= r1 && r1 < m && 0 <= c1 && c1 < n && grid[r1][c1] && !visited[r1][c1]) {\\n                    q.push({r1, c1});\\n                    visited[r1][c1] = true;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n    \\npublic:\\n    int findMaxFish(vector<vector<int>>& grid) {\\n        dr = vector<int>{0, 0, 1, -1};\\n        dc = vector<int>{1, -1, 0, 0};\\n        int m = grid.size(), n = grid[0].size(), result = 0;\\n        vector visited(m, vector<bool>(n));\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (grid[i][j] && !visited[i][j]) {\\n                    result = max(result, countFishes(grid, visited, i, j));\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n};\\n```\n```\\nclass UnionFind {\\nprivate:\\n    vector<int> parent, compSize, fishes;\\n\\npublic:\\n    UnionFind(vector<vector<int>>& grid) {\\n        int m = grid.size(), n = grid[0].size(), mn = m * n;\\n        parent.resize(mn);\\n        compSize.resize(mn, 1);\\n        fishes.resize(mn);\\n        iota(parent.begin(), parent.end(), 0);\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                fishes[n * i + j] = grid[i][j];\\n            }\\n        }\\n    }\\n\\n    int getParent(int x) {\\n        if (x == parent[x]) {\\n            return x;\\n        }\\n        return parent[x] = getParent(parent[x]);\\n    }\\n\\n    void unionSet(int x, int y) {\\n        int parx = getParent(x), pary = getParent(y);\\n        if (parx != pary) {\\n            if (compSize[parx] < compSize[pary]) {\\n                swap(parx, pary);\\n            }\\n            parent[pary] = parx;\\n            compSize[parx] += compSize[pary];\\n            fishes[parx] += fishes[pary];\\n        }\\n    }\\n\\n    int getFishes(int x) {\\n        return fishes[getParent(x)];\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    int findMaxFish(vector<vector<int>>& grid) {\\n        int m = grid.size(), n = grid[0].size(), result = 0;\\n        vector<int> dr{0, 0, 1, -1}, dc{1, -1, 0, 0};\\n        UnionFind dsu(grid);\\n        for (int r = 0; r < m; r++) {\\n            for (int c = 0; c < n; c++) {\\n                if (grid[r][c]) {\\n                    for (int k = 0; k < 4; k++) {\\n                        int r1 = r + dr[k], c1 = c + dc[k];\\n                        if (0 <= r1 && r1 < m && 0 <= c1 && c1 < n && grid[r1][c1]) {\\n                            dsu.unionSet(n * r + c, n * r1 + c1);\\n                        }\\n                    }\\n                    result = max(result, dsu.getFishes(n * r + c));\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3466626,
                "title": "simple-java-solution",
                "content": "# Complexity\\n- Time complexity: $$O(m*n)$$\\n\\n- Space complexity: $$O(m*n)$$\\n\\n# Code\\n```\\nclass Solution {\\n    public int findMaxFish(int[][] grid) {\\n        int sum=0;\\n        for(int i=0;i<grid.length;i++)\\n        {\\n            for(int j=0;j<grid[0].length;j++)\\n            {\\n                if(grid[i][j]!=0)\\n                {\\n                    int a[]=new int[1];\\n                    task(grid,i,j,a);\\n                    sum=Math.max(sum,a[0]);\\n                }\\n            }\\n        }\\n        return sum;\\n    }\\n    public void task(int grid[][], int i, int j, int a[])\\n    {\\n        if(i<0 || j<0 || i>=grid.length || j>=grid[0].length || grid[i][j]==0)\\n        {\\n            return;\\n        }\\n        a[0]+=grid[i][j];\\n        grid[i][j]=0;\\n        task(grid,i+1,j,a);\\n        task(grid,i-1,j,a);\\n        task(grid,i,j+1,a);\\n        task(grid,i,j-1,a);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int findMaxFish(int[][] grid) {\\n        int sum=0;\\n        for(int i=0;i<grid.length;i++)\\n        {\\n            for(int j=0;j<grid[0].length;j++)\\n            {\\n                if(grid[i][j]!=0)\\n                {\\n                    int a[]=new int[1];\\n                    task(grid,i,j,a);\\n                    sum=Math.max(sum,a[0]);\\n                }\\n            }\\n        }\\n        return sum;\\n    }\\n    public void task(int grid[][], int i, int j, int a[])\\n    {\\n        if(i<0 || j<0 || i>=grid.length || j>=grid[0].length || grid[i][j]==0)\\n        {\\n            return;\\n        }\\n        a[0]+=grid[i][j];\\n        grid[i][j]=0;\\n        task(grid,i+1,j,a);\\n        task(grid,i-1,j,a);\\n        task(grid,i,j+1,a);\\n        task(grid,i,j-1,a);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3466670,
                "title": "easy-to-understand-simple-dfs",
                "content": "#Given : We can start at any water cell \\n#So why not do the same\\n#For a given water cell, collect all the fishes from the cells which are **\\u2018connected\\u2019 [directly/indirectly]** from that cell\\n#So **get the count of fishes for each connected component, and then take the maximum**\\n\\n![image](https://assets.leetcode.com/users/images/3c92b14c-6fce-4335-9244-561701786f6b_1682784101.8203545.png)\\n\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int>rowDir = {-1, 1, 0, 0}; //top, bottom, left, right\\n    vector<int>colDir = {0, 0, -1, 1};\\n    int dfs(vector<vector<int>>&grid, int row, int col)\\n    {\\n        if (row < 0 || col < 0 || row == grid.size() || col == grid[0].size()) return 0;\\n        if (grid[row][col] == 0) return 0;\\n       \\n        int sum = grid[row][col]; //include fish count of current cell\\n        grid[row][col] = 0; //mark curr cell as visited [make it a water cell]\\n        for (int dirIdx = 0; dirIdx < 4; dirIdx++)\\n        {\\n            int newRow = row + rowDir[dirIdx];\\n            int newCol = col + colDir[dirIdx];\\n            sum += dfs(grid, newRow, newCol); //add fish count of all connected cells to sum\\n        }\\n        return sum;\\n    }\\n    int findMaxFish(vector<vector<int>>& grid)\\n    {\\n        int m = grid.size(), n = grid[0].size();\\n        int maxCount = 0;\\n        for (int i = 0; i < m; i++)\\n        {\\n            for (int j = 0; j < n; j++)\\n            {\\n                if (grid[i][j] == 0) continue; //if it is a water cell \\n                \\n                int collectedCount = dfs(grid, i, j);\\n                maxCount = max(maxCount, collectedCount);\\n            }\\n        }\\n        return maxCount;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int>rowDir = {-1, 1, 0, 0}; //top, bottom, left, right\\n    vector<int>colDir = {0, 0, -1, 1};\\n    int dfs(vector<vector<int>>&grid, int row, int col)\\n    {\\n        if (row < 0 || col < 0 || row == grid.size() || col == grid[0].size()) return 0;\\n        if (grid[row][col] == 0) return 0;\\n       \\n        int sum = grid[row][col]; //include fish count of current cell\\n        grid[row][col] = 0; //mark curr cell as visited [make it a water cell]\\n        for (int dirIdx = 0; dirIdx < 4; dirIdx++)\\n        {\\n            int newRow = row + rowDir[dirIdx];\\n            int newCol = col + colDir[dirIdx];\\n            sum += dfs(grid, newRow, newCol); //add fish count of all connected cells to sum\\n        }\\n        return sum;\\n    }\\n    int findMaxFish(vector<vector<int>>& grid)\\n    {\\n        int m = grid.size(), n = grid[0].size();\\n        int maxCount = 0;\\n        for (int i = 0; i < m; i++)\\n        {\\n            for (int j = 0; j < n; j++)\\n            {\\n                if (grid[i][j] == 0) continue; //if it is a water cell \\n                \\n                int collectedCount = dfs(grid, i, j);\\n                maxCount = max(maxCount, collectedCount);\\n            }\\n        }\\n        return maxCount;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3467962,
                "title": "python-3-8-lines-dfs-t-m-92-68",
                "content": "```\\nclass Solution:\\n    def findMaxFish(self, grid: List[List[int]]) -> int:\\n\\n        def dfs(r,c):\\n\\n            if (r,c) not in unseen:return 0\\n            unseen.remove((r,c))\\n            return grid[r][c] + dfs(r+1,c)+dfs(r,c+1)+dfs(r-1,c)+dfs(r,c-1)\\n            \\n        m, n, ans = len(grid), len(grid[0]), 0\\n        unseen = {(i,j) for i,j in product(range(m),range(n))\\n                                                if grid[i][j]}\\n        while unseen: ans = max(ans,dfs(*min(unseen)))\\n\\n        return ans \\n```\\n[https://leetcode.com/problems/maximum-number-of-fish-in-a-grid/submissions/975947247/](http://)\\n\\n\\n\\nI\\'m surely wrong, but I think that time complexity might be--worstcase-- *O*(*MN*^2), and space complexity might be *O*(*MN*).\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findMaxFish(self, grid: List[List[int]]) -> int:\\n\\n        def dfs(r,c):\\n\\n            if (r,c) not in unseen:return 0\\n            unseen.remove((r,c))\\n            return grid[r][c] + dfs(r+1,c)+dfs(r,c+1)+dfs(r-1,c)+dfs(r,c-1)\\n            \\n        m, n, ans = len(grid), len(grid[0]), 0\\n        unseen = {(i,j) for i,j in product(range(m),range(n))\\n                                                if grid[i][j]}\\n        while unseen: ans = max(ans,dfs(*min(unseen)))\\n\\n        return ans \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3467188,
                "title": "bfs-c-easy-solution",
                "content": "# Approach\\nSimple BFS approach.\\nEnter in a cell when grid[r][c]!=0 and search in neighbours cell using bfs whenever leaving that particular cell add this to our fish variable and put it equal to 0 that is grid[r][c]=0.\\n\\n# Complexity\\n- Time complexity:\\n  O(n*m)\\n\\n- Space complexity:\\n  O(min(n,m))\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findMaxFish(vector<vector<int>>& grid) {\\n        int n=grid.size(),m=grid[0].size();\\n        vector<int> v={0,-1,0,1,0};\\n        int ans=0,mx=0;\\n         for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<m;j++)\\n            {\\n                ans=0;\\n                if(grid[i][j]!=0)\\n                {\\n                    queue<pair<int,int>> q;\\n                    q.push({i,j});\\n                    ans+=grid[i][j];\\n                    grid[i][j]=0;\\n                    while(!q.empty())\\n                    {\\n                        for(int k=0;k<4;k++)\\n                        {\\n                            int r1=q.front().first+v[k];\\n                            int c1=q.front().second+v[k+1];\\n                            if(r1>=0 && r1<n && c1>=0 && c1<m && grid[r1][c1]!=0)\\n                            {\\n                                ans+=grid[r1][c1];\\n                                q.push({r1,c1});\\n                                grid[r1][c1]=0;\\n                            }\\n                        }\\n                        q.pop();\\n                    }\\n                }\\n                 mx=max(mx,ans);\\n            }\\n         }\\n        return mx;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findMaxFish(vector<vector<int>>& grid) {\\n        int n=grid.size(),m=grid[0].size();\\n        vector<int> v={0,-1,0,1,0};\\n        int ans=0,mx=0;\\n         for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<m;j++)\\n            {\\n                ans=0;\\n                if(grid[i][j]!=0)\\n                {\\n                    queue<pair<int,int>> q;\\n                    q.push({i,j});\\n                    ans+=grid[i][j];\\n                    grid[i][j]=0;\\n                    while(!q.empty())\\n                    {\\n                        for(int k=0;k<4;k++)\\n                        {\\n                            int r1=q.front().first+v[k];\\n                            int c1=q.front().second+v[k+1];\\n                            if(r1>=0 && r1<n && c1>=0 && c1<m && grid[r1][c1]!=0)\\n                            {\\n                                ans+=grid[r1][c1];\\n                                q.push({r1,c1});\\n                                grid[r1][c1]=0;\\n                            }\\n                        }\\n                        q.pop();\\n                    }\\n                }\\n                 mx=max(mx,ans);\\n            }\\n         }\\n        return mx;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3467122,
                "title": "java-bfs-code-with-explanation",
                "content": "# ********** Please upvote if it is helpful **********\\n\\n# Explanation\\n- Given that we have to choose optimal cell i.e grid[r][c] > 0 { water cell } in order to find the maximum fishes we can get.\\n- Traverse the given grid and apply **BFS** on grid[r][c] > 0\\n- We have to calculate the maximum fishes using bfs function.\\n- # BFS function explanation\\n- First of all add the cell into a queue and mark the cell as visited.\\n- Since you are on the cell which have water that consists of fishes so add grid[r][c] to your collection of fishes.\\n- Now check all adjacent sides of current cell whose value should not be \\'0\\' i.e it should be a water cell since if grid[r][c] = 0 it is land and you cant caught fish from land. \\n- If it is water cell then it consists of fishes so, add grid[r][c] it to your collection of fishes.\\n- Now add the adjacent cell to queue if not visited yet.\\n- Lastly **BFS** function returns the number of fishes that you are collected from present cell.\\n-  And each time the max fishes that are collected from each cell{grid[r][c] > 0} calculated in main function.\\n\\n# Complexity\\n- Time complexity: O(N + M) \\n- Space Complexity : O(N)\\n\\n# Code\\n```\\nclass Solution {\\n     int[] x = {-1,0,1,0};\\n     int[] y = {0,1,0,-1};\\n     class Pair {\\n        int first;\\n        int second;\\n        public Pair(int first,int second) {\\n            this.first = first;\\n            this.second = second;\\n        }\\n    }\\n   \\n   \\n   \\n    public int bfs(int i,int j,boolean[][] vis,int[][] grid) {\\n       \\n        int sum = 0;\\n        Queue<Pair> q = new LinkedList<>();\\n        q.add(new Pair(i,j));\\n        vis[i][j] = true;\\n        sum += grid[i][j];\\n        while(!q.isEmpty()) {\\n            Pair p = q.poll();\\n            int first = p.first;\\n            int second = p.second;\\n            \\n           \\n            \\n            for(int k = 0;k<4;k++) {\\n                \\n                int ind1 = x[k] + first;\\n                int ind2 = y[k] + second;\\n              \\n                if(ind1 >=0 && ind2 >=0 && ind1 < grid.length && ind2 < grid[0].length && !vis[ind1][ind2] ){\\n                    \\n                    \\n                     if(grid[ind1][ind2] > 0) {\\n                       \\n                          sum += grid[ind1][ind2];\\n                          q.add(new Pair(ind1,ind2));\\n                          vis[ind1][ind2] = true;\\n                     }\\n                   \\n                     \\n                }\\n                \\n            }\\n           \\n        }\\n        return sum;\\n    }\\n\\n     public int findMaxFish(int[][] grid) {\\n      int ans= 0;\\n        boolean[][] vis = new boolean[grid.length][grid[0].length];\\n        \\n        for(int i = 0;i<grid.length;i++) {\\n            for(int j = 0;j<grid[i].length;j++) {\\n                if(!vis[i][j] && grid[i][j] != 0) {\\n                    ans = Math.max(ans,bfs(i,j,vis,grid));\\n                    \\n                }\\n            }\\n        }\\n       \\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\n     int[] x = {-1,0,1,0};\\n     int[] y = {0,1,0,-1};\\n     class Pair {\\n        int first;\\n        int second;\\n        public Pair(int first,int second) {\\n            this.first = first;\\n            this.second = second;\\n        }\\n    }\\n   \\n   \\n   \\n    public int bfs(int i,int j,boolean[][] vis,int[][] grid) {\\n       \\n        int sum = 0;\\n        Queue<Pair> q = new LinkedList<>();\\n        q.add(new Pair(i,j));\\n        vis[i][j] = true;\\n        sum += grid[i][j];\\n        while(!q.isEmpty()) {\\n            Pair p = q.poll();\\n            int first = p.first;\\n            int second = p.second;\\n            \\n           \\n            \\n            for(int k = 0;k<4;k++) {\\n                \\n                int ind1 = x[k] + first;\\n                int ind2 = y[k] + second;\\n              \\n                if(ind1 >=0 && ind2 >=0 && ind1 < grid.length && ind2 < grid[0].length && !vis[ind1][ind2] ){\\n                    \\n                    \\n                     if(grid[ind1][ind2] > 0) {\\n                       \\n                          sum += grid[ind1][ind2];\\n                          q.add(new Pair(ind1,ind2));\\n                          vis[ind1][ind2] = true;\\n                     }\\n                   \\n                     \\n                }\\n                \\n            }\\n           \\n        }\\n        return sum;\\n    }\\n\\n     public int findMaxFish(int[][] grid) {\\n      int ans= 0;\\n        boolean[][] vis = new boolean[grid.length][grid[0].length];\\n        \\n        for(int i = 0;i<grid.length;i++) {\\n            for(int j = 0;j<grid[i].length;j++) {\\n                if(!vis[i][j] && grid[i][j] != 0) {\\n                    ans = Math.max(ans,bfs(i,j,vis,grid));\\n                    \\n                }\\n            }\\n        }\\n       \\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3466750,
                "title": "c-best-solution-dfs-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nDFS\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    \\n    int solve(vector<vector<int>>& grid, vector<vector<bool>>& visited, int r, int c) {\\n        visited[r][c] = true;\\n        int  cnt = grid[r][c], n = grid.size(), m = grid[0].size();\\n        \\n        if(c+1<m && grid[r][c+1] && !visited[r][c+1])   {\\n            cnt += solve(grid, visited, r, c+1);\\n        }\\n        \\n        if(c-1>=0 && grid[r][c-1] && !visited[r][c-1])  {\\n            cnt += solve(grid, visited, r, c-1);\\n        }\\n            \\n        if(r+1<n && grid[r+1][c] && !visited[r+1][c])   {\\n            cnt += solve(grid, visited, r+1, c);\\n        }\\n            \\n        if(r-1>=0 && grid[r-1][c] && !visited[r-1][c])  {\\n            cnt += solve(grid, visited, r-1, c);\\n        }\\n            \\n        return cnt;\\n    }\\n    \\n    int findMaxFish(vector<vector<int>>& grid) {\\n        int maxi = 0, n = grid.size(), m = grid[0].size();\\n        vector<vector<bool>> visited(n, vector<bool>(m, false));\\n        \\n        for(int i=0; i<n; i++)  for(int j=0; j<m; j++) \\n                // if it is water cell and not visited the call the dfs function to calculate the total fish and compare with the maximum\\n                if(grid[i][j] && !visited[i][j])   {\\n                    int x = solve(grid, visited, i,  j);\\n                    maxi = max(maxi, x);\\n                }\\n        return maxi;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Graph",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int solve(vector<vector<int>>& grid, vector<vector<bool>>& visited, int r, int c) {\\n        visited[r][c] = true;\\n        int  cnt = grid[r][c], n = grid.size(), m = grid[0].size();\\n        \\n        if(c+1<m && grid[r][c+1] && !visited[r][c+1])   {\\n            cnt += solve(grid, visited, r, c+1);\\n        }\\n        \\n        if(c-1>=0 && grid[r][c-1] && !visited[r][c-1])  {\\n            cnt += solve(grid, visited, r, c-1);\\n        }\\n            \\n        if(r+1<n && grid[r+1][c] && !visited[r+1][c])   {\\n            cnt += solve(grid, visited, r+1, c);\\n        }\\n            \\n        if(r-1>=0 && grid[r-1][c] && !visited[r-1][c])  {\\n            cnt += solve(grid, visited, r-1, c);\\n        }\\n            \\n        return cnt;\\n    }\\n    \\n    int findMaxFish(vector<vector<int>>& grid) {\\n        int maxi = 0, n = grid.size(), m = grid[0].size();\\n        vector<vector<bool>> visited(n, vector<bool>(m, false));\\n        \\n        for(int i=0; i<n; i++)  for(int j=0; j<m; j++) \\n                // if it is water cell and not visited the call the dfs function to calculate the total fish and compare with the maximum\\n                if(grid[i][j] && !visited[i][j])   {\\n                    int x = solve(grid, visited, i,  j);\\n                    maxi = max(maxi, x);\\n                }\\n        return maxi;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3949641,
                "title": "best-o-m-n-solution",
                "content": "# Approach\\nBFS Traversal\\n\\n# Complexity\\n- Time complexity:\\n$$O(m*n)$$\\n\\n- Space complexity:\\n$$O(m*n)$$ \\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int traversal(int i, int j, vector<vector<int>>& grid, vector<vector<int>>& vis) {\\n        int m = grid.size(), n = grid[0].size();\\n        int fish = 0;\\n        queue <pair<int, int>> q;\\n        q.push({i, j});\\n        vis[i][j] = 1;\\n        int drow[] = {-1, 0, 1, 0};\\n        int dcol[] = {0, 1, 0, -1};\\n        while (!q.empty()) {\\n            int r = q.front().first;\\n            int c = q.front().second;\\n            q.pop();\\n            fish += grid[r][c];\\n            for (int i = 0; i < 4; i++) {\\n                int nr = r + drow[i];\\n                int nc = c + dcol[i];\\n                if (nr >= 0 && nr < m && nc >= 0 && nc < n\\n                    && grid[nr][nc] > 0 && !vis[nr][nc]) {\\n                       q.push({nr, nc});\\n                       vis[nr][nc] = 1;\\n                   }\\n            }\\n        }\\n        return fish;\\n    }\\n\\n    int findMaxFish(vector<vector<int>>& grid) {\\n        int m = grid.size(), n = grid[0].size();\\n        vector<vector<int>> vis(m, vector<int>(n, 0));\\n        int maxFish = 0;\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (grid[i][j] > 0 && !vis[i][j]) {\\n                    int fish = traversal(i, j, grid, vis);\\n                    maxFish = max (maxFish, fish);\\n                }\\n            }\\n        }\\n        return maxFish;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int traversal(int i, int j, vector<vector<int>>& grid, vector<vector<int>>& vis) {\\n        int m = grid.size(), n = grid[0].size();\\n        int fish = 0;\\n        queue <pair<int, int>> q;\\n        q.push({i, j});\\n        vis[i][j] = 1;\\n        int drow[] = {-1, 0, 1, 0};\\n        int dcol[] = {0, 1, 0, -1};\\n        while (!q.empty()) {\\n            int r = q.front().first;\\n            int c = q.front().second;\\n            q.pop();\\n            fish += grid[r][c];\\n            for (int i = 0; i < 4; i++) {\\n                int nr = r + drow[i];\\n                int nc = c + dcol[i];\\n                if (nr >= 0 && nr < m && nc >= 0 && nc < n\\n                    && grid[nr][nc] > 0 && !vis[nr][nc]) {\\n                       q.push({nr, nc});\\n                       vis[nr][nc] = 1;\\n                   }\\n            }\\n        }\\n        return fish;\\n    }\\n\\n    int findMaxFish(vector<vector<int>>& grid) {\\n        int m = grid.size(), n = grid[0].size();\\n        vector<vector<int>> vis(m, vector<int>(n, 0));\\n        int maxFish = 0;\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (grid[i][j] > 0 && !vis[i][j]) {\\n                    int fish = traversal(i, j, grid, vis);\\n                    maxFish = max (maxFish, fish);\\n                }\\n            }\\n        }\\n        return maxFish;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3492192,
                "title": "c-dfs",
                "content": "# Approach\\nAPPLE DFS\\n\\n# Complexity\\n- Time complexity:\\nO(m*n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void solve(int i,int j,int &m,int &n,vector<vector<int>> &g,int &k){\\n        if(i<0||j<0||i>=m||j>=n||g[i][j]==0)return;\\n        k += g[i][j];\\n        g[i][j]  = 0;\\n        solve(i+1,j,m,n,g,k);\\n        solve(i,j+1,m,n,g,k);\\n        solve(i-1,j,m,n,g,k);\\n        solve(i,j-1,m,n,g,k);\\n    }\\n    int findMaxFish(vector<vector<int>>& grid) {\\n        int ans = 0;\\n        int i,j,m=grid.size(),n=grid[0].size(),k;\\n        for(i = 0; i < m; i++){\\n            for(j = 0; j < n; j++){\\n                if(grid[i][j]){\\n                    k = 0;\\n                    solve(i,j,m,n,grid,k);\\n                    cout<<k<<\" \";\\n                    ans = max(ans,k);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void solve(int i,int j,int &m,int &n,vector<vector<int>> &g,int &k){\\n        if(i<0||j<0||i>=m||j>=n||g[i][j]==0)return;\\n        k += g[i][j];\\n        g[i][j]  = 0;\\n        solve(i+1,j,m,n,g,k);\\n        solve(i,j+1,m,n,g,k);\\n        solve(i-1,j,m,n,g,k);\\n        solve(i,j-1,m,n,g,k);\\n    }\\n    int findMaxFish(vector<vector<int>>& grid) {\\n        int ans = 0;\\n        int i,j,m=grid.size(),n=grid[0].size(),k;\\n        for(i = 0; i < m; i++){\\n            for(j = 0; j < n; j++){\\n                if(grid[i][j]){\\n                    k = 0;\\n                    solve(i,j,m,n,grid,k);\\n                    cout<<k<<\" \";\\n                    ans = max(ans,k);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3468865,
                "title": "easy-solution-java-dfs",
                "content": "# Intuition\\nTo find the maximum fish a fisherman can obtain. The zero represent the land and the numbers represent the number of available fish.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- Initialize the maximum variable as global\\n- Create a boolean matrix called visited to keep track on the visited grid.\\n- Create a function dfs, it helps to move to adjacent cells in deep and stop if the grid is already visted or the land is reached.\\n- Increase the max for eachs recursive call.\\n- Update the maximum vairalbe for each dfs call from the findMaxFish() function.\\n> Upvote\\n---\\n\\n\\n\\n# Code\\n```\\nclass Solution {\\n    public int max;\\n    public int findMaxFish(int[][] grid) {\\n        int rlen = grid.length;\\n        int clen = grid[0].length;\\n        int answer = 0;\\n        boolean visited[][] = new boolean[rlen][clen];\\n        for(int i=0;i<rlen;i++){\\n            for(int j=0;j<clen;j++){\\n                if(grid[i][j]!=0 && !visited[i][j]){\\n                    max = 0;\\n                    dfs(grid, rlen, clen,visited, i, j);\\n                    answer = Math.max(max, answer );\\n                }\\n            }\\n        }\\n        return answer;\\n    }\\n    \\n    public void dfs(int[][] grid, int rlen, int clen, boolean[][] visited, int i, int j){\\n        if(i<0||i>=rlen||j<0||j>=clen||visited[i][j]||grid[i][j] == 0){\\n            return;\\n        }\\n        visited[i][j] = true;\\n        max +=grid[i][j];\\n        dfs(grid, rlen, clen, visited, i+1, j);\\n        dfs(grid, rlen, clen, visited, i-1, j);\\n        dfs(grid, rlen, clen, visited, i, j+1);\\n        dfs(grid, rlen, clen, visited, i, j-1);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    public int max;\\n    public int findMaxFish(int[][] grid) {\\n        int rlen = grid.length;\\n        int clen = grid[0].length;\\n        int answer = 0;\\n        boolean visited[][] = new boolean[rlen][clen];\\n        for(int i=0;i<rlen;i++){\\n            for(int j=0;j<clen;j++){\\n                if(grid[i][j]!=0 && !visited[i][j]){\\n                    max = 0;\\n                    dfs(grid, rlen, clen,visited, i, j);\\n                    answer = Math.max(max, answer );\\n                }\\n            }\\n        }\\n        return answer;\\n    }\\n    \\n    public void dfs(int[][] grid, int rlen, int clen, boolean[][] visited, int i, int j){\\n        if(i<0||i>=rlen||j<0||j>=clen||visited[i][j]||grid[i][j] == 0){\\n            return;\\n        }\\n        visited[i][j] = true;\\n        max +=grid[i][j];\\n        dfs(grid, rlen, clen, visited, i+1, j);\\n        dfs(grid, rlen, clen, visited, i-1, j);\\n        dfs(grid, rlen, clen, visited, i, j+1);\\n        dfs(grid, rlen, clen, visited, i, j-1);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3466636,
                "title": "simple-java-bfs",
                "content": "```\\nclass pair{\\n    int x;int y;\\n    pair(int x1,int y1){\\n        x=x1;\\n        y=y1;\\n    }\\n}\\nclass Solution {\\n    public int findMaxFish(int[][] grid) {\\n        int m=grid.length;\\n        int n=grid[0].length;\\n        int max=0;\\n      //  System.out.print(bfs(0,1,grid,m,n)+\" \");\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                if(grid[i][j]>0){\\n                 //   System.out.print(bfs(i,j,grid,m,n)+\" \");\\n                    \\n                    max=Math.max(max,bfs(i,j,grid,m,n));\\n                }\\n            }\\n        }\\n        return max;\\n       \\n    }\\n    public int bfs(int i,int j,int grid[][],int m,int n){\\n        Queue<pair> q=new LinkedList<>();\\n        q.add(new pair(i,j));\\n         int dx[]={-1,1,0,0};\\n        int dy[]={0,0,-1,1};\\n      //  int max=0;\\n        int sum=grid[i][j];\\n        grid[i][j]=0;\\n        while(!q.isEmpty()){\\n            pair it=q.poll();\\n            int x=it.x;\\n            int y=it.y;\\n          //  System.out.print(x+\" \"+y);\\n            for(int p=0;p<4;p++){\\n                int newx=x+dx[p];\\n                int newy=y+dy[p];\\n                if(newx<0 || newy<0 || newx>=m || newy>=n || grid[newx][newy]==0)continue;\\n                q.add(new pair(newx,newy));\\n               \\n                sum+=grid[newx][newy];\\n                 grid[newx][newy]=0;\\n            }\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Breadth-First Search"
                ],
                "code": "```\\nclass pair{\\n    int x;int y;\\n    pair(int x1,int y1){\\n        x=x1;\\n        y=y1;\\n    }\\n}\\nclass Solution {\\n    public int findMaxFish(int[][] grid) {\\n        int m=grid.length;\\n        int n=grid[0].length;\\n        int max=0;\\n      //  System.out.print(bfs(0,1,grid,m,n)+\" \");\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                if(grid[i][j]>0){\\n                 //   System.out.print(bfs(i,j,grid,m,n)+\" \");\\n                    \\n                    max=Math.max(max,bfs(i,j,grid,m,n));\\n                }\\n            }\\n        }\\n        return max;\\n       \\n    }\\n    public int bfs(int i,int j,int grid[][],int m,int n){\\n        Queue<pair> q=new LinkedList<>();\\n        q.add(new pair(i,j));\\n         int dx[]={-1,1,0,0};\\n        int dy[]={0,0,-1,1};\\n      //  int max=0;\\n        int sum=grid[i][j];\\n        grid[i][j]=0;\\n        while(!q.isEmpty()){\\n            pair it=q.poll();\\n            int x=it.x;\\n            int y=it.y;\\n          //  System.out.print(x+\" \"+y);\\n            for(int p=0;p<4;p++){\\n                int newx=x+dx[p];\\n                int newy=y+dy[p];\\n                if(newx<0 || newy<0 || newx>=m || newy>=n || grid[newx][newy]==0)continue;\\n                q.add(new pair(newx,newy));\\n               \\n                sum+=grid[newx][newy];\\n                 grid[newx][newy]=0;\\n            }\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3673143,
                "title": "easy-approach-c-depth-first-search-maximum-number-of-fishes-in-a-grid",
                "content": "# Approach\\nDepth first Search.\\n- Converted each traversed path to land cell so that a separate `visited` array is not required.\\n\\n# Code\\n```cpp []\\nclass Solution {\\npublic:\\n\\n    bool isValid(int i, int j, int n, int m){\\n        return i>=0 && i<n && j>=0 && j<m;\\n    }\\n    int dfs(vector<vector<int>>& grid, int row, int col){\\n        int n = grid.size(), m = grid[0].size();\\n        if(!isValid(row, col, n, m) || grid[row][col] == 0) return 0;\\n        int direc[5] = {0, 1, 0, -1, 0};\\n        int res = grid[row][col];\\n        grid[row][col] = 0;\\n        for(int k=0; k<4; k++) { \\n            res += dfs(grid, row+direc[k], col+direc[k+1]);\\n        }\\n        return res;\\n    }\\n    int findMaxFish(vector<vector<int>>& grid) {\\n        int ans = 0;\\n        for(int i = 0; i< grid.size(); ++i){\\n            for(int j =0; j < grid[0].size(); ++j){\\n                ans = max(ans, dfs(grid, i, j));\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "```cpp []\\nclass Solution {\\npublic:\\n\\n    bool isValid(int i, int j, int n, int m){\\n        return i>=0 && i<n && j>=0 && j<m;\\n    }\\n    int dfs(vector<vector<int>>& grid, int row, int col){\\n        int n = grid.size(), m = grid[0].size();\\n        if(!isValid(row, col, n, m) || grid[row][col] == 0) return 0;\\n        int direc[5] = {0, 1, 0, -1, 0};\\n        int res = grid[row][col];\\n        grid[row][col] = 0;\\n        for(int k=0; k<4; k++) { \\n            res += dfs(grid, row+direc[k], col+direc[k+1]);\\n        }\\n        return res;\\n    }\\n    int findMaxFish(vector<vector<int>>& grid) {\\n        int ans = 0;\\n        for(int i = 0; i< grid.size(); ++i){\\n            for(int j =0; j < grid[0].size(); ++j){\\n                ans = max(ans, dfs(grid, i, j));\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3468041,
                "title": "fully-explained-java-solution",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    public int findMaxFish(int[][] grid) {\\n        int max=0;\\n\\t\\t// Loop over the Entire Grid\\n        for(int i=0;i< grid.length; i++){\\n            for(int j=0; j<grid[0].length; j++){\\n\\t\\t\\t    // only call the dfs call when we encounter a value>0, then find the number of connected land and calculate value and compare it with the previous max\\n                if(grid[i][j]>0){\\n                    max= Math.max(max, dfs(grid, i, j));\\n                }\\n            }\\n        }\\n        return max;\\n    }\\n    \\n    public int dfs(int[][] grid, int i, int j){\\n\\t\\t// if we gets out of bound or its a 0 i.e. water then return 0\\n        if(i<0 || i>=grid.length || j<0 || j>=grid[0].length || grid[i][j]==0) return 0;\\n\\t\\t// if not then mark the grid value to 0 to make sure we do not come back to the same piece of land and cause infinite recursion i.e. stack over flow\\n        int val = grid[i][j];\\n        grid[i][j]=0;\\n\\t\\t// now just go to all 4 direction get the respective counts and add it all together and return it\\n        return val+ dfs(grid, i-1, j)+ dfs(grid, i+1, j)+ dfs(grid, i, j-1)+ dfs(grid, i, j+1);\\n    }\\n    \\n    \\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\n    public int findMaxFish(int[][] grid) {\\n        int max=0;\\n\\t\\t// Loop over the Entire Grid\\n        for(int i=0;i< grid.length; i++){\\n            for(int j=0; j<grid[0].length; j++){\\n\\t\\t\\t    // only call the dfs call when we encounter a value>0, then find the number of connected land and calculate value and compare it with the previous max\\n                if(grid[i][j]>0){\\n                    max= Math.max(max, dfs(grid, i, j));\\n                }\\n            }\\n        }\\n        return max;\\n    }\\n    \\n    public int dfs(int[][] grid, int i, int j){\\n\\t\\t// if we gets out of bound or its a 0 i.e. water then return 0\\n        if(i<0 || i>=grid.length || j<0 || j>=grid[0].length || grid[i][j]==0) return 0;\\n\\t\\t// if not then mark the grid value to 0 to make sure we do not come back to the same piece of land and cause infinite recursion i.e. stack over flow\\n        int val = grid[i][j];\\n        grid[i][j]=0;\\n\\t\\t// now just go to all 4 direction get the respective counts and add it all together and return it\\n        return val+ dfs(grid, i-1, j)+ dfs(grid, i+1, j)+ dfs(grid, i, j-1)+ dfs(grid, i, j+1);\\n    }\\n    \\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3467257,
                "title": "c-dfs",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    void dfs(int row, int col, vector<vector<int>>& grid, vector<vector<int>>& vis, int &fish) {\\n        int n = grid.size(), m = grid[0].size(); \\n        vis[row][col] = 1;\\n        fish += grid[row][col];\\n        int r_dir[4] = {-1, 0, 1, 0};\\n        int c_dir[4] = {0, 1, 0, -1};\\n        for(int i = 0; i < 4; i++) {\\n            int r = row + r_dir[i];\\n            int c = col + c_dir[i];\\n            if(r >= 0 && r < n && c >= 0 && c < m && grid[r][c] && !vis[r][c]) {\\n                dfs(r, c, grid, vis, fish);\\n            }\\n        }\\n    }\\npublic:\\n    int findMaxFish(vector<vector<int>>& grid) {\\n        int n = grid.size(), m = grid[0].size();\\n        vector<vector<int>> vis(n, vector<int>(m, 0));\\n        int max_fish = 0;\\n        for(int i = 0; i < n; i++) {\\n            for(int j = 0; j < m; j++) {\\n                if(grid[i][j] > 0 && !vis[i][j]) {\\n                    int fish = 0;\\n                    dfs(i, j, grid, vis, fish);\\n                    max_fish = max(max_fish, fish);\\n                }\\n            }\\n        }\\n        return max_fish;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    void dfs(int row, int col, vector<vector<int>>& grid, vector<vector<int>>& vis, int &fish) {\\n        int n = grid.size(), m = grid[0].size(); \\n        vis[row][col] = 1;\\n        fish += grid[row][col];\\n        int r_dir[4] = {-1, 0, 1, 0};\\n        int c_dir[4] = {0, 1, 0, -1};\\n        for(int i = 0; i < 4; i++) {\\n            int r = row + r_dir[i];\\n            int c = col + c_dir[i];\\n            if(r >= 0 && r < n && c >= 0 && c < m && grid[r][c] && !vis[r][c]) {\\n                dfs(r, c, grid, vis, fish);\\n            }\\n        }\\n    }\\npublic:\\n    int findMaxFish(vector<vector<int>>& grid) {\\n        int n = grid.size(), m = grid[0].size();\\n        vector<vector<int>> vis(n, vector<int>(m, 0));\\n        int max_fish = 0;\\n        for(int i = 0; i < n; i++) {\\n            for(int j = 0; j < m; j++) {\\n                if(grid[i][j] > 0 && !vis[i][j]) {\\n                    int fish = 0;\\n                    dfs(i, j, grid, vis, fish);\\n                    max_fish = max(max_fish, fish);\\n                }\\n            }\\n        }\\n        return max_fish;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3467120,
                "title": "python-3-easy-solution",
                "content": "The function then defines an inner function called **dfs** that performs a depth-first search on the grid starting from a given position (i,j) and returns the sum of fish in the connected region.\\n\\nThe dfs function first checks if the **current** position is **outside the bounds** of the grid or if the position corresponds to a cell with value **0 or -1** (0 - water, -1 - visited). If any of these conditions is true, the function returns 0 (**no fish here**).\\nOtherwise, the function retrieves the number of fish fish in the current cell, sets the cell value to -1 (*to mark it as visited*), and recursively calls itself on the four adjacent cells (up, left, down, and right), accumulating the fish counts in a variable temp.\\n\\n```\\n    def findMaxFish(self, grid: List[List[int]]) -> int:\\n        N, M = len(grid), len(grid[0])\\n        \\n        def dfs(i, j, temp):\\n            if i < 0 or j < 0 or i >= N or j >= M or grid[i][j] in [0, -1]:\\n                return 0\\n            \\n            fish = grid[i][j]\\n            grid[i][j] = -1  # visited\\n            temp += (fish + dfs(i-1, j, temp) + dfs(i, j-1, temp) + dfs(i+1, j, temp) + dfs(i, j+1, temp))\\n\\n            return temp \\n        \\n        maxi = 0\\n        for i in range(N):\\n            for j in range(M):\\n                if grid[i][j] > 0:\\n                    maxi = max(maxi, dfs(i, j, 0))\\n                \\n        return maxi\\n```",
                "solutionTags": [
                    "Python3",
                    "Depth-First Search"
                ],
                "code": "```\\n    def findMaxFish(self, grid: List[List[int]]) -> int:\\n        N, M = len(grid), len(grid[0])\\n        \\n        def dfs(i, j, temp):\\n            if i < 0 or j < 0 or i >= N or j >= M or grid[i][j] in [0, -1]:\\n                return 0\\n            \\n            fish = grid[i][j]\\n            grid[i][j] = -1  # visited\\n            temp += (fish + dfs(i-1, j, temp) + dfs(i, j-1, temp) + dfs(i+1, j, temp) + dfs(i, j+1, temp))\\n\\n            return temp \\n        \\n        maxi = 0\\n        for i in range(N):\\n            for j in range(M):\\n                if grid[i][j] > 0:\\n                    maxi = max(maxi, dfs(i, j, 0))\\n                \\n        return maxi\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3466759,
                "title": "simple-clean-java-solution",
                "content": "\\n```java []\\npublic class Solution {\\n    int max = 0, cur = 0;\\n    public int findMaxFish(int[][] grid) {\\n        for(int i=0; i<grid.length; i++){\\n            for(int j=0; j<grid[0].length; j++){\\n                if(grid[i][j] == 0) continue;\\n                pass(grid, i, j);\\n                cur = 0;\\n            }\\n        }\\n        return max;\\n    }\\n    void pass(int[][] grid, int i, int j){\\n        if(i < 0 || j < 0 || i >= grid.length || j >= grid[0].length || grid[i][j] == 0)    return;\\n        cur += grid[i][j];\\n        grid[i][j] = 0;\\n        max = Math.max(max,cur);\\n        pass(grid, i+1, j);\\n        pass(grid, i-1, j);\\n        pass(grid, i, j+1);\\n        pass(grid, i, j-1);\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```java []\\npublic class Solution {\\n    int max = 0, cur = 0;\\n    public int findMaxFish(int[][] grid) {\\n        for(int i=0; i<grid.length; i++){\\n            for(int j=0; j<grid[0].length; j++){\\n                if(grid[i][j] == 0) continue;\\n                pass(grid, i, j);\\n                cur = 0;\\n            }\\n        }\\n        return max;\\n    }\\n    void pass(int[][] grid, int i, int j){\\n        if(i < 0 || j < 0 || i >= grid.length || j >= grid[0].length || grid[i][j] == 0)    return;\\n        cur += grid[i][j];\\n        grid[i][j] = 0;\\n        max = Math.max(max,cur);\\n        pass(grid, i+1, j);\\n        pass(grid, i-1, j);\\n        pass(grid, i, j+1);\\n        pass(grid, i, j-1);\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3466660,
                "title": "easy-to-understand-clean-solution-dfs-python-java",
                "content": "**T.C : O(n^2)**\\n\\n**Python**\\n```\\nclass Solution:\\n    def findMaxFish(self, grid: List[List[int]]) -> int:\\n        m, n = len(grid), len(grid[0])\\n        fishes = 0\\n\\n        def catchFish(r, c):\\n            nonlocal fish\\n            if 0 <= r < m and 0 <= c < n and grid[r][c] > 0:\\n                fish += grid[r][c]\\n                grid[r][c] = 0  # mark cell as visited\\n                catchFish(r+1, c)\\n                catchFish(r-1, c)\\n                catchFish(r, c+1)\\n                catchFish(r, c-1)\\n\\n        for r in range(m):\\n            for c in range(n):\\n                if grid[r][c] > 0:\\n                    fish = 0\\n                    catchFish(r, c)\\n                    fishes = max(fishes, fish)\\n\\n        return fishes\\n```\\n\\n**Java**\\n\\n```\\npublic class Solution {\\n    public int findMaxFish(int[][] grid) {\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        int fishes = 0;\\n\\n        // Helper function to catch fish recursively\\n        // Updates the \\'fishes\\' variable as it catches fish\\n        void catchFish(int r, int c) {\\n            if (r >= 0 && r < m && c >= 0 && c < n && grid[r][c] > 0) {\\n                fishes += grid[r][c];\\n                grid[r][c] = 0; // mark cell as visited\\n                catchFish(r+1, c);\\n                catchFish(r-1, c);\\n                catchFish(r, c+1);\\n                catchFish(r, c-1);\\n            }\\n        }\\n\\n        for (int r = 0; r < m; r++) {\\n            for (int c = 0; c < n; c++) {\\n                if (grid[r][c] > 0) {\\n                    int fish = 0;\\n                    catchFish(r, c);\\n                    fishes = Math.max(fishes, fish);\\n                }\\n            }\\n        }\\n\\n        return fishes;\\n    }\\n}\\n",
                "solutionTags": [
                    "Java",
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def findMaxFish(self, grid: List[List[int]]) -> int:\\n        m, n = len(grid), len(grid[0])\\n        fishes = 0\\n\\n        def catchFish(r, c):\\n            nonlocal fish\\n            if 0 <= r < m and 0 <= c < n and grid[r][c] > 0:\\n                fish += grid[r][c]\\n                grid[r][c] = 0  # mark cell as visited\\n                catchFish(r+1, c)\\n                catchFish(r-1, c)\\n                catchFish(r, c+1)\\n                catchFish(r, c-1)\\n\\n        for r in range(m):\\n            for c in range(n):\\n                if grid[r][c] > 0:\\n                    fish = 0\\n                    catchFish(r, c)\\n                    fishes = max(fishes, fish)\\n\\n        return fishes\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3511854,
                "title": "dfs-approach-easy-to-understand-standard-method-c-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThis is a standard traversal problem where we will traverse each component, find the sum of fishes on each component and find out the maximum of all the sums.\\n\\n# Complexity\\n- Time complexity: O(M*N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    using vvi = vector<vector<int>>;\\n    void dfs(vvi& grid, int i,int j, int& sum){\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        if(i>=m || i<0 || j<0 || j>=n){\\n            return;\\n        }\\n        if(grid[i][j]!=0 && grid[i][j]!=-1){\\n            sum += grid[i][j];\\n            grid[i][j]=-1;\\n            dfs(grid,i+1,j,sum);\\n            dfs(grid,i,j+1,sum);\\n            dfs(grid,i-1,j,sum);\\n            dfs(grid,i,j-1,sum);\\n        }\\n    }\\n    int findMaxFish(vector<vector<int>>& grid) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        int ans = INT_MIN;\\n        int sum=0;\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                if(grid[i][j]>0){\\n                    dfs(grid,i,j,sum);\\n                    ans = max(ans,sum);\\n                    sum=0;\\n                }\\n            }\\n        }\\n    \\n        return ans==INT_MIN?0:ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    using vvi = vector<vector<int>>;\\n    void dfs(vvi& grid, int i,int j, int& sum){\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        if(i>=m || i<0 || j<0 || j>=n){\\n            return;\\n        }\\n        if(grid[i][j]!=0 && grid[i][j]!=-1){\\n            sum += grid[i][j];\\n            grid[i][j]=-1;\\n            dfs(grid,i+1,j,sum);\\n            dfs(grid,i,j+1,sum);\\n            dfs(grid,i-1,j,sum);\\n            dfs(grid,i,j-1,sum);\\n        }\\n    }\\n    int findMaxFish(vector<vector<int>>& grid) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        int ans = INT_MIN;\\n        int sum=0;\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                if(grid[i][j]>0){\\n                    dfs(grid,i,j,sum);\\n                    ans = max(ans,sum);\\n                    sum=0;\\n                }\\n            }\\n        }\\n    \\n        return ans==INT_MIN?0:ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3497476,
                "title": "c-bfs-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n- BFS traversal on the Connected Components. Just a variation of LC #200[Number Of Islands]\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- The code uses a breadth-first search (BFS) approach to traverse the water cells in the given grid and calculate the maximum number of fish that can be caught.\\n\\n- For each water cell in the grid, the BFS is applied to find out  all the connected water cells and count the total number of fish in those cells.\\n\\n- The maximum fish count obtained from all the BFS traversals is then returned as the result.\\n\\n# Complexity\\nTime complexity:  O(m * n(m + n))\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n- where m and n are the number of rows and columns in the input grid. In the worst case, we may have to traverse all the water cells in the grid, and each BFS traversal takes O(m + n) time.\\n\\nSpace complexity: O(m * n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n- since we are using a 2D visited matrix to keep track of the visited water cells. In the worst case, all the water cells may need to be visited, requiring a visited matrix of size mn. Additionally, the queue used in BFS will hold a maximum of O(m*n) water cell positions at any point in time.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    int maxFishes = INT_MIN;\\n\\n    void bfs(int row, int col, vector <vector<int>> &grid, vector <vector<int>> &vis, int dx[], int dy[])\\n    {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        \\n        vis[row][col] = 1;\\n        queue <pair<int, int>> q;\\n        q.push({row, col});\\n\\n        int fishes = 0;\\n        while(!q.empty())\\n        {\\n            int x = q.front().first;\\n            int y = q.front().second;\\n\\n            //adding the count of the number of fishes in the current cell\\n            fishes += grid[x][y];\\n            q.pop();\\n\\n            //finding out the current cell neighbours\\n            for(int i = 0; i < 4; i++)\\n            {\\n                int nRow = x + dx[i];\\n                int nCol = y + dy[i];\\n                \\n                //check for the validity of neighbouring row & col\\n                if(nRow >= 0 && nRow < n && nCol >= 0 && nCol < m && grid[nRow][nCol] > 0 && !vis[nRow][nCol])\\n                {\\n                    vis[nRow][nCol] = 1;\\n                    q.push({nRow, nCol});\\n                }\\n            }\\n        }\\n\\n        maxFishes = max(maxFishes, fishes);\\n        return;\\n    }\\n    \\n    int findMaxFish(vector<vector<int>>& grid) \\n    {\\n        //no of rows\\n        int n = grid.size();\\n        \\n        //no of cols\\n        int m = grid[0].size();\\n        \\n        //create the visited matrix to keep track of the water cell\\n        vector <vector <int>> vis(n, vector <int> (m, 0));\\n        \\n        //can move only in 4-directions\\n        int dx[] = {0, 0, 1, -1};\\n        int dy[] = {1, -1, 0, 0};    \\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            for(int j = 0; j < m; j++)\\n            {\\n                if(grid[i][j] > 0 && !vis[i][j])\\n                    bfs(i, j, grid, vis, dx, dy);\\n            }\\n        }\\n        \\n        return maxFishes == INT_MIN ? 0 : maxFishes;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    int maxFishes = INT_MIN;\\n\\n    void bfs(int row, int col, vector <vector<int>> &grid, vector <vector<int>> &vis, int dx[], int dy[])\\n    {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        \\n        vis[row][col] = 1;\\n        queue <pair<int, int>> q;\\n        q.push({row, col});\\n\\n        int fishes = 0;\\n        while(!q.empty())\\n        {\\n            int x = q.front().first;\\n            int y = q.front().second;\\n\\n            //adding the count of the number of fishes in the current cell\\n            fishes += grid[x][y];\\n            q.pop();\\n\\n            //finding out the current cell neighbours\\n            for(int i = 0; i < 4; i++)\\n            {\\n                int nRow = x + dx[i];\\n                int nCol = y + dy[i];\\n                \\n                //check for the validity of neighbouring row & col\\n                if(nRow >= 0 && nRow < n && nCol >= 0 && nCol < m && grid[nRow][nCol] > 0 && !vis[nRow][nCol])\\n                {\\n                    vis[nRow][nCol] = 1;\\n                    q.push({nRow, nCol});\\n                }\\n            }\\n        }\\n\\n        maxFishes = max(maxFishes, fishes);\\n        return;\\n    }\\n    \\n    int findMaxFish(vector<vector<int>>& grid) \\n    {\\n        //no of rows\\n        int n = grid.size();\\n        \\n        //no of cols\\n        int m = grid[0].size();\\n        \\n        //create the visited matrix to keep track of the water cell\\n        vector <vector <int>> vis(n, vector <int> (m, 0));\\n        \\n        //can move only in 4-directions\\n        int dx[] = {0, 0, 1, -1};\\n        int dy[] = {1, -1, 0, 0};    \\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            for(int j = 0; j < m; j++)\\n            {\\n                if(grid[i][j] > 0 && !vis[i][j])\\n                    bfs(i, j, grid, vis, dx, dy);\\n            }\\n        }\\n        \\n        return maxFishes == INT_MIN ? 0 : maxFishes;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3470839,
                "title": "c-dfs-similar-to-number-of-islands",
                "content": "# Intuition\\nSimple DFS involves calculating the sum of different islands and taking the maximum one.\\nSimilar to Number of Islands problem (https://leetcode.com/problems/number-of-islands/).\\n# Approach\\nDepth First Search\\n\\n## Don\\'t forget to upvote and give a like \\uD83D\\uDE43\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int dx[4] = {0,0,-1,1};\\n    int dy[4] = {1,-1,0,0};\\n    void dfs(int x,int y,vector<vector<int>>& grid,int* ans){\\n        for(int next = 0;next<4;next++){\\n            int x1 = x + dx[next];\\n            int y1 = y + dy[next];\\n            if(x1>=0 and y1>=0 and y1<grid[0].size() and x1<grid.size() and grid[x1][y1]!=0){\\n                *ans += grid[x1][y1];\\n                grid[x1][y1] = 0;\\n                dfs(x1,y1,grid,ans);\\n            }\\n        }\\n    }\\n    int findMaxFish(vector<vector<int>>& grid) {\\n        int m = grid.size();\\n        int n  = grid[0].size();\\n        //vector<vector<int>> vis(m,vector<int>(m,0));\\n        int ans = 0;\\n        for(int i = 0;i<m;i++){\\n            for(int j = 0;j<n;j++){\\n                if(grid[i][j] != 0){\\n                    int count = grid[i][j];\\n                    grid[i][j] = 0;\\n                    dfs(i,j,grid,&count);\\n                    ans = max(ans,count);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n### I hope the solution is clear; use the comment section regarding any doubt.",
                "solutionTags": [
                    "C++",
                    "Depth-First Search",
                    "Counting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dx[4] = {0,0,-1,1};\\n    int dy[4] = {1,-1,0,0};\\n    void dfs(int x,int y,vector<vector<int>>& grid,int* ans){\\n        for(int next = 0;next<4;next++){\\n            int x1 = x + dx[next];\\n            int y1 = y + dy[next];\\n            if(x1>=0 and y1>=0 and y1<grid[0].size() and x1<grid.size() and grid[x1][y1]!=0){\\n                *ans += grid[x1][y1];\\n                grid[x1][y1] = 0;\\n                dfs(x1,y1,grid,ans);\\n            }\\n        }\\n    }\\n    int findMaxFish(vector<vector<int>>& grid) {\\n        int m = grid.size();\\n        int n  = grid[0].size();\\n        //vector<vector<int>> vis(m,vector<int>(m,0));\\n        int ans = 0;\\n        for(int i = 0;i<m;i++){\\n            for(int j = 0;j<n;j++){\\n                if(grid[i][j] != 0){\\n                    int count = grid[i][j];\\n                    grid[i][j] = 0;\\n                    dfs(i,j,grid,&count);\\n                    ans = max(ans,count);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3467138,
                "title": "c-simple-bfs-approach",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxi=INT_MIN;\\n    int dx[4]={0,1,0,-1};\\n    int dy[4]={1,0,-1,0};\\n    void f(int i,int j,int m,int n,vector<vector<int>> &grid,vector<vector<int>> &vis)\\n    {\\n        queue<pair<int,int>> q;\\n        q.push({i,j});\\n        vis[i][j]=1;\\n        int s=0;\\n        while(!q.empty())\\n        {\\n            int x=q.front().first;\\n            int y=q.front().second;\\n            s+=grid[x][y];\\n            q.pop();\\n            for(int k=0;k<4;k++)\\n            {\\n                int newx=x+dx[k];\\n                int newy=y+dy[k];\\n                if(newx<0 or newy<0 or newx>=m or newy>=n or vis[newx][newy]==1 or grid[newx][newy]==0)\\n                    continue;\\n                q.push({newx,newy});\\n                vis[newx][newy]=1;\\n            }\\n        }\\n        maxi=max(maxi,s);\\n    }\\n    int findMaxFish(vector<vector<int>>& grid) {\\n        int m=grid.size();\\n        int n=grid[0].size();\\n        vector<vector<int>> vis(m,vector<int>(n,0));\\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                if(grid[i][j]>0 and !vis[i][j])\\n                {\\n                    f(i,j,m,n,grid,vis);\\n                }\\n            }\\n        }\\n        return (maxi==INT_MIN)?0:maxi;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxi=INT_MIN;\\n    int dx[4]={0,1,0,-1};\\n    int dy[4]={1,0,-1,0};\\n    void f(int i,int j,int m,int n,vector<vector<int>> &grid,vector<vector<int>> &vis)\\n    {\\n        queue<pair<int,int>> q;\\n        q.push({i,j});\\n        vis[i][j]=1;\\n        int s=0;\\n        while(!q.empty())\\n        {\\n            int x=q.front().first;\\n            int y=q.front().second;\\n            s+=grid[x][y];\\n            q.pop();\\n            for(int k=0;k<4;k++)\\n            {\\n                int newx=x+dx[k];\\n                int newy=y+dy[k];\\n                if(newx<0 or newy<0 or newx>=m or newy>=n or vis[newx][newy]==1 or grid[newx][newy]==0)\\n                    continue;\\n                q.push({newx,newy});\\n                vis[newx][newy]=1;\\n            }\\n        }\\n        maxi=max(maxi,s);\\n    }\\n    int findMaxFish(vector<vector<int>>& grid) {\\n        int m=grid.size();\\n        int n=grid[0].size();\\n        vector<vector<int>> vis(m,vector<int>(n,0));\\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                if(grid[i][j]>0 and !vis[i][j])\\n                {\\n                    f(i,j,m,n,grid,vis);\\n                }\\n            }\\n        }\\n        return (maxi==INT_MIN)?0:maxi;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3467125,
                "title": "c-solution",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\n    DFS 2D\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> grids;\\n    int n, m, cnt, vis[11][11];\\n    \\n    bool valid(int x, int y) {\\n        if(x >= 0 and x < n and y >= 0 and y < m and !vis[x][y] and grids[x][y]) return true;\\n        else return false;\\n    }\\n    \\n    void dfs(int x, int y) {\\n        if(valid(x, y)) {\\n            vis[x][y] = 1;\\n            cnt += grids[x][y];\\n            dfs(x, y+1);\\n            dfs(x, y-1);\\n            dfs(x+1, y);\\n            dfs(x-1, y);\\n        }\\n    }\\n    \\n    int findMaxFish(vector<vector<int>>& grid) {\\n        n = grid.size();\\n        m = grid[0].size();\\n        grids = grid;\\n        int ans = 0;\\n        for(int i = 0; i < n; i++) {\\n            for(int j = 0; j < m; j++) {\\n                if(!vis[i][j] and grid[i][j]) {\\n                    cnt = 0;\\n                    dfs(i, j);\\n                    ans = max(ans, cnt);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> grids;\\n    int n, m, cnt, vis[11][11];\\n    \\n    bool valid(int x, int y) {\\n        if(x >= 0 and x < n and y >= 0 and y < m and !vis[x][y] and grids[x][y]) return true;\\n        else return false;\\n    }\\n    \\n    void dfs(int x, int y) {\\n        if(valid(x, y)) {\\n            vis[x][y] = 1;\\n            cnt += grids[x][y];\\n            dfs(x, y+1);\\n            dfs(x, y-1);\\n            dfs(x+1, y);\\n            dfs(x-1, y);\\n        }\\n    }\\n    \\n    int findMaxFish(vector<vector<int>>& grid) {\\n        n = grid.size();\\n        m = grid[0].size();\\n        grids = grid;\\n        int ans = 0;\\n        for(int i = 0; i < n; i++) {\\n            for(int j = 0; j < m; j++) {\\n                if(!vis[i][j] and grid[i][j]) {\\n                    cnt = 0;\\n                    dfs(i, j);\\n                    ans = max(ans, cnt);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3466879,
                "title": "dfs-most-simple-solution-c",
                "content": "\\n````\\nclass Solution {\\npublic:\\n    void solve(int i,int j,int &a,int &b,int &sum,int &ans,vector<vector<int>> &g){\\n        ans = max(ans,sum);\\n        if(i<0||j<0||i>=a||j>=b||g[i][j]==0){\\n            return;\\n        }\\n        sum += g[i][j];\\n        g[i][j] = 0;\\n        solve(i+1,j,a,b,sum,ans,g);\\n        solve(i,j+1,a,b,sum,ans,g);\\n        solve(i-1,j,a,b,sum,ans,g);\\n        solve(i,j-1,a,b,sum,ans,g);\\n    }\\n    int findMaxFish(vector<vector<int>>& grid) {\\n        int ans = 0;\\n        int i,j,a = grid.size(),b = grid[0].size();\\n        int sum = 0;\\n        for(i = 0; i < a; i++){\\n            for(j = 0; j < b; j++){\\n                if(grid[i][j]){\\n                    sum = 0;\\n                    solve(i,j,a,b,sum,ans,grid);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n````\\n\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "````\\nclass Solution {\\npublic:\\n    void solve(int i,int j,int &a,int &b,int &sum,int &ans,vector<vector<int>> &g){\\n        ans = max(ans,sum);\\n        if(i<0||j<0||i>=a||j>=b||g[i][j]==0){\\n            return;\\n        }\\n        sum += g[i][j];\\n        g[i][j] = 0;\\n        solve(i+1,j,a,b,sum,ans,g);\\n        solve(i,j+1,a,b,sum,ans,g);\\n        solve(i-1,j,a,b,sum,ans,g);\\n        solve(i,j-1,a,b,sum,ans,g);\\n    }\\n    int findMaxFish(vector<vector<int>>& grid) {\\n        int ans = 0;\\n        int i,j,a = grid.size(),b = grid[0].size();\\n        int sum = 0;\\n        for(i = 0; i < a; i++){\\n            for(j = 0; j < b; j++){\\n                if(grid[i][j]){\\n                    sum = 0;\\n                    solve(i,j,a,b,sum,ans,grid);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3466830,
                "title": "intuitive-javascript-solution-using-dfs",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nDFS\\n\\n# Complexity\\n- Time complexity: O(M * N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(M * N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number[][]} grid\\n * @return {number}\\n */\\nvar findMaxFish = function(grid) {\\n    let max_fishes = 0;\\n    let ROW = grid.length;\\n    let COL = grid[0].length;\\n    \\n    // returns the sum of fishes possible\\n    const DFS = (r, c, visit) => {\\n        \\n        // base cases returns 0; \\n        if( r < 0 || r >= ROW ||\\n            c < 0 || c >= COL || \\n            visit.has(`${r}_${c}`) ||\\n            grid[r][c] == 0 \\n          ){\\n            return 0;\\n        }\\n        \\n        // set visted\\n        visit.add(`${r}_${c}`);\\n        \\n        let sum = grid[r][c]; // add current value to sum\\n        \\n        // check the surrounding nodes\\n        sum += DFS(r, c + 1, visit);\\n        sum += DFS(r, c - 1, visit);\\n        sum += DFS(r + 1, c, visit);\\n        sum += DFS(r - 1, c, visit);\\n        \\n        return sum;\\n    }\\n    \\n    let set = new Set(); // to record all visted nodes\\n    \\n    // go through each cell\\n    for(let r = 0; r < ROW; r++){\\n       for(let c = 0; c < COL; c++){\\n            // if the cell is water\\n           if(grid[r][c] != 0){ \\n               let res = DFS(r, c, set);\\n\\n               //compare the result from DFS to main global variable \\n               max_fishes = Math.max(res, max_fishes);\\n           }\\n       }\\n    }\\n    \\n    return max_fishes; \\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Depth-First Search"
                ],
                "code": "```\\n/**\\n * @param {number[][]} grid\\n * @return {number}\\n */\\nvar findMaxFish = function(grid) {\\n    let max_fishes = 0;\\n    let ROW = grid.length;\\n    let COL = grid[0].length;\\n    \\n    // returns the sum of fishes possible\\n    const DFS = (r, c, visit) => {\\n        \\n        // base cases returns 0; \\n        if( r < 0 || r >= ROW ||\\n            c < 0 || c >= COL || \\n            visit.has(`${r}_${c}`) ||\\n            grid[r][c] == 0 \\n          ){\\n            return 0;\\n        }\\n        \\n        // set visted\\n        visit.add(`${r}_${c}`);\\n        \\n        let sum = grid[r][c]; // add current value to sum\\n        \\n        // check the surrounding nodes\\n        sum += DFS(r, c + 1, visit);\\n        sum += DFS(r, c - 1, visit);\\n        sum += DFS(r + 1, c, visit);\\n        sum += DFS(r - 1, c, visit);\\n        \\n        return sum;\\n    }\\n    \\n    let set = new Set(); // to record all visted nodes\\n    \\n    // go through each cell\\n    for(let r = 0; r < ROW; r++){\\n       for(let c = 0; c < COL; c++){\\n            // if the cell is water\\n           if(grid[r][c] != 0){ \\n               let res = DFS(r, c, set);\\n\\n               //compare the result from DFS to main global variable \\n               max_fishes = Math.max(res, max_fishes);\\n           }\\n       }\\n    }\\n    \\n    return max_fishes; \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3466744,
                "title": "simple-bfs-solution-connected-components-c",
                "content": "\\n# Approach\\nSame as island problem connected component. Using BFS traverse all the components and return the maximum sum of the the components.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: o(n*m)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N*M)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n   /*  dfs(int row,int col,vector<vector<int>>&vis,cnt){\\n        vis[row][col]=1;\\n        cnt+=grid[row][col];\\n        \\n    }*/\\n    int findMaxFish(vector<vector<int>>& grid) {\\n        int cnt = 0;\\n        int m = grid.size();\\n        int n = grid[0].size();\\nvector<vector<int>>vis;\\n        for (int i = 0; i < m; i++)\\n        {\\n            for (int j = 0; j < n; j++)\\n            {\\n                if (grid[i][j] > 0)\\n                {\\n                    queue<pair<int, int>> q;\\n                    q.push({i, j});\\n                    int fish = grid[i][j];\\n                    grid[i][j] = 0;\\n\\n                    while (!q.empty())\\n                    {\\n                        int row = q.front().first;\\n                        int col = q.front().second;\\n                        q.pop();\\n\\n                        if (row > 0 && grid[row - 1][col] > 0)\\n                        {\\n                            fish += grid[row - 1][col];\\n                            q.push({row - 1, col});\\n                            grid[row - 1][col] = 0;\\n                        }\\n                        if (row < m - 1 && grid[row + 1][col] > 0)\\n                        {\\n                            fish += grid[row + 1][col];\\n                            q.push({row + 1, col});\\n                            grid[row + 1][col] = 0;\\n                        }\\n                        if (col > 0 && grid[row][col - 1] > 0)\\n                        {\\n                            fish += grid[row][col - 1];\\n                            q.push({row, col - 1});\\n                            grid[row][col - 1] = 0;\\n                        }\\n                        if (col < n - 1 && grid[row][col + 1] > 0)\\n                        {\\n                            fish += grid[row][col + 1];\\n                            q.push({row, col + 1});\\n                            grid[row][col + 1] = 0;\\n                        }\\n                    }\\n\\n                    cnt = max(cnt, fish);\\n                              grid[i][j] = fish;\\n                }\\n            }\\n        }\\n\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n   /*  dfs(int row,int col,vector<vector<int>>&vis,cnt){\\n        vis[row][col]=1;\\n        cnt+=grid[row][col];\\n        \\n    }*/\\n    int findMaxFish(vector<vector<int>>& grid) {\\n        int cnt = 0;\\n        int m = grid.size();\\n        int n = grid[0].size();\\nvector<vector<int>>vis;\\n        for (int i = 0; i < m; i++)\\n        {\\n            for (int j = 0; j < n; j++)\\n            {\\n                if (grid[i][j] > 0)\\n                {\\n                    queue<pair<int, int>> q;\\n                    q.push({i, j});\\n                    int fish = grid[i][j];\\n                    grid[i][j] = 0;\\n\\n                    while (!q.empty())\\n                    {\\n                        int row = q.front().first;\\n                        int col = q.front().second;\\n                        q.pop();\\n\\n                        if (row > 0 && grid[row - 1][col] > 0)\\n                        {\\n                            fish += grid[row - 1][col];\\n                            q.push({row - 1, col});\\n                            grid[row - 1][col] = 0;\\n                        }\\n                        if (row < m - 1 && grid[row + 1][col] > 0)\\n                        {\\n                            fish += grid[row + 1][col];\\n                            q.push({row + 1, col});\\n                            grid[row + 1][col] = 0;\\n                        }\\n                        if (col > 0 && grid[row][col - 1] > 0)\\n                        {\\n                            fish += grid[row][col - 1];\\n                            q.push({row, col - 1});\\n                            grid[row][col - 1] = 0;\\n                        }\\n                        if (col < n - 1 && grid[row][col + 1] > 0)\\n                        {\\n                            fish += grid[row][col + 1];\\n                            q.push({row, col + 1});\\n                            grid[row][col + 1] = 0;\\n                        }\\n                    }\\n\\n                    cnt = max(cnt, fish);\\n                              grid[i][j] = fish;\\n                }\\n            }\\n        }\\n\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3466663,
                "title": "concise-dfs-c",
                "content": "```\\nclass Solution {\\n    vector<int> dx = {-1, 0, 1, 0}, dy = {0, 1, 0, -1};\\n    int dfs(int i, int j, vector<vector<int>>& grid, vector<vector<int>>& vis, int n, int m) {\\n        vis[i][j] = 1;\\n        int cnt = grid[i][j];\\n        \\n        for(int k=0; k<4; k++) {\\n            int x = i + dx[k], y = j + dy[k];\\n            if(x >= 0 && x < n && y >= 0 && y < m && grid[x][y] > 0 && !vis[x][y]) {\\n                cnt += dfs(x, y, grid, vis, n, m);\\n            }\\n        }\\n        return cnt;\\n    }\\npublic:\\n    int findMaxFish(vector<vector<int>>& grid) {\\n        int n = grid.size(), m = grid[0].size(), ans = 0;\\n        vector<vector<int>> vis(n, vector<int>(m));\\n        \\n        for(int i=0; i<n; i++) {\\n            for(int j=0; j<m; j++) {\\n                if(grid[i][j] > 0 && !vis[i][j]) {\\n                    ans = max(ans, dfs(i, j, grid, vis, n, m));\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    vector<int> dx = {-1, 0, 1, 0}, dy = {0, 1, 0, -1};\\n    int dfs(int i, int j, vector<vector<int>>& grid, vector<vector<int>>& vis, int n, int m) {\\n        vis[i][j] = 1;\\n        int cnt = grid[i][j];\\n        \\n        for(int k=0; k<4; k++) {\\n            int x = i + dx[k], y = j + dy[k];\\n            if(x >= 0 && x < n && y >= 0 && y < m && grid[x][y] > 0 && !vis[x][y]) {\\n                cnt += dfs(x, y, grid, vis, n, m);\\n            }\\n        }\\n        return cnt;\\n    }\\npublic:\\n    int findMaxFish(vector<vector<int>>& grid) {\\n        int n = grid.size(), m = grid[0].size(), ans = 0;\\n        vector<vector<int>> vis(n, vector<int>(m));\\n        \\n        for(int i=0; i<n; i++) {\\n            for(int j=0; j<m; j++) {\\n                if(grid[i][j] > 0 && !vis[i][j]) {\\n                    ans = max(ans, dfs(i, j, grid, vis, n, m));\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4003882,
                "title": "easy-dfs-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution\\n{\\npublic:\\n    bool check(int row, int col, int n, int m)\\n    {\\n        if (row >= 0 && row < n && col >= 0 && col < m)\\n        {\\n            return true;\\n        }\\n        return false;\\n    }\\n    \\n    int dfs(vector<vector<int>> &grid, int row, int col, vector<vector<bool>> &visited)\\n    {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        \\n        if (!check(row, col, n, m) || grid[row][col] == 0 || visited[row][col])\\n        {\\n            return 0;\\n        }\\n        \\n        visited[row][col] = true;\\n        int curr_fish = grid[row][col];\\n        int dir[4][2] = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};\\n        \\n        for(int i = 0; i < 4; i++)\\n        {\\n            int newR = row + dir[i][0];\\n            int newC = col + dir[i][1];\\n            curr_fish += dfs(grid, newR, newC, visited);\\n        }\\n        \\n        return curr_fish;\\n    }\\n    \\n    int findMaxFish(vector<vector<int>> &grid)\\n    {\\n        int max_fish = 0;\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            for(int j = 0; j < m; j++)\\n            {\\n                if(grid[i][j] > 0)\\n                {\\n                    vector<vector<bool>> visited(n, vector<bool>(m, false));\\n                    int curr_fish_now = dfs(grid, i, j, visited);\\n                    max_fish = max(curr_fish_now, max_fish);\\n                }\\n            }\\n        }\\n        \\n        return max_fish;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution\\n{\\npublic:\\n    bool check(int row, int col, int n, int m)\\n    {\\n        if (row >= 0 && row < n && col >= 0 && col < m)\\n        {\\n            return true;\\n        }\\n        return false;\\n    }\\n    \\n    int dfs(vector<vector<int>> &grid, int row, int col, vector<vector<bool>> &visited)\\n    {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        \\n        if (!check(row, col, n, m) || grid[row][col] == 0 || visited[row][col])\\n        {\\n            return 0;\\n        }\\n        \\n        visited[row][col] = true;\\n        int curr_fish = grid[row][col];\\n        int dir[4][2] = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};\\n        \\n        for(int i = 0; i < 4; i++)\\n        {\\n            int newR = row + dir[i][0];\\n            int newC = col + dir[i][1];\\n            curr_fish += dfs(grid, newR, newC, visited);\\n        }\\n        \\n        return curr_fish;\\n    }\\n    \\n    int findMaxFish(vector<vector<int>> &grid)\\n    {\\n        int max_fish = 0;\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            for(int j = 0; j < m; j++)\\n            {\\n                if(grid[i][j] > 0)\\n                {\\n                    vector<vector<bool>> visited(n, vector<bool>(m, false));\\n                    int curr_fish_now = dfs(grid, i, j, visited);\\n                    max_fish = max(curr_fish_now, max_fish);\\n                }\\n            }\\n        }\\n        \\n        return max_fish;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3843214,
                "title": "easy-dfs-beats-70-java",
                "content": "# Complexity\\n- Time complexity: $$O(n*m)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n*m)$$ , stack space.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    private final List<Integer[]> directions = List.of(\\n            new Integer[]{1, 0}, new Integer[]{-1, 0}, new Integer[]{0, 1}, new Integer[]{0, -1}\\n    );\\n\\n    public int findMaxFish(int[][] grid) {\\n        int maxFish = 0;\\n        for (int i = 0; i < grid.length; i++) {\\n            for (int j = 0; j < grid[0].length; j++) {\\n                if (grid[i][j] != 0) maxFish = Math.max(maxFish, dfs(i, j, grid));\\n            }\\n        }\\n        return maxFish;\\n    }\\n\\n    private int dfs(int i, int j, int[][] grid) {\\n        if (notValid(i, j, grid) || grid[i][j] == 0) return 0;\\n        int fish = grid[i][j];\\n        grid[i][j] = 0;\\n        for (Integer[] direction: directions) {\\n            int x = i + direction[0], y = j + direction[1];\\n            fish += dfs(x, y, grid);\\n        }\\n        return fish;\\n    }\\n\\n    private boolean notValid(int i, int j, int[][] grid) {\\n        return i < 0 || i >= grid.length || j < 0 || j >= grid[0].length;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    private final List<Integer[]> directions = List.of(\\n            new Integer[]{1, 0}, new Integer[]{-1, 0}, new Integer[]{0, 1}, new Integer[]{0, -1}\\n    );\\n\\n    public int findMaxFish(int[][] grid) {\\n        int maxFish = 0;\\n        for (int i = 0; i < grid.length; i++) {\\n            for (int j = 0; j < grid[0].length; j++) {\\n                if (grid[i][j] != 0) maxFish = Math.max(maxFish, dfs(i, j, grid));\\n            }\\n        }\\n        return maxFish;\\n    }\\n\\n    private int dfs(int i, int j, int[][] grid) {\\n        if (notValid(i, j, grid) || grid[i][j] == 0) return 0;\\n        int fish = grid[i][j];\\n        grid[i][j] = 0;\\n        for (Integer[] direction: directions) {\\n            int x = i + direction[0], y = j + direction[1];\\n            fish += dfs(x, y, grid);\\n        }\\n        return fish;\\n    }\\n\\n    private boolean notValid(int i, int j, int[][] grid) {\\n        return i < 0 || i >= grid.length || j < 0 || j >= grid[0].length;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3670649,
                "title": "c-simple-straight-forward-approach",
                "content": "```\\nclass Solution {\\npublic:\\n    int findMaxFish(vector<vector<int>>& grid) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        int ans = 0;\\n        \\n        vector<vector<int>> vis(m,vector<int> (n,0));\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                if(!vis[i][j] && grid[i][j] > 0){\\n                    int fish = 0;\\n                    cout<<i<<\" \"<<j<<endl;\\n                    bfs(i,j,fish,vis,grid);\\n                    ans = max(fish,ans);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n    \\n    void bfs(int i, int j,int &fish, vector<vector<int>>& vis,vector<vector<int>> grid){\\n        \\n        int m = grid.size();\\n        int n = grid[0].size();\\n        int drows[] = {-1,0,1,0};\\n        int dcols[] = {0,1,0,-1};\\n        queue<pair<int,int>> q;\\n        q.push({i,j});\\n        \\n        vis[i][j] = 1;\\n        fish += grid[i][j];\\n        \\n        while(!q.empty()){\\n            auto it = q.front();\\n            q.pop();\\n            int row = it.first;\\n            int col = it.second;\\n            \\n            for(int k=0;k<4;k++){\\n                int nrow = row + drows[k];\\n                int ncol = col + dcols[k];\\n                if(nrow>=0 && nrow<m && ncol>=0 && ncol<n && !vis[nrow][ncol] && grid[nrow][ncol] > 0 ){\\n                    q.push({nrow,ncol});\\n                    vis[nrow][ncol] = 1;\\n                    fish += grid[nrow][ncol];\\n                }\\n            }\\n        }\\n    }\\n};\\n```\\n\\n![image](https://assets.leetcode.com/users/images/39451a8b-4887-46f6-9b8f-b994e2e40253_1687453528.6643982.jpeg)\\n\\n**please upvote!! if you like.**\\ncomment below\\uD83D\\uDC47",
                "solutionTags": [
                    "C",
                    "Breadth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findMaxFish(vector<vector<int>>& grid) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        int ans = 0;\\n        \\n        vector<vector<int>> vis(m,vector<int> (n,0));\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                if(!vis[i][j] && grid[i][j] > 0){\\n                    int fish = 0;\\n                    cout<<i<<\" \"<<j<<endl;\\n                    bfs(i,j,fish,vis,grid);\\n                    ans = max(fish,ans);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n    \\n    void bfs(int i, int j,int &fish, vector<vector<int>>& vis,vector<vector<int>> grid){\\n        \\n        int m = grid.size();\\n        int n = grid[0].size();\\n        int drows[] = {-1,0,1,0};\\n        int dcols[] = {0,1,0,-1};\\n        queue<pair<int,int>> q;\\n        q.push({i,j});\\n        \\n        vis[i][j] = 1;\\n        fish += grid[i][j];\\n        \\n        while(!q.empty()){\\n            auto it = q.front();\\n            q.pop();\\n            int row = it.first;\\n            int col = it.second;\\n            \\n            for(int k=0;k<4;k++){\\n                int nrow = row + drows[k];\\n                int ncol = col + dcols[k];\\n                if(nrow>=0 && nrow<m && ncol>=0 && ncol<n && !vis[nrow][ncol] && grid[nrow][ncol] > 0 ){\\n                    q.push({nrow,ncol});\\n                    vis[nrow][ncol] = 1;\\n                    fish += grid[nrow][ncol];\\n                }\\n            }\\n        }\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3666202,
                "title": "java-dfs-boolean-array-of-visited-cells",
                "content": "# Complexity\\n- Time complexity: O(N)\\n\\n# Code\\n```\\nclass Solution {\\n    public int findMaxFish(int[][] grid) {\\n        int[][] directions = new int[][]{{-1, 0}, {1, 0}, {0, 1}, {0, -1}};\\n        boolean[][] visited = new boolean[grid.length][grid[0].length];\\n        for (int i = 0; i < visited.length; i++) for (int j = 0; j < visited[i].length; j++) if (grid[i][j] == 0) visited[i][j] = true;\\n        int max = 0;\\n        for (int i = 0; i < grid.length; i++) {\\n            for (int j = 0; j < grid[i].length; j++) {\\n                if (visited[i][j]) continue;\\n                int fish = dfs(i, j, grid, visited, directions);\\n                max = Math.max(fish, max);\\n            }\\n        }\\n        return max;\\n    }\\n\\n    private int dfs(int r, int c, int[][] grid, boolean[][] visited, int[][] directions) {\\n        if (!cellExists(r, c, grid)) return 0;\\n\\n        if (visited[r][c]) return 0;\\n        visited[r][c] = true;\\n        int sum = grid[r][c];\\n        for (int[] dir : directions) {\\n            sum += dfs(r + dir[0], c + dir[1], grid, visited, directions);\\n        }\\n        return sum;\\n    }\\n\\n    private boolean cellExists(int r, int c, int[][] grid) {\\n        return r >= 0 && r < grid.length && c >= 0 && c < grid[0].length;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int findMaxFish(int[][] grid) {\\n        int[][] directions = new int[][]{{-1, 0}, {1, 0}, {0, 1}, {0, -1}};\\n        boolean[][] visited = new boolean[grid.length][grid[0].length];\\n        for (int i = 0; i < visited.length; i++) for (int j = 0; j < visited[i].length; j++) if (grid[i][j] == 0) visited[i][j] = true;\\n        int max = 0;\\n        for (int i = 0; i < grid.length; i++) {\\n            for (int j = 0; j < grid[i].length; j++) {\\n                if (visited[i][j]) continue;\\n                int fish = dfs(i, j, grid, visited, directions);\\n                max = Math.max(fish, max);\\n            }\\n        }\\n        return max;\\n    }\\n\\n    private int dfs(int r, int c, int[][] grid, boolean[][] visited, int[][] directions) {\\n        if (!cellExists(r, c, grid)) return 0;\\n\\n        if (visited[r][c]) return 0;\\n        visited[r][c] = true;\\n        int sum = grid[r][c];\\n        for (int[] dir : directions) {\\n            sum += dfs(r + dir[0], c + dir[1], grid, visited, directions);\\n        }\\n        return sum;\\n    }\\n\\n    private boolean cellExists(int r, int c, int[][] grid) {\\n        return r >= 0 && r < grid.length && c >= 0 && c < grid[0].length;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3617423,
                "title": "java-simple-dfs-algorithm-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    int dir[][]={{0,1},{0,-1},{1,0},{-1,0}};\\n    public int explore(int a[][],int i,int j,boolean vis[][]){\\n        if(i<0||j<0||i>=a.length||j>=a[0].length||a[i][j]==0||vis[i][j]){\\n            return 0;\\n        }\\n        vis[i][j] = true;\\n        int sum = 0 ;\\n    for(int t=0;t<dir.length;t++){\\n      sum+=  explore(a,i+dir[t][0],j+dir[t][1],vis);\\n    }\\n\\n    return sum+a[i][j];\\n\\n    }\\n    public int findMaxFish(int[][] grid) {\\n        int max = 0;\\n        boolean vis[][] = new boolean[grid.length][grid[0].length];\\n        for(int i=0;i<grid.length;i++){\\n            for(int j=0;j<grid[0].length;j++){\\n                if(grid[i][j]!=0){\\n                    int val = explore(grid,  i,  j,vis);\\n                    if(max<val)max = val;\\n                }\\n            }\\n        }\\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    int dir[][]={{0,1},{0,-1},{1,0},{-1,0}};\\n    public int explore(int a[][],int i,int j,boolean vis[][]){\\n        if(i<0||j<0||i>=a.length||j>=a[0].length||a[i][j]==0||vis[i][j]){\\n            return 0;\\n        }\\n        vis[i][j] = true;\\n        int sum = 0 ;\\n    for(int t=0;t<dir.length;t++){\\n      sum+=  explore(a,i+dir[t][0],j+dir[t][1],vis);\\n    }\\n\\n    return sum+a[i][j];\\n\\n    }\\n    public int findMaxFish(int[][] grid) {\\n        int max = 0;\\n        boolean vis[][] = new boolean[grid.length][grid[0].length];\\n        for(int i=0;i<grid.length;i++){\\n            for(int j=0;j<grid[0].length;j++){\\n                if(grid[i][j]!=0){\\n                    int val = explore(grid,  i,  j,vis);\\n                    if(max<val)max = val;\\n                }\\n            }\\n        }\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3551393,
                "title": "bfs-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic: \\n    void bfs(int row,int col,vector<vector<int>>&vis,vector<vector<int>>grid,int delrow[],int delcol[],int &sum) \\n    {\\n        vis[row][col]=1;   \\n        //int sum=0;\\n        queue<pair<int,int>>q; \\n        q.push({row,col});  \\n         sum+=grid[row][col];\\n        int n=grid.size(),m=grid[0].size(); \\n        while(!q.empty()) \\n        {\\n            int row=q.front().first; \\n            int col=q.front().second; \\n            q.pop();  \\n           \\n                   for(int i=0;i<4;i++){\\n                    int nrow=delrow[i]+row;\\n                    int ncol=delcol[i]+col; \\n                    if(nrow>=0 && nrow<n && ncol>=0 && ncol<m && grid[nrow][ncol]!=0 && !vis[nrow][ncol]) \\n                    {\\n                        vis[nrow][ncol]=1; \\n                        sum+=grid[nrow][ncol]; \\n                        q.push({nrow,ncol});\\n                    }\\n                \\n            }\\n        } \\n     // return sum;\\n\\n    }\\n    int findMaxFish(vector<vector<int>>& grid) { \\n        if(grid.size()==1 && grid[0][0]==0 && grid[0].size()==1) \\n        return 0;\\n        int n=grid.size(),m=grid[0].size(); \\n        vector<vector<int>>vis(n,vector<int>(m,0)); \\n        int maxi=0,sum=0; \\n        int delrow[]={-1,0,1,0}; \\n         int delcol[]={0,1,0,-1};\\n        for(int row=0;row<n;row++) \\n        {\\n            for(int col=0;col<m;col++) \\n            {  \\n                if(!vis[row][col] && grid[row][col]!=0) \\n                {\\n                  bfs(row,col,vis,grid,delrow,delcol,sum);\\n                  maxi=max(sum,maxi); \\n                  sum=0;\\n                }\\n\\n            }\\n        }  \\n        return maxi;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic: \\n    void bfs(int row,int col,vector<vector<int>>&vis,vector<vector<int>>grid,int delrow[],int delcol[],int &sum) \\n    {\\n        vis[row][col]=1;   \\n        //int sum=0;\\n        queue<pair<int,int>>q; \\n        q.push({row,col});  \\n         sum+=grid[row][col];\\n        int n=grid.size(),m=grid[0].size(); \\n        while(!q.empty()) \\n        {\\n            int row=q.front().first; \\n            int col=q.front().second; \\n            q.pop();  \\n           \\n                   for(int i=0;i<4;i++){\\n                    int nrow=delrow[i]+row;\\n                    int ncol=delcol[i]+col; \\n                    if(nrow>=0 && nrow<n && ncol>=0 && ncol<m && grid[nrow][ncol]!=0 && !vis[nrow][ncol]) \\n                    {\\n                        vis[nrow][ncol]=1; \\n                        sum+=grid[nrow][ncol]; \\n                        q.push({nrow,ncol});\\n                    }\\n                \\n            }\\n        } \\n     // return sum;\\n\\n    }\\n    int findMaxFish(vector<vector<int>>& grid) { \\n        if(grid.size()==1 && grid[0][0]==0 && grid[0].size()==1) \\n        return 0;\\n        int n=grid.size(),m=grid[0].size(); \\n        vector<vector<int>>vis(n,vector<int>(m,0)); \\n        int maxi=0,sum=0; \\n        int delrow[]={-1,0,1,0}; \\n         int delcol[]={0,1,0,-1};\\n        for(int row=0;row<n;row++) \\n        {\\n            for(int col=0;col<m;col++) \\n            {  \\n                if(!vis[row][col] && grid[row][col]!=0) \\n                {\\n                  bfs(row,col,vis,grid,delrow,delcol,sum);\\n                  maxi=max(sum,maxi); \\n                  sum=0;\\n                }\\n\\n            }\\n        }  \\n        return maxi;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3544967,
                "title": "dfs-c-simple",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> dim = {{1,0},{0,1},{-1,0},{0,-1}};\\n    int dfs(vector<vector<int>>& grid,int r,int c){\\n        if(r < 0 || c < 0 || r >= grid.size() || c >= grid[0].size() || grid[r][c] == 0)\\n            return 0;\\n        int ans = grid[r][c];\\n        grid[r][c] = 0;\\n        for(auto a : dim){\\n            ans += dfs(grid,r + a[0],c + a[1]);\\n        }\\n        return ans;   \\n    }\\n    int findMaxFish(vector<vector<int>>& grid) {\\n        int ans = 0;\\n        int r = grid.size();\\n        int c = grid[0].size();\\n        for(int i = 0;i < r;i++){\\n            for(int j = 0;j < c;j++){\\n                ans = max(ans,dfs(grid,i,j));\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> dim = {{1,0},{0,1},{-1,0},{0,-1}};\\n    int dfs(vector<vector<int>>& grid,int r,int c){\\n        if(r < 0 || c < 0 || r >= grid.size() || c >= grid[0].size() || grid[r][c] == 0)\\n            return 0;\\n        int ans = grid[r][c];\\n        grid[r][c] = 0;\\n        for(auto a : dim){\\n            ans += dfs(grid,r + a[0],c + a[1]);\\n        }\\n        return ans;   \\n    }\\n    int findMaxFish(vector<vector<int>>& grid) {\\n        int ans = 0;\\n        int r = grid.size();\\n        int c = grid[0].size();\\n        for(int i = 0;i < r;i++){\\n            for(int j = 0;j < c;j++){\\n                ans = max(ans,dfs(grid,i,j));\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3516055,
                "title": "2658-maximum-number-of-fish-in-a-grid-java",
                "content": "```\\nclass Solution {\\n    public int dfs(int [][] grid,int i,int j)\\n    {\\n        if(i<0||j<0||i>=grid.length||j>=grid[0].length||grid[i][j]==0)\\n            return 0;\\n        int res=grid[i][j];\\n        grid[i][j]=0;\\n        res+=dfs(grid,i+1,j);\\n        res+=dfs(grid,i,j+1);\\n        res+=dfs(grid,i-1,j);\\n        res+=dfs(grid,i,j-1);\\n        return res;\\n    }\\n    \\n    public int findMaxFish(int[][] grid) {\\n        int ans=0;\\n        for(int i=0;i<grid.length;i++)\\n        { \\n            for(int j=0;j<grid[0].length;j++)\\n            {\\n                if(grid[i][j]!=0)\\n                  ans=Math.max(ans,dfs(grid,i,j));  \\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public int dfs(int [][] grid,int i,int j)\\n    {\\n        if(i<0||j<0||i>=grid.length||j>=grid[0].length||grid[i][j]==0)\\n            return 0;\\n        int res=grid[i][j];\\n        grid[i][j]=0;\\n        res+=dfs(grid,i+1,j);\\n        res+=dfs(grid,i,j+1);\\n        res+=dfs(grid,i-1,j);\\n        res+=dfs(grid,i,j-1);\\n        return res;\\n    }\\n    \\n    public int findMaxFish(int[][] grid) {\\n        int ans=0;\\n        for(int i=0;i<grid.length;i++)\\n        { \\n            for(int j=0;j<grid[0].length;j++)\\n            {\\n                if(grid[i][j]!=0)\\n                  ans=Math.max(ans,dfs(grid,i,j));  \\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3488243,
                "title": "c-bfs-dfs-both-approaches",
                "content": "## DFS\\n```\\nclass Solution {\\npublic:\\n    void dfs(vector<vector<int>>& grid, vector<vector<int>>& vis, int i, int j, int& csum){\\n        if (vis[i][j] || grid[i][j]==0)return;\\n        vis[i][j]=1;\\n        csum+= grid[i][j];\\n        int dx[]= {1,-1,0,0};\\n        int dy[]= {0,0,1,-1};\\n        for (int it=0; it<4; it++){\\n            int nr= dx[it]+i;\\n            int nc= dy[it]+j;\\n            if (nr>=0 && nc>=0 && nr<grid.size() && nc<grid[0].size())dfs(grid,vis,nr,nc,csum);\\n        }\\n    }\\n    int findMaxFish(vector<vector<int>>& grid) {\\n        int n= grid.size();\\n        int m= grid[0].size();\\n        vector<vector<int>> vis(n,vector<int>(m,0));\\n        int ans=0;\\n        for (int i=0; i<n; i++){\\n            for (int j=0; j<m; j++){\\n                if (!vis[i][j] && grid[i][j]>0){\\n                    int csum=0;\\n                    dfs(grid,vis,i,j,csum);\\n                    ans= max(ans,csum);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n## BFS\\n```\\nclass Solution {\\npublic:\\n    void bfs(vector<vector<int>>& grid, vector<vector<int>>& vis, int i, int j, int& curr){\\n        queue<pair<int,int>> q;\\n        q.push({i,j});\\n        curr+= grid[i][j];\\n        vis[i][j]=1;\\n        int dx[]= {1,-1,0,0};\\n        int dy[]= {0,0,-1,1};\\n        while (!q.empty()){\\n            int x= q.front().first;\\n            int y= q.front().second;\\n            q.pop();\\n            for (int it=0; it<4; it++){\\n                int nr= x+dx[it];\\n                int nc= y+dy[it];\\n                if (nc>=0 && nc<grid[0].size() && nr>=0 && nr<grid.size() && !vis[nr][nc] && grid[nr][nc]>0){\\n                    q.push({nr,nc});\\n                    curr+= grid[nr][nc];\\n                    vis[nr][nc]=1;\\n                }\\n            }\\n        }\\n    }\\n    int findMaxFish(vector<vector<int>>& grid) {\\n        int ans=0;\\n        int n= grid.size();\\n        int m= grid[0].size();\\n        vector<vector<int>> vis(n,vector<int>(m,0));\\n        for (int i=0; i<n; i++){\\n            for(int j=0; j<m; j++){\\n                if (!vis[i][j] && grid[i][j]>0){\\n                    int curr=0;\\n                    bfs(grid,vis,i,j,curr);\\n                    ans= max(ans,curr);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void dfs(vector<vector<int>>& grid, vector<vector<int>>& vis, int i, int j, int& csum){\\n        if (vis[i][j] || grid[i][j]==0)return;\\n        vis[i][j]=1;\\n        csum+= grid[i][j];\\n        int dx[]= {1,-1,0,0};\\n        int dy[]= {0,0,1,-1};\\n        for (int it=0; it<4; it++){\\n            int nr= dx[it]+i;\\n            int nc= dy[it]+j;\\n            if (nr>=0 && nc>=0 && nr<grid.size() && nc<grid[0].size())dfs(grid,vis,nr,nc,csum);\\n        }\\n    }\\n    int findMaxFish(vector<vector<int>>& grid) {\\n        int n= grid.size();\\n        int m= grid[0].size();\\n        vector<vector<int>> vis(n,vector<int>(m,0));\\n        int ans=0;\\n        for (int i=0; i<n; i++){\\n            for (int j=0; j<m; j++){\\n                if (!vis[i][j] && grid[i][j]>0){\\n                    int csum=0;\\n                    dfs(grid,vis,i,j,csum);\\n                    ans= max(ans,csum);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    void bfs(vector<vector<int>>& grid, vector<vector<int>>& vis, int i, int j, int& curr){\\n        queue<pair<int,int>> q;\\n        q.push({i,j});\\n        curr+= grid[i][j];\\n        vis[i][j]=1;\\n        int dx[]= {1,-1,0,0};\\n        int dy[]= {0,0,-1,1};\\n        while (!q.empty()){\\n            int x= q.front().first;\\n            int y= q.front().second;\\n            q.pop();\\n            for (int it=0; it<4; it++){\\n                int nr= x+dx[it];\\n                int nc= y+dy[it];\\n                if (nc>=0 && nc<grid[0].size() && nr>=0 && nr<grid.size() && !vis[nr][nc] && grid[nr][nc]>0){\\n                    q.push({nr,nc});\\n                    curr+= grid[nr][nc];\\n                    vis[nr][nc]=1;\\n                }\\n            }\\n        }\\n    }\\n    int findMaxFish(vector<vector<int>>& grid) {\\n        int ans=0;\\n        int n= grid.size();\\n        int m= grid[0].size();\\n        vector<vector<int>> vis(n,vector<int>(m,0));\\n        for (int i=0; i<n; i++){\\n            for(int j=0; j<m; j++){\\n                if (!vis[i][j] && grid[i][j]>0){\\n                    int curr=0;\\n                    bfs(grid,vis,i,j,curr);\\n                    ans= max(ans,curr);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3485575,
                "title": "god-level-sol",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> dirx{1,-1,0,0};\\n    vector<int> diry{0,0,1,-1};\\n    int solve(int x,int y,vector<vector<int>>& grid,vector<vector<bool>>& vis,int n,int m){\\n        \\n        queue<pair<int,int>> q;\\n        q.push({x,y});\\n        vis[x][y]=true;\\n        int sum=0;\\n        \\n        while(!q.empty()){\\n            auto curr=q.front();\\n            int xx=curr.first;\\n            int yy=curr.second;\\n            sum+=grid[xx][yy];\\n            q.pop();\\n            \\n            for(int i=0;i<4;i++){\\n                int nx=xx+dirx[i];\\n                int ny=yy+diry[i];\\n                \\n                if(ny<0 || ny==m || nx<0 || nx==n || grid[nx][ny]==0 || vis[nx][ny]) continue;\\n                \\n                q.push({nx,ny});\\n                vis[nx][ny]=true;\\n            }\\n        }\\n        \\n        return sum;\\n    }\\n    int findMaxFish(vector<vector<int>>& grid) {\\n        \\n        int res=0;\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        \\n        vector<vector<bool>> vis(n,vector<bool>(m,false));\\n        \\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(grid[i][j]!=0 && !vis[i][j]){\\n                    int ans=solve(i,j,grid,vis,n,m);\\n                    res=max(res,ans);\\n                }\\n            }\\n        }\\n        \\n        return res;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> dirx{1,-1,0,0};\\n    vector<int> diry{0,0,1,-1};\\n    int solve(int x,int y,vector<vector<int>>& grid,vector<vector<bool>>& vis,int n,int m){\\n        \\n        queue<pair<int,int>> q;\\n        q.push({x,y});\\n        vis[x][y]=true;\\n        int sum=0;\\n        \\n        while(!q.empty()){\\n            auto curr=q.front();\\n            int xx=curr.first;\\n            int yy=curr.second;\\n            sum+=grid[xx][yy];\\n            q.pop();\\n            \\n            for(int i=0;i<4;i++){\\n                int nx=xx+dirx[i];\\n                int ny=yy+diry[i];\\n                \\n                if(ny<0 || ny==m || nx<0 || nx==n || grid[nx][ny]==0 || vis[nx][ny]) continue;\\n                \\n                q.push({nx,ny});\\n                vis[nx][ny]=true;\\n            }\\n        }\\n        \\n        return sum;\\n    }\\n    int findMaxFish(vector<vector<int>>& grid) {\\n        \\n        int res=0;\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        \\n        vector<vector<bool>> vis(n,vector<bool>(m,false));\\n        \\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(grid[i][j]!=0 && !vis[i][j]){\\n                    int ans=solve(i,j,grid,vis,n,m);\\n                    res=max(res,ans);\\n                }\\n            }\\n        }\\n        \\n        return res;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3481241,
                "title": "c-bfs-graphs-easy-approach",
                "content": "Here is my c++ code for this problem.\\n\\n# Complexity\\n- Time complexity:$$O(4*n*m)$$\\n\\n- Space complexity:$$O(n*m)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool valid(int i, int j, int n, int m){\\n        return i>=0 && j>=0 && i<n && j<m;\\n    }\\n    int findMaxFish(vector<vector<int>>& grid) {\\n        vector<vector<int>>v(grid.size(), vector<int>(grid[0].size(), 0));\\n        for(int i=0; i<grid.size(); i++){\\n            for(int j=0; j<grid[0].size(); j++){\\n                if(!grid[i][j]){\\n                    v[i][j]=1;\\n                }\\n            }\\n        }\\n        int ans=0;\\n        for(int i=0; i<v.size(); i++){\\n            for(int j=0; j<v[0].size(); j++){\\n                if(!v[i][j]){\\n                    v[i][j]=1;\\n                    int cnt=0;\\n                    queue<pair<int, int>>q;\\n                    q.push({i, j});\\n                    while(!q.empty()){\\n                        int x=q.front().first, y=q.front().second;\\n                        cnt+=grid[x][y];\\n                        q.pop();\\n                        int r[4]={-1, 1, 0, 0};\\n                        int c[4]={0, 0, 1, -1};\\n                        for(int k=0; k<4; k++){\\n                            int row=r[k]+x, col=c[k]+y;\\n                            if(valid(row, col, v.size(), v[0].size()) && !v[row][col]){\\n                                v[row][col]=1;\\n                                q.push({row, col});\\n                            }\\n                        }\\n                    }\\n                    ans=max(ans, cnt);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Breadth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool valid(int i, int j, int n, int m){\\n        return i>=0 && j>=0 && i<n && j<m;\\n    }\\n    int findMaxFish(vector<vector<int>>& grid) {\\n        vector<vector<int>>v(grid.size(), vector<int>(grid[0].size(), 0));\\n        for(int i=0; i<grid.size(); i++){\\n            for(int j=0; j<grid[0].size(); j++){\\n                if(!grid[i][j]){\\n                    v[i][j]=1;\\n                }\\n            }\\n        }\\n        int ans=0;\\n        for(int i=0; i<v.size(); i++){\\n            for(int j=0; j<v[0].size(); j++){\\n                if(!v[i][j]){\\n                    v[i][j]=1;\\n                    int cnt=0;\\n                    queue<pair<int, int>>q;\\n                    q.push({i, j});\\n                    while(!q.empty()){\\n                        int x=q.front().first, y=q.front().second;\\n                        cnt+=grid[x][y];\\n                        q.pop();\\n                        int r[4]={-1, 1, 0, 0};\\n                        int c[4]={0, 0, 1, -1};\\n                        for(int k=0; k<4; k++){\\n                            int row=r[k]+x, col=c[k]+y;\\n                            if(valid(row, col, v.size(), v[0].size()) && !v[row][col]){\\n                                v[row][col]=1;\\n                                q.push({row, col});\\n                            }\\n                        }\\n                    }\\n                    ans=max(ans, cnt);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3471545,
                "title": "easy-to-understand-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSimple DFS with node sum\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- We simply traverse whole grid and check if current cell is having value greater than 0 or not. \\n- If it has value greater than 0 we call a DFS function which provides us the sum of current node along with it\\'s adjacent cells in the grid (Four Directionally).\\n- It goes without saying that in our DFS function we must keep an eye upon whether the function call for the current indexes in the grid is out of grid boundaries or not.\\n- Along with this we also need to maintain the visited array inorder to avoid duplicate function calls.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. -->\\n$$O(m*n)$$\\nwhere m is number of rows and n is number of columns in the grid. \\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(m*n)$$\\nwhere m is number of rows and n is number of columns in the grid.\\n# Code\\nThe below code is self explanatory.\\n```\\nclass Solution {\\npublic:\\n    // Function to check out of boundary condition\\n    bool isSafe(int i,int j,int m, int n){\\n        if (i<0 or i>=m or j<0 or j>=n) return false;\\n        return true;\\n    }\\n    int solve(vector<vector<int>> &g, int i , int j, int m, int n, int &tmp, vector<vector<int>> &vis){\\n        // Check out of Boundary condition\\n        if (!isSafe(i,j,m,n)) return 0;\\n        if (g[i][j]==0) return 0;\\n        // If current cell is already visited return 0.\\n        if (vis[i][j]==1) return 0;\\n\\n        // mark current node as visited\\n        vis[i][j]=1;\\n        \\n        // add the value of current node\\n        tmp+= g[i][j];\\n        \\n        // call DFS for adjancent cells\\n        solve(g,i+1,j,m,n,tmp,vis);\\n        solve(g,i-1,j,m,n,tmp,vis);\\n        solve(g,i,j-1,m,n,tmp,vis);\\n        solve(g,i,j+1,m,n,tmp,vis);\\n        \\n        return tmp;\\n    }\\n    int findMaxFish(vector<vector<int>>& g) {\\n        int ans=0, res=0;\\n        int m=g.size(), n=g[0].size();\\n        vector<vector<int>> vis(m, vector<int> (n,0));\\n        for (int i=0;i<m;i++)\\n        {\\n            for (int j=0;j<n;j++){\\n                if (g[i][j]>0) \\n                {   int tmp=0;\\n                    ans=solve(g, i ,j ,m,n, tmp, vis);\\n                    res=max(res,ans);\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    // Function to check out of boundary condition\\n    bool isSafe(int i,int j,int m, int n){\\n        if (i<0 or i>=m or j<0 or j>=n) return false;\\n        return true;\\n    }\\n    int solve(vector<vector<int>> &g, int i , int j, int m, int n, int &tmp, vector<vector<int>> &vis){\\n        // Check out of Boundary condition\\n        if (!isSafe(i,j,m,n)) return 0;\\n        if (g[i][j]==0) return 0;\\n        // If current cell is already visited return 0.\\n        if (vis[i][j]==1) return 0;\\n\\n        // mark current node as visited\\n        vis[i][j]=1;\\n        \\n        // add the value of current node\\n        tmp+= g[i][j];\\n        \\n        // call DFS for adjancent cells\\n        solve(g,i+1,j,m,n,tmp,vis);\\n        solve(g,i-1,j,m,n,tmp,vis);\\n        solve(g,i,j-1,m,n,tmp,vis);\\n        solve(g,i,j+1,m,n,tmp,vis);\\n        \\n        return tmp;\\n    }\\n    int findMaxFish(vector<vector<int>>& g) {\\n        int ans=0, res=0;\\n        int m=g.size(), n=g[0].size();\\n        vector<vector<int>> vis(m, vector<int> (n,0));\\n        for (int i=0;i<m;i++)\\n        {\\n            for (int j=0;j<n;j++){\\n                if (g[i][j]>0) \\n                {   int tmp=0;\\n                    ans=solve(g, i ,j ,m,n, tmp, vis);\\n                    res=max(res,ans);\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3468895,
                "title": "bfs-java-super-easy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n\\nclass Pair{\\n    int first;\\n    int second;\\n    Pair(int first,int second){\\n        this.first=first;\\n        this.second=second;\\n    }\\n}\\n\\nclass Solution {\\n    public int findMaxFish(int[][] grid) {\\n        \\n        int n=grid.length;\\n        int m=grid[0].length;\\n        \\n        int visit[][]=new int[n][m];\\n        int delRow[]={0,0,-1,1};\\n        int delCol[]={1,-1,0,0};\\n        \\n        int ans[]={0};\\n        int max=0;\\n  \\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(visit[i][j]==0 && grid[i][j]!=0){\\n\\n                    bfs(i,j,grid,visit,ans,delRow,delCol);\\n                    max=Math.max(max,ans[0]);\\n                    ans[0]=0;\\n                }\\n            }\\n        }\\n        return max;\\n    }\\n    \\n    public void bfs(int i,int j,int[][] grid,int visit[][],int ans[],int delRow[],int delCol[]){\\n        int n=grid.length;\\n        int m=grid[0].length;\\n        \\n        Queue<Pair>q=new LinkedList<>();\\n        q.add(new Pair(i,j));\\n        visit[i][j]=1;\\n        \\n        while(!q.isEmpty()){\\n            int row=q.peek().first;\\n            int col=q.peek().second;\\n            q.poll();\\n            ans[0]+=grid[row][col];\\n            for(int k=0;k<4;k++){\\n                int nrow=row+delRow[k];\\n                int ncol=col+delCol[k];\\n                \\n                \\n                if(nrow<n && nrow>=0 && ncol<m && ncol>=0 && visit[nrow][ncol]==0 && grid[nrow][ncol]!=0){\\n                    q.add(new Pair(nrow,ncol));\\n                    visit[nrow][ncol]=1;\\n                }\\n            }\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n\\nclass Pair{\\n    int first;\\n    int second;\\n    Pair(int first,int second){\\n        this.first=first;\\n        this.second=second;\\n    }\\n}\\n\\nclass Solution {\\n    public int findMaxFish(int[][] grid) {\\n        \\n        int n=grid.length;\\n        int m=grid[0].length;\\n        \\n        int visit[][]=new int[n][m];\\n        int delRow[]={0,0,-1,1};\\n        int delCol[]={1,-1,0,0};\\n        \\n        int ans[]={0};\\n        int max=0;\\n  \\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(visit[i][j]==0 && grid[i][j]!=0){\\n\\n                    bfs(i,j,grid,visit,ans,delRow,delCol);\\n                    max=Math.max(max,ans[0]);\\n                    ans[0]=0;\\n                }\\n            }\\n        }\\n        return max;\\n    }\\n    \\n    public void bfs(int i,int j,int[][] grid,int visit[][],int ans[],int delRow[],int delCol[]){\\n        int n=grid.length;\\n        int m=grid[0].length;\\n        \\n        Queue<Pair>q=new LinkedList<>();\\n        q.add(new Pair(i,j));\\n        visit[i][j]=1;\\n        \\n        while(!q.isEmpty()){\\n            int row=q.peek().first;\\n            int col=q.peek().second;\\n            q.poll();\\n            ans[0]+=grid[row][col];\\n            for(int k=0;k<4;k++){\\n                int nrow=row+delRow[k];\\n                int ncol=col+delCol[k];\\n                \\n                \\n                if(nrow<n && nrow>=0 && ncol<m && ncol>=0 && visit[nrow][ncol]==0 && grid[nrow][ncol]!=0){\\n                    q.add(new Pair(nrow,ncol));\\n                    visit[nrow][ncol]=1;\\n                }\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3468240,
                "title": "c",
                "content": "![image](https://assets.leetcode.com/users/images/cea41f0c-e7be-4699-951b-5a0c9d475d8f_1682827066.2703393.png)\\n```\\n#define MAX(a,b) (a) > (b) ? (a) : (b)\\n\\nconst int dir[4][2] = {{1, 0}, {0, 1}, {-1, 0}, {0, -1}};\\n\\nvoid dfs(int** grid, int r, int c, int rSize, int cSize, int* cnt) {\\n    if (r < 0 || r >= rSize || c < 0 || c >= cSize || grid[r][c] == 0) return;\\n    (*cnt) += grid[r][c];\\n    grid[r][c] = 0;\\n    for (int i = 0; i < 4; i++) {\\n        dfs(grid, r+dir[i][0], c+dir[i][1], rSize, cSize, cnt);\\n    }\\n}\\n\\nint findMaxFish(int** grid, int gridSize, int* gridColSize) {\\n    int ans = 0, cnt = 0;\\n    for (int i = 0; i < gridSize; i++) {\\n        for (int j = 0; j < gridColSize[i]; j++) {\\n            if (grid[i][j] != 0) {\\n                dfs(grid, i, j, gridSize, gridColSize[i], &cnt);\\n                ans = MAX(ans, cnt);\\n                cnt = 0;\\n            }\\n        }\\n    }\\n    return ans;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n#define MAX(a,b) (a) > (b) ? (a) : (b)\\n\\nconst int dir[4][2] = {{1, 0}, {0, 1}, {-1, 0}, {0, -1}};\\n\\nvoid dfs(int** grid, int r, int c, int rSize, int cSize, int* cnt) {\\n    if (r < 0 || r >= rSize || c < 0 || c >= cSize || grid[r][c] == 0) return;\\n    (*cnt) += grid[r][c];\\n    grid[r][c] = 0;\\n    for (int i = 0; i < 4; i++) {\\n        dfs(grid, r+dir[i][0], c+dir[i][1], rSize, cSize, cnt);\\n    }\\n}\\n\\nint findMaxFish(int** grid, int gridSize, int* gridColSize) {\\n    int ans = 0, cnt = 0;\\n    for (int i = 0; i < gridSize; i++) {\\n        for (int j = 0; j < gridColSize[i]; j++) {\\n            if (grid[i][j] != 0) {\\n                dfs(grid, i, j, gridSize, gridColSize[i], &cnt);\\n                ans = MAX(ans, cnt);\\n                cnt = 0;\\n            }\\n        }\\n    }\\n    return ans;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3467612,
                "title": "easiest-solution-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Pair{\\n    int first;\\n    int second;\\n    Pair(int first,int second){\\n        this.first=first;\\n        this.second=second;\\n    }\\n}\\nclass Solution {\\n    public int findMaxFish(int[][] grid) {\\n        int n=grid.length;\\n        int m=grid[0].length;\\n        int vis[][]=new int [n][m];\\n        int delrow[]={0,0,-1,1};\\n        int delcol[]={1,-1,0,0};\\n        int ans[]={0};\\n        int max=0;\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(vis[i][j]==0 && grid[i][j]!=0){\\n                    bfs(i,j,grid,vis,ans,delrow,delcol);\\n                    max=Math.max(max,ans[0]);\\n                    ans[0]=0;\\n                }\\n            }\\n        }\\n        return max;\\n    }\\n    public void bfs(int i,int j,int[][] grid,int visit[][],int ans[],int delRow[],int delCol[]){\\n        int n=grid.length;\\n        int m=grid[0].length;\\n        \\n        Queue<Pair>q=new LinkedList<>();\\n        q.add(new Pair(i,j));\\n        visit[i][j]=1;\\n        \\n        while(!q.isEmpty()){\\n            int row=q.peek().first;\\n            int col=q.peek().second;\\n            q.poll();\\n            ans[0]+=grid[row][col];\\n            for(int k=0;k<4;k++){\\n                int nrow=row+delRow[k];\\n                int ncol=col+delCol[k];\\n                \\n                \\n                if(nrow<n && nrow>=0 && ncol<m && ncol>=0 && visit[nrow][ncol]==0 && grid[nrow][ncol]!=0){\\n                    q.add(new Pair(nrow,ncol));\\n                    visit[nrow][ncol]=1;\\n                }\\n            }\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Pair{\\n    int first;\\n    int second;\\n    Pair(int first,int second){\\n        this.first=first;\\n        this.second=second;\\n    }\\n}\\nclass Solution {\\n    public int findMaxFish(int[][] grid) {\\n        int n=grid.length;\\n        int m=grid[0].length;\\n        int vis[][]=new int [n][m];\\n        int delrow[]={0,0,-1,1};\\n        int delcol[]={1,-1,0,0};\\n        int ans[]={0};\\n        int max=0;\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(vis[i][j]==0 && grid[i][j]!=0){\\n                    bfs(i,j,grid,vis,ans,delrow,delcol);\\n                    max=Math.max(max,ans[0]);\\n                    ans[0]=0;\\n                }\\n            }\\n        }\\n        return max;\\n    }\\n    public void bfs(int i,int j,int[][] grid,int visit[][],int ans[],int delRow[],int delCol[]){\\n        int n=grid.length;\\n        int m=grid[0].length;\\n        \\n        Queue<Pair>q=new LinkedList<>();\\n        q.add(new Pair(i,j));\\n        visit[i][j]=1;\\n        \\n        while(!q.isEmpty()){\\n            int row=q.peek().first;\\n            int col=q.peek().second;\\n            q.poll();\\n            ans[0]+=grid[row][col];\\n            for(int k=0;k<4;k++){\\n                int nrow=row+delRow[k];\\n                int ncol=col+delCol[k];\\n                \\n                \\n                if(nrow<n && nrow>=0 && ncol<m && ncol>=0 && visit[nrow][ncol]==0 && grid[nrow][ncol]!=0){\\n                    q.add(new Pair(nrow,ncol));\\n                    visit[nrow][ncol]=1;\\n                }\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3467563,
                "title": "java-solution-using-dfs",
                "content": "```\\nclass Solution {\\n    public int findMaxFish(int[][] grid) {\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        int maxFish = 0;\\n        boolean [][]vis = new boolean[m][n];\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (grid[i][j] != 0) { \\n                    maxFish = Math.max(maxFish, dfs(i, j,grid));\\n                }\\n            }\\n        }\\n        return maxFish;\\n    }\\n    private int dfs(int i, int j, int[][] grid) {\\n      \\n       \\n        int m = grid.length;\\n        int n = grid[0].length;\\n        if(i<0 || i >= m || j < 0 || j >= n || grid[i][j] == 0){\\n            return 0;\\n        }\\n        int fish = grid[i][j]; \\n        grid[i][j] = 0;\\n        fish += dfs(i-1, j, grid);\\n        fish += dfs(i, j+1, grid);\\n        fish += dfs(i+1, j, grid);\\n        fish += dfs(i, j-1, grid);\\n        return fish;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    public int findMaxFish(int[][] grid) {\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        int maxFish = 0;\\n        boolean [][]vis = new boolean[m][n];\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (grid[i][j] != 0) { \\n                    maxFish = Math.max(maxFish, dfs(i, j,grid));\\n                }\\n            }\\n        }\\n        return maxFish;\\n    }\\n    private int dfs(int i, int j, int[][] grid) {\\n      \\n       \\n        int m = grid.length;\\n        int n = grid[0].length;\\n        if(i<0 || i >= m || j < 0 || j >= n || grid[i][j] == 0){\\n            return 0;\\n        }\\n        int fish = grid[i][j]; \\n        grid[i][j] = 0;\\n        fish += dfs(i-1, j, grid);\\n        fish += dfs(i, j+1, grid);\\n        fish += dfs(i+1, j, grid);\\n        fish += dfs(i, j-1, grid);\\n        return fish;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3467557,
                "title": "easy-to-understand-simple-and-easy-code-dfs",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    private:\\n    int f(int row,int col,vector<vector<int>>& grid,vector<vector<int>>& vis,int drow[],int dcol[]){\\n        vis[row][col]=1;\\n        int n = grid.size();\\n        int m = grid[0].size();\\n         int x = 0 ;\\n         for(int i = 0 ; i < 4 ;i ++){\\n             int nrow = row + drow[i];\\n             int ncol = col + dcol[i];\\n             if(nrow >= 0 && nrow < n && ncol >= 0 && ncol < m && grid[nrow][ncol] != 0 && !vis[nrow][ncol] ){\\n             x = x + grid[nrow][ncol] + f(nrow,ncol,grid,vis,drow,dcol);\\n             }\\n         }\\n         return x;\\n    }\\npublic:\\n    int findMaxFish(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        vector<vector<int>>vis(n,vector<int>(m,0));\\n        int drow[] = {0,-1,0,1};\\n        int dcol[] = {-1,0,1,0};\\n        int maxi = 0 ;\\n        for(int i = 0; i < n ; i++){\\n            for(int j = 0 ;j < m ; j++){\\n                if(grid[i][j] > 0 ){\\n                int x = grid[i][j];\\n              int maxi1 = x + f(i,j,grid,vis,drow,dcol);\\n              maxi = max(maxi , maxi1);\\n                }\\n            }\\n        }\\n        return maxi;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n    private:\\n    int f(int row,int col,vector<vector<int>>& grid,vector<vector<int>>& vis,int drow[],int dcol[]){\\n        vis[row][col]=1;\\n        int n = grid.size();\\n        int m = grid[0].size();\\n         int x = 0 ;\\n         for(int i = 0 ; i < 4 ;i ++){\\n             int nrow = row + drow[i];\\n             int ncol = col + dcol[i];\\n             if(nrow >= 0 && nrow < n && ncol >= 0 && ncol < m && grid[nrow][ncol] != 0 && !vis[nrow][ncol] ){\\n             x = x + grid[nrow][ncol] + f(nrow,ncol,grid,vis,drow,dcol);\\n             }\\n         }\\n         return x;\\n    }\\npublic:\\n    int findMaxFish(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        vector<vector<int>>vis(n,vector<int>(m,0));\\n        int drow[] = {0,-1,0,1};\\n        int dcol[] = {-1,0,1,0};\\n        int maxi = 0 ;\\n        for(int i = 0; i < n ; i++){\\n            for(int j = 0 ;j < m ; j++){\\n                if(grid[i][j] > 0 ){\\n                int x = grid[i][j];\\n              int maxi1 = x + f(i,j,grid,vis,drow,dcol);\\n              maxi = max(maxi , maxi1);\\n                }\\n            }\\n        }\\n        return maxi;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3467495,
                "title": "easy-dfs-soln-max-area-of-island",
                "content": "# Intuition\\nThis is similar to [695. Max Area of Island](https://leetcode.com/problems/max-area-of-island/)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    //x = exchange(a, b) --> x gets assigned with a & a is assiigned with b \\n    int f(int i, int j, vector<vector<int>>& grid) {\\n        if(i < 0 || j < 0 || i >= grid.size() || j >= grid[0].size()) {\\n            return 0;\\n        }\\n        if(grid[i][j] == 0) {\\n            return 0;\\n        }\\n\\n        return exchange(grid[i][j], 0) + f(i - 1, j, grid) + f(i, j - 1, grid) + f(i + 1, j, grid) + f(i, j + 1, grid);\\n    }\\n    int findMaxFish(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        int maxi = 0;\\n        \\n        for(int i = 0; i < n; i++) {\\n            for(int j = 0; j < m; j++) {\\n                if(grid[i][j] > 0) {\\n                    maxi = max(maxi, f(i, j, grid));\\n                }\\n            }\\n        }\\n        \\n        return maxi;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    //x = exchange(a, b) --> x gets assigned with a & a is assiigned with b \\n    int f(int i, int j, vector<vector<int>>& grid) {\\n        if(i < 0 || j < 0 || i >= grid.size() || j >= grid[0].size()) {\\n            return 0;\\n        }\\n        if(grid[i][j] == 0) {\\n            return 0;\\n        }\\n\\n        return exchange(grid[i][j], 0) + f(i - 1, j, grid) + f(i, j - 1, grid) + f(i + 1, j, grid) + f(i, j + 1, grid);\\n    }\\n    int findMaxFish(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        int maxi = 0;\\n        \\n        for(int i = 0; i < n; i++) {\\n            for(int j = 0; j < m; j++) {\\n                if(grid[i][j] > 0) {\\n                    maxi = max(maxi, f(i, j, grid));\\n                }\\n            }\\n        }\\n        \\n        return maxi;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3467447,
                "title": "run-dfs",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int findMaxFish(vector<vector<int>>& grid) {\\n        int n = size(grid),m = size(grid[0]), fish = 0, t = 0;\\n        vector<vector<bool>> vis(n,vector<bool>(m));\\n        auto isvalid = [&](int i,int j){return i>=0 && i<n && j>=0 && j<m;};\\n        vector<pair<int,int>> moves{{0,1},{0,-1},{1,0},{-1,0}};\\n        function<void(int,int)> dfs = [&](int i,int j){\\n            t += grid[i][j];\\n            vis[i][j] = true;\\n            for(auto&[u,v]: moves){\\n                int x = i + u, y = j + v;\\n                if(isvalid(x,y) && grid[x][y] && !vis[x][y])\\n                    dfs(x,y);\\n            }\\n        };\\n        for(int i=0; i<n; ++i){\\n            for(int j=0; j<m; ++j){\\n                if(grid[i][j] && !vis[i][j]){\\n                    t = 0;\\n                    dfs(i,j);\\n                    fish = max(fish,t);\\n                }\\n            }\\n        }\\n        return fish;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findMaxFish(vector<vector<int>>& grid) {\\n        int n = size(grid),m = size(grid[0]), fish = 0, t = 0;\\n        vector<vector<bool>> vis(n,vector<bool>(m));\\n        auto isvalid = [&](int i,int j){return i>=0 && i<n && j>=0 && j<m;};\\n        vector<pair<int,int>> moves{{0,1},{0,-1},{1,0},{-1,0}};\\n        function<void(int,int)> dfs = [&](int i,int j){\\n            t += grid[i][j];\\n            vis[i][j] = true;\\n            for(auto&[u,v]: moves){\\n                int x = i + u, y = j + v;\\n                if(isvalid(x,y) && grid[x][y] && !vis[x][y])\\n                    dfs(x,y);\\n            }\\n        };\\n        for(int i=0; i<n; ++i){\\n            for(int j=0; j<m; ++j){\\n                if(grid[i][j] && !vis[i][j]){\\n                    t = 0;\\n                    dfs(i,j);\\n                    fish = max(fish,t);\\n                }\\n            }\\n        }\\n        return fish;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3467349,
                "title": "dfs-c-solution-with-detailed-explanation",
                "content": "\\n# Approach\\nSo, basically this question can be solved using both BFS and DFS. I have solved this using DFS/recursion.\\nFirstly, I have declared a visited matrix with all indices marked -1.\\nNow, its given in question that if grid[i][j]=0 its land otherwise its number of fishes. \\nSo, for 1st recursion call value of grid[i][j] should be >0. In the reursion function first marked the vis[i][j]=0.\\nNow, we have 4 ways(as mentioned in question) in which we can move, so declared two arrays dr and dc with all 4 conditions/ways. We will traverse through grid with conditions.\\nIn this way this will mark all the visited indices as 0 and if the grid is not valid it won\\'t adding the number of fishes to c and return the value of c to main function. So in main function the value is compared with a max variable and the maximum is returened.\\nThank You and hope u understand my solution.\\nOpen for quries.\\n\\n# Complexity\\n- Time complexity:O(n*n)\\n\\n- Space complexity: O(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int c=0;\\n    void rec(int i, int j, int n, int m, vector<vector<int>> &grid, vector<vector<int>> &vis){\\n        vis[i][j]=0;\\n        \\n        int dr[4]={-1, 0, 1, 0};\\n        int dc[4]={0, -1, 0, 1};\\n        \\n        for(int k=0; k<4; k++){\\n            int nr= dr[k]+i;\\n            int nc= dc[k]+j;\\n            \\n            if(nr>=0 && nc>=0 && nr<n && nc<m && grid[nr][nc]>0 && vis[nr][nc]==-1){\\n                c+=grid[nr][nc];\\n                rec(nr, nc, n, m, grid, vis);\\n            }\\n        }\\n    }\\n    \\n    int findMaxFish(vector<vector<int>>& grid) {\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        int maxi=0;\\n        vector<vector<int>> vis(n, vector<int>(m, -1));\\n        \\n        for(int i=0; i<n; i++){\\n            for(int j=0; j<m; j++){\\n                 c=0;\\n                if(grid[i][j]>0 && vis[i][j]==-1){\\n                    c+=grid[i][j];\\n                    rec(i, j, n, m, grid, vis);\\n                    maxi= max(maxi, c);\\n                }\\n            }\\n        }\\n        return maxi;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int c=0;\\n    void rec(int i, int j, int n, int m, vector<vector<int>> &grid, vector<vector<int>> &vis){\\n        vis[i][j]=0;\\n        \\n        int dr[4]={-1, 0, 1, 0};\\n        int dc[4]={0, -1, 0, 1};\\n        \\n        for(int k=0; k<4; k++){\\n            int nr= dr[k]+i;\\n            int nc= dc[k]+j;\\n            \\n            if(nr>=0 && nc>=0 && nr<n && nc<m && grid[nr][nc]>0 && vis[nr][nc]==-1){\\n                c+=grid[nr][nc];\\n                rec(nr, nc, n, m, grid, vis);\\n            }\\n        }\\n    }\\n    \\n    int findMaxFish(vector<vector<int>>& grid) {\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        int maxi=0;\\n        vector<vector<int>> vis(n, vector<int>(m, -1));\\n        \\n        for(int i=0; i<n; i++){\\n            for(int j=0; j<m; j++){\\n                 c=0;\\n                if(grid[i][j]>0 && vis[i][j]==-1){\\n                    c+=grid[i][j];\\n                    rec(i, j, n, m, grid, vis);\\n                    maxi= max(maxi, c);\\n                }\\n            }\\n        }\\n        return maxi;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3467310,
                "title": "easy-explanation-beginner-friendly",
                "content": "\\tclass Solution {\\n\\tpublic:\\n\\n\\t\\tint fun(int row, int col, vector<vector<int>> &vec)\\n\\t\\t{\\n\\t\\t\\tint n = vec.size();\\n\\t\\t\\tint m = vec[0].size();\\n\\t\\t\\tint score = vec[row][col];\\n\\t\\t\\tvec[row][col] = 0;\\n\\n\\t\\t\\tint rt[] = {0, -1, 0, 1};\\n\\t\\t\\tint ct[] = {-1, 0, 1, 0};\\n\\n\\n\\t\\t\\tfor(int i = 0; i < 4; i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tint r = row + rt[i];\\n\\t\\t\\t\\tint c = col + ct[i];\\n\\n\\t\\t\\t\\tif(r >= 0 && r < n && c >= 0 && c < m && vec[r][c] != 0)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tscore = score + fun(r, c, vec);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn score;\\n\\t\\t}\\n\\n\\n\\n\\t\\tint findMaxFish(vector<vector<int>>& grid) \\n\\t\\t{\\n\\t\\t\\tint score = 0;\\n\\t\\t\\tint n = grid.size();\\n\\t\\t\\tint m = grid[0].size();\\n\\n\\n\\t\\t\\tfor(int i = 0; i < n; i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tfor(int j = 0; j < m; j++)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tvector<vector<int>> vec = grid;\\n\\t\\t\\t\\t\\tif(grid[i][j] != 0)\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tscore = max(score, fun(i, j, vec));\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn score;\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "C++",
                    "Breadth-First Search"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\n\\t\\tint fun(int row, int col, vector<vector<int>> &vec)\\n\\t\\t{\\n\\t\\t\\tint n = vec.size();\\n\\t\\t\\tint m = vec[0].size();\\n\\t\\t\\tint score = vec[row][col];\\n\\t\\t\\tvec[row][col] = 0;\\n\\n\\t\\t\\tint rt[] = {0, -1, 0, 1}",
                "codeTag": "Java"
            },
            {
                "id": 3467296,
                "title": "python-bfs-easy-explained",
                "content": "# Intuition\\nIt is same as a standard bfs count problem just the few optimisations are:\\nadding all zeroes to visited as we dont want to vist them (fisherman cant go there)\\nif u already visited another cell while traversing from current cell no need to visit that cell again as it will carry the same value.\\nreturn the max fish caught from a particular cell.\\n\\n\\n# Code\\n```\\nclass Solution:\\n    def findMaxFish(self, grid: List[List[int]]) -> int:\\n        directions = [(0, 1), (1, 0), (-1, 0), (0, -1)]\\n        ROWS = len(grid)\\n        COLS = len(grid[0])\\n        visited = {(i, j) for i in range(ROWS) for j in range(COLS) if grid[i][j] <= 0}\\n\\n        def catch_fish(i, j):\\n            q = deque()\\n            fish = grid[i][j]\\n            visited.add((i, j))\\n            q.append((i, j))\\n            while q:\\n                curr_row, curr_col = q.popleft()\\n                for dr, dc in directions:\\n                    r, c = curr_row + dr, curr_col + dc\\n                    if (r, c) not in visited and 0 <= r < ROWS and 0 <= c < COLS and grid[r][c] > 0:\\n                        fish += grid[r][c]\\n                        visited.add((r, c))\\n                        q.append((r, c))\\n            return fish\\n\\n        max_fish = 0\\n        for i in range(ROWS):\\n            for j in range(COLS):\\n                if (i, j) not in visited and grid[i][j] > 0:\\n                    fish_count = catch_fish(i, j)\\n                    max_fish = max(max_fish, fish_count)\\n        return max_fish\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findMaxFish(self, grid: List[List[int]]) -> int:\\n        directions = [(0, 1), (1, 0), (-1, 0), (0, -1)]\\n        ROWS = len(grid)\\n        COLS = len(grid[0])\\n        visited = {(i, j) for i in range(ROWS) for j in range(COLS) if grid[i][j] <= 0}\\n\\n        def catch_fish(i, j):\\n            q = deque()\\n            fish = grid[i][j]\\n            visited.add((i, j))\\n            q.append((i, j))\\n            while q:\\n                curr_row, curr_col = q.popleft()\\n                for dr, dc in directions:\\n                    r, c = curr_row + dr, curr_col + dc\\n                    if (r, c) not in visited and 0 <= r < ROWS and 0 <= c < COLS and grid[r][c] > 0:\\n                        fish += grid[r][c]\\n                        visited.add((r, c))\\n                        q.append((r, c))\\n            return fish\\n\\n        max_fish = 0\\n        for i in range(ROWS):\\n            for j in range(COLS):\\n                if (i, j) not in visited and grid[i][j] > 0:\\n                    fish_count = catch_fish(i, j)\\n                    max_fish = max(max_fish, fish_count)\\n        return max_fish\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3467276,
                "title": "c-very-easy-solution-beginner-friendly",
                "content": "<--------------\\u2B06\\uFE0F\\u2B06\\uFE0F\\u2B06\\uFE0F\\u2B06\\uFE0F\\u2B06\\uFE0F PLEASE UPVOTE \\u2B06\\uFE0F\\u2B06\\uFE0F\\u2B06\\uFE0F\\u2B06\\uFE0F\\u2B06\\uFE0F--------------->\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n<--------------\\u2B06\\uFE0F\\u2B06\\uFE0F\\u2B06\\uFE0F\\u2B06\\uFE0F\\u2B06\\uFE0F PLEASE UPVOTE \\u2B06\\uFE0F\\u2B06\\uFE0F\\u2B06\\uFE0F\\u2B06\\uFE0F\\u2B06\\uFE0F--------------->\\nclass Solution {\\npublic:\\n\\xA0\\xA0\\xA0 \\n\\xA0\\xA0\\xA0 int btts(int i,int j,vector<vector<int>>& grid){\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 queue<pair<int,int>>que;\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 int n = grid.size();\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 int m = grid[0].size();\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 vector<vector<int>>vis(n,vector<int>(m,0));\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 \\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 vis[i][j] = 1;\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 que.push({i,j});\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 \\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 int sum = 0;\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 int drow[] = {-1,0,1,0,-1};\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 int maxi = INT_MIN;\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 while(!que.empty()){\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 int row = que.front().first;\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 int col = que.front().second;\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 que.pop();\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 \\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 sum+= grid[row][col];\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 \\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 for(int i=0;i<4;i++){\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 int nrow = row+drow[i];\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 int ncol = col+drow[i+1];\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 \\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 if(nrow>=0 && nrow<n && ncol>=0 && ncol<m && grid[nrow][ncol] != 0 && !vis[nrow][ncol]){\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 que.push({nrow,ncol});\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 vis[nrow][ncol] = 1;\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 \\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 }\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 }\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 }\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 return sum;\\n\\xA0\\xA0\\xA0 }\\n\\xA0\\xA0\\xA0 int findMaxFish(vector<vector<int>>& grid) {\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 int ans = 0;\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 int n = grid.size();\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 int m = grid[0].size();\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 for(int i=0;i<n;i++){\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 for(int j=0;j<m;j++){\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 if(grid[i][j] > 0){\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 ans = max(ans,btts(i,j,grid));\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 }\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 }\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 }\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 return ans;\\n\\xA0\\xA0\\xA0 }\\n};\\n<--------------\\u2B06\\uFE0F\\u2B06\\uFE0F\\u2B06\\uFE0F\\u2B06\\uFE0F\\u2B06\\uFE0F PLEASE UPVOTE \\u2B06\\uFE0F\\u2B06\\uFE0F\\u2B06\\uFE0F\\u2B06\\uFE0F\\u2B06\\uFE0F--------------->\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n<--------------\\u2B06\\uFE0F\\u2B06\\uFE0F\\u2B06\\uFE0F\\u2B06\\uFE0F\\u2B06\\uFE0F PLEASE UPVOTE \\u2B06\\uFE0F\\u2B06\\uFE0F\\u2B06\\uFE0F\\u2B06\\uFE0F\\u2B06\\uFE0F--------------->\\nclass Solution {\\npublic:\\n\\xA0\\xA0\\xA0 \\n\\xA0\\xA0\\xA0 int btts(int i,int j,vector<vector<int>>& grid){\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 queue<pair<int,int>>que;\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 int n = grid.size();\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 int m = grid[0].size();\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 vector<vector<int>>vis(n,vector<int>(m,0));\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 \\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 vis[i][j] = 1;\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 que.push({i,j});\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 \\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 int sum = 0;\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 int drow[] = {-1,0,1,0,-1};\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 int maxi = INT_MIN;\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 while(!que.empty()){\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 int row = que.front().first;\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 int col = que.front().second;\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 que.pop();\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 \\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 sum+= grid[row][col];\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 \\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 for(int i=0;i<4;i++){\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 int nrow = row+drow[i];\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 int ncol = col+drow[i+1];\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 \\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 if(nrow>=0 && nrow<n && ncol>=0 && ncol<m && grid[nrow][ncol] != 0 && !vis[nrow][ncol]){\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 que.push({nrow,ncol});\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 vis[nrow][ncol] = 1;\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 \\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 }\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 }\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 }\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 return sum;\\n\\xA0\\xA0\\xA0 }\\n\\xA0\\xA0\\xA0 int findMaxFish(vector<vector<int>>& grid) {\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 int ans = 0;\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 int n = grid.size();\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 int m = grid[0].size();\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 for(int i=0;i<n;i++){\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 for(int j=0;j<m;j++){\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 if(grid[i][j] > 0){\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 ans = max(ans,btts(i,j,grid));\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 }\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 }\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 }\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 return ans;\\n\\xA0\\xA0\\xA0 }\\n};\\n<--------------\\u2B06\\uFE0F\\u2B06\\uFE0F\\u2B06\\uFE0F\\u2B06\\uFE0F\\u2B06\\uFE0F PLEASE UPVOTE \\u2B06\\uFE0F\\u2B06\\uFE0F\\u2B06\\uFE0F\\u2B06\\uFE0F\\u2B06\\uFE0F--------------->\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3467210,
                "title": "simple-recursion",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    int f(int i, int j, vector<vector<int>>& grid) {\\n        if(i<0 || j<0 || i>=grid.size() || j>=grid[0].size() || grid[i][j] == 0 || grid[i][j] == -1) return 0;\\n        int ans=grid[i][j];\\n        grid[i][j]=-1;\\n        ans+= f(i+1,j, grid)+ f(i-1,j,grid)+ f(i, j-1,grid)+ f(i,j+1, grid);\\n        return ans;\\n    }\\npublic:\\n    int findMaxFish(vector<vector<int>>& grid) {\\n        int ans=0;\\n        for(int i=0; i<grid.size(); i++) {\\n            for(int j=0; j<grid[0].size(); j++) {\\n                ans= max(ans, f(i, j, grid));\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\n\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    int f(int i, int j, vector<vector<int>>& grid) {\\n        if(i<0 || j<0 || i>=grid.size() || j>=grid[0].size() || grid[i][j] == 0 || grid[i][j] == -1) return 0;\\n        int ans=grid[i][j];\\n        grid[i][j]=-1;\\n        ans+= f(i+1,j, grid)+ f(i-1,j,grid)+ f(i, j-1,grid)+ f(i,j+1, grid);\\n        return ans;\\n    }\\npublic:\\n    int findMaxFish(vector<vector<int>>& grid) {\\n        int ans=0;\\n        for(int i=0; i<grid.size(); i++) {\\n            for(int j=0; j<grid[0].size(); j++) {\\n                ans= max(ans, f(i, j, grid));\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3467048,
                "title": "simple-bfs",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSee the fish in cell take these and search for neighbour cell and take maximum whenever leaving the grid.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nEnter in a cell where grid[row][col]!=-1\\nand search in neighbours cell using bfs whenever leaving that particular cell add this to our fish variable and  put it equal to zero i.e grid[row][col]=0\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n     int dx[4]={1,-1,0,0};\\n     int dy[4]={0,0,1,-1};\\n     int find(int i,int j,vector<vector<int>>& grid,int m,int n)\\n     {\\n         int fish=0;\\n         queue<pair<int,int>> q;\\n         q.push({i,j});\\n         while(!q.empty())\\n         {\\n             int x=q.front().first;\\n             int y=q.front().second;\\n             q.pop();\\n             fish+=grid[x][y];\\n             grid[x][y]=0;\\n             for(int k=0;k<4;k++)\\n             {\\n                 if(x+dx[k] >=0 && x+dx[k] <m && y+dy[k]>=0 && y+dy[k]<n && grid[x+dx[k]][y+dy[k]]!=0)\\n                 {\\n                     q.push({x+dx[k],y+dy[k]});\\n                 }\\n             }\\n             \\n         }\\n         return fish;\\n     }\\n    int findMaxFish(vector<vector<int>>& grid) {\\n        \\n        int m=grid.size(),n=grid[0].size();\\n        int ans=0;\\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                if(grid[i][j]!=0)\\n                {\\n                    int fish=find(i,j,grid,m,n);\\n                    ans=max(ans,fish);\\n                }\\n                \\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Breadth-First Search",
                    "Brainteaser"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n     int dx[4]={1,-1,0,0};\\n     int dy[4]={0,0,1,-1};\\n     int find(int i,int j,vector<vector<int>>& grid,int m,int n)\\n     {\\n         int fish=0;\\n         queue<pair<int,int>> q;\\n         q.push({i,j});\\n         while(!q.empty())\\n         {\\n             int x=q.front().first;\\n             int y=q.front().second;\\n             q.pop();\\n             fish+=grid[x][y];\\n             grid[x][y]=0;\\n             for(int k=0;k<4;k++)\\n             {\\n                 if(x+dx[k] >=0 && x+dx[k] <m && y+dy[k]>=0 && y+dy[k]<n && grid[x+dx[k]][y+dy[k]]!=0)\\n                 {\\n                     q.push({x+dx[k],y+dy[k]});\\n                 }\\n             }\\n             \\n         }\\n         return fish;\\n     }\\n    int findMaxFish(vector<vector<int>>& grid) {\\n        \\n        int m=grid.size(),n=grid[0].size();\\n        int ans=0;\\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                if(grid[i][j]!=0)\\n                {\\n                    int fish=find(i,j,grid,m,n);\\n                    ans=max(ans,fish);\\n                }\\n                \\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3466944,
                "title": "python3-solution",
                "content": "\\n```\\nclass Solution:\\n    def findMaxFish(self, grid: List[List[int]]) -> int:\\n        def dfs(i,j):\\n            visited.add((i, j))\\n           \\n            self.fish += grid[i][j]\\n            for r,c in [[0, 1], [0, -1], [1, 0], [-1, 0]]:\\n                new_r = r + i\\n                new_c = c + j\\n                if 0 <= new_r < m and 0 <= new_c < n and (new_r, new_c) not in visited and grid[new_r][new_c] != 0:\\n                    dfs(new_r, new_c)\\n                \\n            \\n        \\n        m = len(grid)\\n        n = len(grid[0])\\n        ans = 0\\n        self.fish = 0\\n        visited = set()\\n        for i in range(m):\\n            for j in range(n):\\n                if grid[i][j] != 0 and (i,j) not in visited:\\n                    self.fish = 0\\n                    dfs(i,j)\\n                    ans = max(self.fish, ans)\\n        return ans\\n        \\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findMaxFish(self, grid: List[List[int]]) -> int:\\n        def dfs(i,j):\\n            visited.add((i, j))\\n           \\n            self.fish += grid[i][j]\\n            for r,c in [[0, 1], [0, -1], [1, 0], [-1, 0]]:\\n                new_r = r + i\\n                new_c = c + j\\n                if 0 <= new_r < m and 0 <= new_c < n and (new_r, new_c) not in visited and grid[new_r][new_c] != 0:\\n                    dfs(new_r, new_c)\\n                \\n            \\n        \\n        m = len(grid)\\n        n = len(grid[0])\\n        ans = 0\\n        self.fish = 0\\n        visited = set()\\n        for i in range(m):\\n            for j in range(n):\\n                if grid[i][j] != 0 and (i,j) not in visited:\\n                    self.fish = 0\\n                    dfs(i,j)\\n                    ans = max(self.fish, ans)\\n        return ans\\n        \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3466898,
                "title": "easy-dfs-solution-o-n-rust",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nimpl Solution {\\n    pub fn find_max_fish(mut grid: Vec<Vec<i32>>) -> i32 {\\n        let mut ans = 0;\\n\\n        for i in 0..grid.len() {\\n            for j in 0..grid[0].len() {\\n                if grid[i][j] > 0 {\\n                    ans = ans.max(dfs(&mut grid, i, j));\\n                }\\n            }\\n        }\\n        \\n        ans\\n    }\\n}\\n\\nfn dfs(grid: &mut Vec<Vec<i32>>, i: usize, j: usize) -> i32 {\\n    if i >= grid.len() || j >= grid[0].len() || grid[i][j] == 0 { return 0 };\\n    let val = grid[i][j];\\n    grid[i][j] = 0;\\n\\n    dfs(grid, i + 1, j) +\\n    dfs(grid, i - 1, j) +\\n    dfs(grid, i, j + 1) +\\n    dfs(grid, i, j - 1) + val\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn find_max_fish(mut grid: Vec<Vec<i32>>) -> i32 {\\n        let mut ans = 0;\\n\\n        for i in 0..grid.len() {\\n            for j in 0..grid[0].len() {\\n                if grid[i][j] > 0 {\\n                    ans = ans.max(dfs(&mut grid, i, j));\\n                }\\n            }\\n        }\\n        \\n        ans\\n    }\\n}\\n\\nfn dfs(grid: &mut Vec<Vec<i32>>, i: usize, j: usize) -> i32 {\\n    if i >= grid.len() || j >= grid[0].len() || grid[i][j] == 0 { return 0 };\\n    let val = grid[i][j];\\n    grid[i][j] = 0;\\n\\n    dfs(grid, i + 1, j) +\\n    dfs(grid, i - 1, j) +\\n    dfs(grid, i, j + 1) +\\n    dfs(grid, i, j - 1) + val\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3466870,
                "title": "c-dfs-easy",
                "content": "```\\nclass Solution {\\npublic:\\n    int dfs(int r, int c, vector<vector<int>>& g, vector<vector<bool>>& vis){\\n      if(min(r, c) < 0 or r >= g.size() or c >= g[0].size() or vis[r][c] or g[r][c] == 0) return 0;\\n      vis[r][c] = true;\\n      int x = dfs(r + 1, c, g, vis);\\n      int y = dfs(r, c + 1, g, vis);\\n      int z = dfs(r - 1, c, g, vis);\\n      int w = dfs(r, c - 1, g, vis);\\n      return g[r][c] + x + y + z + w;\\n    }\\n    int findMaxFish(vector<vector<int>>& g) {\\n      int ans = 0, m = g.size(), n = g[0].size();\\n      vector<vector<bool>> vis(m, vector<bool>(n, false));\\n      for(int i = 0; i < m; i++){\\n        for(int j = 0; j < n; j++){\\n          if(g[i][j] > 0 and !vis[i][j]) \\n            ans = max(ans, dfs(i, j, g, vis));\\n        }\\n      }\\n      return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dfs(int r, int c, vector<vector<int>>& g, vector<vector<bool>>& vis){\\n      if(min(r, c) < 0 or r >= g.size() or c >= g[0].size() or vis[r][c] or g[r][c] == 0) return 0;\\n      vis[r][c] = true;\\n      int x = dfs(r + 1, c, g, vis);\\n      int y = dfs(r, c + 1, g, vis);\\n      int z = dfs(r - 1, c, g, vis);\\n      int w = dfs(r, c - 1, g, vis);\\n      return g[r][c] + x + y + z + w;\\n    }\\n    int findMaxFish(vector<vector<int>>& g) {\\n      int ans = 0, m = g.size(), n = g[0].size();\\n      vector<vector<bool>> vis(m, vector<bool>(n, false));\\n      for(int i = 0; i < m; i++){\\n        for(int j = 0; j < n; j++){\\n          if(g[i][j] > 0 and !vis[i][j]) \\n            ans = max(ans, dfs(i, j, g, vis));\\n        }\\n      }\\n      return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3466805,
                "title": "why-not-dp",
                "content": "Can\\'t we use dp in this problem (wasted 1 hour)?\\uD83E\\uDD14\\n\\nwhy we can not apply dp here anyone please.",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "Can\\'t we use dp in this problem (wasted 1 hour)?\\uD83E\\uDD14\\n\\nwhy we can not apply dp here anyone please.",
                "codeTag": "Unknown"
            },
            {
                "id": 3466773,
                "title": "dfs-brute-force-approach",
                "content": "\\n\\n# Complexity\\n- Time complexity:\\nO(mn4^(mn))\\n\\n- Space complexity:\\nO(mn)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n const int dx[4] = {1, 0, -1, 0};\\n const int dy[4] = {0, 1, 0, -1};\\n\\n int dfs(vector<vector<int>>& grid, int x, int y) {\\n    int ans1 = 0;\\n    if (x < 0 || x >= grid.size() || y < 0 || y >= grid[0].size() || grid[x][y] <= 0) {\\n        return ans1;\\n    }\\n    ans1 += grid[x][y]; \\n    grid[x][y] = -grid[x][y]; \\n    for (int i = 0; i < 4; i++) { \\n        int nx = x + dx[i], ny = y + dy[i];\\n        ans1 += dfs(grid, nx, ny);\\n    }\\n    return ans1;\\n}\\n int findMaxFish(vector<vector<int>>& grid) {\\n    int ans = 0;\\n    for (int x = 0; x < grid.size(); x++) {\\n        for (int y = 0; y < grid[0].size(); y++) {\\n            if (grid[x][y] > 0) {\\n                ans = max(ans, dfs(grid, x, y));\\n            }\\n        }\\n    }\\n    return ans;   \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n const int dx[4] = {1, 0, -1, 0};\\n const int dy[4] = {0, 1, 0, -1};\\n\\n int dfs(vector<vector<int>>& grid, int x, int y) {\\n    int ans1 = 0;\\n    if (x < 0 || x >= grid.size() || y < 0 || y >= grid[0].size() || grid[x][y] <= 0) {\\n        return ans1;\\n    }\\n    ans1 += grid[x][y]; \\n    grid[x][y] = -grid[x][y]; \\n    for (int i = 0; i < 4; i++) { \\n        int nx = x + dx[i], ny = y + dy[i];\\n        ans1 += dfs(grid, nx, ny);\\n    }\\n    return ans1;\\n}\\n int findMaxFish(vector<vector<int>>& grid) {\\n    int ans = 0;\\n    for (int x = 0; x < grid.size(); x++) {\\n        for (int y = 0; y < grid[0].size(); y++) {\\n            if (grid[x][y] > 0) {\\n                ans = max(ans, dfs(grid, x, y));\\n            }\\n        }\\n    }\\n    return ans;   \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3466739,
                "title": "easy-clean-best-c-code-dfs",
                "content": "# Code\\n## PLease Upvote if u liked my Solution\\uD83E\\uDD17\\n```\\nclass Solution {\\npublic:\\n    int maxi=0,ans=0;\\n    bool isValid(int i,int j,int m,int n){\\n        return ((i>=0 && i<m) && (j>=0 && j<n));\\n    }\\n    vector<int> dx={1,-1,0,0};\\n    vector<int> dy={0,0,1,-1};\\n    void DFS(vector<vector<int>>& grid,int i,int j,int m,int n){\\n        ans+=grid[i][j];\\n        grid[i][j]=0;\\n        for(int k=0;k<4;k++){\\n            int x=i+dx[k],y=j+dy[k];\\n            if(isValid(x,y,m,n) && grid[x][y])\\n                DFS(grid,x,y,m,n);\\n        }\\n    }\\n    int findMaxFish(vector<vector<int>>& grid) {\\n        int m=grid.size(),n=grid[0].size();\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                if(grid[i][j]){\\n                    DFS(grid,i,j,m,n);\\n                    maxi=max(maxi,ans);\\n                    ans=0;\\n                }\\n            }\\n        }\\n        return maxi;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxi=0,ans=0;\\n    bool isValid(int i,int j,int m,int n){\\n        return ((i>=0 && i<m) && (j>=0 && j<n));\\n    }\\n    vector<int> dx={1,-1,0,0};\\n    vector<int> dy={0,0,1,-1};\\n    void DFS(vector<vector<int>>& grid,int i,int j,int m,int n){\\n        ans+=grid[i][j];\\n        grid[i][j]=0;\\n        for(int k=0;k<4;k++){\\n            int x=i+dx[k],y=j+dy[k];\\n            if(isValid(x,y,m,n) && grid[x][y])\\n                DFS(grid,x,y,m,n);\\n        }\\n    }\\n    int findMaxFish(vector<vector<int>>& grid) {\\n        int m=grid.size(),n=grid[0].size();\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                if(grid[i][j]){\\n                    DFS(grid,i,j,m,n);\\n                    maxi=max(maxi,ans);\\n                    ans=0;\\n                }\\n            }\\n        }\\n        return maxi;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3466712,
                "title": "dart-recursive-dfs-solution",
                "content": "\\n# Code\\n```\\nclass Solution {\\n  int findMaxFish(List<List<int>> grid) {\\n    int result = 0;\\n    for (int i = 0; i < grid.length; i++) {\\n      for (int j = 0; j < grid[i].length; j++) {\\n        if (grid[i][j] != 0) {\\n          final tempResult = traverseRecurr(grid, i, j);\\n          result = tempResult > result ? tempResult : result;\\n        }\\n      }\\n    }\\n    return result;\\n  }\\n\\n   int traverseRecurr(List<List<int>> grid, i, j) {\\n    if (\\n       i < grid.length \\n    && i >= 0 \\n    && j < grid[i].length \\n    && j >= 0\\n    ) {\\n      if (grid[i][j] == 0) {\\n        return 0;\\n      }\\n      int result = grid[i][j];\\n      grid[i][j] = 0;\\n      result += traverseRecurr(grid, i - 1, j);\\n      result += traverseRecurr(grid, i + 1, j);\\n      result += traverseRecurr(grid, i, j + 1);\\n      result += traverseRecurr(grid, i, j - 1);\\n      return result;\\n    } else {\\n      return 0;\\n    }\\n  }\\n}\\n```",
                "solutionTags": [
                    "Dart",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n  int findMaxFish(List<List<int>> grid) {\\n    int result = 0;\\n    for (int i = 0; i < grid.length; i++) {\\n      for (int j = 0; j < grid[i].length; j++) {\\n        if (grid[i][j] != 0) {\\n          final tempResult = traverseRecurr(grid, i, j);\\n          result = tempResult > result ? tempResult : result;\\n        }\\n      }\\n    }\\n    return result;\\n  }\\n\\n   int traverseRecurr(List<List<int>> grid, i, j) {\\n    if (\\n       i < grid.length \\n    && i >= 0 \\n    && j < grid[i].length \\n    && j >= 0\\n    ) {\\n      if (grid[i][j] == 0) {\\n        return 0;\\n      }\\n      int result = grid[i][j];\\n      grid[i][j] = 0;\\n      result += traverseRecurr(grid, i - 1, j);\\n      result += traverseRecurr(grid, i + 1, j);\\n      result += traverseRecurr(grid, i, j + 1);\\n      result += traverseRecurr(grid, i, j - 1);\\n      return result;\\n    } else {\\n      return 0;\\n    }\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3466700,
                "title": "python-bfs",
                "content": "```python\\nclass Solution:\\n    def findMaxFish(self, grid: List[List[int]]) -> int:\\n\\n        def bfs(y, x):\\n            q = deque([(y, x)])\\n            v = set([(y, x)])\\n            m = 0\\n            \\n            while q:\\n                y, x = q.popleft()\\n                m += grid[y][x]\\n\\n                for y, x in ((y, x + 1), (y, x - 1), (y + 1, x), (y - 1, x)):\\n                    if not (0 <= y < h and 0 <= x < w):\\n                        continue\\n                    if grid[y][x] == 0:\\n                        continue\\n                    if (y, x) in v:\\n                        continue\\n                    v.add((y, x))\\n                    q.append((y, x))\\n\\n            return m\\n\\n        m, h, w = 0, len(grid), len(grid[0])\\n\\n        for y in range(h):\\n            for x in range(w):\\n                if grid[y][x] > 0:\\n                    m = max(m, bfs(y, x))\\n\\n        return m\\n```\\n",
                "solutionTags": [
                    "Breadth-First Search"
                ],
                "code": "```python\\nclass Solution:\\n    def findMaxFish(self, grid: List[List[int]]) -> int:\\n\\n        def bfs(y, x):\\n            q = deque([(y, x)])\\n            v = set([(y, x)])\\n            m = 0\\n            \\n            while q:\\n                y, x = q.popleft()\\n                m += grid[y][x]\\n\\n                for y, x in ((y, x + 1), (y, x - 1), (y + 1, x), (y - 1, x)):\\n                    if not (0 <= y < h and 0 <= x < w):\\n                        continue\\n                    if grid[y][x] == 0:\\n                        continue\\n                    if (y, x) in v:\\n                        continue\\n                    v.add((y, x))\\n                    q.append((y, x))\\n\\n            return m\\n\\n        m, h, w = 0, len(grid), len(grid[0])\\n\\n        for y in range(h):\\n            for x in range(w):\\n                if grid[y][x] > 0:\\n                    m = max(m, bfs(y, x))\\n\\n        return m\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3466687,
                "title": "maximize-sum-of-islands",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isvalid(int x,int y, vector<vector<int>>& grid)\\n    {\\n        int m=grid.size();\\n        int n=grid[0].size();\\n        if(x>=0 && x<m && y>=0 && y<n) return true;\\n        return false;\\n    }\\n    \\n    int bfs(int x, int y, vector<vector<int>>& grid, vector<vector<int>>& vis)\\n    {\\n        queue<pair<int,int>>q;\\n        q.push({x,y});\\n        int sum=grid[x][y];\\n        vis[x][y]=1;\\n        while(!q.empty())\\n        {\\n            pair<int,int>p=q.front();\\n            q.pop();\\n            \\n            int i=p.first;\\n            int j=p.second;\\n                if(isvalid(i+1,j,grid) && grid[i+1][j]!=0 && vis[i+1][j]==0)\\n                {\\n                    vis[i+1][j]=1;\\n                    sum+=grid[i+1][j];\\n                    q.push({i+1,j});\\n                }\\n                if(isvalid(i-1,j,grid) && grid[i-1][j]!=0 && vis[i-1][j]==0)\\n                {\\n                    vis[i-1][j]=1;\\n                    sum+=grid[i-1][j];\\n                    q.push({i-1,j});\\n                }\\n                if(isvalid(i,j+1,grid) && grid[i][j+1]!=0 && vis[i][j+1]==0)\\n                {\\n                    vis[i][j+1]=1;\\n                    sum+=grid[i][j+1];\\n                    q.push({i,j+1});\\n                }\\n                if(isvalid(i,j-1,grid) && grid[i][j-1]!=0 && vis[i][j-1]==0)\\n                {\\n                    vis[i][j-1]=1;\\n                    sum+=grid[i][j-1];\\n                    q.push({i,j-1});\\n                }\\n            //vis[i][j]=1;\\n        }\\n        return sum;\\n    }\\n    \\n    int findMaxFish(vector<vector<int>>& grid) {\\n        int m=grid.size();\\n        int n=grid[0].size();\\n        vector<vector<int>>vis(grid.size(),vector<int>(grid[0].size(),0));\\n        int ans=0;\\n        \\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                if(grid[i][j]!=0 && !vis[i][j])\\n                {\\n                    ans=max(ans,bfs(i,j,grid,vis));\\n                }\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isvalid(int x,int y, vector<vector<int>>& grid)\\n    {\\n        int m=grid.size();\\n        int n=grid[0].size();\\n        if(x>=0 && x<m && y>=0 && y<n) return true;\\n        return false;\\n    }\\n    \\n    int bfs(int x, int y, vector<vector<int>>& grid, vector<vector<int>>& vis)\\n    {\\n        queue<pair<int,int>>q;\\n        q.push({x,y});\\n        int sum=grid[x][y];\\n        vis[x][y]=1;\\n        while(!q.empty())\\n        {\\n            pair<int,int>p=q.front();\\n            q.pop();\\n            \\n            int i=p.first;\\n            int j=p.second;\\n                if(isvalid(i+1,j,grid) && grid[i+1][j]!=0 && vis[i+1][j]==0)\\n                {\\n                    vis[i+1][j]=1;\\n                    sum+=grid[i+1][j];\\n                    q.push({i+1,j});\\n                }\\n                if(isvalid(i-1,j,grid) && grid[i-1][j]!=0 && vis[i-1][j]==0)\\n                {\\n                    vis[i-1][j]=1;\\n                    sum+=grid[i-1][j];\\n                    q.push({i-1,j});\\n                }\\n                if(isvalid(i,j+1,grid) && grid[i][j+1]!=0 && vis[i][j+1]==0)\\n                {\\n                    vis[i][j+1]=1;\\n                    sum+=grid[i][j+1];\\n                    q.push({i,j+1});\\n                }\\n                if(isvalid(i,j-1,grid) && grid[i][j-1]!=0 && vis[i][j-1]==0)\\n                {\\n                    vis[i][j-1]=1;\\n                    sum+=grid[i][j-1];\\n                    q.push({i,j-1});\\n                }\\n            //vis[i][j]=1;\\n        }\\n        return sum;\\n    }\\n    \\n    int findMaxFish(vector<vector<int>>& grid) {\\n        int m=grid.size();\\n        int n=grid[0].size();\\n        vector<vector<int>>vis(grid.size(),vector<int>(grid[0].size(),0));\\n        int ans=0;\\n        \\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                if(grid[i][j]!=0 && !vis[i][j])\\n                {\\n                    ans=max(ans,bfs(i,j,grid,vis));\\n                }\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3466672,
                "title": "easiest-solution-ever",
                "content": "```\\nvoid solve(int i, int j, vector<vector<int>>& g, int &ans, vector<vector<bool>>& vis)\\n    {\\n        if(i<0 || j<0 || i>=g.size() || j>=g[0].size())\\n            return;\\n        \\n        if(vis[i][j] || (g[i][j]==0))\\n            return;\\n        \\n        vis[i][j] = true;\\n        ans += g[i][j];\\n        \\n        solve(i+1, j, g, ans, vis);\\n        solve(i, j+1, g, ans, vis);\\n        solve(i-1, j, g, ans, vis);\\n        solve(i, j-1, g, ans, vis);\\n    }\\n    int findMaxFish(vector<vector<int>>& g) {\\n        int r = g.size(), c = g[0].size();\\n        int mx = 0;\\n        vector<vector<bool>> vis(r, vector<bool>(c, false));\\n        for(int i=0;i<r;i++)\\n        {\\n            for(int j=0;j<c;j++)\\n            {\\n                if(g[i][j]==0)\\n                    continue;\\n                \\n                if(vis[i][j]==true)\\n                    continue;\\n                \\n                int ans = 0;\\n                solve(i, j, g, ans, vis);\\n                mx = max(mx, ans);\\n            }\\n        }\\n        return mx;\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\nvoid solve(int i, int j, vector<vector<int>>& g, int &ans, vector<vector<bool>>& vis)\\n    {\\n        if(i<0 || j<0 || i>=g.size() || j>=g[0].size())\\n            return;\\n        \\n        if(vis[i][j] || (g[i][j]==0))\\n            return;\\n        \\n        vis[i][j] = true;\\n        ans += g[i][j];\\n        \\n        solve(i+1, j, g, ans, vis);\\n        solve(i, j+1, g, ans, vis);\\n        solve(i-1, j, g, ans, vis);\\n        solve(i, j-1, g, ans, vis);\\n    }\\n    int findMaxFish(vector<vector<int>>& g) {\\n        int r = g.size(), c = g[0].size();\\n        int mx = 0;\\n        vector<vector<bool>> vis(r, vector<bool>(c, false));\\n        for(int i=0;i<r;i++)\\n        {\\n            for(int j=0;j<c;j++)\\n            {\\n                if(g[i][j]==0)\\n                    continue;\\n                \\n                if(vis[i][j]==true)\\n                    continue;\\n                \\n                int ans = 0;\\n                solve(i, j, g, ans, vis);\\n                mx = max(mx, ans);\\n            }\\n        }\\n        return mx;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3466647,
                "title": "c-dfs",
                "content": "```\\nclass Solution {\\npublic:\\n    int n,m;\\n    \\n    void dfs(vector<vector<int>> &grid,int i,int j,int &temp,vector<vector<int>>&vis){\\n        if(i<0||i>=n||j<0||j>=m) return;\\n        vis[i][j] = 1;\\n        temp += grid[i][j];\\n        int a[] = {1,0,-1,0};\\n        int b[] = {0,1,0,-1};\\n        for(int x=0;x<4;x++){\\n            if(i+a[x]>=0 && i+a[x]<n && j+b[x]>=0 && j+b[x]<m && !vis[i+a[x]][j+b[x]] && grid[i+a[x]][j+b[x]]){\\n                dfs(grid,i+a[x],j+b[x],temp,vis);\\n            }\\n        }\\n    }\\n    \\n    int findMaxFish(vector<vector<int>>& grid) {\\n        n = grid.size();\\n        m = grid[0].size();\\n        vector<vector<int>> vis(n,vector<int>(m,0));\\n        int ans=0;\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(!vis[i][j] && grid[i][j]){\\n                    int temp=0;\\n                    dfs(grid,i,j,temp,vis);\\n                    if(ans<temp) ans = temp;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int n,m;\\n    \\n    void dfs(vector<vector<int>> &grid,int i,int j,int &temp,vector<vector<int>>&vis){\\n        if(i<0||i>=n||j<0||j>=m) return;\\n        vis[i][j] = 1;\\n        temp += grid[i][j];\\n        int a[] = {1,0,-1,0};\\n        int b[] = {0,1,0,-1};\\n        for(int x=0;x<4;x++){\\n            if(i+a[x]>=0 && i+a[x]<n && j+b[x]>=0 && j+b[x]<m && !vis[i+a[x]][j+b[x]] && grid[i+a[x]][j+b[x]]){\\n                dfs(grid,i+a[x],j+b[x],temp,vis);\\n            }\\n        }\\n    }\\n    \\n    int findMaxFish(vector<vector<int>>& grid) {\\n        n = grid.size();\\n        m = grid[0].size();\\n        vector<vector<int>> vis(n,vector<int>(m,0));\\n        int ans=0;\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(!vis[i][j] && grid[i][j]){\\n                    int temp=0;\\n                    dfs(grid,i,j,temp,vis);\\n                    if(ans<temp) ans = temp;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4097424,
                "title": "easy-c-solution-dfs",
                "content": "\\n```\\n#define max(a, b) (a > b ? a : b)\\n\\nvoid helper (int i, int j, int m, int n, int *sum, int *ans, int** grid) {\\n    *ans = max (*ans, *sum);\\n\\n    if (i < 0 || j < 0 || i >= m || j >= n || !grid[i][j])\\n        return;\\n\\n    *sum += grid[i][j];\\n    grid[i][j] = 0;\\n\\n    if (i + 1 < m) helper (i + 1, j, m, n, sum, ans, grid);\\n    if (i - 1 >= 0) helper (i - 1, j, m, n, sum, ans, grid);\\n    if (j + 1 < n) helper (i, j + 1, m, n, sum, ans, grid);\\n    if (j - 1 >= 0) helper (i, j - 1, m, n, sum, ans, grid);\\n}\\n\\nint findMaxFish(int** grid, int gridSize, int* gridColSize){\\n    if (gridSize == 1 && *gridColSize == 1)\\n        return grid[0][0];\\n        \\n    int m = gridSize, n = *gridColSize, i, j, sum = 0, ans = 0;\\n\\n    for (i = 0; i < m; i++) {\\n        for (j = 0; j < n; j++){\\n            if (grid[i][j]) {\\n                sum = 0;\\n                helper(i, j, m, n, &sum, &ans, grid);\\n            }\\n        }\\n    }\\n\\n    return ans;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n#define max(a, b) (a > b ? a : b)\\n\\nvoid helper (int i, int j, int m, int n, int *sum, int *ans, int** grid) {\\n    *ans = max (*ans, *sum);\\n\\n    if (i < 0 || j < 0 || i >= m || j >= n || !grid[i][j])\\n        return;\\n\\n    *sum += grid[i][j];\\n    grid[i][j] = 0;\\n\\n    if (i + 1 < m) helper (i + 1, j, m, n, sum, ans, grid);\\n    if (i - 1 >= 0) helper (i - 1, j, m, n, sum, ans, grid);\\n    if (j + 1 < n) helper (i, j + 1, m, n, sum, ans, grid);\\n    if (j - 1 >= 0) helper (i, j - 1, m, n, sum, ans, grid);\\n}\\n\\nint findMaxFish(int** grid, int gridSize, int* gridColSize){\\n    if (gridSize == 1 && *gridColSize == 1)\\n        return grid[0][0];\\n        \\n    int m = gridSize, n = *gridColSize, i, j, sum = 0, ans = 0;\\n\\n    for (i = 0; i < m; i++) {\\n        for (j = 0; j < n; j++){\\n            if (grid[i][j]) {\\n                sum = 0;\\n                helper(i, j, m, n, &sum, &ans, grid);\\n            }\\n        }\\n    }\\n\\n    return ans;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4097360,
                "title": "simple-bfs-solution-easy-to-understand",
                "content": "# Intuition\\n\\nIn solving the question we just use the simple bfs algo.\\nRead the code you will understand it.\\n\\n# Approach\\nwe make queue which keep the a pair of elements first the value of the grid value and other values are the row and column respectively.\\nThen check that if  nrow and ncol are not going outside the grid and not visited and the grid is having a fish.\\nthen finding the max. from the possible value.\\nand at last return it maximum value.\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    int maxi=0;\\n    void bfs(int row,int col,vector<vector<int>>& grid,vector<vector<int>>& vis, int delrow[],int delcol[],int &sum){\\n        \\n        vis[row][col]=1;\\n        queue<pair<int,pair<int,int>>> q;\\n        q.push({grid[row][col],{row,col}});\\n        while(!q.empty()){\\n            int n=q.front().first;\\n            int x=q.front().second.first;\\n            int y=q.front().second.second;\\n            q.pop();\\n            sum+=n;\\n            for(int i=0; i<4; i++){\\n            int nrow=x+delrow[i];\\n            int ncol=y+delcol[i];\\n     if(nrow>=0 && nrow<grid.size() && ncol>=0 && ncol<grid[0].size() && grid[nrow][ncol]>0 && vis[nrow][ncol]==0){\\n                vis[nrow][ncol]=1;\\n                q.push({grid[nrow][ncol],{nrow,ncol}});\\n            }\\n            }\\n        }\\n    }\\n    int findMaxFish(vector<vector<int>>& grid) {\\n        \\n        int delrow[]={-1,0,1,0};\\n        int delcol[]={0,-1,0,1};\\n        vector<vector<int>> vis(grid.size(),vector<int>(grid[0].size(),0));\\n\\n        for(int i=0; i<grid.size(); i++){\\n            for(int j=0; j<grid[0].size(); j++){\\n\\n                if(grid[i][j]>0 && vis[i][j]==0){\\n                    int sum=0;\\n                    bfs(i,j,grid,vis,delrow,delcol,sum);\\n\\n                    maxi=max(maxi,sum);\\n                }\\n            }\\n        }\\n        return maxi;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    int maxi=0;\\n    void bfs(int row,int col,vector<vector<int>>& grid,vector<vector<int>>& vis, int delrow[],int delcol[],int &sum){\\n        \\n        vis[row][col]=1;\\n        queue<pair<int,pair<int,int>>> q;\\n        q.push({grid[row][col],{row,col}});\\n        while(!q.empty()){\\n            int n=q.front().first;\\n            int x=q.front().second.first;\\n            int y=q.front().second.second;\\n            q.pop();\\n            sum+=n;\\n            for(int i=0; i<4; i++){\\n            int nrow=x+delrow[i];\\n            int ncol=y+delcol[i];\\n     if(nrow>=0 && nrow<grid.size() && ncol>=0 && ncol<grid[0].size() && grid[nrow][ncol]>0 && vis[nrow][ncol]==0){\\n                vis[nrow][ncol]=1;\\n                q.push({grid[nrow][ncol],{nrow,ncol}});\\n            }\\n            }\\n        }\\n    }\\n    int findMaxFish(vector<vector<int>>& grid) {\\n        \\n        int delrow[]={-1,0,1,0};\\n        int delcol[]={0,-1,0,1};\\n        vector<vector<int>> vis(grid.size(),vector<int>(grid[0].size(),0));\\n\\n        for(int i=0; i<grid.size(); i++){\\n            for(int j=0; j<grid[0].size(); j++){\\n\\n                if(grid[i][j]>0 && vis[i][j]==0){\\n                    int sum=0;\\n                    bfs(i,j,grid,vis,delrow,delcol,sum);\\n\\n                    maxi=max(maxi,sum);\\n                }\\n            }\\n        }\\n        return maxi;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4090243,
                "title": "c-easy-solution-dfs",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int dfs(vector <vector<int>> &grid, vector<vector<int>> &visited, int row, int col)\\n    {\\n        visited[row][col] = 1;\\n        int prerow[] = {-1, 0, 1, 0};\\n        int precol[] = {0, -1, 0, 1};\\n        int res = grid[row][col];\\n        for(int i = 0; i < 4; i++)\\n        {\\n            int nrow = row + prerow[i];\\n            int ncol = col + precol[i];\\n            if(nrow >= 0 && nrow < grid.size() && ncol >= 0 && ncol < grid[0].size() && visited[nrow][ncol] == 0 && grid[nrow][ncol] > 0)\\n            {\\n                res += dfs(grid, visited, nrow, ncol);\\n            }\\n        }\\n        return res;\\n    }\\n    int findMaxFish(vector<vector<int>>& grid) {\\n        vector <vector <int>> visited(grid.size(), vector <int>(grid[0].size(), 0));\\n        int res = 0;\\n        for(int i = 0; i < grid.size(); i++)\\n        {\\n            for(int j = 0; j < grid[0].size(); j++)\\n            {\\n                if(!visited[i][j] && grid[i][j] > 0)\\n                {\\n                    res = max(res, dfs(grid, visited, i, j));\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dfs(vector <vector<int>> &grid, vector<vector<int>> &visited, int row, int col)\\n    {\\n        visited[row][col] = 1;\\n        int prerow[] = {-1, 0, 1, 0};\\n        int precol[] = {0, -1, 0, 1};\\n        int res = grid[row][col];\\n        for(int i = 0; i < 4; i++)\\n        {\\n            int nrow = row + prerow[i];\\n            int ncol = col + precol[i];\\n            if(nrow >= 0 && nrow < grid.size() && ncol >= 0 && ncol < grid[0].size() && visited[nrow][ncol] == 0 && grid[nrow][ncol] > 0)\\n            {\\n                res += dfs(grid, visited, nrow, ncol);\\n            }\\n        }\\n        return res;\\n    }\\n    int findMaxFish(vector<vector<int>>& grid) {\\n        vector <vector <int>> visited(grid.size(), vector <int>(grid[0].size(), 0));\\n        int res = 0;\\n        for(int i = 0; i < grid.size(); i++)\\n        {\\n            for(int j = 0; j < grid[0].size(); j++)\\n            {\\n                if(!visited[i][j] && grid[i][j] > 0)\\n                {\\n                    res = max(res, dfs(grid, visited, i, j));\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4090209,
                "title": "c-easy-solution-bfs",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int bfs(vector <vector<int>> &grid, vector<vector<int>> &visited, int row, int col)\\n    {\\n        visited[row][col] = 1;\\n        queue <pair<int, int>> q;\\n        q.push({row, col});\\n        int prerow[] = {-1, 0, 1, 0};\\n        int precol[] = {0, -1, 0, 1};\\n        int res = grid[row][col];\\n\\n        while(q.empty() == false)\\n        {\\n            row = q.front().first;\\n            col = q.front().second;\\n            q.pop();\\n            for(int i = 0; i < 4; i++)\\n            {\\n                int nrow = row + prerow[i];\\n                int ncol = col + precol[i];\\n\\n                if(nrow >= 0 && nrow < grid.size() && ncol >= 0 && ncol < grid[0].size() && grid[nrow][ncol] > 0 && visited[nrow][ncol] == 0){\\n                    q.push({nrow, ncol});\\n                    res += grid[nrow][ncol];\\n                    visited[nrow][ncol] = 1;\\n                }\\n            }\\n        }\\n         \\n        return res;\\n    }\\n    int findMaxFish(vector<vector<int>>& grid) {\\n        vector <vector<int>> visited(grid.size(), vector<int>(grid[0].size(), 0));\\n        int res = 0;\\n        for(int i = 0; i < grid.size(); i++)\\n        {\\n            for(int j = 0; j < grid[0].size(); j++)\\n            {\\n                if(!visited[i][j] && grid[i][j] > 0)\\n                {\\n                    res = max(res, bfs(grid, visited, i, j));\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int bfs(vector <vector<int>> &grid, vector<vector<int>> &visited, int row, int col)\\n    {\\n        visited[row][col] = 1;\\n        queue <pair<int, int>> q;\\n        q.push({row, col});\\n        int prerow[] = {-1, 0, 1, 0};\\n        int precol[] = {0, -1, 0, 1};\\n        int res = grid[row][col];\\n\\n        while(q.empty() == false)\\n        {\\n            row = q.front().first;\\n            col = q.front().second;\\n            q.pop();\\n            for(int i = 0; i < 4; i++)\\n            {\\n                int nrow = row + prerow[i];\\n                int ncol = col + precol[i];\\n\\n                if(nrow >= 0 && nrow < grid.size() && ncol >= 0 && ncol < grid[0].size() && grid[nrow][ncol] > 0 && visited[nrow][ncol] == 0){\\n                    q.push({nrow, ncol});\\n                    res += grid[nrow][ncol];\\n                    visited[nrow][ncol] = 1;\\n                }\\n            }\\n        }\\n         \\n        return res;\\n    }\\n    int findMaxFish(vector<vector<int>>& grid) {\\n        vector <vector<int>> visited(grid.size(), vector<int>(grid[0].size(), 0));\\n        int res = 0;\\n        for(int i = 0; i < grid.size(); i++)\\n        {\\n            for(int j = 0; j < grid[0].size(); j++)\\n            {\\n                if(!visited[i][j] && grid[i][j] > 0)\\n                {\\n                    res = max(res, bfs(grid, visited, i, j));\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4084103,
                "title": "python-easy-dfs-connected-components",
                "content": "\\n# Code\\n```\\nclass Solution:\\n    def helper(self, grid,i,j):\\n        s=grid[i][j]\\n        grid[i][j]=0\\n        x=[1,0,0,-1]\\n        y=[0,1,-1,0]\\n        for k in range(4):\\n            q=i+x[k]\\n            w=j+y[k]\\n            if q>=0 and w>=0 and q<=len(grid)-1 and  w<=len(grid[0])-1 and grid[q][w]!=0:\\n                s+=self.helper(grid,q,w)\\n        return s\\n\\n\\n    def findMaxFish(self, grid: List[List[int]]) -> int:\\n        ma=0\\n        for i in range(len(grid)):\\n            for j in range(len(grid[0])):\\n                if grid[i][j]>0:\\n                    ma=max(ma,self.helper(grid,i,j))\\n        return ma\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def helper(self, grid,i,j):\\n        s=grid[i][j]\\n        grid[i][j]=0\\n        x=[1,0,0,-1]\\n        y=[0,1,-1,0]\\n        for k in range(4):\\n            q=i+x[k]\\n            w=j+y[k]\\n            if q>=0 and w>=0 and q<=len(grid)-1 and  w<=len(grid[0])-1 and grid[q][w]!=0:\\n                s+=self.helper(grid,q,w)\\n        return s\\n\\n\\n    def findMaxFish(self, grid: List[List[int]]) -> int:\\n        ma=0\\n        for i in range(len(grid)):\\n            for j in range(len(grid[0])):\\n                if grid[i][j]>0:\\n                    ma=max(ma,self.helper(grid,i,j))\\n        return ma\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 4083953,
                "title": "java-standard-dfs-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nStandard DFS, Visited Array\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(n^2)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n^2)$$\\n<!-- Add your space complexity here, e.g. $$O(n^2)$$ --> \\n\\n\\n# Code\\n```\\nclass Solution {\\n    public int findMaxFish(int[][] grid) {\\n        int m = grid.length, n = grid[0].length;\\n        boolean[][] vis = new boolean[m][n];\\n        int currMax=0;\\n        int[] curr=new int[1];\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                if(!vis[i][j] && !(grid[i][j]==0)){\\n                    curr[0]=0;\\n                    dfs(i,j,grid,vis,curr);\\n                    currMax=Math.max(currMax,curr[0]);\\n                }\\n            }\\n        }\\n        return currMax;\\n    }\\n    private void dfs(int i, int j, int[][] grid,boolean[][] vis, int[] curr){\\n        int m = grid.length, n = grid[0].length;\\n        if(i<0 || j<0 || i>m-1 || j>n-1 || grid[i][j]==0 || vis[i][j]) return;\\n        vis[i][j]=true;\\n        curr[0]+=grid[i][j];\\n        dfs(i+1,j,grid,vis,curr);\\n        dfs(i-1,j,grid,vis,curr);\\n        dfs(i,j+1,grid,vis,curr);\\n        dfs(i,j-1,grid,vis,curr);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\n    public int findMaxFish(int[][] grid) {\\n        int m = grid.length, n = grid[0].length;\\n        boolean[][] vis = new boolean[m][n];\\n        int currMax=0;\\n        int[] curr=new int[1];\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                if(!vis[i][j] && !(grid[i][j]==0)){\\n                    curr[0]=0;\\n                    dfs(i,j,grid,vis,curr);\\n                    currMax=Math.max(currMax,curr[0]);\\n                }\\n            }\\n        }\\n        return currMax;\\n    }\\n    private void dfs(int i, int j, int[][] grid,boolean[][] vis, int[] curr){\\n        int m = grid.length, n = grid[0].length;\\n        if(i<0 || j<0 || i>m-1 || j>n-1 || grid[i][j]==0 || vis[i][j]) return;\\n        vis[i][j]=true;\\n        curr[0]+=grid[i][j];\\n        dfs(i+1,j,grid,vis,curr);\\n        dfs(i-1,j,grid,vis,curr);\\n        dfs(i,j+1,grid,vis,curr);\\n        dfs(i,j-1,grid,vis,curr);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4077158,
                "title": "simple-dfs-python-3",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def findMaxFish(self, grid: List[List[int]]) -> int:\\n\\n        ans=0\\n        m=len(grid)\\n        n=len(grid[0])\\n        vis=set()\\n        def dfs(r,c):\\n            if r<0 or c<0 or r==m or c==n or (r,c) in vis or grid[r][c]==0: return 0\\n            vis.add((r,c))\\n            return grid[r][c]+dfs(r-1,c)+dfs(r,c-1)+dfs(r+1,c)+dfs(r,c+1)\\n\\n        for i in range(m):\\n            for j in range(n):\\n                ans=max(ans,dfs(i,j))     \\n\\n        return ans        \\n            \\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findMaxFish(self, grid: List[List[int]]) -> int:\\n\\n        ans=0\\n        m=len(grid)\\n        n=len(grid[0])\\n        vis=set()\\n        def dfs(r,c):\\n            if r<0 or c<0 or r==m or c==n or (r,c) in vis or grid[r][c]==0: return 0\\n            vis.add((r,c))\\n            return grid[r][c]+dfs(r-1,c)+dfs(r,c-1)+dfs(r+1,c)+dfs(r,c+1)\\n\\n        for i in range(m):\\n            for j in range(n):\\n                ans=max(ans,dfs(i,j))     \\n\\n        return ans        \\n            \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 4072146,
                "title": "dfs",
                "content": "# Code\\n```\\nclass Solution(object):\\n    def findMaxFish(self, grid):\\n        \"\"\"\\n        :type grid: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n        if not grid:\\n            return 0\\n        \\n        m, n = len(grid), len(grid[0])\\n        \\n        # directions for moving up, down, left, right\\n        directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]\\n        \\n        # DFS function\\n        def dfs(i, j, visited):\\n            if i < 0 or i >= m or j < 0 or j >= n or grid[i][j] == 0 or (i, j) in visited:\\n                return 0\\n            visited.add((i, j))\\n            fish = grid[i][j]\\n            for dx, dy in directions:\\n                fish += dfs(i + dx, j + dy, visited)\\n            return fish\\n        \\n        max_fish = 0\\n        for i in range(m):\\n            for j in range(n):\\n                if grid[i][j] > 0:  # if it\\'s a water cell\\n                    max_fish = max(max_fish, dfs(i, j, set()))\\n        \\n        return max_fish\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def findMaxFish(self, grid):\\n        \"\"\"\\n        :type grid: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n        if not grid:\\n            return 0\\n        \\n        m, n = len(grid), len(grid[0])\\n        \\n        # directions for moving up, down, left, right\\n        directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]\\n        \\n        # DFS function\\n        def dfs(i, j, visited):\\n            if i < 0 or i >= m or j < 0 or j >= n or grid[i][j] == 0 or (i, j) in visited:\\n                return 0\\n            visited.add((i, j))\\n            fish = grid[i][j]\\n            for dx, dy in directions:\\n                fish += dfs(i + dx, j + dy, visited)\\n            return fish\\n        \\n        max_fish = 0\\n        for i in range(m):\\n            for j in range(n):\\n                if grid[i][j] > 0:  # if it\\'s a water cell\\n                    max_fish = max(max_fish, dfs(i, j, set()))\\n        \\n        return max_fish\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4062067,
                "title": "java-simple-dfs",
                "content": "class Solution {\\n\\n    int dirs1[]=new int[]{-1,0,1,0};\\n    int dirs2[]=new int[]{0,1,0,-1};\\n    \\n    int max = 0;\\n    int mn =0;\\n    int nn=0;\\n    \\n    public int dfs(int i,int j,int[][] grid,boolean vis[][]){\\n        if(i<0 || j<0 || i>= mn || j>= nn || vis[i][j] || grid[i][j]==0){\\n            return 0;\\n        }\\n        \\n        vis[i][j]=true;\\n        int neighborSum = 0;\\n        for(int k=0;k<4;k++){\\n            int r = i + dirs1[k];\\n            int c = j + dirs2[k];\\n            neighborSum += dfs(r,c,grid,vis);\\n        }\\n        return grid[i][j] + neighborSum;\\n        \\n    }\\n    public int findMaxFish(int[][] grid) {\\n        mn= grid.length;\\n        nn=grid[0].length;\\n        \\n        \\n        for(int i=0;i<mn;i++){\\n            for(int j=0;j<nn;j++){\\n                if(grid[i][j]!=0){\\n                    int size = dfs(i,j,grid,new boolean[mn][nn]);\\n                    max = Math.max(size,max);\\n                }\\n            }\\n        }\\n        return max;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n\\n    int dirs1[]=new int[]{-1,0,1,0}",
                "codeTag": "Java"
            },
            {
                "id": 4059104,
                "title": "dfs-implementation-both-in-c-and-java",
                "content": "# Code\\n```java []\\nclass Solution {\\n    void solve(int r, int c, int[][] grid, int[][] vis, int[] sum, int n, int m) {\\n        vis[r][c] = 1;\\n        int dx[] = {-1, 1, 0, 0}, dy[] = {0, 0, -1, 1};\\n        sum[0] += grid[r][c];\\n\\n        for(int i = 0; i < 4; i++) {\\n            int nx = r + dx[i], ny = c + dy[i];\\n            if(nx >= 0 && ny >= 0 && nx < n && ny < m && vis[nx][ny] == 0 && grid[nx][ny] > 0)\\n                solve(nx, ny, grid, vis, sum, n, m);\\n        }\\n    }\\n\\n    int findMaxFish(int[][] grid) {\\n        int n = grid.length, m = grid[0].length;\\n        int maxi = 0;\\n        int[][] vis = new int[n][m];\\n\\n        for(int i = 0; i < n; i++) {\\n            for(int j = 0; j < m; j++) {\\n                if(grid[i][j] > 0 && vis[i][j] == 0) {\\n                    int[] sum = new int[1];\\n                    solve(i, j, grid, vis, sum, n, m);\\n                    maxi = Math.max(maxi, sum[0]);  \\n                }             \\n            }\\n        }        \\n\\n        return maxi;\\n    }\\n}\\n```\\n```C++ []\\nclass Solution {\\npublic:\\n    void solve(int r, int c, vector<vector<int>> &grid, vector<vector<int>> &vis, int &sum, int n, int m) {\\n        vis[r][c] = 1;\\n        int dx[4] = {-1, 1, 0, 0}, dy[4] = {0, 0, -1, 1};\\n        sum += grid[r][c];\\n\\n        for(int i = 0; i < 4; i++) {\\n            int nx = r + dx[i], ny = c + dy[i];\\n            if(nx >= 0 and ny >= 0 and nx < n and ny < m and !vis[nx][ny] and grid[nx][ny] > 0)\\n                solve(nx, ny, grid, vis, sum, n, m);\\n        }\\n    }\\n\\n    int findMaxFish(vector<vector<int>> &grid) {\\n        int n = grid.size(), m = grid[0].size();\\n        int maxi = 0;\\n        vector<vector<int>> vis(n, vector<int> (m));\\n\\n        for(int i = 0; i < n; i++) {\\n            for(int j = 0; j < m; j++) {\\n                if(grid[i][j] > 0 and !vis[i][j]) {\\n                    int sum = 0;\\n                    solve(i, j, grid, vis, sum, n, m);\\n                    maxi = max(maxi, sum);  \\n                }             \\n            }\\n        }        \\n\\n        return maxi;\\n    }\\n};",
                "solutionTags": [
                    "Java"
                ],
                "code": "```java []\\nclass Solution {\\n    void solve(int r, int c, int[][] grid, int[][] vis, int[] sum, int n, int m) {\\n        vis[r][c] = 1;\\n        int dx[] = {-1, 1, 0, 0}, dy[] = {0, 0, -1, 1};\\n        sum[0] += grid[r][c];\\n\\n        for(int i = 0; i < 4; i++) {\\n            int nx = r + dx[i], ny = c + dy[i];\\n            if(nx >= 0 && ny >= 0 && nx < n && ny < m && vis[nx][ny] == 0 && grid[nx][ny] > 0)\\n                solve(nx, ny, grid, vis, sum, n, m);\\n        }\\n    }\\n\\n    int findMaxFish(int[][] grid) {\\n        int n = grid.length, m = grid[0].length;\\n        int maxi = 0;\\n        int[][] vis = new int[n][m];\\n\\n        for(int i = 0; i < n; i++) {\\n            for(int j = 0; j < m; j++) {\\n                if(grid[i][j] > 0 && vis[i][j] == 0) {\\n                    int[] sum = new int[1];\\n                    solve(i, j, grid, vis, sum, n, m);\\n                    maxi = Math.max(maxi, sum[0]);  \\n                }             \\n            }\\n        }        \\n\\n        return maxi;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4051736,
                "title": "template-dfs-solution",
                "content": "```\\nclass Solution:\\n    def findMaxFish(self, grid: List[List[int]]) -> int:\\n        \"\"\"\\n        simple dfs should suffice\\n        \"\"\"\\n        m, n = len(grid), len(grid[0])\\n        self.max_fish = 0\\n\\n        def is_valid(i, j):\\n            if 0 <= i < m and 0 <= j < n:\\n                return True\\n            return False\\n        \\n        def get_neis(i, j):\\n            return [(i+1,j), (i-1, j), (i,j-1), (i,j+1)]\\n        \\n        def dfs(i, j, dfs_visited):\\n            self.count+=grid[i][j]\\n            dfs_visited.add((i,j))\\n            self.max_fish = max(self.max_fish, self.count)\\n            for nei in get_neis(i, j):\\n                x, y = nei\\n                if is_valid(x, y) and grid[x][y] != 0 and (x, y) not in dfs_visited:\\n                    dfs(x, y, dfs_visited)\\n\\n        self.visited = set()\\n        for i in range(m):\\n            for j in range(n):\\n                if grid[i][j] != 0 and (i,j) not in self.visited:\\n                    dfs_visited = set()\\n                    self.count = 0\\n                    dfs(i, j, dfs_visited)\\n                    self.visited = self.visited.union(dfs_visited)\\n\\n        return self.max_fish\\n        \\n```",
                "solutionTags": [
                    "Python3",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def findMaxFish(self, grid: List[List[int]]) -> int:\\n        \"\"\"\\n        simple dfs should suffice\\n        \"\"\"\\n        m, n = len(grid), len(grid[0])\\n        self.max_fish = 0\\n\\n        def is_valid(i, j):\\n            if 0 <= i < m and 0 <= j < n:\\n                return True\\n            return False\\n        \\n        def get_neis(i, j):\\n            return [(i+1,j), (i-1, j), (i,j-1), (i,j+1)]\\n        \\n        def dfs(i, j, dfs_visited):\\n            self.count+=grid[i][j]\\n            dfs_visited.add((i,j))\\n            self.max_fish = max(self.max_fish, self.count)\\n            for nei in get_neis(i, j):\\n                x, y = nei\\n                if is_valid(x, y) and grid[x][y] != 0 and (x, y) not in dfs_visited:\\n                    dfs(x, y, dfs_visited)\\n\\n        self.visited = set()\\n        for i in range(m):\\n            for j in range(n):\\n                if grid[i][j] != 0 and (i,j) not in self.visited:\\n                    dfs_visited = set()\\n                    self.count = 0\\n                    dfs(i, j, dfs_visited)\\n                    self.visited = self.visited.union(dfs_visited)\\n\\n        return self.max_fish\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 4041516,
                "title": "c-bfs-graph",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool valid(int i,int j,int n,int m){\\n      return i>-1 && i<n && j>-1 && j<m;\\n    }\\n    void Bfs(int i,int j,int &count,vector<vector<int>>& grid){\\n      int n=grid.size();\\n      int m=grid[0].size();\\n      int row[4]={-1,1,0,0};\\n      int col[4]={0,0,-1,1};\\n      queue<pair<int,int>>q;\\n      q.push({i,j});\\n      while(!q.empty()){\\n        i=q.front().first;\\n        j=q.front().second;\\n        q.pop();\\n        for(int k=0;k<4;k++){\\n          if(valid(i+row[k],j+col[k],n,m) && grid[i+row[k]][j+col[k]]>0){\\n            q.push({i+row[k],j+col[k]});\\n            count+=grid[i+row[k]][j+col[k]];\\n            grid[i+row[k]][j+col[k]]=0;\\n          }\\n        }\\n      }\\n    }\\n    int findMaxFish(vector<vector<int>>& grid) {\\n      int ans=0;\\n      int n=grid.size();\\n      int m=grid[0].size();\\n      for(int i=0;i<n;i++){\\n        for(int j=0;j<m;j++){\\n          int count=0;\\n           if(grid[i][j]>0){\\n              count+=grid[i][j];\\n              grid[i][j]=0;\\n              Bfs(i,j,count,grid);\\n              ans=max(ans,count);\\n\\n           }\\n        }\\n      } \\n      return ans; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool valid(int i,int j,int n,int m){\\n      return i>-1 && i<n && j>-1 && j<m;\\n    }\\n    void Bfs(int i,int j,int &count,vector<vector<int>>& grid){\\n      int n=grid.size();\\n      int m=grid[0].size();\\n      int row[4]={-1,1,0,0};\\n      int col[4]={0,0,-1,1};\\n      queue<pair<int,int>>q;\\n      q.push({i,j});\\n      while(!q.empty()){\\n        i=q.front().first;\\n        j=q.front().second;\\n        q.pop();\\n        for(int k=0;k<4;k++){\\n          if(valid(i+row[k],j+col[k],n,m) && grid[i+row[k]][j+col[k]]>0){\\n            q.push({i+row[k],j+col[k]});\\n            count+=grid[i+row[k]][j+col[k]];\\n            grid[i+row[k]][j+col[k]]=0;\\n          }\\n        }\\n      }\\n    }\\n    int findMaxFish(vector<vector<int>>& grid) {\\n      int ans=0;\\n      int n=grid.size();\\n      int m=grid[0].size();\\n      for(int i=0;i<n;i++){\\n        for(int j=0;j<m;j++){\\n          int count=0;\\n           if(grid[i][j]>0){\\n              count+=grid[i][j];\\n              grid[i][j]=0;\\n              Bfs(i,j,count,grid);\\n              ans=max(ans,count);\\n\\n           }\\n        }\\n      } \\n      return ans; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4023609,
                "title": "c-easy-dfs-commented-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(m*n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(m*n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\nprivate:\\n    int dfs(int row,int col,vector<vector<int>>&vis,vector<vector<int>>&grid){\\n        // base case that makes the curr cell invalid, if visited, or if it \\n        //is land cell we return 0 (no fish caught);\\n        int m = grid.size();\\n        int n = grid[0].size();\\n\\n        if(row<0 || row>=m || col<0 || col>=n || vis[row][col] || \\n        grid[row][col]==0)\\n        return 0;\\n\\n        //otherwise we mark it as visited and proceed\\n        vis[row][col] = 1;\\n        \\n        int res = 0;\\n        for(int i=0;i<4;i++){\\n            int nrow = row + delrow[i];\\n            int ncol = col + delcol[i];\\n\\n            res +=dfs(nrow,ncol,vis,grid);\\n        } \\n\\n        return res + grid[row][col];\\n    }\\npublic:\\n    vector<int> delrow{-1,0,1,0};\\n    vector<int> delcol{0,1,0,-1};\\n\\n    int findMaxFish(vector<vector<int>>& grid) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n\\n        vector<vector<int>> vis(m,vector<int>(n,0)); //visited vector\\n\\n        //a fisherman can start at any water cell therefore we call dfs for \\n        //every water body and find sum of all cells and maximize it\\n        int maxi = -1e9;\\n\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                //if it is an unvisited water body\\n                if(grid[i][j]>0 && !vis[i][j]){\\n                    int val = dfs(i,j,vis,grid);\\n                    cout<<val<<endl;\\n                    maxi = max(maxi,val);\\n                }\\n            }\\n        }\\n        return max(maxi,0);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    int dfs(int row,int col,vector<vector<int>>&vis,vector<vector<int>>&grid){\\n        // base case that makes the curr cell invalid, if visited, or if it \\n        //is land cell we return 0 (no fish caught);\\n        int m = grid.size();\\n        int n = grid[0].size();\\n\\n        if(row<0 || row>=m || col<0 || col>=n || vis[row][col] || \\n        grid[row][col]==0)\\n        return 0;\\n\\n        //otherwise we mark it as visited and proceed\\n        vis[row][col] = 1;\\n        \\n        int res = 0;\\n        for(int i=0;i<4;i++){\\n            int nrow = row + delrow[i];\\n            int ncol = col + delcol[i];\\n\\n            res +=dfs(nrow,ncol,vis,grid);\\n        } \\n\\n        return res + grid[row][col];\\n    }\\npublic:\\n    vector<int> delrow{-1,0,1,0};\\n    vector<int> delcol{0,1,0,-1};\\n\\n    int findMaxFish(vector<vector<int>>& grid) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n\\n        vector<vector<int>> vis(m,vector<int>(n,0)); //visited vector\\n\\n        //a fisherman can start at any water cell therefore we call dfs for \\n        //every water body and find sum of all cells and maximize it\\n        int maxi = -1e9;\\n\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                //if it is an unvisited water body\\n                if(grid[i][j]>0 && !vis[i][j]){\\n                    int val = dfs(i,j,vis,grid);\\n                    cout<<val<<endl;\\n                    maxi = max(maxi,val);\\n                }\\n            }\\n        }\\n        return max(maxi,0);\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 4004210,
                "title": "c-solution-by-floodfill-algorithm",
                "content": "# Intuition\\nUse floodfill algorithm\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int m, n;\\n    int iCount = 0;\\n    void floodfill(vector<vector<int>>& grid, int i, int j)\\n    {\\n        iCount+=grid[i][j];\\n        grid[i][j] = 0;\\n        if(i-1>=0 && grid[i-1][j] >0) floodfill(grid, i-1, j);\\n        if(i+1 < m && grid[i+1][j] >0) floodfill(grid, i+1, j);\\n        if(j-1>=0 && grid[i][j-1] >0) floodfill(grid, i, j-1);\\n        if(j+1 < n && grid[i][j+1] >0) floodfill(grid, i, j+1);\\n    }\\n    int findMaxFish(vector<vector<int>>& grid) {\\n        m=grid.size();\\n        n=grid[0].size();\\n        int iMaxCount = 0;\\n        for(int i=0; i<m; i++)\\n        {\\n            for(int j=0; j<n; j++)\\n            {\\n                if(grid[i][j] != 0)\\n                {\\n                    iCount = 0;\\n                    floodfill(grid, i, j);\\n                    if(iCount > iMaxCount) iMaxCount = iCount;\\n\\n                }\\n            }\\n        }\\n\\n        return iMaxCount;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int m, n;\\n    int iCount = 0;\\n    void floodfill(vector<vector<int>>& grid, int i, int j)\\n    {\\n        iCount+=grid[i][j];\\n        grid[i][j] = 0;\\n        if(i-1>=0 && grid[i-1][j] >0) floodfill(grid, i-1, j);\\n        if(i+1 < m && grid[i+1][j] >0) floodfill(grid, i+1, j);\\n        if(j-1>=0 && grid[i][j-1] >0) floodfill(grid, i, j-1);\\n        if(j+1 < n && grid[i][j+1] >0) floodfill(grid, i, j+1);\\n    }\\n    int findMaxFish(vector<vector<int>>& grid) {\\n        m=grid.size();\\n        n=grid[0].size();\\n        int iMaxCount = 0;\\n        for(int i=0; i<m; i++)\\n        {\\n            for(int j=0; j<n; j++)\\n            {\\n                if(grid[i][j] != 0)\\n                {\\n                    iCount = 0;\\n                    floodfill(grid, i, j);\\n                    if(iCount > iMaxCount) iMaxCount = iCount;\\n\\n                }\\n            }\\n        }\\n\\n        return iMaxCount;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3999782,
                "title": "a-c-solution",
                "content": "\\n# Code\\n```\\nint traverse(int** grid, int row, int col, int rLimit, int cLimit) {\\n    if(row < 0 || row >= rLimit || col < 0 || col >= cLimit || !grid[row][col]) return 0;\\n    int ret = grid[row][col];\\n    grid[row][col] = 0;\\n\\n    ret += traverse(grid, row + 1, col, rLimit, cLimit);\\n    ret += traverse(grid, row - 1, col, rLimit, cLimit);\\n    ret += traverse(grid, row, col + 1, rLimit, cLimit);\\n    ret += traverse(grid, row, col - 1, rLimit, cLimit);\\n\\n    return ret;\\n}\\n\\nint findMaxFish(int** grid, int gridSize, int* gridColSize){\\n    int tmp = 0;\\n    int max = 0;\\n\\n    for(int i = 0; i < gridSize; i++) {\\n        for(int j = 0; j < *gridColSize; j++) {\\n            if(grid[i][j]) {\\n                tmp = traverse(grid, i, j, gridSize, *gridColSize);\\n                max = (tmp > max)? tmp : max;\\n            }\\n        }\\n    }\\n    return max;\\n}\\n\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint traverse(int** grid, int row, int col, int rLimit, int cLimit) {\\n    if(row < 0 || row >= rLimit || col < 0 || col >= cLimit || !grid[row][col]) return 0;\\n    int ret = grid[row][col];\\n    grid[row][col] = 0;\\n\\n    ret += traverse(grid, row + 1, col, rLimit, cLimit);\\n    ret += traverse(grid, row - 1, col, rLimit, cLimit);\\n    ret += traverse(grid, row, col + 1, rLimit, cLimit);\\n    ret += traverse(grid, row, col - 1, rLimit, cLimit);\\n\\n    return ret;\\n}\\n\\nint findMaxFish(int** grid, int gridSize, int* gridColSize){\\n    int tmp = 0;\\n    int max = 0;\\n\\n    for(int i = 0; i < gridSize; i++) {\\n        for(int j = 0; j < *gridColSize; j++) {\\n            if(grid[i][j]) {\\n                tmp = traverse(grid, i, j, gridSize, *gridColSize);\\n                max = (tmp > max)? tmp : max;\\n            }\\n        }\\n    }\\n    return max;\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3994399,
                "title": "3-liner-dfs-performance-beats-100",
                "content": "# Complexity\\n- Time complexity: $$O(m$$ x $$n)$$\\n- Space complexity: $$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\n\\n    int dfs(int[][] grid, int i, int j) {\\n        if(i < 0 || j < 0 || i == grid.length || j == grid[i].length || grid[i][j] < 1) return 0;\\n        grid[i][j] -= 20;\\n        return 20 + grid[i][j] + dfs(grid, i + 1, j) + dfs(grid, i - 1, j) + dfs(grid, i, j - 1) + dfs(grid, i, j + 1);\\n    }\\n\\n    public int findMaxFish(int[][] grid) {\\n        int m = grid.length, n = grid[0].length, max = 0;\\n        for(int i = 0; i < m; i++) for(int j = 0; j < n; j++) if(grid[i][j] > 0) max = Math.max(max, dfs(grid, i, j));\\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\n\\n    int dfs(int[][] grid, int i, int j) {\\n        if(i < 0 || j < 0 || i == grid.length || j == grid[i].length || grid[i][j] < 1) return 0;\\n        grid[i][j] -= 20;\\n        return 20 + grid[i][j] + dfs(grid, i + 1, j) + dfs(grid, i - 1, j) + dfs(grid, i, j - 1) + dfs(grid, i, j + 1);\\n    }\\n\\n    public int findMaxFish(int[][] grid) {\\n        int m = grid.length, n = grid[0].length, max = 0;\\n        for(int i = 0; i < m; i++) for(int j = 0; j < n; j++) if(grid[i][j] > 0) max = Math.max(max, dfs(grid, i, j));\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3984753,
                "title": "dart-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n  int findMaxFish(List<List<int>> grid) {\\n    var max = -1;\\n    var curMax = 0;\\n    final rows = grid.length;\\n    final cols = grid[0].length;\\n\\n    int dfs(int i, int j) {\\n        if (i < 0 || i >= rows || j < 0 || j >= cols || grid[i][j] == 0) {\\n            return 0;\\n        }\\n        final curValue = grid[i][j];\\n        grid[i][j] = 0;\\n        return curValue + dfs(i - 1, j) + dfs(i + 1, j) + dfs(i, j - 1) + dfs(i, j + 1);\\n    }\\n\\n    for (int i = 0; i < rows; i++) {\\n        for (int j = 0; j < cols; j++) {\\n            if (grid[i][j] != 0) {\\n                curMax = dfs(i, j);\\n            }\\n            if (curMax > max) {\\n                max = curMax;\\n            }\\n        }\\n    }\\n\\n    return max;\\n  }\\n}\\n```",
                "solutionTags": [
                    "Dart"
                ],
                "code": "```\\nclass Solution {\\n  int findMaxFish(List<List<int>> grid) {\\n    var max = -1;\\n    var curMax = 0;\\n    final rows = grid.length;\\n    final cols = grid[0].length;\\n\\n    int dfs(int i, int j) {\\n        if (i < 0 || i >= rows || j < 0 || j >= cols || grid[i][j] == 0) {\\n            return 0;\\n        }\\n        final curValue = grid[i][j];\\n        grid[i][j] = 0;\\n        return curValue + dfs(i - 1, j) + dfs(i + 1, j) + dfs(i, j - 1) + dfs(i, j + 1);\\n    }\\n\\n    for (int i = 0; i < rows; i++) {\\n        for (int j = 0; j < cols; j++) {\\n            if (grid[i][j] != 0) {\\n                curMax = dfs(i, j);\\n            }\\n            if (curMax > max) {\\n                max = curMax;\\n            }\\n        }\\n    }\\n\\n    return max;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3982530,
                "title": "java-100",
                "content": "# Approach\\nWhen we find a water cell, we recurse through it and its water cell neighbors. For each cell, we accumulate the value and then set it to 0 so that it will not be counted again. We store and return the max value.\\n\\n# Complexity\\n- Time complexity : O(m*n)\\n- Space complexity: O(1)\\n\\n# Code\\n```\\nclass Solution\\n{\\n    int [][] g;\\n\\n    public int findMaxFish(int[][] grid)\\n    {\\n        g = grid;\\n        int max = 0;\\n\\n        for(int i=0, l=grid.length, b=grid[0].length; i<l; i++)\\n            for(int j=0; j<b; j++)\\n                if(g[i][j]!=0)\\n                    max = Math.max(max,get(i,j));\\n\\n        return max;\\n    }\\n\\n    private int get(int x, int y)\\n    {\\n        if(x<0 || x>=g.length || y<0 || y>=g[0].length || g[x][y]==0)\\n            return 0;\\n        \\n        int c = g[x][y];\\n        g[x][y] = 0;\\n        \\n        return c + get(x+1,y) + get(x,y+1) + get(x-1,y) + get(x,y-1);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Graph",
                    "Recursion",
                    "Matrix"
                ],
                "code": "```\\nclass Solution\\n{\\n    int [][] g;\\n\\n    public int findMaxFish(int[][] grid)\\n    {\\n        g = grid;\\n        int max = 0;\\n\\n        for(int i=0, l=grid.length, b=grid[0].length; i<l; i++)\\n            for(int j=0; j<b; j++)\\n                if(g[i][j]!=0)\\n                    max = Math.max(max,get(i,j));\\n\\n        return max;\\n    }\\n\\n    private int get(int x, int y)\\n    {\\n        if(x<0 || x>=g.length || y<0 || y>=g[0].length || g[x][y]==0)\\n            return 0;\\n        \\n        int c = g[x][y];\\n        g[x][y] = 0;\\n        \\n        return c + get(x+1,y) + get(x,y+1) + get(x-1,y) + get(x,y-1);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3981408,
                "title": "very-easy-dfs-to-beat-92-python",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def findMaxFish(self, grid: List[List[int]]) -> int:\\n        res=0\\n        def dfs(i,j):\\n            if grid[i][j]==0:\\n                return 0\\n            temp=grid[i][j]\\n            grid[i][j]=0\\n\\n            next_move=[(i+1,j), (i-1,j), (i,j+1), (i,j-1)]\\n            for next_row, next_col in next_move:\\n                if next_row >=0 and next_row <len(grid) and next_col>=0 and next_col < len(grid[0])\\\\\\n                and grid[next_row][next_col] !=0:\\n                    temp+=dfs(next_row, next_col)\\n                else:\\n                    continue\\n            return temp\\n\\n\\n        for i in range(len(grid)):\\n            for j in range(len(grid[0])):\\n                if grid[i][j]!=0:\\n                    res=max(res, dfs(i,j))\\n        return res\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findMaxFish(self, grid: List[List[int]]) -> int:\\n        res=0\\n        def dfs(i,j):\\n            if grid[i][j]==0:\\n                return 0\\n            temp=grid[i][j]\\n            grid[i][j]=0\\n\\n            next_move=[(i+1,j), (i-1,j), (i,j+1), (i,j-1)]\\n            for next_row, next_col in next_move:\\n                if next_row >=0 and next_row <len(grid) and next_col>=0 and next_col < len(grid[0])\\\\\\n                and grid[next_row][next_col] !=0:\\n                    temp+=dfs(next_row, next_col)\\n                else:\\n                    continue\\n            return temp\\n\\n\\n        for i in range(len(grid)):\\n            for j in range(len(grid[0])):\\n                if grid[i][j]!=0:\\n                    res=max(res, dfs(i,j))\\n        return res\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3976375,
                "title": "using-dfs",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(N*M)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N*M)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def findMaxFish(self, grid: List[List[int]]) -> int:\\n        def dfs(i, j):\\n\\n            if i<0 or j<0 or i>m-1 or j>n-1 or grid[i][j] == 0:\\n                return 0\\n            val = grid[i][j]\\n            grid[i][j] = 0\\n            return val + dfs(i-1,j) + dfs(i,j-1) + dfs(i,j+1) + dfs(i+1,j)\\n\\n        m, n = len(grid),len(grid[0])\\n        s = 0\\n        for i in range(m):\\n            for j in range(n):\\n                if grid[i][j] != 0:\\n                    s = max(s, dfs(i,j))\\n                    print(\"S is \",s)\\n        return s\\n            \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findMaxFish(self, grid: List[List[int]]) -> int:\\n        def dfs(i, j):\\n\\n            if i<0 or j<0 or i>m-1 or j>n-1 or grid[i][j] == 0:\\n                return 0\\n            val = grid[i][j]\\n            grid[i][j] = 0\\n            return val + dfs(i-1,j) + dfs(i,j-1) + dfs(i,j+1) + dfs(i+1,j)\\n\\n        m, n = len(grid),len(grid[0])\\n        s = 0\\n        for i in range(m):\\n            for j in range(n):\\n                if grid[i][j] != 0:\\n                    s = max(s, dfs(i,j))\\n                    print(\"S is \",s)\\n        return s\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3971940,
                "title": "similar-to-max-area-of-island-bfs-approach",
                "content": "\\n\\n# Code\\n```\\nclass Solution \\n{\\n    private:\\nvoid bfs(int row,int col, vector<vector<int>>&vis,vector<vector<int>>& grid,int &a)\\n{\\n    vis[row][col]=1;\\n    queue<pair<int,int>>q;\\n    q.push({row,col});\\n    while(!q.empty())\\n    {\\n        int r=q.front().first;\\n        int c=q.front().second;\\n        q.pop();\\n        for(int delrow=-1;delrow<=1;delrow++)\\n        {\\n            for(int delcol=-1;delcol<=1;delcol++)\\n            {\\n                if(abs(delrow)!=abs(delcol))\\n                {\\n                    int nrow=r+delrow;\\n                    int ncol=c+delcol;\\n                    if(nrow>=0&&nrow<grid.size()&&ncol>=0&&ncol<grid[0].size()&&!vis[nrow][ncol]&&grid[nrow][ncol]>0)\\n                    {\\n                        a+=grid[nrow][ncol];\\n                        vis[nrow][ncol]=1;\\n                        q.push({nrow,ncol});\\n                    }\\n                }\\n            }\\n        }\\n    }\\n}\\npublic:\\n    int findMaxFish(vector<vector<int>>& grid) {\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        vector<vector<int>>vis(n,vector<int>(m,0));\\n        int count=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<m;j++)\\n            {\\n                if(!vis[i][j]&&grid[i][j]!=0)\\n                {\\n                    int a=grid[i][j];\\n                    bfs(i,j,vis,grid,a);\\n                    count=max(a,count);\\n                }\\n            }\\n        }\\n        return count;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution \\n{\\n    private:\\nvoid bfs(int row,int col, vector<vector<int>>&vis,vector<vector<int>>& grid,int &a)\\n{\\n    vis[row][col]=1;\\n    queue<pair<int,int>>q;\\n    q.push({row,col});\\n    while(!q.empty())\\n    {\\n        int r=q.front().first;\\n        int c=q.front().second;\\n        q.pop();\\n        for(int delrow=-1;delrow<=1;delrow++)\\n        {\\n            for(int delcol=-1;delcol<=1;delcol++)\\n            {\\n                if(abs(delrow)!=abs(delcol))\\n                {\\n                    int nrow=r+delrow;\\n                    int ncol=c+delcol;\\n                    if(nrow>=0&&nrow<grid.size()&&ncol>=0&&ncol<grid[0].size()&&!vis[nrow][ncol]&&grid[nrow][ncol]>0)\\n                    {\\n                        a+=grid[nrow][ncol];\\n                        vis[nrow][ncol]=1;\\n                        q.push({nrow,ncol});\\n                    }\\n                }\\n            }\\n        }\\n    }\\n}\\npublic:\\n    int findMaxFish(vector<vector<int>>& grid) {\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        vector<vector<int>>vis(n,vector<int>(m,0));\\n        int count=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<m;j++)\\n            {\\n                if(!vis[i][j]&&grid[i][j]!=0)\\n                {\\n                    int a=grid[i][j];\\n                    bfs(i,j,vis,grid,a);\\n                    count=max(a,count);\\n                }\\n            }\\n        }\\n        return count;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3970807,
                "title": "cpp-easy-implementation-fast-and-clean-code",
                "content": "\\n# Complexity\\n- Time complexity:``O( M * N )``\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:``O(1)``\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int bfs(vector<vector<int>>& grid,int i,int j,int m,int n){\\n        int ans=0;\\n        queue<pair<int,int>>q;\\n        q.push({i,j});\\n        ans+=grid[i][j];\\n        grid[i][j]=0;\\n        vector<int> r={1,0,-1,0};\\n        vector<int> c={0,1,0,-1};\\n        while(!q.empty()){\\n            int x=q.front().first;\\n            int y=q.front().second;\\n            q.pop();\\n            for(int k=0;k<4;k++){\\n                int row=x+r[k];\\n                int col=y+c[k];\\n                if(row>=0 && row<m && col>=0 && col<n && grid[row][col]!=0){\\n                    ans+=grid[row][col];\\n                    grid[row][col]=0;\\n                    q.push({row,col});\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n    int findMaxFish(vector<vector<int>>& grid) {\\n        int ans=0;\\n        int m=grid.size();\\n        int n= grid[0].size();\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                if(grid[i][j]!=0){\\n                    int temp=bfs(grid,i,j,m,n);\\n                    ans=max(ans,temp);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Breadth-First Search",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int bfs(vector<vector<int>>& grid,int i,int j,int m,int n){\\n        int ans=0;\\n        queue<pair<int,int>>q;\\n        q.push({i,j});\\n        ans+=grid[i][j];\\n        grid[i][j]=0;\\n        vector<int> r={1,0,-1,0};\\n        vector<int> c={0,1,0,-1};\\n        while(!q.empty()){\\n            int x=q.front().first;\\n            int y=q.front().second;\\n            q.pop();\\n            for(int k=0;k<4;k++){\\n                int row=x+r[k];\\n                int col=y+c[k];\\n                if(row>=0 && row<m && col>=0 && col<n && grid[row][col]!=0){\\n                    ans+=grid[row][col];\\n                    grid[row][col]=0;\\n                    q.push({row,col});\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n    int findMaxFish(vector<vector<int>>& grid) {\\n        int ans=0;\\n        int m=grid.size();\\n        int n= grid[0].size();\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                if(grid[i][j]!=0){\\n                    int temp=bfs(grid,i,j,m,n);\\n                    ans=max(ans,temp);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3969630,
                "title": "jave-dfs-easy-and-straightforward-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nClassic DFS solution\\n\\nMain function:\\n- traverse through all grids\\n- update ```maxFish``` when some grids returns a larger number from dfs search\\n\\nIn DFS function:\\n- check conditions: visited? upper lower bounds? water or land? etc\\n- evaluate grid if condition is fulfilled, then mark as visited = true;\\n- update the returned value (fish in this case)\\n- evaluate adjacent grids, check if there\\'s a possible move. Do this recursively to check all possible moves.\\n- move to adj grids and update returning value (fish)\\n- If back tracking is necessary, mark as false;\\n\\n# Complexity\\n- Time complexity: $$O(n^4)$$\\n- Because we have $$N^2$$ for main function (iterates m*n times), and N (iterates m*n times) for helper dfs function\\n- So, the time complexity is $$O(m^2*n^2)$$. If m and n are roughly equal (i.e., the grid is close to square), then the time complexity could be described as $$O(N^4)$$ where N is the side length of the grid.  \\n\\n- Space complexity: $$O(m*n)$$\\n- The grid itself occupies $$O(m\\xD7n)$$ space, but we don\\'t count this since it\\'s given as input. The visited array occupies $$O(m\\xD7n)$$ space. The recursive DFS can potentially go as deep as m\\xD7n in the worst case, so the call stack could occupy $$O(m\\xD7n)$$ space. \\n- Combining the above, the total space complexity is $$O(m\\xD7n)$$.\\n\\n# Code\\n```\\nclass Solution {\\n    \\n    int [][] directions = {{0,1},{1,0},{0,-1},{-1,0}};\\n\\n    public int findMaxFish(int[][] grid) { \\n        // DFS to find spot with maxfish && maxFish > 0\\n        int m = grid.length, n = grid[0].length; // m >= 1; n <= 10;\\n        int maxFish = 0;\\n        int fish = 0;\\n        // use two for-loops to traverse through all grids\\n        for(int i = 0; i < m; i++ ){\\n            for(int j = 0; j < n; j++){\\n                fish = dfs(i,j,grid,new boolean [m][n]); // don\\'t use visited[i][j] here because \\n                maxFish = Math.max(fish,maxFish); //update if newly collected fish is more\\n            }\\n        }\\n        return maxFish;\\n    }\\n    private int dfs(int r, int c, int[][] grid, boolean[][] visited){\\n        int m = grid.length, n = grid[0].length;\\n        //check all conditions: visited ? water? reach bound m? n?\\n        if (r < 0 || r >= m || c < 0 || c >= n || visited[r][c] || grid[r][c] <= 0) {\\n            return 0;\\n        }\\n        // update visited\\n        visited[r][c] = true;\\n\\n        //if passed, update new fish num\\n        int fish = grid[r][c];\\n        grid[r][c] = 0; // set land mark to 0 to avoid double counting\\n\\n        // keep updating fish if adj routes are possible\\n        for(int[] dir : directions){\\n            int adjrow = r + dir[0];\\n            int adjcol = c + dir[1];\\n            fish += dfs(adjrow,adjcol,grid,visited);\\n        }\\n        \\n        //update if backtrack\\n        visited[r][c] = false;\\n\\n        return fish;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search"
                ],
                "code": "```maxFish```\n```\\nclass Solution {\\n    \\n    int [][] directions = {{0,1},{1,0},{0,-1},{-1,0}};\\n\\n    public int findMaxFish(int[][] grid) { \\n        // DFS to find spot with maxfish && maxFish > 0\\n        int m = grid.length, n = grid[0].length; // m >= 1; n <= 10;\\n        int maxFish = 0;\\n        int fish = 0;\\n        // use two for-loops to traverse through all grids\\n        for(int i = 0; i < m; i++ ){\\n            for(int j = 0; j < n; j++){\\n                fish = dfs(i,j,grid,new boolean [m][n]); // don\\'t use visited[i][j] here because \\n                maxFish = Math.max(fish,maxFish); //update if newly collected fish is more\\n            }\\n        }\\n        return maxFish;\\n    }\\n    private int dfs(int r, int c, int[][] grid, boolean[][] visited){\\n        int m = grid.length, n = grid[0].length;\\n        //check all conditions: visited ? water? reach bound m? n?\\n        if (r < 0 || r >= m || c < 0 || c >= n || visited[r][c] || grid[r][c] <= 0) {\\n            return 0;\\n        }\\n        // update visited\\n        visited[r][c] = true;\\n\\n        //if passed, update new fish num\\n        int fish = grid[r][c];\\n        grid[r][c] = 0; // set land mark to 0 to avoid double counting\\n\\n        // keep updating fish if adj routes are possible\\n        for(int[] dir : directions){\\n            int adjrow = r + dir[0];\\n            int adjcol = c + dir[1];\\n            fish += dfs(adjrow,adjcol,grid,visited);\\n        }\\n        \\n        //update if backtrack\\n        visited[r][c] = false;\\n\\n        return fish;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3963099,
                "title": "golang-dfs-solution",
                "content": "# Code\\n```go\\nfunc findMaxFish(grid [][]int) int {\\n\\tmf := 0\\n\\tfor i := range grid {\\n\\t\\tfor j := range grid[i] {\\n\\t\\t\\tfish := dfs(grid, i, j)\\n\\t\\t\\tif fish > mf {\\n\\t\\t\\t\\tmf = fish\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn mf\\n}\\n\\nfunc dfs(grid [][]int, i, j int) int {\\n\\tif i < 0 || i >= len(grid) || j < 0 || j >= len(grid[0]) {\\n\\t\\treturn 0\\n\\t}\\n\\tif grid[i][j] == 0 {\\n\\t\\treturn 0\\n\\t}\\n\\tfish := grid[i][j]\\n\\tgrid[i][j] = 0\\n\\tfish += dfs(grid, i-1, j)\\n\\tfish += dfs(grid, i+1, j)\\n\\tfish += dfs(grid, i, j-1)\\n\\tfish += dfs(grid, i, j+1)\\n\\treturn fish\\n}\\n\\n```",
                "solutionTags": [
                    "Go",
                    "Depth-First Search"
                ],
                "code": "```go\\nfunc findMaxFish(grid [][]int) int {\\n\\tmf := 0\\n\\tfor i := range grid {\\n\\t\\tfor j := range grid[i] {\\n\\t\\t\\tfish := dfs(grid, i, j)\\n\\t\\t\\tif fish > mf {\\n\\t\\t\\t\\tmf = fish\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn mf\\n}\\n\\nfunc dfs(grid [][]int, i, j int) int {\\n\\tif i < 0 || i >= len(grid) || j < 0 || j >= len(grid[0]) {\\n\\t\\treturn 0\\n\\t}\\n\\tif grid[i][j] == 0 {\\n\\t\\treturn 0\\n\\t}\\n\\tfish := grid[i][j]\\n\\tgrid[i][j] = 0\\n\\tfish += dfs(grid, i-1, j)\\n\\tfish += dfs(grid, i+1, j)\\n\\tfish += dfs(grid, i, j-1)\\n\\tfish += dfs(grid, i, j+1)\\n\\treturn fish\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3957420,
                "title": "c-u-c-t-nh-s-l-ng-c-c-th-c-u-nhi-u-nh-t-theo-4-h-ng",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n\\t\\tpublic static int[] dx = { 1, -1, 0, 0 };\\n\\t\\tpublic static int[] dy = { 0, 0, 1, -1 }; \\n\\t\\tpublic static int MAXFISH = 0;\\n\\n    public int findMaxFish(int[][] matrix) {\\n        \\tint rows = matrix.length;\\n\\t\\t\\t\\t\\tint col = matrix[0].length;\\n\\t\\t\\t\\t\\tint maxFish = 0;\\n\\t\\t\\t\\t\\tboolean[][] visited = new boolean[rows][col];\\n\\n\\t\\t\\t\\t\\tfor (int i = 0; i < rows; i++) {\\n\\t\\t\\t\\t\\t\\tfor (int j = 0; j < col; j++) {\\n\\t\\t\\t\\t\\t\\t\\tif (matrix[i][j] > 0) {\\n\\t\\t\\t\\t\\t\\t\\t\\tint fishByCell = bfs(i, j, matrix, matrix[i][j], visited);\\n\\t\\t\\t\\t\\t\\t\\t\\tmaxFish = Math.max(maxFish, fishByCell);\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\treturn maxFish;\\n    }\\n\\n public static int bfs(int x, int y, int[][] matrix, int fish, boolean[][] visited) {\\n\\t\\tint rows = matrix.length;\\n\\t\\tint col = matrix[0].length;\\n\\t\\tint maxFish = fish;\\n\\t\\tvisited[x][y] = true;\\n\\t\\tQueue<Cellss> queue = new LinkedList<Cellss>();\\n\\t\\tqueue.add(new Cellss(x, y));\\n\\t\\twhile (!queue.isEmpty()) {\\n\\t\\t\\tCellss curenCell = queue.poll();\\n\\t\\t\\tint cureentX = curenCell.x;\\n\\t\\t\\tint cureentY = curenCell.y;\\n\\t\\t\\tfor (int i = 0; i < 4; i++) { \\n\\t\\t\\t\\tint nextX = cureentX + dx[i];\\n\\t\\t\\t\\tint nextY = cureentY + dy[i]; \\n\\t\\t\\t\\tif (nextX < rows && nextX >= 0 && nextY < col && nextY >= 0\\n\\t\\t\\t\\t\\t\\t&& matrix[nextX][nextY] > 0 && !visited[nextX][nextY]) {\\n\\t\\t\\t\\t\\tmaxFish = maxFish + matrix[nextX][nextY];\\n\\n\\t\\t\\t\\t\\tqueue.add(new Cellss(nextX, nextY));\\n\\t\\t\\t\\t\\tvisited[nextX][nextY] = true;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn maxFish;\\n\\t}\\n}\\n\\n\\nclass Cellss {\\n\\tint x;\\n\\tint y;\\n\\n\\tpublic Cellss(int x, int y) {\\n\\t\\tthis.x = x;\\n\\t\\tthis.y = y;\\n\\t}\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n\\t\\tpublic static int[] dx = { 1, -1, 0, 0 };\\n\\t\\tpublic static int[] dy = { 0, 0, 1, -1 }; \\n\\t\\tpublic static int MAXFISH = 0;\\n\\n    public int findMaxFish(int[][] matrix) {\\n        \\tint rows = matrix.length;\\n\\t\\t\\t\\t\\tint col = matrix[0].length;\\n\\t\\t\\t\\t\\tint maxFish = 0;\\n\\t\\t\\t\\t\\tboolean[][] visited = new boolean[rows][col];\\n\\n\\t\\t\\t\\t\\tfor (int i = 0; i < rows; i++) {\\n\\t\\t\\t\\t\\t\\tfor (int j = 0; j < col; j++) {\\n\\t\\t\\t\\t\\t\\t\\tif (matrix[i][j] > 0) {\\n\\t\\t\\t\\t\\t\\t\\t\\tint fishByCell = bfs(i, j, matrix, matrix[i][j], visited);\\n\\t\\t\\t\\t\\t\\t\\t\\tmaxFish = Math.max(maxFish, fishByCell);\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\treturn maxFish;\\n    }\\n\\n public static int bfs(int x, int y, int[][] matrix, int fish, boolean[][] visited) {\\n\\t\\tint rows = matrix.length;\\n\\t\\tint col = matrix[0].length;\\n\\t\\tint maxFish = fish;\\n\\t\\tvisited[x][y] = true;\\n\\t\\tQueue<Cellss> queue = new LinkedList<Cellss>();\\n\\t\\tqueue.add(new Cellss(x, y));\\n\\t\\twhile (!queue.isEmpty()) {\\n\\t\\t\\tCellss curenCell = queue.poll();\\n\\t\\t\\tint cureentX = curenCell.x;\\n\\t\\t\\tint cureentY = curenCell.y;\\n\\t\\t\\tfor (int i = 0; i < 4; i++) { \\n\\t\\t\\t\\tint nextX = cureentX + dx[i];\\n\\t\\t\\t\\tint nextY = cureentY + dy[i]; \\n\\t\\t\\t\\tif (nextX < rows && nextX >= 0 && nextY < col && nextY >= 0\\n\\t\\t\\t\\t\\t\\t&& matrix[nextX][nextY] > 0 && !visited[nextX][nextY]) {\\n\\t\\t\\t\\t\\tmaxFish = maxFish + matrix[nextX][nextY];\\n\\n\\t\\t\\t\\t\\tqueue.add(new Cellss(nextX, nextY));\\n\\t\\t\\t\\t\\tvisited[nextX][nextY] = true;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn maxFish;\\n\\t}\\n}\\n\\n\\nclass Cellss {\\n\\tint x;\\n\\tint y;\\n\\n\\tpublic Cellss(int x, int y) {\\n\\t\\tthis.x = x;\\n\\t\\tthis.y = y;\\n\\t}\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3929438,
                "title": "c-simple-dfs-solution",
                "content": "<!-- # Intuition -->\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n<!-- # Approach -->\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:$$O(m*n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(m*n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> dir = {{-1,0},{1,0},{0,-1},{0,1}};\\n    int m;\\n    int n;\\n    void dfs(vector<vector<int>>&grid, int x, int y, int&curr)\\n    {\\n        curr+=grid[x][y];\\n        grid[x][y]=0;\\n        for(int k=0;k<4;k++)\\n        {\\n            int nx = x+dir[k][0];\\n            int ny = y+dir[k][1];\\n            if(nx>=0 && nx<m && ny>=0 && ny<n && grid[nx][ny]>0)\\n            {\\n                dfs(grid, nx, ny, curr);\\n            }\\n        }\\n        return ;\\n    }\\n    int findMaxFish(vector<vector<int>>& grid)\\n    {\\n        m = grid.size();\\n        n = grid[0].size();\\n        int ans = 0;\\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                if(grid[i][j]>0)\\n                {\\n                    int curr = 0;\\n                    dfs(grid, i, j, curr);\\n                    ans=max(ans, curr);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Depth-First Search",
                    "Graph",
                    "Recursion",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> dir = {{-1,0},{1,0},{0,-1},{0,1}};\\n    int m;\\n    int n;\\n    void dfs(vector<vector<int>>&grid, int x, int y, int&curr)\\n    {\\n        curr+=grid[x][y];\\n        grid[x][y]=0;\\n        for(int k=0;k<4;k++)\\n        {\\n            int nx = x+dir[k][0];\\n            int ny = y+dir[k][1];\\n            if(nx>=0 && nx<m && ny>=0 && ny<n && grid[nx][ny]>0)\\n            {\\n                dfs(grid, nx, ny, curr);\\n            }\\n        }\\n        return ;\\n    }\\n    int findMaxFish(vector<vector<int>>& grid)\\n    {\\n        m = grid.size();\\n        n = grid[0].size();\\n        int ans = 0;\\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                if(grid[i][j]>0)\\n                {\\n                    int curr = 0;\\n                    dfs(grid, i, j, curr);\\n                    ans=max(ans, curr);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3924427,
                "title": "simplest-depth-first-search-python-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n->Check each cell\\n->if the cell has non-zero value\\n->run iterative function to collect all connected non-zero value\\n->as each cell changes to zero\\n->compare with other cell values to save the maximum\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N^2)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def getfish(self,grid,i,j):\\n        if grid[i][j]==0: return 0\\n        fish=grid[i][j]\\n        grid[i][j]=0\\n\\n        if i+1<len(grid):fish+=self.getfish(grid,i+1,j)\\n        if i-1>=0:fish+=self.getfish(grid,i-1,j)\\n        if j+1<len(grid[0]):fish+=self.getfish(grid,i,j+1)\\n        if j-1>=0:fish+=self.getfish(grid,i,j-1)\\n  \\n        return fish\\n\\n\\n\\n    def findMaxFish(self, grid: List[List[int]]) -> int:\\n        out = 0\\n        n = len(grid)\\n        m = len(grid[0])\\n        for i in range(n):\\n            for j in range(m):\\n                if grid[i][j]>0:\\n                    out = max(out,self.getfish(grid,i,j))\\n        return out\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def getfish(self,grid,i,j):\\n        if grid[i][j]==0: return 0\\n        fish=grid[i][j]\\n        grid[i][j]=0\\n\\n        if i+1<len(grid):fish+=self.getfish(grid,i+1,j)\\n        if i-1>=0:fish+=self.getfish(grid,i-1,j)\\n        if j+1<len(grid[0]):fish+=self.getfish(grid,i,j+1)\\n        if j-1>=0:fish+=self.getfish(grid,i,j-1)\\n  \\n        return fish\\n\\n\\n\\n    def findMaxFish(self, grid: List[List[int]]) -> int:\\n        out = 0\\n        n = len(grid)\\n        m = len(grid[0])\\n        for i in range(n):\\n            for j in range(m):\\n                if grid[i][j]>0:\\n                    out = max(out,self.getfish(grid,i,j))\\n        return out\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3922330,
                "title": "easy-cpp-solution-beats-98-of-online-submission",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\nint delrow[4]={-1,0,1,0};\\nint delcol[4]={0,1,0,-1};\\nvoid dfs(vector<vector<int>>& g,int i,int j,int& cnt){\\ncnt=cnt+g[i][j];\\n//vis[i][j]=1;\\nint n=g.size();\\nint m=g[0].size();\\ng[i][j]=0;\\nfor(int k=0;k<4;k++){\\n    int nrow=i+delrow[k];\\n    int ncol=j+delcol[k];\\n    if(nrow>=0 && nrow<n && ncol>=0 && ncol<m && g[nrow][ncol]!=0){\\n        dfs(g,nrow,ncol,cnt);\\n    }\\n}\\n}\\npublic:\\n    int findMaxFish(vector<vector<int>>& grid) {\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        int maxi=0;\\nfor(int i=0;i<n;i++){\\n    for(int j=0;j<m;j++){\\nif(grid[i][j]!=0){\\n    int cnt=0;\\n   // vector<vector<int>> vis(n,vector<int>(m,0));\\ndfs(grid,i,j,cnt);\\nmaxi=max(maxi,cnt);\\n}\\n    }\\n}\\nreturn maxi;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\nint delrow[4]={-1,0,1,0};\\nint delcol[4]={0,1,0,-1};\\nvoid dfs(vector<vector<int>>& g,int i,int j,int& cnt){\\ncnt=cnt+g[i][j];\\n//vis[i][j]=1;\\nint n=g.size();\\nint m=g[0].size();\\ng[i][j]=0;\\nfor(int k=0;k<4;k++){\\n    int nrow=i+delrow[k];\\n    int ncol=j+delcol[k];\\n    if(nrow>=0 && nrow<n && ncol>=0 && ncol<m && g[nrow][ncol]!=0){\\n        dfs(g,nrow,ncol,cnt);\\n    }\\n}\\n}\\npublic:\\n    int findMaxFish(vector<vector<int>>& grid) {\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        int maxi=0;\\nfor(int i=0;i<n;i++){\\n    for(int j=0;j<m;j++){\\nif(grid[i][j]!=0){\\n    int cnt=0;\\n   // vector<vector<int>> vis(n,vector<int>(m,0));\\ndfs(grid,i,j,cnt);\\nmaxi=max(maxi,cnt);\\n}\\n    }\\n}\\nreturn maxi;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3917556,
                "title": "clean-bfs-implementation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def findMaxFish(self, grid: List[List[int]]) -> int:\\n        ans = 0\\n        m = len(grid)\\n        n = len(grid[0])\\n        directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\\n        for r in range(m):\\n            for c in range(n):\\n                if grid[r][c]>0:\\n                    queue = [(r,c)]\\n                    count = 0\\n                    while queue:\\n                        row,col = queue.pop()\\n                        if grid[row][col]==0:continue\\n                        count+=grid[row][col]\\n                        grid[row][col] = 0\\n                        for m_r,m_c in directions:\\n                            new_r,new_c = row+m_r,col+m_c\\n                            if 0 <= new_r < m and 0 <= new_c < n and grid[new_r][new_c] !=0:\\n                                queue.append((new_r, new_c))\\n                    ans = max(ans,count)\\n        return ans\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findMaxFish(self, grid: List[List[int]]) -> int:\\n        ans = 0\\n        m = len(grid)\\n        n = len(grid[0])\\n        directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\\n        for r in range(m):\\n            for c in range(n):\\n                if grid[r][c]>0:\\n                    queue = [(r,c)]\\n                    count = 0\\n                    while queue:\\n                        row,col = queue.pop()\\n                        if grid[row][col]==0:continue\\n                        count+=grid[row][col]\\n                        grid[row][col] = 0\\n                        for m_r,m_c in directions:\\n                            new_r,new_c = row+m_r,col+m_c\\n                            if 0 <= new_r < m and 0 <= new_c < n and grid[new_r][new_c] !=0:\\n                                queue.append((new_r, new_c))\\n                    ans = max(ans,count)\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3916100,
                "title": "easy-python-solution-by-using-dfs",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n    # dfs\\uFF0C\\u8FD4\\u56DE\\u6700\\u5927\\u503C\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution(object):\\n    def findMaxFish(self, grid):\\n        \"\"\"\\n        :type grid: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n        # dfs\\uFF0C\\u8FD4\\u56DE\\u6700\\u5927\\u503C\\n        m,n = len(grid), len(grid[0])\\n        visited = [[0 for j in range(n)] for i in range(m)]\\n        curfishes = [0]\\n\\n        def dfs(i,j):\\n            if 0<=i<=m-1 and 0<=j<=n-1 and visited[i][j] == 0:\\n                visited[i][j] = 1\\n                if grid[i][j] > 0:\\n                    curfishes[0] += grid[i][j]\\n                    dfs(i-1,j)\\n                    dfs(i+1,j)\\n                    dfs(i,j-1)\\n                    dfs(i,j+1)\\n        maxFishes = 0\\n        for i in range(m):\\n            for j in range(n):\\n                if visited[i][j] == 0 and grid[i][j] > 0:\\n                    curfishes[0] = 0\\n                    dfs(i,j)\\n                    maxFishes = max(maxFishes, curfishes[0])\\n        return maxFishes\\n\\n\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def findMaxFish(self, grid):\\n        \"\"\"\\n        :type grid: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n        # dfs\\uFF0C\\u8FD4\\u56DE\\u6700\\u5927\\u503C\\n        m,n = len(grid), len(grid[0])\\n        visited = [[0 for j in range(n)] for i in range(m)]\\n        curfishes = [0]\\n\\n        def dfs(i,j):\\n            if 0<=i<=m-1 and 0<=j<=n-1 and visited[i][j] == 0:\\n                visited[i][j] = 1\\n                if grid[i][j] > 0:\\n                    curfishes[0] += grid[i][j]\\n                    dfs(i-1,j)\\n                    dfs(i+1,j)\\n                    dfs(i,j-1)\\n                    dfs(i,j+1)\\n        maxFishes = 0\\n        for i in range(m):\\n            for j in range(n):\\n                if visited[i][j] == 0 and grid[i][j] > 0:\\n                    curfishes[0] = 0\\n                    dfs(i,j)\\n                    maxFishes = max(maxFishes, curfishes[0])\\n        return maxFishes\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3915836,
                "title": "easy-intuitive-java-solution-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int findMaxFish(int[][] grid) {\\n        int max = 0;\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        for(int i = 0; i < m; i++) {\\n            for(int j = 0; j < n; j++) {\\n                if(grid[i][j] != 0) {\\n                    int maxFish = dfs(grid, i, j);\\n                    max = Math.max(max, maxFish);\\n                }\\n            }\\n        }\\n        return max;\\n    }\\n    private int dfs(int[][] grid, int r, int c) {\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        if(r < 0 || c < 0 || r >= m || c >= n || grid[r][c] == 0) {\\n            return 0;\\n        }\\n       \\n        int curr = grid[r][c];\\n        grid[r][c] = 0;\\n        int u = dfs(grid, r - 1, c);  // Up\\n        int d = dfs(grid, r + 1, c);  // Down\\n        int ri = dfs(grid, r, c + 1); // Right\\n        int l = dfs(grid, r, c - 1);  // Left\\n        return curr + l + ri + u + d;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int findMaxFish(int[][] grid) {\\n        int max = 0;\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        for(int i = 0; i < m; i++) {\\n            for(int j = 0; j < n; j++) {\\n                if(grid[i][j] != 0) {\\n                    int maxFish = dfs(grid, i, j);\\n                    max = Math.max(max, maxFish);\\n                }\\n            }\\n        }\\n        return max;\\n    }\\n    private int dfs(int[][] grid, int r, int c) {\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        if(r < 0 || c < 0 || r >= m || c >= n || grid[r][c] == 0) {\\n            return 0;\\n        }\\n       \\n        int curr = grid[r][c];\\n        grid[r][c] = 0;\\n        int u = dfs(grid, r - 1, c);  // Up\\n        int d = dfs(grid, r + 1, c);  // Down\\n        int ri = dfs(grid, r, c + 1); // Right\\n        int l = dfs(grid, r, c - 1);  // Left\\n        return curr + l + ri + u + d;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3908818,
                "title": "javascript-dfs-o-n-2",
                "content": "```\\nvar findMaxFish = function(grid) {\\n  const dydx = [[0,1],[0,-1],[1,0],[-1,0]];\\n  const rows = grid.length;\\n  const cols = grid[0].length;\\n  const set = new Set();\\n  let max = 0;\\n\\n  for (let i = 0; i < rows; i++) {\\n    for (let j = 0; j < cols; j++) {\\n      if (grid[i][j] > 0) max = Math.max(grid[i][j] + dfs(i,j), max);\\n    }\\n  }\\n  return max;\\n\\n  function dfs(i, j) {\\n    const key = `${i}:${j}`;\\n    if (set.has(key) || notValid(i, j)) return 0;\\n    set.add(key);\\n\\n    let sum = 0;\\n    for (const [dy, dx] of dydx) {\\n      const [x, y] = [dx + i, dy + j];\\n      if (notValid(x,y) || set.has(`${x}:${y}`)) continue;\\n      sum += grid[x][y] + dfs(x,y,set);\\n    }\\n    return sum;\\n  }\\n\\n  function notValid (i, j) {\\n    return (i < 0 || i >= rows || j < 0 || j >= cols || grid[i][j] === 0); \\n  }\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar findMaxFish = function(grid) {\\n  const dydx = [[0,1],[0,-1],[1,0],[-1,0]];\\n  const rows = grid.length;\\n  const cols = grid[0].length;\\n  const set = new Set();\\n  let max = 0;\\n\\n  for (let i = 0; i < rows; i++) {\\n    for (let j = 0; j < cols; j++) {\\n      if (grid[i][j] > 0) max = Math.max(grid[i][j] + dfs(i,j), max);\\n    }\\n  }\\n  return max;\\n\\n  function dfs(i, j) {\\n    const key = `${i}:${j}`;\\n    if (set.has(key) || notValid(i, j)) return 0;\\n    set.add(key);\\n\\n    let sum = 0;\\n    for (const [dy, dx] of dydx) {\\n      const [x, y] = [dx + i, dy + j];\\n      if (notValid(x,y) || set.has(`${x}:${y}`)) continue;\\n      sum += grid[x][y] + dfs(x,y,set);\\n    }\\n    return sum;\\n  }\\n\\n  function notValid (i, j) {\\n    return (i < 0 || i >= rows || j < 0 || j >= cols || grid[i][j] === 0); \\n  }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3905885,
                "title": "cpp-easy-bfs-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nCall a BFS from each water cell we encounter and then find the max from all the function calls.\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nCall a BFS from each water cell we encounter and then find the max from all the function calls.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\nvector<pair<int,int>>vct={{0,1},{0,-1},{1,0},{-1,0}};\\nint bfs(int row,int col,vector<vector<int>>& grid)\\n{\\n    int res=0;\\n     std::vector<std::vector<bool>>track(grid.size(),std::vector<bool>(grid[0].size(),false));\\n     track[row][col]=true;\\n    std::queue<pair<int,int>>q;\\n    q.push({row,col});\\n    while(!q.empty())\\n    {\\n        int newrow=q.front().first;\\n        int newcol=q.front().second;\\n        res+=grid[q.front().first][q.front().second];\\n        q.pop();\\n        for(int i=0;i<vct.size();i++)\\n        {\\n            if((newrow+vct[i].first)>=0 && (newrow+vct[i].first)<grid.size() && (newcol+vct[i].second)>=0 && (newcol+vct[i].second)<grid[0].size() && grid[newrow+vct[i].first][newcol+vct[i].second]>0 && track[newrow+vct[i].first][newcol+vct[i].second]==false)\\n            {\\n                track[newrow+vct[i].first][newcol+vct[i].second]=true;\\n                q.push({newrow+vct[i].first,newcol+vct[i].second});\\n            }\\n        }\\n    }\\n    return res;\\n}\\n    int findMaxFish(vector<vector<int>>& grid) {\\n        int ans=0;\\n        for(int i=0;i<grid.size();i++)\\n        {\\n            for(int j=0;j<grid[i].size();j++)\\n            {\\n                if(grid[i][j]>0)\\n                {\\n                   \\n                    int subans=bfs(i,j,grid);\\n                    ans=max(ans,subans);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nvector<pair<int,int>>vct={{0,1},{0,-1},{1,0},{-1,0}};\\nint bfs(int row,int col,vector<vector<int>>& grid)\\n{\\n    int res=0;\\n     std::vector<std::vector<bool>>track(grid.size(),std::vector<bool>(grid[0].size(),false));\\n     track[row][col]=true;\\n    std::queue<pair<int,int>>q;\\n    q.push({row,col});\\n    while(!q.empty())\\n    {\\n        int newrow=q.front().first;\\n        int newcol=q.front().second;\\n        res+=grid[q.front().first][q.front().second];\\n        q.pop();\\n        for(int i=0;i<vct.size();i++)\\n        {\\n            if((newrow+vct[i].first)>=0 && (newrow+vct[i].first)<grid.size() && (newcol+vct[i].second)>=0 && (newcol+vct[i].second)<grid[0].size() && grid[newrow+vct[i].first][newcol+vct[i].second]>0 && track[newrow+vct[i].first][newcol+vct[i].second]==false)\\n            {\\n                track[newrow+vct[i].first][newcol+vct[i].second]=true;\\n                q.push({newrow+vct[i].first,newcol+vct[i].second});\\n            }\\n        }\\n    }\\n    return res;\\n}\\n    int findMaxFish(vector<vector<int>>& grid) {\\n        int ans=0;\\n        for(int i=0;i<grid.size();i++)\\n        {\\n            for(int j=0;j<grid[i].size();j++)\\n            {\\n                if(grid[i][j]>0)\\n                {\\n                   \\n                    int subans=bfs(i,j,grid);\\n                    ans=max(ans,subans);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3896630,
                "title": "c-clean-code-too-easy-short",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:long long int a=0,s=0;\\n    void t(int i,int j,vector<vector<int>>& g)\\n    {\\n         if(i<0 || j<0 || i>=g.size() || j>=g[0].size() || g[i][j]==0) return;\\n         s+=g[i][j];\\n         g[i][j]=0;\\n\\n         t(i+1,j,g);\\n         t(i-1,j,g);\\n         t(i,j+1,g);\\n         t(i,j-1,g);\\n    }\\n    int findMaxFish(vector<vector<int>>& g) {\\n        for(int i=0;i<g.size();i++)\\n         for(int j=0;j<g[0].size();j++)\\n          if(g[i][j]>0)\\n            {t(i,j,g);\\n            a=max(a,s);\\n            s=0;\\n            }\\n\\n       return a;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:long long int a=0,s=0;\\n    void t(int i,int j,vector<vector<int>>& g)\\n    {\\n         if(i<0 || j<0 || i>=g.size() || j>=g[0].size() || g[i][j]==0) return;\\n         s+=g[i][j];\\n         g[i][j]=0;\\n\\n         t(i+1,j,g);\\n         t(i-1,j,g);\\n         t(i,j+1,g);\\n         t(i,j-1,g);\\n    }\\n    int findMaxFish(vector<vector<int>>& g) {\\n        for(int i=0;i<g.size();i++)\\n         for(int j=0;j<g[0].size();j++)\\n          if(g[i][j]>0)\\n            {t(i,j,g);\\n            a=max(a,s);\\n            s=0;\\n            }\\n\\n       return a;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3868878,
                "title": "dfs-c",
                "content": "# Intuition\\nDo a DFS a find the maximum count\\n\\n# Complexity\\n- Time complexity:\\nO{m*n)\\n\\n- Space complexity:\\nO(m*n)\\n\\n# Code\\n```\\npublic class Solution {\\n    public int FindMaxFish(int[][] grid) {\\n        \\n        int m = grid.Length;\\n        int n = grid[0].Length;\\n\\n        bool[,] visited = new bool[m,n];\\n        int maxFishes = 0;\\n\\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                if(grid[i][j]!=0 && !visited[i,j])\\n                {\\n                    maxFishes = Math.Max(maxFishes,DFS(grid,i,j,visited));\\n                }\\n            }\\n        }\\n        return maxFishes;\\n    }\\n\\n    private int DFS(int[][] grid,int i,int j, bool[,] visited)\\n    {\\n\\n        int[] c = new int[]{1,0,-1,0};\\n        int[] r = new int[]{0,-1,0,1};\\n        int sum = grid[i][j];\\n        visited[i,j] = true;\\n        \\n        for(int k=0;k<4;k++)\\n        {\\n            int row = i+r[k];\\n            int col = j+c[k];\\n            if(isAllowed(row,col,grid.Length,grid[0].Length) && !visited[row,col] && grid[row][col]!=0)\\n            {\\n                sum = sum + DFS(grid,row,col,visited);\\n            }\\n        }\\n        return sum;\\n    }\\n\\n    private bool isAllowed(int i,int j,int m,int n)\\n    {\\n        if(i>=0 && i< m && j>=0 && j<n)\\n            return true;\\n\\n        return false;    \\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int FindMaxFish(int[][] grid) {\\n        \\n        int m = grid.Length;\\n        int n = grid[0].Length;\\n\\n        bool[,] visited = new bool[m,n];\\n        int maxFishes = 0;\\n\\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                if(grid[i][j]!=0 && !visited[i,j])\\n                {\\n                    maxFishes = Math.Max(maxFishes,DFS(grid,i,j,visited));\\n                }\\n            }\\n        }\\n        return maxFishes;\\n    }\\n\\n    private int DFS(int[][] grid,int i,int j, bool[,] visited)\\n    {\\n\\n        int[] c = new int[]{1,0,-1,0};\\n        int[] r = new int[]{0,-1,0,1};\\n        int sum = grid[i][j];\\n        visited[i,j] = true;\\n        \\n        for(int k=0;k<4;k++)\\n        {\\n            int row = i+r[k];\\n            int col = j+c[k];\\n            if(isAllowed(row,col,grid.Length,grid[0].Length) && !visited[row,col] && grid[row][col]!=0)\\n            {\\n                sum = sum + DFS(grid,row,col,visited);\\n            }\\n        }\\n        return sum;\\n    }\\n\\n    private bool isAllowed(int i,int j,int m,int n)\\n    {\\n        if(i>=0 && i< m && j>=0 && j<n)\\n            return true;\\n\\n        return false;    \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3863959,
                "title": "python3-good-enough",
                "content": "``` Python3 []\\nclass Solution:\\n    def findMaxFish(self, grid: List[List[int]]) -> int:\\n        maxx = 0\\n\\n        def helper(x,y):\\n            if x<0 or y<0 or x>=len(grid) or y>=len(grid[0]) or not grid[x][y]:\\n                return 0\\n            \\n            current = grid[x][y]\\n            grid[x][y] = 0\\n\\n            return current + helper(x-1,y) + helper(x+1,y) + helper(x,y-1) + helper(x,y+1)\\n\\n        for i in range(len(grid)):\\n            for j in range(len(grid[0])):\\n                if grid[i][j]:\\n                    maxx = max(helper(i,j), maxx)\\n        \\n        return maxx\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "``` Python3 []\\nclass Solution:\\n    def findMaxFish(self, grid: List[List[int]]) -> int:\\n        maxx = 0\\n\\n        def helper(x,y):\\n            if x<0 or y<0 or x>=len(grid) or y>=len(grid[0]) or not grid[x][y]:\\n                return 0\\n            \\n            current = grid[x][y]\\n            grid[x][y] = 0\\n\\n            return current + helper(x-1,y) + helper(x+1,y) + helper(x,y-1) + helper(x,y+1)\\n\\n        for i in range(len(grid)):\\n            for j in range(len(grid[0])):\\n                if grid[i][j]:\\n                    maxx = max(helper(i,j), maxx)\\n        \\n        return maxx\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3849817,
                "title": "python-3-with-dfs",
                "content": "# Complexity\\n- Time complexity: O(n * m)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def findMaxFish(self, grid: List[List[int]]) -> int:\\n\\n        n, m = len(grid), len(grid[0])\\n\\n\\n        def dfs(i, j):\\n            if i < 0 or j < 0 or i >= n or j >= m:\\n                return 0\\n            \\n            if grid[i][j] == 0:\\n                return 0\\n\\n            fish, grid[i][j] = grid[i][j], 0\\n\\n            fish += dfs(i + 1, j)\\n            fish += dfs(i - 1, j)\\n            fish += dfs(i, j + 1)\\n            fish += dfs(i, j - 1)\\n            return fish\\n\\n            \\n        ans = 0\\n        for i in range(n):\\n            for j in range(m):\\n                if grid[i][j] != 0:\\n                    ans = max(ans, dfs(i, j))\\n\\n        return ans\\n\\n\\n\\n\\n\\n\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findMaxFish(self, grid: List[List[int]]) -> int:\\n\\n        n, m = len(grid), len(grid[0])\\n\\n\\n        def dfs(i, j):\\n            if i < 0 or j < 0 or i >= n or j >= m:\\n                return 0\\n            \\n            if grid[i][j] == 0:\\n                return 0\\n\\n            fish, grid[i][j] = grid[i][j], 0\\n\\n            fish += dfs(i + 1, j)\\n            fish += dfs(i - 1, j)\\n            fish += dfs(i, j + 1)\\n            fish += dfs(i, j - 1)\\n            return fish\\n\\n            \\n        ans = 0\\n        for i in range(n):\\n            for j in range(m):\\n                if grid[i][j] != 0:\\n                    ans = max(ans, dfs(i, j))\\n\\n        return ans\\n\\n\\n\\n\\n\\n\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3848447,
                "title": "beats-100-java-dfs",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->DFS\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    private int dfs(int[][] grid, int r, int c){\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        if(r<0||c<0||r>=m||c>=n||grid[r][c]==0)\\n        return 0;\\n        int x = grid[r][c];\\n        grid[r][c] = 0;\\n\\n        return x+dfs(grid,r-1,c)+dfs(grid,r+1,c)+dfs(grid,r,c-1)+dfs(grid,r,c+1);\\n    }\\n    public int findMaxFish(int[][] grid) {\\n        int fish = 0;\\n        for (int i = 0; i < grid.length; i++){\\n            for (int j = 0; j < grid[0].length; j++){\\n                if(grid[i][j] != 0){\\n                    fish = Math.max(fish,dfs(grid,i,j));\\n                }\\n            }\\n        }\\n        return fish;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\n    private int dfs(int[][] grid, int r, int c){\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        if(r<0||c<0||r>=m||c>=n||grid[r][c]==0)\\n        return 0;\\n        int x = grid[r][c];\\n        grid[r][c] = 0;\\n\\n        return x+dfs(grid,r-1,c)+dfs(grid,r+1,c)+dfs(grid,r,c-1)+dfs(grid,r,c+1);\\n    }\\n    public int findMaxFish(int[][] grid) {\\n        int fish = 0;\\n        for (int i = 0; i < grid.length; i++){\\n            for (int j = 0; j < grid[0].length; j++){\\n                if(grid[i][j] != 0){\\n                    fish = Math.max(fish,dfs(grid,i,j));\\n                }\\n            }\\n        }\\n        return fish;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3848212,
                "title": "python-dfs-beats-98-time",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nNeed to calculate total number of fishes from each group of fishes\\n\\nSo, apply dfs in each group and mark it as visited to avoid going to it again\\n\\n# Approach 1\\n<!-- Describe your approach to solving the problem. -->\\nCall dfs at every point mark the elements visited in visited array. Recursively call for all its adjacent nodes and return the total \\n\\n# Complexity\\n- Time complexity: O(n * m)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n * m)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```class Solution:\\n    def findMaxFish(self, grid: List[List[int]]) -> int:\\n        m = len(grid)\\n        n = len(grid[0])\\n        visited = [[False for i in range(n)] for j in range(m)]\\n\\n\\n        def isSafe(i, j):\\n            if i >= 0 and j >= 0 and i < m and j < n:\\n                return True\\n            return False\\n\\n        def dfs(i, j):\\n            visited[i][j] = True\\n            res = grid[i][j]\\n\\n            dir = [(1, 0), (-1, 0), (0, 1), (0, -1)]\\n            for x, y in dir:\\n                if isSafe(i+x, j+y) and grid[i + x][j + y] != 0 and visited[i + x][j + y] == False:\\n                    res = res +  dfs(i + x, j + y)\\n            \\n            return res\\n        \\n        ans = 0\\n        for i in range(m):\\n            for j in range(n):\\n                if grid[i][j] != 0 and visited[i][j] == False:\\n                    ans = max(ans, dfs(i, j))\\n        \\n        return ans\\n```\\n\\n# Approach 2\\n<!-- Describe your approach to solving the problem. -->\\nSpace Optimized (marking value to 0 on grid after visiting it)\\n\\n# Complexity\\n- Time complexity: O(n * m)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1) (Not including recursion stack space)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n\\n\\n\\n```\\nclass Solution:\\n    def findMaxFish(self, grid: List[List[int]]) -> int:\\n        m = len(grid)\\n        n = len(grid[0])\\n\\n        dir = [(1, 0), (-1, 0), (0, 1), (0, -1)]\\n\\n        def isSafe(i, j):\\n            if i >= 0 and j >= 0 and i < m and j < n:\\n                return True\\n            return False\\n\\n        def dfs(i, j):\\n            \\n            if not isSafe(i, j) or grid[i][j] == 0:\\n                return 0\\n\\n            res = grid[i][j]\\n            grid[i][j] = 0\\n\\n\\n            for x, y in dir:\\n                res = res +  dfs(i + x, j + y)\\n            \\n            return res\\n        \\n        ans = 0\\n        for i in range(m):\\n            for j in range(n):\\n                if grid[i][j] != 0:\\n                    ans = max(ans, dfs(i, j))\\n        \\n        return ans\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```class Solution:\\n    def findMaxFish(self, grid: List[List[int]]) -> int:\\n        m = len(grid)\\n        n = len(grid[0])\\n        visited = [[False for i in range(n)] for j in range(m)]\\n\\n\\n        def isSafe(i, j):\\n            if i >= 0 and j >= 0 and i < m and j < n:\\n                return True\\n            return False\\n\\n        def dfs(i, j):\\n            visited[i][j] = True\\n            res = grid[i][j]\\n\\n            dir = [(1, 0), (-1, 0), (0, 1), (0, -1)]\\n            for x, y in dir:\\n                if isSafe(i+x, j+y) and grid[i + x][j + y] != 0 and visited[i + x][j + y] == False:\\n                    res = res +  dfs(i + x, j + y)\\n            \\n            return res\\n        \\n        ans = 0\\n        for i in range(m):\\n            for j in range(n):\\n                if grid[i][j] != 0 and visited[i][j] == False:\\n                    ans = max(ans, dfs(i, j))\\n        \\n        return ans\\n```\n```\\nclass Solution:\\n    def findMaxFish(self, grid: List[List[int]]) -> int:\\n        m = len(grid)\\n        n = len(grid[0])\\n\\n        dir = [(1, 0), (-1, 0), (0, 1), (0, -1)]\\n\\n        def isSafe(i, j):\\n            if i >= 0 and j >= 0 and i < m and j < n:\\n                return True\\n            return False\\n\\n        def dfs(i, j):\\n            \\n            if not isSafe(i, j) or grid[i][j] == 0:\\n                return 0\\n\\n            res = grid[i][j]\\n            grid[i][j] = 0\\n\\n\\n            for x, y in dir:\\n                res = res +  dfs(i + x, j + y)\\n            \\n            return res\\n        \\n        ans = 0\\n        for i in range(m):\\n            for j in range(n):\\n                if grid[i][j] != 0:\\n                    ans = max(ans, dfs(i, j))\\n        \\n        return ans\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3839217,
                "title": "100-beating-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int findMaxFish(int[][] grid) {\\n        int max=0;\\n        int n=grid.length;\\n        int m=grid[0].length;\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(grid[i][j]!=0 ){\\n                    max=Math.max(max,helper(grid,i,j,n,m));\\n                }\\n            }\\n        }\\n        return max;\\n    }\\n\\n    public int helper(int[][] grid,int i,int j,int n,int m){\\n        if(i<0 || j<0 || i>=n || j>=m)return 0;\\n        if(grid[i][j]==0)return 0;\\n        int ans=grid[i][j];\\n        grid[i][j]=0;\\n        return ans+helper(grid,i+1,j,n,m)+helper(grid,i,j-1,n,m)+helper(grid,i-1,j,n,m)+helper(grid,i,j+1,n,m);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int findMaxFish(int[][] grid) {\\n        int max=0;\\n        int n=grid.length;\\n        int m=grid[0].length;\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(grid[i][j]!=0 ){\\n                    max=Math.max(max,helper(grid,i,j,n,m));\\n                }\\n            }\\n        }\\n        return max;\\n    }\\n\\n    public int helper(int[][] grid,int i,int j,int n,int m){\\n        if(i<0 || j<0 || i>=n || j>=m)return 0;\\n        if(grid[i][j]==0)return 0;\\n        int ans=grid[i][j];\\n        grid[i][j]=0;\\n        return ans+helper(grid,i+1,j,n,m)+helper(grid,i,j-1,n,m)+helper(grid,i-1,j,n,m)+helper(grid,i,j+1,n,m);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3832115,
                "title": "c-simple-beginner-friendly-solution-ll-bfs-dfs-union-find",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findMaxFish(vector<vector<int>>& grid) {\\n        int mx=0,i=0,j=0,p=0,m=grid.size(),n=grid[0].size(),f=0,r=0,c=0,s=0,a=0,k=0;\\n        queue<int>q;\\n        for(i=0;i<m;i++)\\n            for(j=0;j<n;j++)\\n                if(grid[i][j]>0)\\n                {\\n                    a=0;\\n                    q.push(i*n+j);\\n                    while(q.size()>0)\\n                    {\\n                        s=q.size();\\n                        for(k=0;k<s;k++)\\n                        {\\n                            f=q.front();\\n                            r=f/n,c=f%n;\\n                            if(grid[r][c]>0)\\n                            {\\n                                a+=grid[r][c];\\n                                grid[r][c]=0;\\n                                if(r>0) q.push(f-n);\\n                                if(r<m-1) q.push(f+n);\\n                                if(c>0) q.push(f-1);\\n                                if(c<n-1) q.push(f+1);\\n                            }\\n                            q.pop();\\n                        }\\n                    }\\n                    mx=max(a,mx);\\n                }\\n        return mx;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findMaxFish(vector<vector<int>>& grid) {\\n        int mx=0,i=0,j=0,p=0,m=grid.size(),n=grid[0].size(),f=0,r=0,c=0,s=0,a=0,k=0;\\n        queue<int>q;\\n        for(i=0;i<m;i++)\\n            for(j=0;j<n;j++)\\n                if(grid[i][j]>0)\\n                {\\n                    a=0;\\n                    q.push(i*n+j);\\n                    while(q.size()>0)\\n                    {\\n                        s=q.size();\\n                        for(k=0;k<s;k++)\\n                        {\\n                            f=q.front();\\n                            r=f/n,c=f%n;\\n                            if(grid[r][c]>0)\\n                            {\\n                                a+=grid[r][c];\\n                                grid[r][c]=0;\\n                                if(r>0) q.push(f-n);\\n                                if(r<m-1) q.push(f+n);\\n                                if(c>0) q.push(f-1);\\n                                if(c<n-1) q.push(f+1);\\n                            }\\n                            q.pop();\\n                        }\\n                    }\\n                    mx=max(a,mx);\\n                }\\n        return mx;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3827389,
                "title": "bfs-from-land",
                "content": "# Intuition\\n\\nWe can do DFS from each land, but BFS seems interesting here.\\n\\n# Approach\\n\\nCollect all land first. And do BFS for each land. Collecting profit.\\n\\n# Complexity\\n- Time complexity:\\n`O(rows * cols)`\\n\\n- Space complexity:\\n`O(rows * cols)`\\n\\n# Code\\n```\\ntype Pair struct {r, c int}\\n\\nfunc findMaxFish(grid [][]int) int {\\n    // collect all land points\\n    rows, cols := len(grid), len(grid[0])\\n\\n    landArr := []Pair{}\\n\\n    for r := 0; r < rows; r++ {\\n        for c := 0; c < cols; c++ {\\n            // land\\n            if grid[r][c] != 0 {\\n                landArr = append(landArr, Pair{r, c})\\n            }\\n        }\\n    }\\n\\n    profit := 0\\n\\n    if len(landArr) == 0 {\\n       return profit \\n    }\\n\\n    checkNei := func(r, c int, visited [][]bool) bool {\\n        return r >= 0 && r < rows && c >= 0 && c < cols && grid[r][c] > 0 && !visited[r][c]\\n    }\\n\\n    for _, land := range landArr {\\n\\n        newProfit := 0\\n        // start \\n        q := []Pair{land}\\n\\n        visited := make([][]bool, rows)\\n\\n        for r := 0; r < rows; r++ {\\n            visited[r] = make([]bool, cols)\\n        }\\n\\n        for len(q) > 0 {\\n            cur := q[0]\\n            q = q[1:]\\n\\n            if visited[cur.r][cur.c] {continue}\\n\\n            newProfit += grid[cur.r][cur.c]\\n            \\n            visited[cur.r][cur.c] = true\\n\\n            if checkNei(cur.r + 1, cur.c, visited) {\\n                q = append(q, Pair{cur.r + 1, cur.c})\\n            }\\n\\n            if checkNei(cur.r - 1, cur.c, visited) {\\n                q = append(q, Pair{cur.r - 1, cur.c})\\n            }\\n\\n            if checkNei(cur.r, cur.c + 1, visited) {\\n                q = append(q, Pair{cur.r, cur.c + 1})\\n            }\\n\\n            if checkNei(cur.r, cur.c - 1, visited) {\\n                q = append(q, Pair{cur.r, cur.c - 1})\\n            }\\n        }\\n\\n        if newProfit > profit {\\n            profit = newProfit\\n        }\\n    }\\n\\n    return profit\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\ntype Pair struct {r, c int}\\n\\nfunc findMaxFish(grid [][]int) int {\\n    // collect all land points\\n    rows, cols := len(grid), len(grid[0])\\n\\n    landArr := []Pair{}\\n\\n    for r := 0; r < rows; r++ {\\n        for c := 0; c < cols; c++ {\\n            // land\\n            if grid[r][c] != 0 {\\n                landArr = append(landArr, Pair{r, c})\\n            }\\n        }\\n    }\\n\\n    profit := 0\\n\\n    if len(landArr) == 0 {\\n       return profit \\n    }\\n\\n    checkNei := func(r, c int, visited [][]bool) bool {\\n        return r >= 0 && r < rows && c >= 0 && c < cols && grid[r][c] > 0 && !visited[r][c]\\n    }\\n\\n    for _, land := range landArr {\\n\\n        newProfit := 0\\n        // start \\n        q := []Pair{land}\\n\\n        visited := make([][]bool, rows)\\n\\n        for r := 0; r < rows; r++ {\\n            visited[r] = make([]bool, cols)\\n        }\\n\\n        for len(q) > 0 {\\n            cur := q[0]\\n            q = q[1:]\\n\\n            if visited[cur.r][cur.c] {continue}\\n\\n            newProfit += grid[cur.r][cur.c]\\n            \\n            visited[cur.r][cur.c] = true\\n\\n            if checkNei(cur.r + 1, cur.c, visited) {\\n                q = append(q, Pair{cur.r + 1, cur.c})\\n            }\\n\\n            if checkNei(cur.r - 1, cur.c, visited) {\\n                q = append(q, Pair{cur.r - 1, cur.c})\\n            }\\n\\n            if checkNei(cur.r, cur.c + 1, visited) {\\n                q = append(q, Pair{cur.r, cur.c + 1})\\n            }\\n\\n            if checkNei(cur.r, cur.c - 1, visited) {\\n                q = append(q, Pair{cur.r, cur.c - 1})\\n            }\\n        }\\n\\n        if newProfit > profit {\\n            profit = newProfit\\n        }\\n    }\\n\\n    return profit\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3824188,
                "title": "easy-dfs-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    int count;\\n    public int findMaxFish(int[][] mat) {\\n        int n=mat.length;\\n        int m=mat[0].length;\\n      \\n       int ans=0;\\n\\n       for(int i=0;i<n;i++){\\n           for(int j=0;j<m;j++){\\n               count=0;\\n               if(mat[i][j]!=0){\\n                   dfs( mat,i,j);\\n                   ans=Math.max(count,ans);\\n               }\\n           }\\n       }\\n       return ans;\\n    }\\n\\n\\n    public void dfs(int[][] mat,int i,int j){\\n        if(i<0||j<0||i>=mat.length||j>=mat[0].length||mat[i][j]==0)return;\\n        count+=mat[i][j];\\n        mat[i][j]=0;\\n        dfs(mat,i+1,j);\\n        dfs(mat,i-1,j);\\n        dfs(mat,i,j+1);\\n        dfs(mat,i,j-1);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\n    int count;\\n    public int findMaxFish(int[][] mat) {\\n        int n=mat.length;\\n        int m=mat[0].length;\\n      \\n       int ans=0;\\n\\n       for(int i=0;i<n;i++){\\n           for(int j=0;j<m;j++){\\n               count=0;\\n               if(mat[i][j]!=0){\\n                   dfs( mat,i,j);\\n                   ans=Math.max(count,ans);\\n               }\\n           }\\n       }\\n       return ans;\\n    }\\n\\n\\n    public void dfs(int[][] mat,int i,int j){\\n        if(i<0||j<0||i>=mat.length||j>=mat[0].length||mat[i][j]==0)return;\\n        count+=mat[i][j];\\n        mat[i][j]=0;\\n        dfs(mat,i+1,j);\\n        dfs(mat,i-1,j);\\n        dfs(mat,i,j+1);\\n        dfs(mat,i,j-1);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3817700,
                "title": "dfs-solution",
                "content": "# Code\\n```\\nclass Solution {\\n    public int findMaxFish(int[][] grid) {\\n        int m = grid.length;\\n        int n = grid[0].length;\\n       boolean [][] visited = new boolean[m][n];\\n       int ans = 0;\\n       for(int i = 0;i<m ; i++){\\n           for(int j = 0; j<n; j++){\\n               if(grid[i][j]!= 0 && !visited[i][j])\\n               ans = Math.max(ans,dfs(grid,visited,i,j,m,n));\\n           }\\n       }\\n       return ans;\\n    }\\n    public int dfs(int[][] grid, boolean [][] visited,int i,int j,int m,int n){\\n        if(i<0 || j<0 || i>=m || j>= n || grid[i][j]== 0|| visited[i][j])\\n        return 0;\\n        visited[i][j] = true;\\n        int fish = grid[i][j];\\n        return fish + dfs(grid,visited,i+1,j,m,n) +\\n                dfs(grid,visited,i,j+1,m,n) +\\n                dfs(grid,visited,i-1,j,m,n) +\\n                dfs(grid,visited,i,j-1,m,n);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    public int findMaxFish(int[][] grid) {\\n        int m = grid.length;\\n        int n = grid[0].length;\\n       boolean [][] visited = new boolean[m][n];\\n       int ans = 0;\\n       for(int i = 0;i<m ; i++){\\n           for(int j = 0; j<n; j++){\\n               if(grid[i][j]!= 0 && !visited[i][j])\\n               ans = Math.max(ans,dfs(grid,visited,i,j,m,n));\\n           }\\n       }\\n       return ans;\\n    }\\n    public int dfs(int[][] grid, boolean [][] visited,int i,int j,int m,int n){\\n        if(i<0 || j<0 || i>=m || j>= n || grid[i][j]== 0|| visited[i][j])\\n        return 0;\\n        visited[i][j] = true;\\n        int fish = grid[i][j];\\n        return fish + dfs(grid,visited,i+1,j,m,n) +\\n                dfs(grid,visited,i,j+1,m,n) +\\n                dfs(grid,visited,i-1,j,m,n) +\\n                dfs(grid,visited,i,j-1,m,n);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3812217,
                "title": "python-solution-dfs-explained",
                "content": "```\\nclass Solution:\\n    def findMaxFish(self, grid: List[List[int]]) -> int:\\n\\t    # visited keeps track of all the cells visited\\n        visited = set()\\n\\t\\t\\n\\t\\t#initialize rows and columns variables\\n        rows = len(grid)\\n        cols = len(grid[0])\\n        \\n        # DFS function\\n        def backtrack(i, j):\\n\\t\\t    # Check if out of bounds\\n            if i < 0 or j < 0 or i == rows or j == cols:\\n                return 0\\n            else:\\n\\t\\t\\t    # If land the fish caught will be 0\\n                if grid[i][j] == 0:\\n                    return 0\\n\\t\\t\\t\\t# If already visited don\\'t take the path\\n                if (i, j) in visited:\\n                    return 0\\n                \\n\\t\\t\\t\\t# Add the cell to visited\\n                visited.add((i, j))\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t# Find out the total number of fish that can be caught by performing DFS recursively\\n                return grid[i][j] + backtrack(i, j + 1) + backtrack(i, j - 1) + backtrack(i+1, j) + backtrack(i-1,j)\\n            \\n            \\n        res = 0\\n            \\n        \\n\\t\\t# Iterate over every cell of the grid\\n        for i in range(rows):\\n            for j in range(cols):\\n\\t\\t\\t   # If the grid is not land and it has been not visited so far, perform DFS on it and get the total sum as current value\\n                if (i, j) not in visited and grid[i][j] != 0:\\n                    current_value = backtrack(i, j)\\n\\t\\t\\t\\t\\t# If this path gives best result update the result variable\\n                    res = max(current_value, res)\\n        return res\\n            \\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def findMaxFish(self, grid: List[List[int]]) -> int:\\n\\t    # visited keeps track of all the cells visited\\n        visited = set()\\n\\t\\t\\n\\t\\t#initialize rows and columns variables\\n        rows = len(grid)\\n        cols = len(grid[0])\\n        \\n        # DFS function\\n        def backtrack(i, j):\\n\\t\\t    # Check if out of bounds\\n            if i < 0 or j < 0 or i == rows or j == cols:\\n                return 0\\n            else:\\n\\t\\t\\t    # If land the fish caught will be 0\\n                if grid[i][j] == 0:\\n                    return 0\\n\\t\\t\\t\\t# If already visited don\\'t take the path\\n                if (i, j) in visited:\\n                    return 0\\n                \\n\\t\\t\\t\\t# Add the cell to visited\\n                visited.add((i, j))\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t# Find out the total number of fish that can be caught by performing DFS recursively\\n                return grid[i][j] + backtrack(i, j + 1) + backtrack(i, j - 1) + backtrack(i+1, j) + backtrack(i-1,j)\\n            \\n            \\n        res = 0\\n            \\n        \\n\\t\\t# Iterate over every cell of the grid\\n        for i in range(rows):\\n            for j in range(cols):\\n\\t\\t\\t   # If the grid is not land and it has been not visited so far, perform DFS on it and get the total sum as current value\\n                if (i, j) not in visited and grid[i][j] != 0:\\n                    current_value = backtrack(i, j)\\n\\t\\t\\t\\t\\t# If this path gives best result update the result variable\\n                    res = max(current_value, res)\\n        return res\\n            \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3800687,
                "title": "simplest-solution-dfs-brute-force",
                "content": "# Complexity\\n- Time complexity:$$O(n^2)$$\\n\\n- Space complexity:$$stack->O(n)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n   void dfs(int r,int c,vector<vector<int>>&grid,int &sum)\\n   {   int n=grid.size(),m=grid[0].size();\\n       \\n       sum +=grid[r][c];\\n       grid[r][c]=0;\\n\\n       if(r+1<n and grid[r+1][c]!=0)\\n       {\\n         dfs(r+1,c,grid,sum);\\n       }\\n       if(c+1<m and grid[r][c+1] !=0)\\n       {\\n           dfs(r,c+1,grid,sum);\\n       }\\n       if(r-1>=0 and grid[r-1][c] !=0)\\n       {\\n           dfs(r-1,c,grid,sum);\\n       }\\n\\n       if(c-1>=0 and grid[r][c-1] !=0)\\n       {\\n          dfs(r,c-1,grid,sum);\\n       }        \\n   }\\n\\n\\n\\n    int findMaxFish(vector<vector<int>>& grid) {\\n        int fish=0;\\n        for(int i=0;i<grid.size();i++){\\n            for(int j=0;j<grid[0].size();j++){\\n                if(grid[i][j]>0){\\n                    int sum=0;\\n                    dfs(i,j,grid,sum);\\n                    fish=max(fish,sum);\\n                }\\n            }\\n        }\\n    return fish;}\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n   void dfs(int r,int c,vector<vector<int>>&grid,int &sum)\\n   {   int n=grid.size(),m=grid[0].size();\\n       \\n       sum +=grid[r][c];\\n       grid[r][c]=0;\\n\\n       if(r+1<n and grid[r+1][c]!=0)\\n       {\\n         dfs(r+1,c,grid,sum);\\n       }\\n       if(c+1<m and grid[r][c+1] !=0)\\n       {\\n           dfs(r,c+1,grid,sum);\\n       }\\n       if(r-1>=0 and grid[r-1][c] !=0)\\n       {\\n           dfs(r-1,c,grid,sum);\\n       }\\n\\n       if(c-1>=0 and grid[r][c-1] !=0)\\n       {\\n          dfs(r,c-1,grid,sum);\\n       }        \\n   }\\n\\n\\n\\n    int findMaxFish(vector<vector<int>>& grid) {\\n        int fish=0;\\n        for(int i=0;i<grid.size();i++){\\n            for(int j=0;j<grid[0].size();j++){\\n                if(grid[i][j]>0){\\n                    int sum=0;\\n                    dfs(i,j,grid,sum);\\n                    fish=max(fish,sum);\\n                }\\n            }\\n        }\\n    return fish;}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3797461,
                "title": "union-find-c",
                "content": "```\\nclass Solution {\\npublic:\\n\\n    int r,c;\\n    vector<int>parents;\\n\\n    bool isValid(int x, int y, vector<vector<int>>&grid){\\n        if((x>=0 && x<r) && (y>=0 && y<c) && grid[x][y])\\n            return true;\\n        return false;\\n    }\\n\\n    int getAbsoluteParent(int n){\\n        if(n!=parents[n])\\n            parents[n] = getAbsoluteParent(parents[n]);\\n        \\n        return parents[n];\\n    }\\n\\n    void unify(int x, int y){\\n        int px = getAbsoluteParent(x);\\n        int py = getAbsoluteParent(y);\\n\\n        if(px!=py)\\n            parents[px] = py;\\n    }\\n\\n    int findMaxFish(vector<vector<int>>& grid) {\\n        r = grid.size();\\n        c = grid[0].size();\\n        vector<pair<int,int>>dirs{{-1,0},{1,0},{0,-1},{0,1}};\\n        vector<int>totalFishes(r*c,0);\\n        parents = vector<int>(r*c);\\n        \\n        for(int i=0;i<r*c;i++)\\n            parents[i] = i;\\n        \\n        for(int i=0;i<r;i++){\\n            for(int j=0;j<c;j++){\\n                if(!grid[i][j])\\n                    continue;\\n\\n                for(int k=0;k<4;k++){\\n                    int ni = i + dirs[k].first;\\n                    int nj = j + dirs[k].second;\\n                    if(isValid(ni,nj,grid)){\\n                        unify(ni*c+nj,i*c+j);\\n                    }\\n                }\\n            }\\n        }\\n        \\n        int ans = 0;\\n        for(int i=0;i<r;i++){\\n            for(int j=0;j<c;j++){\\n\\n                if(grid[i][j]){\\n                    int cur_parent = getAbsoluteParent(i*c+j);\\n                    totalFishes[cur_parent] += grid[i][j];\\n                    ans = max(ans,totalFishes[cur_parent]);\\n                }\\n                    \\n            }\\n        } \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Union Find"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    int r,c;\\n    vector<int>parents;\\n\\n    bool isValid(int x, int y, vector<vector<int>>&grid){\\n        if((x>=0 && x<r) && (y>=0 && y<c) && grid[x][y])\\n            return true;\\n        return false;\\n    }\\n\\n    int getAbsoluteParent(int n){\\n        if(n!=parents[n])\\n            parents[n] = getAbsoluteParent(parents[n]);\\n        \\n        return parents[n];\\n    }\\n\\n    void unify(int x, int y){\\n        int px = getAbsoluteParent(x);\\n        int py = getAbsoluteParent(y);\\n\\n        if(px!=py)\\n            parents[px] = py;\\n    }\\n\\n    int findMaxFish(vector<vector<int>>& grid) {\\n        r = grid.size();\\n        c = grid[0].size();\\n        vector<pair<int,int>>dirs{{-1,0},{1,0},{0,-1},{0,1}};\\n        vector<int>totalFishes(r*c,0);\\n        parents = vector<int>(r*c);\\n        \\n        for(int i=0;i<r*c;i++)\\n            parents[i] = i;\\n        \\n        for(int i=0;i<r;i++){\\n            for(int j=0;j<c;j++){\\n                if(!grid[i][j])\\n                    continue;\\n\\n                for(int k=0;k<4;k++){\\n                    int ni = i + dirs[k].first;\\n                    int nj = j + dirs[k].second;\\n                    if(isValid(ni,nj,grid)){\\n                        unify(ni*c+nj,i*c+j);\\n                    }\\n                }\\n            }\\n        }\\n        \\n        int ans = 0;\\n        for(int i=0;i<r;i++){\\n            for(int j=0;j<c;j++){\\n\\n                if(grid[i][j]){\\n                    int cur_parent = getAbsoluteParent(i*c+j);\\n                    totalFishes[cur_parent] += grid[i][j];\\n                    ans = max(ans,totalFishes[cur_parent]);\\n                }\\n                    \\n            }\\n        } \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3780050,
                "title": "100-faster-c-solution-using-simple-dfs",
                "content": "```\\nclass Solution {\\npublic:\\n    int m , n ;\\n    void dfs( int i , int j , vector<vector<int>>&grid , int &fish )\\n    {\\n        if( i < 0 or j < 0 or i >= m or j >= n ) return ;\\n        \\n        if(grid[i][j]==0) return ;\\n        fish += grid[i][j] ;\\n        grid[i][j] = 0 ;\\n        \\n        dfs( i , j + 1 , grid , fish ) ;\\n        dfs( i , j - 1 , grid , fish ) ;\\n        dfs( i + 1 , j , grid , fish ) ;\\n        dfs( i - 1 , j , grid , fish ) ;\\n        \\n        \\n    }\\n    int findMaxFish(vector<vector<int>>& grid) {\\n        m = grid.size() ;\\n        n = grid[0].size() ;\\n        int ans = 0 ;\\n        for( int i = 0 ; i < m ; i++ )\\n        {\\n            for( int j = 0 ; j < n ; j++ )\\n            {\\n                if(grid[i][j] != 0 )\\n                {\\n                    int temp = 0 ;\\n                    dfs( i , j , grid , temp ) ;\\n                    ans = max( ans , temp ) ;\\n                }\\n            }\\n        }\\n        \\n        \\n        return ans ;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int m , n ;\\n    void dfs( int i , int j , vector<vector<int>>&grid , int &fish )\\n    {\\n        if( i < 0 or j < 0 or i >= m or j >= n ) return ;\\n        \\n        if(grid[i][j]==0) return ;\\n        fish += grid[i][j] ;\\n        grid[i][j] = 0 ;\\n        \\n        dfs( i , j + 1 , grid , fish ) ;\\n        dfs( i , j - 1 , grid , fish ) ;\\n        dfs( i + 1 , j , grid , fish ) ;\\n        dfs( i - 1 , j , grid , fish ) ;\\n        \\n        \\n    }\\n    int findMaxFish(vector<vector<int>>& grid) {\\n        m = grid.size() ;\\n        n = grid[0].size() ;\\n        int ans = 0 ;\\n        for( int i = 0 ; i < m ; i++ )\\n        {\\n            for( int j = 0 ; j < n ; j++ )\\n            {\\n                if(grid[i][j] != 0 )\\n                {\\n                    int temp = 0 ;\\n                    dfs( i , j , grid , temp ) ;\\n                    ans = max( ans , temp ) ;\\n                }\\n            }\\n        }\\n        \\n        \\n        return ans ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3770309,
                "title": "c-solution-dfs",
                "content": "```\\nclass Solution {\\npublic:\\n    int findMaxFish(vector<vector<int>>& grid) {\\n        int maxFish = 0;\\n        for (int i = 0; i < grid.size(); i++)\\n            for (int j = 0; j < grid[0].size(); j++)\\n                if (grid[i][j] > 0)\\n                    maxFish = max(maxFish, dfs(grid, i, j));\\n        return maxFish;\\n    }\\nprivate:\\n    int dfs(vector<vector<int>>& grid, int i, int j) {\\n        if (i < 0 || i >= grid.size() ||\\n            j < 0 || j >= grid[0].size() ||\\n            grid[i][j] == 0)\\n            return 0;\\n        int fish = grid[i][j];\\n        grid[i][j] = 0;\\n        fish += dfs(grid, i + 1, j);\\n        fish += dfs(grid, i - 1, j);\\n        fish += dfs(grid, i, j + 1);\\n        fish += dfs(grid, i, j - 1);\\n        return fish;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findMaxFish(vector<vector<int>>& grid) {\\n        int maxFish = 0;\\n        for (int i = 0; i < grid.size(); i++)\\n            for (int j = 0; j < grid[0].size(); j++)\\n                if (grid[i][j] > 0)\\n                    maxFish = max(maxFish, dfs(grid, i, j));\\n        return maxFish;\\n    }\\nprivate:\\n    int dfs(vector<vector<int>>& grid, int i, int j) {\\n        if (i < 0 || i >= grid.size() ||\\n            j < 0 || j >= grid[0].size() ||\\n            grid[i][j] == 0)\\n            return 0;\\n        int fish = grid[i][j];\\n        grid[i][j] = 0;\\n        fish += dfs(grid, i + 1, j);\\n        fish += dfs(grid, i - 1, j);\\n        fish += dfs(grid, i, j + 1);\\n        fish += dfs(grid, i, j - 1);\\n        return fish;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3764213,
                "title": "simple-javascript-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number[][]} grid\\n * @return {number}\\n */\\nvar findMaxFish = function(grid) {\\n    let max = 0;\\n\\n    for(let i = 0; i < grid.length; i++) {\\n        for(let j = 0; j < grid[0].length; j++) {\\n            if(grid[i][j] === 0) continue;\\n\\n            max = Math.max(max, dfs(grid, i, j));\\n        }\\n    }\\n\\n    return max;\\n};\\n\\nconst dfs = function(grid, r, c) {\\n    if(r < 0 || r >= grid.length || c < 0 || c >= grid[0].length) return 0;\\n    if(grid[r][c] === 0) return 0;\\n\\n    let fish = grid[r][c];\\n    grid[r][c] = 0;\\n\\n    return fish + dfs(grid, r - 1, c) + dfs(grid, r, c - 1) + dfs(grid, r + 1, c) + dfs(grid, r, c + 1);\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[][]} grid\\n * @return {number}\\n */\\nvar findMaxFish = function(grid) {\\n    let max = 0;\\n\\n    for(let i = 0; i < grid.length; i++) {\\n        for(let j = 0; j < grid[0].length; j++) {\\n            if(grid[i][j] === 0) continue;\\n\\n            max = Math.max(max, dfs(grid, i, j));\\n        }\\n    }\\n\\n    return max;\\n};\\n\\nconst dfs = function(grid, r, c) {\\n    if(r < 0 || r >= grid.length || c < 0 || c >= grid[0].length) return 0;\\n    if(grid[r][c] === 0) return 0;\\n\\n    let fish = grid[r][c];\\n    grid[r][c] = 0;\\n\\n    return fish + dfs(grid, r - 1, c) + dfs(grid, r, c - 1) + dfs(grid, r + 1, c) + dfs(grid, r, c + 1);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3760200,
                "title": "simple",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n * m)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n * m)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int findMaxFish(int[][] grid) {\\n        int sum = 0;\\n\\n        for(int i = 0; i < grid.length; i++) {\\n            for(int j = 0; j < grid[i].length; j++) {\\n                if(grid[i][j] != 0) {\\n                    int res[] = new int[1];\\n                    catchFish(grid, i, j, res);\\n                    sum = Math.max(sum, res[0]);\\n                }\\n            }\\n        }\\n\\n        return sum;\\n    }\\n\\n    private void catchFish(int[][] grid, int i, int j, int[] res) {\\n        if( i < 0 || j < 0 || i >= grid.length || j >= grid[0].length || grid[i][j] == 0) {\\n            return;\\n        }\\n\\n        res[0] += grid[i][j];\\n        grid[i][j] = 0;\\n        catchFish(grid, i, j + 1, res);\\n        catchFish(grid, i, j - 1, res);\\n        catchFish(grid, i + 1, j, res);\\n        catchFish(grid, i - 1, j, res);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\n    public int findMaxFish(int[][] grid) {\\n        int sum = 0;\\n\\n        for(int i = 0; i < grid.length; i++) {\\n            for(int j = 0; j < grid[i].length; j++) {\\n                if(grid[i][j] != 0) {\\n                    int res[] = new int[1];\\n                    catchFish(grid, i, j, res);\\n                    sum = Math.max(sum, res[0]);\\n                }\\n            }\\n        }\\n\\n        return sum;\\n    }\\n\\n    private void catchFish(int[][] grid, int i, int j, int[] res) {\\n        if( i < 0 || j < 0 || i >= grid.length || j >= grid[0].length || grid[i][j] == 0) {\\n            return;\\n        }\\n\\n        res[0] += grid[i][j];\\n        grid[i][j] = 0;\\n        catchFish(grid, i, j + 1, res);\\n        catchFish(grid, i, j - 1, res);\\n        catchFish(grid, i + 1, j, res);\\n        catchFish(grid, i - 1, j, res);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3748345,
                "title": "python-c-numislands-variant-dfs",
                "content": "\\n```python []\\nclass Solution:\\n    def findMaxFish(self, grid: List[List[int]]) -> int:\\n        res = 0\\n        m, n = len(grid), len(grid[0])\\n        \\n        def dfs(i, j):\\n            if i < 0 or i >= m or j < 0 or j >= n:\\n                return 0\\n            if grid[i][j] == 0:\\n                return 0\\n\\n            val = grid[i][j]\\n            grid[i][j] = 0\\n\\n            return val + dfs(i + 1, j) + dfs(i - 1, j) + dfs(i, j + 1) + dfs(i, j - 1)\\n\\n        for i in range(m):\\n            for j in range(n):\\n                res = max(res, dfs(i, j))\\n        \\n        return res\\n```\\n```C++ []\\nclass Solution {\\npublic:\\n    int findMaxFish(vector<vector<int>>& grid) {\\n        int m = grid.size(), n = grid[0].size();\\n        int res = 0;\\n\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                res = max(res, dfs(grid, i, j));\\n            }\\n        }\\n        \\n        return res;\\n    }\\n\\n    int dfs(vector<vector<int>>& grid, int i, int j) {\\n        if (i < 0 || i >= grid.size() || j < 0 || j >= grid[0].size()) {\\n            return 0; \\n        }\\n\\n        if (grid[i][j] == 0) {\\n            return 0;\\n        }\\n\\n        int val = grid[i][j];\\n        grid[i][j] = 0;\\n\\n        return val + dfs(grid, i + 1, j) + dfs(grid, i - 1, j) + dfs(grid, i, j + 1)+ dfs(grid, i, j - 1);\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "Python"
                ],
                "code": "```python []\\nclass Solution:\\n    def findMaxFish(self, grid: List[List[int]]) -> int:\\n        res = 0\\n        m, n = len(grid), len(grid[0])\\n        \\n        def dfs(i, j):\\n            if i < 0 or i >= m or j < 0 or j >= n:\\n                return 0\\n            if grid[i][j] == 0:\\n                return 0\\n\\n            val = grid[i][j]\\n            grid[i][j] = 0\\n\\n            return val + dfs(i + 1, j) + dfs(i - 1, j) + dfs(i, j + 1) + dfs(i, j - 1)\\n\\n        for i in range(m):\\n            for j in range(n):\\n                res = max(res, dfs(i, j))\\n        \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3738696,
                "title": "typescript-solution-easy-to-undestand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n^2)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n^2)\\n\\n# Code\\n```\\nfunction findMaxFish(grid: number[][]): number {\\n    const rows: number = grid.length;\\n    const columns: number = grid[0].length;\\n    let maxResult: number = 0;\\n    let visited: boolean[][] = grid.map(row=> row.map(column=>false));\\n    \\n    function dfs(row: number, column: number): number {\\n        if (row < 0 || row >= rows || column < 0 || column >= columns)\\n            return 0;\\n        if (visited[row][column])\\n            return 0;\\n        \\n        visited[row][column] = true;\\n        if (grid[row][column] == 0)\\n            return 0;\\n\\n        let result: number = grid[row][column];\\n        result += dfs(row-1, column);\\n        result += dfs(row+1, column);\\n        result += dfs(row, column-1);\\n        result += dfs(row, column+1);\\n        return result;\\n    }\\n\\n    for(let i=0; i<rows; i++) {\\n        for(let j=0; j<columns; j++) {\\n            if(grid[i][j] == 0)\\n                continue;\\n            const count: number = dfs(i, j);\\n            maxResult = Math.max(maxResult, count);\\n        }\\n    }\\n    return maxResult;\\n\\n};\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\nfunction findMaxFish(grid: number[][]): number {\\n    const rows: number = grid.length;\\n    const columns: number = grid[0].length;\\n    let maxResult: number = 0;\\n    let visited: boolean[][] = grid.map(row=> row.map(column=>false));\\n    \\n    function dfs(row: number, column: number): number {\\n        if (row < 0 || row >= rows || column < 0 || column >= columns)\\n            return 0;\\n        if (visited[row][column])\\n            return 0;\\n        \\n        visited[row][column] = true;\\n        if (grid[row][column] == 0)\\n            return 0;\\n\\n        let result: number = grid[row][column];\\n        result += dfs(row-1, column);\\n        result += dfs(row+1, column);\\n        result += dfs(row, column-1);\\n        result += dfs(row, column+1);\\n        return result;\\n    }\\n\\n    for(let i=0; i<rows; i++) {\\n        for(let j=0; j<columns; j++) {\\n            if(grid[i][j] == 0)\\n                continue;\\n            const count: number = dfs(i, j);\\n            maxResult = Math.max(maxResult, count);\\n        }\\n    }\\n    return maxResult;\\n\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3731123,
                "title": "easy-dfs",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    void dfs(int row, int col, vector<vector<int>>& grid, vector<vector<int>>& vis, int &fish) {\\n        int n = grid.size(), m = grid[0].size(); \\n        vis[row][col] = 1;\\n        fish += grid[row][col];\\n        int r_dir[4] = {-1, 0, 1, 0};\\n        int c_dir[4] = {0, 1, 0, -1};\\n        for(int i = 0; i < 4; i++) {\\n            int r = row + r_dir[i];\\n            int c = col + c_dir[i];\\n            if(r >= 0 && r < n && c >= 0 && c < m && grid[r][c] && !vis[r][c]) {\\n                dfs(r, c, grid, vis, fish);\\n            }\\n        }\\n    }\\npublic:\\n    int findMaxFish(vector<vector<int>>& grid) {\\n        int n = grid.size(), m = grid[0].size();\\n        vector<vector<int>> vis(n, vector<int>(m, 0));\\n        int max_fish = 0;\\n        for(int i = 0; i < n; i++) {\\n            for(int j = 0; j < m; j++) {\\n                if(grid[i][j] > 0 && !vis[i][j]) {\\n                    int fish = 0;\\n                    dfs(i, j, grid, vis, fish);\\n                    max_fish = max(max_fish, fish);\\n                }\\n            }\\n        }\\n        return max_fish;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n    void dfs(int row, int col, vector<vector<int>>& grid, vector<vector<int>>& vis, int &fish) {\\n        int n = grid.size(), m = grid[0].size(); \\n        vis[row][col] = 1;\\n        fish += grid[row][col];\\n        int r_dir[4] = {-1, 0, 1, 0};\\n        int c_dir[4] = {0, 1, 0, -1};\\n        for(int i = 0; i < 4; i++) {\\n            int r = row + r_dir[i];\\n            int c = col + c_dir[i];\\n            if(r >= 0 && r < n && c >= 0 && c < m && grid[r][c] && !vis[r][c]) {\\n                dfs(r, c, grid, vis, fish);\\n            }\\n        }\\n    }\\npublic:\\n    int findMaxFish(vector<vector<int>>& grid) {\\n        int n = grid.size(), m = grid[0].size();\\n        vector<vector<int>> vis(n, vector<int>(m, 0));\\n        int max_fish = 0;\\n        for(int i = 0; i < n; i++) {\\n            for(int j = 0; j < m; j++) {\\n                if(grid[i][j] > 0 && !vis[i][j]) {\\n                    int fish = 0;\\n                    dfs(i, j, grid, vis, fish);\\n                    max_fish = max(max_fish, fish);\\n                }\\n            }\\n        }\\n        return max_fish;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3731122,
                "title": "easy-dfs",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    void dfs(int row, int col, vector<vector<int>>& grid, vector<vector<int>>& vis, int &fish) {\\n        int n = grid.size(), m = grid[0].size(); \\n        vis[row][col] = 1;\\n        fish += grid[row][col];\\n        int r_dir[4] = {-1, 0, 1, 0};\\n        int c_dir[4] = {0, 1, 0, -1};\\n        for(int i = 0; i < 4; i++) {\\n            int r = row + r_dir[i];\\n            int c = col + c_dir[i];\\n            if(r >= 0 && r < n && c >= 0 && c < m && grid[r][c] && !vis[r][c]) {\\n                dfs(r, c, grid, vis, fish);\\n            }\\n        }\\n    }\\npublic:\\n    int findMaxFish(vector<vector<int>>& grid) {\\n        int n = grid.size(), m = grid[0].size();\\n        vector<vector<int>> vis(n, vector<int>(m, 0));\\n        int max_fish = 0;\\n        for(int i = 0; i < n; i++) {\\n            for(int j = 0; j < m; j++) {\\n                if(grid[i][j] > 0 && !vis[i][j]) {\\n                    int fish = 0;\\n                    dfs(i, j, grid, vis, fish);\\n                    max_fish = max(max_fish, fish);\\n                }\\n            }\\n        }\\n        return max_fish;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n    void dfs(int row, int col, vector<vector<int>>& grid, vector<vector<int>>& vis, int &fish) {\\n        int n = grid.size(), m = grid[0].size(); \\n        vis[row][col] = 1;\\n        fish += grid[row][col];\\n        int r_dir[4] = {-1, 0, 1, 0};\\n        int c_dir[4] = {0, 1, 0, -1};\\n        for(int i = 0; i < 4; i++) {\\n            int r = row + r_dir[i];\\n            int c = col + c_dir[i];\\n            if(r >= 0 && r < n && c >= 0 && c < m && grid[r][c] && !vis[r][c]) {\\n                dfs(r, c, grid, vis, fish);\\n            }\\n        }\\n    }\\npublic:\\n    int findMaxFish(vector<vector<int>>& grid) {\\n        int n = grid.size(), m = grid[0].size();\\n        vector<vector<int>> vis(n, vector<int>(m, 0));\\n        int max_fish = 0;\\n        for(int i = 0; i < n; i++) {\\n            for(int j = 0; j < m; j++) {\\n                if(grid[i][j] > 0 && !vis[i][j]) {\\n                    int fish = 0;\\n                    dfs(i, j, grid, vis, fish);\\n                    max_fish = max(max_fish, fish);\\n                }\\n            }\\n        }\\n        return max_fish;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3720607,
                "title": "98-beat-simple-dfs-bfs-solution",
                "content": "# DFS Code:\\n```\\nclass Solution {\\npublic:\\n    int dfs(vector<vector<int>>& grid, int x, int y, vector<pair<int,int>>& dir){\\n        int currFish = grid[x][y];\\n        grid[x][y] = 0;\\n        \\n        for(auto& d: dir){\\n            int nx = x + d.first;\\n            int ny = y + d.second;\\n\\n            if(nx >= 0 && ny >= 0 && nx < grid.size() && ny < grid[0].size() && grid[nx][ny] != 0){\\n                currFish += dfs(grid, nx, ny, dir);\\n            }\\n        }\\n        \\n        return currFish;\\n    }\\n    int findMaxFish(vector<vector<int>>& grid) {\\n        vector<pair<int,int>> dir{{0,1},{1,0},{-1,0},{0,-1}};\\n        int ans = 0;\\n        for(int i = 0; i < grid.size(); i++){\\n            for(int j = 0; j < grid[0].size(); j++){\\n                if(grid[i][j] != 0){\\n                    int currFish = dfs(grid, i, j, dir);\\n                    ans = max(ans, currFish);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\n```\\n# BFS Code:\\n```\\nclass Solution {\\npublic:\\n    int findMaxFish(vector<vector<int>>& grid) {\\n        queue<pair<int,int>> q;\\n        vector<pair<int,int>> dir{{0,1},{1,0},{-1,0},{0,-1}};\\n        int ans = 0;\\n        for(int i=0; i<grid.size(); i++){\\n            for(int j=0; j<grid[0].size(); j++){\\n                if(grid[i][j]!=0){\\n                    q.push({i,j});\\n                    int currFish = 0;\\n                    while(!q.empty()){\\n                        int x = q.front().first;\\n                        int y = q.front().second;\\n                        q.pop();\\n                        currFish += grid[x][y];\\n                        grid[x][y] = 0;\\n\\n                        for(auto& d: dir){\\n                            int nx = x + d.first;\\n                            int ny = y + d.second;\\n\\n                            if(nx>=0 && ny>=0 && nx<grid.size() && ny<grid[0].size() && grid[nx][ny]!=0){\\n                                q.push({nx,ny});\\n                            }\\n                        }\\n                    }\\n                    ans = max(ans,currFish);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dfs(vector<vector<int>>& grid, int x, int y, vector<pair<int,int>>& dir){\\n        int currFish = grid[x][y];\\n        grid[x][y] = 0;\\n        \\n        for(auto& d: dir){\\n            int nx = x + d.first;\\n            int ny = y + d.second;\\n\\n            if(nx >= 0 && ny >= 0 && nx < grid.size() && ny < grid[0].size() && grid[nx][ny] != 0){\\n                currFish += dfs(grid, nx, ny, dir);\\n            }\\n        }\\n        \\n        return currFish;\\n    }\\n    int findMaxFish(vector<vector<int>>& grid) {\\n        vector<pair<int,int>> dir{{0,1},{1,0},{-1,0},{0,-1}};\\n        int ans = 0;\\n        for(int i = 0; i < grid.size(); i++){\\n            for(int j = 0; j < grid[0].size(); j++){\\n                if(grid[i][j] != 0){\\n                    int currFish = dfs(grid, i, j, dir);\\n                    ans = max(ans, currFish);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\n```\n```\\nclass Solution {\\npublic:\\n    int findMaxFish(vector<vector<int>>& grid) {\\n        queue<pair<int,int>> q;\\n        vector<pair<int,int>> dir{{0,1},{1,0},{-1,0},{0,-1}};\\n        int ans = 0;\\n        for(int i=0; i<grid.size(); i++){\\n            for(int j=0; j<grid[0].size(); j++){\\n                if(grid[i][j]!=0){\\n                    q.push({i,j});\\n                    int currFish = 0;\\n                    while(!q.empty()){\\n                        int x = q.front().first;\\n                        int y = q.front().second;\\n                        q.pop();\\n                        currFish += grid[x][y];\\n                        grid[x][y] = 0;\\n\\n                        for(auto& d: dir){\\n                            int nx = x + d.first;\\n                            int ny = y + d.second;\\n\\n                            if(nx>=0 && ny>=0 && nx<grid.size() && ny<grid[0].size() && grid[nx][ny]!=0){\\n                                q.push({nx,ny});\\n                            }\\n                        }\\n                    }\\n                    ans = max(ans,currFish);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3708698,
                "title": "easy-to-understand-optimised-dfs-without-making-any-visited-array-c",
                "content": "\\n# Complexity\\n- Time complexity:\\n$$O(n*m)$$ \\nWorst case if we had to traverse the whole grid\\n\\n- Space complexity:\\n$$O(n*m)$$ \\nSince we will be accessing the grid so that too counts otherwise constant space\\n\\n# Code\\n```\\nclass Solution {\\n    void dfs(int i, int j, int &count, vector<vector<int>>& grid){\\n        if(i<0 || j<0 || i>=grid.size() || j>=grid[0].size() || grid[i][j]==0){\\n            return;\\n        }\\n        count+=grid[i][j];\\n        grid[i][j]=0;\\n        dfs(i+1, j, count, grid);\\n        dfs(i, j+1, count, grid);\\n        dfs(i, j-1, count, grid);\\n        dfs(i-1, j, count, grid);\\n    }\\npublic:\\n    int findMaxFish(vector<vector<int>>& grid) {\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        int maxi=0;\\n        for(int i=0; i<n; i++){\\n            for(int j=0; j<m; j++){\\n                if(grid[i][j]>0){\\n                    int count=0;\\n                    dfs(i, j, count, grid);\\n                    maxi=max(maxi, count);\\n                }\\n            }\\n        }\\n        return maxi;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\n    void dfs(int i, int j, int &count, vector<vector<int>>& grid){\\n        if(i<0 || j<0 || i>=grid.size() || j>=grid[0].size() || grid[i][j]==0){\\n            return;\\n        }\\n        count+=grid[i][j];\\n        grid[i][j]=0;\\n        dfs(i+1, j, count, grid);\\n        dfs(i, j+1, count, grid);\\n        dfs(i, j-1, count, grid);\\n        dfs(i-1, j, count, grid);\\n    }\\npublic:\\n    int findMaxFish(vector<vector<int>>& grid) {\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        int maxi=0;\\n        for(int i=0; i<n; i++){\\n            for(int j=0; j<m; j++){\\n                if(grid[i][j]>0){\\n                    int count=0;\\n                    dfs(i, j, count, grid);\\n                    maxi=max(maxi, count);\\n                }\\n            }\\n        }\\n        return maxi;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3696630,
                "title": "python-8-line-and-cpp-exchange-function",
                "content": "\\n```\\nIf you don\\'t want to make the values > 0 to 0.\\n```\\n\\n```CPP []\\nclass Solution \\n{\\npublic:\\n    int dfs(vector<vector<int>>& grid, int r, int c)\\n    {\\n        if(r<0 || r>=grid.size() || c<0 || c>=grid[0].size() || grid[r][c] < 1)\\n            return 0;\\n        grid[r][c] *= -1;\\n        return abs(grid[r][c]) + dfs(grid,r,c-1) + dfs(grid,r-1,c) + dfs(grid,r,c+1) + dfs(grid,r+1,c);\\n    }\\n\\n    int findMaxFish(vector<vector<int>>& grid) \\n    {\\n        int row = grid.size(), col = grid[0].size(), sum = 0;\\n        for(int r=0; r<row; r++)\\n            for(int c=0; c<col; c++)\\n                if(grid[r][c]>0)\\n                    sum = max(sum, dfs(grid,r,c));\\n        return sum;\\n    }\\n};\\n```\\n```Python []\\nclass Solution:\\n    def findMaxFish(self, grid: List[List[int]]) -> int:\\n        def dfs(r:int, c:int) -> int:\\n            if r<0 or r>=len(grid) or c<0 or c>=len(grid[0]) or grid[r][c] < 1:\\n                return 0\\n            grid[r][c] *= -1\\n            return abs(grid[r][c]) + sum((dfs(r,c-1),dfs(r-1,c),dfs(r,c+1),dfs(r+1,c)))\\n        \\n        return max( (dfs(r,c) for r in range(len(grid)) for c in range(len(grid[0])) if grid[r][c]>0), default = 0 )\\n```\\n```\\nIf you want to make the values > 0 to 0 so badly.\\n\\nexchange in C++ 14 in utility header file.\\n\\nint a = 1, b = 2;         | Here exchange changing the value of a to b\\nint ans = exchange(a,b);  | and returning the old value of a.\\ncout << a << \" \" << b << \" \" << ans;\\n\\n        Output:\\n\\n2 2 1\\n   \\n```\\n```CPP []\\nclass Solution \\n{\\npublic:\\n    int dfs(vector<vector<int>>& grid, int r, int c)\\n    {\\n        if(r<0 || r>=grid.size() || c<0 || c>=grid[0].size() || grid[r][c] < 1)\\n            return 0;\\n        return exchange(grid[r][c], 0) + dfs(grid,r,c-1) + dfs(grid,r-1,c) + dfs(grid,r,c+1) + dfs(grid,r+1,c);\\n    }\\n\\n    int findMaxFish(vector<vector<int>>& grid) \\n    {\\n        int row = grid.size(), col = grid[0].size(), ans = 0;\\n        for(int r=0; r<row; r++)\\n            for(int c=0; c<col; c++)\\n                if(grid[r][c]>0)\\n                    ans = max(ans, dfs(grid,r,c));\\n        return ans;\\n    }\\n};\\n```\\n```Python []\\nclass Solution:\\n    def findMaxFish(self, grid: List[List[int]]) -> int:\\n        def dfs(r:int, c:int) -> int:\\n            if r<0 or r>=len(grid) or c<0 or c>=len(grid[0]) or grid[r][c] == 0:\\n                return 0\\n            grid[r][c], temp = 0, grid[r][c]\\n            return temp + sum((dfs(r,c-1),dfs(r-1,c),dfs(r,c+1),dfs(r+1,c)))\\n        \\n        return max( (dfs(r,c) for r in range(len(grid)) for c in range(len(grid[0])) if grid[r][c]>0), default = 0 )\\n```\\n\\n```\\nTime  complexity : O(mn)\\nSpace complexity : O(mn)\\n```\\n### If the post was helpful, an upvote will be appreciated.",
                "solutionTags": [
                    "C++",
                    "Python3"
                ],
                "code": "```\\nIf you don\\'t want to make the values > 0 to 0.\\n```\n```CPP []\\nclass Solution \\n{\\npublic:\\n    int dfs(vector<vector<int>>& grid, int r, int c)\\n    {\\n        if(r<0 || r>=grid.size() || c<0 || c>=grid[0].size() || grid[r][c] < 1)\\n            return 0;\\n        grid[r][c] *= -1;\\n        return abs(grid[r][c]) + dfs(grid,r,c-1) + dfs(grid,r-1,c) + dfs(grid,r,c+1) + dfs(grid,r+1,c);\\n    }\\n\\n    int findMaxFish(vector<vector<int>>& grid) \\n    {\\n        int row = grid.size(), col = grid[0].size(), sum = 0;\\n        for(int r=0; r<row; r++)\\n            for(int c=0; c<col; c++)\\n                if(grid[r][c]>0)\\n                    sum = max(sum, dfs(grid,r,c));\\n        return sum;\\n    }\\n};\\n```\n```Python []\\nclass Solution:\\n    def findMaxFish(self, grid: List[List[int]]) -> int:\\n        def dfs(r:int, c:int) -> int:\\n            if r<0 or r>=len(grid) or c<0 or c>=len(grid[0]) or grid[r][c] < 1:\\n                return 0\\n            grid[r][c] *= -1\\n            return abs(grid[r][c]) + sum((dfs(r,c-1),dfs(r-1,c),dfs(r,c+1),dfs(r+1,c)))\\n        \\n        return max( (dfs(r,c) for r in range(len(grid)) for c in range(len(grid[0])) if grid[r][c]>0), default = 0 )\\n```\n```\\nIf you want to make the values > 0 to 0 so badly.\\n\\nexchange in C++ 14 in utility header file.\\n\\nint a = 1, b = 2;         | Here exchange changing the value of a to b\\nint ans = exchange(a,b);  | and returning the old value of a.\\ncout << a << \" \" << b << \" \" << ans;\\n\\n        Output:\\n\\n2 2 1\\n   \\n```\n```CPP []\\nclass Solution \\n{\\npublic:\\n    int dfs(vector<vector<int>>& grid, int r, int c)\\n    {\\n        if(r<0 || r>=grid.size() || c<0 || c>=grid[0].size() || grid[r][c] < 1)\\n            return 0;\\n        return exchange(grid[r][c], 0) + dfs(grid,r,c-1) + dfs(grid,r-1,c) + dfs(grid,r,c+1) + dfs(grid,r+1,c);\\n    }\\n\\n    int findMaxFish(vector<vector<int>>& grid) \\n    {\\n        int row = grid.size(), col = grid[0].size(), ans = 0;\\n        for(int r=0; r<row; r++)\\n            for(int c=0; c<col; c++)\\n                if(grid[r][c]>0)\\n                    ans = max(ans, dfs(grid,r,c));\\n        return ans;\\n    }\\n};\\n```\n```Python []\\nclass Solution:\\n    def findMaxFish(self, grid: List[List[int]]) -> int:\\n        def dfs(r:int, c:int) -> int:\\n            if r<0 or r>=len(grid) or c<0 or c>=len(grid[0]) or grid[r][c] == 0:\\n                return 0\\n            grid[r][c], temp = 0, grid[r][c]\\n            return temp + sum((dfs(r,c-1),dfs(r-1,c),dfs(r,c+1),dfs(r+1,c)))\\n        \\n        return max( (dfs(r,c) for r in range(len(grid)) for c in range(len(grid[0])) if grid[r][c]>0), default = 0 )\\n```\n```\\nTime  complexity : O(mn)\\nSpace complexity : O(mn)\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3689962,
                "title": "c-simple-solution",
                "content": "# Code\\n```\\nclass Solution {\\n    int m, n, mx;\\n    vector<int> dx{0, 0, 1, -1};\\n    vector<int> dy{1, -1, 0, 0};\\npublic:\\n    int findMaxFish(vector<vector<int>>& grid) {\\n\\n        m = grid.size(), n = grid[0].size(), mx = 0;\\n        for(int i = 0; i < m; i++)  \\n            for(int j = 0; j < n; j++)\\n                if(grid[i][j])\\n                    mx = max(mx, helper(grid, i, j));\\n\\n        return mx;\\n    }\\n\\n    int helper(vector<vector<int>> &grid, int i, int j)\\n    {\\n        int tmp = grid[i][j];\\n        grid[i][j] = 0;\\n\\n        for(int k = 0; k < dx.size(); k++)\\n        {\\n            int x = i + dx[k], y = j + dy[k];\\n            if(x >= 0 && y >= 0 && x < m && y < n && grid[x][y])\\n                tmp += helper(grid, x, y);\\n        }\\n\\n        return tmp;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Graph",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\n    int m, n, mx;\\n    vector<int> dx{0, 0, 1, -1};\\n    vector<int> dy{1, -1, 0, 0};\\npublic:\\n    int findMaxFish(vector<vector<int>>& grid) {\\n\\n        m = grid.size(), n = grid[0].size(), mx = 0;\\n        for(int i = 0; i < m; i++)  \\n            for(int j = 0; j < n; j++)\\n                if(grid[i][j])\\n                    mx = max(mx, helper(grid, i, j));\\n\\n        return mx;\\n    }\\n\\n    int helper(vector<vector<int>> &grid, int i, int j)\\n    {\\n        int tmp = grid[i][j];\\n        grid[i][j] = 0;\\n\\n        for(int k = 0; k < dx.size(); k++)\\n        {\\n            int x = i + dx[k], y = j + dy[k];\\n            if(x >= 0 && y >= 0 && x < m && y < n && grid[x][y])\\n                tmp += helper(grid, x, y);\\n        }\\n\\n        return tmp;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3680690,
                "title": "standard-dfs-solution",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void dfs(vector<vector<int>>&grid, int r, int c, int &count){\\n        if(r<0 || c<0 || r>=grid.size() || c>=grid[0].size() || grid[r][c]==0) return ;\\n        count+= grid[r][c];\\n        grid[r][c]=0;\\n        dfs(grid, r-1, c, count);\\n        dfs(grid, r+1, c, count);\\n        dfs(grid, r, c-1, count);\\n        dfs(grid, r, c+1, count);\\n    }\\n    int findMaxFish(vector<vector<int>>& grid) {\\n        int n  =grid.size();\\n        int m = grid[0].size();\\n        int ans = 0;\\n        for(int i=0; i<n; i++){\\n            for(int j=0; j<m; j++){\\n                if(grid[i][j]>0){\\n                    int count = 0;\\n                    dfs(grid, i, j, count);\\n                    // grid[i][j] = 0;\\n                    ans = max(ans, count);\\n                }\\n            }\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void dfs(vector<vector<int>>&grid, int r, int c, int &count){\\n        if(r<0 || c<0 || r>=grid.size() || c>=grid[0].size() || grid[r][c]==0) return ;\\n        count+= grid[r][c];\\n        grid[r][c]=0;\\n        dfs(grid, r-1, c, count);\\n        dfs(grid, r+1, c, count);\\n        dfs(grid, r, c-1, count);\\n        dfs(grid, r, c+1, count);\\n    }\\n    int findMaxFish(vector<vector<int>>& grid) {\\n        int n  =grid.size();\\n        int m = grid[0].size();\\n        int ans = 0;\\n        for(int i=0; i<n; i++){\\n            for(int j=0; j<m; j++){\\n                if(grid[i][j]>0){\\n                    int count = 0;\\n                    dfs(grid, i, j, count);\\n                    // grid[i][j] = 0;\\n                    ans = max(ans, count);\\n                }\\n            }\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3677888,
                "title": "done-with-dfs-easy-solution-c",
                "content": "# Approach\\n* First traverse the matrix by 2 for loops and check if any element of matrix is not zero then call dfs function in which we are calculating sum of connected elements.....\\n* Then we make an isvalid function in which we checked that whether the index where we traverse is valid or within the bound or not....\\n* if yes then return true else false.....\\n* Then in dfs function we add elements in sum variable if connected and make that element 0 so that we can\\'t traverse it again and then call dfs recursively if element connected or valid....\\n* conditions in dfs are:-\\n    1. first we check for row+1 and col\\n    2. second we check for row-1 and col\\n    3. third we check for row and col+1\\n    4. last we check for row and col-1\\n* in last we return sum in dfs function.....\\n* at last in findMaxFish function we take the maximum value of sum among all and return the same.........\\n\\n---\\n\\n\\n- [Time complexity: $$O(MN)$$]()\\n\\n---\\n\\n\\n- [Space complexity:$$ O(1)$$]()\\n\\n---\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isvalid(vector<vector<int>>& grid, int r, int c)\\n    {\\n        if(r>=0 && c>=0 && r<grid.size() && c<grid[0].size() && grid[r][c]!=0)\\n        {\\n            return true;\\n        }\\n        return false;\\n    }\\n    int dfs(vector<vector<int>>& grid, int i, int j, int &sum)\\n    {\\n        sum+=grid[i][j];\\n        grid[i][j]=0;\\n        if(isvalid(grid, i+1, j))\\n        {\\n            dfs(grid, i+1, j, sum);\\n        }\\n        if(isvalid(grid, i-1, j))\\n        {\\n            dfs(grid, i-1, j, sum);\\n        }\\n        if(isvalid(grid, i, j+1))\\n        {\\n            dfs(grid, i, j+1, sum);\\n        }\\n        if(isvalid(grid, i, j-1))\\n        {\\n            dfs(grid, i, j-1, sum);\\n        }\\n        return sum;\\n\\n    }\\n    int findMaxFish(vector<vector<int>>& grid) {\\n        ios::sync_with_stdio;\\n        cin.tie(0);\\n        int m=0;\\n        for(int i=0; i<grid.size(); i++)\\n        {\\n            for(int j=0; j<grid[0].size(); j++)\\n            {\\n                int sum=0;\\n                if(grid[i][j]!=0)\\n                {\\n                    int x = dfs(grid, i, j, sum);\\n                    m = max(m, x);\\n                }\\n            }\\n        }\\n        return m;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isvalid(vector<vector<int>>& grid, int r, int c)\\n    {\\n        if(r>=0 && c>=0 && r<grid.size() && c<grid[0].size() && grid[r][c]!=0)\\n        {\\n            return true;\\n        }\\n        return false;\\n    }\\n    int dfs(vector<vector<int>>& grid, int i, int j, int &sum)\\n    {\\n        sum+=grid[i][j];\\n        grid[i][j]=0;\\n        if(isvalid(grid, i+1, j))\\n        {\\n            dfs(grid, i+1, j, sum);\\n        }\\n        if(isvalid(grid, i-1, j))\\n        {\\n            dfs(grid, i-1, j, sum);\\n        }\\n        if(isvalid(grid, i, j+1))\\n        {\\n            dfs(grid, i, j+1, sum);\\n        }\\n        if(isvalid(grid, i, j-1))\\n        {\\n            dfs(grid, i, j-1, sum);\\n        }\\n        return sum;\\n\\n    }\\n    int findMaxFish(vector<vector<int>>& grid) {\\n        ios::sync_with_stdio;\\n        cin.tie(0);\\n        int m=0;\\n        for(int i=0; i<grid.size(); i++)\\n        {\\n            for(int j=0; j<grid[0].size(); j++)\\n            {\\n                int sum=0;\\n                if(grid[i][j]!=0)\\n                {\\n                    int x = dfs(grid, i, j, sum);\\n                    m = max(m, x);\\n                }\\n            }\\n        }\\n        return m;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3677816,
                "title": "faster-c-dfs-easy-solution",
                "content": "# *Complexity*\\n- *Time & Space Complexity :*\\n```\\nO(mn)\\n```\\n# Code\\n```\\nclass Solution\\n{\\nprivate:\\n    bool isValid(vector<vector<int>> &grid, vector<vector<bool>> &visit, int row, int col)\\n    {\\n        if(row >= 0 && col >= 0 && row < grid.size() && col < grid[0].size() && grid[row][col] != 0 && visit[row][col] == false)\\n        {\\n            return true;\\n        }\\n        else\\n        {\\n            return false;\\n        }\\n    }\\n    void dfs_func(vector<vector<int>> &grid, vector<vector<bool>> &visit, int row, int col, int &temp)\\n    {\\n        if(!isValid(grid, visit, row, col))\\n        {\\n            return;\\n        }\\n        else\\n        {\\n            visit[row][col] = true;\\n            temp += grid[row][col];\\n            if(isValid(grid, visit, row+1, col))\\n            {\\n                dfs_func(grid, visit, row+1, col, temp);\\n            }\\n            if(isValid(grid, visit, row-1, col))\\n            {\\n                dfs_func(grid, visit, row-1, col, temp);\\n            }\\n            if(isValid(grid, visit, row, col+1))\\n            {\\n                dfs_func(grid, visit, row, col+1, temp);\\n            }\\n            if(isValid(grid, visit, row, col-1))\\n            {\\n                dfs_func(grid, visit, row, col-1, temp);\\n            }\\n            return;\\n        }\\n    }\\npublic:\\n    int findMaxFish(vector<vector<int>>& grid) \\n    {\\n        int temp = 0, count = 0;\\n        vector<vector<bool>> visit(grid.size(), vector<bool> (grid[0].size(), false));\\n        for(int i = 0; i < grid.size(); i++)\\n        {\\n            for(int j = 0; j < grid[0].size(); j++)\\n            {\\n                if(grid[i][j] > 0 && visit[i][j] == false)\\n                {\\n                    temp = 0;\\n                    dfs_func(grid, visit, i, j, temp);\\n                    count = max(temp, count);\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```\\n***DO UPVOTE!*** \\uD83D\\uDE03\\n",
                "solutionTags": [
                    "C++",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nO(mn)\\n```\n```\\nclass Solution\\n{\\nprivate:\\n    bool isValid(vector<vector<int>> &grid, vector<vector<bool>> &visit, int row, int col)\\n    {\\n        if(row >= 0 && col >= 0 && row < grid.size() && col < grid[0].size() && grid[row][col] != 0 && visit[row][col] == false)\\n        {\\n            return true;\\n        }\\n        else\\n        {\\n            return false;\\n        }\\n    }\\n    void dfs_func(vector<vector<int>> &grid, vector<vector<bool>> &visit, int row, int col, int &temp)\\n    {\\n        if(!isValid(grid, visit, row, col))\\n        {\\n            return;\\n        }\\n        else\\n        {\\n            visit[row][col] = true;\\n            temp += grid[row][col];\\n            if(isValid(grid, visit, row+1, col))\\n            {\\n                dfs_func(grid, visit, row+1, col, temp);\\n            }\\n            if(isValid(grid, visit, row-1, col))\\n            {\\n                dfs_func(grid, visit, row-1, col, temp);\\n            }\\n            if(isValid(grid, visit, row, col+1))\\n            {\\n                dfs_func(grid, visit, row, col+1, temp);\\n            }\\n            if(isValid(grid, visit, row, col-1))\\n            {\\n                dfs_func(grid, visit, row, col-1, temp);\\n            }\\n            return;\\n        }\\n    }\\npublic:\\n    int findMaxFish(vector<vector<int>>& grid) \\n    {\\n        int temp = 0, count = 0;\\n        vector<vector<bool>> visit(grid.size(), vector<bool> (grid[0].size(), false));\\n        for(int i = 0; i < grid.size(); i++)\\n        {\\n            for(int j = 0; j < grid[0].size(); j++)\\n            {\\n                if(grid[i][j] > 0 && visit[i][j] == false)\\n                {\\n                    temp = 0;\\n                    dfs_func(grid, visit, i, j, temp);\\n                    count = max(temp, count);\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3669574,
                "title": "simple-bfs-solution-in-c",
                "content": "# Code\\n```\\nclass Solution {\\nprivate:\\n    void bfs(int i,int j,int &fishCaught,vector<vector<bool>>& visited,vector<vector<int>>& grid){\\n        queue<pair<int,int>> q;\\n\\n        int newRows[]={-1,0,1,0};\\n        int newCols[]={0,1,0,-1};\\n        q.push({i,j});\\n        visited[i][j]=true;\\n\\n        // bfs to go in 4 direction \\n        while(!q.empty()){\\n\\n            int row = q.front().first;\\n            int col= q.front().second;\\n            q.pop();\\n            // Catching fish \\uD83D\\uDC1F\\uD83D\\uDC20\\uD83E\\uDD88\\uD83D\\uDC21\\n            fishCaught=fishCaught+grid[row][col];\\n\\n            for(int i=0;i<4;i++){\\n                int nRow = newRows[i] + row;\\n                int nCol = newCols[i] + col;\\n\\n                if(nRow>=0 && nRow<grid.size() && nCol>=0 && nCol<grid[0].size() && !visited[nRow][nCol] && grid[nRow][nCol]){\\n                    q.push({nRow,nCol});\\n                    visited[nRow][nCol]=true;\\n                }\\n            }\\n        }\\n    }\\n\\npublic:\\n    int findMaxFish(vector<vector<int>>& grid) {\\n        int rows = grid.size();\\n        int cols = grid[0].size();\\n        int maxFish=0;\\n        int fishCaught=0;\\n        vector<vector<bool>> visited(rows,vector<bool>(cols,false));\\n        \\n        for(int i=0;i<rows;i++){\\n            for(int j=0;j<cols;j++){\\n                // check if there are any fishes \\n                // if not visited go fishing\\n                if(!visited[i][j] && grid[i][j]>0){\\n\\n                    bfs(i,j,fishCaught,visited,grid);\\n                    // to find max fishes a fisherman can catch\\n                    maxFish=max(fishCaught,maxFish);\\n                    fishCaught=0;\\n                }\\n            }\\n        }\\n        return maxFish;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Breadth-First Search",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    void bfs(int i,int j,int &fishCaught,vector<vector<bool>>& visited,vector<vector<int>>& grid){\\n        queue<pair<int,int>> q;\\n\\n        int newRows[]={-1,0,1,0};\\n        int newCols[]={0,1,0,-1};\\n        q.push({i,j});\\n        visited[i][j]=true;\\n\\n        // bfs to go in 4 direction \\n        while(!q.empty()){\\n\\n            int row = q.front().first;\\n            int col= q.front().second;\\n            q.pop();\\n            // Catching fish \\uD83D\\uDC1F\\uD83D\\uDC20\\uD83E\\uDD88\\uD83D\\uDC21\\n            fishCaught=fishCaught+grid[row][col];\\n\\n            for(int i=0;i<4;i++){\\n                int nRow = newRows[i] + row;\\n                int nCol = newCols[i] + col;\\n\\n                if(nRow>=0 && nRow<grid.size() && nCol>=0 && nCol<grid[0].size() && !visited[nRow][nCol] && grid[nRow][nCol]){\\n                    q.push({nRow,nCol});\\n                    visited[nRow][nCol]=true;\\n                }\\n            }\\n        }\\n    }\\n\\npublic:\\n    int findMaxFish(vector<vector<int>>& grid) {\\n        int rows = grid.size();\\n        int cols = grid[0].size();\\n        int maxFish=0;\\n        int fishCaught=0;\\n        vector<vector<bool>> visited(rows,vector<bool>(cols,false));\\n        \\n        for(int i=0;i<rows;i++){\\n            for(int j=0;j<cols;j++){\\n                // check if there are any fishes \\n                // if not visited go fishing\\n                if(!visited[i][j] && grid[i][j]>0){\\n\\n                    bfs(i,j,fishCaught,visited,grid);\\n                    // to find max fishes a fisherman can catch\\n                    maxFish=max(fishCaught,maxFish);\\n                    fishCaught=0;\\n                }\\n            }\\n        }\\n        return maxFish;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3668537,
                "title": "unionfind",
                "content": "```\\nclass Solution {\\n    public int findMaxFish(int[][] grid) {\\n        int ans = 0;\\n        int m = grid.length, n = grid[0].length;\\n        int[][] dirs = new int[][]{{1, 0}, {-1, 0}, {0, 1}, {0, -1}};\\n        UnionFind dsu = new UnionFind(grid);\\n\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (grid[i][j] == 0) continue;\\n                \\n                for (int[] dir : dirs) {\\n                    int x = i + dir[0], y = j + dir[1];\\n                    if (x < 0 || x >= m || y < 0 || y >= n || grid[x][y] == 0)\\n                        continue;\\n                    dsu.union(i, j, x, y);\\n                }\\n            }\\n        }\\n\\n        for (int i = 0; i < m * n; i++) \\n            if (dsu.id[i] == i) ans = Math.max(ans, dsu.sum[i]);\\n\\n        return ans;\\n    }\\n}\\n\\nclass UnionFind {\\n    int[] id, sum, rank;\\n    int m, n;\\n\\n    public UnionFind(int[][] grid) {\\n        this.m = grid.length;\\n        this.n = grid[0].length;\\n        id = new int[m*n];\\n        sum = new int[m*n];\\n        rank = new int[m*n];\\n        for (int i = 0; i < m*n; i++) {\\n            id[i] = i; \\n            rank[i] = 1;\\n        }\\n        \\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) \\n                sum[i * n + j] = grid[i][j];\\n        }\\n    }\\n\\n    public int find(int x) {\\n        int root = x;\\n        while (id[root] != root)\\n            root = id[root];\\n\\n        return root;\\n    }\\n\\n    public void union(int i, int j, int x, int y) {\\n        int rootX = find(i * n + j), rootY = find(x * n + y);\\n        if (rootX == rootY) return;\\n\\n        if (rank[rootX] >= rank[rootY]) {\\n            rank[rootX] += rank[rootY];\\n            rank[rootY] = 0;\\n            id[rootY] = rootX;\\n            sum[rootX] += sum[rootY];\\n        } else {\\n            rank[rootY] += rank[rootX];\\n            rank[rootX] = 0;\\n            id[rootX] = rootY;\\n            sum[rootY] += sum[rootX];\\n        }\\n \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Union Find"
                ],
                "code": "```\\nclass Solution {\\n    public int findMaxFish(int[][] grid) {\\n        int ans = 0;\\n        int m = grid.length, n = grid[0].length;\\n        int[][] dirs = new int[][]{{1, 0}, {-1, 0}, {0, 1}, {0, -1}};\\n        UnionFind dsu = new UnionFind(grid);\\n\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (grid[i][j] == 0) continue;\\n                \\n                for (int[] dir : dirs) {\\n                    int x = i + dir[0], y = j + dir[1];\\n                    if (x < 0 || x >= m || y < 0 || y >= n || grid[x][y] == 0)\\n                        continue;\\n                    dsu.union(i, j, x, y);\\n                }\\n            }\\n        }\\n\\n        for (int i = 0; i < m * n; i++) \\n            if (dsu.id[i] == i) ans = Math.max(ans, dsu.sum[i]);\\n\\n        return ans;\\n    }\\n}\\n\\nclass UnionFind {\\n    int[] id, sum, rank;\\n    int m, n;\\n\\n    public UnionFind(int[][] grid) {\\n        this.m = grid.length;\\n        this.n = grid[0].length;\\n        id = new int[m*n];\\n        sum = new int[m*n];\\n        rank = new int[m*n];\\n        for (int i = 0; i < m*n; i++) {\\n            id[i] = i; \\n            rank[i] = 1;\\n        }\\n        \\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) \\n                sum[i * n + j] = grid[i][j];\\n        }\\n    }\\n\\n    public int find(int x) {\\n        int root = x;\\n        while (id[root] != root)\\n            root = id[root];\\n\\n        return root;\\n    }\\n\\n    public void union(int i, int j, int x, int y) {\\n        int rootX = find(i * n + j), rootY = find(x * n + y);\\n        if (rootX == rootY) return;\\n\\n        if (rank[rootX] >= rank[rootY]) {\\n            rank[rootX] += rank[rootY];\\n            rank[rootY] = 0;\\n            id[rootY] = rootX;\\n            sum[rootX] += sum[rootY];\\n        } else {\\n            rank[rootY] += rank[rootX];\\n            rank[rootX] = 0;\\n            id[rootX] = rootY;\\n            sum[rootY] += sum[rootX];\\n        }\\n \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3667002,
                "title": "c-easy-solution",
                "content": "##### Solution 1: Depth First Search\\n```\\npublic class Solution {\\n    public int FindMaxFish(int[][] grid) {\\n        var max_fish = 0;\\n        for(int row = 0; row < grid.GetLength(0); row++) {\\n            for(int col = 0; col < grid[row].Length; col++) {\\n                if(grid[row][col] != 0)\\n                    max_fish = Math.Max(max_fish, DFS(grid, row, col));\\n            }\\n        }\\n\\n        return max_fish;\\n    }\\n\\n    private int DFS(int[][] grid, int row, int col) {\\n        if(row < 0 || col < 0 || row >= grid.GetLength(0) || col >= grid[row].Length || grid[row][col] == 0)\\n            return 0;\\n\\n        var fish = grid[row][col];\\n        grid[row][col] = 0;\\n\\n        fish += DFS(grid, row + 1, col);\\n        fish += DFS(grid, row - 1, col);\\n        fish += DFS(grid, row, col + 1);\\n        fish += DFS(grid, row, col - 1);\\n\\n        return fish;\\n    }\\n}\\n```\\n\\n##### Solution 2: Union Find\\n```\\n\\npublic class Solution {\\n    int[] rank;\\n    int[] parent;\\n    \\n    public int FindMaxFish(int[][] grid) {\\n        var max_fish = 0;\\n        var rowCount = grid.GetLength(0);\\n        var columnCount = grid[0].Length;\\n\\n        rank = new int[rowCount * columnCount];\\n        parent = new int[rowCount * columnCount];\\n        \\n        for(int row =  0; row < rowCount; row++) {\\n            for(int col = 0; col < columnCount; col++) {\\n                var idx = row * columnCount + col;\\n                parent[idx] = idx;\\n                rank[idx] = grid[row][col];\\n                max_fish = Math.Max(max_fish, rank[idx]);\\n            }\\n        }\\n\\n        for (int row = 0; row < rowCount; row++) {\\n            for (int col = 0; col < columnCount; col++) {\\n                if (grid[row][col] != 0) {\\n                    var idx = row * columnCount + col;\\n                    if(row < rowCount - 1 && grid[row + 1][col] != 0)\\n                        max_fish = Math.Max(max_fish, Union(idx, (row + 1) * columnCount + col));\\n\\n                    if(col < columnCount - 1 && grid[row][col + 1] != 0)\\n                        max_fish = Math.Max(max_fish, Union(idx, row * columnCount + (col + 1)));\\n                }\\n            }\\n        }\\n\\n        return max_fish;\\n    }\\n\\n    private int FindParent(int node) {\\n        if (parent[node] == node)\\n            return parent[node];\\n\\n        parent[node] = FindParent(parent[node]);\\n        return parent[node];\\n    }\\n\\n    private int Union(int node1, int node2) {\\n        var parent1 = FindParent(node1);\\n        var parent2 = FindParent(node2);\\n\\n        if(parent1 != parent2) {\\n            if (parent1 < parent2) {\\n                rank[parent1] += rank[parent2];\\n                parent[parent2] = parent1;\\n                return rank[parent1];\\n            }\\n            else {\\n                rank[parent2] += rank[parent1];\\n                parent[parent1] = parent2;\\n                return rank[parent2];\\n            }\\n        }\\n\\n        return 0;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#",
                    "Depth-First Search",
                    "Union Find"
                ],
                "code": "```\\npublic class Solution {\\n    public int FindMaxFish(int[][] grid) {\\n        var max_fish = 0;\\n        for(int row = 0; row < grid.GetLength(0); row++) {\\n            for(int col = 0; col < grid[row].Length; col++) {\\n                if(grid[row][col] != 0)\\n                    max_fish = Math.Max(max_fish, DFS(grid, row, col));\\n            }\\n        }\\n\\n        return max_fish;\\n    }\\n\\n    private int DFS(int[][] grid, int row, int col) {\\n        if(row < 0 || col < 0 || row >= grid.GetLength(0) || col >= grid[row].Length || grid[row][col] == 0)\\n            return 0;\\n\\n        var fish = grid[row][col];\\n        grid[row][col] = 0;\\n\\n        fish += DFS(grid, row + 1, col);\\n        fish += DFS(grid, row - 1, col);\\n        fish += DFS(grid, row, col + 1);\\n        fish += DFS(grid, row, col - 1);\\n\\n        return fish;\\n    }\\n}\\n```\n```\\n\\npublic class Solution {\\n    int[] rank;\\n    int[] parent;\\n    \\n    public int FindMaxFish(int[][] grid) {\\n        var max_fish = 0;\\n        var rowCount = grid.GetLength(0);\\n        var columnCount = grid[0].Length;\\n\\n        rank = new int[rowCount * columnCount];\\n        parent = new int[rowCount * columnCount];\\n        \\n        for(int row =  0; row < rowCount; row++) {\\n            for(int col = 0; col < columnCount; col++) {\\n                var idx = row * columnCount + col;\\n                parent[idx] = idx;\\n                rank[idx] = grid[row][col];\\n                max_fish = Math.Max(max_fish, rank[idx]);\\n            }\\n        }\\n\\n        for (int row = 0; row < rowCount; row++) {\\n            for (int col = 0; col < columnCount; col++) {\\n                if (grid[row][col] != 0) {\\n                    var idx = row * columnCount + col;\\n                    if(row < rowCount - 1 && grid[row + 1][col] != 0)\\n                        max_fish = Math.Max(max_fish, Union(idx, (row + 1) * columnCount + col));\\n\\n                    if(col < columnCount - 1 && grid[row][col + 1] != 0)\\n                        max_fish = Math.Max(max_fish, Union(idx, row * columnCount + (col + 1)));\\n                }\\n            }\\n        }\\n\\n        return max_fish;\\n    }\\n\\n    private int FindParent(int node) {\\n        if (parent[node] == node)\\n            return parent[node];\\n\\n        parent[node] = FindParent(parent[node]);\\n        return parent[node];\\n    }\\n\\n    private int Union(int node1, int node2) {\\n        var parent1 = FindParent(node1);\\n        var parent2 = FindParent(node2);\\n\\n        if(parent1 != parent2) {\\n            if (parent1 < parent2) {\\n                rank[parent1] += rank[parent2];\\n                parent[parent2] = parent1;\\n                return rank[parent1];\\n            }\\n            else {\\n                rank[parent2] += rank[parent1];\\n                parent[parent1] = parent2;\\n                return rank[parent2];\\n            }\\n        }\\n\\n        return 0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3665865,
                "title": "c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution \\n{\\npublic:\\n    void dfs(vector<vector<int>> &grid,int x,int y,int *curr)\\n    {\\n        if(x<0 || x>=grid.size() || y<0 || y>=grid[0].size() || grid[x][y]==0)\\n        {\\n            return;\\n        }\\n\\n        *curr+=grid[x][y];\\n        grid[x][y]=0;\\n\\n        dfs(grid,x+1,y,curr);\\n        dfs(grid,x-1,y,curr);\\n        dfs(grid,x,y+1,curr);\\n        dfs(grid,x,y-1,curr);\\n    }\\n\\n    int findMaxFish(vector<vector<int>>& grid) \\n    {\\n        int ans;\\n        ans=0;\\n\\n        for(int i=0;i<grid.size();i++)\\n        {\\n            for(int j=0;j<grid[0].size();j++)\\n            {\\n                if(grid[i][j])\\n                {\\n                    int curr=0;\\n                    dfs(grid,i,j,&curr);\\n                    ans=max(ans,curr);\\n                }\\n            }\\n        }    \\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution \\n{\\npublic:\\n    void dfs(vector<vector<int>> &grid,int x,int y,int *curr)\\n    {\\n        if(x<0 || x>=grid.size() || y<0 || y>=grid[0].size() || grid[x][y]==0)\\n        {\\n            return;\\n        }\\n\\n        *curr+=grid[x][y];\\n        grid[x][y]=0;\\n\\n        dfs(grid,x+1,y,curr);\\n        dfs(grid,x-1,y,curr);\\n        dfs(grid,x,y+1,curr);\\n        dfs(grid,x,y-1,curr);\\n    }\\n\\n    int findMaxFish(vector<vector<int>>& grid) \\n    {\\n        int ans;\\n        ans=0;\\n\\n        for(int i=0;i<grid.size();i++)\\n        {\\n            for(int j=0;j<grid[0].size();j++)\\n            {\\n                if(grid[i][j])\\n                {\\n                    int curr=0;\\n                    dfs(grid,i,j,&curr);\\n                    ans=max(ans,curr);\\n                }\\n            }\\n        }    \\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3663430,
                "title": "dfs-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void dfs(int r , int c , vector<vector<int>>& grid , vector<vector<int>>& vis , vector<int> delRow , vector<int> delCol , int m , int n , int& sum){\\n        sum += grid[r][c];\\n        vis[r][c] = 1;\\n\\n        for (int i=0 ; i<4 ; i++){\\n            int nr = r + delRow[i];\\n            int nc = c + delCol[i];\\n\\n            if (nr>=0 && nr<m && nc>=0 && nc<n && !vis[nr][nc] && grid[nr][nc]>0){\\n                dfs(nr , nc , grid, vis , delRow , delCol , m , n , sum);\\n            }\\n        }\\n    }\\n\\n    int findMaxFish(vector<vector<int>>& grid) {\\n        int maxi=-1e9;\\n\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        vector<vector<int>> vis(m , vector<int> (n , 0));\\n        vector<int> delRow = {-1 , 0 , 1 , 0};\\n        vector<int> delCol = {0 , 1 , 0 , -1};\\n\\n        for (int i=0 ; i<m ; i++){\\n            for (int j=0 ; j<n ; j++){\\n                int sum = 0;\\n                if (!vis[i][j] && grid[i][j]>0){\\n                    dfs(i , j , grid , vis , delRow , delCol , m , n , sum);\\n                    maxi = max(maxi , sum);\\n                }\\n            }\\n        }\\n        if (maxi < 0)\\n            return 0;\\n            \\n        return maxi;    \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void dfs(int r , int c , vector<vector<int>>& grid , vector<vector<int>>& vis , vector<int> delRow , vector<int> delCol , int m , int n , int& sum){\\n        sum += grid[r][c];\\n        vis[r][c] = 1;\\n\\n        for (int i=0 ; i<4 ; i++){\\n            int nr = r + delRow[i];\\n            int nc = c + delCol[i];\\n\\n            if (nr>=0 && nr<m && nc>=0 && nc<n && !vis[nr][nc] && grid[nr][nc]>0){\\n                dfs(nr , nc , grid, vis , delRow , delCol , m , n , sum);\\n            }\\n        }\\n    }\\n\\n    int findMaxFish(vector<vector<int>>& grid) {\\n        int maxi=-1e9;\\n\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        vector<vector<int>> vis(m , vector<int> (n , 0));\\n        vector<int> delRow = {-1 , 0 , 1 , 0};\\n        vector<int> delCol = {0 , 1 , 0 , -1};\\n\\n        for (int i=0 ; i<m ; i++){\\n            for (int j=0 ; j<n ; j++){\\n                int sum = 0;\\n                if (!vis[i][j] && grid[i][j]>0){\\n                    dfs(i , j , grid , vis , delRow , delCol , m , n , sum);\\n                    maxi = max(maxi , sum);\\n                }\\n            }\\n        }\\n        if (maxi < 0)\\n            return 0;\\n            \\n        return maxi;    \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3662617,
                "title": "recusion-method",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n   recursion approach \\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(M*N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n  static int sum;\\n    public static void util(int grid[][],int row,int col){\\n\\n        if(row<0 ||col<0||row>=grid.length||col>=grid[0].length||grid[row][col]==0){\\n            return ;\\n        }\\n        sum+=grid[row][col];\\n        grid[row][col]=0;\\n       //checking fishes all four direction of grid\\n        util(grid,row+1,col);\\n        util(grid,row-1,col);\\n        util(grid,row,col+1);\\n        util(grid,row,col-1);\\n    }\\n    public int findMaxFish(int[][] grid) {\\n        int  max=0;\\n       \\n        for(int i=0;i<grid.length;i++){\\n            for(int j=0;j<grid[0].length;j++){\\n                if(grid[i][j]!=0){\\n                    this.sum=0;\\n                    util(grid,i,j);\\n                    max=Math.max(max,this.sum);\\n                }\\n            }\\n        }\\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n  static int sum;\\n    public static void util(int grid[][],int row,int col){\\n\\n        if(row<0 ||col<0||row>=grid.length||col>=grid[0].length||grid[row][col]==0){\\n            return ;\\n        }\\n        sum+=grid[row][col];\\n        grid[row][col]=0;\\n       //checking fishes all four direction of grid\\n        util(grid,row+1,col);\\n        util(grid,row-1,col);\\n        util(grid,row,col+1);\\n        util(grid,row,col-1);\\n    }\\n    public int findMaxFish(int[][] grid) {\\n        int  max=0;\\n       \\n        for(int i=0;i<grid.length;i++){\\n            for(int j=0;j<grid[0].length;j++){\\n                if(grid[i][j]!=0){\\n                    this.sum=0;\\n                    util(grid,i,j);\\n                    max=Math.max(max,this.sum);\\n                }\\n            }\\n        }\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3661397,
                "title": "bfs-dfs-both-java-code",
                "content": "class pair{\\n    int first;\\n    int second;\\n    pair(int first,int second){\\n        this.first=first;\\n        this.second=second;\\n    }\\n}\\nclass Solution {\\n    public int findMaxFish(int[][] grid) {\\n        int n=grid.length;\\n        int m=grid[0].length;\\n        int[][] vis=new int[n][m];\\n        int max=Integer.MIN_VALUE;\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(grid[i][j]!=0){\\n                    max=Math.max(bfs(i,j,grid,vis),max);\\n                }\\n            }\\n        }\\n        if(max>=0){\\n             return max;\\n        }\\n        return 0;\\n    }\\n    // public int dfs(int i,int j,int[][] grid,int[][] vis){\\n    //     if(i>=0 && j>=0 && i<grid.length && j<grid[0].length && grid[i][j]!=0 && vis[i][j]==0){\\n    //         vis[i][j]=1;\\n    //         return grid[i][j]+dfs(i+1,j,grid,vis)+dfs(i,j+1,grid,vis)+dfs(i-1,j,grid,vis)+dfs(i,j-1,grid,vis);\\n    //     }\\n    //     return 0;\\n    //     }\\n    public int bfs(int i,int j,int[][] grid,int[][]vis){\\n        vis[i][j]=1;\\n        Queue<pair> q=new LinkedList<>();\\n        int sum=grid[i][j];\\n        q.add(new pair(i,j));\\n        int dir[]={0,-1,0,1,0};\\n        while(!q.isEmpty()){\\n            int x=q.peek().first;\\n            int y=q.peek().second;\\n            q.remove();\\n            for(int k=0;k<4;k++){\\n                int nrow=x+dir[k];\\n                int ncol=y+dir[k+1];\\n            if(nrow>=0 && ncol>=0 && nrow<grid.length && ncol<grid[0].length && grid[nrow][ncol]!=0 && vis[nrow][ncol]==0){\\n                vis[nrow][ncol]=1;\\n                sum+=grid[nrow][ncol];\\n                q.add(new pair(nrow,ncol));\\n            }\\n            }\\n        }\\n        return sum;\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Matrix"
                ],
                "code": "class Solution {\\n    public int findMaxFish(int[][] grid) {\\n        int n=grid.length;\\n        int m=grid[0].length;\\n        int[][] vis=new int[n][m];\\n        int max=Integer.MIN_VALUE;\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(grid[i][j]!=0){\\n                    max=Math.max(bfs(i,j,grid,vis),max);\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 3660334,
                "title": "simulated-c-dsu-dfs",
                "content": "\\n# Complexity\\n- Time complexity: $$O(m*n * m * n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(m*n + m*n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int dfs(int i, int j, vector<vector<bool>>&visited, vector<vector<int>>&grid)\\n    {\\n        int ans=grid[i][j];\\n        visited[i][j]=true;\\n        if(i+1<grid.size() && !visited[i+1][j] && grid[i+1][j]!=0) ans = ans + dfs(i+1,j,visited,grid);\\n        if(j+1<grid[0].size() && !visited[i][j+1] && grid[i][j+1]!=0) ans = ans + dfs(i,j+1,visited,grid);\\n        if(i-1>=0 && !visited[i-1][j] && grid[i-1][j]!=0) ans = ans + dfs(i-1,j,visited,grid);\\n        if(j-1>=0 && !visited[i][j-1] && grid[i][j-1]!=0) ans = ans + dfs(i,j-1,visited,grid);\\n        return ans;\\n\\n    }\\n    int findMaxFish(vector<vector<int>>& grid) \\n    {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        vector<vector<bool>>visited(m,vector<bool>(n,false));\\n        int ans=0;\\n        for(int i =0;i<m;i++)\\n        {\\n            for(int j =0;j<n;j++)\\n            {\\n                if(!visited[i][j] && grid[i][j]!=0)\\n                {\\n                    ans=max(ans,dfs(i,j,visited,grid));\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n\\n\\n# Complexity\\n- Time complexity: $$O(m*n *)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(m*n )$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findparent(int node, vector<pair<int,int>>&parent)\\n    {\\n        if(node==parent[node].first) return node;\\n        return parent[node].first=findparent(parent[node].first,parent);\\n    }\\n    void Union(int u, int v, vector<pair<int,int>>&parent, vector<int>&rank)\\n    {\\n        int pu = findparent(u,parent);\\n        int pv = findparent(v, parent);\\n        if(pu==pv) return;\\n        else if(rank[pu]<rank[pv]) \\n        {\\n            parent[pu].first = pv;\\n            parent[pv].second +=parent[pu].second;\\n        }\\n        else if(rank[pv]<rank[pu]) \\n        {\\n            parent[pv].first =pu;\\n            parent[pu].second +=parent[pv].second;\\n        }\\n        else\\n        {\\n            parent[pv].first=pu;\\n            parent[pu].second +=parent[pv].second;\\n            rank[pu]++;\\n        }\\n    }\\n    bool isvalid(int i, int j, int m, int n)\\n    {\\n        if(i>=0 && i<m && j>=0 && j<n) return true;\\n        return false;\\n    }\\n    int findMaxFish(vector<vector<int>>& grid) \\n    {\\n         std::ios_base::sync_with_stdio(false);\\n        cin.tie(NULL);\\n        cout.tie(NULL);\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        vector<pair<int,int>>parent(m*n);\\n        vector<int>rank(m*n,0);\\n        for(int i =0;i<(m*n);i++)\\n        {\\n            int a = i/n;\\n            int b = i%n;\\n            parent[i]={i,grid[a][b]};\\n        }\\n        for(int a=0;a<(m*n);a++)\\n        {\\n            int i  = a/n;\\n            int j = a%n;\\n            if(grid[i][j]!=0)\\n            {\\n                if(isvalid(i+1,j,m,n) && grid[i+1][j]!=0)\\n                {\\n                    int b = (i+1)*n+j;\\n                    Union(a,b,parent, rank);\\n                }\\n                if(isvalid(i-1,j,m,n) && grid[i-1][j]!=0)\\n                {\\n                    int b = (i-1)*n+j;\\n                    Union(a,b,parent, rank);\\n                }\\n                if(isvalid(i,j+1,m,n) && grid[i][j+1]!=0)\\n                {\\n                    int b = (i)*n+(j+1);\\n                    Union(a,b,parent, rank);\\n                }\\n                if(isvalid(i,j-1,m,n) && grid[i][j-1]!=0)\\n                {\\n                    int b = (i)*n+(j-1);\\n                    Union(a,b,parent, rank);\\n                }\\n            }\\n        }\\n        int ans=0;\\n        for(int i =0;i<parent.size();i++)\\n        {\\n            ans=max(ans,parent[i].second);\\n        }\\n        return ans;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search",
                    "Union Find"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dfs(int i, int j, vector<vector<bool>>&visited, vector<vector<int>>&grid)\\n    {\\n        int ans=grid[i][j];\\n        visited[i][j]=true;\\n        if(i+1<grid.size() && !visited[i+1][j] && grid[i+1][j]!=0) ans = ans + dfs(i+1,j,visited,grid);\\n        if(j+1<grid[0].size() && !visited[i][j+1] && grid[i][j+1]!=0) ans = ans + dfs(i,j+1,visited,grid);\\n        if(i-1>=0 && !visited[i-1][j] && grid[i-1][j]!=0) ans = ans + dfs(i-1,j,visited,grid);\\n        if(j-1>=0 && !visited[i][j-1] && grid[i][j-1]!=0) ans = ans + dfs(i,j-1,visited,grid);\\n        return ans;\\n\\n    }\\n    int findMaxFish(vector<vector<int>>& grid) \\n    {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        vector<vector<bool>>visited(m,vector<bool>(n,false));\\n        int ans=0;\\n        for(int i =0;i<m;i++)\\n        {\\n            for(int j =0;j<n;j++)\\n            {\\n                if(!visited[i][j] && grid[i][j]!=0)\\n                {\\n                    ans=max(ans,dfs(i,j,visited,grid));\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int findparent(int node, vector<pair<int,int>>&parent)\\n    {\\n        if(node==parent[node].first) return node;\\n        return parent[node].first=findparent(parent[node].first,parent);\\n    }\\n    void Union(int u, int v, vector<pair<int,int>>&parent, vector<int>&rank)\\n    {\\n        int pu = findparent(u,parent);\\n        int pv = findparent(v, parent);\\n        if(pu==pv) return;\\n        else if(rank[pu]<rank[pv]) \\n        {\\n            parent[pu].first = pv;\\n            parent[pv].second +=parent[pu].second;\\n        }\\n        else if(rank[pv]<rank[pu]) \\n        {\\n            parent[pv].first =pu;\\n            parent[pu].second +=parent[pv].second;\\n        }\\n        else\\n        {\\n            parent[pv].first=pu;\\n            parent[pu].second +=parent[pv].second;\\n            rank[pu]++;\\n        }\\n    }\\n    bool isvalid(int i, int j, int m, int n)\\n    {\\n        if(i>=0 && i<m && j>=0 && j<n) return true;\\n        return false;\\n    }\\n    int findMaxFish(vector<vector<int>>& grid) \\n    {\\n         std::ios_base::sync_with_stdio(false);\\n        cin.tie(NULL);\\n        cout.tie(NULL);\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        vector<pair<int,int>>parent(m*n);\\n        vector<int>rank(m*n,0);\\n        for(int i =0;i<(m*n);i++)\\n        {\\n            int a = i/n;\\n            int b = i%n;\\n            parent[i]={i,grid[a][b]};\\n        }\\n        for(int a=0;a<(m*n);a++)\\n        {\\n            int i  = a/n;\\n            int j = a%n;\\n            if(grid[i][j]!=0)\\n            {\\n                if(isvalid(i+1,j,m,n) && grid[i+1][j]!=0)\\n                {\\n                    int b = (i+1)*n+j;\\n                    Union(a,b,parent, rank);\\n                }\\n                if(isvalid(i-1,j,m,n) && grid[i-1][j]!=0)\\n                {\\n                    int b = (i-1)*n+j;\\n                    Union(a,b,parent, rank);\\n                }\\n                if(isvalid(i,j+1,m,n) && grid[i][j+1]!=0)\\n                {\\n                    int b = (i)*n+(j+1);\\n                    Union(a,b,parent, rank);\\n                }\\n                if(isvalid(i,j-1,m,n) && grid[i][j-1]!=0)\\n                {\\n                    int b = (i)*n+(j-1);\\n                    Union(a,b,parent, rank);\\n                }\\n            }\\n        }\\n        int ans=0;\\n        for(int i =0;i<parent.size();i++)\\n        {\\n            ans=max(ans,parent[i].second);\\n        }\\n        return ans;\\n\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3657185,
                "title": "c-easy-bfs",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    int bfs(int row,int col,vector<vector<int>>&grid,vector<vector<int>>&visited)\\n    {\\n        int count =0;\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        queue<pair<int,int>>q;\\n        q.push({row,col});\\n        visited[row][col]=1;\\n        int del_row[]= {-1,0,1,0};\\n        int del_col[] = {0,1,0,-1};\\n        while(!q.empty())\\n        {\\n\\n            int ro = q.front().first;\\n            int cl = q.front().second;\\n\\n            \\n            count +=grid[ro][cl];\\n            q.pop();\\n            for(int i=0;i<4;i++)\\n            {\\n\\n                int ne_row = ro+del_row[i];\\n                int ne_col = cl+del_col[i];\\n                if(ne_row<m && ne_row>=0 && ne_col <n && ne_col>=0 && !visited[ne_row][ne_col] && grid[ne_row][ne_col]!=0)\\n                {\\n                    \\n                    visited[ne_row][ne_col]=1;\\n                    q.push({ne_row,ne_col});\\n\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n\\n    int findMaxFish(vector<vector<int>>& grid) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        vector<int>fishes;\\n        vector<vector<int>>visited(m,vector<int>(n,0));\\n        for(int i=0;i<m;i++)\\n        {\\n\\n            for(int j=0;j<n;j++)\\n            {\\n                if(!visited[i][j] && grid[i][j]!= 0)\\n                {\\n\\n                    fishes.push_back(bfs(i,j,grid,visited));\\n                }\\n            }\\n        }\\n\\n        \\n        if(fishes.size()>0)\\n        {\\n            int max_fish=fishes[0];\\n            for(int i=0;i<fishes.size();i++)\\n            {\\n                if(fishes[i]>max_fish)\\n                {\\n                    max_fish= fishes[i];\\n                }\\n            }\\n            return max_fish;\\n        }\\n        return 0;\\n\\n\\n\\n\\n    }\\n};\\n\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    int bfs(int row,int col,vector<vector<int>>&grid,vector<vector<int>>&visited)\\n    {\\n        int count =0;\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        queue<pair<int,int>>q;\\n        q.push({row,col});\\n        visited[row][col]=1;\\n        int del_row[]= {-1,0,1,0};\\n        int del_col[] = {0,1,0,-1};\\n        while(!q.empty())\\n        {\\n\\n            int ro = q.front().first;\\n            int cl = q.front().second;\\n\\n            \\n            count +=grid[ro][cl];\\n            q.pop();\\n            for(int i=0;i<4;i++)\\n            {\\n\\n                int ne_row = ro+del_row[i];\\n                int ne_col = cl+del_col[i];\\n                if(ne_row<m && ne_row>=0 && ne_col <n && ne_col>=0 && !visited[ne_row][ne_col] && grid[ne_row][ne_col]!=0)\\n                {\\n                    \\n                    visited[ne_row][ne_col]=1;\\n                    q.push({ne_row,ne_col});\\n\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n\\n    int findMaxFish(vector<vector<int>>& grid) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        vector<int>fishes;\\n        vector<vector<int>>visited(m,vector<int>(n,0));\\n        for(int i=0;i<m;i++)\\n        {\\n\\n            for(int j=0;j<n;j++)\\n            {\\n                if(!visited[i][j] && grid[i][j]!= 0)\\n                {\\n\\n                    fishes.push_back(bfs(i,j,grid,visited));\\n                }\\n            }\\n        }\\n\\n        \\n        if(fishes.size()>0)\\n        {\\n            int max_fish=fishes[0];\\n            for(int i=0;i<fishes.size();i++)\\n            {\\n                if(fishes[i]>max_fish)\\n                {\\n                    max_fish= fishes[i];\\n                }\\n            }\\n            return max_fish;\\n        }\\n        return 0;\\n\\n\\n\\n\\n    }\\n};\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3649008,
                "title": "maximum-number-of-fish-in-a-grid-easy-approach",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int dfs(vector<vector<int>>& grid, int r, int c) {\\n    if (r < 0 || r >= grid.size() || c < 0 || c >= grid[0].size() || grid[r][c] == 0) {\\n        return 0; // Base case: out of bounds or land cell\\n    }\\n    int fishCaught = grid[r][c]; // Catch fish at current cell\\n    grid[r][c] = 0; // Mark cell as caught\\n    int moves[4][2] = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}}; // Possible movements\\n    for (int i = 0; i < 4; i++) {\\n        int newR = r + moves[i][0];\\n        int newC = c + moves[i][1];\\n        fishCaught += dfs(grid, newR, newC); // Recursively search adjacent cells\\n    }\\n    return fishCaught;\\n}\\n\\nint findMaxFish(vector<vector<int>>& grid) {\\n    int maxFish = 0;\\n    for (int i = 0; i < grid.size(); i++) {\\n        for (int j = 0; j < grid[0].size(); j++) {\\n            if (grid[i][j] > 0) { // Start DFS search from water cell\\n                int fishCaught = dfs(grid, i, j);\\n                maxFish = max(maxFish, fishCaught);\\n            }\\n        }\\n    }\\n    return maxFish;\\n}\\n};\\n```",
                "solutionTags": [
                    "Array",
                    "Depth-First Search",
                    "Union Find"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dfs(vector<vector<int>>& grid, int r, int c) {\\n    if (r < 0 || r >= grid.size() || c < 0 || c >= grid[0].size() || grid[r][c] == 0) {\\n        return 0; // Base case: out of bounds or land cell\\n    }\\n    int fishCaught = grid[r][c]; // Catch fish at current cell\\n    grid[r][c] = 0; // Mark cell as caught\\n    int moves[4][2] = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}}; // Possible movements\\n    for (int i = 0; i < 4; i++) {\\n        int newR = r + moves[i][0];\\n        int newC = c + moves[i][1];\\n        fishCaught += dfs(grid, newR, newC); // Recursively search adjacent cells\\n    }\\n    return fishCaught;\\n}\\n\\nint findMaxFish(vector<vector<int>>& grid) {\\n    int maxFish = 0;\\n    for (int i = 0; i < grid.size(); i++) {\\n        for (int j = 0; j < grid[0].size(); j++) {\\n            if (grid[i][j] > 0) { // Start DFS search from water cell\\n                int fishCaught = dfs(grid, i, j);\\n                maxFish = max(maxFish, fishCaught);\\n            }\\n        }\\n    }\\n    return maxFish;\\n}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3644249,
                "title": "dfs-approach-c",
                "content": "\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nIt is similar to \"Max Area of Island\" question with oneline variation.\\nhttps://leetcode.com/problems/max-area-of-island/\\n\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n// it will store the answer.\\nint ans=0;\\nvoid dfs(int row,int col,int&fish,vector<vector<int>>&visited,vector<vector<int>>&grid)\\n    {\\n\\n        // variation.\\n        fish+= grid[row][col];\\n\\n        visited[row][col]=1;\\n       \\n\\n        int drow[] = {-1,0,1,0};\\n        int dcol[] = {0,1,0,-1};\\n\\n        for(int i=0;i<4;i++)\\n        {\\n            int nrow = row + drow[i];\\n            int ncol = col + dcol[i];\\n\\n            if(nrow>=0 && ncol>=0 && nrow<grid.size() && ncol<grid[0].size() && !visited[nrow][ncol] &&grid[nrow][ncol])\\n            {               \\n                dfs(nrow,ncol,fish,visited,grid);            \\n            }\\n        }\\n    }\\n    int findMaxFish(vector<vector<int>>& grid) {\\n\\n        int m = grid.size();\\n        int n = grid[0].size();\\n\\n        vector<vector<int>>visited(m,vector<int>(n,0));\\n\\n\\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                if(!visited[i][j] && grid[i][j])\\n                {\\n                    int fish=0;\\n                    dfs(i,j,fish,visited,grid);\\n\\n                    // store the max answer.\\n                    ans = max(ans,fish);\\n                    \\n                }\\n            }\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n// it will store the answer.\\nint ans=0;\\nvoid dfs(int row,int col,int&fish,vector<vector<int>>&visited,vector<vector<int>>&grid)\\n    {\\n\\n        // variation.\\n        fish+= grid[row][col];\\n\\n        visited[row][col]=1;\\n       \\n\\n        int drow[] = {-1,0,1,0};\\n        int dcol[] = {0,1,0,-1};\\n\\n        for(int i=0;i<4;i++)\\n        {\\n            int nrow = row + drow[i];\\n            int ncol = col + dcol[i];\\n\\n            if(nrow>=0 && ncol>=0 && nrow<grid.size() && ncol<grid[0].size() && !visited[nrow][ncol] &&grid[nrow][ncol])\\n            {               \\n                dfs(nrow,ncol,fish,visited,grid);            \\n            }\\n        }\\n    }\\n    int findMaxFish(vector<vector<int>>& grid) {\\n\\n        int m = grid.size();\\n        int n = grid[0].size();\\n\\n        vector<vector<int>>visited(m,vector<int>(n,0));\\n\\n\\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                if(!visited[i][j] && grid[i][j])\\n                {\\n                    int fish=0;\\n                    dfs(i,j,fish,visited,grid);\\n\\n                    // store the max answer.\\n                    ans = max(ans,fish);\\n                    \\n                }\\n            }\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3636773,
                "title": "golang-dfs-simple",
                "content": "# Code\\n```\\nfunc findMaxFish(grid [][]int) int {\\n  m, n := len(grid), len(grid[0])\\n  var res int\\n  for i := 0; i < m; i++ {\\n    for j := 0; j < n; j++ {\\n      if grid[i][j] != 0 {\\n        res = max(res, dfs(grid, i, j))\\n      }\\n    }\\n  }\\n  return res\\n}\\n\\nfunc dfs(grid [][]int, row, col int) int {\\n  res := grid[row][col]\\n  grid[row][col] = 0\\n  directions := [4][2]int{{-1, 0}, {0, -1}, {0, 1}, {1, 0}}\\n  for _, dir := range directions {\\n    x, y := row + dir[0], col + dir[1]\\n    if x >= 0 && x < len(grid) && y >= 0 && y < len(grid[x]) && grid[x][y] > 0 {\\n      res += dfs(grid, x, y)\\n    }\\n  }\\n  return res\\n}\\n\\nfunc max(a, b int) int {\\n  if a > b {\\n    return a\\n  }\\n  return b\\n}\\n```",
                "solutionTags": [
                    "Go",
                    "Depth-First Search"
                ],
                "code": "```\\nfunc findMaxFish(grid [][]int) int {\\n  m, n := len(grid), len(grid[0])\\n  var res int\\n  for i := 0; i < m; i++ {\\n    for j := 0; j < n; j++ {\\n      if grid[i][j] != 0 {\\n        res = max(res, dfs(grid, i, j))\\n      }\\n    }\\n  }\\n  return res\\n}\\n\\nfunc dfs(grid [][]int, row, col int) int {\\n  res := grid[row][col]\\n  grid[row][col] = 0\\n  directions := [4][2]int{{-1, 0}, {0, -1}, {0, 1}, {1, 0}}\\n  for _, dir := range directions {\\n    x, y := row + dir[0], col + dir[1]\\n    if x >= 0 && x < len(grid) && y >= 0 && y < len(grid[x]) && grid[x][y] > 0 {\\n      res += dfs(grid, x, y)\\n    }\\n  }\\n  return res\\n}\\n\\nfunc max(a, b int) int {\\n  if a > b {\\n    return a\\n  }\\n  return b\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3636025,
                "title": "c-dfs-graph-easy",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\nvoid dfs(vector<vector<int>>& grid, vector<vector<int>>& visited, int i, int j, int &count){\\n    if(i<0 || i>=grid.size() || j<0 || j>=grid[0].size() || visited[i][j]==1 || grid[i][j]==0)\\n    return ;\\n    visited[i][j] = 1;\\n    count += grid[i][j];\\n    \\n    dfs(grid, visited, i+1, j, count);\\n    dfs(grid, visited, i-1, j, count);\\n    dfs(grid, visited, i, j+1, count);\\n    dfs(grid, visited, i, j-1, count);\\n}\\n    int findMaxFish(vector<vector<int>>& grid) {\\n\\n        int n = grid.size(), m = grid[0].size();\\n        int ans = 0;\\n\\n        vector<vector<int>> visited(n, vector<int> (m, 0));\\n\\n        for(int i=0 ;i<n ;i++){\\n            for(int j=0 ;j<m ;j++){\\n        \\n                int count = 0;\\n                if(!visited[i][j] && grid[i][j]>0)\\n                dfs(grid, visited, i, j, count);\\n                ans = max(ans, count);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nvoid dfs(vector<vector<int>>& grid, vector<vector<int>>& visited, int i, int j, int &count){\\n    if(i<0 || i>=grid.size() || j<0 || j>=grid[0].size() || visited[i][j]==1 || grid[i][j]==0)\\n    return ;\\n    visited[i][j] = 1;\\n    count += grid[i][j];\\n    \\n    dfs(grid, visited, i+1, j, count);\\n    dfs(grid, visited, i-1, j, count);\\n    dfs(grid, visited, i, j+1, count);\\n    dfs(grid, visited, i, j-1, count);\\n}\\n    int findMaxFish(vector<vector<int>>& grid) {\\n\\n        int n = grid.size(), m = grid[0].size();\\n        int ans = 0;\\n\\n        vector<vector<int>> visited(n, vector<int> (m, 0));\\n\\n        for(int i=0 ;i<n ;i++){\\n            for(int j=0 ;j<m ;j++){\\n        \\n                int count = 0;\\n                if(!visited[i][j] && grid[i][j]>0)\\n                dfs(grid, visited, i, j, count);\\n                ans = max(ans, count);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3635164,
                "title": "java-dfs-solution",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    int sum;\\n    public int findMaxFish(int[][] grid) {\\n        sum = 0;\\n        int max = 0;\\n        for(int i=0;i<grid.length;i++){\\n            for(int j=0;j<grid[0].length;j++){\\n                dfs(grid,i,j);\\n                max = Math.max(max,sum);\\n                sum=0;\\n            }\\n        }\\n        return max;\\n    }\\n\\n    private void dfs(int[][] grid, int i, int j){\\n        if(i<0 || i>=grid.length || j<0 || j>=grid[0].length || grid[i][j]==0){\\n            return;\\n        }\\n         sum = sum + grid[i][j];\\n         grid[i][j]=0;\\n         dfs(grid,i+1,j);\\n         dfs(grid,i-1,j);\\n         dfs(grid,i,j+1);\\n         dfs(grid,i,j-1);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    int sum;\\n    public int findMaxFish(int[][] grid) {\\n        sum = 0;\\n        int max = 0;\\n        for(int i=0;i<grid.length;i++){\\n            for(int j=0;j<grid[0].length;j++){\\n                dfs(grid,i,j);\\n                max = Math.max(max,sum);\\n                sum=0;\\n            }\\n        }\\n        return max;\\n    }\\n\\n    private void dfs(int[][] grid, int i, int j){\\n        if(i<0 || i>=grid.length || j<0 || j>=grid[0].length || grid[i][j]==0){\\n            return;\\n        }\\n         sum = sum + grid[i][j];\\n         grid[i][j]=0;\\n         dfs(grid,i+1,j);\\n         dfs(grid,i-1,j);\\n         dfs(grid,i,j+1);\\n         dfs(grid,i,j-1);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3620887,
                "title": "easy-dfs-solution-beats-100-online-submissions",
                "content": "# Code\\n```\\nclass Solution {\\n\\n    private int dfs(int[][] grid, int i, int j){\\n        if(i < 0 || j < 0 || i >= grid.length || j >= grid[0].length || grid[i][j] == 0){\\n            return 0;\\n        }\\n\\n        int val = grid[i][j];\\n\\n        grid[i][j] = 0;\\n\\n        val += dfs(grid, i+1, j);\\n        val += dfs(grid, i, j+1);\\n        val += dfs(grid, i-1, j);\\n        val += dfs(grid, i, j-1);\\n\\n        return val;\\n    }\\n\\n    public int findMaxFish(int[][] grid) {\\n        int ans = 0;\\n\\n        for(int i = 0;i < grid.length;i++){\\n            for(int j = 0;j < grid[0].length;j++){\\n                if(grid[i][j] != 0){\\n                    ans = Math.max(ans,dfs(grid,i,j));\\n                }\\n            }\\n        }\\n\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\n\\n    private int dfs(int[][] grid, int i, int j){\\n        if(i < 0 || j < 0 || i >= grid.length || j >= grid[0].length || grid[i][j] == 0){\\n            return 0;\\n        }\\n\\n        int val = grid[i][j];\\n\\n        grid[i][j] = 0;\\n\\n        val += dfs(grid, i+1, j);\\n        val += dfs(grid, i, j+1);\\n        val += dfs(grid, i-1, j);\\n        val += dfs(grid, i, j-1);\\n\\n        return val;\\n    }\\n\\n    public int findMaxFish(int[][] grid) {\\n        int ans = 0;\\n\\n        for(int i = 0;i < grid.length;i++){\\n            for(int j = 0;j < grid[0].length;j++){\\n                if(grid[i][j] != 0){\\n                    ans = Math.max(ans,dfs(grid,i,j));\\n                }\\n            }\\n        }\\n\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3620603,
                "title": "java-dfs-solution-using-striver-concept-visited-array",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    private int sum;\\n    public void dfs(int grid[][],int row,int col,int vis[][]){\\n        sum+=grid[row][col];\\n        vis[row][col]=1;\\n        int drow[]={-1,0,1,0};\\n        int dcol[]={0,1,0,-1};\\n        for(int i=0;i<4;i++){\\n            int r=row+drow[i];\\n            int c=col+dcol[i];\\n\\n            if(r>=0&&r<grid.length&&c>=0&&c<grid[0].length&&grid[r][c]!=0&&vis[r][c]==0){\\n                dfs(grid,r,c,vis);\\n            }\\n        }\\n    }\\n    public int findMaxFish(int[][] grid) {\\n        int max=0;\\n        int vis[][]=new int[grid.length][grid[0].length];\\n        for(int i=0;i<grid.length;i++){\\n            for(int j=0;j<grid[0].length;j++){\\n                if(grid[i][j]!=0 && vis[i][j]==0){\\n                   sum=0;  \\n                  dfs(grid,i,j,vis);\\n                  max=Math.max(sum,max);\\n                }\\n            }\\n        }\\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    private int sum;\\n    public void dfs(int grid[][],int row,int col,int vis[][]){\\n        sum+=grid[row][col];\\n        vis[row][col]=1;\\n        int drow[]={-1,0,1,0};\\n        int dcol[]={0,1,0,-1};\\n        for(int i=0;i<4;i++){\\n            int r=row+drow[i];\\n            int c=col+dcol[i];\\n\\n            if(r>=0&&r<grid.length&&c>=0&&c<grid[0].length&&grid[r][c]!=0&&vis[r][c]==0){\\n                dfs(grid,r,c,vis);\\n            }\\n        }\\n    }\\n    public int findMaxFish(int[][] grid) {\\n        int max=0;\\n        int vis[][]=new int[grid.length][grid[0].length];\\n        for(int i=0;i<grid.length;i++){\\n            for(int j=0;j<grid[0].length;j++){\\n                if(grid[i][j]!=0 && vis[i][j]==0){\\n                   sum=0;  \\n                  dfs(grid,i,j,vis);\\n                  max=Math.max(sum,max);\\n                }\\n            }\\n        }\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3620196,
                "title": "c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n\\n\\ntypedef struct\\n{\\n    int **grid;\\n    int x;\\n    int y;\\n    int **visited;\\n}stGrid;\\n\\nvoid recrusion(stGrid *field,int cur_x, int cur_y, int *cur_greb, int *maxFish)\\n{\\n    if((cur_x < 0 || cur_x >= field->x) || (cur_y < 0 || cur_y >= field->y) || \\n                field->grid[cur_y][cur_x] == 0 || field->visited[cur_y][cur_x])\\n    {\\n        *maxFish = (*cur_greb>*maxFish)?(*cur_greb):(*maxFish);\\n    }\\n    else\\n    {\\n        if(field->visited[cur_y][cur_x] != 1)\\n        {\\n            *cur_greb += field->grid[cur_y][cur_x];\\n        }\\n        field->visited[cur_y][cur_x] = 1;\\n        recrusion(field,cur_x + 1, cur_y, cur_greb, maxFish);\\n        recrusion(field,cur_x, cur_y - 1, cur_greb, maxFish);\\n        recrusion(field,cur_x - 1, cur_y, cur_greb, maxFish);\\n        recrusion(field,cur_x, cur_y + 1, cur_greb, maxFish);\\n    }\\n}\\n\\n\\n\\nint findMaxFish(int** grid, int gridSize, int* gridColSize){\\n\\n    stGrid field;\\n    field.grid = grid;\\n    field.y = gridSize;\\n    field.x = *gridColSize;\\n    field.visited = (int**)calloc(field.y, sizeof(int*)); \\n    for(int i = 0; i < field.y; i++)\\n    {\\n        field.visited[i] = (int*)calloc(field.x, sizeof(int));\\n    }\\n\\n    int maxFish = 0;\\n    int temp_Fish = 0;\\n    for(int row = 0; row < field.y ; row++)\\n    {\\n        for(int col = 0; col < field.x; col++)\\n        {\\n            recrusion(&field, col, row, &temp_Fish, &maxFish);\\n            temp_Fish = 0;\\n        }\\n    }\\n\\n    return maxFish;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n\\n\\ntypedef struct\\n{\\n    int **grid;\\n    int x;\\n    int y;\\n    int **visited;\\n}stGrid;\\n\\nvoid recrusion(stGrid *field,int cur_x, int cur_y, int *cur_greb, int *maxFish)\\n{\\n    if((cur_x < 0 || cur_x >= field->x) || (cur_y < 0 || cur_y >= field->y) || \\n                field->grid[cur_y][cur_x] == 0 || field->visited[cur_y][cur_x])\\n    {\\n        *maxFish = (*cur_greb>*maxFish)?(*cur_greb):(*maxFish);\\n    }\\n    else\\n    {\\n        if(field->visited[cur_y][cur_x] != 1)\\n        {\\n            *cur_greb += field->grid[cur_y][cur_x];\\n        }\\n        field->visited[cur_y][cur_x] = 1;\\n        recrusion(field,cur_x + 1, cur_y, cur_greb, maxFish);\\n        recrusion(field,cur_x, cur_y - 1, cur_greb, maxFish);\\n        recrusion(field,cur_x - 1, cur_y, cur_greb, maxFish);\\n        recrusion(field,cur_x, cur_y + 1, cur_greb, maxFish);\\n    }\\n}\\n\\n\\n\\nint findMaxFish(int** grid, int gridSize, int* gridColSize){\\n\\n    stGrid field;\\n    field.grid = grid;\\n    field.y = gridSize;\\n    field.x = *gridColSize;\\n    field.visited = (int**)calloc(field.y, sizeof(int*)); \\n    for(int i = 0; i < field.y; i++)\\n    {\\n        field.visited[i] = (int*)calloc(field.x, sizeof(int));\\n    }\\n\\n    int maxFish = 0;\\n    int temp_Fish = 0;\\n    for(int row = 0; row < field.y ; row++)\\n    {\\n        for(int col = 0; col < field.x; col++)\\n        {\\n            recrusion(&field, col, row, &temp_Fish, &maxFish);\\n            temp_Fish = 0;\\n        }\\n    }\\n\\n    return maxFish;\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3618242,
                "title": "java-5ms-99-dfs-and-clean-code",
                "content": "# Approach: DFS\\n1. For i =0..n, j = 0..m, if current cell is water, jump on it and try catching the max nr of fish. Keep track of max number of fish\\n2. Catching fish: recursive function that takes, grid, i, j and returns the max number of fish\\n    - if i,j outside the bounds or current cell is land, return 0\\n    - else add current cell to a return answer, set current cell to 0 and try fishing in the 4 directions, adding their values to return answer.\\n    - return the answer for this function call.  \\n3. Method #2 will traverse all linked water calls, catch their fish and marking the cells with 0.\\n4. #1 will then ignore these already fished cells.\\n\\n# Complexity\\n- Time complexity:$$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int findMaxFish(int[][] grid) {\\n        int maxFish = 0;\\n        for(int i = 0; i < grid.length; i++) {\\n            for (int j = 0; j < grid[0].length; j++) {\\n                if (grid[i][j] != 0) {\\n                    maxFish = Math.max(maxFish, catchFish(grid, i, j));\\n                }\\n            }\\n        }\\n        return maxFish;\\n    }\\n\\n    private int catchFish(int[][] grid, int i, int j) {\\n        if (i < 0 || i >= grid.length || j < 0 || j >= grid[0].length || grid[i][j] == 0) {\\n            return 0;\\n        }\\n        int fish = grid[i][j];\\n        grid[i][j] = 0;\\n        fish += catchFish(grid, i-1, j) + catchFish(grid, i, j+1) + catchFish(grid, i+1, j) + catchFish(grid, i, j-1);\\n        return fish;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int findMaxFish(int[][] grid) {\\n        int maxFish = 0;\\n        for(int i = 0; i < grid.length; i++) {\\n            for (int j = 0; j < grid[0].length; j++) {\\n                if (grid[i][j] != 0) {\\n                    maxFish = Math.max(maxFish, catchFish(grid, i, j));\\n                }\\n            }\\n        }\\n        return maxFish;\\n    }\\n\\n    private int catchFish(int[][] grid, int i, int j) {\\n        if (i < 0 || i >= grid.length || j < 0 || j >= grid[0].length || grid[i][j] == 0) {\\n            return 0;\\n        }\\n        int fish = grid[i][j];\\n        grid[i][j] = 0;\\n        fish += catchFish(grid, i-1, j) + catchFish(grid, i, j+1) + catchFish(grid, i+1, j) + catchFish(grid, i, j-1);\\n        return fish;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3607455,
                "title": "simple-dfs-c",
                "content": "# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N^2)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(N^2)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n   int dfs(vector<vector<int>>& grid,int i,int j,vector<vector<int>> &vis){\\n   if(vis[i][j]==1 || grid[i][j]<=0)return 0;\\n   int ans=grid[i][j];\\n   vis[i][j]=1;\\n   if(i>0)ans+=dfs(grid,i-1,j,vis);\\n   if(j>0)ans+=dfs(grid,i,j-1,vis);\\n   if(i<grid.size()-1)ans+=dfs(grid,i+1,j,vis);\\n   if(j<grid[0].size()-1)ans+=dfs(grid,i,j+1,vis);\\n   return ans;\\n   }\\n    int findMaxFish(vector<vector<int>>& grid) {\\n        int maxi=0;\\n        for(int i=0;i<grid.size();i++){\\n            vector<vector<int>> vis(grid.size(),vector<int> (grid[0].size(),0));\\n            for(int j=0;j<grid[0].size();j++){\\n            if(grid[i][j]>0 ){\\n            maxi=max(maxi,dfs(grid,i,j,vis));\\n           // cout<<maxi<<\" \"<<i<<\" \"<<j<<\"\\\\n\";\\n            }\\n            }\\n        }\\n        return maxi;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n   int dfs(vector<vector<int>>& grid,int i,int j,vector<vector<int>> &vis){\\n   if(vis[i][j]==1 || grid[i][j]<=0)return 0;\\n   int ans=grid[i][j];\\n   vis[i][j]=1;\\n   if(i>0)ans+=dfs(grid,i-1,j,vis);\\n   if(j>0)ans+=dfs(grid,i,j-1,vis);\\n   if(i<grid.size()-1)ans+=dfs(grid,i+1,j,vis);\\n   if(j<grid[0].size()-1)ans+=dfs(grid,i,j+1,vis);\\n   return ans;\\n   }\\n    int findMaxFish(vector<vector<int>>& grid) {\\n        int maxi=0;\\n        for(int i=0;i<grid.size();i++){\\n            vector<vector<int>> vis(grid.size(),vector<int> (grid[0].size(),0));\\n            for(int j=0;j<grid[0].size();j++){\\n            if(grid[i][j]>0 ){\\n            maxi=max(maxi,dfs(grid,i,j,vis));\\n           // cout<<maxi<<\" \"<<i<<\" \"<<j<<\"\\\\n\";\\n            }\\n            }\\n        }\\n        return maxi;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3602081,
                "title": "most-intuitive-c-solution-dfs",
                "content": "# Complexity\\n- Time complexity: O(n * m)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int di[4] = {1, -1, 0, 0}, dj[4] = {0, 0, 1, -1};\\n    \\n    bool ok(int i, int j, vector<vector<int>>& grid) {\\n        return i >= 0 && i < grid.size() &&\\n               j >= 0 && j < grid[0].size() &&\\n               grid[i][j] != 0;\\n    }\\n\\n    int dfs(int i, int j, vector<vector<int>>& grid) {\\n        int res = grid[i][j];\\n        grid[i][j] = 0;\\n        for (int k = 0; k < 4; k++) {\\n            int r = i + di[k];\\n            int c = j + dj[k];\\n            if (ok(r, c, grid)) res += dfs(r, c, grid);\\n        }\\n        return res;\\n    }\\n\\n    int findMaxFish(vector<vector<int>>& grid) {\\n        int n = grid.size(), m = grid[0].size();\\n        int ans = 0;\\n\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < m; j++) {\\n                if (grid[i][j] == 0) continue;\\n                int cnt = dfs(i, j, grid);\\n                ans = max(ans, cnt);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int di[4] = {1, -1, 0, 0}, dj[4] = {0, 0, 1, -1};\\n    \\n    bool ok(int i, int j, vector<vector<int>>& grid) {\\n        return i >= 0 && i < grid.size() &&\\n               j >= 0 && j < grid[0].size() &&\\n               grid[i][j] != 0;\\n    }\\n\\n    int dfs(int i, int j, vector<vector<int>>& grid) {\\n        int res = grid[i][j];\\n        grid[i][j] = 0;\\n        for (int k = 0; k < 4; k++) {\\n            int r = i + di[k];\\n            int c = j + dj[k];\\n            if (ok(r, c, grid)) res += dfs(r, c, grid);\\n        }\\n        return res;\\n    }\\n\\n    int findMaxFish(vector<vector<int>>& grid) {\\n        int n = grid.size(), m = grid[0].size();\\n        int ans = 0;\\n\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < m; j++) {\\n                if (grid[i][j] == 0) continue;\\n                int cnt = dfs(i, j, grid);\\n                ans = max(ans, cnt);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3593140,
                "title": "java-solution-simple-dfs-99-fast",
                "content": "# Approach\\n**DFS** through every non-zero cell, and add up all the numbers found on the way. Also, mark all the cells as 0, so they won\\'t be parsed again.\\nEvery DFS dive will get back a number, that will be the maximum number of fishes caught starting from current cell, as well as from any cell that was visited.No need to do it again from every cell.\\nBiggest number returned among all dfs dives will be the answer.\\n\\n# Complexity\\nLet rows and columns be denoted by ```row```, ```col```\\n- Time complexity:\\nAt worst case parsing of every cell in the grid:$$O(row*col)$$\\n**Total: $$O(row * col)$$**\\n\\n- Space complexity:\\nExcluding input: **$$O(1)$$**\\nIncluding input: **$$O(row * col)$$**\\n\\n\\n# Code\\n```\\nclass Solution {\\n    public int findMaxFish(int[][] grid) {\\n        int max = 0;\\n        int row = grid.length,col = grid[0].length;\\n        for(int i=0;i<row;i++){\\n            for(int j=0;j<col;j++){\\n                if(grid[i][j] == 0) continue;\\n                int count = dfs(grid,i,j,row,col);\\n                max = Math.max(max,count);\\n            }\\n        }\\n        return max;\\n    }\\n\\n    int dfs(int[][] arr,int i,int j,int row,int col){\\n        if(i<0 || j<0 || i>=row || j>=col) return 0;\\n        if(arr[i][j] == 0) return 0;\\n        int count = arr[i][j];\\n        arr[i][j] = 0;\\n\\n        count+=dfs(arr,i+1,j,row,col);\\n        count+=dfs(arr,i,j+1,row,col);\\n        count+=dfs(arr,i-1,j,row,col);\\n        count+=dfs(arr,i,j-1,row,col);\\n\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search"
                ],
                "code": "```row```\n```col```\n```\\nclass Solution {\\n    public int findMaxFish(int[][] grid) {\\n        int max = 0;\\n        int row = grid.length,col = grid[0].length;\\n        for(int i=0;i<row;i++){\\n            for(int j=0;j<col;j++){\\n                if(grid[i][j] == 0) continue;\\n                int count = dfs(grid,i,j,row,col);\\n                max = Math.max(max,count);\\n            }\\n        }\\n        return max;\\n    }\\n\\n    int dfs(int[][] arr,int i,int j,int row,int col){\\n        if(i<0 || j<0 || i>=row || j>=col) return 0;\\n        if(arr[i][j] == 0) return 0;\\n        int count = arr[i][j];\\n        arr[i][j] = 0;\\n\\n        count+=dfs(arr,i+1,j,row,col);\\n        count+=dfs(arr,i,j+1,row,col);\\n        count+=dfs(arr,i-1,j,row,col);\\n        count+=dfs(arr,i,j-1,row,col);\\n\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1877160,
                "content": [
                    {
                        "username": "15o1",
                        "content": "This should be a medium problem"
                    },
                    {
                        "username": "jameshsw",
                        "content": "The problem could use a clearer description, such as 'Return the maximum number of fish the fisher can catch \"in all the connected water cells\" if he chooses his starting cell optimally'"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "Yes this is important point to be noted."
                    },
                    {
                        "username": "adis176",
                        "content": "The question is really quite ambiguous. It needs to be defined properly. \\nThis test-case can help: \\n[[4, 5, 5], [0, 10, 0]] -> its correct answer will be 24.\\nHope this helps to clarify the problem."
                    },
                    {
                        "username": "ips2105",
                        "content": "Thought once you collect the fishes from a cell, you can\\'t come back. . The question should clarify this :("
                    },
                    {
                        "username": "adis176",
                        "content": "Actually you can. It is not DFS (traversal from start point to any one end, it is the complete traversal of all possible points from your chosen starting point. \\nThis question was in the biweekly contest 103, and initially I failed at the test-case [[4, 5, 5], [0, 10, 0]] -> Its correct answer was 24. \\nThough I agree that the question is quite ambiguous."
                    },
                    {
                        "username": "rishiagarwal-lc",
                        "content": "WTH! it must be ranked above hard, leetcode should ban such problem setters:)"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "It\\'s pretty much this problem, but with variable numbers instead of only 1\\'s: https://leetcode.com/problems/max-area-of-island/\\nI don\\'t see why the difficulty would be different. good BFS problem though."
                    },
                    {
                        "username": "amitbansal13",
                        "content": "There are medium classified problems much much harder than this. This is definitely wrongly classified."
                    },
                    {
                        "username": "MdoingIt",
                        "content": "poorly described statement"
                    },
                    {
                        "username": "gadmo",
                        "content": "that should be easy level just saying, literally 2 minutes start to working submission , cant get more straight forward dfs than this ."
                    },
                    {
                        "username": "Mohamed_1",
                        "content": "why this code wrong at this case ! \n[[6,1,10]]  \n`\n\n    def findMaxFish(self, grid: List[List[int]]) -> int:\n        n , m = len(grid) , len(grid[0])\n        directions = [(1 , 0) ,(-1 , 0) ,(0 , 1) ,(0 , -1)]\n\n        def dfs(i , j):\n            if( i < 0 or i == n or \n               j < 0 or j == m or\n               grid[i][j] == 0): return 0\n\n            fish = grid[i][j]\n            print(fish)\n            grid[i][j] = 0\n            for x,y in directions:\n                self.res+=dfs(i+x , y+j)\n            return fish\n\n\n        mx = 0\n        for i in range(n):\n            for j in range(m):\n                if grid[i][j] > 0:\n                    self.res = grid[i][j]\n                    dfs(i , j)\n                    mx = max(mx , self.res )\n        return mx\n`\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your current DFS function doesn\\'t look for the optimal path. Instead, it traverses the grid in the order of the directions list, without considering which move would yield the most fish.\\n\\nA key part of this problem is that the fisher can choose the order of his moves optimally, meaning he doesn\\'t just go to the first non-zero cell he finds, but instead he should always move to the adjacent cell with the most fish.\\n\\nIn order to fix the function, you should change the DFS so that it always moves to the adjacent cell with the most fish. To do this, you should add a step to find the max fish in all adjacent cells, and only then call the DFS function recursively.\\n"
                    },
                    {
                        "username": "wataru",
                        "content": "In the dfs you return |fish| but you need to return sum of |fish| and the sum of recursive results."
                    }
                ]
            },
            {
                "id": 1877329,
                "content": [
                    {
                        "username": "15o1",
                        "content": "This should be a medium problem"
                    },
                    {
                        "username": "jameshsw",
                        "content": "The problem could use a clearer description, such as 'Return the maximum number of fish the fisher can catch \"in all the connected water cells\" if he chooses his starting cell optimally'"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "Yes this is important point to be noted."
                    },
                    {
                        "username": "adis176",
                        "content": "The question is really quite ambiguous. It needs to be defined properly. \\nThis test-case can help: \\n[[4, 5, 5], [0, 10, 0]] -> its correct answer will be 24.\\nHope this helps to clarify the problem."
                    },
                    {
                        "username": "ips2105",
                        "content": "Thought once you collect the fishes from a cell, you can\\'t come back. . The question should clarify this :("
                    },
                    {
                        "username": "adis176",
                        "content": "Actually you can. It is not DFS (traversal from start point to any one end, it is the complete traversal of all possible points from your chosen starting point. \\nThis question was in the biweekly contest 103, and initially I failed at the test-case [[4, 5, 5], [0, 10, 0]] -> Its correct answer was 24. \\nThough I agree that the question is quite ambiguous."
                    },
                    {
                        "username": "rishiagarwal-lc",
                        "content": "WTH! it must be ranked above hard, leetcode should ban such problem setters:)"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "It\\'s pretty much this problem, but with variable numbers instead of only 1\\'s: https://leetcode.com/problems/max-area-of-island/\\nI don\\'t see why the difficulty would be different. good BFS problem though."
                    },
                    {
                        "username": "amitbansal13",
                        "content": "There are medium classified problems much much harder than this. This is definitely wrongly classified."
                    },
                    {
                        "username": "MdoingIt",
                        "content": "poorly described statement"
                    },
                    {
                        "username": "gadmo",
                        "content": "that should be easy level just saying, literally 2 minutes start to working submission , cant get more straight forward dfs than this ."
                    },
                    {
                        "username": "Mohamed_1",
                        "content": "why this code wrong at this case ! \n[[6,1,10]]  \n`\n\n    def findMaxFish(self, grid: List[List[int]]) -> int:\n        n , m = len(grid) , len(grid[0])\n        directions = [(1 , 0) ,(-1 , 0) ,(0 , 1) ,(0 , -1)]\n\n        def dfs(i , j):\n            if( i < 0 or i == n or \n               j < 0 or j == m or\n               grid[i][j] == 0): return 0\n\n            fish = grid[i][j]\n            print(fish)\n            grid[i][j] = 0\n            for x,y in directions:\n                self.res+=dfs(i+x , y+j)\n            return fish\n\n\n        mx = 0\n        for i in range(n):\n            for j in range(m):\n                if grid[i][j] > 0:\n                    self.res = grid[i][j]\n                    dfs(i , j)\n                    mx = max(mx , self.res )\n        return mx\n`\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your current DFS function doesn\\'t look for the optimal path. Instead, it traverses the grid in the order of the directions list, without considering which move would yield the most fish.\\n\\nA key part of this problem is that the fisher can choose the order of his moves optimally, meaning he doesn\\'t just go to the first non-zero cell he finds, but instead he should always move to the adjacent cell with the most fish.\\n\\nIn order to fix the function, you should change the DFS so that it always moves to the adjacent cell with the most fish. To do this, you should add a step to find the max fish in all adjacent cells, and only then call the DFS function recursively.\\n"
                    },
                    {
                        "username": "wataru",
                        "content": "In the dfs you return |fish| but you need to return sum of |fish| and the sum of recursive results."
                    }
                ]
            },
            {
                "id": 1878212,
                "content": [
                    {
                        "username": "15o1",
                        "content": "This should be a medium problem"
                    },
                    {
                        "username": "jameshsw",
                        "content": "The problem could use a clearer description, such as 'Return the maximum number of fish the fisher can catch \"in all the connected water cells\" if he chooses his starting cell optimally'"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "Yes this is important point to be noted."
                    },
                    {
                        "username": "adis176",
                        "content": "The question is really quite ambiguous. It needs to be defined properly. \\nThis test-case can help: \\n[[4, 5, 5], [0, 10, 0]] -> its correct answer will be 24.\\nHope this helps to clarify the problem."
                    },
                    {
                        "username": "ips2105",
                        "content": "Thought once you collect the fishes from a cell, you can\\'t come back. . The question should clarify this :("
                    },
                    {
                        "username": "adis176",
                        "content": "Actually you can. It is not DFS (traversal from start point to any one end, it is the complete traversal of all possible points from your chosen starting point. \\nThis question was in the biweekly contest 103, and initially I failed at the test-case [[4, 5, 5], [0, 10, 0]] -> Its correct answer was 24. \\nThough I agree that the question is quite ambiguous."
                    },
                    {
                        "username": "rishiagarwal-lc",
                        "content": "WTH! it must be ranked above hard, leetcode should ban such problem setters:)"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "It\\'s pretty much this problem, but with variable numbers instead of only 1\\'s: https://leetcode.com/problems/max-area-of-island/\\nI don\\'t see why the difficulty would be different. good BFS problem though."
                    },
                    {
                        "username": "amitbansal13",
                        "content": "There are medium classified problems much much harder than this. This is definitely wrongly classified."
                    },
                    {
                        "username": "MdoingIt",
                        "content": "poorly described statement"
                    },
                    {
                        "username": "gadmo",
                        "content": "that should be easy level just saying, literally 2 minutes start to working submission , cant get more straight forward dfs than this ."
                    },
                    {
                        "username": "Mohamed_1",
                        "content": "why this code wrong at this case ! \n[[6,1,10]]  \n`\n\n    def findMaxFish(self, grid: List[List[int]]) -> int:\n        n , m = len(grid) , len(grid[0])\n        directions = [(1 , 0) ,(-1 , 0) ,(0 , 1) ,(0 , -1)]\n\n        def dfs(i , j):\n            if( i < 0 or i == n or \n               j < 0 or j == m or\n               grid[i][j] == 0): return 0\n\n            fish = grid[i][j]\n            print(fish)\n            grid[i][j] = 0\n            for x,y in directions:\n                self.res+=dfs(i+x , y+j)\n            return fish\n\n\n        mx = 0\n        for i in range(n):\n            for j in range(m):\n                if grid[i][j] > 0:\n                    self.res = grid[i][j]\n                    dfs(i , j)\n                    mx = max(mx , self.res )\n        return mx\n`\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your current DFS function doesn\\'t look for the optimal path. Instead, it traverses the grid in the order of the directions list, without considering which move would yield the most fish.\\n\\nA key part of this problem is that the fisher can choose the order of his moves optimally, meaning he doesn\\'t just go to the first non-zero cell he finds, but instead he should always move to the adjacent cell with the most fish.\\n\\nIn order to fix the function, you should change the DFS so that it always moves to the adjacent cell with the most fish. To do this, you should add a step to find the max fish in all adjacent cells, and only then call the DFS function recursively.\\n"
                    },
                    {
                        "username": "wataru",
                        "content": "In the dfs you return |fish| but you need to return sum of |fish| and the sum of recursive results."
                    }
                ]
            },
            {
                "id": 1877308,
                "content": [
                    {
                        "username": "15o1",
                        "content": "This should be a medium problem"
                    },
                    {
                        "username": "jameshsw",
                        "content": "The problem could use a clearer description, such as 'Return the maximum number of fish the fisher can catch \"in all the connected water cells\" if he chooses his starting cell optimally'"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "Yes this is important point to be noted."
                    },
                    {
                        "username": "adis176",
                        "content": "The question is really quite ambiguous. It needs to be defined properly. \\nThis test-case can help: \\n[[4, 5, 5], [0, 10, 0]] -> its correct answer will be 24.\\nHope this helps to clarify the problem."
                    },
                    {
                        "username": "ips2105",
                        "content": "Thought once you collect the fishes from a cell, you can\\'t come back. . The question should clarify this :("
                    },
                    {
                        "username": "adis176",
                        "content": "Actually you can. It is not DFS (traversal from start point to any one end, it is the complete traversal of all possible points from your chosen starting point. \\nThis question was in the biweekly contest 103, and initially I failed at the test-case [[4, 5, 5], [0, 10, 0]] -> Its correct answer was 24. \\nThough I agree that the question is quite ambiguous."
                    },
                    {
                        "username": "rishiagarwal-lc",
                        "content": "WTH! it must be ranked above hard, leetcode should ban such problem setters:)"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "It\\'s pretty much this problem, but with variable numbers instead of only 1\\'s: https://leetcode.com/problems/max-area-of-island/\\nI don\\'t see why the difficulty would be different. good BFS problem though."
                    },
                    {
                        "username": "amitbansal13",
                        "content": "There are medium classified problems much much harder than this. This is definitely wrongly classified."
                    },
                    {
                        "username": "MdoingIt",
                        "content": "poorly described statement"
                    },
                    {
                        "username": "gadmo",
                        "content": "that should be easy level just saying, literally 2 minutes start to working submission , cant get more straight forward dfs than this ."
                    },
                    {
                        "username": "Mohamed_1",
                        "content": "why this code wrong at this case ! \n[[6,1,10]]  \n`\n\n    def findMaxFish(self, grid: List[List[int]]) -> int:\n        n , m = len(grid) , len(grid[0])\n        directions = [(1 , 0) ,(-1 , 0) ,(0 , 1) ,(0 , -1)]\n\n        def dfs(i , j):\n            if( i < 0 or i == n or \n               j < 0 or j == m or\n               grid[i][j] == 0): return 0\n\n            fish = grid[i][j]\n            print(fish)\n            grid[i][j] = 0\n            for x,y in directions:\n                self.res+=dfs(i+x , y+j)\n            return fish\n\n\n        mx = 0\n        for i in range(n):\n            for j in range(m):\n                if grid[i][j] > 0:\n                    self.res = grid[i][j]\n                    dfs(i , j)\n                    mx = max(mx , self.res )\n        return mx\n`\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your current DFS function doesn\\'t look for the optimal path. Instead, it traverses the grid in the order of the directions list, without considering which move would yield the most fish.\\n\\nA key part of this problem is that the fisher can choose the order of his moves optimally, meaning he doesn\\'t just go to the first non-zero cell he finds, but instead he should always move to the adjacent cell with the most fish.\\n\\nIn order to fix the function, you should change the DFS so that it always moves to the adjacent cell with the most fish. To do this, you should add a step to find the max fish in all adjacent cells, and only then call the DFS function recursively.\\n"
                    },
                    {
                        "username": "wataru",
                        "content": "In the dfs you return |fish| but you need to return sum of |fish| and the sum of recursive results."
                    }
                ]
            },
            {
                "id": 1877396,
                "content": [
                    {
                        "username": "15o1",
                        "content": "This should be a medium problem"
                    },
                    {
                        "username": "jameshsw",
                        "content": "The problem could use a clearer description, such as 'Return the maximum number of fish the fisher can catch \"in all the connected water cells\" if he chooses his starting cell optimally'"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "Yes this is important point to be noted."
                    },
                    {
                        "username": "adis176",
                        "content": "The question is really quite ambiguous. It needs to be defined properly. \\nThis test-case can help: \\n[[4, 5, 5], [0, 10, 0]] -> its correct answer will be 24.\\nHope this helps to clarify the problem."
                    },
                    {
                        "username": "ips2105",
                        "content": "Thought once you collect the fishes from a cell, you can\\'t come back. . The question should clarify this :("
                    },
                    {
                        "username": "adis176",
                        "content": "Actually you can. It is not DFS (traversal from start point to any one end, it is the complete traversal of all possible points from your chosen starting point. \\nThis question was in the biweekly contest 103, and initially I failed at the test-case [[4, 5, 5], [0, 10, 0]] -> Its correct answer was 24. \\nThough I agree that the question is quite ambiguous."
                    },
                    {
                        "username": "rishiagarwal-lc",
                        "content": "WTH! it must be ranked above hard, leetcode should ban such problem setters:)"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "It\\'s pretty much this problem, but with variable numbers instead of only 1\\'s: https://leetcode.com/problems/max-area-of-island/\\nI don\\'t see why the difficulty would be different. good BFS problem though."
                    },
                    {
                        "username": "amitbansal13",
                        "content": "There are medium classified problems much much harder than this. This is definitely wrongly classified."
                    },
                    {
                        "username": "MdoingIt",
                        "content": "poorly described statement"
                    },
                    {
                        "username": "gadmo",
                        "content": "that should be easy level just saying, literally 2 minutes start to working submission , cant get more straight forward dfs than this ."
                    },
                    {
                        "username": "Mohamed_1",
                        "content": "why this code wrong at this case ! \n[[6,1,10]]  \n`\n\n    def findMaxFish(self, grid: List[List[int]]) -> int:\n        n , m = len(grid) , len(grid[0])\n        directions = [(1 , 0) ,(-1 , 0) ,(0 , 1) ,(0 , -1)]\n\n        def dfs(i , j):\n            if( i < 0 or i == n or \n               j < 0 or j == m or\n               grid[i][j] == 0): return 0\n\n            fish = grid[i][j]\n            print(fish)\n            grid[i][j] = 0\n            for x,y in directions:\n                self.res+=dfs(i+x , y+j)\n            return fish\n\n\n        mx = 0\n        for i in range(n):\n            for j in range(m):\n                if grid[i][j] > 0:\n                    self.res = grid[i][j]\n                    dfs(i , j)\n                    mx = max(mx , self.res )\n        return mx\n`\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your current DFS function doesn\\'t look for the optimal path. Instead, it traverses the grid in the order of the directions list, without considering which move would yield the most fish.\\n\\nA key part of this problem is that the fisher can choose the order of his moves optimally, meaning he doesn\\'t just go to the first non-zero cell he finds, but instead he should always move to the adjacent cell with the most fish.\\n\\nIn order to fix the function, you should change the DFS so that it always moves to the adjacent cell with the most fish. To do this, you should add a step to find the max fish in all adjacent cells, and only then call the DFS function recursively.\\n"
                    },
                    {
                        "username": "wataru",
                        "content": "In the dfs you return |fish| but you need to return sum of |fish| and the sum of recursive results."
                    }
                ]
            },
            {
                "id": 1877159,
                "content": [
                    {
                        "username": "15o1",
                        "content": "This should be a medium problem"
                    },
                    {
                        "username": "jameshsw",
                        "content": "The problem could use a clearer description, such as 'Return the maximum number of fish the fisher can catch \"in all the connected water cells\" if he chooses his starting cell optimally'"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "Yes this is important point to be noted."
                    },
                    {
                        "username": "adis176",
                        "content": "The question is really quite ambiguous. It needs to be defined properly. \\nThis test-case can help: \\n[[4, 5, 5], [0, 10, 0]] -> its correct answer will be 24.\\nHope this helps to clarify the problem."
                    },
                    {
                        "username": "ips2105",
                        "content": "Thought once you collect the fishes from a cell, you can\\'t come back. . The question should clarify this :("
                    },
                    {
                        "username": "adis176",
                        "content": "Actually you can. It is not DFS (traversal from start point to any one end, it is the complete traversal of all possible points from your chosen starting point. \\nThis question was in the biweekly contest 103, and initially I failed at the test-case [[4, 5, 5], [0, 10, 0]] -> Its correct answer was 24. \\nThough I agree that the question is quite ambiguous."
                    },
                    {
                        "username": "rishiagarwal-lc",
                        "content": "WTH! it must be ranked above hard, leetcode should ban such problem setters:)"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "It\\'s pretty much this problem, but with variable numbers instead of only 1\\'s: https://leetcode.com/problems/max-area-of-island/\\nI don\\'t see why the difficulty would be different. good BFS problem though."
                    },
                    {
                        "username": "amitbansal13",
                        "content": "There are medium classified problems much much harder than this. This is definitely wrongly classified."
                    },
                    {
                        "username": "MdoingIt",
                        "content": "poorly described statement"
                    },
                    {
                        "username": "gadmo",
                        "content": "that should be easy level just saying, literally 2 minutes start to working submission , cant get more straight forward dfs than this ."
                    },
                    {
                        "username": "Mohamed_1",
                        "content": "why this code wrong at this case ! \n[[6,1,10]]  \n`\n\n    def findMaxFish(self, grid: List[List[int]]) -> int:\n        n , m = len(grid) , len(grid[0])\n        directions = [(1 , 0) ,(-1 , 0) ,(0 , 1) ,(0 , -1)]\n\n        def dfs(i , j):\n            if( i < 0 or i == n or \n               j < 0 or j == m or\n               grid[i][j] == 0): return 0\n\n            fish = grid[i][j]\n            print(fish)\n            grid[i][j] = 0\n            for x,y in directions:\n                self.res+=dfs(i+x , y+j)\n            return fish\n\n\n        mx = 0\n        for i in range(n):\n            for j in range(m):\n                if grid[i][j] > 0:\n                    self.res = grid[i][j]\n                    dfs(i , j)\n                    mx = max(mx , self.res )\n        return mx\n`\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your current DFS function doesn\\'t look for the optimal path. Instead, it traverses the grid in the order of the directions list, without considering which move would yield the most fish.\\n\\nA key part of this problem is that the fisher can choose the order of his moves optimally, meaning he doesn\\'t just go to the first non-zero cell he finds, but instead he should always move to the adjacent cell with the most fish.\\n\\nIn order to fix the function, you should change the DFS so that it always moves to the adjacent cell with the most fish. To do this, you should add a step to find the max fish in all adjacent cells, and only then call the DFS function recursively.\\n"
                    },
                    {
                        "username": "wataru",
                        "content": "In the dfs you return |fish| but you need to return sum of |fish| and the sum of recursive results."
                    }
                ]
            },
            {
                "id": 1877341,
                "content": [
                    {
                        "username": "15o1",
                        "content": "This should be a medium problem"
                    },
                    {
                        "username": "jameshsw",
                        "content": "The problem could use a clearer description, such as 'Return the maximum number of fish the fisher can catch \"in all the connected water cells\" if he chooses his starting cell optimally'"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "Yes this is important point to be noted."
                    },
                    {
                        "username": "adis176",
                        "content": "The question is really quite ambiguous. It needs to be defined properly. \\nThis test-case can help: \\n[[4, 5, 5], [0, 10, 0]] -> its correct answer will be 24.\\nHope this helps to clarify the problem."
                    },
                    {
                        "username": "ips2105",
                        "content": "Thought once you collect the fishes from a cell, you can\\'t come back. . The question should clarify this :("
                    },
                    {
                        "username": "adis176",
                        "content": "Actually you can. It is not DFS (traversal from start point to any one end, it is the complete traversal of all possible points from your chosen starting point. \\nThis question was in the biweekly contest 103, and initially I failed at the test-case [[4, 5, 5], [0, 10, 0]] -> Its correct answer was 24. \\nThough I agree that the question is quite ambiguous."
                    },
                    {
                        "username": "rishiagarwal-lc",
                        "content": "WTH! it must be ranked above hard, leetcode should ban such problem setters:)"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "It\\'s pretty much this problem, but with variable numbers instead of only 1\\'s: https://leetcode.com/problems/max-area-of-island/\\nI don\\'t see why the difficulty would be different. good BFS problem though."
                    },
                    {
                        "username": "amitbansal13",
                        "content": "There are medium classified problems much much harder than this. This is definitely wrongly classified."
                    },
                    {
                        "username": "MdoingIt",
                        "content": "poorly described statement"
                    },
                    {
                        "username": "gadmo",
                        "content": "that should be easy level just saying, literally 2 minutes start to working submission , cant get more straight forward dfs than this ."
                    },
                    {
                        "username": "Mohamed_1",
                        "content": "why this code wrong at this case ! \n[[6,1,10]]  \n`\n\n    def findMaxFish(self, grid: List[List[int]]) -> int:\n        n , m = len(grid) , len(grid[0])\n        directions = [(1 , 0) ,(-1 , 0) ,(0 , 1) ,(0 , -1)]\n\n        def dfs(i , j):\n            if( i < 0 or i == n or \n               j < 0 or j == m or\n               grid[i][j] == 0): return 0\n\n            fish = grid[i][j]\n            print(fish)\n            grid[i][j] = 0\n            for x,y in directions:\n                self.res+=dfs(i+x , y+j)\n            return fish\n\n\n        mx = 0\n        for i in range(n):\n            for j in range(m):\n                if grid[i][j] > 0:\n                    self.res = grid[i][j]\n                    dfs(i , j)\n                    mx = max(mx , self.res )\n        return mx\n`\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your current DFS function doesn\\'t look for the optimal path. Instead, it traverses the grid in the order of the directions list, without considering which move would yield the most fish.\\n\\nA key part of this problem is that the fisher can choose the order of his moves optimally, meaning he doesn\\'t just go to the first non-zero cell he finds, but instead he should always move to the adjacent cell with the most fish.\\n\\nIn order to fix the function, you should change the DFS so that it always moves to the adjacent cell with the most fish. To do this, you should add a step to find the max fish in all adjacent cells, and only then call the DFS function recursively.\\n"
                    },
                    {
                        "username": "wataru",
                        "content": "In the dfs you return |fish| but you need to return sum of |fish| and the sum of recursive results."
                    }
                ]
            },
            {
                "id": 1921099,
                "content": [
                    {
                        "username": "15o1",
                        "content": "This should be a medium problem"
                    },
                    {
                        "username": "jameshsw",
                        "content": "The problem could use a clearer description, such as 'Return the maximum number of fish the fisher can catch \"in all the connected water cells\" if he chooses his starting cell optimally'"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "Yes this is important point to be noted."
                    },
                    {
                        "username": "adis176",
                        "content": "The question is really quite ambiguous. It needs to be defined properly. \\nThis test-case can help: \\n[[4, 5, 5], [0, 10, 0]] -> its correct answer will be 24.\\nHope this helps to clarify the problem."
                    },
                    {
                        "username": "ips2105",
                        "content": "Thought once you collect the fishes from a cell, you can\\'t come back. . The question should clarify this :("
                    },
                    {
                        "username": "adis176",
                        "content": "Actually you can. It is not DFS (traversal from start point to any one end, it is the complete traversal of all possible points from your chosen starting point. \\nThis question was in the biweekly contest 103, and initially I failed at the test-case [[4, 5, 5], [0, 10, 0]] -> Its correct answer was 24. \\nThough I agree that the question is quite ambiguous."
                    },
                    {
                        "username": "rishiagarwal-lc",
                        "content": "WTH! it must be ranked above hard, leetcode should ban such problem setters:)"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "It\\'s pretty much this problem, but with variable numbers instead of only 1\\'s: https://leetcode.com/problems/max-area-of-island/\\nI don\\'t see why the difficulty would be different. good BFS problem though."
                    },
                    {
                        "username": "amitbansal13",
                        "content": "There are medium classified problems much much harder than this. This is definitely wrongly classified."
                    },
                    {
                        "username": "MdoingIt",
                        "content": "poorly described statement"
                    },
                    {
                        "username": "gadmo",
                        "content": "that should be easy level just saying, literally 2 minutes start to working submission , cant get more straight forward dfs than this ."
                    },
                    {
                        "username": "Mohamed_1",
                        "content": "why this code wrong at this case ! \n[[6,1,10]]  \n`\n\n    def findMaxFish(self, grid: List[List[int]]) -> int:\n        n , m = len(grid) , len(grid[0])\n        directions = [(1 , 0) ,(-1 , 0) ,(0 , 1) ,(0 , -1)]\n\n        def dfs(i , j):\n            if( i < 0 or i == n or \n               j < 0 or j == m or\n               grid[i][j] == 0): return 0\n\n            fish = grid[i][j]\n            print(fish)\n            grid[i][j] = 0\n            for x,y in directions:\n                self.res+=dfs(i+x , y+j)\n            return fish\n\n\n        mx = 0\n        for i in range(n):\n            for j in range(m):\n                if grid[i][j] > 0:\n                    self.res = grid[i][j]\n                    dfs(i , j)\n                    mx = max(mx , self.res )\n        return mx\n`\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your current DFS function doesn\\'t look for the optimal path. Instead, it traverses the grid in the order of the directions list, without considering which move would yield the most fish.\\n\\nA key part of this problem is that the fisher can choose the order of his moves optimally, meaning he doesn\\'t just go to the first non-zero cell he finds, but instead he should always move to the adjacent cell with the most fish.\\n\\nIn order to fix the function, you should change the DFS so that it always moves to the adjacent cell with the most fish. To do this, you should add a step to find the max fish in all adjacent cells, and only then call the DFS function recursively.\\n"
                    },
                    {
                        "username": "wataru",
                        "content": "In the dfs you return |fish| but you need to return sum of |fish| and the sum of recursive results."
                    }
                ]
            },
            {
                "id": 1894798,
                "content": [
                    {
                        "username": "15o1",
                        "content": "This should be a medium problem"
                    },
                    {
                        "username": "jameshsw",
                        "content": "The problem could use a clearer description, such as 'Return the maximum number of fish the fisher can catch \"in all the connected water cells\" if he chooses his starting cell optimally'"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "Yes this is important point to be noted."
                    },
                    {
                        "username": "adis176",
                        "content": "The question is really quite ambiguous. It needs to be defined properly. \\nThis test-case can help: \\n[[4, 5, 5], [0, 10, 0]] -> its correct answer will be 24.\\nHope this helps to clarify the problem."
                    },
                    {
                        "username": "ips2105",
                        "content": "Thought once you collect the fishes from a cell, you can\\'t come back. . The question should clarify this :("
                    },
                    {
                        "username": "adis176",
                        "content": "Actually you can. It is not DFS (traversal from start point to any one end, it is the complete traversal of all possible points from your chosen starting point. \\nThis question was in the biweekly contest 103, and initially I failed at the test-case [[4, 5, 5], [0, 10, 0]] -> Its correct answer was 24. \\nThough I agree that the question is quite ambiguous."
                    },
                    {
                        "username": "rishiagarwal-lc",
                        "content": "WTH! it must be ranked above hard, leetcode should ban such problem setters:)"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "It\\'s pretty much this problem, but with variable numbers instead of only 1\\'s: https://leetcode.com/problems/max-area-of-island/\\nI don\\'t see why the difficulty would be different. good BFS problem though."
                    },
                    {
                        "username": "amitbansal13",
                        "content": "There are medium classified problems much much harder than this. This is definitely wrongly classified."
                    },
                    {
                        "username": "MdoingIt",
                        "content": "poorly described statement"
                    },
                    {
                        "username": "gadmo",
                        "content": "that should be easy level just saying, literally 2 minutes start to working submission , cant get more straight forward dfs than this ."
                    },
                    {
                        "username": "Mohamed_1",
                        "content": "why this code wrong at this case ! \n[[6,1,10]]  \n`\n\n    def findMaxFish(self, grid: List[List[int]]) -> int:\n        n , m = len(grid) , len(grid[0])\n        directions = [(1 , 0) ,(-1 , 0) ,(0 , 1) ,(0 , -1)]\n\n        def dfs(i , j):\n            if( i < 0 or i == n or \n               j < 0 or j == m or\n               grid[i][j] == 0): return 0\n\n            fish = grid[i][j]\n            print(fish)\n            grid[i][j] = 0\n            for x,y in directions:\n                self.res+=dfs(i+x , y+j)\n            return fish\n\n\n        mx = 0\n        for i in range(n):\n            for j in range(m):\n                if grid[i][j] > 0:\n                    self.res = grid[i][j]\n                    dfs(i , j)\n                    mx = max(mx , self.res )\n        return mx\n`\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your current DFS function doesn\\'t look for the optimal path. Instead, it traverses the grid in the order of the directions list, without considering which move would yield the most fish.\\n\\nA key part of this problem is that the fisher can choose the order of his moves optimally, meaning he doesn\\'t just go to the first non-zero cell he finds, but instead he should always move to the adjacent cell with the most fish.\\n\\nIn order to fix the function, you should change the DFS so that it always moves to the adjacent cell with the most fish. To do this, you should add a step to find the max fish in all adjacent cells, and only then call the DFS function recursively.\\n"
                    },
                    {
                        "username": "wataru",
                        "content": "In the dfs you return |fish| but you need to return sum of |fish| and the sum of recursive results."
                    }
                ]
            },
            {
                "id": 1877371,
                "content": [
                    {
                        "username": "15o1",
                        "content": "This should be a medium problem"
                    },
                    {
                        "username": "jameshsw",
                        "content": "The problem could use a clearer description, such as 'Return the maximum number of fish the fisher can catch \"in all the connected water cells\" if he chooses his starting cell optimally'"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "Yes this is important point to be noted."
                    },
                    {
                        "username": "adis176",
                        "content": "The question is really quite ambiguous. It needs to be defined properly. \\nThis test-case can help: \\n[[4, 5, 5], [0, 10, 0]] -> its correct answer will be 24.\\nHope this helps to clarify the problem."
                    },
                    {
                        "username": "ips2105",
                        "content": "Thought once you collect the fishes from a cell, you can\\'t come back. . The question should clarify this :("
                    },
                    {
                        "username": "adis176",
                        "content": "Actually you can. It is not DFS (traversal from start point to any one end, it is the complete traversal of all possible points from your chosen starting point. \\nThis question was in the biweekly contest 103, and initially I failed at the test-case [[4, 5, 5], [0, 10, 0]] -> Its correct answer was 24. \\nThough I agree that the question is quite ambiguous."
                    },
                    {
                        "username": "rishiagarwal-lc",
                        "content": "WTH! it must be ranked above hard, leetcode should ban such problem setters:)"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "It\\'s pretty much this problem, but with variable numbers instead of only 1\\'s: https://leetcode.com/problems/max-area-of-island/\\nI don\\'t see why the difficulty would be different. good BFS problem though."
                    },
                    {
                        "username": "amitbansal13",
                        "content": "There are medium classified problems much much harder than this. This is definitely wrongly classified."
                    },
                    {
                        "username": "MdoingIt",
                        "content": "poorly described statement"
                    },
                    {
                        "username": "gadmo",
                        "content": "that should be easy level just saying, literally 2 minutes start to working submission , cant get more straight forward dfs than this ."
                    },
                    {
                        "username": "Mohamed_1",
                        "content": "why this code wrong at this case ! \n[[6,1,10]]  \n`\n\n    def findMaxFish(self, grid: List[List[int]]) -> int:\n        n , m = len(grid) , len(grid[0])\n        directions = [(1 , 0) ,(-1 , 0) ,(0 , 1) ,(0 , -1)]\n\n        def dfs(i , j):\n            if( i < 0 or i == n or \n               j < 0 or j == m or\n               grid[i][j] == 0): return 0\n\n            fish = grid[i][j]\n            print(fish)\n            grid[i][j] = 0\n            for x,y in directions:\n                self.res+=dfs(i+x , y+j)\n            return fish\n\n\n        mx = 0\n        for i in range(n):\n            for j in range(m):\n                if grid[i][j] > 0:\n                    self.res = grid[i][j]\n                    dfs(i , j)\n                    mx = max(mx , self.res )\n        return mx\n`\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your current DFS function doesn\\'t look for the optimal path. Instead, it traverses the grid in the order of the directions list, without considering which move would yield the most fish.\\n\\nA key part of this problem is that the fisher can choose the order of his moves optimally, meaning he doesn\\'t just go to the first non-zero cell he finds, but instead he should always move to the adjacent cell with the most fish.\\n\\nIn order to fix the function, you should change the DFS so that it always moves to the adjacent cell with the most fish. To do this, you should add a step to find the max fish in all adjacent cells, and only then call the DFS function recursively.\\n"
                    },
                    {
                        "username": "wataru",
                        "content": "In the dfs you return |fish| but you need to return sum of |fish| and the sum of recursive results."
                    }
                ]
            },
            {
                "id": 1877160,
                "content": [
                    {
                        "username": "15o1",
                        "content": "This should be a medium problem"
                    },
                    {
                        "username": "jameshsw",
                        "content": "The problem could use a clearer description, such as 'Return the maximum number of fish the fisher can catch \"in all the connected water cells\" if he chooses his starting cell optimally'"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "Yes this is important point to be noted."
                    },
                    {
                        "username": "adis176",
                        "content": "The question is really quite ambiguous. It needs to be defined properly. \\nThis test-case can help: \\n[[4, 5, 5], [0, 10, 0]] -> its correct answer will be 24.\\nHope this helps to clarify the problem."
                    },
                    {
                        "username": "ips2105",
                        "content": "Thought once you collect the fishes from a cell, you can\\'t come back. . The question should clarify this :("
                    },
                    {
                        "username": "adis176",
                        "content": "Actually you can. It is not DFS (traversal from start point to any one end, it is the complete traversal of all possible points from your chosen starting point. \\nThis question was in the biweekly contest 103, and initially I failed at the test-case [[4, 5, 5], [0, 10, 0]] -> Its correct answer was 24. \\nThough I agree that the question is quite ambiguous."
                    },
                    {
                        "username": "rishiagarwal-lc",
                        "content": "WTH! it must be ranked above hard, leetcode should ban such problem setters:)"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "It\\'s pretty much this problem, but with variable numbers instead of only 1\\'s: https://leetcode.com/problems/max-area-of-island/\\nI don\\'t see why the difficulty would be different. good BFS problem though."
                    },
                    {
                        "username": "amitbansal13",
                        "content": "There are medium classified problems much much harder than this. This is definitely wrongly classified."
                    },
                    {
                        "username": "MdoingIt",
                        "content": "poorly described statement"
                    },
                    {
                        "username": "gadmo",
                        "content": "that should be easy level just saying, literally 2 minutes start to working submission , cant get more straight forward dfs than this ."
                    },
                    {
                        "username": "Mohamed_1",
                        "content": "why this code wrong at this case ! \n[[6,1,10]]  \n`\n\n    def findMaxFish(self, grid: List[List[int]]) -> int:\n        n , m = len(grid) , len(grid[0])\n        directions = [(1 , 0) ,(-1 , 0) ,(0 , 1) ,(0 , -1)]\n\n        def dfs(i , j):\n            if( i < 0 or i == n or \n               j < 0 or j == m or\n               grid[i][j] == 0): return 0\n\n            fish = grid[i][j]\n            print(fish)\n            grid[i][j] = 0\n            for x,y in directions:\n                self.res+=dfs(i+x , y+j)\n            return fish\n\n\n        mx = 0\n        for i in range(n):\n            for j in range(m):\n                if grid[i][j] > 0:\n                    self.res = grid[i][j]\n                    dfs(i , j)\n                    mx = max(mx , self.res )\n        return mx\n`\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your current DFS function doesn\\'t look for the optimal path. Instead, it traverses the grid in the order of the directions list, without considering which move would yield the most fish.\\n\\nA key part of this problem is that the fisher can choose the order of his moves optimally, meaning he doesn\\'t just go to the first non-zero cell he finds, but instead he should always move to the adjacent cell with the most fish.\\n\\nIn order to fix the function, you should change the DFS so that it always moves to the adjacent cell with the most fish. To do this, you should add a step to find the max fish in all adjacent cells, and only then call the DFS function recursively.\\n"
                    },
                    {
                        "username": "wataru",
                        "content": "In the dfs you return |fish| but you need to return sum of |fish| and the sum of recursive results."
                    }
                ]
            },
            {
                "id": 1877329,
                "content": [
                    {
                        "username": "15o1",
                        "content": "This should be a medium problem"
                    },
                    {
                        "username": "jameshsw",
                        "content": "The problem could use a clearer description, such as 'Return the maximum number of fish the fisher can catch \"in all the connected water cells\" if he chooses his starting cell optimally'"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "Yes this is important point to be noted."
                    },
                    {
                        "username": "adis176",
                        "content": "The question is really quite ambiguous. It needs to be defined properly. \\nThis test-case can help: \\n[[4, 5, 5], [0, 10, 0]] -> its correct answer will be 24.\\nHope this helps to clarify the problem."
                    },
                    {
                        "username": "ips2105",
                        "content": "Thought once you collect the fishes from a cell, you can\\'t come back. . The question should clarify this :("
                    },
                    {
                        "username": "adis176",
                        "content": "Actually you can. It is not DFS (traversal from start point to any one end, it is the complete traversal of all possible points from your chosen starting point. \\nThis question was in the biweekly contest 103, and initially I failed at the test-case [[4, 5, 5], [0, 10, 0]] -> Its correct answer was 24. \\nThough I agree that the question is quite ambiguous."
                    },
                    {
                        "username": "rishiagarwal-lc",
                        "content": "WTH! it must be ranked above hard, leetcode should ban such problem setters:)"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "It\\'s pretty much this problem, but with variable numbers instead of only 1\\'s: https://leetcode.com/problems/max-area-of-island/\\nI don\\'t see why the difficulty would be different. good BFS problem though."
                    },
                    {
                        "username": "amitbansal13",
                        "content": "There are medium classified problems much much harder than this. This is definitely wrongly classified."
                    },
                    {
                        "username": "MdoingIt",
                        "content": "poorly described statement"
                    },
                    {
                        "username": "gadmo",
                        "content": "that should be easy level just saying, literally 2 minutes start to working submission , cant get more straight forward dfs than this ."
                    },
                    {
                        "username": "Mohamed_1",
                        "content": "why this code wrong at this case ! \n[[6,1,10]]  \n`\n\n    def findMaxFish(self, grid: List[List[int]]) -> int:\n        n , m = len(grid) , len(grid[0])\n        directions = [(1 , 0) ,(-1 , 0) ,(0 , 1) ,(0 , -1)]\n\n        def dfs(i , j):\n            if( i < 0 or i == n or \n               j < 0 or j == m or\n               grid[i][j] == 0): return 0\n\n            fish = grid[i][j]\n            print(fish)\n            grid[i][j] = 0\n            for x,y in directions:\n                self.res+=dfs(i+x , y+j)\n            return fish\n\n\n        mx = 0\n        for i in range(n):\n            for j in range(m):\n                if grid[i][j] > 0:\n                    self.res = grid[i][j]\n                    dfs(i , j)\n                    mx = max(mx , self.res )\n        return mx\n`\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your current DFS function doesn\\'t look for the optimal path. Instead, it traverses the grid in the order of the directions list, without considering which move would yield the most fish.\\n\\nA key part of this problem is that the fisher can choose the order of his moves optimally, meaning he doesn\\'t just go to the first non-zero cell he finds, but instead he should always move to the adjacent cell with the most fish.\\n\\nIn order to fix the function, you should change the DFS so that it always moves to the adjacent cell with the most fish. To do this, you should add a step to find the max fish in all adjacent cells, and only then call the DFS function recursively.\\n"
                    },
                    {
                        "username": "wataru",
                        "content": "In the dfs you return |fish| but you need to return sum of |fish| and the sum of recursive results."
                    }
                ]
            },
            {
                "id": 1878212,
                "content": [
                    {
                        "username": "15o1",
                        "content": "This should be a medium problem"
                    },
                    {
                        "username": "jameshsw",
                        "content": "The problem could use a clearer description, such as 'Return the maximum number of fish the fisher can catch \"in all the connected water cells\" if he chooses his starting cell optimally'"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "Yes this is important point to be noted."
                    },
                    {
                        "username": "adis176",
                        "content": "The question is really quite ambiguous. It needs to be defined properly. \\nThis test-case can help: \\n[[4, 5, 5], [0, 10, 0]] -> its correct answer will be 24.\\nHope this helps to clarify the problem."
                    },
                    {
                        "username": "ips2105",
                        "content": "Thought once you collect the fishes from a cell, you can\\'t come back. . The question should clarify this :("
                    },
                    {
                        "username": "adis176",
                        "content": "Actually you can. It is not DFS (traversal from start point to any one end, it is the complete traversal of all possible points from your chosen starting point. \\nThis question was in the biweekly contest 103, and initially I failed at the test-case [[4, 5, 5], [0, 10, 0]] -> Its correct answer was 24. \\nThough I agree that the question is quite ambiguous."
                    },
                    {
                        "username": "rishiagarwal-lc",
                        "content": "WTH! it must be ranked above hard, leetcode should ban such problem setters:)"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "It\\'s pretty much this problem, but with variable numbers instead of only 1\\'s: https://leetcode.com/problems/max-area-of-island/\\nI don\\'t see why the difficulty would be different. good BFS problem though."
                    },
                    {
                        "username": "amitbansal13",
                        "content": "There are medium classified problems much much harder than this. This is definitely wrongly classified."
                    },
                    {
                        "username": "MdoingIt",
                        "content": "poorly described statement"
                    },
                    {
                        "username": "gadmo",
                        "content": "that should be easy level just saying, literally 2 minutes start to working submission , cant get more straight forward dfs than this ."
                    },
                    {
                        "username": "Mohamed_1",
                        "content": "why this code wrong at this case ! \n[[6,1,10]]  \n`\n\n    def findMaxFish(self, grid: List[List[int]]) -> int:\n        n , m = len(grid) , len(grid[0])\n        directions = [(1 , 0) ,(-1 , 0) ,(0 , 1) ,(0 , -1)]\n\n        def dfs(i , j):\n            if( i < 0 or i == n or \n               j < 0 or j == m or\n               grid[i][j] == 0): return 0\n\n            fish = grid[i][j]\n            print(fish)\n            grid[i][j] = 0\n            for x,y in directions:\n                self.res+=dfs(i+x , y+j)\n            return fish\n\n\n        mx = 0\n        for i in range(n):\n            for j in range(m):\n                if grid[i][j] > 0:\n                    self.res = grid[i][j]\n                    dfs(i , j)\n                    mx = max(mx , self.res )\n        return mx\n`\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your current DFS function doesn\\'t look for the optimal path. Instead, it traverses the grid in the order of the directions list, without considering which move would yield the most fish.\\n\\nA key part of this problem is that the fisher can choose the order of his moves optimally, meaning he doesn\\'t just go to the first non-zero cell he finds, but instead he should always move to the adjacent cell with the most fish.\\n\\nIn order to fix the function, you should change the DFS so that it always moves to the adjacent cell with the most fish. To do this, you should add a step to find the max fish in all adjacent cells, and only then call the DFS function recursively.\\n"
                    },
                    {
                        "username": "wataru",
                        "content": "In the dfs you return |fish| but you need to return sum of |fish| and the sum of recursive results."
                    }
                ]
            },
            {
                "id": 1877308,
                "content": [
                    {
                        "username": "15o1",
                        "content": "This should be a medium problem"
                    },
                    {
                        "username": "jameshsw",
                        "content": "The problem could use a clearer description, such as 'Return the maximum number of fish the fisher can catch \"in all the connected water cells\" if he chooses his starting cell optimally'"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "Yes this is important point to be noted."
                    },
                    {
                        "username": "adis176",
                        "content": "The question is really quite ambiguous. It needs to be defined properly. \\nThis test-case can help: \\n[[4, 5, 5], [0, 10, 0]] -> its correct answer will be 24.\\nHope this helps to clarify the problem."
                    },
                    {
                        "username": "ips2105",
                        "content": "Thought once you collect the fishes from a cell, you can\\'t come back. . The question should clarify this :("
                    },
                    {
                        "username": "adis176",
                        "content": "Actually you can. It is not DFS (traversal from start point to any one end, it is the complete traversal of all possible points from your chosen starting point. \\nThis question was in the biweekly contest 103, and initially I failed at the test-case [[4, 5, 5], [0, 10, 0]] -> Its correct answer was 24. \\nThough I agree that the question is quite ambiguous."
                    },
                    {
                        "username": "rishiagarwal-lc",
                        "content": "WTH! it must be ranked above hard, leetcode should ban such problem setters:)"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "It\\'s pretty much this problem, but with variable numbers instead of only 1\\'s: https://leetcode.com/problems/max-area-of-island/\\nI don\\'t see why the difficulty would be different. good BFS problem though."
                    },
                    {
                        "username": "amitbansal13",
                        "content": "There are medium classified problems much much harder than this. This is definitely wrongly classified."
                    },
                    {
                        "username": "MdoingIt",
                        "content": "poorly described statement"
                    },
                    {
                        "username": "gadmo",
                        "content": "that should be easy level just saying, literally 2 minutes start to working submission , cant get more straight forward dfs than this ."
                    },
                    {
                        "username": "Mohamed_1",
                        "content": "why this code wrong at this case ! \n[[6,1,10]]  \n`\n\n    def findMaxFish(self, grid: List[List[int]]) -> int:\n        n , m = len(grid) , len(grid[0])\n        directions = [(1 , 0) ,(-1 , 0) ,(0 , 1) ,(0 , -1)]\n\n        def dfs(i , j):\n            if( i < 0 or i == n or \n               j < 0 or j == m or\n               grid[i][j] == 0): return 0\n\n            fish = grid[i][j]\n            print(fish)\n            grid[i][j] = 0\n            for x,y in directions:\n                self.res+=dfs(i+x , y+j)\n            return fish\n\n\n        mx = 0\n        for i in range(n):\n            for j in range(m):\n                if grid[i][j] > 0:\n                    self.res = grid[i][j]\n                    dfs(i , j)\n                    mx = max(mx , self.res )\n        return mx\n`\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your current DFS function doesn\\'t look for the optimal path. Instead, it traverses the grid in the order of the directions list, without considering which move would yield the most fish.\\n\\nA key part of this problem is that the fisher can choose the order of his moves optimally, meaning he doesn\\'t just go to the first non-zero cell he finds, but instead he should always move to the adjacent cell with the most fish.\\n\\nIn order to fix the function, you should change the DFS so that it always moves to the adjacent cell with the most fish. To do this, you should add a step to find the max fish in all adjacent cells, and only then call the DFS function recursively.\\n"
                    },
                    {
                        "username": "wataru",
                        "content": "In the dfs you return |fish| but you need to return sum of |fish| and the sum of recursive results."
                    }
                ]
            },
            {
                "id": 1877396,
                "content": [
                    {
                        "username": "15o1",
                        "content": "This should be a medium problem"
                    },
                    {
                        "username": "jameshsw",
                        "content": "The problem could use a clearer description, such as 'Return the maximum number of fish the fisher can catch \"in all the connected water cells\" if he chooses his starting cell optimally'"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "Yes this is important point to be noted."
                    },
                    {
                        "username": "adis176",
                        "content": "The question is really quite ambiguous. It needs to be defined properly. \\nThis test-case can help: \\n[[4, 5, 5], [0, 10, 0]] -> its correct answer will be 24.\\nHope this helps to clarify the problem."
                    },
                    {
                        "username": "ips2105",
                        "content": "Thought once you collect the fishes from a cell, you can\\'t come back. . The question should clarify this :("
                    },
                    {
                        "username": "adis176",
                        "content": "Actually you can. It is not DFS (traversal from start point to any one end, it is the complete traversal of all possible points from your chosen starting point. \\nThis question was in the biweekly contest 103, and initially I failed at the test-case [[4, 5, 5], [0, 10, 0]] -> Its correct answer was 24. \\nThough I agree that the question is quite ambiguous."
                    },
                    {
                        "username": "rishiagarwal-lc",
                        "content": "WTH! it must be ranked above hard, leetcode should ban such problem setters:)"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "It\\'s pretty much this problem, but with variable numbers instead of only 1\\'s: https://leetcode.com/problems/max-area-of-island/\\nI don\\'t see why the difficulty would be different. good BFS problem though."
                    },
                    {
                        "username": "amitbansal13",
                        "content": "There are medium classified problems much much harder than this. This is definitely wrongly classified."
                    },
                    {
                        "username": "MdoingIt",
                        "content": "poorly described statement"
                    },
                    {
                        "username": "gadmo",
                        "content": "that should be easy level just saying, literally 2 minutes start to working submission , cant get more straight forward dfs than this ."
                    },
                    {
                        "username": "Mohamed_1",
                        "content": "why this code wrong at this case ! \n[[6,1,10]]  \n`\n\n    def findMaxFish(self, grid: List[List[int]]) -> int:\n        n , m = len(grid) , len(grid[0])\n        directions = [(1 , 0) ,(-1 , 0) ,(0 , 1) ,(0 , -1)]\n\n        def dfs(i , j):\n            if( i < 0 or i == n or \n               j < 0 or j == m or\n               grid[i][j] == 0): return 0\n\n            fish = grid[i][j]\n            print(fish)\n            grid[i][j] = 0\n            for x,y in directions:\n                self.res+=dfs(i+x , y+j)\n            return fish\n\n\n        mx = 0\n        for i in range(n):\n            for j in range(m):\n                if grid[i][j] > 0:\n                    self.res = grid[i][j]\n                    dfs(i , j)\n                    mx = max(mx , self.res )\n        return mx\n`\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your current DFS function doesn\\'t look for the optimal path. Instead, it traverses the grid in the order of the directions list, without considering which move would yield the most fish.\\n\\nA key part of this problem is that the fisher can choose the order of his moves optimally, meaning he doesn\\'t just go to the first non-zero cell he finds, but instead he should always move to the adjacent cell with the most fish.\\n\\nIn order to fix the function, you should change the DFS so that it always moves to the adjacent cell with the most fish. To do this, you should add a step to find the max fish in all adjacent cells, and only then call the DFS function recursively.\\n"
                    },
                    {
                        "username": "wataru",
                        "content": "In the dfs you return |fish| but you need to return sum of |fish| and the sum of recursive results."
                    }
                ]
            },
            {
                "id": 1877159,
                "content": [
                    {
                        "username": "15o1",
                        "content": "This should be a medium problem"
                    },
                    {
                        "username": "jameshsw",
                        "content": "The problem could use a clearer description, such as 'Return the maximum number of fish the fisher can catch \"in all the connected water cells\" if he chooses his starting cell optimally'"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "Yes this is important point to be noted."
                    },
                    {
                        "username": "adis176",
                        "content": "The question is really quite ambiguous. It needs to be defined properly. \\nThis test-case can help: \\n[[4, 5, 5], [0, 10, 0]] -> its correct answer will be 24.\\nHope this helps to clarify the problem."
                    },
                    {
                        "username": "ips2105",
                        "content": "Thought once you collect the fishes from a cell, you can\\'t come back. . The question should clarify this :("
                    },
                    {
                        "username": "adis176",
                        "content": "Actually you can. It is not DFS (traversal from start point to any one end, it is the complete traversal of all possible points from your chosen starting point. \\nThis question was in the biweekly contest 103, and initially I failed at the test-case [[4, 5, 5], [0, 10, 0]] -> Its correct answer was 24. \\nThough I agree that the question is quite ambiguous."
                    },
                    {
                        "username": "rishiagarwal-lc",
                        "content": "WTH! it must be ranked above hard, leetcode should ban such problem setters:)"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "It\\'s pretty much this problem, but with variable numbers instead of only 1\\'s: https://leetcode.com/problems/max-area-of-island/\\nI don\\'t see why the difficulty would be different. good BFS problem though."
                    },
                    {
                        "username": "amitbansal13",
                        "content": "There are medium classified problems much much harder than this. This is definitely wrongly classified."
                    },
                    {
                        "username": "MdoingIt",
                        "content": "poorly described statement"
                    },
                    {
                        "username": "gadmo",
                        "content": "that should be easy level just saying, literally 2 minutes start to working submission , cant get more straight forward dfs than this ."
                    },
                    {
                        "username": "Mohamed_1",
                        "content": "why this code wrong at this case ! \n[[6,1,10]]  \n`\n\n    def findMaxFish(self, grid: List[List[int]]) -> int:\n        n , m = len(grid) , len(grid[0])\n        directions = [(1 , 0) ,(-1 , 0) ,(0 , 1) ,(0 , -1)]\n\n        def dfs(i , j):\n            if( i < 0 or i == n or \n               j < 0 or j == m or\n               grid[i][j] == 0): return 0\n\n            fish = grid[i][j]\n            print(fish)\n            grid[i][j] = 0\n            for x,y in directions:\n                self.res+=dfs(i+x , y+j)\n            return fish\n\n\n        mx = 0\n        for i in range(n):\n            for j in range(m):\n                if grid[i][j] > 0:\n                    self.res = grid[i][j]\n                    dfs(i , j)\n                    mx = max(mx , self.res )\n        return mx\n`\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your current DFS function doesn\\'t look for the optimal path. Instead, it traverses the grid in the order of the directions list, without considering which move would yield the most fish.\\n\\nA key part of this problem is that the fisher can choose the order of his moves optimally, meaning he doesn\\'t just go to the first non-zero cell he finds, but instead he should always move to the adjacent cell with the most fish.\\n\\nIn order to fix the function, you should change the DFS so that it always moves to the adjacent cell with the most fish. To do this, you should add a step to find the max fish in all adjacent cells, and only then call the DFS function recursively.\\n"
                    },
                    {
                        "username": "wataru",
                        "content": "In the dfs you return |fish| but you need to return sum of |fish| and the sum of recursive results."
                    }
                ]
            },
            {
                "id": 1877341,
                "content": [
                    {
                        "username": "15o1",
                        "content": "This should be a medium problem"
                    },
                    {
                        "username": "jameshsw",
                        "content": "The problem could use a clearer description, such as 'Return the maximum number of fish the fisher can catch \"in all the connected water cells\" if he chooses his starting cell optimally'"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "Yes this is important point to be noted."
                    },
                    {
                        "username": "adis176",
                        "content": "The question is really quite ambiguous. It needs to be defined properly. \\nThis test-case can help: \\n[[4, 5, 5], [0, 10, 0]] -> its correct answer will be 24.\\nHope this helps to clarify the problem."
                    },
                    {
                        "username": "ips2105",
                        "content": "Thought once you collect the fishes from a cell, you can\\'t come back. . The question should clarify this :("
                    },
                    {
                        "username": "adis176",
                        "content": "Actually you can. It is not DFS (traversal from start point to any one end, it is the complete traversal of all possible points from your chosen starting point. \\nThis question was in the biweekly contest 103, and initially I failed at the test-case [[4, 5, 5], [0, 10, 0]] -> Its correct answer was 24. \\nThough I agree that the question is quite ambiguous."
                    },
                    {
                        "username": "rishiagarwal-lc",
                        "content": "WTH! it must be ranked above hard, leetcode should ban such problem setters:)"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "It\\'s pretty much this problem, but with variable numbers instead of only 1\\'s: https://leetcode.com/problems/max-area-of-island/\\nI don\\'t see why the difficulty would be different. good BFS problem though."
                    },
                    {
                        "username": "amitbansal13",
                        "content": "There are medium classified problems much much harder than this. This is definitely wrongly classified."
                    },
                    {
                        "username": "MdoingIt",
                        "content": "poorly described statement"
                    },
                    {
                        "username": "gadmo",
                        "content": "that should be easy level just saying, literally 2 minutes start to working submission , cant get more straight forward dfs than this ."
                    },
                    {
                        "username": "Mohamed_1",
                        "content": "why this code wrong at this case ! \n[[6,1,10]]  \n`\n\n    def findMaxFish(self, grid: List[List[int]]) -> int:\n        n , m = len(grid) , len(grid[0])\n        directions = [(1 , 0) ,(-1 , 0) ,(0 , 1) ,(0 , -1)]\n\n        def dfs(i , j):\n            if( i < 0 or i == n or \n               j < 0 or j == m or\n               grid[i][j] == 0): return 0\n\n            fish = grid[i][j]\n            print(fish)\n            grid[i][j] = 0\n            for x,y in directions:\n                self.res+=dfs(i+x , y+j)\n            return fish\n\n\n        mx = 0\n        for i in range(n):\n            for j in range(m):\n                if grid[i][j] > 0:\n                    self.res = grid[i][j]\n                    dfs(i , j)\n                    mx = max(mx , self.res )\n        return mx\n`\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your current DFS function doesn\\'t look for the optimal path. Instead, it traverses the grid in the order of the directions list, without considering which move would yield the most fish.\\n\\nA key part of this problem is that the fisher can choose the order of his moves optimally, meaning he doesn\\'t just go to the first non-zero cell he finds, but instead he should always move to the adjacent cell with the most fish.\\n\\nIn order to fix the function, you should change the DFS so that it always moves to the adjacent cell with the most fish. To do this, you should add a step to find the max fish in all adjacent cells, and only then call the DFS function recursively.\\n"
                    },
                    {
                        "username": "wataru",
                        "content": "In the dfs you return |fish| but you need to return sum of |fish| and the sum of recursive results."
                    }
                ]
            },
            {
                "id": 1921099,
                "content": [
                    {
                        "username": "15o1",
                        "content": "This should be a medium problem"
                    },
                    {
                        "username": "jameshsw",
                        "content": "The problem could use a clearer description, such as 'Return the maximum number of fish the fisher can catch \"in all the connected water cells\" if he chooses his starting cell optimally'"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "Yes this is important point to be noted."
                    },
                    {
                        "username": "adis176",
                        "content": "The question is really quite ambiguous. It needs to be defined properly. \\nThis test-case can help: \\n[[4, 5, 5], [0, 10, 0]] -> its correct answer will be 24.\\nHope this helps to clarify the problem."
                    },
                    {
                        "username": "ips2105",
                        "content": "Thought once you collect the fishes from a cell, you can\\'t come back. . The question should clarify this :("
                    },
                    {
                        "username": "adis176",
                        "content": "Actually you can. It is not DFS (traversal from start point to any one end, it is the complete traversal of all possible points from your chosen starting point. \\nThis question was in the biweekly contest 103, and initially I failed at the test-case [[4, 5, 5], [0, 10, 0]] -> Its correct answer was 24. \\nThough I agree that the question is quite ambiguous."
                    },
                    {
                        "username": "rishiagarwal-lc",
                        "content": "WTH! it must be ranked above hard, leetcode should ban such problem setters:)"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "It\\'s pretty much this problem, but with variable numbers instead of only 1\\'s: https://leetcode.com/problems/max-area-of-island/\\nI don\\'t see why the difficulty would be different. good BFS problem though."
                    },
                    {
                        "username": "amitbansal13",
                        "content": "There are medium classified problems much much harder than this. This is definitely wrongly classified."
                    },
                    {
                        "username": "MdoingIt",
                        "content": "poorly described statement"
                    },
                    {
                        "username": "gadmo",
                        "content": "that should be easy level just saying, literally 2 minutes start to working submission , cant get more straight forward dfs than this ."
                    },
                    {
                        "username": "Mohamed_1",
                        "content": "why this code wrong at this case ! \n[[6,1,10]]  \n`\n\n    def findMaxFish(self, grid: List[List[int]]) -> int:\n        n , m = len(grid) , len(grid[0])\n        directions = [(1 , 0) ,(-1 , 0) ,(0 , 1) ,(0 , -1)]\n\n        def dfs(i , j):\n            if( i < 0 or i == n or \n               j < 0 or j == m or\n               grid[i][j] == 0): return 0\n\n            fish = grid[i][j]\n            print(fish)\n            grid[i][j] = 0\n            for x,y in directions:\n                self.res+=dfs(i+x , y+j)\n            return fish\n\n\n        mx = 0\n        for i in range(n):\n            for j in range(m):\n                if grid[i][j] > 0:\n                    self.res = grid[i][j]\n                    dfs(i , j)\n                    mx = max(mx , self.res )\n        return mx\n`\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your current DFS function doesn\\'t look for the optimal path. Instead, it traverses the grid in the order of the directions list, without considering which move would yield the most fish.\\n\\nA key part of this problem is that the fisher can choose the order of his moves optimally, meaning he doesn\\'t just go to the first non-zero cell he finds, but instead he should always move to the adjacent cell with the most fish.\\n\\nIn order to fix the function, you should change the DFS so that it always moves to the adjacent cell with the most fish. To do this, you should add a step to find the max fish in all adjacent cells, and only then call the DFS function recursively.\\n"
                    },
                    {
                        "username": "wataru",
                        "content": "In the dfs you return |fish| but you need to return sum of |fish| and the sum of recursive results."
                    }
                ]
            },
            {
                "id": 1894798,
                "content": [
                    {
                        "username": "15o1",
                        "content": "This should be a medium problem"
                    },
                    {
                        "username": "jameshsw",
                        "content": "The problem could use a clearer description, such as 'Return the maximum number of fish the fisher can catch \"in all the connected water cells\" if he chooses his starting cell optimally'"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "Yes this is important point to be noted."
                    },
                    {
                        "username": "adis176",
                        "content": "The question is really quite ambiguous. It needs to be defined properly. \\nThis test-case can help: \\n[[4, 5, 5], [0, 10, 0]] -> its correct answer will be 24.\\nHope this helps to clarify the problem."
                    },
                    {
                        "username": "ips2105",
                        "content": "Thought once you collect the fishes from a cell, you can\\'t come back. . The question should clarify this :("
                    },
                    {
                        "username": "adis176",
                        "content": "Actually you can. It is not DFS (traversal from start point to any one end, it is the complete traversal of all possible points from your chosen starting point. \\nThis question was in the biweekly contest 103, and initially I failed at the test-case [[4, 5, 5], [0, 10, 0]] -> Its correct answer was 24. \\nThough I agree that the question is quite ambiguous."
                    },
                    {
                        "username": "rishiagarwal-lc",
                        "content": "WTH! it must be ranked above hard, leetcode should ban such problem setters:)"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "It\\'s pretty much this problem, but with variable numbers instead of only 1\\'s: https://leetcode.com/problems/max-area-of-island/\\nI don\\'t see why the difficulty would be different. good BFS problem though."
                    },
                    {
                        "username": "amitbansal13",
                        "content": "There are medium classified problems much much harder than this. This is definitely wrongly classified."
                    },
                    {
                        "username": "MdoingIt",
                        "content": "poorly described statement"
                    },
                    {
                        "username": "gadmo",
                        "content": "that should be easy level just saying, literally 2 minutes start to working submission , cant get more straight forward dfs than this ."
                    },
                    {
                        "username": "Mohamed_1",
                        "content": "why this code wrong at this case ! \n[[6,1,10]]  \n`\n\n    def findMaxFish(self, grid: List[List[int]]) -> int:\n        n , m = len(grid) , len(grid[0])\n        directions = [(1 , 0) ,(-1 , 0) ,(0 , 1) ,(0 , -1)]\n\n        def dfs(i , j):\n            if( i < 0 or i == n or \n               j < 0 or j == m or\n               grid[i][j] == 0): return 0\n\n            fish = grid[i][j]\n            print(fish)\n            grid[i][j] = 0\n            for x,y in directions:\n                self.res+=dfs(i+x , y+j)\n            return fish\n\n\n        mx = 0\n        for i in range(n):\n            for j in range(m):\n                if grid[i][j] > 0:\n                    self.res = grid[i][j]\n                    dfs(i , j)\n                    mx = max(mx , self.res )\n        return mx\n`\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your current DFS function doesn\\'t look for the optimal path. Instead, it traverses the grid in the order of the directions list, without considering which move would yield the most fish.\\n\\nA key part of this problem is that the fisher can choose the order of his moves optimally, meaning he doesn\\'t just go to the first non-zero cell he finds, but instead he should always move to the adjacent cell with the most fish.\\n\\nIn order to fix the function, you should change the DFS so that it always moves to the adjacent cell with the most fish. To do this, you should add a step to find the max fish in all adjacent cells, and only then call the DFS function recursively.\\n"
                    },
                    {
                        "username": "wataru",
                        "content": "In the dfs you return |fish| but you need to return sum of |fish| and the sum of recursive results."
                    }
                ]
            },
            {
                "id": 1877371,
                "content": [
                    {
                        "username": "15o1",
                        "content": "This should be a medium problem"
                    },
                    {
                        "username": "jameshsw",
                        "content": "The problem could use a clearer description, such as 'Return the maximum number of fish the fisher can catch \"in all the connected water cells\" if he chooses his starting cell optimally'"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "Yes this is important point to be noted."
                    },
                    {
                        "username": "adis176",
                        "content": "The question is really quite ambiguous. It needs to be defined properly. \\nThis test-case can help: \\n[[4, 5, 5], [0, 10, 0]] -> its correct answer will be 24.\\nHope this helps to clarify the problem."
                    },
                    {
                        "username": "ips2105",
                        "content": "Thought once you collect the fishes from a cell, you can\\'t come back. . The question should clarify this :("
                    },
                    {
                        "username": "adis176",
                        "content": "Actually you can. It is not DFS (traversal from start point to any one end, it is the complete traversal of all possible points from your chosen starting point. \\nThis question was in the biweekly contest 103, and initially I failed at the test-case [[4, 5, 5], [0, 10, 0]] -> Its correct answer was 24. \\nThough I agree that the question is quite ambiguous."
                    },
                    {
                        "username": "rishiagarwal-lc",
                        "content": "WTH! it must be ranked above hard, leetcode should ban such problem setters:)"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "It\\'s pretty much this problem, but with variable numbers instead of only 1\\'s: https://leetcode.com/problems/max-area-of-island/\\nI don\\'t see why the difficulty would be different. good BFS problem though."
                    },
                    {
                        "username": "amitbansal13",
                        "content": "There are medium classified problems much much harder than this. This is definitely wrongly classified."
                    },
                    {
                        "username": "MdoingIt",
                        "content": "poorly described statement"
                    },
                    {
                        "username": "gadmo",
                        "content": "that should be easy level just saying, literally 2 minutes start to working submission , cant get more straight forward dfs than this ."
                    },
                    {
                        "username": "Mohamed_1",
                        "content": "why this code wrong at this case ! \n[[6,1,10]]  \n`\n\n    def findMaxFish(self, grid: List[List[int]]) -> int:\n        n , m = len(grid) , len(grid[0])\n        directions = [(1 , 0) ,(-1 , 0) ,(0 , 1) ,(0 , -1)]\n\n        def dfs(i , j):\n            if( i < 0 or i == n or \n               j < 0 or j == m or\n               grid[i][j] == 0): return 0\n\n            fish = grid[i][j]\n            print(fish)\n            grid[i][j] = 0\n            for x,y in directions:\n                self.res+=dfs(i+x , y+j)\n            return fish\n\n\n        mx = 0\n        for i in range(n):\n            for j in range(m):\n                if grid[i][j] > 0:\n                    self.res = grid[i][j]\n                    dfs(i , j)\n                    mx = max(mx , self.res )\n        return mx\n`\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your current DFS function doesn\\'t look for the optimal path. Instead, it traverses the grid in the order of the directions list, without considering which move would yield the most fish.\\n\\nA key part of this problem is that the fisher can choose the order of his moves optimally, meaning he doesn\\'t just go to the first non-zero cell he finds, but instead he should always move to the adjacent cell with the most fish.\\n\\nIn order to fix the function, you should change the DFS so that it always moves to the adjacent cell with the most fish. To do this, you should add a step to find the max fish in all adjacent cells, and only then call the DFS function recursively.\\n"
                    },
                    {
                        "username": "wataru",
                        "content": "In the dfs you return |fish| but you need to return sum of |fish| and the sum of recursive results."
                    }
                ]
            }
        ]
    },
    {
        "title": "Make Costs of Paths Equal in a Binary Tree",
        "question_content": "<p>You are given an integer <code>n</code> representing the number of nodes in a <strong>perfect binary tree</strong> consisting of nodes numbered from <code>1</code> to <code>n</code>. The root of the tree is node <code>1</code> and each node <code>i</code> in the tree has two children where the left child is the node <code>2 * i</code> and the right child is <code>2 * i + 1</code>.</p>\n\n<p>Each node in the tree also has a <strong>cost</strong> represented by a given <strong>0-indexed</strong> integer array <code>cost</code> of size <code>n</code> where <code>cost[i]</code> is the cost of node <code>i + 1</code>. You are allowed to <strong>increment</strong> the cost of <strong>any</strong> node by <code>1</code> <strong>any</strong> number of times.</p>\n\n<p>Return <em>the <strong>minimum</strong> number of increments you need to make the cost of paths from the root to each <strong>leaf</strong> node equal</em>.</p>\n\n<p><strong>Note</strong>:</p>\n\n<ul>\n\t<li>A <strong>perfect binary tree </strong>is a tree where each node, except the leaf nodes, has exactly 2 children.</li>\n\t<li>The <strong>cost of a path</strong> is the sum of costs of nodes in the path.</li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2023/04/04/binaryytreeedrawio-4.png\" />\n<pre>\n<strong>Input:</strong> n = 7, cost = [1,5,2,2,3,3,1]\n<strong>Output:</strong> 6\n<strong>Explanation:</strong> We can do the following increments:\n- Increase the cost of node 4 one time.\n- Increase the cost of node 3 three times.\n- Increase the cost of node 7 two times.\nEach path from the root to a leaf will have a total cost of 9.\nThe total increments we did is 1 + 3 + 2 = 6.\nIt can be shown that this is the minimum answer we can achieve.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2023/04/04/binaryytreee2drawio.png\" style=\"width: 205px; height: 151px;\" />\n<pre>\n<strong>Input:</strong> n = 3, cost = [5,3,3]\n<strong>Output:</strong> 0\n<strong>Explanation:</strong> The two paths already have equal total costs, so no increments are needed.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>3 &lt;= n &lt;= 10<sup>5</sup></code></li>\n\t<li><code>n + 1</code> is a power of <code>2</code></li>\n\t<li><code>cost.length == n</code></li>\n\t<li><code>1 &lt;= cost[i] &lt;= 10<sup>4</sup></code></li>\n</ul>\n",
        "solutions": [
            {
                "id": 3494844,
                "title": "c-java-python3-short-dfs",
                "content": "\\n\\n# Intuition\\nWe can move level by level from the the leaves and make sure that the adjacent nodes have equal cost. First make the cost of adjacent leaves equal. Then move one level up. Make sure that the cost of the two children are equal and so on. If they are not equal just increment the node with the lower cost to make it equal to the other node.\\n\\n# Approach\\nUse `(2 * i + 1)` instead of `2 * i` for child node because `2 * i` will go into infinite loop when you run `dfs(0)`\\n\\n# Complexity\\n- Time complexity: O(n)\\n\\n- Space complexity: O(h)\\n\\n# Code\\n**Python3**:\\n```\\ndef minIncrements(self, n, cost):\\n    self.res = 0\\n    def dfs(i):\\n        if i >= len(cost): return 0\\n        a, b = dfs(2 * i + 1), dfs(2 * i + 2)\\n        self.res += abs(a - b)\\n        return cost[i] + max(a, b)\\n    dfs(0)\\n    return self.res\\n```\\n\\n**C++**:\\n```\\nint minIncrements(int n, vector<int>& cost) {\\n    int res = 0;\\n    function<int(int)> dfs = [&](int i) {\\n        if (i >= cost.size()) return 0;\\n        int a = dfs(2 * i + 1), b = dfs(2 * i + 2);\\n        res += abs(a - b);\\n        return cost[i] + max(a, b);\\n    };\\n    dfs(0);\\n    return res;\\n}\\n```\\n\\n**Java**:\\n```\\nint res = 0;\\npublic int minIncrements(int n, int[] cost) {\\n    dfs(0, cost);\\n    return res;\\n}\\nprivate int dfs(int i, int[] cost) {\\n    if (i >= cost.length) return 0;\\n    int a = dfs(2 * i + 1, cost), b = dfs(2 * i + 2, cost);\\n    res += Math.abs(a - b);\\n    return cost[i] + Math.max(a, b);\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3"
                ],
                "code": "```\\ndef minIncrements(self, n, cost):\\n    self.res = 0\\n    def dfs(i):\\n        if i >= len(cost): return 0\\n        a, b = dfs(2 * i + 1), dfs(2 * i + 2)\\n        self.res += abs(a - b)\\n        return cost[i] + max(a, b)\\n    dfs(0)\\n    return self.res\\n```\n```\\nint minIncrements(int n, vector<int>& cost) {\\n    int res = 0;\\n    function<int(int)> dfs = [&](int i) {\\n        if (i >= cost.size()) return 0;\\n        int a = dfs(2 * i + 1), b = dfs(2 * i + 2);\\n        res += abs(a - b);\\n        return cost[i] + max(a, b);\\n    };\\n    dfs(0);\\n    return res;\\n}\\n```\n```\\nint res = 0;\\npublic int minIncrements(int n, int[] cost) {\\n    dfs(0, cost);\\n    return res;\\n}\\nprivate int dfs(int i, int[] cost) {\\n    if (i >= cost.length) return 0;\\n    int a = dfs(2 * i + 1, cost), b = dfs(2 * i + 2, cost);\\n    res += Math.abs(a - b);\\n    return cost[i] + Math.max(a, b);\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3494915,
                "title": "java-c-python-bottom-up-and-follow-up",
                "content": "# Solution: Bottom Up\\nBottom up iterate the whole tree.\\nFor each node `i`, compare its two children `left` and `right`.\\nThe smaller child needs to catch up the bigger child,\\nso we increment `res += abs(A[left] - A[right])`,\\nthen we update `A[i] += max(A[left], A[right]`,\\nand `A[i]` present minimum cost from node `i` to any leaf.\\n\\nWe continue iterate the whole tree and finally return result `res`\\n<br>\\n\\n# **Complexity**\\nTime `O(n)`\\nSpace `O(1)`\\n\\nActually space `O(n)`,\\nsince needs to save result for each node,\\nI overwrite the input in the solutions.\\nDFS recursion requires only `O(logn)` space.\\n<br>\\n\\n**Java**\\n```java\\n    public int minIncrements(int n, int[] A) {\\n        int res = 0;\\n        for (int i = n / 2 - 1; i >= 0; --i) {\\n            int l = i * 2 + 1, r = i * 2 + 2;\\n            res += Math.abs(A[l] - A[r]);\\n            A[i] += Math.max(A[l], A[r]);\\n        }\\n        return res;\\n    }\\n```\\n\\n**C++**\\n```cpp\\n    int minIncrements(int n, vector<int>& A) {\\n        int res = 0;\\n        for (int i = n / 2 - 1; i >= 0; --i) {\\n            int l = i * 2 + 1, r = i * 2 + 2;\\n            res += abs(A[l] - A[r]);\\n            A[i] += max(A[l], A[r]);\\n        }\\n        return res;\\n    }\\n```\\n\\n**Python**\\n```py\\n    def minIncrements(self, n: int, A: List[int]) -> int:\\n        res = 0\\n        for i in range(n // 2 - 1, -1, -1):\\n            l, r = i * 2 + 1, i * 2 + 2\\n            res += abs(A[l] - A[r])\\n            A[i] += max(A[l], A[r])\\n        return res\\n```\\n<br>\\n\\n\\n# **Follow up**\\nYou are allowed to both **increment** or **decrement**\\nthe cost of any node by 1 any number of times.\\nWhat the result now?\\n\\nIn the previous,\\nwe only record the lower bound path value of each node,\\nnow it will be a range.\\nIf left path cost is 5,\\nand path cost is 10,\\nthen we can make them equal in `[5, 10]`.\\n\\nIf left path cost is in range `[2,4]`,\\nand path cost is in range `[10, 15]`,\\nthen we can make them equal in range `[4, 10]`,\\nextra steps is `10 - 4 = 6`\\n\\n\\nIf left path cost is `[2, 10]`,\\nand path cost is `[4, 15]`,\\nthen we can make them equal in `[4, 10]`,\\nno extra steps.\\n\\n",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C"
                ],
                "code": "```java\\n    public int minIncrements(int n, int[] A) {\\n        int res = 0;\\n        for (int i = n / 2 - 1; i >= 0; --i) {\\n            int l = i * 2 + 1, r = i * 2 + 2;\\n            res += Math.abs(A[l] - A[r]);\\n            A[i] += Math.max(A[l], A[r]);\\n        }\\n        return res;\\n    }\\n```\n```cpp\\n    int minIncrements(int n, vector<int>& A) {\\n        int res = 0;\\n        for (int i = n / 2 - 1; i >= 0; --i) {\\n            int l = i * 2 + 1, r = i * 2 + 2;\\n            res += abs(A[l] - A[r]);\\n            A[i] += max(A[l], A[r]);\\n        }\\n        return res;\\n    }\\n```\n```py\\n    def minIncrements(self, n: int, A: List[int]) -> int:\\n        res = 0\\n        for i in range(n // 2 - 1, -1, -1):\\n            l, r = i * 2 + 1, i * 2 + 2\\n            res += abs(A[l] - A[r])\\n            A[i] += max(A[l], A[r])\\n        return res\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3495321,
                "title": "clearly-illustrated-dfs-proof-of-correctness",
                "content": "Many solutions show the right way to do it but do not prove that it is correct, and do not explain why this is the optimal way. Let\\'s do it!\\n\\n# Intuition\\n\\nWe want our binary tree to verify the equal path property (the cost to go from root to any leaf has to be the same). I will call a binary tree which verifies this property **balanced**.\\nThe key logic is the following:\\n\\n**The optimal strategy is to ensure every subtree is balanced**\\n\\nWhy is this true? Well, let\\u2019s imagine that there is a subtree rooted at a node `subroot` which is unbalanced. That is to say it can reach a certain `leaf1` for `lowcost`, and another `leaf2` for a different `highcost`.\\nWell, in that case, its parent node will reach `leaf1` for `lowcost+cost[subroot]` and `leaf2` for `highcost+cost[subroot]`, which are different costs. We see that the unbalanced property is recursive: if any subtree is unbalanced, it will \\u201Ccontaminate\\u201D the parent.\\n\\n![illustration cost path tree.png](https://assets.leetcode.com/users/images/56b9ad51-e064-459f-a063-513c10ce5d02_1683437244.2906523.png)\\n\\n\\n\\nTherefore, if we want to balance `root`, it is necessary to balance *every subroot* on its way. It is easy to verify that this is also a sufficient condition. **So this is the optimal way to do it, because it is in fact kinda the only way to do it!** (root is balanced *if and only if* all of the subtrees are balanced). We just need to balance every subtree in the least number of operations\\n\\nThat begs for a recursive approach! If we ensure starting from every leaf, that every subtree is balanced, then it\\u2019s easy to make the optimal corrections to balance the parent too!\\n\\n\\n# Approach\\nLet\\u2019s do a recursive dfs. \\n\\nWe position ourselves at a specific node `subroot` and will treat it as the root of a subtree. We assume that all of its subtrees are already balanced (we traverse in a post-order fashion and the subtree is taken care of earlier in the recursion). Then its left child reaches all leaves for `leftcost`, and the right child for `rightcost`. So we just need to make those costs equal to balance `subroot`! All we need is a correction according to the difference between those two (`correction+=abs(leftcost-rightcost)`).\\n\\nWe then return the total cost of this `subroot` which is simply `max(leftcost,rightcost)+cost[subroot]`. The maximum is taken here because we can only increment, so that means that we increase the lowest cost of the two children until it is equal to the other, and we are left with the max.\\n\\nAnd that\\u2019s it! If this helped you understand the proof of correctness and visualize it, do leave an upvote, it is always encouraging!\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(logn) for the stack call\\n\\n# Code\\n```\\nclass Solution:\\n    def minIncrements(self, n: int, cost: List[int]) -> int:\\n        \\n        correction=0\\n        def dfs(node):\\n            nonlocal correction\\n            if node>=len(cost):\\n                return 0\\n            #the indexing is a bit annoying, but I like to think about it this way:\\n            #we have to treat it as being 1-indexed to get the child (so we use 2*(node+1) rather than 2*node)\\n            #we then convert it back to 0-indexed for the array (so 2*(node+1)-1)\\n            #I explain the indexing in more details in the comment section\\n            lcost=dfs(2*(node+1)-1)\\n            rcost=dfs(2*(node+1))\\n            correction+=abs(rcost-lcost)\\n            return max(lcost,rcost)+cost[node]\\n        \\n        dfs(0)\\n        return correction\\n            \\n```",
                "solutionTags": [
                    "Python3",
                    "Depth-First Search",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution:\\n    def minIncrements(self, n: int, cost: List[int]) -> int:\\n        \\n        correction=0\\n        def dfs(node):\\n            nonlocal correction\\n            if node>=len(cost):\\n                return 0\\n            #the indexing is a bit annoying, but I like to think about it this way:\\n            #we have to treat it as being 1-indexed to get the child (so we use 2*(node+1) rather than 2*node)\\n            #we then convert it back to 0-indexed for the array (so 2*(node+1)-1)\\n            #I explain the indexing in more details in the comment section\\n            lcost=dfs(2*(node+1)-1)\\n            rcost=dfs(2*(node+1))\\n            correction+=abs(rcost-lcost)\\n            return max(lcost,rcost)+cost[node]\\n        \\n        dfs(0)\\n        return correction\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3494857,
                "title": "explained-very-simple-and-easy-to-understand-solution",
                "content": "<b> Up vote if you like the solution </b>\\n\\n# Approach\\n\\nTrick here is to have equal path cast at each node for its child nodes.\\n\\n1. First traverse to the leaf node and then return the sum of path cost from the leaf towards root.\\n2. While returning from the leaf node, we will equal the path sum to the max value\\n   - to do so, add the diff in paths of two child to the ans\\n   - take the max and return it to its parent node\\n   \\nNote : As there is no actual tree built here, we will use max value of root as <= n for the base condition to return.  \\n\\n\\nTime complexity O(N) & space complexity O(H), where H is height of the tree\\n\\n```\\nclass Solution {\\npublic:\\n    int ans = 0;\\n    int dfs(int root, vector<int>& cost, int n){\\n        if(root > n ) return 0;\\n        int t1 = dfs(root*2, cost, n);\\n        int t2 = dfs(root*2+1, cost, n);\\n        ans += abs(t1 - t2);\\n        return cost[root-1] + max(t1, t2);\\n    }\\n    \\n    int minIncrements(int n, vector<int>& cost) {\\n        dfs(1, cost, n);\\n        return ans;\\n    }\\n};\\n```\\n\\n<b>Here is an article of my last interview experience - A Journey to FAANG Company, I recomand you to go through this to know which all resources I have used & how I cracked interview at Amazon:\\nhttps://leetcode.com/discuss/interview-experience/3171859/Journey-to-a-FAANG-Company-Amazon-or-SDE2-(L5)-or-Bangalore-or-Oct-2022-Accepted",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int ans = 0;\\n    int dfs(int root, vector<int>& cost, int n){\\n        if(root > n ) return 0;\\n        int t1 = dfs(root*2, cost, n);\\n        int t2 = dfs(root*2+1, cost, n);\\n        ans += abs(t1 - t2);\\n        return cost[root-1] + max(t1, t2);\\n    }\\n    \\n    int minIncrements(int n, vector<int>& cost) {\\n        dfs(1, cost, n);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3494855,
                "title": "cpp-java-python-simple-dfs-one-pass",
                "content": "### Intuition\\nJust make left and right subtree cost equal.\\n\\n### TIme Complexity : `O(n)`\\n\\n### C++\\n```\\nclass Solution {\\npublic:\\n    int dfs(int n,vector<int> &cost,int i,int &ans) {\\n        if(i > n) return 0;\\n        int leftCost = dfs(n,cost,2 * i,ans);\\n        int rightCost = dfs(n,cost,2 * i + 1,ans);\\n        ans += abs(leftCost - rightCost);\\n        return max(leftCost,rightCost) + cost[i - 1];\\n    }\\n    int minIncrements(int n, vector<int>& cost) {\\n        int ans = 0;\\n        dfs(n,cost,1,ans);\\n        return ans;\\n    }\\n};\\n```\\n\\n### Java\\n\\n```\\nclass Solution {\\n    int ans = 0;\\n    int dfs(int n,int[] cost,int i) {\\n        if(i > n) return 0;\\n        int leftCost = dfs(n,cost,2 * i);\\n        int rightCost = dfs(n,cost,2 * i + 1);\\n        ans += Math.abs(leftCost - rightCost);\\n        return Math.max(leftCost,rightCost) + cost[i - 1];\\n    }\\n    public int minIncrements(int n, int[] cost) {\\n        dfs(n,cost,1);\\n        return ans;\\n    }\\n}\\n```\\n\\n### Python\\n\\n```\\nans = 0\\ndef dfs(n, cost, i):\\n    global ans\\n    if(i > n):\\n        return 0\\n    leftCost = dfs(n,cost,2 * i);\\n    rightCost = dfs(n,cost,2 * i + 1);\\n    ans += abs(leftCost - rightCost);\\n    return max(leftCost,rightCost) + cost[i - 1];\\n    \\nclass Solution:\\n    def minIncrements(self, n: int, cost: List[int]) -> int:\\n        global ans\\n        ans = 0\\n        dfs(n,cost,1)\\n        return ans\\n        \\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dfs(int n,vector<int> &cost,int i,int &ans) {\\n        if(i > n) return 0;\\n        int leftCost = dfs(n,cost,2 * i,ans);\\n        int rightCost = dfs(n,cost,2 * i + 1,ans);\\n        ans += abs(leftCost - rightCost);\\n        return max(leftCost,rightCost) + cost[i - 1];\\n    }\\n    int minIncrements(int n, vector<int>& cost) {\\n        int ans = 0;\\n        dfs(n,cost,1,ans);\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\n    int ans = 0;\\n    int dfs(int n,int[] cost,int i) {\\n        if(i > n) return 0;\\n        int leftCost = dfs(n,cost,2 * i);\\n        int rightCost = dfs(n,cost,2 * i + 1);\\n        ans += Math.abs(leftCost - rightCost);\\n        return Math.max(leftCost,rightCost) + cost[i - 1];\\n    }\\n    public int minIncrements(int n, int[] cost) {\\n        dfs(n,cost,1);\\n        return ans;\\n    }\\n}\\n```\n```\\nans = 0\\ndef dfs(n, cost, i):\\n    global ans\\n    if(i > n):\\n        return 0\\n    leftCost = dfs(n,cost,2 * i);\\n    rightCost = dfs(n,cost,2 * i + 1);\\n    ans += abs(leftCost - rightCost);\\n    return max(leftCost,rightCost) + cost[i - 1];\\n    \\nclass Solution:\\n    def minIncrements(self, n: int, cost: List[int]) -> int:\\n        global ans\\n        ans = 0\\n        dfs(n,cost,1)\\n        return ans\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3495289,
                "title": "c-very-well-commented-easy-to-understand-solution",
                "content": "# Approach\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe use post-order dfs to calculate difference of left and right path cost at a node. Then return the current path to parent.\\n\\nMinimum operations we need are abs(right-left) because we want to make lower path equal to the larger path by incrementing the lower path sum.\\n\\nThen, the left and right path should be equal to each other, \\ni.e. $$max(left, right)$$, and\\nCurrent path becomes $$cost[node] + max(left, right)$$\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(log2(n))$$ \\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    // To store the answer\\n    int ans=0;\\n    \\n    // A post-order dfs to calculate difference of every left and right path cost\\n    int dfs(int node, int n,vector<int>& cost){\\n\\n        // if this node doesn\\'t exist(if it is greater that n) then return 0\\n        if(node>n)return 0;\\n        int left=0,right=0;\\n\\n        // the left path cost\\n        left=dfs(2*node,n,cost);\\n        //the right path cost\\n        right=dfs((node*2)+1,n,cost);\\n\\n        // we store the difference needed to make the left and right path equal\\n        ans+= abs(right-left);\\n\\n        // return the current path\\n        return cost[node-1] + max(left,right);\\n    }\\n    \\n    int minIncrements(int n, vector<int>& cost) {\\n        dfs(1,n,cost);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    // To store the answer\\n    int ans=0;\\n    \\n    // A post-order dfs to calculate difference of every left and right path cost\\n    int dfs(int node, int n,vector<int>& cost){\\n\\n        // if this node doesn\\'t exist(if it is greater that n) then return 0\\n        if(node>n)return 0;\\n        int left=0,right=0;\\n\\n        // the left path cost\\n        left=dfs(2*node,n,cost);\\n        //the right path cost\\n        right=dfs((node*2)+1,n,cost);\\n\\n        // we store the difference needed to make the left and right path equal\\n        ans+= abs(right-left);\\n\\n        // return the current path\\n        return cost[node-1] + max(left,right);\\n    }\\n    \\n    int minIncrements(int n, vector<int>& cost) {\\n        dfs(1,n,cost);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3495360,
                "title": "simple-solution-without-dfs-simple-loop-very-short",
                "content": "# Intuition\\nWe shouldn\\'t add 1 on 2 siblings since it\\'s better to add 1 to the parent.\\n\\n# Approach\\nFrom leaf to root, for each pair of siblings (x, y), keep the larger value as the result. And the we need to add the difference to the smaller value to make (x, y) the same. And add the same value to the parent since the parent is the \"new leaf\".\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {        \\npublic:\\n    int minIncrements(int n, vector<int>& cost) {\\n      int r = 0;\\n      for (int i = n - 1; i; i -= 2) {\\n         r += abs(cost[i] - cost[i - 1]);\\n         cost[(i - 1) >> 1] += max(cost[i], cost[i - 1]);\\n       }\\n       return r;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {        \\npublic:\\n    int minIncrements(int n, vector<int>& cost) {\\n      int r = 0;\\n      for (int i = n - 1; i; i -= 2) {\\n         r += abs(cost[i] - cost[i - 1]);\\n         cost[(i - 1) >> 1] += max(cost[i], cost[i - 1]);\\n       }\\n       return r;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3495060,
                "title": "find-the-maximum-sum-from-root-to-leaf",
                "content": "# Intuition\\nGo from root to leaf, find the maxium sum. And then go back from leaf to root.\\n\\n# Approach\\nIf a 2 siblings needs to add values x and y, then move min(x, y) to the parent.\\n\\n# Complexity\\n- Time complexity:\\nO(nlogn)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\n    void cal(const vector<int> &cost, int now, int s, vector<int> &v) {\\n        if (now > cost.size()) {\\n            return;\\n        }\\n        s += cost[now - 1];\\n        if (now + now >= cost.size()) {\\n            v[now] = s;\\n            return;\\n        }\\n        cal(cost, now << 1, s, v);\\n        cal(cost, (now << 1) | 1, s, v);\\n    }\\npublic:\\n    int minIncrements(int n, vector<int>& cost) {\\n        vector<int> v(n + 1);\\n        cal(cost, 1, 0, v);\\n        const int m = *max_element(v.begin(), v.end());\\n        long long r = 0;\\n        for (int i = (n + 1) >> 1; i <= n; ++i) {\\n            v[i] = m - v[i];\\n            r += v[i];\\n        }\\n        for (int from = (n + 1) >> 1; from > 1; from >>= 1) {\\n            for (int i = from, to = from << 1; i < to; i += 2) {\\n                r -= (v[i >> 1] = min(v[i], v[i + 1]));\\n            }\\n        }\\n        return r;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n    void cal(const vector<int> &cost, int now, int s, vector<int> &v) {\\n        if (now > cost.size()) {\\n            return;\\n        }\\n        s += cost[now - 1];\\n        if (now + now >= cost.size()) {\\n            v[now] = s;\\n            return;\\n        }\\n        cal(cost, now << 1, s, v);\\n        cal(cost, (now << 1) | 1, s, v);\\n    }\\npublic:\\n    int minIncrements(int n, vector<int>& cost) {\\n        vector<int> v(n + 1);\\n        cal(cost, 1, 0, v);\\n        const int m = *max_element(v.begin(), v.end());\\n        long long r = 0;\\n        for (int i = (n + 1) >> 1; i <= n; ++i) {\\n            v[i] = m - v[i];\\n            r += v[i];\\n        }\\n        for (int from = (n + 1) >> 1; from > 1; from >>= 1) {\\n            for (int i = from, to = from << 1; i < to; i += 2) {\\n                r -= (v[i >> 1] = min(v[i], v[i + 1]));\\n            }\\n        }\\n        return r;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3495265,
                "title": "beginner-friendly-and-very-simple-solution-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nFor a particular node its children should have equal path sum.\\nSo we will calculate path sum of both childs and make them equal. And we will perform this operation for all nodes. \\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nFirst we will traverse using dfs from starting node and calculate path sum of childs. Our dfs(node) will return path sum. After finding path sum of childs difference of both paths will be added to our final answer and then we return path sum till parent node.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n) -> Traversing complete tree using dfs.\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(log(n)) -> Stack size during recursion call\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int ans=0;\\n    int dfs(int i,vector<int>&cost)\\n    {\\n        if(i>cost.size())\\n            return 0;\\n        int x=dfs(2*i,cost);\\n        int y=dfs(2*i+1,cost);\\n        ans+=abs(x-y);\\n        return max(x,y)+cost[i-1];\\n    }\\n    int minIncrements(int n, vector<int>& cost) {\\n        int x=dfs(1,cost);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int ans=0;\\n    int dfs(int i,vector<int>&cost)\\n    {\\n        if(i>cost.size())\\n            return 0;\\n        int x=dfs(2*i,cost);\\n        int y=dfs(2*i+1,cost);\\n        ans+=abs(x-y);\\n        return max(x,y)+cost[i-1];\\n    }\\n    int minIncrements(int n, vector<int>& cost) {\\n        int x=dfs(1,cost);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3494956,
                "title": "hand-written-with-observation-and-diagram-dry-run",
                "content": "** Please Upvote if you liked the solution**\\n![image.png](https://assets.leetcode.com/users/images/7c0bcab3-56dd-4cab-a512-4957e5dc6181_1683435348.005485.png)\\n![image.png](https://assets.leetcode.com/users/images/5aa93401-b7eb-4d69-816a-d97e263394ae_1683432142.6954012.png)\\n\\n\\n![image.png](https://assets.leetcode.com/users/images/dcd17658-2fd7-4b4a-9244-487870a78a84_1683432164.5087936.png)\\n![image.png](https://assets.leetcode.com/users/images/a4164879-06c2-4879-a5c9-df091864f6c8_1683432178.6084197.png)\\n![image.png](https://assets.leetcode.com/users/images/09f98284-7afa-43a5-9db5-29cbb1b12fb1_1683432187.3257892.png)\\n![image.png](https://assets.leetcode.com/users/images/bda67c11-0700-4ab5-981f-152db677a35c_1683432206.899085.png)\\n![image.png](https://assets.leetcode.com/users/images/7af80caa-2c45-49c9-86f4-319527d8c17d_1683432217.3027983.png)\\n\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> findLeaves(int n) {\\n    vector<int> leaves;\\n    for (int i = n/2 + 1; i <= n; i++) {\\n        leaves.push_back(i);\\n    }\\n    return leaves;\\n}\\n    int minIncrements(int n, vector<int>& cost) {\\n        vector<int>leaves=findLeaves(n);\\n        queue<int>q;\\n        map<int,int>mp;\\n        for(auto child:leaves){\\n            mp[child]=0;\\n            q.push(child);\\n        }\\n        int ans=0;\\n        while(!q.empty()){\\n            int sz=q.size();\\n            while(sz--){\\n                int curr=q.front();\\n                if(curr==1)\\n                    return ans;\\n                q.pop();\\n                int parent;\\n                if(curr&1){\\n                    parent=(curr-1)/2;\\n                }else {\\n                    parent=curr/2;\\n                }\\n                if(parent>0 && mp.count(parent)==0){\\n                    mp[parent]=mp[curr]+cost[curr-1];\\n            \\n                    q.push(parent);\\n                }else{\\n                    ans+=abs(mp[parent]-(mp[curr]+cost[curr-1]));\\n                    mp[parent]=max(mp[parent],mp[curr]+cost[curr-1]);\\n\\n                }\\n       \\n                \\n                \\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n\\n**Please Upvote if you liked the solution **",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findLeaves(int n) {\\n    vector<int> leaves;\\n    for (int i = n/2 + 1; i <= n; i++) {\\n        leaves.push_back(i);\\n    }\\n    return leaves;\\n}\\n    int minIncrements(int n, vector<int>& cost) {\\n        vector<int>leaves=findLeaves(n);\\n        queue<int>q;\\n        map<int,int>mp;\\n        for(auto child:leaves){\\n            mp[child]=0;\\n            q.push(child);\\n        }\\n        int ans=0;\\n        while(!q.empty()){\\n            int sz=q.size();\\n            while(sz--){\\n                int curr=q.front();\\n                if(curr==1)\\n                    return ans;\\n                q.pop();\\n                int parent;\\n                if(curr&1){\\n                    parent=(curr-1)/2;\\n                }else {\\n                    parent=curr/2;\\n                }\\n                if(parent>0 && mp.count(parent)==0){\\n                    mp[parent]=mp[curr]+cost[curr-1];\\n            \\n                    q.push(parent);\\n                }else{\\n                    ans+=abs(mp[parent]-(mp[curr]+cost[curr-1]));\\n                    mp[parent]=max(mp[parent],mp[curr]+cost[curr-1]);\\n\\n                }\\n       \\n                \\n                \\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3494848,
                "title": "one-pass",
                "content": "We tack the maximum the path sum, and for each non-leaf node, we \"pick up the slack\".\\n\\nThe top-down solution is easier to comprehend; once you get it - it should be easy to code the bottom-up approach.\\n\\n## Top-Down\\n\\n**C++**\\n```cpp\\narray<int, 2> path_sum(int i, int n, vector<int>& cost) {\\n    if (i * 2 >= n)\\n        return {0, cost[i - 1]};\\n    auto l = path_sum(i * 2, n, cost), r = path_sum(i * 2 + 1, n, cost);\\n    return {l[0] + r[0] + abs(l[1] - r[1]), cost[i - 1] + max(l[1], r[1])};\\n}     \\nint minIncrements(int n, vector<int>& cost) {\\n    return path_sum(1, n, cost)[0];\\n}\\n```\\n\\n## Bottom-Up\\n```cpp\\nint minIncrements(int n, vector<int>& cost) {\\n    int res = 0;\\n    for (int i = n - 2; i > 0; i -= 2) {\\n        res += abs(cost[i] - cost[i + 1]);\\n        cost[i / 2] += max(cost[i], cost[i + 1]);\\n    }\\n    return res;\\n}\\n```",
                "solutionTags": [],
                "code": "```cpp\\narray<int, 2> path_sum(int i, int n, vector<int>& cost) {\\n    if (i * 2 >= n)\\n        return {0, cost[i - 1]};\\n    auto l = path_sum(i * 2, n, cost), r = path_sum(i * 2 + 1, n, cost);\\n    return {l[0] + r[0] + abs(l[1] - r[1]), cost[i - 1] + max(l[1], r[1])};\\n}     \\nint minIncrements(int n, vector<int>& cost) {\\n    return path_sum(1, n, cost)[0];\\n}\\n```\n```cpp\\nint minIncrements(int n, vector<int>& cost) {\\n    int res = 0;\\n    for (int i = n - 2; i > 0; i -= 2) {\\n        res += abs(cost[i] - cost[i + 1]);\\n        cost[i / 2] += max(cost[i], cost[i + 1]);\\n    }\\n    return res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3495055,
                "title": "c-no-dfs",
                "content": "# Intuition\\nNote the binary tree is complete, we just need to ensure the most bottom node is equals and carry over the cost to higher level until we reach the root.\\n\\n# Approach\\nSince we can only increment, we need to ensure lowest level is equals before moving up. Carry the max of left-right nodes to its parent node. On the parent node, calculate cost to make same level equals and carry it up to its parent. Do it until you reach the root.\\n\\n# Complexity\\n- Time complexity:\\n$$O(N)$$\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minIncrements(int n, vector<int>& cost) {\\n        int ans {};\\n        for(int i = cost.size()-1; i > 0; --i) {\\n//start on left-node since we know the binary tree is complete\\n            --i; \\n//cost to make left node and right node equals\\n            ans += abs(cost[i]-cost[i+1]);\\n//the cost of path to leaf node can be recomputed as cost to parent node + max of parent\\'s child\\n            cost[i/2] += max(cost[i],cost[i+1]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minIncrements(int n, vector<int>& cost) {\\n        int ans {};\\n        for(int i = cost.size()-1; i > 0; --i) {\\n//start on left-node since we know the binary tree is complete\\n            --i; \\n//cost to make left node and right node equals\\n            ans += abs(cost[i]-cost[i+1]);\\n//the cost of path to leaf node can be recomputed as cost to parent node + max of parent\\'s child\\n            cost[i/2] += max(cost[i],cost[i+1]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3494925,
                "title": "simple-post-order-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int ans=0;\\n    \\n    int post(int nd,vector<int>&cost,int n){\\n      if(nd>n)return 0;\\n        int left=post(2*nd,cost,n);\\n        int right=post(2*nd+1,cost,n);\\n        if(left!=right)ans+=abs(left-right);\\n        return cost[nd-1]+max(left,right);\\n    \\n    }\\n    int minIncrements(int n, vector<int>& cost) {\\n        post(1,cost,n);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int ans=0;\\n    \\n    int post(int nd,vector<int>&cost,int n){\\n      if(nd>n)return 0;\\n        int left=post(2*nd,cost,n);\\n        int right=post(2*nd+1,cost,n);\\n        if(left!=right)ans+=abs(left-right);\\n        return cost[nd-1]+max(left,right);\\n    \\n    }\\n    int minIncrements(int n, vector<int>& cost) {\\n        post(1,cost,n);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3513119,
                "title": "java-dfs-clean-code-10-lines",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(log(n))$$ on the stack\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n  int ans = 0;\\n\\n  private int dfs(int n, int[] cost, int i) {\\n    if (i > n) return 0;\\n\\n    var l = dfs(n, cost, 2*i);\\n    var r = dfs(n, cost, 2*i + 1);\\n    ans += Math.abs(l - r);\\n\\n    return cost[i-1] + Math.max(l, r);\\n  }\\n\\n  public int minIncrements(int n, int[] cost) {\\n    dfs(n, cost, 1);\\n    return ans;\\n  }\\n}\\n```\\nIf you like my solution, please upvote it!",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Depth-First Search",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n  int ans = 0;\\n\\n  private int dfs(int n, int[] cost, int i) {\\n    if (i > n) return 0;\\n\\n    var l = dfs(n, cost, 2*i);\\n    var r = dfs(n, cost, 2*i + 1);\\n    ans += Math.abs(l - r);\\n\\n    return cost[i-1] + Math.max(l, r);\\n  }\\n\\n  public int minIncrements(int n, int[] cost) {\\n    dfs(n, cost, 1);\\n    return ans;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3501702,
                "title": "python-3-7-lines-iterative-bottom-up-t-m-1269-ms-25-5-mb",
                "content": "A couple of notes:\\n1. The iteration covers only the parents, so we can prune the leaves from the iteration.\\n2. We add `1` each to `2i` and `2i+1` because `cost` is zero-indexed and the tree is one-indexed.\\n\\n\\n```\\nclass Solution:\\n    def minIncrements(self, n: int, cost: List[int]) -> int:\\n\\n        ans = 0\\n        n//=2                                               # <-- 1)\\n\\n        for i in reversed(range(n)):\\n        \\n            mn, mx = sorted((cost[2*i+1], cost[2*i+2]))     # <-- 2)\\n\\n            ans+= mx - mn\\n            cost[i]+= mx\\n\\n        return ans\\n```\\n[https://leetcode.com/problems/make-costs-of-paths-equal-in-a-binary-tree/submissions/946746736/](http://)\\n\\n\\nI could be wrong, but I think that time complexity is *O*(*N*) and space complexity is *O*(1).\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minIncrements(self, n: int, cost: List[int]) -> int:\\n\\n        ans = 0\\n        n//=2                                               # <-- 1)\\n\\n        for i in reversed(range(n)):\\n        \\n            mn, mx = sorted((cost[2*i+1], cost[2*i+2]))     # <-- 2)\\n\\n            ans+= mx - mn\\n            cost[i]+= mx\\n\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3495143,
                "title": "c-backtracking",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Base Condition is if current node is leaf we returns its cost.\\n2. we perform dfs.\\n3. while backtracking we add difference in cost arrived from both child and add max of both to current cost and returns.\\n4. final asnswer is `ans` where we stored differences sum which returned at `i=0`.\\n\\n# Complexity\\n- Time complexity: $$O(log(n))$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(log(n))$$ //Recursion\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int ans=0;\\n    int minIncrements(int& n, vector<int>& cost,int i=0) {\\n        if(2*i+1>=n) return i==0?ans:cost[i];\\n        int x = minIncrements(n,cost,2*i+1);\\n        int y = minIncrements(n,cost,2*i+2);\\n        ans+=abs(x-y);\\n        return i==0?ans:max(x,y)+cost[i];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Backtracking",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int ans=0;\\n    int minIncrements(int& n, vector<int>& cost,int i=0) {\\n        if(2*i+1>=n) return i==0?ans:cost[i];\\n        int x = minIncrements(n,cost,2*i+1);\\n        int y = minIncrements(n,cost,2*i+2);\\n        ans+=abs(x-y);\\n        return i==0?ans:max(x,y)+cost[i];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3494892,
                "title": "6-lines-c-beats-100-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minIncrements(int n, vector<int>& cost) {\\n        int sum = 0;\\n        vector<int> path = cost;\\n        for(int i = cost.size()-1; i > 0; i = i -2){\\n            int minM = min(cost[i], cost[i-1]);\\n            int maxM = max(cost[i],cost[i-1]);\\n            sum += maxM - minM;\\n            cost[(i-1)/2] += maxM;\\n            \\n        }\\n        \\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minIncrements(int n, vector<int>& cost) {\\n        int sum = 0;\\n        vector<int> path = cost;\\n        for(int i = cost.size()-1; i > 0; i = i -2){\\n            int minM = min(cost[i], cost[i-1]);\\n            int maxM = max(cost[i],cost[i-1]);\\n            sum += maxM - minM;\\n            cost[(i-1)/2] += maxM;\\n            \\n        }\\n        \\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3786336,
                "title": "5-line-cpp-solution-with-explanation-optimal-space-and-time-array-operations",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe start from the leaf nodes and then move upwards. Also note that a perfect binary tree is given.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe add the difference of the two sibling nodes(with the same parent) into our answer and add the value of their maximum to the parent node\\'s node value.\\nSince we have a perfect binary tree we can use simple array operations for the desired result.\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minIncrements(int n, vector<int>& cost) {\\n        int ans = 0;\\n        for(int i = n-1; i>=1; i = i-2){\\n            ans+= abs(cost[i]-cost[i-1]);\\n            cost[(i-1)/2]+=max(cost[i],cost[i-1]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minIncrements(int n, vector<int>& cost) {\\n        int ans = 0;\\n        for(int i = n-1; i>=1; i = i-2){\\n            ans+= abs(cost[i]-cost[i-1]);\\n            cost[(i-1)/2]+=max(cost[i],cost[i-1]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3502359,
                "title": "2-lines-code",
                "content": "# Intuition\\nThink Bottom UP.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n<!-- # Approach -->\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n\\n```C++ []\\nclass Solution {\\npublic:\\n    int minIncrements(int n, vector<int>& cost) {\\n        int moves = 0;\\n        for(int i = n / 2 - 1; i >= 0; i--) {\\n            moves += abs(cost[2 * i + 1] - cost[2 * i + 2]);\\n            cost[i] += max(cost[2 * i + 1], cost[2 * i + 2]);\\n        }\\n        return moves;\\n    }\\n};\\n```\\n```Java []\\nclass Solution {\\n    public int minIncrements(int n, int[] cost) {\\n        int moves = 0;\\n        for(int i = n / 2 - 1; i >= 0; i--) {\\n            moves += Math.abs(cost[2 * i + 1] - cost[2 * i + 2]);\\n            cost[i] += Math.max(cost[2 * i + 1], cost[2 * i + 2]);\\n        }\\n        return moves;\\n    }\\n}\\n```\\n```JavaScript []\\nvar minIncrements = function(n, cost) {\\n    let moves = 0;\\n    for(let i = (n + 1) / 2 - 2; i >= 0; i--) {\\n        moves += Math.abs(cost[2 * i + 1] - cost[2 * i + 2]);\\n        cost[i] += Math.max(cost[2 * i + 1], cost[2 * i + 2]);\\n    }\\n    return moves;\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "JavaScript",
                    "Binary Tree"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    int minIncrements(int n, vector<int>& cost) {\\n        int moves = 0;\\n        for(int i = n / 2 - 1; i >= 0; i--) {\\n            moves += abs(cost[2 * i + 1] - cost[2 * i + 2]);\\n            cost[i] += max(cost[2 * i + 1], cost[2 * i + 2]);\\n        }\\n        return moves;\\n    }\\n};\\n```\n```Java []\\nclass Solution {\\n    public int minIncrements(int n, int[] cost) {\\n        int moves = 0;\\n        for(int i = n / 2 - 1; i >= 0; i--) {\\n            moves += Math.abs(cost[2 * i + 1] - cost[2 * i + 2]);\\n            cost[i] += Math.max(cost[2 * i + 1], cost[2 * i + 2]);\\n        }\\n        return moves;\\n    }\\n}\\n```\n```JavaScript []\\nvar minIncrements = function(n, cost) {\\n    let moves = 0;\\n    for(let i = (n + 1) / 2 - 2; i >= 0; i--) {\\n        moves += Math.abs(cost[2 * i + 1] - cost[2 * i + 2]);\\n        cost[i] += Math.max(cost[2 * i + 1], cost[2 * i + 2]);\\n    }\\n    return moves;\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3499189,
                "title": "beats-100-solution-easy-dfs-c-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int ans=0;\\n    int dfs(vector<int>& cost,int ind,int n)\\n    {\\n        if(ind>n) return 0;\\n        int l=dfs(cost , 2*ind ,n);\\n        int r=dfs(cost , (2*ind )+1 ,n);\\n        ans+=abs(l-r);\\n        return cost[ind-1]+max(l,r);\\n        \\n    }\\n    int minIncrements(int n, vector<int>& cost) {\\n        ios::sync_with_stdio(false);\\n        cin.tie(0);\\n        cout.tie(0);\\n        dfs(cost,1,n);\\n        return ans;\\n    }\\n};\\n```\\n![7dr99c.jpg](https://assets.leetcode.com/users/images/167fd5e0-7ff6-4c96-91a8-bc52eaee94f8_1683524540.0145473.jpeg)\\n",
                "solutionTags": [
                    "C++",
                    "Tree",
                    "Depth-First Search",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int ans=0;\\n    int dfs(vector<int>& cost,int ind,int n)\\n    {\\n        if(ind>n) return 0;\\n        int l=dfs(cost , 2*ind ,n);\\n        int r=dfs(cost , (2*ind )+1 ,n);\\n        ans+=abs(l-r);\\n        return cost[ind-1]+max(l,r);\\n        \\n    }\\n    int minIncrements(int n, vector<int>& cost) {\\n        ios::sync_with_stdio(false);\\n        cin.tie(0);\\n        cout.tie(0);\\n        dfs(cost,1,n);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3496277,
                "title": "short-dfs-straight-forward-o-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    int ans;\\n    public int minIncrements(int n, int[] cost) {\\n        ans=0;\\n        rec(n, cost, 0);\\n        return ans;\\n    }\\n    int rec(int n, int[] cost, int i){\\n        if(i>=n)return 0;\\n        int left=rec(n, cost, i*2+1);\\n        int right=rec(n, cost, i*2+2);\\n        ans+=Math.abs(left-right);\\n        return Math.max(left,right)+cost[i];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    int ans;\\n    public int minIncrements(int n, int[] cost) {\\n        ans=0;\\n        rec(n, cost, 0);\\n        return ans;\\n    }\\n    int rec(int n, int[] cost, int i){\\n        if(i>=n)return 0;\\n        int left=rec(n, cost, i*2+1);\\n        int right=rec(n, cost, i*2+2);\\n        ans+=Math.abs(left-right);\\n        return Math.max(left,right)+cost[i];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3496157,
                "title": "medium",
                "content": "# Please Upvote as it really motivates me \\uD83C\\uDD99\\uD83C\\uDD99\\uD83C\\uDD99\\n# Intuition & Approach\\n<!-- Describe your approach to solving the problem. -->\\nCOMMING SOON\\n\\n# Complexity\\n- Time complexity:O(LOG N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```JAVA []\\npublic int minIncrements(int n, int[] cost) {\\n    int res =0;\\n    for(int i=n / 2 - 1;i>=0;--i){\\n        int l =  i * 2 + 1,r=  i *  2 + 2;\\n        res+=Math.abs(cost[l]-cost[r]);\\n        cost[i]+=Math.max(cost[l],cost[r]);\\n    }return res;\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Python3"
                ],
                "code": "```JAVA []\\npublic int minIncrements(int n, int[] cost) {\\n    int res =0;\\n    for(int i=n / 2 - 1;i>=0;--i){\\n        int l =  i * 2 + 1,r=  i *  2 + 2;\\n        res+=Math.abs(cost[l]-cost[r]);\\n        cost[i]+=Math.max(cost[l],cost[r]);\\n    }return res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3638632,
                "title": "fully-expalined-recursive-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n**We need to calculate the height of each subtree from Bottom to top \\nand keep track of difference**\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1.  **The func function takes four parameters: cost, which is a vector of integers representing the cost at each node of the binary tree; l, which represents the current level or index of the node being processed; n, the total number of nodes in the tree; and ans, a reference to an integer that keeps track of the total cost increments**.\\n\\n2. **The first conditional statement if (2 * l > n || 2 * l + 1 > n) checks if the current node is a leaf node. If the left child (2 * l) or the right child (2 * l + 1) exceeds the total number of nodes n, it means that the current node is a leaf node, and the function returns the cost at that leaf node cost[l-1].**\\n\\n3. **If the current node is not a leaf node, the function proceeds to the following steps:**\\n\\n4. **It recursively calls func for the left child of the current node with 2 * l as the new index and stores the result in the left variable.**\\n\\n5. **Similarly, it recursively calls func for the right child of the current node with    2 * l + 1 as the new index and stores the result in the right variable.**\\n\\n6. **The difference between the left and right values is added to the ans variable to keep track of the total cost increments.**\\n\\n7. **The function returns the sum of the cost at the current node   cost[l-1] and the maximum value between left and right.**\\n\\n8. **The result variable in main function basicall print the maximum distance b/w leaf node and root node**\\n\\n```\\n return cost[l-1]+max(left,right);\\n```\\n**This statement basically gives the maximum distance b/w root to leaf among all paths**\\n\\n ```\\nif(2*l>n||2*l+1>n) return cost[l-1];\\n\\n```\\n**The ```if condition``` checks if the ```current node is a leaf node. ```It does this by comparing whether the index of the ```left child (2 * l) or the index of the right child (2 * l + 1) exceeds the total number of nodes n```. If either child\\'s index is greater than n, it means the current node is a leaf node. In that case, the function returns the cost at that leaf node (cost[l - 1]).**\\n\\n\\n\\n\\n```\\n        int left=func(cost,2*l,n,ans);\\n        int right=func(cost,2*l+1,n,ans);\\n       \\n```\\n\\n**left calculate the distance of left leaf in ever subtree and right subtree is calculated by right variable**\\n\\n``` ans+=abs(left-right); ```\\n **This satement keep track the changes we need to made to make the paths equal**\\n\\n\\n        \\n\\n\\n# Complexity\\n- Time complexity:$$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n**RECURSIVE APPROACH**\\n```\\nclass Solution {\\npublic:\\n    int func(vector<int>&cost,int l,int n,int &ans)\\n    {\\n        if(2*l>n||2*l+1>n) return cost[l-1];\\n\\n        int left=func(cost,2*l,n,ans);\\n        int right=func(cost,2*l+1,n,ans);\\n        ans+=abs(left-right);\\n        return cost[l-1]+max(left,right);\\n    }\\n    int minIncrements(int n, vector<int>& cost) {\\n     int ans=0;\\n     int level=1;//level\\n     int result=func(cost,level, n,ans);\\n\\n\\n     cout<<result<<\" \";\\n     return ans;\\n}\\n};\\n```\\n**ITERATIVE APPROACH**\\n```\\nclass Solution {\\npublic:\\n    int minIncrements(int n, vector<int>& cost) {\\n\\n         n=n/2;\\n         int ans=0;\\n    for(int i=n; i>0; i--)\\n    {\\n        int l=2*i-1;//left\\n        int r=2*i; //right\\n        ans+=abs(cost[l]-cost[r]);//updating the difference \\n        cost[i-1]+=max(cost[l],cost[r]);//updatin the max subtree cost\\n    }\\n        return ans;\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Tree",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\n return cost[l-1]+max(left,right);\\n```\n```\\nif(2*l>n||2*l+1>n) return cost[l-1];\\n\\n```\n```if condition```\n```current node is a leaf node. ```\n```left child (2 * l) or the index of the right child (2 * l + 1) exceeds the total number of nodes n```\n```\\n        int left=func(cost,2*l,n,ans);\\n        int right=func(cost,2*l+1,n,ans);\\n       \\n```\n``` ans+=abs(left-right); ```\n```\\nclass Solution {\\npublic:\\n    int func(vector<int>&cost,int l,int n,int &ans)\\n    {\\n        if(2*l>n||2*l+1>n) return cost[l-1];\\n\\n        int left=func(cost,2*l,n,ans);\\n        int right=func(cost,2*l+1,n,ans);\\n        ans+=abs(left-right);\\n        return cost[l-1]+max(left,right);\\n    }\\n    int minIncrements(int n, vector<int>& cost) {\\n     int ans=0;\\n     int level=1;//level\\n     int result=func(cost,level, n,ans);\\n\\n\\n     cout<<result<<\" \";\\n     return ans;\\n}\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int minIncrements(int n, vector<int>& cost) {\\n\\n         n=n/2;\\n         int ans=0;\\n    for(int i=n; i>0; i--)\\n    {\\n        int l=2*i-1;//left\\n        int r=2*i; //right\\n        ans+=abs(cost[l]-cost[r]);//updating the difference \\n        cost[i-1]+=max(cost[l],cost[r]);//updatin the max subtree cost\\n    }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3577222,
                "title": "python-iterative-not-recursive-short-and-concise",
                "content": "# Intuition\\nIf only 3 nodes,\\n```\\n    1\\n   / \\\\\\n  2   3\\n```\\nto make cost equal, we add 1 to 2\\n\\nIf 7 nodes,\\n```\\n            1\\n           / \\\\\\n          2   3\\n         / \\\\ / \\\\\\n        4  5 6  7\\n```\\nwe add 1 to 4, to make 1->2->4 and 1->2->5 have equal cost.\\nwe add 1 to 6, to make 1->3->6 and 1->3->7 have equal cost.\\nTo make 1->2->5 and 1->3->7 have equal cost, we need to add 3 to 2 (3+7-(2+5))\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution:\\n    def minIncrements(self, n: int, cost: List[int]) -> int:\\n        res = 0\\n        for i in range(len(cost)-1, 1, -2): # from leaf to root\\n            res += abs(cost[i] - cost[i-1]) # make two nodes with same parent equal\\n            cost[(i-1)//2] += max(cost[i], cost[i-1]) # add the cost to the parent\\n        return res\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n    1\\n   / \\\\\\n  2   3\\n```\n```\\n            1\\n           / \\\\\\n          2   3\\n         / \\\\ / \\\\\\n        4  5 6  7\\n```\n```\\nclass Solution:\\n    def minIncrements(self, n: int, cost: List[int]) -> int:\\n        res = 0\\n        for i in range(len(cost)-1, 1, -2): # from leaf to root\\n            res += abs(cost[i] - cost[i-1]) # make two nodes with same parent equal\\n            cost[(i-1)//2] += max(cost[i], cost[i-1]) # add the cost to the parent\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3575840,
                "title": "c-no-dfs-easy-solution",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\nint minIncrements(int n, vector<int> &cost)\\n{\\n    int ans = 0;\\n    for (int i = n / 2 - 1; i >= 0; i--)\\n    {\\n        int left = i * 2 + 1;\\n        int right = i * 2 + 2;\\n\\n        ans += abs(cost[left] - cost[right]);\\n\\n        cost[i] += max(cost[left], cost[right]);\\n\\n    }\\n    return ans;\\n}\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nint minIncrements(int n, vector<int> &cost)\\n{\\n    int ans = 0;\\n    for (int i = n / 2 - 1; i >= 0; i--)\\n    {\\n        int left = i * 2 + 1;\\n        int right = i * 2 + 2;\\n\\n        ans += abs(cost[left] - cost[right]);\\n\\n        cost[i] += max(cost[left], cost[right]);\\n\\n    }\\n    return ans;\\n}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3568199,
                "title": "2673-make-costs-of-paths-equal-in-a-binary-tree-java",
                "content": "```\\nclass Solution {\\n    int ans=0;\\n    public int solve(int [] cost,int n,int ind)\\n    {\\n        if(ind>=n)\\n            return 0;\\n        int left=solve(cost,n,2*ind+1);\\n        int right=solve(cost,n,2*ind+2);\\n        ans+=Math.abs(left-right);\\n        return cost[ind]+Math.max(left,right);\\n    }\\n    public int minIncrements(int n, int[] cost) {\\n        solve(cost,n,0);\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    int ans=0;\\n    public int solve(int [] cost,int n,int ind)\\n    {\\n        if(ind>=n)\\n            return 0;\\n        int left=solve(cost,n,2*ind+1);\\n        int right=solve(cost,n,2*ind+2);\\n        ans+=Math.abs(left-right);\\n        return cost[ind]+Math.max(left,right);\\n    }\\n    public int minIncrements(int n, int[] cost) {\\n        solve(cost,n,0);\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3543167,
                "title": "simple-bfs-solution-with-time-complexity-o-n-no-recursion",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n- Space complexity: $$O(n)$$\\n\\n# Code\\n``` golang []\\nfunc max(a, b int) int {\\n    if a > b {\\n        return a\\n    }\\n\\n    return b\\n}\\n\\n\\nfunc min(a, b int) int {\\n    if a > b {\\n        return b\\n    }\\n\\n    return a\\n}\\n\\n\\nfunc minIncrements(n int, cost []int) int {\\n    var ans int\\n    var sums []int = make([]int, n / 2)\\n\\n    for i := n - 1; i > 1; i -= 2 {\\n        left_sum, right_sum := cost[i - 1], cost[i]\\n\\n        if i < len(sums) {\\n            left_sum += sums[i - 1]\\n            right_sum += sums[i]\\n        }\\n        \\n        sums[i / 2 - 1] = max(left_sum, right_sum)\\n        ans += sums[i / 2 - 1] - min(left_sum, right_sum)\\n    }\\n\\n    return ans\\n}\\n\\n```\\n``` python []\\nclass Solution:\\n    def minIncrements(self, n: int, cost: List[int]) -> int:\\n        ans = 0\\n        sums = [0] * (n // 2)\\n\\n        for i in range(n - 1, 1, -2):\\n            left_sum, right_sum = cost[i - 1], cost[i]\\n            if i < len(sums):\\n                left_sum += sums[i - 1]\\n                right_sum += sums[i]\\n\\n            sums[i // 2 - 1] = max(left_sum, right_sum)\\n            ans += sums[i // 2 - 1] - min(left_sum, right_sum)\\n\\n        return ans\\n\\n```",
                "solutionTags": [
                    "Python3",
                    "Go",
                    "Dynamic Programming",
                    "Breadth-First Search"
                ],
                "code": "``` golang []\\nfunc max(a, b int) int {\\n    if a > b {\\n        return a\\n    }\\n\\n    return b\\n}\\n\\n\\nfunc min(a, b int) int {\\n    if a > b {\\n        return b\\n    }\\n\\n    return a\\n}\\n\\n\\nfunc minIncrements(n int, cost []int) int {\\n    var ans int\\n    var sums []int = make([]int, n / 2)\\n\\n    for i := n - 1; i > 1; i -= 2 {\\n        left_sum, right_sum := cost[i - 1], cost[i]\\n\\n        if i < len(sums) {\\n            left_sum += sums[i - 1]\\n            right_sum += sums[i]\\n        }\\n        \\n        sums[i / 2 - 1] = max(left_sum, right_sum)\\n        ans += sums[i / 2 - 1] - min(left_sum, right_sum)\\n    }\\n\\n    return ans\\n}\\n\\n```\n``` python []\\nclass Solution:\\n    def minIncrements(self, n: int, cost: List[int]) -> int:\\n        ans = 0\\n        sums = [0] * (n // 2)\\n\\n        for i in range(n - 1, 1, -2):\\n            left_sum, right_sum = cost[i - 1], cost[i]\\n            if i < len(sums):\\n                left_sum += sums[i - 1]\\n                right_sum += sums[i]\\n\\n            sums[i // 2 - 1] = max(left_sum, right_sum)\\n            ans += sums[i // 2 - 1] - min(left_sum, right_sum)\\n\\n        return ans\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3529561,
                "title": "java-simple-dfs",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nSee comments\\n# Complexity\\nT O(N)\\nS O(1)\\n\\n# Code\\n```\\nclass Solution {\\n    int res = 0;\\n    public int minIncrements(int n, int[] cost) {\\n        dfs(1, cost);\\n        return res;\\n    }\\n\\n    // get the max cost of a path of sub tree root at i;\\n    public int dfs(int i, int[] cost) {\\n        if (i > cost.length) return 0;\\n        int left = dfs(i * 2, cost), right = dfs(i * 2 + 1, cost);\\n        // you need keep two child tree has the same cost of path.\\n        // best way to tune the root of lower cost path, increase the\\n        // lower root, by Math.abs(left - right);\\n        res += Math.abs(left - right);\\n        return cost[i - 1] + Math.max(left, right);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    int res = 0;\\n    public int minIncrements(int n, int[] cost) {\\n        dfs(1, cost);\\n        return res;\\n    }\\n\\n    // get the max cost of a path of sub tree root at i;\\n    public int dfs(int i, int[] cost) {\\n        if (i > cost.length) return 0;\\n        int left = dfs(i * 2, cost), right = dfs(i * 2 + 1, cost);\\n        // you need keep two child tree has the same cost of path.\\n        // best way to tune the root of lower cost path, increase the\\n        // lower root, by Math.abs(left - right);\\n        res += Math.abs(left - right);\\n        return cost[i - 1] + Math.max(left, right);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3511150,
                "title": "dfs-and-bfs",
                "content": "# Intuition\\nWe need to find how much value for each node we can increment while moving from root to leaf such that on reaching each leaf we will get same sum.\\n\\n# Approach\\nFor a given node the minimum value we can increment will be minimum of (sum from root to given node - max value of sum from left child to any leaf, sum from root to given node - max value of sum from right child to any of it leaft). We will add this value to given node and to the ans(which count minimum increment to make all value from root to leaf equal).\\n\\n# Complexity\\n- Time complexity: O(n)\\n\\n- Space complexity: O(n)\\n\\n# Code\\n```\\nclass Solution {\\nprivate:\\n    void dfs(int s,vector<int>&cost,vector<int>&maxSum){\\n        if(s>(int)cost.size()) return ;\\n        dfs(2*s,cost,maxSum);\\n        dfs(2*s+1,cost,maxSum);\\n        maxSum[s]=cost[s-1]+max(maxSum[2*s],maxSum[(2*s)+1]);\\n    }\\npublic:\\n    int minIncrements(int n, vector<int>& cost) {\\n        vector<int>maxSum(4*n,0);\\n        dfs(1,cost,maxSum);\\n        queue<pair<int,int>>q;\\n        q.push({1,cost[0]});\\n        int total=0;\\n        while(!q.empty()){\\n            int n=q.size();\\n            int numEle=n;\\n            int sum=0;\\n            int mx=INT_MIN;\\n            while(n--){\\n                int front=q.front().first;\\n                int s=q.front().second;\\n                q.pop();\\n                int val=min(maxSum[1] - (s+maxSum[2*front]), maxSum[1] - (s+maxSum[2*front + 1]));   // maxSum[1] will contain max sum from root to any leaf\\n                total+=val;\\n                s+=val;\\n                if((2*front)<=(int)cost.size()) q.push({2*front,s+cost[2*front-1]});\\n                if(2*front+1<=(int)cost.size()) q.push({2*front+1,s+cost[2*front]});\\n            }\\n        }\\n        return total;\\n    }\\n};\\n```\\n\\n# Follow Up\\nFrom this approach we can also print how much value added to each node.",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    void dfs(int s,vector<int>&cost,vector<int>&maxSum){\\n        if(s>(int)cost.size()) return ;\\n        dfs(2*s,cost,maxSum);\\n        dfs(2*s+1,cost,maxSum);\\n        maxSum[s]=cost[s-1]+max(maxSum[2*s],maxSum[(2*s)+1]);\\n    }\\npublic:\\n    int minIncrements(int n, vector<int>& cost) {\\n        vector<int>maxSum(4*n,0);\\n        dfs(1,cost,maxSum);\\n        queue<pair<int,int>>q;\\n        q.push({1,cost[0]});\\n        int total=0;\\n        while(!q.empty()){\\n            int n=q.size();\\n            int numEle=n;\\n            int sum=0;\\n            int mx=INT_MIN;\\n            while(n--){\\n                int front=q.front().first;\\n                int s=q.front().second;\\n                q.pop();\\n                int val=min(maxSum[1] - (s+maxSum[2*front]), maxSum[1] - (s+maxSum[2*front + 1]));   // maxSum[1] will contain max sum from root to any leaf\\n                total+=val;\\n                s+=val;\\n                if((2*front)<=(int)cost.size()) q.push({2*front,s+cost[2*front-1]});\\n                if(2*front+1<=(int)cost.size()) q.push({2*front+1,s+cost[2*front]});\\n            }\\n        }\\n        return total;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3502665,
                "title": "python-from-the-last-level-to-root-explained",
                "content": "Since we are dealing with the prefect binary tree, each node except the nodes on the last level has two children.\\n\\nLet\\'s considering the two children from the same parent. We have two pathes from the two children and the  difference between the two pathes is the difference of the children nodes because they share the same previous path from root. \\n\\nTherefore, to make the two pathes equal, we just need to check the value of the two children nodes. If they are not the same, we increase the one with the samller value. For the two pathes, the minimum number to inrease is difference between the two children.\\n\\nAfter the increase, the path cost to their parent would be the parent value + the max value of the two children. We can add this cost to the parent node. Next step, we apply the same method to the parent nodes level. Once we get to the root node, we can find out the minimum increases we need to make all the pathes equal.\\n\\nSee the code below:\\n\\n```\\nclass Solution:\\n    def minIncrements(self, n: int, cost: List[int]) -> int:\\n        idx, ans = n - 1, 0\\n        while idx >= 2:\\n            parent_idx = idx // 2 - 1\\n            child_cost = cost[idx]\\n            if cost[idx] != cost[idx - 1]:\\n                child_cost = max(cost[idx], cost[idx - 1])\\n                ans += abs(cost[idx] - cost[idx - 1])\\n            cost[parent_idx] += child_cost\\n            idx -= 2\\n        return ans\\n```",
                "solutionTags": [
                    "Python3",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution:\\n    def minIncrements(self, n: int, cost: List[int]) -> int:\\n        idx, ans = n - 1, 0\\n        while idx >= 2:\\n            parent_idx = idx // 2 - 1\\n            child_cost = cost[idx]\\n            if cost[idx] != cost[idx - 1]:\\n                child_cost = max(cost[idx], cost[idx - 1])\\n                ans += abs(cost[idx] - cost[idx - 1])\\n            cost[parent_idx] += child_cost\\n            idx -= 2\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3497934,
                "title": "java-easy-to-understand-dfs",
                "content": "Description:\\nThe task is to find the minimum number of increment operations required to make all the paths in a given binary tree with given cost values equal. This can be achieved by first calculating the maximum path sum in the binary tree and then finding the minimum number of operations required to make each path equal to the maximum path sum.\\nIntution:\\nWe can always make all paths equal by incrementing those leaf nodes where path sum is less than the maximum.\\nIn order to calculate the minimum operations we wil first do all the operations at last. Now at an arbitrary level which is non-root and non-leaf level we will do the minimum of operations done by it left and right child and decrease our total operations by same as we our doing operations on a common node. we will return number of operations done at this level to upperlevels.\\n```\\nclass Solution {\\n    int myN,max;\\n    int ans=0;\\n    public int minIncrements(int n, int[] cost) {\\n        myN = n;\\n        max =  helper(0,cost);\\n        helper2(0,0,cost);\\n        return ans;\\n    }\\n\\t//to calculate maximum path sum.\\n    int helper(int i,int[] cost){\\n        if(i>=myN) return 0;\\n        int left = helper(2*i+1,cost);\\n        int right = helper(2*i+2,cost);\\n        return cost[i]+Math.max(left,right);\\n    }\\n\\t//to calculate minimum operations\\n    int helper2(int i,int sum,int[] cost){\\n        if(i>=myN){\\n\\t\\t\\t//update answer with operations needed\\n            ans+=(max-sum);\\n            return max-sum;\\n        }\\n\\t\\t//get operations done by lower leverls.\\n        int left = helper2(2*i+1,sum+cost[i],cost);\\n        int right = helper2(2*i+2,sum+cost[i],cost);\\n        \\n\\t\\t//reduce ans by min left,right\\n        ans-=(Math.min(left,right));\\n        return Math.min(left,right);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Greedy",
                    "Depth-First Search",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    int myN,max;\\n    int ans=0;\\n    public int minIncrements(int n, int[] cost) {\\n        myN = n;\\n        max =  helper(0,cost);\\n        helper2(0,0,cost);\\n        return ans;\\n    }\\n\\t//to calculate maximum path sum.\\n    int helper(int i,int[] cost){\\n        if(i>=myN) return 0;\\n        int left = helper(2*i+1,cost);\\n        int right = helper(2*i+2,cost);\\n        return cost[i]+Math.max(left,right);\\n    }\\n\\t//to calculate minimum operations\\n    int helper2(int i,int sum,int[] cost){\\n        if(i>=myN){\\n\\t\\t\\t//update answer with operations needed\\n            ans+=(max-sum);\\n            return max-sum;\\n        }\\n\\t\\t//get operations done by lower leverls.\\n        int left = helper2(2*i+1,sum+cost[i],cost);\\n        int right = helper2(2*i+2,sum+cost[i],cost);\\n        \\n\\t\\t//reduce ans by min left,right\\n        ans-=(Math.min(left,right));\\n        return Math.min(left,right);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3496927,
                "title": "python3-solution",
                "content": "\\n```\\nclass Solution:\\n    def minIncrements(self, n: int, cost: List[int]) -> int:\\n        ans = 0\\n        for i in range(n // 2 - 1, -1, -1):\\n            left, right = i * 2 + 1, i * 2 + 2\\n            ans += abs(cost[left] - cost[right])\\n            cost[i] += max(cost[left], cost[right])\\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minIncrements(self, n: int, cost: List[int]) -> int:\\n        ans = 0\\n        for i in range(n // 2 - 1, -1, -1):\\n            left, right = i * 2 + 1, i * 2 + 2\\n            ans += abs(cost[left] - cost[right])\\n            cost[i] += max(cost[left], cost[right])\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3496903,
                "title": "c-intuitive-solution-dfs",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int ans = 0;\\n    int max_sum = INT_MIN;\\n\\n    int dfs1(vector<int>& cost, int root, int n) {\\n        if (2 * root > n) {\\n            return cost[root - 1];\\n        }\\n        int left = dfs1(cost, 2 * root, n);\\n        int right = dfs1(cost, 2 * root + 1, n);\\n        return max(left, right) + cost[root - 1];\\n    }\\n\\n    int dfs(vector<int>& cost, int root, int curr_sum, int max_sum, int n) {\\n        if (2 * root > n) {\\n            return max_sum - curr_sum - cost[root - 1];\\n        }\\n        int left = dfs(cost, 2 * root, curr_sum + cost[root - 1], max_sum, n);\\n        int right = dfs(cost, 2 * root + 1, curr_sum + cost[root - 1], max_sum, n);\\n        ans += abs(left - right);\\n        return min(left, right);\\n    }\\n\\n    int minIncrements(int n,vector<int>& nums) {\\n \\n        max_sum = dfs1(nums, 1, n);\\n        dfs(nums, 1, 0, max_sum, n);\\n        return ans;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int ans = 0;\\n    int max_sum = INT_MIN;\\n\\n    int dfs1(vector<int>& cost, int root, int n) {\\n        if (2 * root > n) {\\n            return cost[root - 1];\\n        }\\n        int left = dfs1(cost, 2 * root, n);\\n        int right = dfs1(cost, 2 * root + 1, n);\\n        return max(left, right) + cost[root - 1];\\n    }\\n\\n    int dfs(vector<int>& cost, int root, int curr_sum, int max_sum, int n) {\\n        if (2 * root > n) {\\n            return max_sum - curr_sum - cost[root - 1];\\n        }\\n        int left = dfs(cost, 2 * root, curr_sum + cost[root - 1], max_sum, n);\\n        int right = dfs(cost, 2 * root + 1, curr_sum + cost[root - 1], max_sum, n);\\n        ans += abs(left - right);\\n        return min(left, right);\\n    }\\n\\n    int minIncrements(int n,vector<int>& nums) {\\n \\n        max_sum = dfs1(nums, 1, n);\\n        dfs(nums, 1, 0, max_sum, n);\\n        return ans;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3495921,
                "title": "simple-java-solution-in-o-n-time-complexity-with-explanation",
                "content": "\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- Iterate from the nth node to the root node and compute the cost of path from the leaf node to the current node.\\n- As the tree is a complete binary tree, there will always be pair of left and right child nodes except for the root node.\\n- If the current node is leaf node, make the max of left and right node cost as the cost of path from bottom for both the nodes.\\n- The difference between the costs of 2 nodes give the number of increments required.\\n- If the nodes are not leaf nodes, calculate the number of increments required to make the cost of paths from bottom equal for the both nodes. \\n- In above step, increments might be needed for one of the 2 nodes, so that cost or path from leaf node becomes equal for both the nodes. \\n`cost[left-1] + cb[2*left] + k = cost[right-1] + cb[2*right]`\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n) for additional array\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minIncrements(int n, int[] cost) {\\n        int[] cb = new int[n]; // cost from bottom\\n        int i = n;\\n        int res = 0;\\n        while(i>1){\\n            int r = i--;\\n            int l = i--;\\n            // if these are leaf nodes\\n            if(2*r > n){\\n                int max = Math.max(cost[l-1],cost[r-1]);\\n                cb[l-1] = max;\\n                cb[r-1] = max;\\n                res += Math.abs(cost[l-1]-cost[r-1]);\\n                continue;\\n            }\\n\\n            if(cost[l-1] + cb[2*l] <= cost[r-1] + cb[2*r]){\\n                int k = cost[r-1] + cb[2*r] - cb[2*l] - cost[l-1];\\n                // k is added to l\\n                res += k;\\n                cb[l-1] = cost[r-1] + cb[2*r];\\n                cb[r-1] = cost[r-1] + cb[2*r];\\n            }else{\\n                int k = cost[l-1] + cb[2*l] - cost[r-1] - cb[2*r];\\n                res += k;\\n                cb[l-1] = cost[l-1] + cb[2*l];\\n                cb[r-1] = cost[l-1] + cb[2*l];\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minIncrements(int n, int[] cost) {\\n        int[] cb = new int[n]; // cost from bottom\\n        int i = n;\\n        int res = 0;\\n        while(i>1){\\n            int r = i--;\\n            int l = i--;\\n            // if these are leaf nodes\\n            if(2*r > n){\\n                int max = Math.max(cost[l-1],cost[r-1]);\\n                cb[l-1] = max;\\n                cb[r-1] = max;\\n                res += Math.abs(cost[l-1]-cost[r-1]);\\n                continue;\\n            }\\n\\n            if(cost[l-1] + cb[2*l] <= cost[r-1] + cb[2*r]){\\n                int k = cost[r-1] + cb[2*r] - cb[2*l] - cost[l-1];\\n                // k is added to l\\n                res += k;\\n                cb[l-1] = cost[r-1] + cb[2*r];\\n                cb[r-1] = cost[r-1] + cb[2*r];\\n            }else{\\n                int k = cost[l-1] + cb[2*l] - cost[r-1] - cb[2*r];\\n                res += k;\\n                cb[l-1] = cost[l-1] + cb[2*l];\\n                cb[r-1] = cost[l-1] + cb[2*l];\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3495843,
                "title": "different-approach-similar-to-merge-sort-o-nlog-n-c",
                "content": "# Intuition and Approach\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe intuition behind this solution is to think of divide and conquer algorithm.\\ni.e. lets say we have a array arr, which contains every path cost from root to leaf.\\narr = {10,4,12,15};\\nHere the common node for whole array is node 1.\\nthe common node for {10,4} is 2.\\nthe common node for {12,15} is 3.\\nthe common node for {10} is 4.\\nthe common node for {4} is 5.\\nthe common node for {12} is 6.\\nthe common node for {15} is 7.\\n\\nyou can scale this to some bigger perfect binary trees also.\\nto change both {10,4} values simultaneously we can change the value of their common node (here the common node is 2).\\n\\n<!-- # Approach\\nDescribe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(N*log(N))$$ Here N is the number of leaf nodes\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(N)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    // this array contains every cost of path from root to leaf\\n    vector<int> ans;\\n    \\n    void rec(vector<int> &cost,int n,int node,int val){\\n        if(node*2>n){\\n            // pushing the cost of path from root to leaf (node)\\n            ans.push_back(val+cost[node-1]);\\n            return;\\n        }\\n        \\n        rec(cost,n,2*node,val+cost[node-1]);\\n        rec(cost,n,2*node+1,val+cost[node-1]);\\n    }\\n    \\n    int cnt = 0; // this is our answer to the question\\n    int mx = -1; // this is the final value of every path\\n    \\n    //// this function is just like merge sort /////////////////\\n    void half(vector<int> &arr,int l,int r,int add){\\n        if(l>=r)\\n            return;\\n        int mid = (l+r)>>1;\\n        \\n        ////////////////// calculating maximum /////////////////\\n        int b = -1;\\n        for(int i=l;i<=mid;i++){\\n            b = max(b,arr[i]+add);\\n        }\\n        /// why doing max(b,arr[i]+add)\\n        /// arr[i] + add. here add variable tell us the total\\n        /// value that we have added to the parent or ancestor\\n        /// that came befor our current node. so if we have\\n        /// increase our ancestor by value add then we must also\\n        /// increase its childrens the the same value add.\\n        ////////////////////////////////////////////////////////\\n        \\n        cnt+=(mx-b); // how much to increase in this segment l - mid\\n        half(arr,l,mid,add+(mx-b));\\n        /// add+(mx-b). here mx-b tell us how much we need to increase\\n        /// the common node to make the value of the max to become \\n        /// mx i.e. the final equal value\\n        ////////////////////////////////////////////////////////\\n\\n        ///////////////// calculating maximum //////////////////\\n        b = -1;\\n        for(int i = mid+1;i<=r;i++){\\n            b = max(b,arr[i]+add);\\n        }\\n        ////////////////////////////////////////////////////////\\n\\n        cnt+=(mx-b); // how much to increase in this segment mid+1 - r\\n        half(arr,mid+1,r,add+(mx-b));\\n    }\\n    \\npublic:\\n    int minIncrements(int n, vector<int>& cost) {\\n        rec(cost,n,1,0);\\n        /// calculating the final common value /////\\n        for(auto it:ans){\\n            mx = max(mx,it);\\n        }\\n        half(ans,0,ans.size()-1,0);  \\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Divide and Conquer",
                    "Depth-First Search",
                    "Merge Sort",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    // this array contains every cost of path from root to leaf\\n    vector<int> ans;\\n    \\n    void rec(vector<int> &cost,int n,int node,int val){\\n        if(node*2>n){\\n            // pushing the cost of path from root to leaf (node)\\n            ans.push_back(val+cost[node-1]);\\n            return;\\n        }\\n        \\n        rec(cost,n,2*node,val+cost[node-1]);\\n        rec(cost,n,2*node+1,val+cost[node-1]);\\n    }\\n    \\n    int cnt = 0; // this is our answer to the question\\n    int mx = -1; // this is the final value of every path\\n    \\n    //// this function is just like merge sort /////////////////\\n    void half(vector<int> &arr,int l,int r,int add){\\n        if(l>=r)\\n            return;\\n        int mid = (l+r)>>1;\\n        \\n        ////////////////// calculating maximum /////////////////\\n        int b = -1;\\n        for(int i=l;i<=mid;i++){\\n            b = max(b,arr[i]+add);\\n        }\\n        /// why doing max(b,arr[i]+add)\\n        /// arr[i] + add. here add variable tell us the total\\n        /// value that we have added to the parent or ancestor\\n        /// that came befor our current node. so if we have\\n        /// increase our ancestor by value add then we must also\\n        /// increase its childrens the the same value add.\\n        ////////////////////////////////////////////////////////\\n        \\n        cnt+=(mx-b); // how much to increase in this segment l - mid\\n        half(arr,l,mid,add+(mx-b));\\n        /// add+(mx-b). here mx-b tell us how much we need to increase\\n        /// the common node to make the value of the max to become \\n        /// mx i.e. the final equal value\\n        ////////////////////////////////////////////////////////\\n\\n        ///////////////// calculating maximum //////////////////\\n        b = -1;\\n        for(int i = mid+1;i<=r;i++){\\n            b = max(b,arr[i]+add);\\n        }\\n        ////////////////////////////////////////////////////////\\n\\n        cnt+=(mx-b); // how much to increase in this segment mid+1 - r\\n        half(arr,mid+1,r,add+(mx-b));\\n    }\\n    \\npublic:\\n    int minIncrements(int n, vector<int>& cost) {\\n        rec(cost,n,1,0);\\n        /// calculating the final common value /////\\n        for(auto it:ans){\\n            mx = max(mx,it);\\n        }\\n        half(ans,0,ans.size()-1,0);  \\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3495594,
                "title": "simple-dfs-illstrated-c-6line",
                "content": "# Intuition\\nWe want our binary tree to verify the equal path property (the cost to go from root to any leaf has to be the same). I will call a binary tree which verifies this property balanced.\\nThe key logic is the following:\\n\\nThe optimal strategy is to ensure every subtree is balanced\\n\\nWhy is this true? Well, let\\u2019s imagine that there is a subtree rooted at a node subroot which is unbalanced. That is to say it can reach a certain leaf1 for lowcost, and another leaf2 for a different highcost.\\nWell, in that case, its parent node will reach leaf1 for lowcost+cost[subroot] and leaf2 for highcost+cost[subroot], which are different costs. We see that the unbalanced property is recursive: if any subtree is unbalanced, it will \\u201Ccontaminate\\u201D the parent.\\n![56b9ad51-e064-459f-a063-513c10ce5d02_1683437244.2906523.png](https://assets.leetcode.com/users/images/0a60aa6d-095d-4480-a3e0-804d77d7f2f8_1683439721.0159767.png)\\n\\n\\nTherefore, if we want to balance root, it is necessary to balance every subroot on its way. It is easy to verify that this is also a sufficient condition. So this is the optimal way to do it, because it is in fact the only way to do it! (root is balanced if and only if all of the subtrees are balanced)\\n\\nThat begs for a recursive approach! If we ensure starting from every leaf, that every subtree is balanced, then it\\u2019s easy to make the right corrections to balance the parent too!\\n\\n\\nApproach\\nLet\\u2019s do a recursive dfs.\\n\\nWe position ourselves at a specific node subroot and will treat it as the root of a subtree. We assume that all of its subtrees are already balanced (done earlier in the recursion). Then its left child reaches all leaves for leftcost, and the right child for rightcost. We just need to make a correction according to the difference between those two (correction+=abs(leftcost-rightcost)) to balance the subroot.\\n\\nWe then return the total cost of this subroot which is simply max(leftcost,rightcost)+cost[subroot]. The maximum is taken here because we can only increment, so that means after we balance a subtree, its cost to leaf will be set to the largest of the initial values.\\n\\nAnd that\\u2019s it! If this helped you understand the proof of correctness and visualize it, do leave an upvote, it is always encouraging!\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int ans=0;\\n    int dfs (int node ,vector<int>&cost)\\n    {    \\n        if(node>cost.size())return 0;\\n        int left=0 ,right=0;\\n        left= dfs(2*node,cost);\\n        right=dfs(2*node+1,cost);\\n        ans+=abs(left-right);\\n        return cost[node-1]+max(left,right);\\n    }\\n    int minIncrements(int N, vector<int>& cost)\\n    {\\n        dfs(1,cost);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int ans=0;\\n    int dfs (int node ,vector<int>&cost)\\n    {    \\n        if(node>cost.size())return 0;\\n        int left=0 ,right=0;\\n        left= dfs(2*node,cost);\\n        right=dfs(2*node+1,cost);\\n        ans+=abs(left-right);\\n        return cost[node-1]+max(left,right);\\n    }\\n    int minIncrements(int N, vector<int>& cost)\\n    {\\n        dfs(1,cost);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3495490,
                "title": "c-simple-implementation",
                "content": "**Algorithm:**\\n\\nThe variables used in the solution are:\\n* n -> the size of the binary tree array\\n* cost -> a vector of size n containing the costs of each node in the binary tree\\n* v -> a vector to store the sum of costs for each leaf node\\n* ans -> the minimum number of increments\\n\\nThe solution first constructs an array v of size (N + 1) / 2, where N is the size of the binary tree array. For each leaf node in the binary tree, the solution calculates the sum of costs along the path from the leaf node to the root node and appends it to the array v.\\n\\nThe algorithm then performs a loop until the size of v becomes 1. In each iteration, it creates a new empty vector v1 to store the maximum value of adjacent elements from the previous iteration. It then loops over the elements of v and performs the following operations:\\n\\n* Compute the absolute difference between the adjacent elements.\\n* Increment the answer by the absolute difference.\\n* Compute the maximum value of the adjacent elements.\\n* Append the maximum value to the vector v1.\\n\\nFinally, the algorithm returns the value of the answer variable.\\n\\n**Code**\\n```\\nclass Solution {\\npublic:\\n    int minIncrements(int n, vector<int>& cost) {\\n        vector<int> v;\\n        int ans = 0;\\n        for(int i = 0;i<n;i++){\\n            int child = 2 * (i + 1);\\n            if(child > n){\\n                int par = (i + 1) / 2;\\n                int sum = 0;\\n                int x = i + 1;\\n                while(x){\\n                    sum += cost[x - 1];\\n                    x /= 2;\\n                }\\n                v.push_back(sum);\\n            }\\n        }\\n        while(v.size() > 1){\\n            vector<int> v1;\\n            for(int i = 0;i<v.size();i+=2){\\n                int a = v[i] , b = v[i+1];\\n                int diff = abs(b - a);\\n                ans += diff;\\n                int mx = max(a, b);\\n                v1.push_back(mx);\\n            }\\n            v = v1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minIncrements(int n, vector<int>& cost) {\\n        vector<int> v;\\n        int ans = 0;\\n        for(int i = 0;i<n;i++){\\n            int child = 2 * (i + 1);\\n            if(child > n){\\n                int par = (i + 1) / 2;\\n                int sum = 0;\\n                int x = i + 1;\\n                while(x){\\n                    sum += cost[x - 1];\\n                    x /= 2;\\n                }\\n                v.push_back(sum);\\n            }\\n        }\\n        while(v.size() > 1){\\n            vector<int> v1;\\n            for(int i = 0;i<v.size();i+=2){\\n                int a = v[i] , b = v[i+1];\\n                int diff = abs(b - a);\\n                ans += diff;\\n                int mx = max(a, b);\\n                v1.push_back(mx);\\n            }\\n            v = v1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3495268,
                "title": "python-5-lines-o-n-beats-100",
                "content": "# Intuition\\n**The main insight is that two sibling leaves must have the same cost, if the path from root to them is to be the same, since they share the path to their direct parent.**\\nSo we start equalizing costs at the leaf level and go up, level by level, by adding the leaf costs to the parents (has same effect as removing the leaves, and we now deal with a smaller problem).\\n\\n# Approach\\nSince this is a full binary tree, it has `2^k-1` nodes distributed in `k` levels. Levels start, bottom to top, at `2^(k-1)`, `2^(k-2)` ... `2^1`, `2^0`. In the code `p` is the start node for the level being considered. On each level we look at pair of nodes (nodes `i` and `i+1`), equalize their values (increase the smaller to the larger value), update current value of the result by the difference, and update cost of their parent (node `i//2`).\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def minIncrements(self, n: int, cost: List[int]) -> int:\\n        res = 0\\n        p = (n+1)//2 # start of leaves level\\n        while p > 1:\\n            i = p\\n            while i < 2*p:\\n                res += abs(cost[i-1]-cost[i]) # equalize the children nodes\\n                cost[i//2 - 1] += max(cost[i-1], cost[i]) # add cost of chidren to parent\\n                i += 2 # move to next pair of left/right nodes\\n            p //= 2 # go one level up\\n        return res        \\n```\\n\\nOnce you understand the code above, take a look at this more **concise version (5 lines)** of the same code:\\n\\n```\\n    def minIncrements(self, n: int, cost: List[int]) -> int:\\n        res = 0\\n        for i in reversed(range(2,n,2)):\\n            res += abs(cost[i-1]-cost[i])\\n            cost[i//2 - 1] += max(cost[i-1], cost[i])\\n        return res\\n```\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minIncrements(self, n: int, cost: List[int]) -> int:\\n        res = 0\\n        p = (n+1)//2 # start of leaves level\\n        while p > 1:\\n            i = p\\n            while i < 2*p:\\n                res += abs(cost[i-1]-cost[i]) # equalize the children nodes\\n                cost[i//2 - 1] += max(cost[i-1], cost[i]) # add cost of chidren to parent\\n                i += 2 # move to next pair of left/right nodes\\n            p //= 2 # go one level up\\n        return res        \\n```\n```\\n    def minIncrements(self, n: int, cost: List[int]) -> int:\\n        res = 0\\n        for i in reversed(range(2,n,2)):\\n            res += abs(cost[i-1]-cost[i])\\n            cost[i//2 - 1] += max(cost[i-1], cost[i])\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3495243,
                "title": "python-iterative-solution-o-n",
                "content": "# Intuition and Approach\\n* we have to find the minimum no. of increment operations.\\n* we will go for divide and conquer approach in which we will first find the no. of operations in left and right tree.\\n* simaltaneously we will store the cost from root to leaf at the root.\\n* Trick: two children tree must have the same cost from root to leaf.\\n* * if they had diff then make them same by increasing the smaller one with the diff. and cost of parent tree=max of both + cost of parent node.\\n* * ans+=max(lc,rc)-min(lc,rc); parent+=max(lc,rc);\\n* at the end return the sum of total oprations\\n\\n# Complexity\\n- Time complexity:O(N)\\n\\n- Space complexity:O(1)\\n# Code\\n```\\nclass Solution:\\n    def minIncrements(self, n: int, cost: List[int]) -> int:\\n        ans=0\\n        for i in range(n-1,-1,-1):\\n            if((2*i)+2>=n):continue\\n            else:\\n                l=cost[(2*i)+1]\\n                r=cost[(2*i)+2]\\n                ans+=(max(l,r)-min(l,r))\\n                cost[i]+=max(l,r)\\n                # print(i,cost[i],ans)\\n        return ans\\n            \\n        \\n```",
                "solutionTags": [
                    "Python3",
                    "Divide and Conquer",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution:\\n    def minIncrements(self, n: int, cost: List[int]) -> int:\\n        ans=0\\n        for i in range(n-1,-1,-1):\\n            if((2*i)+2>=n):continue\\n            else:\\n                l=cost[(2*i)+1]\\n                r=cost[(2*i)+2]\\n                ans+=(max(l,r)-min(l,r))\\n                cost[i]+=max(l,r)\\n                # print(i,cost[i],ans)\\n        return ans\\n            \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3495176,
                "title": "c-dfs",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$ \\n\\n- Space complexity: $$O(n)$$ \\n\\n# Code\\n```\\npublic class Solution \\n{\\n    int result;\\n    public int MinIncrements(int n, int[] cost) \\n    {\\n        result = 0;\\n        DFS(1, n, cost);\\n        return result;\\n    }\\n\\n    private int DFS(int curr, int n, int[] cost)\\n    {\\n        if (curr > n / 2)\\n            return cost[curr - 1];\\n        int left = DFS(2 * curr, n, cost);\\n        int right = DFS(2 * curr + 1, n, cost);\\n        result += Math.Abs(right - left);\\n        return Math.Max(left, right) + cost[curr - 1];\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution \\n{\\n    int result;\\n    public int MinIncrements(int n, int[] cost) \\n    {\\n        result = 0;\\n        DFS(1, n, cost);\\n        return result;\\n    }\\n\\n    private int DFS(int curr, int n, int[] cost)\\n    {\\n        if (curr > n / 2)\\n            return cost[curr - 1];\\n        int left = DFS(2 * curr, n, cost);\\n        int right = DFS(2 * curr + 1, n, cost);\\n        result += Math.Abs(right - left);\\n        return Math.Max(left, right) + cost[curr - 1];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3495152,
                "title": "rust-python-no-recursion-optimized-linear-solution-with-constant-additional-memory",
                "content": "# Intuition\\n\\nSolution in Rust is highly optimized which uses constant additional space and reuses original array. I leave nonoptimized python solution submitted by me during the contest as it shows the intuition and how I got to this solution.\\n\\nIn general the idea is:\\n\\n 1. find the cost of every path. This is `bfs` in python and just one look (first one) in rust (costs will be last `(n + 1) / 2` elements).\\n 2. then find the maximum costs of the paths. In Python this is last block in return statement in bfs. In rust, second loop\\n 3. Then traverse back to find which node will you increase values. While loop in python, and last for loop in rust\\n\\n# Complexity\\n- Time complexity: $O(n)$\\n- Space complexity: $O(1)$\\n\\n# Code\\n```Rust []\\nimpl Solution {\\n  pub fn min_increments(mut n: i32, mut cost: Vec<i32>) -> i32 {\\n    for i in 1 .. cost.len() {\\n      cost[i] += cost[(i - 1) / 2];\\n    }\\n\\n    let mut max = 0;\\n    for i in cost.len() / 2 .. cost.len() {\\n      max = max.max(cost[i]);\\n    }\\n\\n    for i in cost.len() / 2 .. cost.len() {\\n      cost[i] = max - cost[i];\\n    }\\n\\n    let mut res = 0;\\n    for i in (1 .. cost.len() / 2 + 1).rev() {\\n      let min = cost[2 * i].min(cost[2 * i - 1]);\\n      res += cost[2 * i] + cost[2 * i - 1] - 2 * min;\\n      cost[i - 1] = min;\\n    }\\n\\n    return res;\\n  }\\n}\\n```\\n```python []\\nclass Solution:\\n\\n  def __init__(self):\\n    self.res = 0\\n\\n  def bfs(self, cost):\\n    frontier = [(1, cost[0])]\\n    while True:\\n      new_frontier = []\\n      for i, c in frontier:\\n        if i * 2 < len(cost):\\n          new_frontier.append((i * 2, c + cost[i * 2 - 1]))\\n          new_frontier.append((i * 2 + 1, c + cost[i * 2]))\\n\\n      if not new_frontier:\\n        r = [c for _, c in frontier]\\n        max_val = max(r)\\n        return [max_val - v for v in r]\\n\\n      frontier = new_frontier\\n\\n  def cmd(self, diff):\\n    tmp = []\\n    for i in range(len(diff) // 2):\\n      v1, v2 = diff[i * 2], diff[i * 2 + 1]\\n      m = min(v1, v2)\\n      tmp.append(m)\\n      self.res += v1 - m + v2 - m\\n\\n    return tmp\\n\\n  def minIncrements(self, n: int, cost: List[int]) -> int:\\n    self.res = 0\\n    diff = self.bfs(cost)\\n    while len(diff) > 1:\\n      diff = self.cmd(diff)\\n\\n    return self.res\\n```\\n",
                "solutionTags": [
                    "Python3",
                    "Rust"
                ],
                "code": "```Rust []\\nimpl Solution {\\n  pub fn min_increments(mut n: i32, mut cost: Vec<i32>) -> i32 {\\n    for i in 1 .. cost.len() {\\n      cost[i] += cost[(i - 1) / 2];\\n    }\\n\\n    let mut max = 0;\\n    for i in cost.len() / 2 .. cost.len() {\\n      max = max.max(cost[i]);\\n    }\\n\\n    for i in cost.len() / 2 .. cost.len() {\\n      cost[i] = max - cost[i];\\n    }\\n\\n    let mut res = 0;\\n    for i in (1 .. cost.len() / 2 + 1).rev() {\\n      let min = cost[2 * i].min(cost[2 * i - 1]);\\n      res += cost[2 * i] + cost[2 * i - 1] - 2 * min;\\n      cost[i - 1] = min;\\n    }\\n\\n    return res;\\n  }\\n}\\n```\n```python []\\nclass Solution:\\n\\n  def __init__(self):\\n    self.res = 0\\n\\n  def bfs(self, cost):\\n    frontier = [(1, cost[0])]\\n    while True:\\n      new_frontier = []\\n      for i, c in frontier:\\n        if i * 2 < len(cost):\\n          new_frontier.append((i * 2, c + cost[i * 2 - 1]))\\n          new_frontier.append((i * 2 + 1, c + cost[i * 2]))\\n\\n      if not new_frontier:\\n        r = [c for _, c in frontier]\\n        max_val = max(r)\\n        return [max_val - v for v in r]\\n\\n      frontier = new_frontier\\n\\n  def cmd(self, diff):\\n    tmp = []\\n    for i in range(len(diff) // 2):\\n      v1, v2 = diff[i * 2], diff[i * 2 + 1]\\n      m = min(v1, v2)\\n      tmp.append(m)\\n      self.res += v1 - m + v2 - m\\n\\n    return tmp\\n\\n  def minIncrements(self, n: int, cost: List[int]) -> int:\\n    self.res = 0\\n    diff = self.bfs(cost)\\n    while len(diff) > 1:\\n      diff = self.cmd(diff)\\n\\n    return self.res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3495144,
                "title": "python-easy-solution-using-dfs",
                "content": "\\n# Code\\n```\\nclass Solution:\\n    def minIncrements(self, n: int, cost: List[int]) -> int:\\n        ans = 0\\n        def dfs(at):\\n            nonlocal ans\\n            left = 2*at+1\\n            right = left+1\\n            if left >= n: return cost[at]\\n            \\n            left_val = dfs(left)\\n            right_val = dfs(right)\\n            \\n            ans += abs(left_val-right_val)\\n            # cost[left] = cost[right] = max(cost[left], cost[right])\\n            return max(left_val, right_val) + cost[at]\\n        \\n        dfs(0)\\n        return ans\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minIncrements(self, n: int, cost: List[int]) -> int:\\n        ans = 0\\n        def dfs(at):\\n            nonlocal ans\\n            left = 2*at+1\\n            right = left+1\\n            if left >= n: return cost[at]\\n            \\n            left_val = dfs(left)\\n            right_val = dfs(right)\\n            \\n            ans += abs(left_val-right_val)\\n            # cost[left] = cost[right] = max(cost[left], cost[right])\\n            return max(left_val, right_val) + cost[at]\\n        \\n        dfs(0)\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3494981,
                "title": "easy-java-code-find-diff-in-cost-at-each-level",
                "content": "# Code\\n```\\nclass Solution {\\n    int result = 0;\\n    public int minIncrements(int n, int[] cost) {\\n        getCost(1, n, cost);\\n        return result;\\n    }\\n    \\n    private long getCost(int index, int n, int[] cost){\\n        if(index * 2 <= n){\\n            long leftCost = getCost(index * 2, n, cost);\\n            long rightCost = getCost(index * 2 + 1, n, cost);\\n            \\n            result = result + (int) Math.abs(leftCost - rightCost);\\n            return (cost[index - 1] + (Math.max(leftCost, rightCost)));\\n        }\\n        else{\\n            return cost[index - 1];\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    int result = 0;\\n    public int minIncrements(int n, int[] cost) {\\n        getCost(1, n, cost);\\n        return result;\\n    }\\n    \\n    private long getCost(int index, int n, int[] cost){\\n        if(index * 2 <= n){\\n            long leftCost = getCost(index * 2, n, cost);\\n            long rightCost = getCost(index * 2 + 1, n, cost);\\n            \\n            result = result + (int) Math.abs(leftCost - rightCost);\\n            return (cost[index - 1] + (Math.max(leftCost, rightCost)));\\n        }\\n        else{\\n            return cost[index - 1];\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3494934,
                "title": "c-solution",
                "content": "# Code\\n```\\npublic class Solution\\n{\\n    public int MinIncrements(int n, int[] cost)\\n    {\\n        var result = 0;\\n        var sum = new int[n];\\n\\n        for (var i = n - 1; i >= 0; i--)\\n        {\\n            sum[i] = cost[i];\\n\\n            if (i * 2 + 1 < n)\\n                sum[i] += Math.Max(sum[i * 2 + 1], sum[i * 2 + 2]);\\n        }\\n\\n        for (var i = 0; i < n; i++)\\n            if (i * 2 + 1 < n)\\n                result += Math.Abs(sum[i * 2 + 1] - sum[i * 2 + 2]);\\n\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution\\n{\\n    public int MinIncrements(int n, int[] cost)\\n    {\\n        var result = 0;\\n        var sum = new int[n];\\n\\n        for (var i = n - 1; i >= 0; i--)\\n        {\\n            sum[i] = cost[i];\\n\\n            if (i * 2 + 1 < n)\\n                sum[i] += Math.Max(sum[i * 2 + 1], sum[i * 2 + 2]);\\n        }\\n\\n        for (var i = 0; i < n; i++)\\n            if (i * 2 + 1 < n)\\n                result += Math.Abs(sum[i * 2 + 1] - sum[i * 2 + 2]);\\n\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3494849,
                "title": "c-dfs-sum-of-children-minus-minimum-o-n",
                "content": "\\n\\nThe idea is that you can DFS the binary tree and calculate the cost to make every path equal to the most expensive one. For every node, you can subtract the minimum of its children from the answer as you could have incremented that node instead and saved some moves.\\n\\n\\n```\\nclass Solution {\\npublic:\\n    typedef array<int, 2> ai;\\n    ai dfs(int pos, int target, vector<int>& sum){\\n        if(pos*2 >= cost.size()) return {target-sum[pos-1],target-sum[pos-1]};\\n        int ans = 0;\\n        auto a1 = dfs(pos*2, target, sum);\\n        auto a2 = dfs(pos*2+1, target, sum);\\n        int mn = min(a1[1], a2[1]);\\n        ans += a1[0] + a2[0];\\n        ans -= mn;\\n        return {ans, mn};\\n    }\\n    int minIncrements(int n, vector<int>& cost) {\\n        vector<int> sum(cost.size(), 0);\\n        queue<ai> q;\\n        q.push({1, 0});\\n        while(!q.empty()){ // precomputed sums array, can also do it in the dfs if you want to\\n            auto [id, d] = q.front();\\n            q.pop();\\n            if(id > n) continue;\\n            d += cost[id-1];\\n            sum[id-1] = d;\\n            q.push({id*2, d});\\n            q.push({id*2+1, d});\\n        }\\n        int target = *max_element(sum.begin(), sum.end());\\n        return dfs(1, cost, target, sum)[0];\\n    }\\n};\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\npublic:\\n    typedef array<int, 2> ai;\\n    ai dfs(int pos, int target, vector<int>& sum){\\n        if(pos*2 >= cost.size()) return {target-sum[pos-1],target-sum[pos-1]}",
                "codeTag": "Java"
            },
            {
                "id": 3494838,
                "title": "javascript-dfs",
                "content": "**Solution: DFS**\\n\\n**Key point: For each node, the sum of the all children paths must be equal since they share the same root path.**\\nSince we can only increase node values, we must make all path sums equal to the maximum path sum. \\nIncrease the child node with the smaller path sum to become equal to the larger path sum.\\nThen, return the maximum out of the left and right path sums.\\n\\n`n = number of nodes`, `h = height of tree`\\nTime Complexity: `O(n)`\\nSpace Complexity: `O(h)`\\n```\\nvar minIncrements = function(n, cost) {\\n  let ans = 0;\\n  dfs(1);\\n  return ans;\\n  \\n  function dfs(i) { \\n    if (i * 2 > n) return cost[i - 1]; // leaf node\\n    let leftSum = dfs(2 * i), rightSum = dfs(2 * i + 1);\\n    ans += Math.max(leftSum, rightSum) - Math.min(leftSum, rightSum);\\n    return cost[i - 1] + Math.max(leftSum, rightSum);\\n  }  \\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar minIncrements = function(n, cost) {\\n  let ans = 0;\\n  dfs(1);\\n  return ans;\\n  \\n  function dfs(i) { \\n    if (i * 2 > n) return cost[i - 1]; // leaf node\\n    let leftSum = dfs(2 * i), rightSum = dfs(2 * i + 1);\\n    ans += Math.max(leftSum, rightSum) - Math.min(leftSum, rightSum);\\n    return cost[i - 1] + Math.max(leftSum, rightSum);\\n  }  \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4087420,
                "title": "c-dfs-simple-code-intuition-and-approach-explained-simple-to-understand",
                "content": "# Intuition\\nIn this question we move in the array assuming it to be the tree.\\nfor 1 indexed room 2*i is left and 2*i+1 is right.\\nbut here we are taking it to be 0 indexed so we did 2*i as left and 2*i+1 as right.\\n\\n# Approach\\nWe find the maximum cost root to leaf path because we can only increase the cost of any path so the minimum we can do to make the cost of each path equal to the maximum.\\n\\nso as to have minimum number of increments, we need to increase the cost of the nodes as upper as possible because it will benefit all the lower path costs hence lesser number of increments will be needed to make cost of all the paths equal.\\n\\n\\n# Complexity\\n- Time complexity:\\nO(2 * N) ~= O(N)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int func(int node, int n, vector<int>&cost){\\n        if(node>=n)return 0;\\n        return cost[node]+max(func(2*node+1,n,cost), func(2*node+2,n,cost));\\n    }\\n\\n    int ans(int node,int currcost, int maxcost, int n, vector<int>&cost, int&already){\\n        if(node>=n)return abs(maxcost-currcost);\\n        int left = ans(node*2+1,cost[node]+currcost,maxcost,n,cost,already);\\n        int right = ans(node*2+2,cost[node]+currcost,maxcost,n,cost,already);\\n        already+=(abs(left-right));\\n        return min(left,right);\\n    }\\n\\n    int minIncrements(int n, vector<int>& cost) {\\n        int maxcost = func(0,n,cost);\\n        int already = 0;\\n        int finalans = ans(0,0, maxcost,n,cost, already);\\n        return already+finalans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int func(int node, int n, vector<int>&cost){\\n        if(node>=n)return 0;\\n        return cost[node]+max(func(2*node+1,n,cost), func(2*node+2,n,cost));\\n    }\\n\\n    int ans(int node,int currcost, int maxcost, int n, vector<int>&cost, int&already){\\n        if(node>=n)return abs(maxcost-currcost);\\n        int left = ans(node*2+1,cost[node]+currcost,maxcost,n,cost,already);\\n        int right = ans(node*2+2,cost[node]+currcost,maxcost,n,cost,already);\\n        already+=(abs(left-right));\\n        return min(left,right);\\n    }\\n\\n    int minIncrements(int n, vector<int>& cost) {\\n        int maxcost = func(0,n,cost);\\n        int already = 0;\\n        int finalans = ans(0,0, maxcost,n,cost, already);\\n        return already+finalans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4053382,
                "title": "ruby-o-n",
                "content": "```ruby\\n# @param {Integer} n\\n# @param {Integer[]} cost\\n# @return {Integer}\\ndef min_increments(n, cost)\\n  res = 0\\n  for node in (2...n).step(2).to_a.reverse\\n    res += (cost[node-1] - cost[node]).abs\\n    cost[node/2 - 1] += [cost[node-1], cost[node]].max\\n  end\\n  res\\nend\\n```",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```ruby\\n# @param {Integer} n\\n# @param {Integer[]} cost\\n# @return {Integer}\\ndef min_increments(n, cost)\\n  res = 0\\n  for node in (2...n).step(2).to_a.reverse\\n    res += (cost[node-1] - cost[node]).abs\\n    cost[node/2 - 1] += [cost[node-1], cost[node]].max\\n  end\\n  res\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 4043362,
                "title": "ok",
                "content": "```\\nint minIncrements(int n, vector<int>& c)\\n{\\n\\tint out{};\\n\\tfor(int i{n-1}; i; i-=2)\\n\\t{\\n\\t\\tauto [m, M] = minmax(c[i-1], c[i]);\\n\\t\\tc[(i-1)/2] += M; \\n\\t\\tout += M-m;\\n\\t}\\n\\treturn out;\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nint minIncrements(int n, vector<int>& c)\\n{\\n\\tint out{};\\n\\tfor(int i{n-1}; i; i-=2)\\n\\t{\\n\\t\\tauto [m, M] = minmax(c[i-1], c[i]);\\n\\t\\tc[(i-1)/2] += M; \\n\\t\\tout += M-m;\\n\\t}\\n\\treturn out;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4022550,
                "title": "c-from-leaves-node-just-check-diff-easy-solution",
                "content": "# Please UpVote if it helps you\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minIncrements(int n, vector<int>& cost) {\\n        int ans = 0,t = n;\\n        vector<int> a;\\n        t /= 2;\\n        while(t>0){\\n            for(int i=0;i<t;i+=2){\\n                a.push_back(max(cost[i+t],cost[i+1+t]));\\n                ans += abs(cost[i+t]-cost[i+t+1]);\\n            }\\n            t /= 2;\\n            for(int i=0;i<=t;++i){\\n                cost[i+t] += a[i];\\n            }\\n            a.clear();\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minIncrements(int n, vector<int>& cost) {\\n        int ans = 0,t = n;\\n        vector<int> a;\\n        t /= 2;\\n        while(t>0){\\n            for(int i=0;i<t;i+=2){\\n                a.push_back(max(cost[i+t],cost[i+1+t]));\\n                ans += abs(cost[i+t]-cost[i+t+1]);\\n            }\\n            t /= 2;\\n            for(int i=0;i<=t;++i){\\n                cost[i+t] += a[i];\\n            }\\n            a.clear();\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4002452,
                "title": "solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int ans = 0;\\n\\n    int dfs(int i, vector<int>& cost) {\\n        if (i >= cost.size()) return 0;\\n        \\n        int dis = 0;\\n        int left = cost[i] + dfs(2 * i+1, cost);\\n        int right = cost[i] + dfs(2 * i + 2, cost);\\n        \\n        dis = max(left, right);\\n        ans += (abs(left - right));\\n        return dis;\\n    }\\n\\n    int minIncrements(int n, vector<int>& cost) {\\n        dfs(0, cost);\\n        return ans;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int ans = 0;\\n\\n    int dfs(int i, vector<int>& cost) {\\n        if (i >= cost.size()) return 0;\\n        \\n        int dis = 0;\\n        int left = cost[i] + dfs(2 * i+1, cost);\\n        int right = cost[i] + dfs(2 * i + 2, cost);\\n        \\n        dis = max(left, right);\\n        ans += (abs(left - right));\\n        return dis;\\n    }\\n\\n    int minIncrements(int n, vector<int>& cost) {\\n        dfs(0, cost);\\n        return ans;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3930726,
                "title": "caution-the-index",
                "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def minIncrements(self, n: int, cost: List[int]) -> int:\\n        # we must balanced the subpath first \\n        # by the time we move up to a node, its decendents paths are already balanced locally\\n        # we start from the node n//2-1, and iterative backwards to 1.\\n\\n        res=0\\n        # the last non-leaf node is n//2 , but in the 0-indexed cost array is n//2-1\\n        for i in range(n//2-1,-1,-1):\\n            left=2*(i+1)-1\\n            right=2*(i+1)+1-1\\n            res+=abs(cost[left]-cost[right])\\n            cost[i]+=max(cost[left],cost[right])\\n        return res\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minIncrements(self, n: int, cost: List[int]) -> int:\\n        # we must balanced the subpath first \\n        # by the time we move up to a node, its decendents paths are already balanced locally\\n        # we start from the node n//2-1, and iterative backwards to 1.\\n\\n        res=0\\n        # the last non-leaf node is n//2 , but in the 0-indexed cost array is n//2-1\\n        for i in range(n//2-1,-1,-1):\\n            left=2*(i+1)-1\\n            right=2*(i+1)+1-1\\n            res+=abs(cost[left]-cost[right])\\n            cost[i]+=max(cost[left],cost[right])\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3921730,
                "title": "c-python-bottom-up-solution-with-explanation",
                "content": "### bottom up\\n![image](https://assets.leetcode.com/users/images/d1fbd5ea-74b1-417c-812e-fae90b4dff85_1692265913.6029902.png)\\n\\n\\n### python\\n```python\\nclass Solution:\\n    def minIncrements(self, n: int, cost: List[int]) -> int:\\n        ans = 0\\n        for i in range(n // 2 - 1, -1, -1):\\n            ans += abs(cost[2 * i + 1] - cost[2 * i + 2])\\n            cost[i] += max(cost[2 * i + 1], cost[2 * i + 2])\\n        return ans\\n```\\n\\n### c++\\n```cpp\\nclass Solution {\\npublic:\\n    int minIncrements(int n, vector<int>& cost) {\\n        int ans = 0;\\n        for (int i = n / 2 - 1; i >= 0; i -= 1) {\\n            ans += abs(cost[2*i+1] - cost[2*i+2]);\\n            cost[i] += max(cost[2*i+1], cost[2*i+2]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Python",
                    "C"
                ],
                "code": "```python\\nclass Solution:\\n    def minIncrements(self, n: int, cost: List[int]) -> int:\\n        ans = 0\\n        for i in range(n // 2 - 1, -1, -1):\\n            ans += abs(cost[2 * i + 1] - cost[2 * i + 2])\\n            cost[i] += max(cost[2 * i + 1], cost[2 * i + 2])\\n        return ans\\n```\n```cpp\\nclass Solution {\\npublic:\\n    int minIncrements(int n, vector<int>& cost) {\\n        int ans = 0;\\n        for (int i = n / 2 - 1; i >= 0; i -= 1) {\\n            ans += abs(cost[2*i+1] - cost[2*i+2]);\\n            cost[i] += max(cost[2*i+1], cost[2*i+2]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3920257,
                "title": "python3-recursive",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nrecursive \\ndist: distance from root to leaf\\noutput: cost \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def minIncrements(self, n: int, cost: List[int]) -> int:\\n        \\n        dist, output = self.helper(0, n, cost)\\n\\n        return output\\n\\n    def helper(self, p, n, cost):\\n        # p: node number of root\\n        if p < n:\\n\\n            l_dist, l_output = self.helper(2*p + 1, n, cost)\\n            r_dist, r_output = self.helper(2*p + 2, n, cost)\\n            \\n            dist = cost[p] + max(l_dist, r_dist)\\n            output = l_output + r_output + abs(l_dist - r_dist)\\n            \\n            return dist, output \\n        \\n        return 0, 0 \\n            \\n\\n            \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minIncrements(self, n: int, cost: List[int]) -> int:\\n        \\n        dist, output = self.helper(0, n, cost)\\n\\n        return output\\n\\n    def helper(self, p, n, cost):\\n        # p: node number of root\\n        if p < n:\\n\\n            l_dist, l_output = self.helper(2*p + 1, n, cost)\\n            r_dist, r_output = self.helper(2*p + 2, n, cost)\\n            \\n            dist = cost[p] + max(l_dist, r_dist)\\n            output = l_output + r_output + abs(l_dist - r_dist)\\n            \\n            return dist, output \\n        \\n        return 0, 0 \\n            \\n\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3888499,
                "title": "simple-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n\\n# Approach\\nis solved by traversing in revese from last parent node to root node.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minIncrements(int n, vector<int>& cost) {\\n        int res = 0, maxOfC;\\n        for (int i = ((n - 1) / 2) - 1; i >= 0 ; i--)\\n        {\\n            maxOfC = max(cost[2 * i + 1], cost[2 * i + 2]);\\n            res += (maxOfC -  min(cost[2 * i + 1], cost[2 * i + 2]));\\n            cost[i] = cost[i] + maxOfC;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minIncrements(int n, vector<int>& cost) {\\n        int res = 0, maxOfC;\\n        for (int i = ((n - 1) / 2) - 1; i >= 0 ; i--)\\n        {\\n            maxOfC = max(cost[2 * i + 1], cost[2 * i + 2]);\\n            res += (maxOfC -  min(cost[2 * i + 1], cost[2 * i + 2]));\\n            cost[i] = cost[i] + maxOfC;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3875928,
                "title": "java-postorder",
                "content": "# Intuition\\nPostOrder traversal\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n- O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    int sum=0;\\n    public int minIncrements(int n, int[] cost) {\\n        solve(n,cost,1);\\n        return sum;\\n    }\\n\\n    int solve(int n,int[]cost,int index){\\n\\n        if(index>cost.length){\\n            return 0;\\n        }\\n\\n        int left=solve(n,cost,2*index);\\n        int right=solve(n,cost,2*index+1);\\n\\n        if(left!=right){\\n            sum=sum+(int)Math.abs(left-right);\\n        }\\n        return cost[index-1]+Math.max(left,right);\\n    }\\n} \\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    int sum=0;\\n    public int minIncrements(int n, int[] cost) {\\n        solve(n,cost,1);\\n        return sum;\\n    }\\n\\n    int solve(int n,int[]cost,int index){\\n\\n        if(index>cost.length){\\n            return 0;\\n        }\\n\\n        int left=solve(n,cost,2*index);\\n        int right=solve(n,cost,2*index+1);\\n\\n        if(left!=right){\\n            sum=sum+(int)Math.abs(left-right);\\n        }\\n        return cost[index-1]+Math.max(left,right);\\n    }\\n} \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3865298,
                "title": "one-pass-detailed-explanation-and-comments",
                "content": "# Intuition\\nKey points:\\n1. You can only **increment**\\n2. For the two child nodes belonging to the same parent, they need to have equal values after the increment(so that the path from root to them can be the same)\\n\\n# Approach\\nBased on the intuitions, we can start from each pair of the child nodes from the same parent, two scenarios:\\n1. `child1.val` = `child2.val`, do nothing\\n2. `child1.val` != `child2.val`, the lesser value child needs to be incremented, it needs to increase by `abs(child1.val - child2.val)`. We also add the resulting value after the increment to the parent to keep track of totol path cost.\\n\\nNow, since the tree is a perfect tree (all nodes has 2 child except the leafs), we don\\'t need to actually build the tree. We can just link index to track parent and child: if a node\\'s index is i, its left child\\'s index is `2*i + 1`, right child\\'s index is `2*i + 2`. It is also easy to find a parent\\'s index given the child\\'s index.\\n\\n# Complexity\\n- Time complexity:\\n $$O(n)$$\\n\\n- Space complexity:\\n$$O(1)$$ since you can use the input list directly, otherwise $$O(N)$$ if you don\\'t want to modify inputs\\n\\n# Code\\n```\\nclass Solution(object):\\n    def minIncrements(self, n, cost):\\n        \"\"\"\\n        :type n: int\\n        :type cost: List[int]\\n        :rtype: int\\n        \"\"\"\\n        res = 0\\n        for i in range(len(cost)-1, 0, -2): # go backward from the last node pair, notice step = 2\\n            a, b = cost[i], cost[i-1] \\n            diff = abs(a-b) # the increment we need to do for this pair\\n            res += diff\\n            par = i / 2 - 1 # index of the parent\\n            cost[par] += max(a, b) # increment parent to keep track of path cost\\n        return res\\n\\n         \\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def minIncrements(self, n, cost):\\n        \"\"\"\\n        :type n: int\\n        :type cost: List[int]\\n        :rtype: int\\n        \"\"\"\\n        res = 0\\n        for i in range(len(cost)-1, 0, -2): # go backward from the last node pair, notice step = 2\\n            a, b = cost[i], cost[i-1] \\n            diff = abs(a-b) # the increment we need to do for this pair\\n            res += diff\\n            par = i / 2 - 1 # index of the parent\\n            cost[par] += max(a, b) # increment parent to keep track of path cost\\n        return res\\n\\n         \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3857904,
                "title": "easy-c-code-without-recursion",
                "content": "# Intuition\\nThe given code aims to find the minimum number of increments needed to make each element of the input vector cost strictly greater than the previous element. It does this by iteratively merging adjacent elements and updating their values to meet the requirement.\\n\\n# Approach\\nThe given code uses a greedy approach to find the minimum number of increments required to make each element in the cost vector strictly greater than its previous element. The idea is to iteratively merge adjacent elements in the vector, updating their values in a way that maintains the increasing order.\\n\\n# Complexity\\n- Time complexity: O(N)\\n\\n- Space complexity: O(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int solve(int n, vector<int>& cost,int& ans){\\n        if(cost.size()==0) return 0;\\n        for(int i=n-1;i>0;i-=2){\\n            ans+=abs(cost[i]-cost[i-1]);\\n            cost[(i-1)/2]+=max(cost[i],cost[i-1]);\\n        }\\n        return ans;\\n    }\\n    int minIncrements(int n, vector<int>& cost) {\\n        int ans=0;\\n        return solve(n, cost, ans);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int solve(int n, vector<int>& cost,int& ans){\\n        if(cost.size()==0) return 0;\\n        for(int i=n-1;i>0;i-=2){\\n            ans+=abs(cost[i]-cost[i-1]);\\n            cost[(i-1)/2]+=max(cost[i],cost[i-1]);\\n        }\\n        return ans;\\n    }\\n    int minIncrements(int n, vector<int>& cost) {\\n        int ans=0;\\n        return solve(n, cost, ans);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3857883,
                "title": "simple-c-code-without-recursion",
                "content": "\\n\\n# Complexity\\n- Time complexity: **O(n)**\\n\\n- Space complexity: **O(1)**\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int solve(int n, vector<int>& cost,int& ans){\\n        if(cost.size()==0) return 0;\\n        for(int i=n-1;i>0;i-=2){\\n            ans+=abs(cost[i]-cost[i-1]);\\n            cost[(i-1)/2]+=max(cost[i],cost[i-1]);\\n        }\\n        return ans;\\n    }\\n    int minIncrements(int n, vector<int>& cost) {\\n        int ans=0;\\n        return solve(n, cost, ans);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int solve(int n, vector<int>& cost,int& ans){\\n        if(cost.size()==0) return 0;\\n        for(int i=n-1;i>0;i-=2){\\n            ans+=abs(cost[i]-cost[i-1]);\\n            cost[(i-1)/2]+=max(cost[i],cost[i-1]);\\n        }\\n        return ans;\\n    }\\n    int minIncrements(int n, vector<int>& cost) {\\n        int ans=0;\\n        return solve(n, cost, ans);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3853584,
                "title": "beats-99-simple-recusion-tree-traversal-c",
                "content": "# Intuition\\nwhen ever a tree problem comes try to think about the recursion on left subtree and right subtree.\\n\\n# Approach\\nuse recursion and find path lenght of left subtree and right subtree and then use a simple logic at every node while comming back from recursion.\\nlogic : at every node the modification will be the difference in the path lenght of left subtree and right subtree.\\n\\n# Complexity\\n- Time complexity: O(N)\\n\\n- Space complexity: O(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int ans=0;\\n    int rec(int ind,vector<int> &cost){\\n        if(ind>=cost.size()){\\n            return 0;\\n        }\\n        else{\\n            int lsum=rec(2*ind+1,cost);\\n            int rsum=rec(2*ind+2,cost);\\n            ans+=(abs(lsum-rsum));\\n            return max(lsum,rsum)+cost[ind];\\n        }\\n    }\\n    int minIncrements(int n, vector<int>& cost) {\\n        int val=rec(0,cost);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int ans=0;\\n    int rec(int ind,vector<int> &cost){\\n        if(ind>=cost.size()){\\n            return 0;\\n        }\\n        else{\\n            int lsum=rec(2*ind+1,cost);\\n            int rsum=rec(2*ind+2,cost);\\n            ans+=(abs(lsum-rsum));\\n            return max(lsum,rsum)+cost[ind];\\n        }\\n    }\\n    int minIncrements(int n, vector<int>& cost) {\\n        int val=rec(0,cost);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3824130,
                "title": "beats-99-92-simple-solution",
                "content": "\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    int solve(int i,int &ans,int n,vector<int>&cost){\\n        if(i>n) return 0;\\n\\n        int l=solve(2*i,ans,n,cost);\\n        int r=solve(2*i+1,ans,n,cost);\\n\\n        ans+=abs(l-r);\\n        int x= max(l,r)+cost[i-1];\\n        return x;\\n    }\\npublic:\\n    int minIncrements(int n, vector<int>& cost) {\\n        int ans=0;\\n        solve(1,ans,n,cost);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n    int solve(int i,int &ans,int n,vector<int>&cost){\\n        if(i>n) return 0;\\n\\n        int l=solve(2*i,ans,n,cost);\\n        int r=solve(2*i+1,ans,n,cost);\\n\\n        ans+=abs(l-r);\\n        int x= max(l,r)+cost[i-1];\\n        return x;\\n    }\\npublic:\\n    int minIncrements(int n, vector<int>& cost) {\\n        int ans=0;\\n        solve(1,ans,n,cost);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3795873,
                "title": "get-the-right-intution",
                "content": "# Intuition\\nAt every node you need that right sum and left sum should be equal.For this you increase the left or right node if sum is unequal.And this increase = diff between rightsum and leftsum.\\n\\n# Approach\\nRun a post order type traversal i.e first get left sum then right sum\\nNext compare both sum \\ndiff of these sum is what u need to inrcease\\n\\n\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int ans=0;\\n    \\n    int post(int nd,vector<int>&cost,int n){\\n      if(nd>n)return 0;\\n        int left=post(2*nd,cost,n);\\n        int right=post(2*nd+1,cost,n);\\n        if(left!=right)ans+=abs(left-right);\\n        return cost[nd-1]+max(left,right);\\n    \\n    }\\n    int minIncrements(int n, vector<int>& cost) {\\n     post(1,cost,n);\\n     return ans;   \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int ans=0;\\n    \\n    int post(int nd,vector<int>&cost,int n){\\n      if(nd>n)return 0;\\n        int left=post(2*nd,cost,n);\\n        int right=post(2*nd+1,cost,n);\\n        if(left!=right)ans+=abs(left-right);\\n        return cost[nd-1]+max(left,right);\\n    \\n    }\\n    int minIncrements(int n, vector<int>& cost) {\\n     post(1,cost,n);\\n     return ans;   \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3788666,
                "title": "c-easy-solution",
                "content": "# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1) - Recursion stack not considered\\n\\n# Code\\n```\\npublic class Solution {\\n    int max_sum, min_increment;\\n    public int MinIncrements(int n, int[] cost) {\\n        max_sum = 0;\\n        min_increment = 0;\\n\\n        CalculateRootToLeafMax(cost, 0, 0, 0);\\n        MinIncrementsUntil(cost, 0, 0, 0);\\n\\n        return min_increment;\\n    }\\n\\n    private int MinIncrementsUntil(int[] cost, int level, int idx, int sum) {\\n        if(idx >= cost.Length)\\n            return max_sum - sum;\\n\\n        var child = idx << 1;\\n        var currSum = sum + cost[idx];\\n\\n        var left = MinIncrementsUntil(cost, 1 + level, child + 1, currSum);\\n        var right = MinIncrementsUntil(cost, 1 + level, child + 2, currSum);\\n\\n        var temp = Math.Min(left, right);\\n\\n        min_increment = min_increment + (left - temp) + (right - temp);\\n\\n        return temp;\\n    }\\n\\n    private void CalculateRootToLeafMax(int[] cost, int level, int idx, int sum) {\\n        if(idx >= cost.Length) {\\n            max_sum = Math.Max(max_sum, sum);\\n            return;\\n        }\\n\\n        var child = idx << 1;\\n        var currSum = sum + cost[idx];\\n\\n        CalculateRootToLeafMax(cost, 1 + level, child + 1, currSum);\\n        CalculateRootToLeafMax(cost, 1 + level, child + 2, currSum);\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#",
                    "Greedy",
                    "Recursion"
                ],
                "code": "```\\npublic class Solution {\\n    int max_sum, min_increment;\\n    public int MinIncrements(int n, int[] cost) {\\n        max_sum = 0;\\n        min_increment = 0;\\n\\n        CalculateRootToLeafMax(cost, 0, 0, 0);\\n        MinIncrementsUntil(cost, 0, 0, 0);\\n\\n        return min_increment;\\n    }\\n\\n    private int MinIncrementsUntil(int[] cost, int level, int idx, int sum) {\\n        if(idx >= cost.Length)\\n            return max_sum - sum;\\n\\n        var child = idx << 1;\\n        var currSum = sum + cost[idx];\\n\\n        var left = MinIncrementsUntil(cost, 1 + level, child + 1, currSum);\\n        var right = MinIncrementsUntil(cost, 1 + level, child + 2, currSum);\\n\\n        var temp = Math.Min(left, right);\\n\\n        min_increment = min_increment + (left - temp) + (right - temp);\\n\\n        return temp;\\n    }\\n\\n    private void CalculateRootToLeafMax(int[] cost, int level, int idx, int sum) {\\n        if(idx >= cost.Length) {\\n            max_sum = Math.Max(max_sum, sum);\\n            return;\\n        }\\n\\n        var child = idx << 1;\\n        var currSum = sum + cost[idx];\\n\\n        CalculateRootToLeafMax(cost, 1 + level, child + 1, currSum);\\n        CalculateRootToLeafMax(cost, 1 + level, child + 2, currSum);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3785392,
                "title": "c-dfs-binary-tree",
                "content": "# Code 1\\n```\\nclass Solution {\\n    int calculateTotalIncrement(int idx, int &n, int &ans, vector<int> &cost) {\\n        if (idx >= n) {\\n            return 0;\\n        } \\n\\n        int left = calculateTotalIncrement(2 * idx + 1, n, ans, cost);\\n        int right = calculateTotalIncrement(2 * idx + 2, n, ans, cost);\\n\\n        ans += abs(left - right);\\n\\n        return max(left, right) + cost[idx];\\n    }\\npublic:\\n    int minIncrements(int n, vector<int>& cost) {\\n        int ans = 0;\\n        calculateTotalIncrement(0, n, ans, cost);\\n        \\n        return ans;\\n    }\\n};\\n```\\n# Code 2\\n```\\nclass Node {\\npublic:\\n    int val;\\n    int weight;\\n    Node *left;\\n    Node *right;\\n\\n    Node(int val, int weight) {\\n        this->val = val;\\n        this->weight = weight;\\n        this->left = nullptr;\\n        this->right = nullptr;\\n    }\\n};\\n\\nclass Solution {\\n    int calculateTotalIncrement(Node * root, int &ans) {\\n        if (!root) {\\n            return 0;\\n        }\\n        \\n        int left = calculateTotalIncrement(root->left, ans);\\n        int right = calculateTotalIncrement(root->right, ans);\\n        \\n        ans += (abs(left - right));\\n        \\n        return max(left, right) + root->weight;\\n    }\\n\\npublic:\\n    int minIncrements(int n, vector<int>& cost) {\\n        vector<Node *> nodes(n);\\n\\n        for (int idx = 0; idx < n; idx++) {\\n            Node *node = new Node(idx + 1, cost[idx]);\\n            nodes[idx] = node;\\n        }\\n\\n        int idx = 0;\\n\\n        while ((2 * idx + 1) < n - 1) {\\n            Node *node = nodes[idx];\\n\\n            node->left = nodes[2 * idx + 1];\\n            node->right = nodes[2 * idx + 2];\\n            \\n            idx++;\\n        }\\n        \\n        int ans = 0;\\n        calculateTotalIncrement(nodes[0], ans);\\n        \\n        return ans;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    int calculateTotalIncrement(int idx, int &n, int &ans, vector<int> &cost) {\\n        if (idx >= n) {\\n            return 0;\\n        } \\n\\n        int left = calculateTotalIncrement(2 * idx + 1, n, ans, cost);\\n        int right = calculateTotalIncrement(2 * idx + 2, n, ans, cost);\\n\\n        ans += abs(left - right);\\n\\n        return max(left, right) + cost[idx];\\n    }\\npublic:\\n    int minIncrements(int n, vector<int>& cost) {\\n        int ans = 0;\\n        calculateTotalIncrement(0, n, ans, cost);\\n        \\n        return ans;\\n    }\\n};\\n```\n```\\nclass Node {\\npublic:\\n    int val;\\n    int weight;\\n    Node *left;\\n    Node *right;\\n\\n    Node(int val, int weight) {\\n        this->val = val;\\n        this->weight = weight;\\n        this->left = nullptr;\\n        this->right = nullptr;\\n    }\\n};\\n\\nclass Solution {\\n    int calculateTotalIncrement(Node * root, int &ans) {\\n        if (!root) {\\n            return 0;\\n        }\\n        \\n        int left = calculateTotalIncrement(root->left, ans);\\n        int right = calculateTotalIncrement(root->right, ans);\\n        \\n        ans += (abs(left - right));\\n        \\n        return max(left, right) + root->weight;\\n    }\\n\\npublic:\\n    int minIncrements(int n, vector<int>& cost) {\\n        vector<Node *> nodes(n);\\n\\n        for (int idx = 0; idx < n; idx++) {\\n            Node *node = new Node(idx + 1, cost[idx]);\\n            nodes[idx] = node;\\n        }\\n\\n        int idx = 0;\\n\\n        while ((2 * idx + 1) < n - 1) {\\n            Node *node = nodes[idx];\\n\\n            node->left = nodes[2 * idx + 1];\\n            node->right = nodes[2 * idx + 2];\\n            \\n            idx++;\\n        }\\n        \\n        int ans = 0;\\n        calculateTotalIncrement(nodes[0], ans);\\n        \\n        return ans;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3782247,
                "title": "100-runtime-beat-recursive-way-to-solve-it",
                "content": "# Code\\n```\\nint max(int a,int b){\\n    return a>b?a:b;\\n}\\n\\nvoid balance(int root,int* cost,int costSize,int* totalCost){\\n    int left = 2 * root + 1;\\n    int right = 2 * root + 2;\\n    if(right * 2 + 1 > costSize){\\n        *totalCost += abs(cost[left]-cost[right]);\\n        cost[root] += max(cost[left],cost[right]);\\n    }\\n    else{\\n        balance(left,cost,costSize,totalCost);\\n        balance(right,cost,costSize,totalCost);\\n        *totalCost += abs(cost[left]-cost[right]);\\n        cost[root] += max(cost[left],cost[right]);\\n    }\\n}\\n\\nint minIncrements(int n, int* cost, int costSize){\\n    int result = 0;\\n    balance(0,cost,costSize,&result);\\n    return result;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint max(int a,int b){\\n    return a>b?a:b;\\n}\\n\\nvoid balance(int root,int* cost,int costSize,int* totalCost){\\n    int left = 2 * root + 1;\\n    int right = 2 * root + 2;\\n    if(right * 2 + 1 > costSize){\\n        *totalCost += abs(cost[left]-cost[right]);\\n        cost[root] += max(cost[left],cost[right]);\\n    }\\n    else{\\n        balance(left,cost,costSize,totalCost);\\n        balance(right,cost,costSize,totalCost);\\n        *totalCost += abs(cost[left]-cost[right]);\\n        cost[root] += max(cost[left],cost[right]);\\n    }\\n}\\n\\nint minIncrements(int n, int* cost, int costSize){\\n    int result = 0;\\n    balance(0,cost,costSize,&result);\\n    return result;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3722268,
                "title": "easiest-solution-in-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n\\n    static int  res = 0 ;\\n    static int ans( int i ,  int n , int[] cost   )\\n    {\\n        if( i>n  ) {\\n            return 0 ;\\n        }\\n\\n        int left = ans( 2*i , n , cost  );\\n        int right = ans( 2*i+1 , n , cost  );\\n        res += Math.abs( left - right );\\n        return cost[i-1] + Math.max( left , right );\\n\\n    }\\n\\n\\n    public int minIncrements(int n, int[] cost) {\\n        res = 0 ;\\n    ans( 1 , cost.length , cost );\\n      return res ;\\n\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n\\n    static int  res = 0 ;\\n    static int ans( int i ,  int n , int[] cost   )\\n    {\\n        if( i>n  ) {\\n            return 0 ;\\n        }\\n\\n        int left = ans( 2*i , n , cost  );\\n        int right = ans( 2*i+1 , n , cost  );\\n        res += Math.abs( left - right );\\n        return cost[i-1] + Math.max( left , right );\\n\\n    }\\n\\n\\n    public int minIncrements(int n, int[] cost) {\\n        res = 0 ;\\n    ans( 1 , cost.length , cost );\\n      return res ;\\n\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3719705,
                "title": "o-n-solution-single-pass-self-explainatory",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minIncrements(int n, vector<int>& cost) {\\n        int totalcost = 0;\\n        for(int i=n;i>=2;)\\n        {\\n            int node1 = i;\\n            int node2 = i-1;\\n            int parent = node1/2;\\n            totalcost+=abs(cost[node1-1]-cost[node2-1]);\\n            cost[parent-1] = cost[parent-1]+max(cost[node1-1],cost[node2-1]);\\n            i = i-2; \\n        }\\n        return totalcost;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minIncrements(int n, vector<int>& cost) {\\n        int totalcost = 0;\\n        for(int i=n;i>=2;)\\n        {\\n            int node1 = i;\\n            int node2 = i-1;\\n            int parent = node1/2;\\n            totalcost+=abs(cost[node1-1]-cost[node2-1]);\\n            cost[parent-1] = cost[parent-1]+max(cost[node1-1],cost[node2-1]);\\n            i = i-2; \\n        }\\n        return totalcost;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3716216,
                "title": "o-n-linear-simple-solution-bottomup",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\nThis is an idea based on recursion but we do use bottom up approach. The idea here is to solve for subtrees and update the variable **ans** After solving for subtree we update its cost (By solving i mean we have calculated the no of operations to make all path sums in that subtree equal) and update it so that we do not need to calculate the path sum again and again. This has to be done from lower nodes to upper nodes.\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\nWe are given an array representing a tree.\\nWe do not solve for leaf nodes since the path sum to leaf from that node is its value only.\\n\\n- For each non-leaf node, we get the leaf-path-sum from its left node and right node.\\n- We calculate the diff and this would the operations required to make them equal\\n``` \\nans += abs(rightCost - leftCost)\\n\\n```\\n- update the child with less sum to become equal to its sibling.\\n- Update the sum of the node to either **curr + leftCost** or **curr + rightCost** since both would be equal.\\n- \\n# Complexity\\n- Time complexity: $$O(n)$$  \\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minIncrements(int n, vector<int>& cost) {\\n        int ans =0 ;\\n        for(int i=(n/2 - 1) ;i>=0;i--) {\\n            int index = i+1;\\n            int leftCost = cost[2*index-1] ;\\n            int rightCost = cost[2*index];\\n            if(leftCost < rightCost) {\\n                ans += rightCost - leftCost;\\n                cost[2*index-1] = rightCost;\\n            }\\n            else if(leftCost > rightCost) {\\n                ans += leftCost - rightCost;\\n                cost[2*index] = leftCost;\\n            }\\n            cost[index-1] += cost[2*index];\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Tree",
                    "Recursion"
                ],
                "code": "``` \\nans += abs(rightCost - leftCost)\\n\\n```\n```\\nclass Solution {\\npublic:\\n    int minIncrements(int n, vector<int>& cost) {\\n        int ans =0 ;\\n        for(int i=(n/2 - 1) ;i>=0;i--) {\\n            int index = i+1;\\n            int leftCost = cost[2*index-1] ;\\n            int rightCost = cost[2*index];\\n            if(leftCost < rightCost) {\\n                ans += rightCost - leftCost;\\n                cost[2*index-1] = rightCost;\\n            }\\n            else if(leftCost > rightCost) {\\n                ans += leftCost - rightCost;\\n                cost[2*index] = leftCost;\\n            }\\n            cost[index-1] += cost[2*index];\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3706262,
                "title": "python-post-order-traversal",
                "content": "```python\\nfrom functools import cache\\n\\n\\nclass Solution:\\n\\n    def minIncrements(self, n: int, cost: list[int]) -> int:\\n        @cache\\n        def post_order(i: int) -> tuple[int, int]:\\n            \"\"\"\\n            :param i: node id\\n            :return: total changes up to node \"i\", path sum from leaf to node \"i\"\\n            \"\"\"\\n            if i >= n:\\n                return 0, 0\\n            else:\\n                (l_inc, l_path_sum), (r_inc, r_path_sum) = post_order(2 * i + 1), post_order(2 * i + 2)\\n\\n                inc = l_inc + abs(l_path_sum - r_path_sum) + r_inc\\n                path_sum = cost[i] + max(l_path_sum, r_path_sum)\\n\\n                return inc, path_sum\\n\\n        return post_order(0)[0]\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```python\\nfrom functools import cache\\n\\n\\nclass Solution:\\n\\n    def minIncrements(self, n: int, cost: list[int]) -> int:\\n        @cache\\n        def post_order(i: int) -> tuple[int, int]:\\n            \"\"\"\\n            :param i: node id\\n            :return: total changes up to node \"i\", path sum from leaf to node \"i\"\\n            \"\"\"\\n            if i >= n:\\n                return 0, 0\\n            else:\\n                (l_inc, l_path_sum), (r_inc, r_path_sum) = post_order(2 * i + 1), post_order(2 * i + 2)\\n\\n                inc = l_inc + abs(l_path_sum - r_path_sum) + r_inc\\n                path_sum = cost[i] + max(l_path_sum, r_path_sum)\\n\\n                return inc, path_sum\\n\\n        return post_order(0)[0]\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3702597,
                "title": "simple-approach-using-recursion",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\nBasically I update the cost[index] with total cost is used for traversing from that index node to the leaf node.\\n\\n--> I started the index from n-1 and try compare both value i.e (i and i-1) add the absolute difference in my ans variable.\\n\\n--> In leaf node only compare then iterate to (i-2),update the cost[index];\\n\\n--> In other nodes I take their child node value and add in parent node then compare do the same thing as do in leaf node,and at last update the cost[index].\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    void fun(int & ans,int i,int n,vector<int>& cost){\\n        if(i == 0){\\n            //ans = ans + abs(cost[2*i] - cost[2*i + 1]);\\n            return;\\n        }\\n        else{\\n            if(2* i > n && 2*i + 1 > n){ // for leaf node\\n                if(cost[i] >= cost[i-1]){\\n                    ans = ans + cost[i] - cost[i-1];\\n                    //cout<<ans<<\"leaf \";\\n                }\\n                else{\\n                    ans = ans + cost[i-1] - cost[i];\\n                    //cout<<ans<<\"leaf \";\\n                }\\n\\n                int x = max(cost[i],cost[i-1]);\\n\\n                cost[i] = x;\\n                cost[i-1] = x;\\n\\n                fun(ans,i-2,n,cost);\\n            }\\n            else if(2*i < n && 2*i + 1 < n ){\\n                int right = cost[2*i + 1] + cost[i];\\n\\n                int left = cost[2*(i-1) + 1] + cost[i-1];\\n\\n                //cout<<right<<\" \"<<left<<\"\\\\n\";\\n\\n                cost[i] = right;\\n\\n                cost[i-1] = left;\\n\\n                if(cost[i] >= cost[i-1]){\\n                    ans = ans + cost[i] - cost[i-1];\\n                    //cout<<ans<<\" \";\\n                }\\n                else{\\n                    ans = ans + cost[i-1] - cost[i];\\n                    //cout<<ans<<\" \";\\n                }\\n\\n                \\n                int x = max(cost[i],cost[i-1]);\\n\\n                cost[i] = x;\\n                cost[i-1] = x;\\n\\n                fun(ans,i-2,n,cost);\\n            }\\n        }\\n    }\\n\\n    int minIncrements(int n, vector<int>& cost) {\\n        \\n        int ans =0;\\n\\n        int i = n-1;\\n\\n        fun(ans,i,n,cost);\\n\\n        for(int i=0;i<n;i++){\\n            cout<<cost[i]<<\" \";\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    void fun(int & ans,int i,int n,vector<int>& cost){\\n        if(i == 0){\\n            //ans = ans + abs(cost[2*i] - cost[2*i + 1]);\\n            return;\\n        }\\n        else{\\n            if(2* i > n && 2*i + 1 > n){ // for leaf node\\n                if(cost[i] >= cost[i-1]){\\n                    ans = ans + cost[i] - cost[i-1];\\n                    //cout<<ans<<\"leaf \";\\n                }\\n                else{\\n                    ans = ans + cost[i-1] - cost[i];\\n                    //cout<<ans<<\"leaf \";\\n                }\\n\\n                int x = max(cost[i],cost[i-1]);\\n\\n                cost[i] = x;\\n                cost[i-1] = x;\\n\\n                fun(ans,i-2,n,cost);\\n            }\\n            else if(2*i < n && 2*i + 1 < n ){\\n                int right = cost[2*i + 1] + cost[i];\\n\\n                int left = cost[2*(i-1) + 1] + cost[i-1];\\n\\n                //cout<<right<<\" \"<<left<<\"\\\\n\";\\n\\n                cost[i] = right;\\n\\n                cost[i-1] = left;\\n\\n                if(cost[i] >= cost[i-1]){\\n                    ans = ans + cost[i] - cost[i-1];\\n                    //cout<<ans<<\" \";\\n                }\\n                else{\\n                    ans = ans + cost[i-1] - cost[i];\\n                    //cout<<ans<<\" \";\\n                }\\n\\n                \\n                int x = max(cost[i],cost[i-1]);\\n\\n                cost[i] = x;\\n                cost[i-1] = x;\\n\\n                fun(ans,i-2,n,cost);\\n            }\\n        }\\n    }\\n\\n    int minIncrements(int n, vector<int>& cost) {\\n        \\n        int ans =0;\\n\\n        int i = n-1;\\n\\n        fun(ans,i,n,cost);\\n\\n        for(int i=0;i<n;i++){\\n            cout<<cost[i]<<\" \";\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3689607,
                "title": "c-start-from-bottom-up",
                "content": "```\\nclass Solution {\\n    \\npublic:\\n    int minIncrements(int n, vector<int>& cost) {\\n        int ans=0,leftChildCost=0,rightChildCost=0;\\n        \\n        for (int i=n/2 -1;i>=0;i--){\\n            leftChildCost = cost[i*2+1];\\n            rightChildCost = cost[i*2+2];\\n            ans += abs(leftChildCost-rightChildCost);\\n            cost[i] += max(leftChildCost,rightChildCost);\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    \\npublic:\\n    int minIncrements(int n, vector<int>& cost) {\\n        int ans=0,leftChildCost=0,rightChildCost=0;\\n        \\n        for (int i=n/2 -1;i>=0;i--){\\n            leftChildCost = cost[i*2+1];\\n            rightChildCost = cost[i*2+2];\\n            ans += abs(leftChildCost-rightChildCost);\\n            cost[i] += max(leftChildCost,rightChildCost);\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3674969,
                "title": "easiest-implementation-best-idea-greedy-and-unique-solution",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int minIncrements(int n, vector<int>& cost) {\\n        int min_cost=0;\\n        for(int i=n-1;i>0;i-=2)\\n        {\\n            int left=cost[i], right=cost[i-1], par=(i-1)/2;\\n            if(left>right)\\n            {\\n                min_cost+=left-right;\\n                right=left;\\n            }\\n            else\\n            {\\n                min_cost+=right-left;\\n                left=right;\\n            }\\n            cost[par]=cost[par]+left;\\n        }\\n        return min_cost;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Dynamic Programming",
                    "Greedy",
                    "Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minIncrements(int n, vector<int>& cost) {\\n        int min_cost=0;\\n        for(int i=n-1;i>0;i-=2)\\n        {\\n            int left=cost[i], right=cost[i-1], par=(i-1)/2;\\n            if(left>right)\\n            {\\n                min_cost+=left-right;\\n                right=left;\\n            }\\n            else\\n            {\\n                min_cost+=right-left;\\n                left=right;\\n            }\\n            cost[par]=cost[par]+left;\\n        }\\n        return min_cost;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3674775,
                "title": "c-simple-and-clean-dfs-solution",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- Build the solution from the leaves upwards\\n- Relies on this invariant of `dfs`: add the correct number of increments for the current subtree to `res` and return its total cost\\n- Thus, when the algorithm comes back to the root, the left and right subtrees have already been solved and what\\'s left is to compare their heights and add the number of increments to make up their difference\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n$$ O(n) $$\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n$$ O(h) $$, where $$ h $$ is height\\n\\n# Code\\n```\\nclass Solution {\\nprivate:\\n    int res;\\n\\npublic:\\n    int minIncrements(int n, vector<int>& cost) {\\n        dfs(1, cost, n);\\n        return res;\\n    }\\n\\n    int dfs(int root, vector<int>& cost, int n) {\\n        if (root > n) {\\n            return 0;\\n        }\\n\\n        int leftLen = dfs(root * 2, cost, n);\\n        int rightLen = dfs(root * 2 + 1, cost, n);\\n        res += abs(leftLen - rightLen);\\n        return cost[root - 1] + max(leftLen, rightLen);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    int res;\\n\\npublic:\\n    int minIncrements(int n, vector<int>& cost) {\\n        dfs(1, cost, n);\\n        return res;\\n    }\\n\\n    int dfs(int root, vector<int>& cost, int n) {\\n        if (root > n) {\\n            return 0;\\n        }\\n\\n        int leftLen = dfs(root * 2, cost, n);\\n        int rightLen = dfs(root * 2 + 1, cost, n);\\n        res += abs(leftLen - rightLen);\\n        return cost[root - 1] + max(leftLen, rightLen);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3670271,
                "title": "95-beats-iterative-cpp-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minIncrements(int n, vector<int>& cost) {\\n        int ans=0;\\n        for(int i=n/2-1;i>=0;i--){\\n            int left=2*i+1;\\n            int right=2*i+2;\\n            ans+=abs(cost[left]-cost[right]);\\n            cost[i]+=max(cost[left],cost[right]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minIncrements(int n, vector<int>& cost) {\\n        int ans=0;\\n        for(int i=n/2-1;i>=0;i--){\\n            int left=2*i+1;\\n            int right=2*i+2;\\n            ans+=abs(cost[left]-cost[right]);\\n            cost[i]+=max(cost[left],cost[right]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3649252,
                "title": "easy-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    void solve(int i,int sum,int &ans,vector<int>&dp,vector<int>&cost,int n){\\n        if(i>=n)return;\\n        int inc=sum-dp[i];\\n        ans+=inc;\\n     solve(2*i+1,sum-inc-cost[i],ans,dp,cost,n);\\n     solve(2*i+2,sum-inc-cost[i],ans,dp,cost,n);\\n    }\\n    int minIncrements(int n, vector<int>&cost) {\\n        vector<int>dp(n);\\n        int p=log2(n);\\n        for(int i=n-1;i>(n-1-(1<<p));i--)dp[i]=cost[i];\\n        int i=n-1;\\n        while(i>0){\\n                dp[(i-1)/2]=max(dp[i],dp[i-1])+cost[(i-1)/2];\\n                i-=2;\\n        }\\n        int ans=0;\\n        solve(0,dp[0],ans,dp,cost,n);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void solve(int i,int sum,int &ans,vector<int>&dp,vector<int>&cost,int n){\\n        if(i>=n)return;\\n        int inc=sum-dp[i];\\n        ans+=inc;\\n     solve(2*i+1,sum-inc-cost[i],ans,dp,cost,n);\\n     solve(2*i+2,sum-inc-cost[i],ans,dp,cost,n);\\n    }\\n    int minIncrements(int n, vector<int>&cost) {\\n        vector<int>dp(n);\\n        int p=log2(n);\\n        for(int i=n-1;i>(n-1-(1<<p));i--)dp[i]=cost[i];\\n        int i=n-1;\\n        while(i>0){\\n                dp[(i-1)/2]=max(dp[i],dp[i-1])+cost[(i-1)/2];\\n                i-=2;\\n        }\\n        int ans=0;\\n        solve(0,dp[0],ans,dp,cost,n);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3649144,
                "title": "java-solution-using-recursion",
                "content": "# Intuition\\nTo solve this problem, you can use a recursive approach. The intuition is to calculate the cost for each path from the root to a leaf node, and then find the minimum number of increments needed to make all the paths have equal costs.\\n\\n# Approach\\nWhile calcultaing the maxLength recursively, maintain two array leftSum and rightSum. The leftSum and rightSum will contain the max length to current node. On the next recursion, just keep on sending remainingSum which is maxLength - cost[i] to each child node. If both leftSum(i) and rightSum(i) are less than remainingSum then we know that we can increase the cost[i] by remainingSum-max(leftSum[i], rightSum[i]).\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\nclass Solution {\\n    int maxLength;\\n    int []leftSum;\\n    int []rightSum;\\n    int ans;\\n    public int getMaxLength(int[] cost, int i) {\\n        if(i>=cost.length) {\\n            return 0;\\n        }\\n        if(cost.length<=((2*i) + 1) || cost.length<=((2*i) + 2)) {\\n            leftSum[i] = cost[i];\\n            rightSum[i] = cost[i];\\n            return cost[i];\\n        }\\n        leftSum[i] = getMaxLength(cost, 2*i+1) + cost[i];\\n        rightSum[i] = getMaxLength(cost, 2*i+2) + cost[i];\\n\\n        return Math.max(leftSum[i], rightSum[i]);\\n\\n    }\\n    public void traverse1(int[] cost, int remainingSum, int i) {\\n        if(i>=cost.length) {\\n            return;\\n        }\\n        if(cost.length<=((2*i) + 1) || cost.length<=((2*i) + 2)) {\\n            ans = ans + (remainingSum-leftSum[i]);\\n            return;\\n        }\\n        int inc = 0;\\n        if(leftSum[i]<remainingSum && rightSum[i]<remainingSum) {\\n            inc = remainingSum - Math.max(leftSum[i], rightSum[i]);\\n            leftSum[i] +=inc;\\n            rightSum[i] +=inc;\\n            cost[i]+=inc;\\n            ans+=inc;\\n        } else {\\n            inc = 0;\\n        }\\n        traverse1(cost, remainingSum-cost[i], 2*i+1);\\n        traverse1(cost, remainingSum-cost[i], 2*i+2);\\n\\n    }\\n    public int minIncrements(int n, int[] cost) {\\n        \\n        leftSum = new int[n];\\n        rightSum = new int[n];\\n        maxLength = getMaxLength(cost, 0);\\n        traverse1(cost, maxLength, 0);\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    int maxLength;\\n    int []leftSum;\\n    int []rightSum;\\n    int ans;\\n    public int getMaxLength(int[] cost, int i) {\\n        if(i>=cost.length) {\\n            return 0;\\n        }\\n        if(cost.length<=((2*i) + 1) || cost.length<=((2*i) + 2)) {\\n            leftSum[i] = cost[i];\\n            rightSum[i] = cost[i];\\n            return cost[i];\\n        }\\n        leftSum[i] = getMaxLength(cost, 2*i+1) + cost[i];\\n        rightSum[i] = getMaxLength(cost, 2*i+2) + cost[i];\\n\\n        return Math.max(leftSum[i], rightSum[i]);\\n\\n    }\\n    public void traverse1(int[] cost, int remainingSum, int i) {\\n        if(i>=cost.length) {\\n            return;\\n        }\\n        if(cost.length<=((2*i) + 1) || cost.length<=((2*i) + 2)) {\\n            ans = ans + (remainingSum-leftSum[i]);\\n            return;\\n        }\\n        int inc = 0;\\n        if(leftSum[i]<remainingSum && rightSum[i]<remainingSum) {\\n            inc = remainingSum - Math.max(leftSum[i], rightSum[i]);\\n            leftSum[i] +=inc;\\n            rightSum[i] +=inc;\\n            cost[i]+=inc;\\n            ans+=inc;\\n        } else {\\n            inc = 0;\\n        }\\n        traverse1(cost, remainingSum-cost[i], 2*i+1);\\n        traverse1(cost, remainingSum-cost[i], 2*i+2);\\n\\n    }\\n    public int minIncrements(int n, int[] cost) {\\n        \\n        leftSum = new int[n];\\n        rightSum = new int[n];\\n        maxLength = getMaxLength(cost, 0);\\n        traverse1(cost, maxLength, 0);\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3636709,
                "title": "easy-greedy-approach",
                "content": "# Intuition\\nJust greedy\\n# Approach\\ntraverse from back of the array and change the cost array whenever there is mismatch in children of a node(add diff of cost of child to parent) ,and take the sum of differnce in cost of children.\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minIncrements(int n, vector<int>& cost) {\\n        int ans=0;\\n        for(int i=n-1;i>=0;i--)\\n        {\\n            if(2*(i+1)<=n && 2*(i+1)+1<=n)\\n            {\\n                ans+=abs(cost[2*i+1]-cost[2*i+2]);\\n                cost[i]+=max(cost[2*i+1],cost[2*i+2]);\\n            }\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minIncrements(int n, vector<int>& cost) {\\n        int ans=0;\\n        for(int i=n-1;i>=0;i--)\\n        {\\n            if(2*(i+1)<=n && 2*(i+1)+1<=n)\\n            {\\n                ans+=abs(cost[2*i+1]-cost[2*i+2]);\\n                cost[i]+=max(cost[2*i+1],cost[2*i+2]);\\n            }\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3627719,
                "title": "bottom-up-python-beats-96",
                "content": "# Intuition\\nBottum up, at each level, we do\\n1. add the difference of the cost between 2 siblings to the result\\n2. add the max cost of the 2 to their parent\\n\\n# Complexity\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution:\\n    def minIncrements(self, n: int, cost: List[int]) -> int:\\n        r = 0\\n        n -= 1\\n        while n > 0:\\n            rv = cost[n]\\n            n -= 1\\n            lv = cost[n]\\n            r += abs(lv - rv)\\n            n -= 1\\n            parent = n // 2\\n            cost[parent] += max(lv, rv)\\n        return r\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minIncrements(self, n: int, cost: List[int]) -> int:\\n        r = 0\\n        n -= 1\\n        while n > 0:\\n            rv = cost[n]\\n            n -= 1\\n            lv = cost[n]\\n            r += abs(lv - rv)\\n            n -= 1\\n            parent = n // 2\\n            cost[parent] += max(lv, rv)\\n        return r\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3592965,
                "title": "java-dfs",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nif you see carefully ,for every subtree the cost of parent node will be shared equally to left  tree portion and right tree portion.so we just need to balance the cost of left subtree and right subtree.so we calculate the difference of left subtree and right subtree cost ,that many times we perfom increment operation on the shortage side.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    int increments;\\n    private int back(int[]cost,int root){\\n         if(root>cost.length)return 0;\\n         int left=2*root; //calculate left and right subtree cost\\n         int right=left+1; \\n         \\n         int lsum=back(cost,left);\\n         int rsum=back(cost,right);\\n         increments+=Math.abs(lsum-rsum);//adding the  number of operations required to equalize the cost of both subtrees \\n         return cost[root-1]+Math.max(lsum,rsum);  \\n\\n    }\\n    public int minIncrements(int n, int[] cost) {\\n      increments=0;\\n      back(cost,1);\\n      return increments;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    int increments;\\n    private int back(int[]cost,int root){\\n         if(root>cost.length)return 0;\\n         int left=2*root; //calculate left and right subtree cost\\n         int right=left+1; \\n         \\n         int lsum=back(cost,left);\\n         int rsum=back(cost,right);\\n         increments+=Math.abs(lsum-rsum);//adding the  number of operations required to equalize the cost of both subtrees \\n         return cost[root-1]+Math.max(lsum,rsum);  \\n\\n    }\\n    public int minIncrements(int n, int[] cost) {\\n      increments=0;\\n      back(cost,1);\\n      return increments;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3564029,
                "title": "beats-100-2-line-solution-explained",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nCalculate the absolute difference between the costs of the left child (2 * i + 1) and the right child (2 * i + 2) of each node at index i. Add this difference to the moves variable to keep track of the total increments needed.\\n\\nUpdate the cost of the current node (at index i) by adding the maximum cost between its left and right child. This ensures that the cost of the current node becomes equal to the maximum cost among its children.\\n\\nRepeat the above steps for the parent nodes up to the root.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    O(1)\\n\\n# Code\\n```\\n/**\\n * @param {number} n\\n * @param {number[]} cost\\n * @return {number}\\n */\\nvar minIncrements = function(n, cost) {\\n    let moves = 0;\\n    for(let i = (n + 1) / 2 - 2; i >= 0; i--) {\\n        moves += Math.abs(cost[2 * i + 1] - cost[2 * i + 2]);\\n        cost[i] += Math.max(cost[2 * i + 1], cost[2 * i + 2]);\\n    }\\n    return moves;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} n\\n * @param {number[]} cost\\n * @return {number}\\n */\\nvar minIncrements = function(n, cost) {\\n    let moves = 0;\\n    for(let i = (n + 1) / 2 - 2; i >= 0; i--) {\\n        moves += Math.abs(cost[2 * i + 1] - cost[2 * i + 2]);\\n        cost[i] += Math.max(cost[2 * i + 1], cost[2 * i + 2]);\\n    }\\n    return moves;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3563771,
                "title": "4-liner-c-lazy-propagation",
                "content": "\\n# Complexity\\n- Time complexity:\\n***O(n)***\\n\\n- Space complexity: \\n***O(1)***\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minIncrements(int n, vector<int>& cost) {\\n        int ans = 0;\\n        for(int i = n-1; i >= 2 ; i-=2) {\\n            ans += (max(cost[i], cost[i-1]) - min(cost[i], cost[i-1]));\\n            cost[(i-1)/2] += max(cost[i], cost[i-1]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minIncrements(int n, vector<int>& cost) {\\n        int ans = 0;\\n        for(int i = n-1; i >= 2 ; i-=2) {\\n            ans += (max(cost[i], cost[i-1]) - min(cost[i], cost[i-1]));\\n            cost[(i-1)/2] += max(cost[i], cost[i-1]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3562583,
                "title": "easy-to-understand-c-solution-using-recursion",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int cnt=0;\\n    \\n    int solve(int i, int n, vector<int> &cost){\\n        if(i==n) return cost[n-1];\\n        if(2*i>=n) return cost[i-1];\\n        \\n        int left=0;\\n        left = solve(2*i,n,cost);\\n        int rt=0;\\n        rt = solve(2*i+1,n,cost);\\n        int diff = abs(left-rt);\\n        cnt+=diff;\\n        return max(left,rt) + cost[i-1];\\n    }\\n    \\n    \\n    int minIncrements(int n, vector<int>& cost) {\\n        int i=1;\\n        int val = solve(1,n,cost);\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int cnt=0;\\n    \\n    int solve(int i, int n, vector<int> &cost){\\n        if(i==n) return cost[n-1];\\n        if(2*i>=n) return cost[i-1];\\n        \\n        int left=0;\\n        left = solve(2*i,n,cost);\\n        int rt=0;\\n        rt = solve(2*i+1,n,cost);\\n        int diff = abs(left-rt);\\n        cnt+=diff;\\n        return max(left,rt) + cost[i-1];\\n    }\\n    \\n    \\n    int minIncrements(int n, vector<int>& cost) {\\n        int i=1;\\n        int val = solve(1,n,cost);\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3558676,
                "title": "o-1-space-o-n-time",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minIncrements(int n, vector<int>& cost) {\\n        int ans=0;\\n        int i=(n-1)/2;\\n        while(i>=1){\\n            ans+=abs(cost[2*i-1]-cost[2*i+1-1]);\\n            cost[i-1]=cost[i-1]+max(cost[2*i-1],cost[2*i+1-1]);\\n            i--;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minIncrements(int n, vector<int>& cost) {\\n        int ans=0;\\n        int i=(n-1)/2;\\n        while(i>=1){\\n            ans+=abs(cost[2*i-1]-cost[2*i+1-1]);\\n            cost[i-1]=cost[i-1]+max(cost[2*i-1],cost[2*i+1-1]);\\n            i--;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3553714,
                "title": "c-240-ms",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int minIncrements(int n, const vector<int>& cost)\\n    {\\n        int count=0;\\n\\n        function<int(int)> func = [&](int pos)\\n        {\\n            int left  = 0;\\n            int right = 0;\\n            int tmp = pos * 2 + 1;\\n\\n            if(tmp < cost.size())\\n            {\\n                left  = func(tmp);\\n                right = func(tmp + 1);\\n                count += abs(left - right);\\n            }\\n\\n            return max(left, right) + cost[pos];\\n        };\\n\\n        func(0);\\n\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minIncrements(int n, const vector<int>& cost)\\n    {\\n        int count=0;\\n\\n        function<int(int)> func = [&](int pos)\\n        {\\n            int left  = 0;\\n            int right = 0;\\n            int tmp = pos * 2 + 1;\\n\\n            if(tmp < cost.size())\\n            {\\n                left  = func(tmp);\\n                right = func(tmp + 1);\\n                count += abs(left - right);\\n            }\\n\\n            return max(left, right) + cost[pos];\\n        };\\n\\n        func(0);\\n\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3543320,
                "title": "java-3-liner-constant-space-and-o-n-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nAs every path leading upto root must be the same cost, two children must have the same cost. As we can only increment, we\\'ve to increment the cost of the node with lesser cost. We do this bottoms up and update cost of each node to cost of path to any leaf node from that node (they\\'ll all be equal as we\\'re adjusting costs).\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nAs the tree is a perfect binary tree, it\\'s size will be always be one less than a power of 2. As we can track increments as we update costs, we can just modify the cost array and don\\'t need extra space. We start from the layer above the leaf nodes as leaf nodes cost adjustment really need not be recorded.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public int minIncrements(int n, int[] cost) {\\n        int res = 0;\\n    \\n        for (int i = (n - 2) / 2; i >= 0; i--) {\\n            cost[i] += Math.max(cost[2 * i + 1], cost[2 * i + 2]);\\n            res += Math.abs(cost[2 * i + 1] - cost[2 * i + 2]);\\n        }\\n        \\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minIncrements(int n, int[] cost) {\\n        int res = 0;\\n    \\n        for (int i = (n - 2) / 2; i >= 0; i--) {\\n            cost[i] += Math.max(cost[2 * i + 1], cost[2 * i + 2]);\\n            res += Math.abs(cost[2 * i + 1] - cost[2 * i + 2]);\\n        }\\n        \\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3532176,
                "title": "optimizing-cost-equality-in-perfect-binary-trees-using-dfs-and-recursion",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIn a perfect binary tree, the objective is to equalise the costs of all pathways leading from the root to each leaf node. We can reduce the total number of increments necessary by raising the costs of a few specific nodes.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nTo navigate the ideal binary tree, we can utilise a depth-first search (DFS). We determine the absolute difference between each node\\'s left and right child node sums at each node. This difference is added to the final outcome. Along with the cost of the current node, we also return the highest sum between the left and right child nodes. We discover the ideal increments for each subtree in this way.\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(logN)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumIncrements = 0;\\n\\n    // Depth-first search function\\n    int dfs(int index, vector<int>& cost) {\\n        // Base case: If index exceeds the size of the cost vector, return 0\\n        if (index > cost.size()) {\\n            return 0;\\n        }\\n\\n        // Recursive calls for left and right child nodes\\n        int leftSum = dfs(2 * index, cost);\\n        int rightSum = dfs(2 * index + 1, cost);\\n\\n        // Calculate the absolute difference between left and right child sums\\n        int difference = abs(leftSum - rightSum);\\n\\n        // Accumulate the absolute difference to the overall result\\n        minimumIncrements += difference;\\n\\n        // Return the maximum sum between the left and right child nodes, plus the current cost\\n        return max(leftSum, rightSum) + cost[index - 1];\\n    }\\n\\n    int minIncrements(int n, vector<int>& cost) {\\n        // Start the depth-first search from the root node (index 1)\\n        int sum = dfs(1, cost);\\n\\n        // Return the accumulated minimum increments\\n        return minimumIncrements;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumIncrements = 0;\\n\\n    // Depth-first search function\\n    int dfs(int index, vector<int>& cost) {\\n        // Base case: If index exceeds the size of the cost vector, return 0\\n        if (index > cost.size()) {\\n            return 0;\\n        }\\n\\n        // Recursive calls for left and right child nodes\\n        int leftSum = dfs(2 * index, cost);\\n        int rightSum = dfs(2 * index + 1, cost);\\n\\n        // Calculate the absolute difference between left and right child sums\\n        int difference = abs(leftSum - rightSum);\\n\\n        // Accumulate the absolute difference to the overall result\\n        minimumIncrements += difference;\\n\\n        // Return the maximum sum between the left and right child nodes, plus the current cost\\n        return max(leftSum, rightSum) + cost[index - 1];\\n    }\\n\\n    int minIncrements(int n, vector<int>& cost) {\\n        // Start the depth-first search from the root node (index 1)\\n        int sum = dfs(1, cost);\\n\\n        // Return the accumulated minimum increments\\n        return minimumIncrements;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3530180,
                "title": "java-c-python-fast-and-short-solution-explained",
                "content": "# TL;DR\\n\\n\\n```java []\\nclass Solution {\\n    public int minIncrements(int n, int[] cost) {\\n        int increments = 0;\\n        for (int i = (n - 3) / 2; i >= 0; i--) {\\n            cost[i] += Math.max(cost[i * 2 + 1], cost[i * 2 + 2]);\\n            increments += Math.abs(cost[i * 2 + 1] - cost[i * 2 + 2]);\\n        }\\n        return increments;\\n    }\\n}\\n```\\n``` cpp []\\nclass Solution {\\npublic:\\n    int minIncrements(int n, vector<int>& cost) {\\n        int increments = 0;\\n        for (int i = (n - 3) / 2; i >= 0; i--) {\\n            cost[i] += max(cost[i * 2 + 1], cost[i * 2 + 2]);\\n            increments += abs(cost[i * 2 + 1] - cost[i * 2 + 2]);\\n        }\\n        return increments;\\n    }\\n};\\n```\\n``` python []\\nclass Solution:\\n    def minIncrements(self, n: int, cost: List[int]) -> int:\\n        increments = 0\\n        for i in range((n - 3) // 2, -1, -1):\\n            cost[i] += max(cost[i * 2 + 1], cost[i * 2 + 2])\\n            increments += abs(cost[i * 2 + 1] - cost[i * 2 + 2])\\n        return increments\\n```\\n---\\n#### \\u26A0\\uFE0F Don\\'t forget to upvote if you like this solution. \\uD83D\\uDE43\\n---\\n\\n\\n# Approach\\n\\n1. **Iterate over the array in reverse order**: We start from the last parent node which is at index `(n - 3) / 2` and move towards the root. The `-3` is to avoid the leaf nodes as they do not have children.\\n\\n2. **Increase the cost of the parent node**: For each node, we increment its cost by the maximum cost of its children. This ensures that the path through this node to a leaf node has the same cost as the path through its sibling to a leaf node. \\n\\n3. **Calculate the increments**: We calculate the difference in costs of the two children of the node and add it to a counter. This represents the minimum number of increments we have made to make the costs of the paths from the root to each leaf node equal.\\n\\n4. **Return the increments**: After iterating over all nodes, we return the counter.\\n\\n# Complexity Analysis\\n\\n- **Time Complexity**: The time complexity is $$O(n)$$, where $$n$$ is the number of nodes. This is because we\\'re iterating over the list of nodes once.\\n\\n- **Space Complexity**: The space complexity is $$O(1)$$, as we only use a few variables to store the intermediate and final results.\\n\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Python3"
                ],
                "code": "```java []\\nclass Solution {\\n    public int minIncrements(int n, int[] cost) {\\n        int increments = 0;\\n        for (int i = (n - 3) / 2; i >= 0; i--) {\\n            cost[i] += Math.max(cost[i * 2 + 1], cost[i * 2 + 2]);\\n            increments += Math.abs(cost[i * 2 + 1] - cost[i * 2 + 2]);\\n        }\\n        return increments;\\n    }\\n}\\n```\n``` cpp []\\nclass Solution {\\npublic:\\n    int minIncrements(int n, vector<int>& cost) {\\n        int increments = 0;\\n        for (int i = (n - 3) / 2; i >= 0; i--) {\\n            cost[i] += max(cost[i * 2 + 1], cost[i * 2 + 2]);\\n            increments += abs(cost[i * 2 + 1] - cost[i * 2 + 2]);\\n        }\\n        return increments;\\n    }\\n};\\n```\n``` python []\\nclass Solution:\\n    def minIncrements(self, n: int, cost: List[int]) -> int:\\n        increments = 0\\n        for i in range((n - 3) // 2, -1, -1):\\n            cost[i] += max(cost[i * 2 + 1], cost[i * 2 + 2])\\n            increments += abs(cost[i * 2 + 1] - cost[i * 2 + 2])\\n        return increments\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3530034,
                "title": "solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nReplace node values with max in its leaf values and than add the absolute of difference in its sum values in the result integer.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n# Code\\n```\\nclass Solution {\\n        public int minIncrements(int n, int[] A) {\\n        int res = 0;\\n        for (int i = n / 2 - 1; i >= 0; --i) {\\n            int l = i * 2 + 1, r = i * 2 + 2;\\n            res += Math.abs(A[l] - A[r]);\\n            A[i] += Math.max(A[l], A[r]);\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n        public int minIncrements(int n, int[] A) {\\n        int res = 0;\\n        for (int i = n / 2 - 1; i >= 0; --i) {\\n            int l = i * 2 + 1, r = i * 2 + 2;\\n            res += Math.abs(A[l] - A[r]);\\n            A[i] += Math.max(A[l], A[r]);\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3526828,
                "title": "java",
                "content": "\\n# Code\\n```\\nclass Solution {\\n\\n    int n;\\n    int [] cost;\\n    int increaments;\\n    public int minIncrements(int n, int[] cost) {\\n        this.n=n;\\n        this.cost=cost;\\n        increaments =0;\\n        if (n==3) return  Math.abs(cost[1]-cost[2]);\\n        equalize(1);\\n        return increaments;\\n    }\\n\\n    public int equalize(int head){\\n        if (head*4>n){\\n            increaments += Math.abs(cost[head*2-1]-cost[head*2+1-1]);\\n            return Math.max(cost[head*2-1],cost[head*2+1-1]);\\n        }\\n        int leftPath = equalize(head*2) + cost[head*2-1];\\n        int rightPath = equalize(head*2+1)+ cost[head*2+1-1];\\n        increaments += Math.abs(leftPath-rightPath);\\n        return Math.max(leftPath,rightPath);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n\\n    int n;\\n    int [] cost;\\n    int increaments;\\n    public int minIncrements(int n, int[] cost) {\\n        this.n=n;\\n        this.cost=cost;\\n        increaments =0;\\n        if (n==3) return  Math.abs(cost[1]-cost[2]);\\n        equalize(1);\\n        return increaments;\\n    }\\n\\n    public int equalize(int head){\\n        if (head*4>n){\\n            increaments += Math.abs(cost[head*2-1]-cost[head*2+1-1]);\\n            return Math.max(cost[head*2-1],cost[head*2+1-1]);\\n        }\\n        int leftPath = equalize(head*2) + cost[head*2-1];\\n        int rightPath = equalize(head*2+1)+ cost[head*2+1-1];\\n        increaments += Math.abs(leftPath-rightPath);\\n        return Math.max(leftPath,rightPath);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3524043,
                "title": "c-solution-recursion",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int ans=0;\\n    int helper(int n,vector<int> &cost,int i)\\n    {\\n        if(i>=n)\\n        {\\n            return 0;\\n        }\\n        int left=helper(n,cost,2*i+1);\\n        int right=helper(n,cost,2*i+2);\\n        ans+=abs(right-left);\\n        return max(right,left)+cost[i];\\n    }\\n    int minIncrements(int n, vector<int>& cost) {\\n         helper(n,cost,0);\\n         return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int ans=0;\\n    int helper(int n,vector<int> &cost,int i)\\n    {\\n        if(i>=n)\\n        {\\n            return 0;\\n        }\\n        int left=helper(n,cost,2*i+1);\\n        int right=helper(n,cost,2*i+2);\\n        ans+=abs(right-left);\\n        return max(right,left)+cost[i];\\n    }\\n    int minIncrements(int n, vector<int>& cost) {\\n         helper(n,cost,0);\\n         return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3517911,
                "title": "scala-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nobject Solution {\\n    def minIncrements(n: Int, cost: Array[Int]): Int = \\n        (n / 2 - 1 to 0 by -1).foldLeft(0)((acc, i) =>{\\n            val l = i * 2 + 1\\n            var r = i * 2 + 2\\n            cost(i) += cost(l) max cost(r)\\n            acc + Math.abs(cost(l) - cost(r))\\n        })\\n}\\n```",
                "solutionTags": [
                    "Scala"
                ],
                "code": "```\\nobject Solution {\\n    def minIncrements(n: Int, cost: Array[Int]): Int = \\n        (n / 2 - 1 to 0 by -1).foldLeft(0)((acc, i) =>{\\n            val l = i * 2 + 1\\n            var r = i * 2 + 2\\n            cost(i) += cost(l) max cost(r)\\n            acc + Math.abs(cost(l) - cost(r))\\n        })\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3516322,
                "title": "greedy-solution-c",
                "content": "# Complexity\\n- Time complexity:O(N)\\n\\n- Space complexity: O(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minIncrements(int n, vector<int>& costs) {\\n        int ans=0;\\n        for(int i=costs.size()-1; i>=1; i-=2){\\n            int d= max(costs[i],costs[i-1]);\\n            ans+=abs(costs[i]-costs[i-1]);\\n            costs[(i-1)/2]+=d;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minIncrements(int n, vector<int>& costs) {\\n        int ans=0;\\n        for(int i=costs.size()-1; i>=1; i-=2){\\n            int d= max(costs[i],costs[i-1]);\\n            ans+=abs(costs[i]-costs[i-1]);\\n            costs[(i-1)/2]+=d;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3514495,
                "title": "c-intuitive-breadth-first-search",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- `int lastLvlCnt = (n + 1) / 2;` Used to count nodes from each level\\n- `int[] minCosts = new int[n];` Tree with min increased cost\\n- `public int GetMaxCost(int[] costs, int i) {...}` Find the max cost from tree paths\\n- `public void SetCostsWithLeafSum(int[] costs, int[] minCosts, int i, int pathSum, int maxCost) {...}` Set the `minCosts` arr and leaf = leaf + how much required cost in this path to be equal to max path cost\\n- `while (lastLvlCnt != 1) {... for (int curIdx = idx; curIdx < curN - 1; curIdx += 2) {...}...}` Iterate level by level in the tree from the leaf(bottom-up). And to minimize added cost for each path: left, right, we can remove common added cost from both of them, and add to parent node.\\n- `for (int i = 0; i < costs.Length; i++) {\\n            res += minCosts[i] - costs[i];\\n        }` Finally compare initial nodes with `minCosts` and add difference to `result`.\\n\\n# Complexity\\n- Time complexity:$$O(n)$$, n = nodes size\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(n) +  O(h)$$, n = nodes size, h - nodes height\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\npublic class Solution {\\n    public int MinIncrements(int n, int[] costs) {\\n        int lastLvlCnt = (n + 1) / 2;\\n        int[] minCosts = new int[n];\\n        int res = 0;\\n\\n        int maxCost = GetMaxCost(costs, 0);\\n        SetCostsWithLeafSum(costs, minCosts, 0, 0, maxCost);\\n      \\n        int idx = n - lastLvlCnt;\\n        while (lastLvlCnt != 1) {\\n            int curN = idx + lastLvlCnt;\\n\\n            for (int curIdx = idx; curIdx < curN - 1; curIdx += 2) {\\n                int addedLeft = minCosts[curIdx] - costs[curIdx];\\n                int addedRight = minCosts[curIdx + 1] - costs[curIdx + 1];\\n                int minAdded = Math.Min(addedLeft, addedRight);\\n\\n                minCosts[curIdx / 2] += minAdded;\\n                minCosts[curIdx] -= minAdded;\\n                minCosts[curIdx + 1] -= minAdded;\\n            }\\n\\n            lastLvlCnt /= 2;\\n            idx -= lastLvlCnt;\\n        }\\n\\n        for (int i = 0; i < costs.Length; i++) {\\n            res += minCosts[i] - costs[i];\\n        }\\n\\n        return res;\\n    }\\n\\n    public int GetMaxCost(int[] costs, int i) {\\n        if (i >= costs.Length) return 0;\\n\\n        int leftCost = GetMaxCost(costs, (i + 1) * 2 - 1);\\n        int rightCost = GetMaxCost(costs, (i + 1) * 2 + 1 - 1);\\n\\n        return costs[i] + Math.Max(leftCost, rightCost);\\n    }\\n\\n    public void SetCostsWithLeafSum(int[] costs, int[] minCosts, int i, int pathSum, int maxCost) {\\n        minCosts[i] = costs[i];\\n\\n        if ((i + 1) * 2 >= costs.Length) {\\n            minCosts[i] += maxCost - (pathSum + costs[i]);\\n            return;\\n        }\\n\\n        SetCostsWithLeafSum(costs, minCosts, (i + 1) * 2 - 1, pathSum + costs[i], maxCost);\\n        SetCostsWithLeafSum(costs, minCosts, (i + 1) * 2 + 1 - 1, pathSum + costs[i], maxCost);\\n    }\\n}\\n\\n\\n```",
                "solutionTags": [
                    "C#",
                    "Tree",
                    "Breadth-First Search",
                    "Recursion"
                ],
                "code": "```\\npublic class Solution {\\n    public int MinIncrements(int n, int[] costs) {\\n        int lastLvlCnt = (n + 1) / 2;\\n        int[] minCosts = new int[n];\\n        int res = 0;\\n\\n        int maxCost = GetMaxCost(costs, 0);\\n        SetCostsWithLeafSum(costs, minCosts, 0, 0, maxCost);\\n      \\n        int idx = n - lastLvlCnt;\\n        while (lastLvlCnt != 1) {\\n            int curN = idx + lastLvlCnt;\\n\\n            for (int curIdx = idx; curIdx < curN - 1; curIdx += 2) {\\n                int addedLeft = minCosts[curIdx] - costs[curIdx];\\n                int addedRight = minCosts[curIdx + 1] - costs[curIdx + 1];\\n                int minAdded = Math.Min(addedLeft, addedRight);\\n\\n                minCosts[curIdx / 2] += minAdded;\\n                minCosts[curIdx] -= minAdded;\\n                minCosts[curIdx + 1] -= minAdded;\\n            }\\n\\n            lastLvlCnt /= 2;\\n            idx -= lastLvlCnt;\\n        }\\n\\n        for (int i = 0; i < costs.Length; i++) {\\n            res += minCosts[i] - costs[i];\\n        }\\n\\n        return res;\\n    }\\n\\n    public int GetMaxCost(int[] costs, int i) {\\n        if (i >= costs.Length) return 0;\\n\\n        int leftCost = GetMaxCost(costs, (i + 1) * 2 - 1);\\n        int rightCost = GetMaxCost(costs, (i + 1) * 2 + 1 - 1);\\n\\n        return costs[i] + Math.Max(leftCost, rightCost);\\n    }\\n\\n    public void SetCostsWithLeafSum(int[] costs, int[] minCosts, int i, int pathSum, int maxCost) {\\n        minCosts[i] = costs[i];\\n\\n        if ((i + 1) * 2 >= costs.Length) {\\n            minCosts[i] += maxCost - (pathSum + costs[i]);\\n            return;\\n        }\\n\\n        SetCostsWithLeafSum(costs, minCosts, (i + 1) * 2 - 1, pathSum + costs[i], maxCost);\\n        SetCostsWithLeafSum(costs, minCosts, (i + 1) * 2 + 1 - 1, pathSum + costs[i], maxCost);\\n    }\\n}\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3513696,
                "title": "c-recursion-based-solution-simple-and-easy-to-understand",
                "content": "# Intuition\\n Use simple recursion, main logic is that for two leaves with same parent length of path uptil those two leaves will be same therefore values of two leaves should be equal. To make them equal just make them equal to max of both. Now recursively do this for each level \\n\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int final_cost = 0;\\n    int recurs(int n, vector<int>& cost,int i)\\n    {\\n        if(2*i>n)\\n            return cost[i-1];\\n        \\n        int left = recurs(n,cost,2*i);\\n        int right = recurs(n,cost,2*i+1);\\n\\n        // cout<<i<<\" \"<<left<<\" \"<<right<<endl;\\n\\n        int m = max(left,right);\\n        final_cost += m-left+m-right;\\n        return m+cost[i-1];       \\n    }\\n  \\n    int minIncrements(int n, vector<int>& cost) {\\n        final_cost = 0;\\n        recurs(n,cost,1);\\n        return final_cost;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int final_cost = 0;\\n    int recurs(int n, vector<int>& cost,int i)\\n    {\\n        if(2*i>n)\\n            return cost[i-1];\\n        \\n        int left = recurs(n,cost,2*i);\\n        int right = recurs(n,cost,2*i+1);\\n\\n        // cout<<i<<\" \"<<left<<\" \"<<right<<endl;\\n\\n        int m = max(left,right);\\n        final_cost += m-left+m-right;\\n        return m+cost[i-1];       \\n    }\\n  \\n    int minIncrements(int n, vector<int>& cost) {\\n        final_cost = 0;\\n        recurs(n,cost,1);\\n        return final_cost;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3513367,
                "title": "easy-dfs-solution-with-tc-sc",
                "content": "\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$ \\n\\n- Space complexity:\\n$$O(h)$$ , height of tree = logn\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n   \\n    int solve(int node,vector<int> &cost,int n,int &ans){\\n        int child1 = 2*node + 1;\\n        int child2 = 2*node + 2;\\n        \\n        if(child1 >= n && child2 >= n){\\n            //Leaf\\n            return cost[node];\\n        }\\n        \\n        int left_cost_needed = 0, right_cost_needed = 0;\\n        \\n        left_cost_needed = solve(child1,cost,n,ans);\\n        \\n        right_cost_needed = solve(child2,cost,n,ans);\\n        \\n        ans = ans + abs(left_cost_needed-right_cost_needed);\\n\\n        //Updated Cost For Tree from node till ALL leafs\\n        return cost[node] + max(left_cost_needed,right_cost_needed);\\n             \\n    }\\n    \\n    int minIncrements(int n, vector<int>& cost) {\\n       //Perfect Tree => Two Childs OR Zero\\n        int ans = 0;\\n      \\n        solve(0,cost,n,ans);\\n    \\n        return ans;\\n          \\n    }\\n  \\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n   \\n    int solve(int node,vector<int> &cost,int n,int &ans){\\n        int child1 = 2*node + 1;\\n        int child2 = 2*node + 2;\\n        \\n        if(child1 >= n && child2 >= n){\\n            //Leaf\\n            return cost[node];\\n        }\\n        \\n        int left_cost_needed = 0, right_cost_needed = 0;\\n        \\n        left_cost_needed = solve(child1,cost,n,ans);\\n        \\n        right_cost_needed = solve(child2,cost,n,ans);\\n        \\n        ans = ans + abs(left_cost_needed-right_cost_needed);\\n\\n        //Updated Cost For Tree from node till ALL leafs\\n        return cost[node] + max(left_cost_needed,right_cost_needed);\\n             \\n    }\\n    \\n    int minIncrements(int n, vector<int>& cost) {\\n       //Perfect Tree => Two Childs OR Zero\\n        int ans = 0;\\n      \\n        solve(0,cost,n,ans);\\n    \\n        return ans;\\n          \\n    }\\n  \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3512718,
                "title": "simple-dfs-recursion-python-3",
                "content": "# Intuition\\nI had a hard time solving this question but what u can really do is run a simple recursion/dfs.\\nThe main logic of the question is we have to find the min no of increment we need to make.\\n\\nSo for every sibling nodes we always have to make them equal thus add their diff to total will give us min no inc to make.\\n**why left = 2 * node => because we are given the left will have 2 * node and right will have 2 * node + 1**\\n\\nif any time our node >= n+1 we moved out of boundary thus return 0\\n\\n`why max(left, right) => suppose left has cost of 2 and right has cost of 3. We already added 1 in total making left = right so what cost we need to send to parent to make it max cost? The max value of its child i.e max(left, right)\\n`\\n# Code\\n```\\nclass Solution:\\n    def minIncrements(self, n: int, cost: List[int]) -> int:\\n        # if they have same parent -> make parent increment\\n        # else -> indivdual increment\\n        total = 0\\n        def dfs(node):\\n            nonlocal total\\n            if node >= n + 1:\\n                return 0\\n            \\n            left = dfs(2*node)\\n            right = dfs(2*node + 1)\\n            total += abs(left - right)\\n            return max(left, right) + cost[node-1]\\n        dfs(1)\\n        return total\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minIncrements(self, n: int, cost: List[int]) -> int:\\n        # if they have same parent -> make parent increment\\n        # else -> indivdual increment\\n        total = 0\\n        def dfs(node):\\n            nonlocal total\\n            if node >= n + 1:\\n                return 0\\n            \\n            left = dfs(2*node)\\n            right = dfs(2*node + 1)\\n            total += abs(left - right)\\n            return max(left, right) + cost[node-1]\\n        dfs(1)\\n        return total\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3511367,
                "title": "c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int minIncrements(int n, vector<int>& cost) {\\n        int len = cost.size();\\n        for (int i = 0; i < len; i++) {\\n            if (2 * i + 1 < len) {\\n                cost[2 * i + 1] += cost[i];\\n            }\\n            if (2 * i + 2 < len) {\\n                cost[2 * i + 2] += cost[i];\\n            }\\n        }\\n        int mxValue = *max_element(cost.begin(), cost.end());\\n        vector<int> mx(len);\\n        for (int i = len - 1; i > len / 2 - 1; i--) {\\n            mx[i] = cost[i];\\n        }\\n        for (int i = len / 2 - 1; i >= 0; i--) {\\n           mx[i] = max(mx[2 * i + 1], mx[2 * i + 2]);\\n        }\\n        vector<int> down(len);\\n        int sol = 0;\\n        for (int i = 0; i < n; i++) {\\n            int curValue = mx[i] + down[i];\\n            if (curValue < mxValue) {\\n                int diff = mxValue - curValue;\\n                sol += diff;\\n                down[i] += diff;\\n            }\\n            if (2  * i + 1 < len) {\\n                down[2 * i + 1] = down[i];\\n            }\\n            if (2 * i + 2 < len) {\\n                down[2 * i + 2] = down[i];\\n            }\\n        }\\n        return sol;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minIncrements(int n, vector<int>& cost) {\\n        int len = cost.size();\\n        for (int i = 0; i < len; i++) {\\n            if (2 * i + 1 < len) {\\n                cost[2 * i + 1] += cost[i];\\n            }\\n            if (2 * i + 2 < len) {\\n                cost[2 * i + 2] += cost[i];\\n            }\\n        }\\n        int mxValue = *max_element(cost.begin(), cost.end());\\n        vector<int> mx(len);\\n        for (int i = len - 1; i > len / 2 - 1; i--) {\\n            mx[i] = cost[i];\\n        }\\n        for (int i = len / 2 - 1; i >= 0; i--) {\\n           mx[i] = max(mx[2 * i + 1], mx[2 * i + 2]);\\n        }\\n        vector<int> down(len);\\n        int sol = 0;\\n        for (int i = 0; i < n; i++) {\\n            int curValue = mx[i] + down[i];\\n            if (curValue < mxValue) {\\n                int diff = mxValue - curValue;\\n                sol += diff;\\n                down[i] += diff;\\n            }\\n            if (2  * i + 1 < len) {\\n                down[2 * i + 1] = down[i];\\n            }\\n            if (2 * i + 2 < len) {\\n                down[2 * i + 2] = down[i];\\n            }\\n        }\\n        return sol;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3511031,
                "title": "lazy-propagation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThis is a complete binary tree, which means every node will have two children, and you can just iterate them from buttom to first. And the data is relatively small, we can propagate the largest value to it\\'s parent node by dividing current index by 2.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nLinear iteration. I have no idea why I did not come up with this in contest. This problem wastes me an hour.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$ we will only iterate the array once\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(1)$$ no extra space required\\n\\n# Code\\n```\\nclass Solution:\\n    def minIncrements(self, n: int, cost: List[int]) -> int:\\n        # strategy a, balance each layer\\n        totalcost=0\\n        for i in range(n-1,0,-2):\\n            print(\\'cost of balancing node {} is {}\\'.format(i, max(cost[i],cost[i-1])-min(cost[i],cost[i-1])))\\n            totalcost+=max(cost[i],cost[i-1])-min(cost[i],cost[i-1])\\n            cost[i//2-1]+=max(cost[i],cost[i-1])\\n        return totalcost\\n\\n```\\n\\n\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minIncrements(self, n: int, cost: List[int]) -> int:\\n        # strategy a, balance each layer\\n        totalcost=0\\n        for i in range(n-1,0,-2):\\n            print(\\'cost of balancing node {} is {}\\'.format(i, max(cost[i],cost[i-1])-min(cost[i],cost[i-1])))\\n            totalcost+=max(cost[i],cost[i-1])-min(cost[i],cost[i-1])\\n            cost[i//2-1]+=max(cost[i],cost[i-1])\\n        return totalcost\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3510867,
                "title": "simple-o-n-solution-c",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minIncrements(int n, vector<int>& cost) {\\n        int ans = 0;\\n        for(int i = n/2-1; i >= 0; i--){\\n            int left = 2*i + 1;\\n            int right = 2*i + 2;\\n            ans += abs(cost[left] - cost[right]);\\n            cost[i] += max(cost[left], cost[right]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minIncrements(int n, vector<int>& cost) {\\n        int ans = 0;\\n        for(int i = n/2-1; i >= 0; i--){\\n            int left = 2*i + 1;\\n            int right = 2*i + 2;\\n            ans += abs(cost[left] - cost[right]);\\n            cost[i] += max(cost[left], cost[right]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3509622,
                "title": "c-basic-dfs-postorder-one-pass-fast",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSince we could only increment, we should not modify the largest path.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWith the post-order traversal approach, it becomes easy to find the sum path of the left and right subtrees. Based on this idea, we can try to equalize the cost of the left and right subtrees. To achieve this, we can calculate the absolute difference between the costs of the left and right subtrees using the expression ***abs(left - right)***. This value represents the minimum number of operations required to balance the two subtrees. Then return ***current cost + max(left, right)*** since we have balance the two sub-tree.\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nTraversed all the nodes once\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nStack of recursive\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int res = 0;\\n    int minIncrements(int n, vector<int>& cost) {\\n        DFS(1,cost);\\n        return res;\\n    }\\n\\n\\n    int DFS(int node, vector<int>& cost){\\n        //basecase\\n        int n = cost.size();\\n        if(node>n){\\n            return 0;\\n        }\\n        \\n        int currCost = cost[node-1];\\n\\n        int left = DFS(node*2, cost);\\n        int right = DFS(node*2+1, cost);\\n\\n        res+= abs(left-right);\\n\\n        return currCost + max(left, right);\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int res = 0;\\n    int minIncrements(int n, vector<int>& cost) {\\n        DFS(1,cost);\\n        return res;\\n    }\\n\\n\\n    int DFS(int node, vector<int>& cost){\\n        //basecase\\n        int n = cost.size();\\n        if(node>n){\\n            return 0;\\n        }\\n        \\n        int currCost = cost[node-1];\\n\\n        int left = DFS(node*2, cost);\\n        int right = DFS(node*2+1, cost);\\n\\n        res+= abs(left-right);\\n\\n        return currCost + max(left, right);\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3509051,
                "title": "c-dfs-beat-99",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minIncrements(int n, vector<int>& cost) {\\n        int minIncrement = 0;\\n        maxPath(1, n, cost, minIncrement);\\n        return minIncrement;\\n    }\\n\\n    int maxPath(int i, int n, const vector<int>& cost, int& minIncrement){\\n        if(i>n) return 0;\\n        int l = maxPath(i*2, n, cost, minIncrement), r = maxPath(i*2+1, n, cost, minIncrement);\\n        minIncrement += max(l, r) - min(l, r);\\n        return max(l, r) + cost[i-1];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minIncrements(int n, vector<int>& cost) {\\n        int minIncrement = 0;\\n        maxPath(1, n, cost, minIncrement);\\n        return minIncrement;\\n    }\\n\\n    int maxPath(int i, int n, const vector<int>& cost, int& minIncrement){\\n        if(i>n) return 0;\\n        int l = maxPath(i*2, n, cost, minIncrement), r = maxPath(i*2+1, n, cost, minIncrement);\\n        minIncrement += max(l, r) - min(l, r);\\n        return max(l, r) + cost[i-1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3508709,
                "title": "easy-c-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int fn(vector<int> &cost,int i,int &ct)\\n    {\\n        if(i-1<cost.size())\\n        {\\n            int a = fn(cost,2*i,ct);\\n            int b = fn(cost,2*i+1,ct);\\n            ct+=max(a,b) - min(a,b);\\n            return max(a,b)+cost[i-1];\\n        }\\n        else return 0;\\n    }\\n    int minIncrements(int n, vector<int>& cost) {\\n        int i  =1;\\n        int ct = 0;\\n         fn(cost,i,ct);\\n         return ct;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int fn(vector<int> &cost,int i,int &ct)\\n    {\\n        if(i-1<cost.size())\\n        {\\n            int a = fn(cost,2*i,ct);\\n            int b = fn(cost,2*i+1,ct);\\n            ct+=max(a,b) - min(a,b);\\n            return max(a,b)+cost[i-1];\\n        }\\n        else return 0;\\n    }\\n    int minIncrements(int n, vector<int>& cost) {\\n        int i  =1;\\n        int ct = 0;\\n         fn(cost,i,ct);\\n         return ct;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3508689,
                "title": "accepted-swift",
                "content": "```\\nclass Solution {\\n    func minIncrements(_ n: Int, _ cost: [Int]) -> Int {\\n        \\n        var cost = cost\\n        var len = 0\\n        var res = 0\\n\\n        func find(_ m: Int = 1, _ c: Int = 0) {\\n            let leaf = 2 * m > n\\n            let nc = c + cost[m - 1]\\n\\n            if leaf {\\n                len = max(len, nc)\\n            }\\n            else {\\n                find(m * 2, nc)\\n                find(m * 2 + 1, nc)\\n            }\\n        }\\n\\n        func adjust(_ m: Int = 1, _ c: Int = 0) -> [Int] {\\n            let leaf = 2 * m > n\\n            let nc = c + cost[m - 1]\\n\\n            if leaf {\\n                return [nc, nc]\\n            }\\n            else {\\n                let r1 = adjust(m * 2, nc)\\n                let r2 = adjust(m * 2 + 1, nc)\\n                let r = [min(r1[0], r2[0]), max(r1[1], r2[1])]\\n                res += r[1] - r[0]\\n                return [r[1], r[1]]\\n            }\\n        }\\n\\n        find()\\n        adjust()\\n\\n        return res\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func minIncrements(_ n: Int, _ cost: [Int]) -> Int {\\n        \\n        var cost = cost\\n        var len = 0\\n        var res = 0\\n\\n        func find(_ m: Int = 1, _ c: Int = 0) {\\n            let leaf = 2 * m > n\\n            let nc = c + cost[m - 1]\\n\\n            if leaf {\\n                len = max(len, nc)\\n            }\\n            else {\\n                find(m * 2, nc)\\n                find(m * 2 + 1, nc)\\n            }\\n        }\\n\\n        func adjust(_ m: Int = 1, _ c: Int = 0) -> [Int] {\\n            let leaf = 2 * m > n\\n            let nc = c + cost[m - 1]\\n\\n            if leaf {\\n                return [nc, nc]\\n            }\\n            else {\\n                let r1 = adjust(m * 2, nc)\\n                let r2 = adjust(m * 2 + 1, nc)\\n                let r = [min(r1[0], r2[0]), max(r1[1], r2[1])]\\n                res += r[1] - r[0]\\n                return [r[1], r[1]]\\n            }\\n        }\\n\\n        find()\\n        adjust()\\n\\n        return res\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3507600,
                "title": "python-2-approaches-post-order-traversal-iterate-over-parents",
                "content": "From description (and not only): you can traverse backward parents from `(N // 2 - 1) .. 0`.\\nThis way you have access to `left` and `right` children\\'s values.\\nAll you have to do in the problem is to find numbers of increases to align `parent.left_child_sum + parent.val` and `parent.right_child_sum + parent.val`\\n\\nE.g.\\n```\\n  1\\n / \\\\\\n2   3\\n```\\n`parent = 1`\\nin order to get the same paths sum you need to align parent\\'s left and right sums.\\nIn this case the path `1 - 2` should become `1 - 3` and `1 - 3` wlll not be changes as there is no way to decrease numbers. Thus the only way is to align right to left child.\\nSo we end up with `max(left, right) - min(left, right)` which is the same as `abs(left - right)` - number of increases needed to align `left` and `right` children to the same path sum .\\n`parent.val + abs(min - max)` is the path sum from the parent to a leaf.\\nReturn the new `sum` to the next `parent` and repeat.\\n\\n**Post-order traversal**\\n```\\nclass Solution:\\n    def minIncrements(self, N: int, cost: List[int]) -> int:\\n        def dfs(pos):\\n            nonlocal count\\n            if pos >= N:\\n                return 0\\n            left_sum = dfs(2 * pos + 1)\\n            right_sum = dfs(2 * pos + 2)\\n            \\n            count += abs(left_sum - right_sum)\\n            return cost[pos] + max(left_sum, right_sum)\\n        \\n        count = 0        \\n        dfs(0)\\n        return count\\n```\\n\\nIterate backward over parents as we know the parents location:\\n`left_child = parent * 2 + 1`\\n`right_child = parent * 2 + 2`\\n`parent =  left/right_child // 2`\\n```\\nclass Solution:\\n    def minIncrements(self, N: int, cost: List[int]) -> int:\\n        count = 0\\n        for i in reversed(range(N // 2)):\\n            count += abs(cost[2 * i + 1] - cost[2 * i + 2])\\n            cost[i] += max(cost[2 * i + 1], cost[2 * i + 2])\\n        return count\\n```\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\n  1\\n / \\\\\\n2   3\\n```\n```\\nclass Solution:\\n    def minIncrements(self, N: int, cost: List[int]) -> int:\\n        def dfs(pos):\\n            nonlocal count\\n            if pos >= N:\\n                return 0\\n            left_sum = dfs(2 * pos + 1)\\n            right_sum = dfs(2 * pos + 2)\\n            \\n            count += abs(left_sum - right_sum)\\n            return cost[pos] + max(left_sum, right_sum)\\n        \\n        count = 0        \\n        dfs(0)\\n        return count\\n```\n```\\nclass Solution:\\n    def minIncrements(self, N: int, cost: List[int]) -> int:\\n        count = 0\\n        for i in reversed(range(N // 2)):\\n            count += abs(cost[2 * i + 1] - cost[2 * i + 2])\\n            cost[i] += max(cost[2 * i + 1], cost[2 * i + 2])\\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3506797,
                "title": "python-bfs",
                "content": "# Intuition\\nWe need to determine the maximum path to the leaf. \\nOnce we find the maximum, we can calculate the sum of the maximum values of the child nodes from the leaf to the root. \\n\\nNext, starting from the root again, we compare the value with the maximum. Why? Because modifying from the root allows us to minimize the cost. \\nFor example, if both children should add two (2*2), performing the modification on the parent node only costs 2.\\n\\nIf the value is equal to the maximum, it means we cannot modify this node. One of its child paths has already reached the maximum. In this case, we need to explore its children to see if any nodes should be modified. \\n\\nIf the value is less than the maximum, we can add it to the value (maximum leaf value minus the current value). After making this addition, it is crucial to record the add-on value for the child. The child\\'s value should be updated by adding the addon value to its sum.\\n\\n\\n# Approach\\nTo avoid dealing with the index offset and cost, I introduce a dummy value to the cost array.\\n(This dummy value helps to shift the index correctly when calculating the right node: 0 * 2 won\\'t be the correct index, so we push a value to shift it.)\\n\\nUtilizing the properties of a perfect binary tree,\\n2 * i represents the left node\\n2 * i + 1 represents the right node\\n\\nStep 1:\\nWe start by summing the values from the root, eventually obtaining the maximum leaf sum.\\n\\nStep 2:\\nNext, we traverse from the leaf to the node, choosing the maximum sum between the left and right nodes, and updating their parent accordingly.\\n\\nStep 3:\\nAfter completing the above steps, we perform a breadth-first search (BFS) traversal starting from the root.\\nWe calculate the value to be added by subtracting the node value from the maximum leaf value (e.g., if the maximum path value is 9 and we encounter a node value of 8, we modify it to 9 by calculating the difference: 9 - 8 = 1).\\nFollowing this modification, we propagate the difference (1) to its child nodes. All child paths should have the difference added to their parent value.\\nFinally, we re-evaluate the value of the node.\\n\\n```\\n  origin\\n    1\\n  3    4      \\n 4 1  4 3\\n\\nstep1:  perform sum from root to leaf\\n    1\\n  4    5       \\n 8 5  9 8\\n\\nstep2: update max sum max(left val, right val) from leaf to root\\n    9\\n  8    9       \\n 8 5  9 8\\n\\nstep3: traverse from root to leaft, modify each value\\n                    9\\n       8 to 9                  9\\n  carry=9-8=1              carry=9-9=0\\n8+1(9)       5+1=6          9      8+0 = 8\\nadd carry  after add carry         still need 1\\n           still need 9-6=3\\n\\nso the anwser would be \\n8 to 9  = 1\\n6 to 9  = 3\\n8 to 9  = 1\\n1+3+1 = 5\\n```\\n\\n# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\nO(N)\\n\\n# Code\\n```\\nclass Solution:\\n    def minIncrements(self, n: int, cost: List[int]) -> int:\\n        cost = [0]+cost\\n        maxLeaf = 0\\n        for i in range(1, len(cost)//2):\\n            cost[i*2]+=cost[i]\\n            cost[i*2+1]+=cost[i]\\n            maxLeaf = max(maxLeaf, cost[i*2], cost[i*2+1])\\n        for i in range(len(cost)-1, 1, -1):\\n            cost[i//2] = max(cost[i//2], cost[i])\\n        ans = 0\\n        q = deque([[1,0]])\\n        while q:\\n            idx, carry = q.popleft()\\n            diff = maxLeaf-cost[idx]-carry\\n            if diff>0:\\n                ans+=diff\\n                carry+=diff\\n            if 2*idx+1<len(cost):\\n                q.append([2*idx, carry])\\n                q.append([2*idx+1, carry])\\n            \\n        return ans\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n  origin\\n    1\\n  3    4      \\n 4 1  4 3\\n\\nstep1:  perform sum from root to leaf\\n    1\\n  4    5       \\n 8 5  9 8\\n\\nstep2: update max sum max(left val, right val) from leaf to root\\n    9\\n  8    9       \\n 8 5  9 8\\n\\nstep3: traverse from root to leaft, modify each value\\n                    9\\n       8 to 9                  9\\n  carry=9-8=1              carry=9-9=0\\n8+1(9)       5+1=6          9      8+0 = 8\\nadd carry  after add carry         still need 1\\n           still need 9-6=3\\n\\nso the anwser would be \\n8 to 9  = 1\\n6 to 9  = 3\\n8 to 9  = 1\\n1+3+1 = 5\\n```\n```\\nclass Solution:\\n    def minIncrements(self, n: int, cost: List[int]) -> int:\\n        cost = [0]+cost\\n        maxLeaf = 0\\n        for i in range(1, len(cost)//2):\\n            cost[i*2]+=cost[i]\\n            cost[i*2+1]+=cost[i]\\n            maxLeaf = max(maxLeaf, cost[i*2], cost[i*2+1])\\n        for i in range(len(cost)-1, 1, -1):\\n            cost[i//2] = max(cost[i//2], cost[i])\\n        ans = 0\\n        q = deque([[1,0]])\\n        while q:\\n            idx, carry = q.popleft()\\n            diff = maxLeaf-cost[idx]-carry\\n            if diff>0:\\n                ans+=diff\\n                carry+=diff\\n            if 2*idx+1<len(cost):\\n                q.append([2*idx, carry])\\n                q.append([2*idx+1, carry])\\n            \\n        return ans\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3506549,
                "title": "c-postorder-traversal",
                "content": "\\n```\\nclass Solution \\n{\\n    int ans = 0;\\npublic:\\n    int minIncrements(int n, vector<int>& cost) \\n    {\\n        dfs(n, 1, cost);\\n\\n        return ans;\\n    }\\n\\n    int dfs(int n, int i, const vector<int>& cost)\\n    {\\n        if (i > n)\\n        {\\n            return 0;\\n        }\\n\\n        int lsum = dfs(n, 2 * i, cost);\\n        int rsum = dfs(n, 2 * i + 1, cost);\\n\\n        ans += abs(lsum - rsum);\\n\\n        return max(lsum, rsum) + cost[i - 1];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution \\n{\\n    int ans = 0;\\npublic:\\n    int minIncrements(int n, vector<int>& cost) \\n    {\\n        dfs(n, 1, cost);\\n\\n        return ans;\\n    }\\n\\n    int dfs(int n, int i, const vector<int>& cost)\\n    {\\n        if (i > n)\\n        {\\n            return 0;\\n        }\\n\\n        int lsum = dfs(n, 2 * i, cost);\\n        int rsum = dfs(n, 2 * i + 1, cost);\\n\\n        ans += abs(lsum - rsum);\\n\\n        return max(lsum, rsum) + cost[i - 1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3505321,
                "title": "easy-simple-dfs-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n- At each node I will calculate the difference between left and right\\n- add that difference in my answer and pass the max(left,right)+root\\n- as both left and right is equal form that node after perfoming the increment operation form that node to its child node.\\n- recurively this will be computed for all the nodes from bottom to top\\n- and ultimately I will return the answer.\\n- Look at Code.\\n# Complexity\\n- Time complexity:\\n    - $$O(N)$$\\n\\n- Space complexity:\\n    - $$O(Log(N))$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int ans=0;\\n    int minIncrements(int n, vector<int>& cost) \\n    {\\n        f(cost,1,n);\\n        return ans;\\n    }\\n    int f(vector<int>&cost,int i,int n)\\n    {\\n        if (i>n)\\n        {\\n            return 0;\\n        }\\n        int priceLeft=f(cost,2*i,n);\\n        int priceRight=f(cost,2*i+1,n);\\n        ans+=abs(priceLeft-priceRight);\\n        return max(priceLeft,priceRight)+cost[i-1];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Greedy",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int ans=0;\\n    int minIncrements(int n, vector<int>& cost) \\n    {\\n        f(cost,1,n);\\n        return ans;\\n    }\\n    int f(vector<int>&cost,int i,int n)\\n    {\\n        if (i>n)\\n        {\\n            return 0;\\n        }\\n        int priceLeft=f(cost,2*i,n);\\n        int priceRight=f(cost,2*i+1,n);\\n        ans+=abs(priceLeft-priceRight);\\n        return max(priceLeft,priceRight)+cost[i-1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3505299,
                "title": "java-dfs-o-n-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nUpdate the subtree to larger one, return the maxPath value\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(lgn)\\n\\n# Code\\n```\\nclass Solution {\\n    int res = 0;\\n    public int minIncrements(int n, int[] cost) {\\n        dfs(0, cost);\\n        return res;\\n    }\\n    \\n    public int dfs(int current, int[] cost){\\n        if(current >= cost.length) return 0;\\n        int left = dfs(2 * current + 1, cost);\\n        int right = dfs(2 * current + 2, cost);\\n        res += Math.abs(left - right);\\n        return Math.max(left, right) + cost[current];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    int res = 0;\\n    public int minIncrements(int n, int[] cost) {\\n        dfs(0, cost);\\n        return res;\\n    }\\n    \\n    public int dfs(int current, int[] cost){\\n        if(current >= cost.length) return 0;\\n        int left = dfs(2 * current + 1, cost);\\n        int right = dfs(2 * current + 2, cost);\\n        res += Math.abs(left - right);\\n        return Math.max(left, right) + cost[current];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3504740,
                "title": "easy-dfs-and-greedy-approach",
                "content": "# Intuition\\n<we try increment the element which are top on tree>\\n\\n# Approach\\n<find max path from that element to leaf element and add path length from 1 to that element, if it is smaller than max possible path length from 1 to leaf then increment that by that number so that it get equal to the max path length from 1 to leaf >\\n\\n# Complexity\\n- Time complexity:\\n<O(n)>\\n\\n- Space complexity:\\n<O(n)>\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int m;\\n    vector<long long>dp;\\n    int ans;\\n    long long  dfs1(int i,vector<int>&cost)\\n    {\\n        if(i>m)return 0;\\n        dp[i-1]=max(dfs1(2*i,cost),dfs1(2*i+1,cost));\\n        return dp[i-1]+cost[i-1];\\n    }\\n    \\n    void dfs(int x,long long  prev,vector<int>&cost,int i)\\n    {\\n        if(i>m)return ;\\n        long long  total=cost[i-1]+dp[i-1]+prev;\\n        long long  incre=x-total;\\n        ans+=(int)incre;\\n        cost[i-1]+=(int)incre;\\n        dfs(x,prev+cost[i-1],cost,2*i);\\n         dfs(x,prev+cost[i-1],cost,2*i+1);\\n        return ;\\n    }\\n        \\n    int minIncrements(int n, vector<int>& cost) {\\n        m=n;\\n        dp.clear();\\n        dp=vector<long long>(n+1);\\n        vector<int>prevcost=cost;\\n        ans=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            dp[i]=(long long)cost[i];\\n        }\\n        int x=(int)dfs1(1,cost);\\n        \\n         dfs(x,0,cost,1);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int m;\\n    vector<long long>dp;\\n    int ans;\\n    long long  dfs1(int i,vector<int>&cost)\\n    {\\n        if(i>m)return 0;\\n        dp[i-1]=max(dfs1(2*i,cost),dfs1(2*i+1,cost));\\n        return dp[i-1]+cost[i-1];\\n    }\\n    \\n    void dfs(int x,long long  prev,vector<int>&cost,int i)\\n    {\\n        if(i>m)return ;\\n        long long  total=cost[i-1]+dp[i-1]+prev;\\n        long long  incre=x-total;\\n        ans+=(int)incre;\\n        cost[i-1]+=(int)incre;\\n        dfs(x,prev+cost[i-1],cost,2*i);\\n         dfs(x,prev+cost[i-1],cost,2*i+1);\\n        return ;\\n    }\\n        \\n    int minIncrements(int n, vector<int>& cost) {\\n        m=n;\\n        dp.clear();\\n        dp=vector<long long>(n+1);\\n        vector<int>prevcost=cost;\\n        ans=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            dp[i]=(long long)cost[i];\\n        }\\n        int x=(int)dfs1(1,cost);\\n        \\n         dfs(x,0,cost,1);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3504494,
                "title": "shortest-logical-solution",
                "content": "\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```\\nclass Solution:\\n    def minIncrements(self, n: int, cost: List[int]) -> int:\\n        \\n        total = 0\\n        \\n        for i in range(n-1,0,-2):\\n            \\n            k = max(cost[i], cost[i-1])\\n            total += k - min(cost[i], cost[i-1])\\n            cost[(i-2) // 2] += k\\n        \\n        return total\\n        \\n```",
                "solutionTags": [
                    "Python3",
                    "Math"
                ],
                "code": "```\\nclass Solution:\\n    def minIncrements(self, n: int, cost: List[int]) -> int:\\n        \\n        total = 0\\n        \\n        for i in range(n-1,0,-2):\\n            \\n            k = max(cost[i], cost[i-1])\\n            total += k - min(cost[i], cost[i-1])\\n            cost[(i-2) // 2] += k\\n        \\n        return total\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3504332,
                "title": "most-intutive-in-terms-of-arrays-indexing-in-terms-of-trees",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe have to make all the level of tree same cost ,so to maintain same cost I used recursion\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\nlog N (as it was a balanced Tree)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nLogN \\n\\n# Code\\n```\\nclass Solution {\\n  int ans=0;\\n\\n    public int minIncrements(int n, int[] cost) {\\n\\n        calculate(0,cost,n);\\n        return ans;\\n    }\\n\\n    int calculate(int i,int[] cost,int N)\\n    {\\n      if(i>N-1) \\n      {\\n        return 0;\\n      }\\n\\n      int left=calculate(2*i+1,cost,N); // left part index 2*i+1\\n      int right=calculate(2*i+2,cost,N);//right part index 2*i+2\\n\\n      ans=ans+Math.abs(left-right);\\n      return Math.max(left,right)+cost[i];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Tree"
                ],
                "code": "```\\nclass Solution {\\n  int ans=0;\\n\\n    public int minIncrements(int n, int[] cost) {\\n\\n        calculate(0,cost,n);\\n        return ans;\\n    }\\n\\n    int calculate(int i,int[] cost,int N)\\n    {\\n      if(i>N-1) \\n      {\\n        return 0;\\n      }\\n\\n      int left=calculate(2*i+1,cost,N); // left part index 2*i+1\\n      int right=calculate(2*i+2,cost,N);//right part index 2*i+2\\n\\n      ans=ans+Math.abs(left-right);\\n      return Math.max(left,right)+cost[i];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3504226,
                "title": "python-100-time-complexity-solution",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\n![binaryytreeedrawio-4.png](https://assets.leetcode.com/users/images/1f5888ef-05f7-42c2-bf18-1b401fd39059_1683623878.54071.png)\\n\\n0) **For every 2 nodes, bottom layer nodes value must be equal**.\\nIn example 1, that mean Node 4 = Node 5, Node 6 = Nodes 7. \\n(Need not to Node 4 = Node 5 = Node 6 = Node 7)\\n\\n1) Create the 0 array \"addition\" with the length of the bottom layer initially.\\n\\n2)  For every 2 nodes:\\n    a)  **Add the absolute difference to integer parameter \"output\"**.\\n    b)  **Append the maximum value to \"addition\"**.\\n\\n3)  After go through the bottom layer, Now:\\n    Node 4 = Node 5 = 3\\n    Node 6 = Node 7 = 3\\n\\n4)  In the second lowest layer, \\n    We compare Node 2 + (max(Node 4, Node 5)) & Node 3 + (max(Node 6, Node 7)), which have been marked at the \"addition\". \\n\\n5)  Repeat Step 2: Add the absolute difference and append the maximum.\\n\\n6)  Loop the process until reach the top of binary tree.\\n\\n7)  Need not to pop the value in the addition array. We can just **apply \"shift\" parameter to select the value we wanted**. The runtime will reduce from 2500ms to 1200ms.\\n\\n# Stdout (For Reference)\\n\\n(\\'addition_arr\\', [0, 0, 0, 0], \\'target_node_value\\', 1, 3, \\'output\\', 0, \\'checking_arr\\', [1, 3, 3, 2])\\n(\\'addition_arr\\', [0, 0, 0, 0, 3], \\'target_node_value\\', 3, 2, \\'output\\', 2, \\'checking_arr\\', [1, 3, 3, 2])\\n(\\'addition_arr\\', [0, 0, 0, 0, 3, 3], \\'target_node_value\\', 2, 5, \\'output\\', 3, \\'checking_arr\\', [2, 5])\\n\\n# Complexity\\n- Time complexity:\\nO(n2)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution(object):\\n    def minIncrements(self, n, cost):\\n        base = n + 1\\n        output = 0\\n        addition = [0] * (base/2)\\n        shift = 0\\n\\n        while base > 2:\\n            arr = cost[base-2:base/2-2:-1]\\n            for i in range(base/4):\\n                a = arr[i*2+1] + addition[shift+1]\\n                b = arr[i*2] + addition[shift+0]\\n                output += abs(a - b)\\n                addition.append(max(a, b))\\n                shift += 2\\n            base /= 2\\n\\n        return output\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def minIncrements(self, n, cost):\\n        base = n + 1\\n        output = 0\\n        addition = [0] * (base/2)\\n        shift = 0\\n\\n        while base > 2:\\n            arr = cost[base-2:base/2-2:-1]\\n            for i in range(base/4):\\n                a = arr[i*2+1] + addition[shift+1]\\n                b = arr[i*2] + addition[shift+0]\\n                output += abs(a - b)\\n                addition.append(max(a, b))\\n                shift += 2\\n            base /= 2\\n\\n        return output\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3503399,
                "title": "java-dfs-and-dp-combination-way",
                "content": "First of all, there must be a maximum cost path exist in the tree, then each other path should get the final addition equal to the max cost path. We get that max and record max path of every tree root node.\\n\\nHow do we get max cost of every root node? We iterate from the back n to 1, if the root node is a leaf, that max cost is the cost[i] itself, if the root node has children, max cost of the root node is Math.max(leftchild, rightchild) + cost[i].\\n\\nSecondly, If we want to get the minimum addition, we should add the most from the root node.\\n```\\npublic int minIncrements(int n, int[] cost) {\\n\\tint[] dp = new int[n+1];\\n\\t//first we record max cost path of each tree root node\\n\\tfor(int i=n; i>=1; i--){\\n\\t\\tif(2*i+1 <= n){\\n\\t\\t\\tdp[i] = Math.max(dp[i*2], dp[i*2+1]) + cost[i-1];\\n\\t\\t}else{\\n\\t\\t\\tdp[i] = cost[i-1];\\n\\t\\t}\\n\\t}\\n\\tint[] res = new int[1];\\n\\tint max = dp[1];\\n\\tdsf(1, max, n, cost, dp, res);\\n\\t\\n\\treturn res[0];\\n}\\nvoid dsf(int root, int max, int n, int[] cost, int[] dp, int[] res){\\n\\tif(root > n) return;\\n\\t\\n\\tint diff = max - dp[root];\\n\\tint newmax = 0;\\n\\tif(diff == 0){\\n\\t\\tnewmax = max - cost[root-1];\\n\\t}else{\\n\\t\\tnewmax = max - (diff + cost[root-1]);\\n\\t\\tres[0] += diff;\\n\\t}\\n\\t\\n\\tint left = root * 2;\\n\\tdsf(left, newmax, n, cost, dp, res);\\n\\tint right = root * 2 + 1;\\n\\tdsf(right, newmax, n, cost, dp, res);\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Depth-First Search"
                ],
                "code": "```\\npublic int minIncrements(int n, int[] cost) {\\n\\tint[] dp = new int[n+1];\\n\\t//first we record max cost path of each tree root node\\n\\tfor(int i=n; i>=1; i--){\\n\\t\\tif(2*i+1 <= n){\\n\\t\\t\\tdp[i] = Math.max(dp[i*2], dp[i*2+1]) + cost[i-1];\\n\\t\\t}else{\\n\\t\\t\\tdp[i] = cost[i-1];\\n\\t\\t}\\n\\t}\\n\\tint[] res = new int[1];\\n\\tint max = dp[1];\\n\\tdsf(1, max, n, cost, dp, res);\\n\\t\\n\\treturn res[0];\\n}\\nvoid dsf(int root, int max, int n, int[] cost, int[] dp, int[] res){\\n\\tif(root > n) return;\\n\\t\\n\\tint diff = max - dp[root];\\n\\tint newmax = 0;\\n\\tif(diff == 0){\\n\\t\\tnewmax = max - cost[root-1];\\n\\t}else{\\n\\t\\tnewmax = max - (diff + cost[root-1]);\\n\\t\\tres[0] += diff;\\n\\t}\\n\\t\\n\\tint left = root * 2;\\n\\tdsf(left, newmax, n, cost, dp, res);\\n\\tint right = root * 2 + 1;\\n\\tdsf(right, newmax, n, cost, dp, res);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3503255,
                "title": "simple-java-solution",
                "content": "# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    int ans=0;\\n    public int minIncrements(int n, int[] cost) {\\n        Dfs(1,n,cost);\\n        return ans;\\n    }\\n    private int Dfs(int node,int n,int[] cost){\\n        if(node>n) return 0;\\n        int left=Dfs(node*2,n,cost);\\n        int right=Dfs(node*2+1,n,cost);\\n        ans+=Math.abs(left-right);\\n        return Math.max(left,right)+cost[node-1];\\n    }\\n}//upvote if helpful...\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    int ans=0;\\n    public int minIncrements(int n, int[] cost) {\\n        Dfs(1,n,cost);\\n        return ans;\\n    }\\n    private int Dfs(int node,int n,int[] cost){\\n        if(node>n) return 0;\\n        int left=Dfs(node*2,n,cost);\\n        int right=Dfs(node*2+1,n,cost);\\n        ans+=Math.abs(left-right);\\n        return Math.max(left,right)+cost[node-1];\\n    }\\n}//upvote if helpful...\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3503023,
                "title": "very-simple-solution-c-dfs-very-well-commented",
                "content": "![image](https://assets.leetcode.com/users/images/df55920d-5f03-423d-9292-2e023319f514_1683603201.4346242.png)\\n\\n\\n```\\nclass Solution {\\npublic:\\n    int incrementsNeeded;\\n    int dfs(int root, vector<int>&cost, int n){\\n        if(root > n) return 0;\\n        int left_sum = dfs(root*2,cost,n);\\n        int right_sum = dfs(root*2+1,cost,n);\\n        // now we can only increment , so the lesser of the above two sums, will be incremented to the greater of above two sums\\n        incrementsNeeded += abs(left_sum - right_sum);\\n        \\n        // Now in example 1 of this question, we would be incrementing node 3(val = 2) , \\n        // because both of its child nodes are having value 3,\\n        // here now, left_sum = 5 + max(2,3) = 8, right_sum = 2 + max(1,3) = 5 || incrementsNeeded are 3, as (abs(8-5) = 3), increment, 2 to         //5\\n        return cost[root-1] + max(left_sum,right_sum);\\n        \\n    }\\n    int minIncrements(int n, vector<int>& cost) {\\n        incrementsNeeded = 0;\\n        int w = dfs(1,cost,n);\\n        return incrementsNeeded;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int incrementsNeeded;\\n    int dfs(int root, vector<int>&cost, int n){\\n        if(root > n) return 0;\\n        int left_sum = dfs(root*2,cost,n);\\n        int right_sum = dfs(root*2+1,cost,n);\\n        // now we can only increment , so the lesser of the above two sums, will be incremented to the greater of above two sums\\n        incrementsNeeded += abs(left_sum - right_sum);\\n        \\n        // Now in example 1 of this question, we would be incrementing node 3(val = 2) , \\n        // because both of its child nodes are having value 3,\\n        // here now, left_sum = 5 + max(2,3) = 8, right_sum = 2 + max(1,3) = 5 || incrementsNeeded are 3, as (abs(8-5) = 3), increment, 2 to         //5\\n        return cost[root-1] + max(left_sum,right_sum);\\n        \\n    }\\n    int minIncrements(int n, vector<int>& cost) {\\n        incrementsNeeded = 0;\\n        int w = dfs(1,cost,n);\\n        return incrementsNeeded;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3502556,
                "title": "java-different-approach-dfs-binary-search",
                "content": "```\\nclass Solution {\\n    \\n    \\n    int max [] ;\\n    \\n    public int minIncrements(int n, int[] cost) {\\n    \\n        max = new int[n];\\n        \\n        dfs(0,n,cost);\\n        \\n        int low  = 1; int high = 1000000;\\n        \\n        \\n        int ans = 0;\\n        \\n        while(low<=high){\\n            \\n            \\n            int mid = ( low +  high )/2;\\n            \\n            int res = dfs2(0,mid,cost);\\n            \\n            if( res == -1) {\\n                \\n                low  = mid + 1;\\n            }\\n            else {\\n                \\n                \\n                ans = res;\\n                \\n                high = mid - 1;\\n            }\\n            \\n            \\n        }\\n        \\n        return ans;\\n        \\n    }\\n    \\n    int dfs( int node , int n , int cost[]){\\n        \\n        if( node >= n ) return 0;\\n        \\n        int left = dfs(2*node+1,n,cost);\\n        \\n        int right = dfs(2*node+2,n,cost);\\n        \\n        max[node] = Math.max(left,right) + cost[node];\\n        \\n        return Math.max(left,right) + cost[node];\\n        \\n    }\\n    \\n    \\n    int dfs2(int node , int value,int cost[]){\\n        \\n        if( node >= cost.length ) return 0;\\n        \\n         int temp = value - max[node];\\n        \\n          if( temp < 0 )  return -1;\\n        \\n          int left = dfs2(2*node+1,value - cost[node] - temp , cost);\\n            \\n            if( left == -1 ) return -1;\\n        \\n          int right  =dfs2(2*node+2,value-cost[node]-temp,cost);\\n          \\n        if(right == -1) return -1;\\n        \\n        return left + right + temp;\\n    }\\n    \\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    \\n    \\n    int max [] ;\\n    \\n    public int minIncrements(int n, int[] cost) {\\n    \\n        max = new int[n];\\n        \\n        dfs(0,n,cost);\\n        \\n        int low  = 1; int high = 1000000;\\n        \\n        \\n        int ans = 0;\\n        \\n        while(low<=high){\\n            \\n            \\n            int mid = ( low +  high )/2;\\n            \\n            int res = dfs2(0,mid,cost);\\n            \\n            if( res == -1) {\\n                \\n                low  = mid + 1;\\n            }\\n            else {\\n                \\n                \\n                ans = res;\\n                \\n                high = mid - 1;\\n            }\\n            \\n            \\n        }\\n        \\n        return ans;\\n        \\n    }\\n    \\n    int dfs( int node , int n , int cost[]){\\n        \\n        if( node >= n ) return 0;\\n        \\n        int left = dfs(2*node+1,n,cost);\\n        \\n        int right = dfs(2*node+2,n,cost);\\n        \\n        max[node] = Math.max(left,right) + cost[node];\\n        \\n        return Math.max(left,right) + cost[node];\\n        \\n    }\\n    \\n    \\n    int dfs2(int node , int value,int cost[]){\\n        \\n        if( node >= cost.length ) return 0;\\n        \\n         int temp = value - max[node];\\n        \\n          if( temp < 0 )  return -1;\\n        \\n          int left = dfs2(2*node+1,value - cost[node] - temp , cost);\\n            \\n            if( left == -1 ) return -1;\\n        \\n          int right  =dfs2(2*node+2,value-cost[node]-temp,cost);\\n          \\n        if(right == -1) return -1;\\n        \\n        return left + right + temp;\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3502350,
                "title": "c-java-dfs-solution",
                "content": "## Explanation\\nConsider a perfect binary tree with 3 nodes.\\n\\n                           1\\n                          / \\\\\\n                         2   3\\n\\nHere, to make both the root to leaf paths equal, we add `1 (3 - 2)` to `2`. So we perform 1 operation and the path cost becomes `4 (1 + 3)`.\\n\\nIf this is a subtree of a perfect binary tree, then we would increment `result` by 1 and return the path cost `4` to the calling function. \\n\\n                              1\\n                            /   \\\\\\n                           5     2\\n                          / \\\\   / \\\\\\n                         2   3 3   1\\n\\nHere, the node `5` in the left subtree of root node `1` would get the path cost from left subtree and right subtree as `2` and `3` respectively. Hence after the result being incremented by `1`, `8` would be returned to the root node as its left subtree\\'s path costs.\\n\\nIn the same way as mentioned above, the root node would get the right subtree\\'s path cost as `5` with result being updated to `3`. Then, the difference `3 (8 - 5)` would be added to the node `2`, to make both path costs equal and `9` would be returned to the main calling function.\\n\\nThis approach can be implemented by both DFS and BFS.\\n \\n\\n## Code\\n\\n```C++ []\\nclass Solution {\\npublic:\\n    \\n    int res = 0, n;\\n    \\n    int dfs(int ind, vector<int> &cost){\\n        if(ind > size(cost)) return 0;\\n        int left = dfs(2 * ind, cost), right = dfs(2 * ind + 1, cost);\\n        res += abs(left - right);\\n        return cost[ind - 1] + max(left, right);\\n    }\\n    \\n    int minIncrements(int n, vector<int>& cost) {\\n        dfs(1, cost);\\n        return res;\\n    }\\n};\\n```\\n```Java []\\nimport java.util.List;\\n\\nclass Solution {\\n    int res = 0, n;\\n\\n    int dfs(int ind, int[] cost) {\\n        if (ind > cost.size()) return 0;\\n        int left = dfs(2 * ind, cost), right = dfs(2 * ind + 1, cost);\\n        res += Math.abs(left - right);\\n        return cost[ind - 1] + Math.max(left, right);\\n    }\\n\\n    public int minIncrements(int n, int[] cost) {\\n        dfs(1, cost);\\n        return res;\\n    }\\n}\\n\\n```\\n\\n# Complexity\\n- Time complexity:  $$O(n)$$ \\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:  $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Depth-First Search",
                    "Binary Tree"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    \\n    int res = 0, n;\\n    \\n    int dfs(int ind, vector<int> &cost){\\n        if(ind > size(cost)) return 0;\\n        int left = dfs(2 * ind, cost), right = dfs(2 * ind + 1, cost);\\n        res += abs(left - right);\\n        return cost[ind - 1] + max(left, right);\\n    }\\n    \\n    int minIncrements(int n, vector<int>& cost) {\\n        dfs(1, cost);\\n        return res;\\n    }\\n};\\n```\n```Java []\\nimport java.util.List;\\n\\nclass Solution {\\n    int res = 0, n;\\n\\n    int dfs(int ind, int[] cost) {\\n        if (ind > cost.size()) return 0;\\n        int left = dfs(2 * ind, cost), right = dfs(2 * ind + 1, cost);\\n        res += Math.abs(left - right);\\n        return cost[ind - 1] + Math.max(left, right);\\n    }\\n\\n    public int minIncrements(int n, int[] cost) {\\n        dfs(1, cost);\\n        return res;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3502341,
                "title": "swift-one-liner",
                "content": "**One-Liner, terse (accepted answer)**\\n```\\nclass Solution {\\n    func minIncrements(_ n: Int, _ cost: [Int]) -> Int {\\n        (0..<(n+1)/2-1).reversed().reduce(into: (0,cost)) {let l=$1*2+1;let c=$0.1[l...l+1].sorted();$0.0+=c[1]-c[0];$0.1[$1]+=c[1]}.0}\\n}\\n```\\n\\n---\\n\\n**One-Liner, expanded and annotated (accepted answer)**\\n```\\nclass Solution {\\n    func minIncrements(_ n: Int, _ cost: [Int]) -> Int {\\n        (0 ..< (n+1)/2-1)\\n\\t\\t\\t.reversed() // need to reverse order to equalize children before parent.\\n\\t\\t\\t.reduce(into: (\\n\\t\\t\\t\\t\\tresult: 0,\\n\\t\\t\\t\\t\\tarr: cost\\n\\t\\t\\t)) { data, i in \\n\\t\\t\\t\\tlet c = i*2+1\\n\\t\\t\\t\\tlet children = data.arr[c...c+1].sorted()\\n\\t\\t\\t\\tdata.result += children[1] - children[0]\\n\\t\\t\\t\\tdata.arr[i] += children[1]\\n\\t\\t\\t}\\n\\t\\t\\t.result\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func minIncrements(_ n: Int, _ cost: [Int]) -> Int {\\n        (0..<(n+1)/2-1).reversed().reduce(into: (0,cost)) {let l=$1*2+1;let c=$0.1[l...l+1].sorted();$0.0+=c[1]-c[0];$0.1[$1]+=c[1]}.0}\\n}\\n```\n```\\nclass Solution {\\n    func minIncrements(_ n: Int, _ cost: [Int]) -> Int {\\n        (0 ..< (n+1)/2-1)\\n\\t\\t\\t.reversed() // need to reverse order to equalize children before parent.\\n\\t\\t\\t.reduce(into: (\\n\\t\\t\\t\\t\\tresult: 0,\\n\\t\\t\\t\\t\\tarr: cost\\n\\t\\t\\t)) { data, i in \\n\\t\\t\\t\\tlet c = i*2+1\\n\\t\\t\\t\\tlet children = data.arr[c...c+1].sorted()\\n\\t\\t\\t\\tdata.result += children[1] - children[0]\\n\\t\\t\\t\\tdata.arr[i] += children[1]\\n\\t\\t\\t}\\n\\t\\t\\t.result\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3501775,
                "title": "c-iterative-bottom-up-and-recursive-dfs",
                "content": "# Code\\n```\\n// Iterative (Bottom Up)\\nclass Solution {\\npublic:\\n    int minIncrements(int n, vector<int>& cost) {\\n        int ans = 0;\\n        for(int i = n / 2 - 1; i >= 0; i--) {\\n            ans += abs(cost[2 * i + 1] - cost[2 * i + 2]);\\n            cost[i] += max(cost[2 * i + 1], cost[2 * i + 2]);\\n        }\\n        return ans;\\n    }\\n};\\n\\n\\n// Recursive (DFS)\\nclass Solution {\\n    int dfs(int i, int &ans, vector<int>& cost) {\\n        if(i >= cost.size()) return 0;\\n        int l = dfs(2 * i + 1, ans, cost);\\n        int r = dfs(2 * i + 2, ans, cost);\\n        ans += abs(l - r);\\n        return cost[i] + max(l, r);\\n    }\\npublic:\\n    int minIncrements(int n, vector<int>& cost) {\\n        int ans = 0;\\n        dfs(0, ans, cost);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n// Iterative (Bottom Up)\\nclass Solution {\\npublic:\\n    int minIncrements(int n, vector<int>& cost) {\\n        int ans = 0;\\n        for(int i = n / 2 - 1; i >= 0; i--) {\\n            ans += abs(cost[2 * i + 1] - cost[2 * i + 2]);\\n            cost[i] += max(cost[2 * i + 1], cost[2 * i + 2]);\\n        }\\n        return ans;\\n    }\\n};\\n\\n\\n// Recursive (DFS)\\nclass Solution {\\n    int dfs(int i, int &ans, vector<int>& cost) {\\n        if(i >= cost.size()) return 0;\\n        int l = dfs(2 * i + 1, ans, cost);\\n        int r = dfs(2 * i + 2, ans, cost);\\n        ans += abs(l - r);\\n        return cost[i] + max(l, r);\\n    }\\npublic:\\n    int minIncrements(int n, vector<int>& cost) {\\n        int ans = 0;\\n        dfs(0, ans, cost);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3500126,
                "title": "python3-walk-from-leaf-to-root",
                "content": "# Intuition\\nAny path sum from root to a leaf will involve all the nodes who are ancestors of that leaf. The max cost path will be the path with maximum sum to a leaf. Now, the difference of two path\\'sum will be because of node\\'s cost along those paths.\\nWe start from leaf and look towards  their parent, at this point from that parent\\'s perspective the child with minimum cost need to be incremented to have same cost path value to each child. Since we have incremented one of two child\\'s cost , the total cost for this parent will increase. so we will increment the parent\\'s cost.  Now this parent will look towards it\\'s parent and calculate the current path value with this new parent. Keep doing this untill we reach to the root. Keep running sum of all values incremented for a low cost child along the path. This value will be the final answer.\\n\\n\\n\\n# Code\\n```\\nclass Solution:\\n    def minIncrements(self, n: int, cost: List[int]) -> int:\\n        # Start form  leave\\n        child = n\\n        diff = 0\\n        while child != 1 :\\n            parent = (child -1)//2\\n            other_child = 2 * parent\\n            diff += abs(cost[child-1] - cost[other_child-1])\\n            cost[parent-1] += max(cost[child-1],cost[other_child-1])\\n            child = other_child - 1\\n     \\n        return diff\\n        \\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minIncrements(self, n: int, cost: List[int]) -> int:\\n        # Start form  leave\\n        child = n\\n        diff = 0\\n        while child != 1 :\\n            parent = (child -1)//2\\n            other_child = 2 * parent\\n            diff += abs(cost[child-1] - cost[other_child-1])\\n            cost[parent-1] += max(cost[child-1],cost[other_child-1])\\n            child = other_child - 1\\n     \\n        return diff\\n        \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3499592,
                "title": "tc-o-n-c-sc-o-1-bottom-up",
                "content": "# Approach\\nTraverse the cost array in reverse direction (i.e. traverse the tree in a bottom up manner) from the last non-leaf node(that\\'s why : s/2 -1). Calculate the absolute difference of both the children of the current node and add it to the res, and also add the max(left child cost, right child cost) to the current node cost.\\n\\n# Complexity\\n- Time complexity: O(n)\\n\\n- Space complexity: O(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minIncrements(int n, vector<int>& cost) {\\n        int res = 0;\\n        int s = cost.size();\\n        for(int i = s/2 - 1; i >= 0; i--){\\n            int l = 2 * i + 1;\\n            int r = 2 * i + 2;\\n            if(l>=0 && r>=0){ \\n                res += abs(cost[l] - cost[r]);\\n                cost[i] += max(cost[l], cost[r]);\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minIncrements(int n, vector<int>& cost) {\\n        int res = 0;\\n        int s = cost.size();\\n        for(int i = s/2 - 1; i >= 0; i--){\\n            int l = 2 * i + 1;\\n            int r = 2 * i + 2;\\n            if(l>=0 && r>=0){ \\n                res += abs(cost[l] - cost[r]);\\n                cost[i] += max(cost[l], cost[r]);\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3499399,
                "title": "python-easy-to-read-dfs-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n\\'\\'\\'\\nApply DFS and try to make path cost equal from bottom to up.\\nWhen diff is applied save it in ans variable. return cost of the path.\\nIf left or right any path have imbalance, increase respective cost.\\n\\'\\'\\'\\nclass Solution:\\n    def dfs(self, root, cost, n):\\n        if root > n:\\n            return 0\\n        left = self.dfs(root*2, cost, n)\\n        right = self.dfs(1 + root*2, cost, n)\\n        if left < right:\\n            diff = right - left\\n            left_index = root*2-1\\n            cost[left_index] += diff\\n            self.ans += diff\\n        elif right < left:\\n            diff = left - right\\n            right_index = root*2 + 1 -1\\n            cost[right_index] += diff\\n            self.ans += diff\\n        return cost[root-1] + max(left, right)\\n\\n    def minIncrements(self, n: int, cost: List[int]) -> int:\\n        self.ans = 0\\n        self.dfs(1, cost, n)\\n        return self.ans\\n    \\n```",
                "solutionTags": [
                    "Python3",
                    "Depth-First Search"
                ],
                "code": "```\\n\\'\\'\\'\\nApply DFS and try to make path cost equal from bottom to up.\\nWhen diff is applied save it in ans variable. return cost of the path.\\nIf left or right any path have imbalance, increase respective cost.\\n\\'\\'\\'\\nclass Solution:\\n    def dfs(self, root, cost, n):\\n        if root > n:\\n            return 0\\n        left = self.dfs(root*2, cost, n)\\n        right = self.dfs(1 + root*2, cost, n)\\n        if left < right:\\n            diff = right - left\\n            left_index = root*2-1\\n            cost[left_index] += diff\\n            self.ans += diff\\n        elif right < left:\\n            diff = left - right\\n            right_index = root*2 + 1 -1\\n            cost[right_index] += diff\\n            self.ans += diff\\n        return cost[root-1] + max(left, right)\\n\\n    def minIncrements(self, n: int, cost: List[int]) -> int:\\n        self.ans = 0\\n        self.dfs(1, cost, n)\\n        return self.ans\\n    \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3499209,
                "title": "java-ez-2-understand",
                "content": "```\\nclass Solution {\\n    int ans;\\n    public int minIncrements(int n, int[] cost) {\\n        ans=0;\\n        int max=findMax(cost,0);//first find the path which has max path length\\n        helper(max,cost,0,0);\\n        return ans;\\n    }\\n    int helper(int max,int cost[],int root,int sum){\\n        int n=cost.length,diff=0,min=0;\\n        if(2*root+1>=n)\\n            return max-sum-cost[root];//leaf node case just return the diff btween path sum and max\\n        else{\\n            sum+=cost[root];\\n            int left=helper(max,cost,2*root+1,sum);\\n            int right=helper(max,cost,2*root+2,sum);\\n            min=Math.min(left,right);\\n            diff=Math.abs(left-right);//the diff can be adjusted in the same level\\n            //minimum of both can be sent to upper level to minimise the total cost.\\n        }\\n        ans+=diff;//adjust the difference on the same level\\n        return min;//send the min to the upper level\\n    }\\n    int findMax(int cost[],int root){\\n        //fxn to find the max path length\\n        int n=cost.length;\\n        if(root>=n)\\n            return 0;\\n        return cost[root]+Math.max(findMax(cost,2*root+1),findMax(cost,2*root+2));\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    int ans;\\n    public int minIncrements(int n, int[] cost) {\\n        ans=0;\\n        int max=findMax(cost,0);//first find the path which has max path length\\n        helper(max,cost,0,0);\\n        return ans;\\n    }\\n    int helper(int max,int cost[],int root,int sum){\\n        int n=cost.length,diff=0,min=0;\\n        if(2*root+1>=n)\\n            return max-sum-cost[root];//leaf node case just return the diff btween path sum and max\\n        else{\\n            sum+=cost[root];\\n            int left=helper(max,cost,2*root+1,sum);\\n            int right=helper(max,cost,2*root+2,sum);\\n            min=Math.min(left,right);\\n            diff=Math.abs(left-right);//the diff can be adjusted in the same level\\n            //minimum of both can be sent to upper level to minimise the total cost.\\n        }\\n        ans+=diff;//adjust the difference on the same level\\n        return min;//send the min to the upper level\\n    }\\n    int findMax(int cost[],int root){\\n        //fxn to find the max path length\\n        int n=cost.length;\\n        if(root>=n)\\n            return 0;\\n        return cost[root]+Math.max(findMax(cost,2*root+1),findMax(cost,2*root+2));\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3499045,
                "title": "c",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    \\n    map<int,vector<int>> mp;\\n    int ans=0;\\n    void dfs(int n, vector<int>& cost,int v)\\n    {\\n        for(auto it:mp[v])\\n        {\\n          dfs(n,cost,it);\\n        }  \\n        if(2*v<n)\\n        { \\n            int a=cost[2*v-1];\\n            int b=cost[2*v];\\n            // cout<<a<<\" \"<<b<<\" \"<<v<<\" \"<<abs(a-b)<<\"\\\\n\";   \\n            cost[v-1]+=max(a,b);\\n        \\n              ans+=abs(a-b);\\n        }\\n    }\\n    \\n    int minIncrements(int n, vector<int>& cost) {\\n        for(int i=1;i<=n;i++)\\n        {\\n            if(2*i<n)\\n            {\\n                mp[i].push_back(2*i);\\n                mp[i].push_back(2*i+1);\\n            }\\n        }\\n        dfs(n,cost,1);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    \\n    map<int,vector<int>> mp;\\n    int ans=0;\\n    void dfs(int n, vector<int>& cost,int v)\\n    {\\n        for(auto it:mp[v])\\n        {\\n          dfs(n,cost,it);\\n        }  \\n        if(2*v<n)\\n        { \\n            int a=cost[2*v-1];\\n            int b=cost[2*v];\\n            // cout<<a<<\" \"<<b<<\" \"<<v<<\" \"<<abs(a-b)<<\"\\\\n\";   \\n            cost[v-1]+=max(a,b);\\n        \\n              ans+=abs(a-b);\\n        }\\n    }\\n    \\n    int minIncrements(int n, vector<int>& cost) {\\n        for(int i=1;i<=n;i++)\\n        {\\n            if(2*i<n)\\n            {\\n                mp[i].push_back(2*i);\\n                mp[i].push_back(2*i+1);\\n            }\\n        }\\n        dfs(n,cost,1);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3498946,
                "title": "java-dfs-small-code",
                "content": "class Solution {\\n    \\n    int ans = 0;\\n    \\n    int dfs(int s, int n, int[] cost) {\\n        if(s > n) {\\n            return 0;\\n        }\\n        \\n        int left = dfs(2*s, n, cost);\\n        int right = dfs(2*s+1, n, cost);\\n        \\n        ans += Math.abs(left - right);\\n        return cost[s-1] + Math.max(left, right); \\n    }\\n    \\n    public int minIncrements(int n, int[] cost) {\\n        dfs(1, n, cost);\\n        return ans;\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Depth-First Search"
                ],
                "code": "class Solution {\\n    \\n    int ans = 0;\\n    \\n    int dfs(int s, int n, int[] cost) {\\n        if(s > n) {\\n            return 0;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3498585,
                "title": "pyhton3-o-n-two-pass-dfs",
                "content": "```\\nclass Solution:\\n    def minIncrements(self, n: int, cost: List[int]) -> int:\\n        cost.insert(0, 0)\\n        maxsub = [0] * (n + 1)\\n        def maxpath(v):\\n            if v > n: return 0\\n            maxsub[v] = max(maxpath(2 * v), maxpath(2 * v + 1))\\n            return maxsub[v] + cost[v]\\n        mp, ans = maxpath(1), 0\\n        def minadd(v, p):\\n            if v > n: return\\n            nonlocal mp, ans\\n            ans += mp - p - cost[v] - maxsub[v]\\n            p = mp - maxsub[v]\\n            minadd(2 * v, p)\\n            minadd(2 * v + 1, p)\\n        minadd(1, 0)\\n        return ans\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minIncrements(self, n: int, cost: List[int]) -> int:\\n        cost.insert(0, 0)\\n        maxsub = [0] * (n + 1)\\n        def maxpath(v):\\n            if v > n: return 0\\n            maxsub[v] = max(maxpath(2 * v), maxpath(2 * v + 1))\\n            return maxsub[v] + cost[v]\\n        mp, ans = maxpath(1), 0\\n        def minadd(v, p):\\n            if v > n: return\\n            nonlocal mp, ans\\n            ans += mp - p - cost[v] - maxsub[v]\\n            p = mp - maxsub[v]\\n            minadd(2 * v, p)\\n            minadd(2 * v + 1, p)\\n        minadd(1, 0)\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3498299,
                "title": "scala-simple-recursion-dfs",
                "content": "# Approach\\nWe can write a recursive function that uses the left and right subtrees of a node to evaluate the answer for that node\\'s subtree. Since we use two values for each subtree, Scala\\'s pattern matching comes in handy.\\n\\n# Code\\n```\\nobject Solution {\\n  def minIncrements(n: Int, cost: Array[Int]): Int = {\\n    def dfs(i: Int): (Int, Int) = {\\n      if (2 * i <= n) {\\n        val ((lCost, lValue), (rCost, rValue)) = (dfs(2 * i), dfs(2 * i + 1))\\n        (lCost + rCost + (lValue - rValue).abs, cost(i - 1) + lValue.max(rValue))\\n      } else (0, cost(i - 1))\\n    }\\n    dfs(1)._1\\n  }\\n}\\n```",
                "solutionTags": [
                    "Scala"
                ],
                "code": "```\\nobject Solution {\\n  def minIncrements(n: Int, cost: Array[Int]): Int = {\\n    def dfs(i: Int): (Int, Int) = {\\n      if (2 * i <= n) {\\n        val ((lCost, lValue), (rCost, rValue)) = (dfs(2 * i), dfs(2 * i + 1))\\n        (lCost + rCost + (lValue - rValue).abs, cost(i - 1) + lValue.max(rValue))\\n      } else (0, cost(i - 1))\\n    }\\n    dfs(1)._1\\n  }\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3498277,
                "title": "python-dfs-o-n",
                "content": "# Code\\n```\\nclass Solution:\\n    def minIncrements(self, n: int, cost: List[int]) -> int:\\n        self.res = 0\\n        def dfs(v):\\n            if v > n:\\n                return 0\\n            left = dfs(2*v)\\n            right = dfs(2*v+1)\\n            self.res += abs(left - right)\\n            return max(left, right) + cost[v-1]\\n        dfs(1)\\n        return self.res\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minIncrements(self, n: int, cost: List[int]) -> int:\\n        self.res = 0\\n        def dfs(v):\\n            if v > n:\\n                return 0\\n            left = dfs(2*v)\\n            right = dfs(2*v+1)\\n            self.res += abs(left - right)\\n            return max(left, right) + cost[v-1]\\n        dfs(1)\\n        return self.res\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3498125,
                "title": "bottom-up-dfs",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nLet each parent decide whether left child or right child needs to be adjusted and by how much and then return that information to it\\'s own parent.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Create a tree using n and the cost array\\n2. Use dfs to get the cost at each node and the increments that node made to it\\'s child nodes.\\n3. Base case is leaf node which returns current path cost + it\\'s cost as the cost till that node and 0 as the increments.\\n4. At every no-leaf node, find the adjustment required in either left child or right child. Return the adjusted cost, increments made by it\\'s left child + increments made by it\\'s right child + increments made by itself.\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n# Code\\n```\\nclass TreeNode:\\n    def __init__(self, idx, cost):\\n        self.id = idx\\n        self.cost = cost\\n        self.left = None\\n        self.right = None\\n\\nclass Solution:\\n    def minIncrements(self, n: int, cost: List[int]) -> int:\\n        \\n        startroot = TreeNode(1, cost[0])\\n        \\n        def createTree(root, rootId):\\n            if 2 * rootId >= n+1 or (2 * rootId) + 1 >= n+1: \\n                return TreeNode(rootId, cost[rootId-1])\\n            \\n            leftChildId, rightChildId = 2 * rootId, (2 * rootId) + 1\\n            leftChild = TreeNode(leftChildId, cost[leftChildId-1])\\n            rightChild = TreeNode(rightChildId, cost[rightChildId-1])\\n            \\n            root.left = createTree(leftChild, leftChildId)\\n            root.right = createTree(rightChild, rightChildId)\\n            \\n            return root\\n        \\n        treeRoot = createTree(startroot, 1)\\n        \\n        def helper(root, currCost):\\n            if not root.left and not root.right:\\n                return currCost + root.cost, 0\\n            \\n            leftCost, leftIncrements = helper(root.left, currCost + root.cost)\\n            rightCost, rightIncrements = helper(root.right, currCost + root.cost)\\n            \\n            greaterCost = max(leftCost, rightCost)\\n            currIncrements = (2 * greaterCost) - (leftCost + rightCost)\\n            \\n            return greaterCost, leftIncrements + rightIncrements + currIncrements\\n        \\n        finalCost, ans = helper(treeRoot, 0)\\n        return ans\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass TreeNode:\\n    def __init__(self, idx, cost):\\n        self.id = idx\\n        self.cost = cost\\n        self.left = None\\n        self.right = None\\n\\nclass Solution:\\n    def minIncrements(self, n: int, cost: List[int]) -> int:\\n        \\n        startroot = TreeNode(1, cost[0])\\n        \\n        def createTree(root, rootId):\\n            if 2 * rootId >= n+1 or (2 * rootId) + 1 >= n+1: \\n                return TreeNode(rootId, cost[rootId-1])\\n            \\n            leftChildId, rightChildId = 2 * rootId, (2 * rootId) + 1\\n            leftChild = TreeNode(leftChildId, cost[leftChildId-1])\\n            rightChild = TreeNode(rightChildId, cost[rightChildId-1])\\n            \\n            root.left = createTree(leftChild, leftChildId)\\n            root.right = createTree(rightChild, rightChildId)\\n            \\n            return root\\n        \\n        treeRoot = createTree(startroot, 1)\\n        \\n        def helper(root, currCost):\\n            if not root.left and not root.right:\\n                return currCost + root.cost, 0\\n            \\n            leftCost, leftIncrements = helper(root.left, currCost + root.cost)\\n            rightCost, rightIncrements = helper(root.right, currCost + root.cost)\\n            \\n            greaterCost = max(leftCost, rightCost)\\n            currIncrements = (2 * greaterCost) - (leftCost + rightCost)\\n            \\n            return greaterCost, leftIncrements + rightIncrements + currIncrements\\n        \\n        finalCost, ans = helper(treeRoot, 0)\\n        return ans\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3497939,
                "title": "kotlin-o-n",
                "content": "# Approach\\n\\n\\nSince we know it\\'s a perfect tree, we know that the last non-leaf node is at index `n / 2 - 1`.\\n\\n\\nTraverse the tree array from that index above down to index 0. For each index `i` in our loop, find it\\'s children leaf at indicies  `2 * i + 1` and `2 * i + 2`, take the difference between their values, add the (**absolute**) difference to our result (since the difference between them is amount of increments we made), and update the current value at `i` with the largest child value to sum the path sum.\\n\\n\\n\\n\\n# Code\\n```\\nclass Solution {\\n    fun minIncrements(n: Int, cost: IntArray): Int {\\n        val last = n / 2 - 1\\n\\n\\n        var res = 0\\n        for (i in last downTo 0) {\\n            var abs = cost[2 * i + 1] - cost[2 * i + 2]\\n            if (abs < 0) abs *= -1\\n            cost[i] += maxOf(cost[2 * i + 1], cost[2 * i + 2])\\n            res += abs\\n        }\\n\\n\\n        return res\\n    }\\n}\\n```\\n\\n",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\nclass Solution {\\n    fun minIncrements(n: Int, cost: IntArray): Int {\\n        val last = n / 2 - 1\\n\\n\\n        var res = 0\\n        for (i in last downTo 0) {\\n            var abs = cost[2 * i + 1] - cost[2 * i + 2]\\n            if (abs < 0) abs *= -1\\n            cost[i] += maxOf(cost[2 * i + 1], cost[2 * i + 2])\\n            res += abs\\n        }\\n\\n\\n        return res\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3497937,
                "title": "c-simple-and-short-bottom-up",
                "content": "```\\nclass Solution {\\npublic:\\n    int minIncrements(int n, vector<int>& cost) {\\n        int start = n/2, end = n-1, ans = 0;\\n        while(start > 0) {\\n            for(int i=start;i<end;i+=2) {\\n                ans += 2*max(cost[i],cost[i+1]) - (cost[i]+cost[i+1]);\\n                cost[i/2] += max(cost[i],cost[i+1]);\\n            }\\n            end = start-1;\\n            start/=2;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minIncrements(int n, vector<int>& cost) {\\n        int start = n/2, end = n-1, ans = 0;\\n        while(start > 0) {\\n            for(int i=start;i<end;i+=2) {\\n                ans += 2*max(cost[i],cost[i+1]) - (cost[i]+cost[i+1]);\\n                cost[i/2] += max(cost[i],cost[i+1]);\\n            }\\n            end = start-1;\\n            start/=2;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3497932,
                "title": "one-pass-iterative-solution-beginner-friendly",
                "content": "```\\nclass Solution {\\npublic:\\n    int minIncrements(int n, vector<int>& cost) {\\n        int ans = 0;\\n        int len = cost.size();\\n        for(int i = len / 2;i >= 0;i--){\\n            if(2 * i + 2 >= len||2 * i + 1 >= len) continue;\\n            cost[i] += max(cost[2 * i + 2],cost[2 * i + 1]);\\n            ans += abs(cost[2 * i + 2] - cost[2 * i + 1]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minIncrements(int n, vector<int>& cost) {\\n        int ans = 0;\\n        int len = cost.size();\\n        for(int i = len / 2;i >= 0;i--){\\n            if(2 * i + 2 >= len||2 * i + 1 >= len) continue;\\n            cost[i] += max(cost[2 * i + 2],cost[2 * i + 1]);\\n            ans += abs(cost[2 * i + 2] - cost[2 * i + 1]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3497529,
                "title": "java-bottom-up-approach",
                "content": "#     class Solution {\\n    public int minIncrements(int n, int[] cost) {\\n         int ans=0;\\n         for(int i=n/2;i<n;i+=2)\\n         {\\n             if(cost[i]!=cost[i+1])\\n             {\\n                 int temp=Math.max(cost[i],cost[i+1]);\\n                 ans+=temp-cost[i];\\n                 ans+=temp-cost[i+1];\\n                 cost[i]=temp;\\n                 cost[i+1]=temp;\\n             }   \\n         }\\n         // System.out.println(ans);\\n         n=n/2;\\n         while(n/2>0)\\n         {\\n             for(int i=n/2;i<n;i+=2)\\n             {\\n                 int temp=Math.max(cost[i]+cost[2*i+1],cost[i+1]+cost[2*(i+1)+1]);\\n                 ans+=temp-(cost[i]+cost[2*i+1]);\\n                 ans+=temp-(cost[i+1]+cost[2*(i+1)+1]);\\n                 cost[i]=temp;\\n                 cost[i+1]=temp;\\n                 //System.out.println(cost[i]+\" \"+cost[i+1]);\\n             }\\n             n=n/2;\\n         }\\n         return ans;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public int minIncrements(int n, int[] cost) {\\n         int ans=0;\\n         for(int i=n/2;i<n;i+=2)\\n         {\\n             if(cost[i]!=cost[i+1])\\n             {\\n                 int temp=Math.max(cost[i],cost[i+1]);\\n                 ans+=temp-cost[i];\\n                 ans+=temp-cost[i+1];\\n                 cost[i]=temp;\\n                 cost[i+1]=temp;\\n             }",
                "codeTag": "Java"
            },
            {
                "id": 3497397,
                "title": "java-dfs",
                "content": "\\n# class Solution {\\n    public int dfs(int child,int[] cost,int n,int[] ans)\\n    {\\n        if(child*2+1 >=n || child*2+2>=n)//leaf nodes\\n        {\\n            return cost[child];\\n        }\\n        int l=dfs(child*2+1,cost,n,ans);\\n        int r=dfs(child*2+2,cost,n,ans);\\n        \\n        ans[0]+=Math.abs(l-r);\\n        cost[child]+=Math.max(l,r);\\n        return cost[child];\\n    }\\n    public int minIncrements(int n, int[] cost) {\\n        int[] ans=new int[1];\\n        dfs(0,cost,n,ans);\\n        return ans[0];\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int dfs(int child,int[] cost,int n,int[] ans)\\n    {\\n        if(child*2+1 >=n || child*2+2>=n)//leaf nodes\\n        {\\n            return cost[child];\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3497313,
                "title": "java-dfs-simple",
                "content": "```\\nclass Solution {\\n    public int minIncrements(int n, int[] cost) {\\n        int[] incre = new int[1];\\n        find(0, cost, incre, n);\\n        return incre[0];\\n    }\\n\\n    public int find(int i, int[] cost, int[] incre, int n) {\\n        if (i >= n) return 0;\\n        int leftCost = find((2 * i) + 1, cost, incre, n);\\n        int rightCost = find((2 * i) + 2, cost, incre, n);\\n        incre[0] += Math.abs(leftCost - rightCost);\\n        return cost[i] + Math.max(leftCost, rightCost);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    public int minIncrements(int n, int[] cost) {\\n        int[] incre = new int[1];\\n        find(0, cost, incre, n);\\n        return incre[0];\\n    }\\n\\n    public int find(int i, int[] cost, int[] incre, int n) {\\n        if (i >= n) return 0;\\n        int leftCost = find((2 * i) + 1, cost, incre, n);\\n        int rightCost = find((2 * i) + 2, cost, incre, n);\\n        incre[0] += Math.abs(leftCost - rightCost);\\n        return cost[i] + Math.max(leftCost, rightCost);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3497253,
                "title": "using-dfs-cpp",
                "content": "\\n# Code\\n```\\nclass Solution {\\nprivate:\\n    int isPowerOfTwo(int n){\\n        if (n == 0)\\n            return -1;\\n        int x=ceil(log2(n));\\n        int y=floor(log2(n));\\n\\n        if(x==y) return x;\\n        else return -1;\\n    }\\n    int inOrder(int root,int h,vector<int>&cost,int &ans){\\n        if(h==0){\\n            return 0;\\n        }\\n\\n        int leftCost=inOrder(2*root,h-1,cost,ans);\\n        int rootCost=cost[root-1];\\n        int rightCost=inOrder(2*root+1,h-1,cost,ans);\\n\\n        if(leftCost!=rightCost){\\n            ans+=abs(leftCost-rightCost);\\n        }\\n\\n        return max(leftCost,rightCost)+rootCost;\\n    }\\npublic:\\n    int minIncrements(int n, vector<int>& cost) {\\n\\n        int height= isPowerOfTwo(n+1);\\n\\n        int ans=0;\\n        inOrder(1,height,cost,ans);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    int isPowerOfTwo(int n){\\n        if (n == 0)\\n            return -1;\\n        int x=ceil(log2(n));\\n        int y=floor(log2(n));\\n\\n        if(x==y) return x;\\n        else return -1;\\n    }\\n    int inOrder(int root,int h,vector<int>&cost,int &ans){\\n        if(h==0){\\n            return 0;\\n        }\\n\\n        int leftCost=inOrder(2*root,h-1,cost,ans);\\n        int rootCost=cost[root-1];\\n        int rightCost=inOrder(2*root+1,h-1,cost,ans);\\n\\n        if(leftCost!=rightCost){\\n            ans+=abs(leftCost-rightCost);\\n        }\\n\\n        return max(leftCost,rightCost)+rootCost;\\n    }\\npublic:\\n    int minIncrements(int n, vector<int>& cost) {\\n\\n        int height= isPowerOfTwo(n+1);\\n\\n        int ans=0;\\n        inOrder(1,height,cost,ans);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3497223,
                "title": "commented-explaination-why-post-order-and-finding-from-leaf-to-root",
                "content": "\\n\\n# Complexity\\n- Time complexity:O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:logn\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\nint ans= 0 ;\\nint dfs(int r , vector<int>& cost, int n ){\\n    if(r>n)return 0;\\n    int l = dfs(2*r, cost, n);\\n    int right = dfs(2*r+1, cost, n);\\n    ans +=abs(right-l);\\n    return cost[r-1]+max(l, right);//why we doing cost[r-1]-> cost is 0 based indexing so \\n}\\n    int minIncrements(int n, vector<int>& cost) {\\n        dfs(1, cost, n);\\n        return ans;\\n    }\\n};\\n//simply make root to leaf PATH is equal in order to make this will just think like strtign from leaf as to get max odf left and right in order to incerse only the value which will result add to root this make the balanced value path to root \\n//why? not taking root to leaft why tking postorder coz we cant decrease \\n\\n\\n//tc is O(N) \\n```",
                "solutionTags": [
                    "C++",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nint ans= 0 ;\\nint dfs(int r , vector<int>& cost, int n ){\\n    if(r>n)return 0;\\n    int l = dfs(2*r, cost, n);\\n    int right = dfs(2*r+1, cost, n);\\n    ans +=abs(right-l);\\n    return cost[r-1]+max(l, right);//why we doing cost[r-1]-> cost is 0 based indexing so \\n}\\n    int minIncrements(int n, vector<int>& cost) {\\n        dfs(1, cost, n);\\n        return ans;\\n    }\\n};\\n//simply make root to leaf PATH is equal in order to make this will just think like strtign from leaf as to get max odf left and right in order to incerse only the value which will result add to root this make the balanced value path to root \\n//why? not taking root to leaft why tking postorder coz we cant decrease \\n\\n\\n//tc is O(N) \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3496998,
                "title": "python-3-dfs-needs-optimization",
                "content": "```\\nclass Solution:\\n    def minIncrements(self, n: int, cost: List[int]) -> int:\\n        \\n        # get maximum path sum\\n        def dfs(i):\\n            if 2 * i > n:\\n                return cost[i-1]\\n            return cost[i-1] + max(dfs(2*i), dfs(2*i+1))\\n\\n        max_v = dfs(1)\\n        \\n        \\n        # calculate the path sum for each leaf node \\n        leaf_sum = {}\\n        def dfs2(i, v):\\n            if 2 * i > n:\\n                leaf_sum[i] = cost[i-1] + v\\n                return\\n            dfs2(2*i, v+cost[i-1])\\n            dfs2(2*i+1, v+cost[i-1])\\n        \\n        \\n        dfs2(1, 0)\\n        \\n        # up propagate the max leaf path sum to its parent, which means the minimum cost to travel to the leaf\\n        node_max = defaultdict(int)\\n        for i in range((n + 1) // 2, n+1):\\n            j = i\\n            while j > 0:\\n                node_max[j] = max(node_max[j], leaf_sum[i])\\n                j //= 2\\n        \\n        # for each node, calculate the increments needed to reach the leaf node and accumulate the increments\\n        self.ans = 0\\n        def dfs3(i, v):\\n            if i > n:\\n                return\\n            diff = max_v - (node_max[i] + v)\\n            self.ans += diff\\n            dfs3(2*i, v+diff)\\n            dfs3(2*i+1, v+diff)\\n            \\n        dfs3(1, 0)\\n        \\n        return self.ans",
                "solutionTags": [
                    "Depth-First Search"
                ],
                "code": "class Solution:\\n    def minIncrements(self, n: int, cost: List[int]) -> int:\\n        \\n        # get maximum path sum\\n        def dfs(i):\\n            if 2 * i > n:\\n                return cost[i-1]\\n            return cost[i-1] + max(dfs(2*i), dfs(2*i+1))\\n\\n        max_v = dfs(1)\\n        \\n        \\n        # calculate the path sum for each leaf node \\n        leaf_sum = {}",
                "codeTag": "Java"
            },
            {
                "id": 3496964,
                "title": "java-easy-with-recursion",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nwe need to compare left and right leafs for node and increment the ans by thier difference.  \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nuse recursion for each leaf and on the way back compare left and right leafs sum with and increment ans by the difference.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O[N] -> we just traverse all nodes.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    2*O[N] -> we use extra space to save the sum and out stack consumes O[n] during recursion\\n\\n# Code\\n```\\nclass Solution {\\n    public int minIncrements(int n, int[] cost) {\\n        ans = 0;\\n        int[] sum = new int[n];\\n        recursion(cost, sum, 1);\\n        return ans;\\n    }\\n\\n    int ans = 0;\\n\\n    int recursion(int[] cost,int[] sum, int index){\\n        if(index > cost.length) return 0;\\n        int l = recursion(cost, sum, 2*index);\\n        int r = recursion(cost, sum, 2*index+1);\\n        ans += Math.abs(l-r);\\n        \\n        sum[index-1] = Math.max(l, r)+cost[index-1];\\n        \\n        return sum[index-1];\\n    }\\n\\n\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minIncrements(int n, int[] cost) {\\n        ans = 0;\\n        int[] sum = new int[n];\\n        recursion(cost, sum, 1);\\n        return ans;\\n    }\\n\\n    int ans = 0;\\n\\n    int recursion(int[] cost,int[] sum, int index){\\n        if(index > cost.length) return 0;\\n        int l = recursion(cost, sum, 2*index);\\n        int r = recursion(cost, sum, 2*index+1);\\n        ans += Math.abs(l-r);\\n        \\n        sum[index-1] = Math.max(l, r)+cost[index-1];\\n        \\n        return sum[index-1];\\n    }\\n\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3496876,
                "title": "c-children-to-parent",
                "content": "```\\nclass Solution {\\npublic:\\n    int minIncrements(int n, vector<int>& cost) {\\n        int inc = 0;\\n        for(int r = n-1, l = r-1; r; r -= 2, l -= 2) {\\n            inc += abs(cost[l] - cost[r]);\\n            cost[(l-1)/2] += max(cost[l], cost[r]);\\n        }\\n        return inc;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minIncrements(int n, vector<int>& cost) {\\n        int inc = 0;\\n        for(int r = n-1, l = r-1; r; r -= 2, l -= 2) {\\n            inc += abs(cost[l] - cost[r]);\\n            cost[(l-1)/2] += max(cost[l], cost[r]);\\n        }\\n        return inc;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3496703,
                "title": "c-dfs-easy-solution",
                "content": "# Intuition\\nUpdate the costs from leaf nodes to root.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int ans = 0;\\n    int dfs(int x,vector<vector<int>>& adj,vector<int>& cost)\\n    {\\n        if(adj[x].size()==0)\\n        return cost[x-1];\\n        int l = dfs(adj[x][0],adj,cost);\\n        int r = dfs(adj[x][1],adj,cost);\\n        if(abs(l-r)>0)\\n        ans+=max(l,r)-min(l,r);\\n        return cost[x-1]+max(l,r);\\n    }\\n    int minIncrements(int n, vector<int>& cost) {\\n        vector<vector<int>> adj(n+1);\\n        for(int i=1;i<=n;i++)\\n        {\\n            if(2*i<=n && 2*i+1<=n)\\n            {\\n                adj[i].push_back(2*i);\\n                adj[i].push_back(2*(i)+1);\\n            }\\n        }\\n        ans = 0;\\n        dfs(1,adj,cost);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int ans = 0;\\n    int dfs(int x,vector<vector<int>>& adj,vector<int>& cost)\\n    {\\n        if(adj[x].size()==0)\\n        return cost[x-1];\\n        int l = dfs(adj[x][0],adj,cost);\\n        int r = dfs(adj[x][1],adj,cost);\\n        if(abs(l-r)>0)\\n        ans+=max(l,r)-min(l,r);\\n        return cost[x-1]+max(l,r);\\n    }\\n    int minIncrements(int n, vector<int>& cost) {\\n        vector<vector<int>> adj(n+1);\\n        for(int i=1;i<=n;i++)\\n        {\\n            if(2*i<=n && 2*i+1<=n)\\n            {\\n                adj[i].push_back(2*i);\\n                adj[i].push_back(2*(i)+1);\\n            }\\n        }\\n        ans = 0;\\n        dfs(1,adj,cost);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3496587,
                "title": "sum-of-a-binary-tree-c",
                "content": "```\\nclass Solution {\\n    int sum(int i,vector<int>&cost,int &cnt,int n)\\n    {\\n        if(i>n)\\n            return 0;\\n        int left=sum(2*i,cost,cnt,n);\\n        int right=sum(2*i+1,cost,cnt,n);\\n        cnt+=abs(left-right);\\n        return max(left,right)+cost[i-1];\\n    }\\npublic:\\n    int minIncrements(int n, vector<int>& cost) {\\n        int cnt=0;\\n        sum(1,cost,cnt,n);\\n        return cnt;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\n    int sum(int i,vector<int>&cost,int &cnt,int n)\\n    {\\n        if(i>n)\\n            return 0;\\n        int left=sum(2*i,cost,cnt,n);\\n        int right=sum(2*i+1,cost,cnt,n);\\n        cnt+=abs(left-right);\\n        return max(left,right)+cost[i-1];\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 3496465,
                "title": "dfs",
                "content": "# Code\\n```\\nuse std::cmp;\\nimpl Solution {\\n    pub fn min_increments(n: i32, cost: Vec<i32>) -> i32 {\\n        let mut result = 0;\\n        Self::dfs(0, &cost, &mut result);\\n\\n        result\\n    }\\n\\n    fn dfs(index: usize, cost: &Vec<i32>, result: &mut i32) -> i32 {\\n        if index >= cost.len() {\\n            return 0\\n        }\\n\\n        let node_left = Self::dfs((index + 1) * 2 - 1, cost, result);\\n        let node_right = Self::dfs((index + 1) * 2, cost, result);\\n\\n        *result += (node_left - node_right).abs();\\n\\n        return cost[index] + cmp::max(node_left, node_right)\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust",
                    "Recursion"
                ],
                "code": "```\\nuse std::cmp;\\nimpl Solution {\\n    pub fn min_increments(n: i32, cost: Vec<i32>) -> i32 {\\n        let mut result = 0;\\n        Self::dfs(0, &cost, &mut result);\\n\\n        result\\n    }\\n\\n    fn dfs(index: usize, cost: &Vec<i32>, result: &mut i32) -> i32 {\\n        if index >= cost.len() {\\n            return 0\\n        }\\n\\n        let node_left = Self::dfs((index + 1) * 2 - 1, cost, result);\\n        let node_right = Self::dfs((index + 1) * 2, cost, result);\\n\\n        *result += (node_left - node_right).abs();\\n\\n        return cost[index] + cmp::max(node_left, node_right)\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3496440,
                "title": "most-optimized-solution-in-c-with-proper-explanation",
                "content": "# Intuition\\nThe intuition behind the given code is to use segment tree data structure to efficiently compute the minimum number of increments needed to make the cost of paths from the root to each leaf node equal.\\n\\n# Approach\\nThe approach uses two helper functions and one main function:\\n\\n- The ```\\'helper_st\\'``` function recursively constructs the segment tree for the given binary tree using the segment tree array ```\\'st\\'```. For each node of the binary tree, it computes the sum of its cost and the cost of its parent node and stores it at the corresponding index in the segment tree array. It then recursively calls itself for the left and right child nodes of the current node.\\n- The ```\\'helper_ans\\'``` function recursively traverses the segment tree and updates the cost of nodes in the segment tree if needed to make the cost of all leaf nodes equal. It returns the minimum number of increments required to update the segment tree to achieve the desired condition.\\n- The ```\\'minIncrements\\'``` function initializes the segment tree by calling the ```\\'helper_st\\'``` function and then calls the ```\\'helper_ans\\'``` function to get the minimum number of increments needed to make the cost of paths from the root to each leaf node equal.\\n\\nTo explain the approach in detail, we first construct a segment tree for the given binary tree using the ```\\'helper_st\\'``` function. We initialize the root of the segment tree (index 0) to have a value of 0. For each node in the binary tree, we compute the sum of its cost and the cost of its parent node and store it at the corresponding index in the segment tree. We do this recursively for each left and right child node of the current node until we reach the leaf nodes of the binary tree.\\n\\nNext, we compute the maximum value of the segment tree for all leaf nodes and all nodes below them using a range query. We do this by traversing the right half of the segment tree (indices n/2 to n-1), which corresponds to the leaf nodes of the original binary tree. We find the maximum value among all nodes in this range and store it in the variable ```\\'maxi\\'```.\\n\\nWe then call the ```\\'helper_ans\\'``` function with the right half of the segment tree as the input range. This function recursively traverses the segment tree and updates the cost of nodes if needed to make the cost of all leaf nodes equal. It starts by checking if the given input range is valid, i.e., if the left index is less than or equal to the right index. If not, it returns 0. Otherwise, it finds the maximum value among all nodes in the given input range and subtracts it from ```\\'maxi\\'``` to get the number of increments needed to update all nodes in this range to have the same cost as the leaf nodes. It then updates the cost of each node in the input range to be equal to ```\\'maxi\\'```. Finally, it recursively calls itself for the left and right half of the input range and adds the returned values to the current answer.\\n\\nThe main function ```\\'minIncrements\\'``` initializes the segment tree by calling the \\'helper_st\\' function and then calls the ```\\'helper_ans\\'``` function with the right half of the segment tree as the input range to get the minimum number of increments needed to make the cost of paths from the root to each leaf node equal.\\n\\n# Complexity\\n- Time complexity: $$O(nlogn)$$\\n\\n- Space complexity: $$O(nlogn)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void helper_st(int p, int v, int n, vector<int>& cost, vector<int>& st) {\\n        if (p >= n) return;\\n        st[p] = v + cost[p];\\n        int temp = st[p];\\n        helper_st(2 * p + 1, temp, n, cost, st);\\n        helper_st(2 * p + 2, temp, n, cost, st);\\n    }\\n\\n    int helper_ans(int l, int r, int n, vector<int>& st, int maxi) {\\n        if (l > r) \\n            return 0;\\n\\n        int currMax = *max_element(st.begin() + l, st.begin() + r + 1);\\n        int ans = maxi - currMax;\\n\\n        for (int i = l; i <= r; i++) \\n            st[i] += maxi - currMax;\\n        \\n\\n        if (l != r) {\\n            int m = (l + r) / 2;\\n            ans = ans + helper_ans(l, m, n, st, maxi);\\n            ans = ans + helper_ans(m + 1, r, n, st, maxi);\\n        }\\n\\n        return ans;\\n    }\\n\\n    int minIncrements(int n, vector<int>& cost) {\\n        vector<int> st(n, 0);\\n        helper_st(0, 0, n, cost, st);\\n        int temp = n / 2;\\n        int temp2 = n - 1;\\n\\n        int maxi = *max_element(st.begin() + temp, st.end());\\n\\n        int ans = helper_ans(temp, temp2, n, st, maxi);\\n\\n        return ans;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Segment Tree"
                ],
                "code": "```\\'helper_st\\'```\n```\\'st\\'```\n```\\'helper_ans\\'```\n```\\'minIncrements\\'```\n```\\'helper_st\\'```\n```\\'helper_ans\\'```\n```\\'helper_st\\'```\n```\\'maxi\\'```\n```\\'helper_ans\\'```\n```\\'maxi\\'```\n```\\'maxi\\'```\n```\\'minIncrements\\'```\n```\\'helper_ans\\'```\n```\\nclass Solution {\\npublic:\\n    void helper_st(int p, int v, int n, vector<int>& cost, vector<int>& st) {\\n        if (p >= n) return;\\n        st[p] = v + cost[p];\\n        int temp = st[p];\\n        helper_st(2 * p + 1, temp, n, cost, st);\\n        helper_st(2 * p + 2, temp, n, cost, st);\\n    }\\n\\n    int helper_ans(int l, int r, int n, vector<int>& st, int maxi) {\\n        if (l > r) \\n            return 0;\\n\\n        int currMax = *max_element(st.begin() + l, st.begin() + r + 1);\\n        int ans = maxi - currMax;\\n\\n        for (int i = l; i <= r; i++) \\n            st[i] += maxi - currMax;\\n        \\n\\n        if (l != r) {\\n            int m = (l + r) / 2;\\n            ans = ans + helper_ans(l, m, n, st, maxi);\\n            ans = ans + helper_ans(m + 1, r, n, st, maxi);\\n        }\\n\\n        return ans;\\n    }\\n\\n    int minIncrements(int n, vector<int>& cost) {\\n        vector<int> st(n, 0);\\n        helper_st(0, 0, n, cost, st);\\n        int temp = n / 2;\\n        int temp2 = n - 1;\\n\\n        int maxi = *max_element(st.begin() + temp, st.end());\\n\\n        int ans = helper_ans(temp, temp2, n, st, maxi);\\n\\n        return ans;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3496348,
                "title": "easy-dfs-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nJust follow simple instruction and make dfs call.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nfor max create another dfs call.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(nlog(n))$$\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int dfs(int ind,vector<int>& cost,int n,int c,int &ans){\\n     \\n        if(2*ind>n or 2*ind+1>n){return c-cost[ind-1];}\\n\\n    int l=dfs(2*ind,cost,n,c-cost[ind-1],ans);\\n    int r=dfs(2*ind+1,cost,n,c-cost[ind-1],ans);\\n   int x= min(l,r);\\n    ans+=l+r-2*x;\\n    return x;\\n\\n    }\\n    int dfs2(int ind,vector<int>& cost,int n){\\n         if(2*ind>n or 2*ind+1>n){return cost[ind-1];}\\n\\n    int l=dfs2(2*ind,cost,n);\\n    int r=dfs2(2*ind+1,cost,n);\\n   int x= max(l,r);\\n    return x+cost[ind-1];\\n    }\\n    int minIncrements(int n, vector<int>& cost) {\\n        int ans=0, c=dfs2(1,cost,n);\\n       dfs(1,cost,n,c,ans);\\n        return ans; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dfs(int ind,vector<int>& cost,int n,int c,int &ans){\\n     \\n        if(2*ind>n or 2*ind+1>n){return c-cost[ind-1];}\\n\\n    int l=dfs(2*ind,cost,n,c-cost[ind-1],ans);\\n    int r=dfs(2*ind+1,cost,n,c-cost[ind-1],ans);\\n   int x= min(l,r);\\n    ans+=l+r-2*x;\\n    return x;\\n\\n    }\\n    int dfs2(int ind,vector<int>& cost,int n){\\n         if(2*ind>n or 2*ind+1>n){return cost[ind-1];}\\n\\n    int l=dfs2(2*ind,cost,n);\\n    int r=dfs2(2*ind+1,cost,n);\\n   int x= max(l,r);\\n    return x+cost[ind-1];\\n    }\\n    int minIncrements(int n, vector<int>& cost) {\\n        int ans=0, c=dfs2(1,cost,n);\\n       dfs(1,cost,n,c,ans);\\n        return ans; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3496269,
                "title": "easy-java-solution",
                "content": "# Code\\n```\\npublic class Solution {\\n    private void calculateStep(int p,int v,int n,int[] cost,int[] st) {\\n        if (p>=n) {\\n            return;\\n        }\\n        st[p]=v+cost[p];\\n        calculateStep(2*p+1,st[p],n,cost,st);\\n        calculateStep(2*p+2,st[p],n,cost,st);\\n    }\\n\\n    private int calculateAns(int l, int r, int n, int[] st, int max) {\\n        if (l>r) {\\n            return 0;\\n        }\\n        int cmax = Integer.MIN_VALUE;\\n        for (int i=l; i<=r; i++) {\\n            cmax = Math.max(cmax, st[i]);\\n        }\\n        int res=max-cmax;\\n\\n        for (int i = l; i <= r; i++) {\\n            st[i]+=max-cmax;\\n        }\\n\\n        if (l != r) {\\n            int m = (l+r)/2;\\n            res +=calculateAns(l,m,n,st,max);\\n            res +=calculateAns(m+1,r,n,st,max);\\n        }\\n\\n        return res;\\n    }\\n\\n    public int minIncrements(int n, int[] cost) {\\n        int[] st = new int[n];\\n        calculateStep(0, 0, n, cost, st);\\n\\n        int maxInd = n/2;\\n        int maxVal = Integer.MIN_VALUE;\\n        for (int i = maxInd; i<n; i++) {\\n            maxVal = Math.max(maxVal, st[i]);\\n        }\\n        int res=calculateAns(maxInd, n - 1, n, st, maxVal);\\n\\n        return res;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic class Solution {\\n    private void calculateStep(int p,int v,int n,int[] cost,int[] st) {\\n        if (p>=n) {\\n            return;\\n        }\\n        st[p]=v+cost[p];\\n        calculateStep(2*p+1,st[p],n,cost,st);\\n        calculateStep(2*p+2,st[p],n,cost,st);\\n    }\\n\\n    private int calculateAns(int l, int r, int n, int[] st, int max) {\\n        if (l>r) {\\n            return 0;\\n        }\\n        int cmax = Integer.MIN_VALUE;\\n        for (int i=l; i<=r; i++) {\\n            cmax = Math.max(cmax, st[i]);\\n        }\\n        int res=max-cmax;\\n\\n        for (int i = l; i <= r; i++) {\\n            st[i]+=max-cmax;\\n        }\\n\\n        if (l != r) {\\n            int m = (l+r)/2;\\n            res +=calculateAns(l,m,n,st,max);\\n            res +=calculateAns(m+1,r,n,st,max);\\n        }\\n\\n        return res;\\n    }\\n\\n    public int minIncrements(int n, int[] cost) {\\n        int[] st = new int[n];\\n        calculateStep(0, 0, n, cost, st);\\n\\n        int maxInd = n/2;\\n        int maxVal = Integer.MIN_VALUE;\\n        for (int i = maxInd; i<n; i++) {\\n            maxVal = Math.max(maxVal, st[i]);\\n        }\\n        int res=calculateAns(maxInd, n - 1, n, st, maxVal);\\n\\n        return res;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3496158,
                "title": "c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\npublic class Solution {\\n    public int MinIncrements(int n, int[] cost)\\n    {\\n        int res = 0;\\n        Search(ref res, 0, cost);\\n        return res;\\n    }\\n\\n    private int Search(ref int res, int i, int[] cost)\\n    {\\n        if (i >= cost.Length) return 0;\\n        int a = Search(ref res, 2 * i + 1, cost), b = Search(ref res, 2 * i + 2, cost);\\n        res += Math.Abs(a - b);\\n        return cost[i] + Math.Max(a, b);\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int MinIncrements(int n, int[] cost)\\n    {\\n        int res = 0;\\n        Search(ref res, 0, cost);\\n        return res;\\n    }\\n\\n    private int Search(ref int res, int i, int[] cost)\\n    {\\n        if (i >= cost.Length) return 0;\\n        int a = Search(ref res, 2 * i + 1, cost), b = Search(ref res, 2 * i + 2, cost);\\n        res += Math.Abs(a - b);\\n        return cost[i] + Math.Max(a, b);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3496098,
                "title": "c",
                "content": "```\\nclass Solution {\\npublic:\\n    int minIncrements(int n, vector<int>& cost) {\\n        int ret = 0 ;\\n        for(int i = n-1; i >= 2; i -= 2){\\n            int M = max(cost[i], cost[i-1]) ;\\n            ret += abs(cost[i] - cost[i-1]) ;\\n            int root = (i-1) / 2 ;\\n            cost[root] += M ;\\n        }\\n        return ret ;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minIncrements(int n, vector<int>& cost) {\\n        int ret = 0 ;\\n        for(int i = n-1; i >= 2; i -= 2){\\n            int M = max(cost[i], cost[i-1]) ;\\n            ret += abs(cost[i] - cost[i-1]) ;\\n            int root = (i-1) / 2 ;\\n            cost[root] += M ;\\n        }\\n        return ret ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3495908,
                "title": "javascript-2673-make-costs-of-paths-equal-in-a-binary-tree",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nvar minIncrements = function (n, c) {\\n    let tot = 0;\\n    function dfs(i) {\\n        if (2 * i < n) {\\n            dfs(2 * i); // left child\\n            dfs(2 * i + 1);\\n            tot += Math.abs(c[2 * i - 1] - c[2 * i]); // diff of chldren\\n            c[i - 1] += Math.max(c[2 * i - 1], c[2 * i]); // add max of chldren to parent cost\\n        } else {\\n            return c[i - 1]; // send parent cost\\n        }\\n    }\\n    dfs(1); // start from root\\n    return tot;\\n};\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar minIncrements = function (n, c) {\\n    let tot = 0;\\n    function dfs(i) {\\n        if (2 * i < n) {\\n            dfs(2 * i); // left child\\n            dfs(2 * i + 1);\\n            tot += Math.abs(c[2 * i - 1] - c[2 * i]); // diff of chldren\\n            c[i - 1] += Math.max(c[2 * i - 1], c[2 * i]); // add max of chldren to parent cost\\n        } else {\\n            return c[i - 1]; // send parent cost\\n        }\\n    }\\n    dfs(1); // start from root\\n    return tot;\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3495884,
                "title": "java-easy-to-understand-dfs-solution",
                "content": "```\\nclass Solution {\\n    int res = 0;\\n    private int dfs(int n, int[] cost){\\n        if(n >= cost.length){\\n            return 0;\\n        }\\n        int left = dfs(2 * n + 1, cost);\\n        int right = dfs(2 * n + 2, cost);\\n        res += Math.abs(left - right);\\n        return Math.max(left, right) + cost[n];\\n    }\\n    public int minIncrements(int n, int[] cost) {\\n        res = 0;\\n        dfs(0, cost);\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    int res = 0;\\n    private int dfs(int n, int[] cost){\\n        if(n >= cost.length){\\n            return 0;\\n        }\\n        int left = dfs(2 * n + 1, cost);\\n        int right = dfs(2 * n + 2, cost);\\n        res += Math.abs(left - right);\\n        return Math.max(left, right) + cost[n];\\n    }\\n    public int minIncrements(int n, int[] cost) {\\n        res = 0;\\n        dfs(0, cost);\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1885433,
                "content": [
                    {
                        "username": "note_08",
                        "content": "I was thinking of making each level of tree  all node  value equal  using bfs  storing the level and then  counting the operation why is this approach wrong?"
                    },
                    {
                        "username": "aditya_42",
                        "content": "so let us say you have a node with value 2, it has children 3,4 \nNow 3 has children 5,5 and \n4 has children 4,4 \nThis makes the tree\n   ----      2\n    -- 3    4\n    5 5     4 4\nSo now you can see even with different leaf values the total cost in both sub trees is same (from root to leaf) "
                    },
                    {
                        "username": "sergei-durkin",
                        "content": "Because if you set the same cost on each level, it will affect the left and right tree\\nbtw i tried this approach too)"
                    },
                    {
                        "username": "purushattom1999",
                        "content": "Why I\\'m getting wrong output in this test case can anyone explain ??\\nInput\\nn =\\n15\\ncost =\\n[764,1460,2664,764,2725,4556,5305,8829,5064,5929,7660,6321,4830,7055,3761]\\nOutput\\n14195\\nExpected\\n15735\\n\\n\\n\\n\\nclass Solution {\\n    public int minIncrements(int n, int[] cost) {\\n        int N=n;\\n        int ans=Math.abs(cost[1]-cost[2]);\\n\\n        for(int i=1;i<N/2;i++)\\n        {\\n            ans+= Math.abs(cost[i*2+1]-cost[i*2+2]);\\n        }\\n        return ans;\\n    }\\n}"
                    },
                    {
                        "username": "sk_games",
                        "content": "Because: \\n---- 2\\n-- 3 4\\n5 5 4 4\\n[valid answer]\\n\\nNot the same as:\\n---- 2\\n-- 4 4\\n5 5 5 5\\n[not valid, not the smallest]"
                    },
                    {
                        "username": "sk_games",
                        "content": "For everybody who didn't get  (like myself) why simply aligning all items in the layer is not acceptable answer: \n\nBecause:\n---- 2\n-- 3 4\n5 5 4 4\n[valid answer, from root to leaf all equal]\n\nNot the same as:\n---- 2\n-- 4 4\n5 5 5 5\n[not valid, not the smallest]\n\nCredits to [@Aditya](/aditya_42)"
                    },
                    {
                        "username": "himanshuu173",
                        "content": "Can anyone explain y my code is wrng???\\nint minIncrements(int n, vector<int>& cost) {\\n        int cst=0;\\n        int i=0,c1=0,c2=0;\\n        while(i<n and c1<n and c2<n){\\n            c1=2*i+1,c2=2*i+2;\\n            if(cost[c1]==cost[c2] and c1<n and c2<n)i++;\\n            else if(cost[c1]!=cost[c2] and c1<n and c1<n){\\n                cst+=max(cost[c1],cost[c2])-min(cost[c1],cost[c2]);\\n                i++;\\n            }\\n            //else if(c1>=n or c2>=n) break;\\n        }\\n        return cst;\\n    }"
                    },
                    {
                        "username": "aman1320",
                        "content": "Why they have to asked the Binary Tree question without giving the binary tree ? :("
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I think it's good practice to mix it up and force you to use different formats. The array representation of binary trees is not something leetcode made up, it's just one of the ways to represent them. In some languages, it might be a lot more efficient to store them like that than designing a class with pointers.\n\nDon't get too used to \"the usual leetcode format\" or you're gonna be taken by surprise in a different context"
                    },
                    {
                        "username": "aman1320",
                        "content": "[@Michael_V](/Michael_V) where did i wrote binary searcg tree?"
                    },
                    {
                        "username": "Michael_V",
                        "content": "It is a binary tree. Don't confuse it with BST (binary search tree)."
                    },
                    {
                        "username": "dynamo214",
                        "content": "Can someone help, Why I am getting TLE on Q4 DFS\n```\nclass Solution {\npublic:\n    int minIncrements(int n, vector<int>& cost) {\n        int res = 0, pathSum = 0;\n        dfs(0, pathSum, res, n, cost);\n        return res;\n    }\n    int dfs(int node, int pathSum, int& res, int lastNode, vector<int> cost) {\n        if(node*2+2 < lastNode) {\n            int leftSum = dfs(node*2+1, pathSum+cost[node], res, lastNode, cost);\n            int rightSum = dfs(node*2+2, pathSum+cost[node], res, lastNode, cost);\n            res += abs(leftSum - rightSum);\n            return cost[node] + max(leftSum, rightSum);\n        }\n        return cost[node];\n    }\n};\n```"
                    },
                    {
                        "username": "dynamo214",
                        "content": "[@anya509](/anya509) yes"
                    },
                    {
                        "username": "anya509",
                        "content": "Trying passing variables by reference whenever you can for all function calls - here you can send cost array by reference."
                    },
                    {
                        "username": "sergei-durkin",
                        "content": "[@dynamo214](/dynamo214) oh sure, I have not seen `&`) Have a nice day)"
                    },
                    {
                        "username": "dynamo214",
                        "content": "[@sergei-durkin](/sergei-durkin) Thanks for taking a look, I have found the issue.\nIn C++, in each pass it creates a new cost array which is time consuming, if we pass cost array by ref then it works like a charm\nso change\n`int dfs(int node, int pathSum, int& res, int lastNode, vector<int> cost)` \nto \n`int dfs(int node, int pathSum, int& res, int lastNode, vector<int>& cost)` \n```\nclass Solution {\npublic:\n    int minIncrements(int n, vector<int>& cost) {\n        int res = 0, pathSum = 0;\n        dfs(0, pathSum, res, n, cost);\n        return res;\n    }\n    int dfs(int node, int pathSum, int& res, int lastNode, vector<int>& cost) {\n        if(node*2+2 < lastNode) {\n            int leftSum = dfs(node*2+1, pathSum+cost[node], res, lastNode, cost);\n            int rightSum = dfs(node*2+2, pathSum+cost[node], res, lastNode, cost);\n            res += abs(leftSum - rightSum);\n            return cost[node] + max(leftSum, rightSum);\n        }\n        return cost[node];\n    }\n};\n```"
                    },
                    {
                        "username": "sergei-durkin",
                        "content": "Hi bro your code works fine with golang\\n```go\\nfunc minIncrements(n int, cost []int) int {\\n    res := 0\\n    dfs(0, 0, &res, n, cost)\\n    \\n    return res\\n}\\n\\nfunc dfs(i, sum int, res *int, n int, cost []int)int{\\n    if i*2+2 < n{\\n        left := dfs(i*2+1, sum+cost[i], res, n, cost)\\n        right := dfs(i*2+2, sum+cost[i], res, n, cost)\\n\\n        (*res) += abs(left-right)\\n        return cost[i]+max(left,right)\\n    }\\n    return cost[i]\\n}\\n\\nfunc abs(x int)int{\\n    if x < 0{\\n        return -x\\n    }\\n    return x\\n}\\n\\nfunc max(x,y int)int{\\n    if x > y{\\n        return x\\n    }\\n    return y\\n}\\n```"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "If you would like a clear justification of the dfs logic, along with illustrations and detailed explanations, I posted a solution  \\n[here](https://leetcode.com/problems/make-costs-of-paths-equal-in-a-binary-tree/solutions/3495321/clear-simple-dfs-illustrated/)!"
                    }
                ]
            },
            {
                "id": 1888071,
                "content": [
                    {
                        "username": "note_08",
                        "content": "I was thinking of making each level of tree  all node  value equal  using bfs  storing the level and then  counting the operation why is this approach wrong?"
                    },
                    {
                        "username": "aditya_42",
                        "content": "so let us say you have a node with value 2, it has children 3,4 \nNow 3 has children 5,5 and \n4 has children 4,4 \nThis makes the tree\n   ----      2\n    -- 3    4\n    5 5     4 4\nSo now you can see even with different leaf values the total cost in both sub trees is same (from root to leaf) "
                    },
                    {
                        "username": "sergei-durkin",
                        "content": "Because if you set the same cost on each level, it will affect the left and right tree\\nbtw i tried this approach too)"
                    },
                    {
                        "username": "purushattom1999",
                        "content": "Why I\\'m getting wrong output in this test case can anyone explain ??\\nInput\\nn =\\n15\\ncost =\\n[764,1460,2664,764,2725,4556,5305,8829,5064,5929,7660,6321,4830,7055,3761]\\nOutput\\n14195\\nExpected\\n15735\\n\\n\\n\\n\\nclass Solution {\\n    public int minIncrements(int n, int[] cost) {\\n        int N=n;\\n        int ans=Math.abs(cost[1]-cost[2]);\\n\\n        for(int i=1;i<N/2;i++)\\n        {\\n            ans+= Math.abs(cost[i*2+1]-cost[i*2+2]);\\n        }\\n        return ans;\\n    }\\n}"
                    },
                    {
                        "username": "sk_games",
                        "content": "Because: \\n---- 2\\n-- 3 4\\n5 5 4 4\\n[valid answer]\\n\\nNot the same as:\\n---- 2\\n-- 4 4\\n5 5 5 5\\n[not valid, not the smallest]"
                    },
                    {
                        "username": "sk_games",
                        "content": "For everybody who didn't get  (like myself) why simply aligning all items in the layer is not acceptable answer: \n\nBecause:\n---- 2\n-- 3 4\n5 5 4 4\n[valid answer, from root to leaf all equal]\n\nNot the same as:\n---- 2\n-- 4 4\n5 5 5 5\n[not valid, not the smallest]\n\nCredits to [@Aditya](/aditya_42)"
                    },
                    {
                        "username": "himanshuu173",
                        "content": "Can anyone explain y my code is wrng???\\nint minIncrements(int n, vector<int>& cost) {\\n        int cst=0;\\n        int i=0,c1=0,c2=0;\\n        while(i<n and c1<n and c2<n){\\n            c1=2*i+1,c2=2*i+2;\\n            if(cost[c1]==cost[c2] and c1<n and c2<n)i++;\\n            else if(cost[c1]!=cost[c2] and c1<n and c1<n){\\n                cst+=max(cost[c1],cost[c2])-min(cost[c1],cost[c2]);\\n                i++;\\n            }\\n            //else if(c1>=n or c2>=n) break;\\n        }\\n        return cst;\\n    }"
                    },
                    {
                        "username": "aman1320",
                        "content": "Why they have to asked the Binary Tree question without giving the binary tree ? :("
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I think it's good practice to mix it up and force you to use different formats. The array representation of binary trees is not something leetcode made up, it's just one of the ways to represent them. In some languages, it might be a lot more efficient to store them like that than designing a class with pointers.\n\nDon't get too used to \"the usual leetcode format\" or you're gonna be taken by surprise in a different context"
                    },
                    {
                        "username": "aman1320",
                        "content": "[@Michael_V](/Michael_V) where did i wrote binary searcg tree?"
                    },
                    {
                        "username": "Michael_V",
                        "content": "It is a binary tree. Don't confuse it with BST (binary search tree)."
                    },
                    {
                        "username": "dynamo214",
                        "content": "Can someone help, Why I am getting TLE on Q4 DFS\n```\nclass Solution {\npublic:\n    int minIncrements(int n, vector<int>& cost) {\n        int res = 0, pathSum = 0;\n        dfs(0, pathSum, res, n, cost);\n        return res;\n    }\n    int dfs(int node, int pathSum, int& res, int lastNode, vector<int> cost) {\n        if(node*2+2 < lastNode) {\n            int leftSum = dfs(node*2+1, pathSum+cost[node], res, lastNode, cost);\n            int rightSum = dfs(node*2+2, pathSum+cost[node], res, lastNode, cost);\n            res += abs(leftSum - rightSum);\n            return cost[node] + max(leftSum, rightSum);\n        }\n        return cost[node];\n    }\n};\n```"
                    },
                    {
                        "username": "dynamo214",
                        "content": "[@anya509](/anya509) yes"
                    },
                    {
                        "username": "anya509",
                        "content": "Trying passing variables by reference whenever you can for all function calls - here you can send cost array by reference."
                    },
                    {
                        "username": "sergei-durkin",
                        "content": "[@dynamo214](/dynamo214) oh sure, I have not seen `&`) Have a nice day)"
                    },
                    {
                        "username": "dynamo214",
                        "content": "[@sergei-durkin](/sergei-durkin) Thanks for taking a look, I have found the issue.\nIn C++, in each pass it creates a new cost array which is time consuming, if we pass cost array by ref then it works like a charm\nso change\n`int dfs(int node, int pathSum, int& res, int lastNode, vector<int> cost)` \nto \n`int dfs(int node, int pathSum, int& res, int lastNode, vector<int>& cost)` \n```\nclass Solution {\npublic:\n    int minIncrements(int n, vector<int>& cost) {\n        int res = 0, pathSum = 0;\n        dfs(0, pathSum, res, n, cost);\n        return res;\n    }\n    int dfs(int node, int pathSum, int& res, int lastNode, vector<int>& cost) {\n        if(node*2+2 < lastNode) {\n            int leftSum = dfs(node*2+1, pathSum+cost[node], res, lastNode, cost);\n            int rightSum = dfs(node*2+2, pathSum+cost[node], res, lastNode, cost);\n            res += abs(leftSum - rightSum);\n            return cost[node] + max(leftSum, rightSum);\n        }\n        return cost[node];\n    }\n};\n```"
                    },
                    {
                        "username": "sergei-durkin",
                        "content": "Hi bro your code works fine with golang\\n```go\\nfunc minIncrements(n int, cost []int) int {\\n    res := 0\\n    dfs(0, 0, &res, n, cost)\\n    \\n    return res\\n}\\n\\nfunc dfs(i, sum int, res *int, n int, cost []int)int{\\n    if i*2+2 < n{\\n        left := dfs(i*2+1, sum+cost[i], res, n, cost)\\n        right := dfs(i*2+2, sum+cost[i], res, n, cost)\\n\\n        (*res) += abs(left-right)\\n        return cost[i]+max(left,right)\\n    }\\n    return cost[i]\\n}\\n\\nfunc abs(x int)int{\\n    if x < 0{\\n        return -x\\n    }\\n    return x\\n}\\n\\nfunc max(x,y int)int{\\n    if x > y{\\n        return x\\n    }\\n    return y\\n}\\n```"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "If you would like a clear justification of the dfs logic, along with illustrations and detailed explanations, I posted a solution  \\n[here](https://leetcode.com/problems/make-costs-of-paths-equal-in-a-binary-tree/solutions/3495321/clear-simple-dfs-illustrated/)!"
                    }
                ]
            },
            {
                "id": 1890713,
                "content": [
                    {
                        "username": "note_08",
                        "content": "I was thinking of making each level of tree  all node  value equal  using bfs  storing the level and then  counting the operation why is this approach wrong?"
                    },
                    {
                        "username": "aditya_42",
                        "content": "so let us say you have a node with value 2, it has children 3,4 \nNow 3 has children 5,5 and \n4 has children 4,4 \nThis makes the tree\n   ----      2\n    -- 3    4\n    5 5     4 4\nSo now you can see even with different leaf values the total cost in both sub trees is same (from root to leaf) "
                    },
                    {
                        "username": "sergei-durkin",
                        "content": "Because if you set the same cost on each level, it will affect the left and right tree\\nbtw i tried this approach too)"
                    },
                    {
                        "username": "purushattom1999",
                        "content": "Why I\\'m getting wrong output in this test case can anyone explain ??\\nInput\\nn =\\n15\\ncost =\\n[764,1460,2664,764,2725,4556,5305,8829,5064,5929,7660,6321,4830,7055,3761]\\nOutput\\n14195\\nExpected\\n15735\\n\\n\\n\\n\\nclass Solution {\\n    public int minIncrements(int n, int[] cost) {\\n        int N=n;\\n        int ans=Math.abs(cost[1]-cost[2]);\\n\\n        for(int i=1;i<N/2;i++)\\n        {\\n            ans+= Math.abs(cost[i*2+1]-cost[i*2+2]);\\n        }\\n        return ans;\\n    }\\n}"
                    },
                    {
                        "username": "sk_games",
                        "content": "Because: \\n---- 2\\n-- 3 4\\n5 5 4 4\\n[valid answer]\\n\\nNot the same as:\\n---- 2\\n-- 4 4\\n5 5 5 5\\n[not valid, not the smallest]"
                    },
                    {
                        "username": "sk_games",
                        "content": "For everybody who didn't get  (like myself) why simply aligning all items in the layer is not acceptable answer: \n\nBecause:\n---- 2\n-- 3 4\n5 5 4 4\n[valid answer, from root to leaf all equal]\n\nNot the same as:\n---- 2\n-- 4 4\n5 5 5 5\n[not valid, not the smallest]\n\nCredits to [@Aditya](/aditya_42)"
                    },
                    {
                        "username": "himanshuu173",
                        "content": "Can anyone explain y my code is wrng???\\nint minIncrements(int n, vector<int>& cost) {\\n        int cst=0;\\n        int i=0,c1=0,c2=0;\\n        while(i<n and c1<n and c2<n){\\n            c1=2*i+1,c2=2*i+2;\\n            if(cost[c1]==cost[c2] and c1<n and c2<n)i++;\\n            else if(cost[c1]!=cost[c2] and c1<n and c1<n){\\n                cst+=max(cost[c1],cost[c2])-min(cost[c1],cost[c2]);\\n                i++;\\n            }\\n            //else if(c1>=n or c2>=n) break;\\n        }\\n        return cst;\\n    }"
                    },
                    {
                        "username": "aman1320",
                        "content": "Why they have to asked the Binary Tree question without giving the binary tree ? :("
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I think it's good practice to mix it up and force you to use different formats. The array representation of binary trees is not something leetcode made up, it's just one of the ways to represent them. In some languages, it might be a lot more efficient to store them like that than designing a class with pointers.\n\nDon't get too used to \"the usual leetcode format\" or you're gonna be taken by surprise in a different context"
                    },
                    {
                        "username": "aman1320",
                        "content": "[@Michael_V](/Michael_V) where did i wrote binary searcg tree?"
                    },
                    {
                        "username": "Michael_V",
                        "content": "It is a binary tree. Don't confuse it with BST (binary search tree)."
                    },
                    {
                        "username": "dynamo214",
                        "content": "Can someone help, Why I am getting TLE on Q4 DFS\n```\nclass Solution {\npublic:\n    int minIncrements(int n, vector<int>& cost) {\n        int res = 0, pathSum = 0;\n        dfs(0, pathSum, res, n, cost);\n        return res;\n    }\n    int dfs(int node, int pathSum, int& res, int lastNode, vector<int> cost) {\n        if(node*2+2 < lastNode) {\n            int leftSum = dfs(node*2+1, pathSum+cost[node], res, lastNode, cost);\n            int rightSum = dfs(node*2+2, pathSum+cost[node], res, lastNode, cost);\n            res += abs(leftSum - rightSum);\n            return cost[node] + max(leftSum, rightSum);\n        }\n        return cost[node];\n    }\n};\n```"
                    },
                    {
                        "username": "dynamo214",
                        "content": "[@anya509](/anya509) yes"
                    },
                    {
                        "username": "anya509",
                        "content": "Trying passing variables by reference whenever you can for all function calls - here you can send cost array by reference."
                    },
                    {
                        "username": "sergei-durkin",
                        "content": "[@dynamo214](/dynamo214) oh sure, I have not seen `&`) Have a nice day)"
                    },
                    {
                        "username": "dynamo214",
                        "content": "[@sergei-durkin](/sergei-durkin) Thanks for taking a look, I have found the issue.\nIn C++, in each pass it creates a new cost array which is time consuming, if we pass cost array by ref then it works like a charm\nso change\n`int dfs(int node, int pathSum, int& res, int lastNode, vector<int> cost)` \nto \n`int dfs(int node, int pathSum, int& res, int lastNode, vector<int>& cost)` \n```\nclass Solution {\npublic:\n    int minIncrements(int n, vector<int>& cost) {\n        int res = 0, pathSum = 0;\n        dfs(0, pathSum, res, n, cost);\n        return res;\n    }\n    int dfs(int node, int pathSum, int& res, int lastNode, vector<int>& cost) {\n        if(node*2+2 < lastNode) {\n            int leftSum = dfs(node*2+1, pathSum+cost[node], res, lastNode, cost);\n            int rightSum = dfs(node*2+2, pathSum+cost[node], res, lastNode, cost);\n            res += abs(leftSum - rightSum);\n            return cost[node] + max(leftSum, rightSum);\n        }\n        return cost[node];\n    }\n};\n```"
                    },
                    {
                        "username": "sergei-durkin",
                        "content": "Hi bro your code works fine with golang\\n```go\\nfunc minIncrements(n int, cost []int) int {\\n    res := 0\\n    dfs(0, 0, &res, n, cost)\\n    \\n    return res\\n}\\n\\nfunc dfs(i, sum int, res *int, n int, cost []int)int{\\n    if i*2+2 < n{\\n        left := dfs(i*2+1, sum+cost[i], res, n, cost)\\n        right := dfs(i*2+2, sum+cost[i], res, n, cost)\\n\\n        (*res) += abs(left-right)\\n        return cost[i]+max(left,right)\\n    }\\n    return cost[i]\\n}\\n\\nfunc abs(x int)int{\\n    if x < 0{\\n        return -x\\n    }\\n    return x\\n}\\n\\nfunc max(x,y int)int{\\n    if x > y{\\n        return x\\n    }\\n    return y\\n}\\n```"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "If you would like a clear justification of the dfs logic, along with illustrations and detailed explanations, I posted a solution  \\n[here](https://leetcode.com/problems/make-costs-of-paths-equal-in-a-binary-tree/solutions/3495321/clear-simple-dfs-illustrated/)!"
                    }
                ]
            },
            {
                "id": 1886858,
                "content": [
                    {
                        "username": "note_08",
                        "content": "I was thinking of making each level of tree  all node  value equal  using bfs  storing the level and then  counting the operation why is this approach wrong?"
                    },
                    {
                        "username": "aditya_42",
                        "content": "so let us say you have a node with value 2, it has children 3,4 \nNow 3 has children 5,5 and \n4 has children 4,4 \nThis makes the tree\n   ----      2\n    -- 3    4\n    5 5     4 4\nSo now you can see even with different leaf values the total cost in both sub trees is same (from root to leaf) "
                    },
                    {
                        "username": "sergei-durkin",
                        "content": "Because if you set the same cost on each level, it will affect the left and right tree\\nbtw i tried this approach too)"
                    },
                    {
                        "username": "purushattom1999",
                        "content": "Why I\\'m getting wrong output in this test case can anyone explain ??\\nInput\\nn =\\n15\\ncost =\\n[764,1460,2664,764,2725,4556,5305,8829,5064,5929,7660,6321,4830,7055,3761]\\nOutput\\n14195\\nExpected\\n15735\\n\\n\\n\\n\\nclass Solution {\\n    public int minIncrements(int n, int[] cost) {\\n        int N=n;\\n        int ans=Math.abs(cost[1]-cost[2]);\\n\\n        for(int i=1;i<N/2;i++)\\n        {\\n            ans+= Math.abs(cost[i*2+1]-cost[i*2+2]);\\n        }\\n        return ans;\\n    }\\n}"
                    },
                    {
                        "username": "sk_games",
                        "content": "Because: \\n---- 2\\n-- 3 4\\n5 5 4 4\\n[valid answer]\\n\\nNot the same as:\\n---- 2\\n-- 4 4\\n5 5 5 5\\n[not valid, not the smallest]"
                    },
                    {
                        "username": "sk_games",
                        "content": "For everybody who didn't get  (like myself) why simply aligning all items in the layer is not acceptable answer: \n\nBecause:\n---- 2\n-- 3 4\n5 5 4 4\n[valid answer, from root to leaf all equal]\n\nNot the same as:\n---- 2\n-- 4 4\n5 5 5 5\n[not valid, not the smallest]\n\nCredits to [@Aditya](/aditya_42)"
                    },
                    {
                        "username": "himanshuu173",
                        "content": "Can anyone explain y my code is wrng???\\nint minIncrements(int n, vector<int>& cost) {\\n        int cst=0;\\n        int i=0,c1=0,c2=0;\\n        while(i<n and c1<n and c2<n){\\n            c1=2*i+1,c2=2*i+2;\\n            if(cost[c1]==cost[c2] and c1<n and c2<n)i++;\\n            else if(cost[c1]!=cost[c2] and c1<n and c1<n){\\n                cst+=max(cost[c1],cost[c2])-min(cost[c1],cost[c2]);\\n                i++;\\n            }\\n            //else if(c1>=n or c2>=n) break;\\n        }\\n        return cst;\\n    }"
                    },
                    {
                        "username": "aman1320",
                        "content": "Why they have to asked the Binary Tree question without giving the binary tree ? :("
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I think it's good practice to mix it up and force you to use different formats. The array representation of binary trees is not something leetcode made up, it's just one of the ways to represent them. In some languages, it might be a lot more efficient to store them like that than designing a class with pointers.\n\nDon't get too used to \"the usual leetcode format\" or you're gonna be taken by surprise in a different context"
                    },
                    {
                        "username": "aman1320",
                        "content": "[@Michael_V](/Michael_V) where did i wrote binary searcg tree?"
                    },
                    {
                        "username": "Michael_V",
                        "content": "It is a binary tree. Don't confuse it with BST (binary search tree)."
                    },
                    {
                        "username": "dynamo214",
                        "content": "Can someone help, Why I am getting TLE on Q4 DFS\n```\nclass Solution {\npublic:\n    int minIncrements(int n, vector<int>& cost) {\n        int res = 0, pathSum = 0;\n        dfs(0, pathSum, res, n, cost);\n        return res;\n    }\n    int dfs(int node, int pathSum, int& res, int lastNode, vector<int> cost) {\n        if(node*2+2 < lastNode) {\n            int leftSum = dfs(node*2+1, pathSum+cost[node], res, lastNode, cost);\n            int rightSum = dfs(node*2+2, pathSum+cost[node], res, lastNode, cost);\n            res += abs(leftSum - rightSum);\n            return cost[node] + max(leftSum, rightSum);\n        }\n        return cost[node];\n    }\n};\n```"
                    },
                    {
                        "username": "dynamo214",
                        "content": "[@anya509](/anya509) yes"
                    },
                    {
                        "username": "anya509",
                        "content": "Trying passing variables by reference whenever you can for all function calls - here you can send cost array by reference."
                    },
                    {
                        "username": "sergei-durkin",
                        "content": "[@dynamo214](/dynamo214) oh sure, I have not seen `&`) Have a nice day)"
                    },
                    {
                        "username": "dynamo214",
                        "content": "[@sergei-durkin](/sergei-durkin) Thanks for taking a look, I have found the issue.\nIn C++, in each pass it creates a new cost array which is time consuming, if we pass cost array by ref then it works like a charm\nso change\n`int dfs(int node, int pathSum, int& res, int lastNode, vector<int> cost)` \nto \n`int dfs(int node, int pathSum, int& res, int lastNode, vector<int>& cost)` \n```\nclass Solution {\npublic:\n    int minIncrements(int n, vector<int>& cost) {\n        int res = 0, pathSum = 0;\n        dfs(0, pathSum, res, n, cost);\n        return res;\n    }\n    int dfs(int node, int pathSum, int& res, int lastNode, vector<int>& cost) {\n        if(node*2+2 < lastNode) {\n            int leftSum = dfs(node*2+1, pathSum+cost[node], res, lastNode, cost);\n            int rightSum = dfs(node*2+2, pathSum+cost[node], res, lastNode, cost);\n            res += abs(leftSum - rightSum);\n            return cost[node] + max(leftSum, rightSum);\n        }\n        return cost[node];\n    }\n};\n```"
                    },
                    {
                        "username": "sergei-durkin",
                        "content": "Hi bro your code works fine with golang\\n```go\\nfunc minIncrements(n int, cost []int) int {\\n    res := 0\\n    dfs(0, 0, &res, n, cost)\\n    \\n    return res\\n}\\n\\nfunc dfs(i, sum int, res *int, n int, cost []int)int{\\n    if i*2+2 < n{\\n        left := dfs(i*2+1, sum+cost[i], res, n, cost)\\n        right := dfs(i*2+2, sum+cost[i], res, n, cost)\\n\\n        (*res) += abs(left-right)\\n        return cost[i]+max(left,right)\\n    }\\n    return cost[i]\\n}\\n\\nfunc abs(x int)int{\\n    if x < 0{\\n        return -x\\n    }\\n    return x\\n}\\n\\nfunc max(x,y int)int{\\n    if x > y{\\n        return x\\n    }\\n    return y\\n}\\n```"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "If you would like a clear justification of the dfs logic, along with illustrations and detailed explanations, I posted a solution  \\n[here](https://leetcode.com/problems/make-costs-of-paths-equal-in-a-binary-tree/solutions/3495321/clear-simple-dfs-illustrated/)!"
                    }
                ]
            },
            {
                "id": 1886011,
                "content": [
                    {
                        "username": "note_08",
                        "content": "I was thinking of making each level of tree  all node  value equal  using bfs  storing the level and then  counting the operation why is this approach wrong?"
                    },
                    {
                        "username": "aditya_42",
                        "content": "so let us say you have a node with value 2, it has children 3,4 \nNow 3 has children 5,5 and \n4 has children 4,4 \nThis makes the tree\n   ----      2\n    -- 3    4\n    5 5     4 4\nSo now you can see even with different leaf values the total cost in both sub trees is same (from root to leaf) "
                    },
                    {
                        "username": "sergei-durkin",
                        "content": "Because if you set the same cost on each level, it will affect the left and right tree\\nbtw i tried this approach too)"
                    },
                    {
                        "username": "purushattom1999",
                        "content": "Why I\\'m getting wrong output in this test case can anyone explain ??\\nInput\\nn =\\n15\\ncost =\\n[764,1460,2664,764,2725,4556,5305,8829,5064,5929,7660,6321,4830,7055,3761]\\nOutput\\n14195\\nExpected\\n15735\\n\\n\\n\\n\\nclass Solution {\\n    public int minIncrements(int n, int[] cost) {\\n        int N=n;\\n        int ans=Math.abs(cost[1]-cost[2]);\\n\\n        for(int i=1;i<N/2;i++)\\n        {\\n            ans+= Math.abs(cost[i*2+1]-cost[i*2+2]);\\n        }\\n        return ans;\\n    }\\n}"
                    },
                    {
                        "username": "sk_games",
                        "content": "Because: \\n---- 2\\n-- 3 4\\n5 5 4 4\\n[valid answer]\\n\\nNot the same as:\\n---- 2\\n-- 4 4\\n5 5 5 5\\n[not valid, not the smallest]"
                    },
                    {
                        "username": "sk_games",
                        "content": "For everybody who didn't get  (like myself) why simply aligning all items in the layer is not acceptable answer: \n\nBecause:\n---- 2\n-- 3 4\n5 5 4 4\n[valid answer, from root to leaf all equal]\n\nNot the same as:\n---- 2\n-- 4 4\n5 5 5 5\n[not valid, not the smallest]\n\nCredits to [@Aditya](/aditya_42)"
                    },
                    {
                        "username": "himanshuu173",
                        "content": "Can anyone explain y my code is wrng???\\nint minIncrements(int n, vector<int>& cost) {\\n        int cst=0;\\n        int i=0,c1=0,c2=0;\\n        while(i<n and c1<n and c2<n){\\n            c1=2*i+1,c2=2*i+2;\\n            if(cost[c1]==cost[c2] and c1<n and c2<n)i++;\\n            else if(cost[c1]!=cost[c2] and c1<n and c1<n){\\n                cst+=max(cost[c1],cost[c2])-min(cost[c1],cost[c2]);\\n                i++;\\n            }\\n            //else if(c1>=n or c2>=n) break;\\n        }\\n        return cst;\\n    }"
                    },
                    {
                        "username": "aman1320",
                        "content": "Why they have to asked the Binary Tree question without giving the binary tree ? :("
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I think it's good practice to mix it up and force you to use different formats. The array representation of binary trees is not something leetcode made up, it's just one of the ways to represent them. In some languages, it might be a lot more efficient to store them like that than designing a class with pointers.\n\nDon't get too used to \"the usual leetcode format\" or you're gonna be taken by surprise in a different context"
                    },
                    {
                        "username": "aman1320",
                        "content": "[@Michael_V](/Michael_V) where did i wrote binary searcg tree?"
                    },
                    {
                        "username": "Michael_V",
                        "content": "It is a binary tree. Don't confuse it with BST (binary search tree)."
                    },
                    {
                        "username": "dynamo214",
                        "content": "Can someone help, Why I am getting TLE on Q4 DFS\n```\nclass Solution {\npublic:\n    int minIncrements(int n, vector<int>& cost) {\n        int res = 0, pathSum = 0;\n        dfs(0, pathSum, res, n, cost);\n        return res;\n    }\n    int dfs(int node, int pathSum, int& res, int lastNode, vector<int> cost) {\n        if(node*2+2 < lastNode) {\n            int leftSum = dfs(node*2+1, pathSum+cost[node], res, lastNode, cost);\n            int rightSum = dfs(node*2+2, pathSum+cost[node], res, lastNode, cost);\n            res += abs(leftSum - rightSum);\n            return cost[node] + max(leftSum, rightSum);\n        }\n        return cost[node];\n    }\n};\n```"
                    },
                    {
                        "username": "dynamo214",
                        "content": "[@anya509](/anya509) yes"
                    },
                    {
                        "username": "anya509",
                        "content": "Trying passing variables by reference whenever you can for all function calls - here you can send cost array by reference."
                    },
                    {
                        "username": "sergei-durkin",
                        "content": "[@dynamo214](/dynamo214) oh sure, I have not seen `&`) Have a nice day)"
                    },
                    {
                        "username": "dynamo214",
                        "content": "[@sergei-durkin](/sergei-durkin) Thanks for taking a look, I have found the issue.\nIn C++, in each pass it creates a new cost array which is time consuming, if we pass cost array by ref then it works like a charm\nso change\n`int dfs(int node, int pathSum, int& res, int lastNode, vector<int> cost)` \nto \n`int dfs(int node, int pathSum, int& res, int lastNode, vector<int>& cost)` \n```\nclass Solution {\npublic:\n    int minIncrements(int n, vector<int>& cost) {\n        int res = 0, pathSum = 0;\n        dfs(0, pathSum, res, n, cost);\n        return res;\n    }\n    int dfs(int node, int pathSum, int& res, int lastNode, vector<int>& cost) {\n        if(node*2+2 < lastNode) {\n            int leftSum = dfs(node*2+1, pathSum+cost[node], res, lastNode, cost);\n            int rightSum = dfs(node*2+2, pathSum+cost[node], res, lastNode, cost);\n            res += abs(leftSum - rightSum);\n            return cost[node] + max(leftSum, rightSum);\n        }\n        return cost[node];\n    }\n};\n```"
                    },
                    {
                        "username": "sergei-durkin",
                        "content": "Hi bro your code works fine with golang\\n```go\\nfunc minIncrements(n int, cost []int) int {\\n    res := 0\\n    dfs(0, 0, &res, n, cost)\\n    \\n    return res\\n}\\n\\nfunc dfs(i, sum int, res *int, n int, cost []int)int{\\n    if i*2+2 < n{\\n        left := dfs(i*2+1, sum+cost[i], res, n, cost)\\n        right := dfs(i*2+2, sum+cost[i], res, n, cost)\\n\\n        (*res) += abs(left-right)\\n        return cost[i]+max(left,right)\\n    }\\n    return cost[i]\\n}\\n\\nfunc abs(x int)int{\\n    if x < 0{\\n        return -x\\n    }\\n    return x\\n}\\n\\nfunc max(x,y int)int{\\n    if x > y{\\n        return x\\n    }\\n    return y\\n}\\n```"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "If you would like a clear justification of the dfs logic, along with illustrations and detailed explanations, I posted a solution  \\n[here](https://leetcode.com/problems/make-costs-of-paths-equal-in-a-binary-tree/solutions/3495321/clear-simple-dfs-illustrated/)!"
                    }
                ]
            },
            {
                "id": 1885389,
                "content": [
                    {
                        "username": "note_08",
                        "content": "I was thinking of making each level of tree  all node  value equal  using bfs  storing the level and then  counting the operation why is this approach wrong?"
                    },
                    {
                        "username": "aditya_42",
                        "content": "so let us say you have a node with value 2, it has children 3,4 \nNow 3 has children 5,5 and \n4 has children 4,4 \nThis makes the tree\n   ----      2\n    -- 3    4\n    5 5     4 4\nSo now you can see even with different leaf values the total cost in both sub trees is same (from root to leaf) "
                    },
                    {
                        "username": "sergei-durkin",
                        "content": "Because if you set the same cost on each level, it will affect the left and right tree\\nbtw i tried this approach too)"
                    },
                    {
                        "username": "purushattom1999",
                        "content": "Why I\\'m getting wrong output in this test case can anyone explain ??\\nInput\\nn =\\n15\\ncost =\\n[764,1460,2664,764,2725,4556,5305,8829,5064,5929,7660,6321,4830,7055,3761]\\nOutput\\n14195\\nExpected\\n15735\\n\\n\\n\\n\\nclass Solution {\\n    public int minIncrements(int n, int[] cost) {\\n        int N=n;\\n        int ans=Math.abs(cost[1]-cost[2]);\\n\\n        for(int i=1;i<N/2;i++)\\n        {\\n            ans+= Math.abs(cost[i*2+1]-cost[i*2+2]);\\n        }\\n        return ans;\\n    }\\n}"
                    },
                    {
                        "username": "sk_games",
                        "content": "Because: \\n---- 2\\n-- 3 4\\n5 5 4 4\\n[valid answer]\\n\\nNot the same as:\\n---- 2\\n-- 4 4\\n5 5 5 5\\n[not valid, not the smallest]"
                    },
                    {
                        "username": "sk_games",
                        "content": "For everybody who didn't get  (like myself) why simply aligning all items in the layer is not acceptable answer: \n\nBecause:\n---- 2\n-- 3 4\n5 5 4 4\n[valid answer, from root to leaf all equal]\n\nNot the same as:\n---- 2\n-- 4 4\n5 5 5 5\n[not valid, not the smallest]\n\nCredits to [@Aditya](/aditya_42)"
                    },
                    {
                        "username": "himanshuu173",
                        "content": "Can anyone explain y my code is wrng???\\nint minIncrements(int n, vector<int>& cost) {\\n        int cst=0;\\n        int i=0,c1=0,c2=0;\\n        while(i<n and c1<n and c2<n){\\n            c1=2*i+1,c2=2*i+2;\\n            if(cost[c1]==cost[c2] and c1<n and c2<n)i++;\\n            else if(cost[c1]!=cost[c2] and c1<n and c1<n){\\n                cst+=max(cost[c1],cost[c2])-min(cost[c1],cost[c2]);\\n                i++;\\n            }\\n            //else if(c1>=n or c2>=n) break;\\n        }\\n        return cst;\\n    }"
                    },
                    {
                        "username": "aman1320",
                        "content": "Why they have to asked the Binary Tree question without giving the binary tree ? :("
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I think it's good practice to mix it up and force you to use different formats. The array representation of binary trees is not something leetcode made up, it's just one of the ways to represent them. In some languages, it might be a lot more efficient to store them like that than designing a class with pointers.\n\nDon't get too used to \"the usual leetcode format\" or you're gonna be taken by surprise in a different context"
                    },
                    {
                        "username": "aman1320",
                        "content": "[@Michael_V](/Michael_V) where did i wrote binary searcg tree?"
                    },
                    {
                        "username": "Michael_V",
                        "content": "It is a binary tree. Don't confuse it with BST (binary search tree)."
                    },
                    {
                        "username": "dynamo214",
                        "content": "Can someone help, Why I am getting TLE on Q4 DFS\n```\nclass Solution {\npublic:\n    int minIncrements(int n, vector<int>& cost) {\n        int res = 0, pathSum = 0;\n        dfs(0, pathSum, res, n, cost);\n        return res;\n    }\n    int dfs(int node, int pathSum, int& res, int lastNode, vector<int> cost) {\n        if(node*2+2 < lastNode) {\n            int leftSum = dfs(node*2+1, pathSum+cost[node], res, lastNode, cost);\n            int rightSum = dfs(node*2+2, pathSum+cost[node], res, lastNode, cost);\n            res += abs(leftSum - rightSum);\n            return cost[node] + max(leftSum, rightSum);\n        }\n        return cost[node];\n    }\n};\n```"
                    },
                    {
                        "username": "dynamo214",
                        "content": "[@anya509](/anya509) yes"
                    },
                    {
                        "username": "anya509",
                        "content": "Trying passing variables by reference whenever you can for all function calls - here you can send cost array by reference."
                    },
                    {
                        "username": "sergei-durkin",
                        "content": "[@dynamo214](/dynamo214) oh sure, I have not seen `&`) Have a nice day)"
                    },
                    {
                        "username": "dynamo214",
                        "content": "[@sergei-durkin](/sergei-durkin) Thanks for taking a look, I have found the issue.\nIn C++, in each pass it creates a new cost array which is time consuming, if we pass cost array by ref then it works like a charm\nso change\n`int dfs(int node, int pathSum, int& res, int lastNode, vector<int> cost)` \nto \n`int dfs(int node, int pathSum, int& res, int lastNode, vector<int>& cost)` \n```\nclass Solution {\npublic:\n    int minIncrements(int n, vector<int>& cost) {\n        int res = 0, pathSum = 0;\n        dfs(0, pathSum, res, n, cost);\n        return res;\n    }\n    int dfs(int node, int pathSum, int& res, int lastNode, vector<int>& cost) {\n        if(node*2+2 < lastNode) {\n            int leftSum = dfs(node*2+1, pathSum+cost[node], res, lastNode, cost);\n            int rightSum = dfs(node*2+2, pathSum+cost[node], res, lastNode, cost);\n            res += abs(leftSum - rightSum);\n            return cost[node] + max(leftSum, rightSum);\n        }\n        return cost[node];\n    }\n};\n```"
                    },
                    {
                        "username": "sergei-durkin",
                        "content": "Hi bro your code works fine with golang\\n```go\\nfunc minIncrements(n int, cost []int) int {\\n    res := 0\\n    dfs(0, 0, &res, n, cost)\\n    \\n    return res\\n}\\n\\nfunc dfs(i, sum int, res *int, n int, cost []int)int{\\n    if i*2+2 < n{\\n        left := dfs(i*2+1, sum+cost[i], res, n, cost)\\n        right := dfs(i*2+2, sum+cost[i], res, n, cost)\\n\\n        (*res) += abs(left-right)\\n        return cost[i]+max(left,right)\\n    }\\n    return cost[i]\\n}\\n\\nfunc abs(x int)int{\\n    if x < 0{\\n        return -x\\n    }\\n    return x\\n}\\n\\nfunc max(x,y int)int{\\n    if x > y{\\n        return x\\n    }\\n    return y\\n}\\n```"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "If you would like a clear justification of the dfs logic, along with illustrations and detailed explanations, I posted a solution  \\n[here](https://leetcode.com/problems/make-costs-of-paths-equal-in-a-binary-tree/solutions/3495321/clear-simple-dfs-illustrated/)!"
                    }
                ]
            },
            {
                "id": 1885554,
                "content": [
                    {
                        "username": "note_08",
                        "content": "I was thinking of making each level of tree  all node  value equal  using bfs  storing the level and then  counting the operation why is this approach wrong?"
                    },
                    {
                        "username": "aditya_42",
                        "content": "so let us say you have a node with value 2, it has children 3,4 \nNow 3 has children 5,5 and \n4 has children 4,4 \nThis makes the tree\n   ----      2\n    -- 3    4\n    5 5     4 4\nSo now you can see even with different leaf values the total cost in both sub trees is same (from root to leaf) "
                    },
                    {
                        "username": "sergei-durkin",
                        "content": "Because if you set the same cost on each level, it will affect the left and right tree\\nbtw i tried this approach too)"
                    },
                    {
                        "username": "purushattom1999",
                        "content": "Why I\\'m getting wrong output in this test case can anyone explain ??\\nInput\\nn =\\n15\\ncost =\\n[764,1460,2664,764,2725,4556,5305,8829,5064,5929,7660,6321,4830,7055,3761]\\nOutput\\n14195\\nExpected\\n15735\\n\\n\\n\\n\\nclass Solution {\\n    public int minIncrements(int n, int[] cost) {\\n        int N=n;\\n        int ans=Math.abs(cost[1]-cost[2]);\\n\\n        for(int i=1;i<N/2;i++)\\n        {\\n            ans+= Math.abs(cost[i*2+1]-cost[i*2+2]);\\n        }\\n        return ans;\\n    }\\n}"
                    },
                    {
                        "username": "sk_games",
                        "content": "Because: \\n---- 2\\n-- 3 4\\n5 5 4 4\\n[valid answer]\\n\\nNot the same as:\\n---- 2\\n-- 4 4\\n5 5 5 5\\n[not valid, not the smallest]"
                    },
                    {
                        "username": "sk_games",
                        "content": "For everybody who didn't get  (like myself) why simply aligning all items in the layer is not acceptable answer: \n\nBecause:\n---- 2\n-- 3 4\n5 5 4 4\n[valid answer, from root to leaf all equal]\n\nNot the same as:\n---- 2\n-- 4 4\n5 5 5 5\n[not valid, not the smallest]\n\nCredits to [@Aditya](/aditya_42)"
                    },
                    {
                        "username": "himanshuu173",
                        "content": "Can anyone explain y my code is wrng???\\nint minIncrements(int n, vector<int>& cost) {\\n        int cst=0;\\n        int i=0,c1=0,c2=0;\\n        while(i<n and c1<n and c2<n){\\n            c1=2*i+1,c2=2*i+2;\\n            if(cost[c1]==cost[c2] and c1<n and c2<n)i++;\\n            else if(cost[c1]!=cost[c2] and c1<n and c1<n){\\n                cst+=max(cost[c1],cost[c2])-min(cost[c1],cost[c2]);\\n                i++;\\n            }\\n            //else if(c1>=n or c2>=n) break;\\n        }\\n        return cst;\\n    }"
                    },
                    {
                        "username": "aman1320",
                        "content": "Why they have to asked the Binary Tree question without giving the binary tree ? :("
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I think it's good practice to mix it up and force you to use different formats. The array representation of binary trees is not something leetcode made up, it's just one of the ways to represent them. In some languages, it might be a lot more efficient to store them like that than designing a class with pointers.\n\nDon't get too used to \"the usual leetcode format\" or you're gonna be taken by surprise in a different context"
                    },
                    {
                        "username": "aman1320",
                        "content": "[@Michael_V](/Michael_V) where did i wrote binary searcg tree?"
                    },
                    {
                        "username": "Michael_V",
                        "content": "It is a binary tree. Don't confuse it with BST (binary search tree)."
                    },
                    {
                        "username": "dynamo214",
                        "content": "Can someone help, Why I am getting TLE on Q4 DFS\n```\nclass Solution {\npublic:\n    int minIncrements(int n, vector<int>& cost) {\n        int res = 0, pathSum = 0;\n        dfs(0, pathSum, res, n, cost);\n        return res;\n    }\n    int dfs(int node, int pathSum, int& res, int lastNode, vector<int> cost) {\n        if(node*2+2 < lastNode) {\n            int leftSum = dfs(node*2+1, pathSum+cost[node], res, lastNode, cost);\n            int rightSum = dfs(node*2+2, pathSum+cost[node], res, lastNode, cost);\n            res += abs(leftSum - rightSum);\n            return cost[node] + max(leftSum, rightSum);\n        }\n        return cost[node];\n    }\n};\n```"
                    },
                    {
                        "username": "dynamo214",
                        "content": "[@anya509](/anya509) yes"
                    },
                    {
                        "username": "anya509",
                        "content": "Trying passing variables by reference whenever you can for all function calls - here you can send cost array by reference."
                    },
                    {
                        "username": "sergei-durkin",
                        "content": "[@dynamo214](/dynamo214) oh sure, I have not seen `&`) Have a nice day)"
                    },
                    {
                        "username": "dynamo214",
                        "content": "[@sergei-durkin](/sergei-durkin) Thanks for taking a look, I have found the issue.\nIn C++, in each pass it creates a new cost array which is time consuming, if we pass cost array by ref then it works like a charm\nso change\n`int dfs(int node, int pathSum, int& res, int lastNode, vector<int> cost)` \nto \n`int dfs(int node, int pathSum, int& res, int lastNode, vector<int>& cost)` \n```\nclass Solution {\npublic:\n    int minIncrements(int n, vector<int>& cost) {\n        int res = 0, pathSum = 0;\n        dfs(0, pathSum, res, n, cost);\n        return res;\n    }\n    int dfs(int node, int pathSum, int& res, int lastNode, vector<int>& cost) {\n        if(node*2+2 < lastNode) {\n            int leftSum = dfs(node*2+1, pathSum+cost[node], res, lastNode, cost);\n            int rightSum = dfs(node*2+2, pathSum+cost[node], res, lastNode, cost);\n            res += abs(leftSum - rightSum);\n            return cost[node] + max(leftSum, rightSum);\n        }\n        return cost[node];\n    }\n};\n```"
                    },
                    {
                        "username": "sergei-durkin",
                        "content": "Hi bro your code works fine with golang\\n```go\\nfunc minIncrements(n int, cost []int) int {\\n    res := 0\\n    dfs(0, 0, &res, n, cost)\\n    \\n    return res\\n}\\n\\nfunc dfs(i, sum int, res *int, n int, cost []int)int{\\n    if i*2+2 < n{\\n        left := dfs(i*2+1, sum+cost[i], res, n, cost)\\n        right := dfs(i*2+2, sum+cost[i], res, n, cost)\\n\\n        (*res) += abs(left-right)\\n        return cost[i]+max(left,right)\\n    }\\n    return cost[i]\\n}\\n\\nfunc abs(x int)int{\\n    if x < 0{\\n        return -x\\n    }\\n    return x\\n}\\n\\nfunc max(x,y int)int{\\n    if x > y{\\n        return x\\n    }\\n    return y\\n}\\n```"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "If you would like a clear justification of the dfs logic, along with illustrations and detailed explanations, I posted a solution  \\n[here](https://leetcode.com/problems/make-costs-of-paths-equal-in-a-binary-tree/solutions/3495321/clear-simple-dfs-illustrated/)!"
                    }
                ]
            }
        ]
    },
    {
        "title": "Neighboring Bitwise XOR",
        "question_content": "<p>A <strong>0-indexed</strong> array <code>derived</code> with length <code>n</code> is derived by computing the <strong>bitwise XOR</strong>&nbsp;(&oplus;) of adjacent values in a <strong>binary array</strong> <code>original</code> of length <code>n</code>.</p>\n\n<p>Specifically, for each index <code>i</code> in the range <code>[0, n - 1]</code>:</p>\n\n<ul>\n\t<li>If <code>i = n - 1</code>, then <code>derived[i] = original[i] &oplus; original[0]</code>.</li>\n\t<li>Otherwise, <code>derived[i] = original[i] &oplus; original[i + 1]</code>.</li>\n</ul>\n\n<p>Given an array <code>derived</code>, your task is to determine whether there exists a <strong>valid binary array</strong> <code>original</code> that could have formed <code>derived</code>.</p>\n\n<p>Return <em><strong>true</strong> if such an array exists or <strong>false</strong> otherwise.</em></p>\n\n<ul>\n\t<li>A binary array is an array containing only <strong>0&#39;s</strong> and <strong>1&#39;s</strong></li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> derived = [1,1,0]\n<strong>Output:</strong> true\n<strong>Explanation:</strong> A valid original array that gives derived is [0,1,0].\nderived[0] = original[0] &oplus; original[1] = 0 &oplus; 1 = 1 \nderived[1] = original[1] &oplus; original[2] = 1 &oplus; 0 = 1\nderived[2] = original[2] &oplus; original[0] = 0 &oplus; 0 = 0\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> derived = [1,1]\n<strong>Output:</strong> true\n<strong>Explanation:</strong> A valid original array that gives derived is [0,1].\nderived[0] = original[0] &oplus; original[1] = 1\nderived[1] = original[1] &oplus; original[0] = 1\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> derived = [1,0]\n<strong>Output:</strong> false\n<strong>Explanation:</strong> There is no valid original array that gives derived.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>n == derived.length</code></li>\n\t<li><code>1 &lt;= n&nbsp;&lt;= 10<sup>5</sup></code></li>\n\t<li>The values in <code>derived</code>&nbsp;are either <strong>0&#39;s</strong> or <strong>1&#39;s</strong></li>\n</ul>\n",
        "solutions": [
            {
                "id": 3522095,
                "title": "java-c-python-sum-is-even",
                "content": "# **Explanation**\\norginal: `A[0], A[1], .... A[n-1]`\\nderived: `A[0]^A[1], A[1]^A[2] .... A[n-1]^A[0]`\\n\\n`xor(derived) = (A[0]^A[1])^(A[1]^A[2])^ .... ^(A[n-1]^A[0]) = 0`\\n\\nThe necessary and suffisant condition for `derived` to have an `original` is\\n`xor(derived) == 0`\\n\\nWhend `original` and `derived` is binary sequence,\\nthis equals to `sum(derived) % 2 == 0`.\\n<br>\\n\\n# **Complexity**\\nTime `O(n)`\\nSpace `O(1)`\\n<br>\\n\\n\\n**Java**\\n```java\\n    public boolean doesValidArrayExist(int[] A) {\\n        return Arrays.stream(A).sum() % 2 == 0;\\n    }\\n```\\n\\n**C++**\\n```cpp\\n    bool doesValidArrayExist(vector<int>& A) {\\n        return accumulate(A.begin(), A.end(), 0) % 2 == 0;\\n    }\\n```\\n\\n**Python**\\n```py\\n    def doesValidArrayExist(self, A: List[int]) -> bool:\\n        return sum(A) % 2 == 0\\n```\\n",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C"
                ],
                "code": "```java\\n    public boolean doesValidArrayExist(int[] A) {\\n        return Arrays.stream(A).sum() % 2 == 0;\\n    }\\n```\n```cpp\\n    bool doesValidArrayExist(vector<int>& A) {\\n        return accumulate(A.begin(), A.end(), 0) % 2 == 0;\\n    }\\n```\n```py\\n    def doesValidArrayExist(self, A: List[int]) -> bool:\\n        return sum(A) % 2 == 0\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3522096,
                "title": "illustrated-step-by-step-simulation",
                "content": "We will discuss a solution that has the additional advantage of explicitly reconstructing the potential original array.\\nThere are other ways of solving the problem that do not achieve this, You can check the last section of this post for links to other nice solutions which show you how to do just that.\\n\\n# The inverse operation:\\nThe key insight here is that the reverse operation for XOR is.. XOR\\n\\nIt means that $(x \\\\oplus a) \\\\oplus a = x$ (because $a \\\\oplus a = 0$). Basically, you can cancel the operation \\u201C$\\\\oplus a$\\u201D by applying it a second time.\\nThis will prove very useful indeed to reverse the derived array into the original one!\\n\\n# Let\\'s draw an example \\n\\nLet\\u2019s visualize the situation. We have the knowledge of a derived array `d=[0,1,0,0,1,0]` that is constructed from an potential (unknown) original array `o` as such:\\n![step0.png](https://assets.leetcode.com/users/images/27bfa739-8849-44e4-9371-c41bd0babccc_1684037089.1706958.png)\\n\\nWe want to deduce the original array `o` from the derived one and see if it is valid. Well, having determined the reverse operation is sure gonna be useful for that! But we need a starting point\\u2026 \\n**Let\\u2019s first assume that the first element in the original array was 0**. Then we can compute the next element by using the reverse operation $\\\\oplus 0$, that is to say `o[1]=d[0]^0`. \\nHave a look:\\n![step1.png](https://assets.leetcode.com/users/images/634d5b31-5874-41f7-bef4-5ea6a1876a67_1684037140.3522964.png)\\n\\nThat\\u2019s great because we can just repeat that procedure with the newly obtained element:\\n![step2.png](https://assets.leetcode.com/users/images/ceda5252-3195-4763-b252-7203e2fcb906_1684037171.1177502.png)\\n\\n\\nYou get the drill! At each step, we can reconstruct the original array further using knowledge of the previous elements and our reverse operation! The whole procedure is shown below:\\n\\nstep3:\\n![step3.png](https://assets.leetcode.com/users/images/ef9291b8-b1fa-45aa-b51e-9951bb569124_1684037237.0331168.png)\\n\\nstep4:\\n![step4.png](https://assets.leetcode.com/users/images/b683451f-e341-4b98-9bde-1ce30f055525_1684037245.0338237.png)\\n\\nstep5:\\n![step5.png](https://assets.leetcode.com/users/images/310b523f-3453-4208-891e-c526ec159927_1684037251.8169003.png)\\n\\n\\n\\n\\nEventually, we are able to reconstruct the whole array. In our case, we got `o=[0,0,1,1,1,0]`.\\nNow how do we know if it is valid? Well, we didn\\u2019t yet use the last value of our derived array to reconstruct the orginal one (check again the graphical  steps above if you don\\'t believe me!). That is our validity condition!  \\n\\nWe check if the last element of the original array XOR the first gives us the result in the last square indeed `o[0]^o[-1]==d[-1]`. \\nIf yes, the array is valid (it is valid in our case). **If not, try again assuming that the first value was 1!**\\nAnd that\\u2019s all, we covered every case! If we can\\'t find a valid original array starting with either 0 or 1, it means there\\'s no possible original array\\n\\nDo feel free to upvote if that helped you visualize and understand what is going on!\\n\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1). We don\\'t need to explicitly reconstruct the original array (which would be O(n) space), because at each step we only use the value at the previous index, so a single variable is enough to hold it\\n\\n# Code\\n```\\nclass Solution:\\n    def doesValidArrayExist(self, derived: List[int]) -> bool:\\n        \\n        #we try 0 and 1 as potential first elements\\n        for first in [0,1]:\\n            original=first\\n            for result in derived[:-1]:\\n                #we apply the reverse operation as shown in the pictures\\n                original=original^result\\n            #finally, we check if the validity condtion is true\\n            if original^first==derived[-1]:\\n                return True\\n        return False\\n        \\n```\\n\\n# Other great solutions:\\nYou can find a [different thought process explained here](https://leetcode.com/problems/neighboring-bitwise-xor/solutions/3521867/full-thought-process-one-line-solution/) or [more formally proven here](https://leetcode.com/problems/neighboring-bitwise-xor/solutions/3521882/c-java-python-explanation-with-formal-proof-one-liner-time-o-n/).\\nThose solutions are great because they are more \"parcimonious\". They do not reconstruct the original array (which the problem doesn\\'t require), so it leads to shorter solutions.\\nThey rely on the idea that if the array has been derived from an original array, then the whole XOR aggregation must be zero: $d[0] \\\\oplus d[1] \\\\oplus ... \\\\oplus d[n] == 0$.\\nIf you have followed this solution, can you see why? Take another look at the images if you need it or just check out the links ;)\\nLee has an [even slightly craftier version](https://leetcode.com/problems/neighboring-bitwise-xor/solutions/3522095/java-c-python-sum-is-even/) \\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def doesValidArrayExist(self, derived: List[int]) -> bool:\\n        \\n        #we try 0 and 1 as potential first elements\\n        for first in [0,1]:\\n            original=first\\n            for result in derived[:-1]:\\n                #we apply the reverse operation as shown in the pictures\\n                original=original^result\\n            #finally, we check if the validity condtion is true\\n            if original^first==derived[-1]:\\n                return True\\n        return False\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3521882,
                "title": "c-java-python-explanation-with-formal-proof-one-liner-time-o-n",
                "content": "# Intuition\\n`derived` array is given as\\n```\\n[a[0] ^ a[1],\\n a[1] ^ a[2],\\n a[2] ^ a[3],\\n .\\n .\\n .\\n a[n - 2] ^ a[n - 1]\\n a[n - 1] ^ a[0]]\\n```\\nTake Bitwise-XOR of `derived` array.\\nSince `x ^ x = 0` and `x ^ 0 = x`.\\nUse these properties to cancel out `a[1], a[2], ..., a[n - 1]`.\\n\\n![image.png](https://assets.leetcode.com/users/images/be63ea49-544b-415a-96c7-4a7052270812_1684167829.023799.png)\\n\\nWe will be left with `a[0] ^ a[0] = 0`.\\n\\nSo Bitwise-XOR of derived array should be `0` for `original` to exist.\\n\\n**Proof of why this is a necessary condition**\\nIf Bitwise-XOR comes `1` then it means there is some `a[i]` which didn\\'t find it\\'s another `a[i]` to cancel each other, meaning `a[i] != a[i]` which is a contradiction. So, for any possible `original` array, `derived` array\\'s Bitwise-XOR will always be `0`. If it is not, that means `original` does not exists.\\n\\n**Proof of why this is a sufficient condition**\\nCredits to [@Andimeo](/Andimeo) for pointing this out. I will also try to generate `original` array from `derived`.\\n\\n> I will be using this identity which says:\\nIf `x ^ y = z`, then `y ^ z = x` and `x ^ z = y`.\\nProof: `y ^ z = y ^ (x ^ y) = x`\\nMeans we can shuffle `x`, `y`, and `z` any way we want.\\n\\nWe have to make `[a[0], a[1], a[2], ..., a[n - 1]]`\\nLet\\'s assume `a[0] = a[0]`. ~(Haha, really?)~ I mean just let\\'s say we don\\'t bother calculating `a[0]`.\\nAlso, we are given `[d[0], d[1], d[2], ..., d[n - 1]]`\\n\\n- If `d[0] = a[0] ^ a[1]` then `a[1] = a[0] ^ d[0]`.\\n- If `d[1] = a[1] ^ a[2]` then `a[2] = a[1] ^ d[1] = a[0] ^ d[0] ^ d[1]`.\\n- If `d[2] = a[2] ^ a[3]` then `a[3] = a[2] ^ d[2] = a[0] ^ d[0] ^ d[1] ^ d[2]`\\n.\\n.\\n.\\n- `a[n - 1] = a[0] ^ d[0] ^ d[1] ^ d[2] ^ ... ^ d[n - 2]`\\n\\nThe `original` array will be:\\n```\\n[a[0],\\n a[0] ^ d[0],\\n a[0] ^ d[0] ^ d[1],\\n a[0] ^ d[0] ^ d[1] ^ d[2],\\n .\\n .\\n .\\n a[0] ^ d[0] ^ d[1] ^ d[2] ^ ... ^ d[n - 2]]\\n```\\n\\nNow, we know `d[n - 1] = a[n - 1] ^ a[0]`. Put the value of `a[n - 1]` from above:\\n```\\nd[n - 1] = (a[0] ^ d[0] ^ d[1] ^ d[2] ^ ... ^ d[n - 2]) ^ a[0]\\n         =         d[0] ^ d[1] ^ d[2] ^ ... ^ d[n - 2]\\n\\nd[n - 1] ^ 0 = d[0] ^ d[1] ^ d[2] ^ ... ^ d[n - 2]\\nd[0] ^ d[1] ^ d[2] ^ ... ^ d[n - 2] ^ d[n - 1] = 0\\n```\\nHence proved.\\n\\n> Notice how `a[0]` gets cancelled out in equation of `d[n - 1]`? Means value of `a[0]` does not matter. Therefore, for a valid `derived` array, there will be 2 `original` arrays, one with `a[0] = 0` and another with `a[0] = 1`. Also, both of them will be 1\\'s complement of each other.\\n\\n# Code\\n```C++ []\\nclass Solution {\\npublic:\\n    bool doesValidArrayExist(vector<int>& derived) {\\n        return !accumulate(derived.begin(), derived.end(), 0, bit_xor<int>());\\n    }\\n};\\n```\\n```Java []\\nclass Solution {\\n    public boolean doesValidArrayExist(int[] derived) {\\n        int xr = 0;\\n        for (int x: derived) {\\n            xr = xr ^ x;\\n        }\\n        return xr == 0;\\n    }\\n}\\n```\\n```Python []\\nclass Solution:\\n    def doesValidArrayExist(self, derived: List[int]) -> bool:\\n        return not reduce(operator.xor, derived)\\n```\\n\\n# Complexity\\n- Time Complexity: $$O(n)$$\\n- Space Complexity: $$O(1)$$",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "Bit Manipulation"
                ],
                "code": "```\\n[a[0] ^ a[1],\\n a[1] ^ a[2],\\n a[2] ^ a[3],\\n .\\n .\\n .\\n a[n - 2] ^ a[n - 1]\\n a[n - 1] ^ a[0]]\\n```\n```\\n[a[0],\\n a[0] ^ d[0],\\n a[0] ^ d[0] ^ d[1],\\n a[0] ^ d[0] ^ d[1] ^ d[2],\\n .\\n .\\n .\\n a[0] ^ d[0] ^ d[1] ^ d[2] ^ ... ^ d[n - 2]]\\n```\n```\\nd[n - 1] = (a[0] ^ d[0] ^ d[1] ^ d[2] ^ ... ^ d[n - 2]) ^ a[0]\\n         =         d[0] ^ d[1] ^ d[2] ^ ... ^ d[n - 2]\\n\\nd[n - 1] ^ 0 = d[0] ^ d[1] ^ d[2] ^ ... ^ d[n - 2]\\nd[0] ^ d[1] ^ d[2] ^ ... ^ d[n - 2] ^ d[n - 1] = 0\\n```\n```C++ []\\nclass Solution {\\npublic:\\n    bool doesValidArrayExist(vector<int>& derived) {\\n        return !accumulate(derived.begin(), derived.end(), 0, bit_xor<int>());\\n    }\\n};\\n```\n```Java []\\nclass Solution {\\n    public boolean doesValidArrayExist(int[] derived) {\\n        int xr = 0;\\n        for (int x: derived) {\\n            xr = xr ^ x;\\n        }\\n        return xr == 0;\\n    }\\n}\\n```\n```Python []\\nclass Solution:\\n    def doesValidArrayExist(self, derived: List[int]) -> bool:\\n        return not reduce(operator.xor, derived)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3521867,
                "title": "full-thought-process-one-line-solution",
                "content": "# Properties About XOR\\n\\nThe operator XOR has the following property:\\n\\n```\\nA xor A = 0\\n```\\n\\nalso,\\n\\n```\\nA xor A xor B xor B = 0\\n```\\n\\nThe order of which we place `A` or `B` does not matter. This means:\\n\\n```\\nA xor B xor B xor A = 0\\n```\\n\\nWe can reason about this because, when we have the same value in the xor formula even number of times, their bits \"cancel\" each other out and gives us 0. And, for any number `x`,  `x xor 0` will just give us `x`.\\n\\n# Derived Array and Original Array\\n\\nIn the derived array, since `derived[0] = original[0] xor original[1]`, `derived[1] = original[1] xor original[2]`, ..., `derived[n] = original[n] xor original[0]`, we notice that for a valid derived array, when we `xor` all elements in the derived array, we must obtain 0.\\n\\nSuppose that we have an original array `[A B C D]`. The derived array, by definition, will be `[A xor B, B xor C, C xor D, D xor A]`. When we `xor` all elements in the derived array, we are calculating `A xor B` xor `B xor C` xor `C xor D` xor `D xor A`. We can see that every member of the original array appeared twice in the xor formula.\\n\\nNow, please take time to convince yourself that\\n(1) For all original arrays, xor(derived) **must** be equal to 0; and\\n(2) For all derived arrays, if xor(derived) != 0, then the derived array **must not** be valid.\\n\\n# Algorithm\\n\\n```python3\\ndef doesValidArrayExist(self, derived: List[int]) -> bool:\\n    return reduce(operator.xor, derived) == 0\\n```\\n\\n`reduce(operator.xor, derived)` finds the `xor(derived)` as mentioned above.\\n\\n**Please give an upvote** if this post helps you understand the thought process behind my solution. Thanks for your help for more content to come!\\n\\n**Other Great Solutions**\\nSome of my learnings too:\\n1. I noticed that we haven\\'t fully utilized the \"binary array\" condition. @lee215 gives an awesome solution on utilizing the sum of the array: https://leetcode.com/problems/neighboring-bitwise-xor/solutions/3522095/java-c-python-sum-is-even\\n2. If you\\'d like a visualization, @cartesPerforees drew a great diagram: https://leetcode.com/problems/neighboring-bitwise-xor/solutions/3522096/illustrated-step-by-step-solution\\n\\nI hope this really helps your LeetCode journey! Please keep going.\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nA xor A = 0\\n```\n```\\nA xor A xor B xor B = 0\\n```\n```\\nA xor B xor B xor A = 0\\n```\n```python3\\ndef doesValidArrayExist(self, derived: List[int]) -> bool:\\n    return reduce(operator.xor, derived) == 0\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3522054,
                "title": "xor-of-all-java-python-c-simple-approach",
                "content": "# Intuition\\nXor of all the elements should be zero.\\n\\n# Approach\\nlet\\'s us take original = [a,b,c,d,e]\\n        \\nthen derived = [a ^ b, b ^ c, c ^ d, d ^ e, e ^ a] \\n        \\nIf we perform XOR operation of all the elements of derived array then result should be zero beacause\\n        \\na ^ b ^ b ^ c ^ c ^ d ^ d ^ e ^ e ^ a = 0 \\n        \\nHence if it results in zero then we can form the original array. \\n\\n**Solution (Java):**\\n\\n\\n\\n```\\nclass Solution {\\npublic:\\n    boolean doesValidArrayExist(int[] derived) {\\n        int total = 0;\\n        for(int i = 0; i < derived.length; i++)\\n            total = total ^ derived[i];\\n        return total == 0;\\n    }\\n};\\n```\\n\\n\\n**Solution (C++):**\\n\\n\\n```\\nclass Solution {\\npublic:\\n    boolean doesValidArrayExist(vector<int>& derived) {\\n        int total = 0;\\n        for(int &a: derived)\\n            total = total ^ a;\\n        return total == 0;\\n    }\\n};\\n```\\n\\n\\n**Solution (Python):**\\n\\n```\\ntotal = 0 \\nfor i in derived:\\n    total = total ^ i\\n            \\nreturn total == 0\\n```\\n\\n**One liner (python):**\\n\\n```\\nreturn reduce(operator.xor, derived) == 0\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    boolean doesValidArrayExist(int[] derived) {\\n        int total = 0;\\n        for(int i = 0; i < derived.length; i++)\\n            total = total ^ derived[i];\\n        return total == 0;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    boolean doesValidArrayExist(vector<int>& derived) {\\n        int total = 0;\\n        for(int &a: derived)\\n            total = total ^ a;\\n        return total == 0;\\n    }\\n};\\n```\n```\\ntotal = 0 \\nfor i in derived:\\n    total = total ^ i\\n            \\nreturn total == 0\\n```\n```\\nreturn reduce(operator.xor, derived) == 0\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3521940,
                "title": "explained-simple",
                "content": "<b>Up vote if you like the solution</b>\\n\\n# Approach \\n1. Assume the 0th index value is 0 ( as status ).\\n2. Then keep traking the status variable by following ( basically toggle the value of status):\\n   - when the dervied is 1 & status is 0 then change it to 1.\\n   - when the derived is 1 & status is 1 then change it to 0.\\n3. At the end of the traverse, then final reault of status should be same as the inital ( that is 0)\\n       if that is the case then return true other wise return false.\\n    \\n    \\n# Code\\n\\n```\\nbool doesValidArrayExist(vector<int>& derived) {\\n    int status = 0;\\n    for(auto n: derived) status = (status + n)%2;\\n    return (status == 0);\\n}\\n```\\n\\n<b>Here is an article of my last interview experience - A Journey to FAANG Company, I recomand you to go through this to know which all resources I have used & how I cracked interview at Amazon:\\nhttps://leetcode.com/discuss/interview-experience/3171859/Journey-to-a-FAANG-Company-Amazon-or-SDE2-(L5)-or-Bangalore-or-Oct-2022-Accepted",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nbool doesValidArrayExist(vector<int>& derived) {\\n    int status = 0;\\n    for(auto n: derived) status = (status + n)%2;\\n    return (status == 0);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3521942,
                "title": "one-liner",
                "content": "I originally solved by restoring the array, assuming we start either from `0` or `1`.\\n\\nThen, I realized that we can simplify the check - we can always build the array if we have an even number of `1`.\\n\\n## One-Liner\\n**C++**\\n```cpp\\nbool doesValidArrayExist(vector<int>& derived) { \\n    return accumulate(begin(derived), end(derived), 0, bit_xor<>()) == 0;\\n}\\n```\\n\\n## Original Solution\\n**C++**\\n```cpp\\nbool check(vector<int>& derived, int i, int start, int cur) {\\n    if (i + 1 == derived.size())\\n        return start ^ cur == derived[i];\\n    return check(derived, i + 1, start, cur ^ derived[i]);\\n}\\nbool doesValidArrayExist(vector<int>& derived) {\\n    return check(derived, 0, 0, 0) || check(derived, 0, 1, 1);\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```cpp\\nbool doesValidArrayExist(vector<int>& derived) { \\n    return accumulate(begin(derived), end(derived), 0, bit_xor<>()) == 0;\\n}\\n```\n```cpp\\nbool check(vector<int>& derived, int i, int start, int cur) {\\n    if (i + 1 == derived.size())\\n        return start ^ cur == derived[i];\\n    return check(derived, i + 1, start, cur ^ derived[i]);\\n}\\nbool doesValidArrayExist(vector<int>& derived) {\\n    return check(derived, 0, 0, 0) || check(derived, 0, 1, 1);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3522147,
                "title": "fast-and-simple-o-n-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\no(N)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\no(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool doesValidArrayExist(vector<int>& d) {\\n       int m=0;\\n        for(auto x:d)\\n            m^=x;\\n        if(m==0)return 1;\\n        else return 0;\\n       \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool doesValidArrayExist(vector<int>& d) {\\n       int m=0;\\n        for(auto x:d)\\n            m^=x;\\n        if(m==0)return 1;\\n        else return 0;\\n       \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3522838,
                "title": "just-count-how-many-ones-java-simple-o-n",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nEvery time you met 1, you have to make sure the next neigbor from original different than this prev neigbor from original.\\nEvery time you met 0, you have to make sure the next neigbor from original SAME with this prev neigbor from original.\\nThe last neig will be the first original number. That means you have to change even times to come back, that is even times of 1.\\n\\nSo keep it simple, you just need count how many 1s. True if Even Counts of ONEs.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n# Code\\n```\\nclass Solution {\\n    public boolean doesValidArrayExist(int[] derived) {\\n        int cnt = 0;\\n        for (int n : derived) if (n == 1) cnt++;\\n        return cnt % 2 == 0;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean doesValidArrayExist(int[] derived) {\\n        int cnt = 0;\\n        for (int n : derived) if (n == 1) cnt++;\\n        return cnt % 2 == 0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3521955,
                "title": "cpp-count-1-s",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: `O(n)`\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: `O(1)`\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool doesValidArrayExist(vector<int>& v) {\\n        int xr = 0;\\n        for(int x : v) xr ^= x;\\n        return xr == 0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool doesValidArrayExist(vector<int>& v) {\\n        int xr = 0;\\n        for(int x : v) xr ^= x;\\n        return xr == 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3532393,
                "title": "python-3-1-line-w-proof-t-m-84-82",
                "content": "This problem is much more a mathematics problem than a coding problem. The solution is`true` if the count of ones in`derived` is even and`false`otherwise. Here\\'s the proof:\\n\\nThe`xor`operator has these identities:\\n```\\n(1)         a xor 0 =  a                (0 is the xor-identity element)\\n(2)         a xor 1 = ~a                (xor with 1 flips the other digit)\\n(3)         a xor a = 0                 (a is its own xor-inverse)\\n(4) (a xor b) xor c = a xor (b xor c)   (xor is associative)\\n\\n```\\nUsing (3) and (4)), one can assert that the constraint`derived[i] = original[i] \\u2295 original[i+1]`implies that\\n```\\n(*)            original[i+1] = original[i] \\u2295 derived[i].\\n(**)             original[0] = original[n-1] \\u2295 derived[n-1].\\n```\\nWe can use (*) to iteratively construct`original` from derived.\\n\\nSuppose that`derived = [1,0,1,0,0]`and we arbitrally assign`original[0] = 1`. Then:\\n ```\\n                                                   derived = [1, 0,1,0,0]\\n                                                  original = [1, _,_,_,_]\\n\\n    original[1] = original[0] \\u2295 derived[0] = 1 \\u2295 1 = 0       [1,0, 1,0,0] \\n                                                             [1,0, _,_,_]\\n\\n    original[2] = original[1] \\u2295 derived[1] = 0 \\u2295 0 = 0       [1,0,1, 0,0]\\n                                                             [1,0,0, _,_]\\n     \\n    original[3] = original[2] \\u2295 derived[2] = 1 \\u2295 1 = 1       [1,0,1,0, 0]\\n                                                             [1,0,0,1, _]\\n\\n    original[4] = original[3] \\u2295 derived[3] = 0 \\u2295 0 = 1       [1,0,1,0,0 ]\\n                                                             [1,0,0,1,1 ]\\n```\\nThus`original = [1,0,0,0,1]`is a possible solution: It remains to check (**):\\n\\n```\\n    original[0] = 1 =? original[4] \\u2295 derived[4] =? 0 \\u2295 0 = 1.\\n```\\nThus,`original = [1,0,0,1,0]` is a valid solution. \\n\\nNote that by (1), `derived[i] = 0` causes `original[i+1]` to be the same as `original[i]` and that by (2), `derived[i] = 1` causes `original[i+1]` to be the flip of `original[i]`. It\\'s not diffcult to see that (**) is true if and only if the number of flips is even, or equivalently *the count of ones in `derived` is an even integer.*\\n\\nIt\\'s worth asking what happens if we had arbitrally assigned`original[0] = 0` instead of one. (Hint: there\\'s either exactly zero or exactly two solutions for any given `derived`).\\n\\nThe code:\\n\\n```\\nclass Solution:\\n    def doesValidArrayExist(self, derived: List[int]) -> bool:\\n        \\n        return  sum(derived)%2^1\\n```\\n[https://leetcode.com/problems/neighboring-bitwise-xor/submissions/951729349/](http://)\\n\\nPython 3   ||   1 line,  w/ proof   ||   T/M: 84% / 82%\\n\\nI could be wrong, but I think that time complexity is *O*(*N*) and space complexity is *O*(1).",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n(1)         a xor 0 =  a                (0 is the xor-identity element)\\n(2)         a xor 1 = ~a                (xor with 1 flips the other digit)\\n(3)         a xor a = 0                 (a is its own xor-inverse)\\n(4) (a xor b) xor c = a xor (b xor c)   (xor is associative)\\n\\n```\n```\\n(*)            original[i+1] = original[i] \\u2295 derived[i].\\n(**)             original[0] = original[n-1] \\u2295 derived[n-1].\\n```\n```\\n                                                   derived = [1, 0,1,0,0]\\n                                                  original = [1, _,_,_,_]\\n\\n    original[1] = original[0] \\u2295 derived[0] = 1 \\u2295 1 = 0       [1,0, 1,0,0] \\n                                                             [1,0, _,_,_]\\n\\n    original[2] = original[1] \\u2295 derived[1] = 0 \\u2295 0 = 0       [1,0,1, 0,0]\\n                                                             [1,0,0, _,_]\\n     \\n    original[3] = original[2] \\u2295 derived[2] = 1 \\u2295 1 = 1       [1,0,1,0, 0]\\n                                                             [1,0,0,1, _]\\n\\n    original[4] = original[3] \\u2295 derived[3] = 0 \\u2295 0 = 1       [1,0,1,0,0 ]\\n                                                             [1,0,0,1,1 ]\\n```\n```\\n    original[0] = 1 =? original[4] \\u2295 derived[4] =? 0 \\u2295 0 = 1.\\n```\n```\\nclass Solution:\\n    def doesValidArrayExist(self, derived: List[int]) -> bool:\\n        \\n        return  sum(derived)%2^1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3522565,
                "title": "c-no-of-1-s-odd-or-even-easy-to-uderstand",
                "content": "get no of 1\\'s is odd or even.\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool doesValidArrayExist(vector<int>& v) {\\n        int x = 0;\\n        for(auto &i: v)x ^= i;\\n        return (x==0);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool doesValidArrayExist(vector<int>& v) {\\n        int x = 0;\\n        for(auto &i: v)x ^= i;\\n        return (x==0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3522031,
                "title": "easy-and-fast-solution-o-n-time-o-1-space",
                "content": "# Approach\\nwe just need to try it but remember that 0 ^ 1 is same as 1 ^ 0 so it doesn\\'t matter how we start because we need to know if it\\'s true or false so it\\'s like easy 1d dp like fib problem\\n\\n# Code\\n```\\nvar doesValidArrayExist = function(derived) {\\n    let n = derived.length;\\n    let original = 1\\n    for(let i = 1; i < n; i++){\\n        original = original ^ derived[i - 1];\\n    }\\n    return 1 ^ original == derived[n - 1];\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar doesValidArrayExist = function(derived) {\\n    let n = derived.length;\\n    let original = 1\\n    for(let i = 1; i < n; i++){\\n        original = original ^ derived[i - 1];\\n    }\\n    return 1 ^ original == derived[n - 1];\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3521965,
                "title": "easy-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean doesValidArrayExist(int[] de) {\\n        int ans=0;\\n        for(int a:de){\\n            if(a==1)\\n                ans++;\\n        }\\n        return (ans%2==0);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean doesValidArrayExist(int[] de) {\\n        int ans=0;\\n        for(int a:de){\\n            if(a==1)\\n                ans++;\\n        }\\n        return (ans%2==0);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3522108,
                "title": "pen-paper-explaination-easy-c-code",
                "content": "### DO UPVOTE If you find it useful !\\n![image.png](https://assets.leetcode.com/users/images/d5e0ef66-cb2a-4872-a1fe-146495608ef5_1684037490.8005672.png)\\n\\n\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool doesValidArrayExist(vector<int>& d) {\\n        int n=d.size();\\n        bool chk=d[0];\\n        for(int i=1 ; i<n; i++){\\n            chk=chk^(d[i]);\\n        }\\n        return !chk;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool doesValidArrayExist(vector<int>& d) {\\n        int n=d.size();\\n        bool chk=d[0];\\n        for(int i=1 ; i<n; i++){\\n            chk=chk^(d[i]);\\n        }\\n        return !chk;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3522094,
                "title": "c-pure-implementation-easy-to-understand",
                "content": "## Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool doesValidArrayExist(vector<int>& derived) {\\n        vector<int> ori;\\n        int n= derived.size();\\n        ori.push_back(1);\\n        for (int i=0; i<n-1; i++){\\n            int el= ori[i];\\n            if (derived[i]==0){\\n                ori.push_back(el);\\n            }\\n            else{\\n                ori.push_back(!el);\\n            }\\n        }\\n        if (derived[n-1]==0){\\n            return (ori[0]==ori[n-1]);\\n        }\\n        return (ori[0]!=ori[n-1]);\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Math",
                    "Brainteaser",
                    "Simulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool doesValidArrayExist(vector<int>& derived) {\\n        vector<int> ori;\\n        int n= derived.size();\\n        ori.push_back(1);\\n        for (int i=0; i<n-1; i++){\\n            int el= ori[i];\\n            if (derived[i]==0){\\n                ori.push_back(el);\\n            }\\n            else{\\n                ori.push_back(!el);\\n            }\\n        }\\n        if (derived[n-1]==0){\\n            return (ori[0]==ori[n-1]);\\n        }\\n        return (ori[0]!=ori[n-1]);\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3521915,
                "title": "day-409-easy-100-python-java-c-explained",
                "content": "# Please Upvote as it really motivates me \\uD83C\\uDD99\\uD83C\\uDD99\\uD83C\\uDD99\\n# Intuition &  Approach\\n<!-- Describe your approach to solving the problem. -->\\nhey create an array A of the same size as D and fill it using the XOR operation. Then they iterate over A and D to check if the XOR of adjacent elements in A matches the corresponding element in D. If all elements match, the function returns true, otherwise it returns false.\\n\\n# Complexity\\n- Time complexity:o(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:o(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```java []\\npublic boolean doesValidArrayExist(int[] D) {\\n    int n = D.length;\\n    int A[] = new int[n];\\n    for(int i=0;i<n-1;i++){\\n        A[i+1]=(A[i]^D[i]);\\n    }\\n    for(int i=0;i<n;i++){\\n        int ni= (i+1)%n;\\n        if((A[i]^A[ni])!=D[i]) return false;\\n    }return true;\\n}\\n```\\n```c++ []\\nbool doesValidArrayExist(vector<int>& D) {\\n    int n = D.size();\\n    vector<int> A(n, 0);\\n    for (int i = 0; i < n - 1; i++) {\\n        A[i + 1] = A[i] ^ D[i];\\n    }\\n    for (int i = 0; i < n; i++) {\\n        int ni = (i + 1) % n;\\n        if ((A[i] ^ A[ni]) != D[i]) {\\n            return false;\\n        }\\n    }\\n    return true;\\n}\\n```\\n```python []\\ndef doesArrayExist(D: List[int]) -> bool:\\n    n = len(D)\\n    A = [0] * n\\n    for i in range(n - 1):\\n        A[i + 1] = A[i] ^ D[i]\\n    for i in range(n):\\n        ni = (i + 1) % n\\n        if (A[i] ^ A[ni]) != D[i]:\\n            return False\\n    return True",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Python3"
                ],
                "code": "```java []\\npublic boolean doesValidArrayExist(int[] D) {\\n    int n = D.length;\\n    int A[] = new int[n];\\n    for(int i=0;i<n-1;i++){\\n        A[i+1]=(A[i]^D[i]);\\n    }\\n    for(int i=0;i<n;i++){\\n        int ni= (i+1)%n;\\n        if((A[i]^A[ni])!=D[i]) return false;\\n    }return true;\\n}\\n```\n```c++ []\\nbool doesValidArrayExist(vector<int>& D) {\\n    int n = D.size();\\n    vector<int> A(n, 0);\\n    for (int i = 0; i < n - 1; i++) {\\n        A[i + 1] = A[i] ^ D[i];\\n    }\\n    for (int i = 0; i < n; i++) {\\n        int ni = (i + 1) % n;\\n        if ((A[i] ^ A[ni]) != D[i]) {\\n            return false;\\n        }\\n    }\\n    return true;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3521880,
                "title": "check-xor-0-or-not",
                "content": "```\\nclass Solution \\n{\\n    public boolean doesValidArrayExist(int[] derived)\\n    {\\n        int xor =0;\\n        for(int d: derived)\\n        {\\n           xor ^= d;\\n        }\\n        return xor == 0;\\n    }\\n}\\n/*\\nlet original array be ;  arr \\nDerived be drr :  \\n\\n drr[0] = arr[0] ^ arr[1] ;\\n drr[1] = arr[1] ^ arr[2] ;\\n ........ \\n ........\\n     \\n drr[n-1] = arr[n-1] ^ arr[0];\\n\\nif u do xor separtely for both sides L.H.S and R.H.S\\n\\ndrr[0] ^ drr[1] ^... drr[n-1] = 0\\n*/\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution \\n{\\n    public boolean doesValidArrayExist(int[] derived)\\n    {\\n        int xor =0;\\n        for(int d: derived)\\n        {\\n           xor ^= d;\\n        }\\n        return xor == 0;\\n    }\\n}\\n/*\\nlet original array be ;  arr \\nDerived be drr :  \\n\\n drr[0] = arr[0] ^ arr[1] ;\\n drr[1] = arr[1] ^ arr[2] ;\\n ........ \\n ........\\n     \\n drr[n-1] = arr[n-1] ^ arr[0];\\n\\nif u do xor separtely for both sides L.H.S and R.H.S\\n\\ndrr[0] ^ drr[1] ^... drr[n-1] = 0\\n*/\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3859871,
                "title": "simple-java-solution-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean doesValidArrayExist(int[] derived) {\\n       int currXor=0;\\n       for(int i: derived)\\n        currXor ^= i;\\n        return currXor==0;\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean doesValidArrayExist(int[] derived) {\\n       int currXor=0;\\n       for(int i: derived)\\n        currXor ^= i;\\n        return currXor==0;\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3693512,
                "title": "best-c-solution-approach-easily-explained-beats-90",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nLets consider the first example:\\nSay `original = [a, b, c]` and given is `derived = [1, 1, 0]`\\nNow, it is given that `derived[i] = original[i]^original[i+1]` for all and `dervied[n-1] = original[n-1]^original[0] `\\nWe can see that `a^b = 1` Similarly `b^c = 1 and c^a = 0`\\nNow, if we perform XOR of all these equations then it must result in 0. \\n\\n## **Proof** \\n`(a^b) ^ (b^c) ^ (c^a) = (a^a) ^ (b^b) ^ (c^c) = 0`\\nNow, if you observe,` a^b = 1, b^c = 1 and c^a = 0` are the elements of derived array and hence must give **XOR of all elements equal to zero.**\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool doesValidArrayExist(vector<int>& derived) {\\n        int ans = 0;\\n        for(int i=0; i<derived.size(); i++)\\n            ans ^= derived[i];\\n        return ans==0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool doesValidArrayExist(vector<int>& derived) {\\n        int ans = 0;\\n        for(int i=0; i<derived.size(); i++)\\n            ans ^= derived[i];\\n        return ans==0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3686249,
                "title": "c-easy-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool doesValidArrayExist(vector<int>& derived) {\\n        int x=0;\\n\\n        for(int i=0; i<derived.size();i++){\\n            x^=derived[i];\\n        }\\n\\n        if(x==0){\\n            return true;\\n        }\\n\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool doesValidArrayExist(vector<int>& derived) {\\n        int x=0;\\n\\n        for(int i=0; i<derived.size();i++){\\n            x^=derived[i];\\n        }\\n\\n        if(x==0){\\n            return true;\\n        }\\n\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3653902,
                "title": "xorr",
                "content": "```\\nclass Solution {\\npublic:\\n    bool doesValidArrayExist(vector<int>& derived) {\\n        int xoor = 0;\\n        for (auto i: derived) xoor ^= i;\\n        return !xoor;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool doesValidArrayExist(vector<int>& derived) {\\n        int xoor = 0;\\n        for (auto i: derived) xoor ^= i;\\n        return !xoor;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3549808,
                "title": "neighboring-bitwise-xor-c",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    bool doesValidArrayExist(vector<int>& derived) {\\n        bool res=true;\\n        int n=derived.size();\\n        if(n==1)\\n        {\\n            if(derived[0]==0)\\n            {\\n                return true;\\n            }\\n            return false;\\n        }\\n        vector<int> temp(n);\\n        if(derived[0]==0)\\n        {\\n            temp[0]=1;\\n            temp[1]=1;\\n        }\\n        else\\n        {\\n            temp[0]=1;\\n            temp[1]=0;\\n        }\\n        for(int i=1;i<n-1;i++)\\n        {\\n            int val=temp[i];\\n            if(derived[i]==0)\\n            {\\n                temp[i+1]=val;\\n            }\\n            else\\n            {\\n                if(val==0)\\n                {\\n                    temp[i+1]=1;\\n                }\\n                else\\n                {\\n                    temp[i+1]=0;\\n                }\\n            }\\n        }\\n        int last=temp[n-1]^temp[0];\\n        if(last==derived[n-1])\\n        {\\n            return true;\\n        }\\n        \\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Array",
                    "Math",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool doesValidArrayExist(vector<int>& derived) {\\n        bool res=true;\\n        int n=derived.size();\\n        if(n==1)\\n        {\\n            if(derived[0]==0)\\n            {\\n                return true;\\n            }\\n            return false;\\n        }\\n        vector<int> temp(n);\\n        if(derived[0]==0)\\n        {\\n            temp[0]=1;\\n            temp[1]=1;\\n        }\\n        else\\n        {\\n            temp[0]=1;\\n            temp[1]=0;\\n        }\\n        for(int i=1;i<n-1;i++)\\n        {\\n            int val=temp[i];\\n            if(derived[i]==0)\\n            {\\n                temp[i+1]=val;\\n            }\\n            else\\n            {\\n                if(val==0)\\n                {\\n                    temp[i+1]=1;\\n                }\\n                else\\n                {\\n                    temp[i+1]=0;\\n                }\\n            }\\n        }\\n        int last=temp[n-1]^temp[0];\\n        if(last==derived[n-1])\\n        {\\n            return true;\\n        }\\n        \\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3538437,
                "title": "by-finding-original-array-c-bitwise",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool doesValidArrayExist(vector<int>& derived) {\\n        int n = derived.size();\\n        vector<int> ori(n,0);\\n        if(n > 1)\\n        ori[1] = derived[0]^ori[0];\\n        for(int i = 2;i < n;i++){\\n            ori[i] = ori[i-1]^derived[i-1];\\n        }\\n        for(int i = 0;i < n-1;i++){\\n            if(ori[i]^ori[i+1] != derived[i])\\n            return false;\\n        }\\n        if(ori[n-1]^ori[0] != derived[n-1])\\n        return false;\\n        \\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool doesValidArrayExist(vector<int>& derived) {\\n        int n = derived.size();\\n        vector<int> ori(n,0);\\n        if(n > 1)\\n        ori[1] = derived[0]^ori[0];\\n        for(int i = 2;i < n;i++){\\n            ori[i] = ori[i-1]^derived[i-1];\\n        }\\n        for(int i = 0;i < n-1;i++){\\n            if(ori[i]^ori[i+1] != derived[i])\\n            return false;\\n        }\\n        if(ori[n-1]^ori[0] != derived[n-1])\\n        return false;\\n        \\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3535178,
                "title": "python-simple-and-clean-beats-99-99",
                "content": "### Please upvote if you find this helpful. \\u270C\\n<img src=\"https://assets.leetcode.com/users/images/b8e25620-d320-420a-ae09-94c7453bd033_1678818986.7001078.jpeg\" alt=\"Cute Robot - Stable diffusion\" width=\"200\"/>\\n\\n*This is an NFT*\\n\\n# Intuition\\nThe problem asks us to determine whether there exists a valid binary array `original` that could have formed a given array `derived` by computing the bitwise XOR of adjacent values in `original`. Our first thought might be to check if the sum of all elements in `derived` is even. If it is, then there must be an even number of 1\\'s in `original` and a valid binary array `original` exists.\\n\\n# Approach\\n1. We can use the property that if the sum of all elements in `derived` is even, then there must be an even number of 1\\'s in `original`.\\n2. To see why this property holds, let\\'s consider two cases:\\n    - If there are an even number of 1\\'s in `original`, then each pair of adjacent 1\\'s will cancel out when computing the bitwise XOR. This means that the sum of all elements in `derived` will be even.\\n    - If there are an odd number of 1\\'s in `original`, then all but one pair of adjacent 1\\'s will cancel out when computing the bitwise XOR. This means that the sum of all elements in `derived` will be odd.\\n3. Therefore, if the sum of all elements in `derived` is even, then there must be an even number of 1\\'s in `original`, and a valid binary array `original` exists.\\n\\n# Complexity\\n- Time complexity: $$O(n)$$ where n is the length of the array `derived`. This is because we need to compute the sum of all elements in `derived`, which takes $$O(n)$$ time.\\n- Space complexity: $$O(1)$$ since we only use a constant amount of extra space.\\n\\n# Code\\n```\\nclass Solution:\\n    def doesValidArrayExist(self, derived: List[int]) -> bool:\\n        return sum(derived)%2 == 0\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Bit Manipulation",
                    "Bitmask"
                ],
                "code": "```\\nclass Solution:\\n    def doesValidArrayExist(self, derived: List[int]) -> bool:\\n        return sum(derived)%2 == 0\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3526322,
                "title": "java-easy-approch",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean doesValidArrayExist(int[] derived) {\\n        int original = 0;\\n        for(int i =0;i<derived.length;i++){\\n            original = original ^ derived[i];\\n        }\\n        if(original == 0){\\n            return true;\\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean doesValidArrayExist(int[] derived) {\\n        int original = 0;\\n        for(int i =0;i<derived.length;i++){\\n            original = original ^ derived[i];\\n        }\\n        if(original == 0){\\n            return true;\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3525924,
                "title": "python-simulation-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe can start with an arbitary original[0] and iteratively calculate original[n - 1] from the formula derived[i] = original[i] \\u2295 original[i + 1].\\nThe only thing we need to check is if derived[n - 1] = original[n - 1] \\u2295 original[0]. Since we\\'ve fixed original[0] = 1, we can write derived[n - 1] = original[n - 1] \\u2295 1. The function is true when derived[n - 1] is NOT original[n - 1], or we can say the array is valid if derived[n - 1] \\u2295 original[n - 1] is true. \\n\\n### Example 1:\\n**Input:** derived = [1,1,0]\\n**Output:** true\\n**Explanation:**\\nLet original[0] = 1\\nderived[0] = 1 &rarr; original[1] is NOT original[0] &rarr; original[1] = 0\\nderived[1] = 1 &rarr; original[2] is NOT original[1] &rarr; original[2] = 1\\nFinally we need to check if derived[2] \\u2295 original[2] is true &rarr; 0 \\u2295 1, which is true!\\n\\n### Example 3:\\n**Input:** derived = [1,0]\\n**Output:** false\\n**Explanation:**\\nLet original[0] = 1\\nderived[0] = 1 &rarr; original[1] is NOT original[0] &rarr; original[1] = 0\\nFinally we need to check if derived[1] \\u2295 original[1] is true &rarr; 0 \\u2295 0, which is false!\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def doesValidArrayExist(self, derived: List[int]) -> bool:\\n        b = True\\n        for n in derived:\\n            b = not b if n else b\\n        return b\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def doesValidArrayExist(self, derived: List[int]) -> bool:\\n        b = True\\n        for n in derived:\\n            b = not b if n else b\\n        return b\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3525527,
                "title": "answer-in-2-lines-very-easy-soln",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n     O(1)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool doesValidArrayExist(vector<int>& derived) {\\n        int xorSum = 0;\\n        for (int i = 0; i < derived.size() ; i++)xorSum ^= derived[i];\\n        return xorSum == 0 && (derived[0] == 0 || derived[0] == 1);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool doesValidArrayExist(vector<int>& derived) {\\n        int xorSum = 0;\\n        for (int i = 0; i < derived.size() ; i++)xorSum ^= derived[i];\\n        return xorSum == 0 && (derived[0] == 0 || derived[0] == 1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3524654,
                "title": "c-best-shortest-4-lines-solution-beats-100-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nDONE \\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\njust count the number of 1\\'s and if its even return true else false if odd \\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool doesValidArrayExist(vector<int>& derived) {\\n        int count=0;\\n        for(auto it:derived)\\n        {\\n            if(it==1) count++;\\n        }\\n        if(count&1) return false;\\n        else return true;\\n        \\n    }\\n};\\n```\\n![7abc56.jpg](https://assets.leetcode.com/users/images/2bf81065-0f05-4c07-bf02-71e80f866bc2_1684088543.5221298.jpeg)\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool doesValidArrayExist(vector<int>& derived) {\\n        int count=0;\\n        for(auto it:derived)\\n        {\\n            if(it==1) count++;\\n        }\\n        if(count&1) return false;\\n        else return true;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3524588,
                "title": "c-best-shortest-solution-beats-100-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool doesValidArrayExist(vector<int>& derived) {\\n        int count=0;\\n        for(auto it:derived)\\n        {\\n            if(it==1) count++;\\n        }\\n        if(count&1) return false;\\n        else return true;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool doesValidArrayExist(vector<int>& derived) {\\n        int count=0;\\n        for(auto it:derived)\\n        {\\n            if(it==1) count++;\\n        }\\n        if(count&1) return false;\\n        else return true;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3524555,
                "title": "easy-c-solution-simple-explained",
                "content": "# Intuition\\nJust check original array for length (varying) to observe any pattern.\\nExample :-\\n- for len = 1 -> i) [0] .. true , ii) [1] - false\\n- for len = 2 -> <br>i) [00] - Original array: [00] or [11] <br>ii) [01] & [10] - Original array: Not exist <br>iii) [11] - Original array: [01] or [10]\\n\\nIt can be observed that \\'1\\' must exist in pairs for original array to exist.\\n\\n# Approach\\nJust iterate over array to find occurences of \\'1\\' in array.Return true if even ; else false.\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n\\n- Space complexity: $$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool doesValidArrayExist(vector<int>& derived) {\\n        int n = derived.size(); \\n        \\n        int ones = 0;\\n        for(int i=0;i<n;i++){\\n            if(derived[i] == 1) ones++;\\n        }\\n        if(ones%2 == 0) return true;\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool doesValidArrayExist(vector<int>& derived) {\\n        int n = derived.size(); \\n        \\n        int ones = 0;\\n        for(int i=0;i<n;i++){\\n            if(derived[i] == 1) ones++;\\n        }\\n        if(ones%2 == 0) return true;\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3524050,
                "title": "simplest-proof-xor-of-general-derived-array-even-parity-checking-for-0-1-derived-array",
                "content": "Let original array be:\\n[A, B, C, D, E, F]\\nthen derived array will be:\\n[A\\u2295B, B\\u2295C, C\\u2295D, D\\u2295E, E\\u2295F, F\\u2295A]\\nnow, if you take xor of all the elements in derived array, it will be:\\nA\\u2295B \\u2295 B\\u2295C \\u2295 C\\u2295D \\u2295 D\\u2295E \\u2295 E\\u2295F \\u2295 F\\u2295A = 0\\nas all the elements are appears twice (and  A\\u2295A = 0)\\n......................................................................................\\nor if not convinced with twice argument, you can follow the operations \\nA\\u2295B \\u2295 B\\u2295C \\u2295 C\\u2295D \\u2295 D\\u2295E \\u2295 E\\u2295F \\u2295 F\\u2295A as:\\n**A\\u2295B \\u2295 B\\u2295C** \\u2295 C\\u2295D \\u2295 D\\u2295E \\u2295 E\\u2295F \\u2295 F\\u2295A = **A\\u2295C** \\u2295 C\\u2295D \\u2295 D\\u2295E \\u2295 E\\u2295F \\u2295 F\\u2295A\\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&nbsp;**A\\u2295C \\u2295 C\\u2295D** \\u2295 D\\u2295E \\u2295 E\\u2295F \\u2295 F\\u2295A = **A\\u2295D** \\u2295 D\\u2295E \\u2295 E\\u2295F \\u2295 F\\u2295A \\n-> follow this chain to arrive to **A\\u2295A** = 0\\n......................................................................................\\nthis result is **general** and doesn\\'t limit our derived array to be 0 1 only and would work on any **input array**.\\nIf derived array is only 0 1 as in our case, as an **alternate solution**, we can just count number of 1\\'s, which should be even\\nas it is the special case of our xor result. Even number of 1\\'s will cancel out each other while taking xor.\\n```\\nclass Solution {\\npublic:\\n    bool doesValidArrayExist(vector<int>& derived) {\\n        int x = 0;\\n        for(int y: derived) x ^= y;\\n        return x == 0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Math",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool doesValidArrayExist(vector<int>& derived) {\\n        int x = 0;\\n        for(int y: derived) x ^= y;\\n        return x == 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3523382,
                "title": "c-solution",
                "content": "# Code\\n```\\nbool doesValidArrayExist(int* derived, int derivedSize){\\n    int res=0;\\n    for(int i=0;i<derivedSize;i++){\\n        res^=derived[i];\\n    }\\n    return res==0?true:false;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nbool doesValidArrayExist(int* derived, int derivedSize){\\n    int res=0;\\n    for(int i=0;i<derivedSize;i++){\\n        res^=derived[i];\\n    }\\n    return res==0?true:false;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3523220,
                "title": "python3-solution",
                "content": "\\n```\\nclass Solution:\\n    def doesValidArrayExist(self, derived: List[int]) -> bool:\\n        return sum(derived)%2==0\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def doesValidArrayExist(self, derived: List[int]) -> bool:\\n        return sum(derived)%2==0\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3523033,
                "title": "java-straight-forward",
                "content": "# Code\\n```\\nclass Solution {\\n    public boolean doesValidArrayExist(int[] derived) {\\n        int startWith0 = 0, startWith1 = 1;\\n\\n        for(int n : derived) {\\n            startWith0 ^= n;\\n            startWith1 ^= n;\\n        }\\n\\n        return startWith0 == 0 || startWith1 == 1 ? true : false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean doesValidArrayExist(int[] derived) {\\n        int startWith0 = 0, startWith1 = 1;\\n\\n        for(int n : derived) {\\n            startWith0 ^= n;\\n            startWith1 ^= n;\\n        }\\n\\n        return startWith0 == 0 || startWith1 == 1 ? true : false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3523031,
                "title": "c-simplest-solution-on-leetcode",
                "content": "# Please dont forget to UPVOTE\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool doesValidArrayExist(vector<int>& derived) {\\n        int n=derived.size();\\n        if(n==1 && derived[0]==0) return true;\\n        else if(n==1) return false;\\n\\n        vector<int> orignal(n,0);\\n        orignal[0]=0;\\n        orignal[1]=derived[0];\\n\\n        for(int i=2;i<n;i++) orignal[i]=orignal[i-1]^derived[i-1];\\n\\n        if(orignal[n-1]^0==derived[n-1]) return true;\\n        return false;\\n    }\\n};\\n```\\n\\n# Please dont forget to UPVOTE",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool doesValidArrayExist(vector<int>& derived) {\\n        int n=derived.size();\\n        if(n==1 && derived[0]==0) return true;\\n        else if(n==1) return false;\\n\\n        vector<int> orignal(n,0);\\n        orignal[0]=0;\\n        orignal[1]=derived[0];\\n\\n        for(int i=2;i<n;i++) orignal[i]=orignal[i-1]^derived[i-1];\\n\\n        if(orignal[n-1]^0==derived[n-1]) return true;\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3522919,
                "title": "generate-possible-2-array-combination-check-if-its-valid-easy",
                "content": "# Code\\n```\\nclass Solution {\\n    public boolean doesValidArrayExist(int[] derived) {\\n        int[] start0 = new int[derived.length];\\n        int[] start1 = new int[derived.length];\\n        start0[0] = 0; start1[0]=1;\\n        for(int i=0;i<derived.length-1;i++){\\n            if(derived[i]==1){\\n                start0[i+1] = start0[i]==0?1:0;\\n                start1[i+1] = start1[i]==0?1:0;\\n            }else{\\n                start0[i+1] = start0[i];\\n                start1[i+1] = start1[i];\\n            }\\n        }\\n        // System.out.println(Arrays.toString(start0));\\n        // System.out.println(Arrays.toString(start1));\\n        if(derived[derived.length-1]==0){\\n            return start0[0]==start0[start0.length-1] || start1[0]==start1[start1.length-1];\\n        }else{\\n            return start0[0]!=start0[start0.length-1] || start1[0]!=start1[start1.length-1];\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean doesValidArrayExist(int[] derived) {\\n        int[] start0 = new int[derived.length];\\n        int[] start1 = new int[derived.length];\\n        start0[0] = 0; start1[0]=1;\\n        for(int i=0;i<derived.length-1;i++){\\n            if(derived[i]==1){\\n                start0[i+1] = start0[i]==0?1:0;\\n                start1[i+1] = start1[i]==0?1:0;\\n            }else{\\n                start0[i+1] = start0[i];\\n                start1[i+1] = start1[i];\\n            }\\n        }\\n        // System.out.println(Arrays.toString(start0));\\n        // System.out.println(Arrays.toString(start1));\\n        if(derived[derived.length-1]==0){\\n            return start0[0]==start0[start0.length-1] || start1[0]==start1[start1.length-1];\\n        }else{\\n            return start0[0]!=start0[start0.length-1] || start1[0]!=start1[start1.length-1];\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3522629,
                "title": "c-easy-solution-beats-100",
                "content": "# Intuition\\nIf Xor of all element is 1 then its not possible else it is possible.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(N);\\n- Space complexity:O(1);\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool doesValidArrayExist(vector<int>& d) {\\n        int ans=0;\\n        for(auto &x:d)\\n        {\\n            ans^=x;\\n        }\\n        return ans?false:true;\\n    }\\n};\\n```\\n![7dr99c.jpg](https://assets.leetcode.com/users/images/265dddef-a8d3-439d-a352-a92153ef5f5c_1684044579.1847186.jpeg)\\n",
                "solutionTags": [
                    "C++",
                    "Bit Manipulation",
                    "Bitmask"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool doesValidArrayExist(vector<int>& d) {\\n        int ans=0;\\n        for(auto &x:d)\\n        {\\n            ans^=x;\\n        }\\n        return ans?false:true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3522575,
                "title": "all-four-solutions-cpp-easy-to-understand",
                "content": "# 1. Finding Losers of the circular game\\n```\\nclass Solution {\\npublic:\\n    vector<int> circularGameLosers(int n, int k) {\\n        unordered_map<int, int> m;\\n        for(int i = 0, j = 1; ; ++j){\\n            if(m[i]) break;\\n            m[i]++;\\n            int x = j*k;\\n            while(x){\\n                i++;\\n                if(i == n) i = i-n;\\n                x--;\\n            }\\n        }\\n        vector<int> v;\\n        for(int i = 0; i<n; ++i){\\n            if(!m[i]) v.push_back(i+1);\\n        }\\n        return v;\\n    }\\n};\\n```\\n# 2. Neighboring Bitwise XOR\\n```\\nclass Solution {\\npublic:\\n    bool doesValidArrayExist(vector<int>& d) {\\n        int res = 0;\\n        for(int i = 0; i<d.size(); ++i){\\n            res ^= d[i];\\n        }\\n        return res ? false: true;\\n    }\\n};\\n```\\n# 3. Minimum number of moves in a grid\\n```\\nclass Solution {\\npublic:\\n    vector<int> I = {-1, 0, 1};\\n    vector<int> J = {1, 1, 1};\\n    int res = 0;\\n    int dfs(vector<vector<int>>& grid, vector<vector<int>>& dp, vector<vector<int>>& v, int i, int j){\\n        if(dp[i][j] != -1) return dp[i][j];\\n        v[i][j] = 1;\\n        cout<<grid[i][j]<<\" \";\\n        for(int k = 0; k<3; ++k){\\n            int newI = i + I[k];\\n            int newJ = j + J[k];\\n            int ans = 0;\\n            if(newI >= 0 && newJ >=0 && newI < grid.size() && newJ <grid[0].size()){\\n                if(dp[newI][newJ] == -1 && !v[newI][newJ] && grid[i][j] < grid[newI][newJ]){\\n                    ans = 1+dfs(grid, dp, v, newI, newJ);\\n                }\\n                dp[i][j] = max(ans, dp[i][j]);\\n                res = max(res, dp[i][j]);\\n            }\\n        }\\n        return dp[i][j] == -1 ? 0:dp[i][j];\\n    }\\n    int maxMoves(vector<vector<int>>& grid) {\\n        int n = grid.size(), m = grid[0].size();\\n        vector<vector<int>> dp(n, vector<int>(m,-1));\\n        vector<vector<int>> v(n, vector<int>(m, 0));\\n        for(int i = 0; i<n; i++){\\n            for(int j = 0; j<1; ++j){\\n                if(dp[i][j] == -1)\\n                    dfs(grid, dp, v, i, j);\\n            }\\n        }\\n        int ans = res;\\n        res = 0;\\n        return ans;\\n    }\\n};\\n```\\n# 4. Count the Number of Complete Components\\n```\\nclass Solution {\\npublic:\\n    void dfs(vector<int> adj[], int i, vector<vector<int>>& m, vector<int>& v, vector<int>& res){\\n        if(!v[i]){\\n            res.push_back(i);\\n            v[i] = 1;\\n            for(int x: adj[i]) dfs(adj, x, m, v, res);\\n        }\\n    }\\n    int countCompleteComponents(int n, vector<vector<int>>& e) {\\n        vector<int> a[n];\\n        map<pair<int,int>, int> t;\\n        for(auto x: e){\\n            a[x[0]].push_back(x[1]);\\n            a[x[1]].push_back(x[0]);\\n            t[{x[0], x[1]}]++;\\n            t[{x[1], x[0]}]++;\\n        }\\n        vector<vector<int>> m;\\n        vector<int> v(n);\\n        for(int i = 0; i<n; ++i){\\n            vector<int> res;\\n            if(!v[i]){\\n                dfs(a, i, m, v, res);\\n                m.push_back(res);\\n            }\\n        }\\n        int cnt = m.size(), f = 0;\\n        for(auto x: m){\\n            for(int i = 0; i<x.size(); ++i){\\n                for(int j = i+1; j<x.size(); ++j){\\n                    if(!t[{x[i], x[j]}]){\\n                        cnt--;\\n                        f = 1;\\n                        break;\\n                    }\\n                }\\n                if(f){\\n                    f = 0;\\n                    break;\\n                }\\n            }\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> circularGameLosers(int n, int k) {\\n        unordered_map<int, int> m;\\n        for(int i = 0, j = 1; ; ++j){\\n            if(m[i]) break;\\n            m[i]++;\\n            int x = j*k;\\n            while(x){\\n                i++;\\n                if(i == n) i = i-n;\\n                x--;\\n            }\\n        }\\n        vector<int> v;\\n        for(int i = 0; i<n; ++i){\\n            if(!m[i]) v.push_back(i+1);\\n        }\\n        return v;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    bool doesValidArrayExist(vector<int>& d) {\\n        int res = 0;\\n        for(int i = 0; i<d.size(); ++i){\\n            res ^= d[i];\\n        }\\n        return res ? false: true;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<int> I = {-1, 0, 1};\\n    vector<int> J = {1, 1, 1};\\n    int res = 0;\\n    int dfs(vector<vector<int>>& grid, vector<vector<int>>& dp, vector<vector<int>>& v, int i, int j){\\n        if(dp[i][j] != -1) return dp[i][j];\\n        v[i][j] = 1;\\n        cout<<grid[i][j]<<\" \";\\n        for(int k = 0; k<3; ++k){\\n            int newI = i + I[k];\\n            int newJ = j + J[k];\\n            int ans = 0;\\n            if(newI >= 0 && newJ >=0 && newI < grid.size() && newJ <grid[0].size()){\\n                if(dp[newI][newJ] == -1 && !v[newI][newJ] && grid[i][j] < grid[newI][newJ]){\\n                    ans = 1+dfs(grid, dp, v, newI, newJ);\\n                }\\n                dp[i][j] = max(ans, dp[i][j]);\\n                res = max(res, dp[i][j]);\\n            }\\n        }\\n        return dp[i][j] == -1 ? 0:dp[i][j];\\n    }\\n    int maxMoves(vector<vector<int>>& grid) {\\n        int n = grid.size(), m = grid[0].size();\\n        vector<vector<int>> dp(n, vector<int>(m,-1));\\n        vector<vector<int>> v(n, vector<int>(m, 0));\\n        for(int i = 0; i<n; i++){\\n            for(int j = 0; j<1; ++j){\\n                if(dp[i][j] == -1)\\n                    dfs(grid, dp, v, i, j);\\n            }\\n        }\\n        int ans = res;\\n        res = 0;\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    void dfs(vector<int> adj[], int i, vector<vector<int>>& m, vector<int>& v, vector<int>& res){\\n        if(!v[i]){\\n            res.push_back(i);\\n            v[i] = 1;\\n            for(int x: adj[i]) dfs(adj, x, m, v, res);\\n        }\\n    }\\n    int countCompleteComponents(int n, vector<vector<int>>& e) {\\n        vector<int> a[n];\\n        map<pair<int,int>, int> t;\\n        for(auto x: e){\\n            a[x[0]].push_back(x[1]);\\n            a[x[1]].push_back(x[0]);\\n            t[{x[0], x[1]}]++;\\n            t[{x[1], x[0]}]++;\\n        }\\n        vector<vector<int>> m;\\n        vector<int> v(n);\\n        for(int i = 0; i<n; ++i){\\n            vector<int> res;\\n            if(!v[i]){\\n                dfs(a, i, m, v, res);\\n                m.push_back(res);\\n            }\\n        }\\n        int cnt = m.size(), f = 0;\\n        for(auto x: m){\\n            for(int i = 0; i<x.size(); ++i){\\n                for(int j = i+1; j<x.size(); ++j){\\n                    if(!t[{x[i], x[j]}]){\\n                        cnt--;\\n                        f = 1;\\n                        break;\\n                    }\\n                }\\n                if(f){\\n                    f = 0;\\n                    break;\\n                }\\n            }\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3522558,
                "title": "only-count-no-of-1s-very-easy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool doesValidArrayExist(vector<int>& derived) {\\n        int count=0;\\n        for(int i=0;i<derived.size();i++){\\n            if(derived[i]==1) count++;\\n        }\\n\\n        if(count%2==0) return true;\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool doesValidArrayExist(vector<int>& derived) {\\n        int count=0;\\n        for(int i=0;i<derived.size();i++){\\n            if(derived[i]==1) count++;\\n        }\\n\\n        if(count%2==0) return true;\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3522417,
                "title": "very-very-easy-solution-using-c",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    bool doesValidArrayExist(vector<int>& derived) {\\n        int ans = derived[0];\\n        for(int i = 1; i < derived.size(); i++) {\\n            ans = ans xor derived[i];\\n        }\\n        if(ans == 0) {\\n            return true;\\n        }\\n        \\n        return false;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool doesValidArrayExist(vector<int>& derived) {\\n        int ans = derived[0];\\n        for(int i = 1; i < derived.size(); i++) {\\n            ans = ans xor derived[i];\\n        }\\n        if(ans == 0) {\\n            return true;\\n        }\\n        \\n        return false;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3522333,
                "title": "c-best-solution-easy-to-understand",
                "content": "\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool doesValidArrayExist(vector<int>& derived) {\\n        int a=0, b=1, n=derived.size();\\n        for(int i=0; i<n-1; i++) a ^= derived[i], b ^= derived[i];\\n        return (a^0 == derived[n-1] || b^1 == derived[n-1]);\\n    }\\n};\\n```\\n\\n# Approach-2\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool doesValidArrayExist(vector<int>& derived) {\\n        int x=1;\\n        for(auto it : derived) x ^= it;\\n        return x;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Bit Manipulation",
                    "Brainteaser"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool doesValidArrayExist(vector<int>& derived) {\\n        int a=0, b=1, n=derived.size();\\n        for(int i=0; i<n-1; i++) a ^= derived[i], b ^= derived[i];\\n        return (a^0 == derived[n-1] || b^1 == derived[n-1]);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    bool doesValidArrayExist(vector<int>& derived) {\\n        int x=1;\\n        for(auto it : derived) x ^= it;\\n        return x;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3522332,
                "title": "c-brute-force-easy-approach",
                "content": "Here is my c++ code for this problem.\\n\\n# Complexity\\n- Time complexity:$$O(n)$$\\n\\n- Space complexity:$$O(n)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool doesValidArrayExist(vector<int>& d) {\\n        vector<int>v(d.size(), 0);\\n        int n=d.size();\\n        int o=0, z=0;\\n        for(int i=0; i<n; i++){\\n            if(d[i]){\\n                if(i==n-1){\\n                    if(v[(i+1)%n]==v[i]){\\n                        return false;\\n                    }\\n                    else{return true;}\\n                }\\n                else{v[(i+1)%n]=!v[i];}\\n            }\\n            else{\\n                if(i==n-1){\\n                    if(v[(i+1)%n]!=v[i]){\\n                        return false;\\n                    }\\n                    else{\\n                        return true;\\n                    }\\n                }\\n                else{\\n                    v[(i+1)%n]=v[i];\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool doesValidArrayExist(vector<int>& d) {\\n        vector<int>v(d.size(), 0);\\n        int n=d.size();\\n        int o=0, z=0;\\n        for(int i=0; i<n; i++){\\n            if(d[i]){\\n                if(i==n-1){\\n                    if(v[(i+1)%n]==v[i]){\\n                        return false;\\n                    }\\n                    else{return true;}\\n                }\\n                else{v[(i+1)%n]=!v[i];}\\n            }\\n            else{\\n                if(i==n-1){\\n                    if(v[(i+1)%n]!=v[i]){\\n                        return false;\\n                    }\\n                    else{\\n                        return true;\\n                    }\\n                }\\n                else{\\n                    v[(i+1)%n]=v[i];\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3522324,
                "title": "c-3-lines-detailed-explanation-count-1-s",
                "content": "**Explaination**\\nlet us find derived array of all the binary numbers of size \\n\\n* original = [0] -> derived = [0]\\n* original = [1] -> derived = [0]\\n\\npossible derives are:\\n* [0]\\n\\nderived was only possible for number of bits equal to **0**\\n\\n----------------------------------\\n* original = [0,0] -> derived = [0,0]\\n* original = [0,1] -> derived = [1,1]\\n* original = [1,0] -> derived = [1.1]\\n* original = [1,1] -> derived = [0,0]\\n\\npossible derives are:\\n* [0,0]\\n* [1,1]\\n\\nderived was only possible for number of bits equal to **0,2**\\n\\n ----------------------------------\\n* original = [0,0,0] -> derived = [0,0,0]\\n* original = [0,0,1] -> derived = [0,1,1]\\n* original = [0,1,0] -> derived = [1,1,0]\\n* original = [0,1,1] -> derived = [1,0,1]\\n* original = [1,0,0] -> derived = [1.0,1]\\n* original = [1,0,1] -> derived = [1.1,0]\\n* original = [1,1,0] -> derived = [0,1,1]\\n* original = [1,1,1] -> derived = [0,0,0]\\n\\n\\npossible derives are:\\n* [0,0,0]\\n* [0,1,1]\\n* [1,0,1]\\n* [1,1,0]\\n\\nderived was only possible for number of bits equal to **0,2**\\n\\n ----------------------------------\\n* original = [0,0,0,0] -> derived = [0,0,0,0]\\n* original = [0,0,0,1] -> derived = [0,0,1,1]\\n* original = [0,0,1,0] -> derived = [0,1,1,0]\\n* original = [0,0,1,1] -> derived = [0,1,0,1]\\n* original = [0,1,0,0] -> derived = [1,1,0,0]\\n* original = [0,1,0,1] -> derived = [1,1,1,1]\\n* original = [0,1,1,0] -> derived = [1,0,1,0]\\n* original = [0,1,1,1] -> derived = [1,0,0,1]\\n* original = [1,0,0,0] -> derived = [1.0,0,1]\\n* original = [1,0,0,1] -> derived = [1.0,1,0]\\n* original = [1,0,1,0] -> derived = [1.1,1,1]\\n* original = [1,0,1,1] -> derived = [1.1,0,0]\\n* original = [1,1,0,0] -> derived = [0,1,0,1]\\n* original = [1,1,0,1] -> derived = [0,1,1,0]\\n* original = [1,1,1,0] -> derived = [0,0,1,1]\\n* original = [1,1,1,1] -> derived = [0,0,0,0]\\n\\n\\n\\npossible derives are:\\n* [0,0,0,0]\\n* [0,0,1,1]\\n* [0,1,0,1]\\n* [0,1,1,0]\\n* [1,0,0,1]\\n* [1,0,1,0]\\n* [1,1,0,0]\\n* [1,1,1,1]\\n\\nderived was only possible for number of bits equal to **0,2,4**\\n\\n-------------------------------\\n\\nHence the original is possible only for sum of bits being even\\n\\n```\\nclass Solution {\\npublic:\\n    bool doesValidArrayExist(vector<int>& derived) {\\n        int count = 0;\\n        \\n        for(auto it: derived) count+=it;\\n        \\n        return count%2==0;\\n    }\\n};\\n```\\nTime Complexity - *O(N)*\\nSpace Complexity - *O(N)*\\n\\nIf you found this solution helpful, please consider upvoting.",
                "solutionTags": [
                    "C",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool doesValidArrayExist(vector<int>& derived) {\\n        int count = 0;\\n        \\n        for(auto it: derived) count+=it;\\n        \\n        return count%2==0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3522295,
                "title": "easy-cpp-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\nO(N)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool doesValidArrayExist(vector<int>& arr) {\\n        vector<int>first;\\n        if(arr.size() == 1  ){\\n             if(arr[0] == 1) return false;\\n             else return true;\\n        }       \\n        \\n       if(arr[0] == 1){\\n               first.push_back(0);\\n               first.push_back(1);\\n        }\\n        else {\\n               first.push_back(0);\\n               first.push_back(0);\\n        }\\n        for(int i = 1 ;i<arr.size();i++){\\n              \\n              if( i == arr.size() - 1){\\n                  bool flag1 = false;\\n                  if((first[0]^first[i]) == arr[i] ) return true;\\n                  else return false;\\n                  \\n              }\\n              else if( arr[i] == 1){\\n\\n                  if((first[i]^0) == arr[i] ) first.push_back(0);\\n                  else if((first[i]^1) == arr[i] ) first.push_back(1);\\n                  else return false;\\n                  \\n              }\\n             else {\\n                  if((first[i]^0) == arr[i] ) first.push_back(0);\\n                  else if((first[i]^1 )== arr[i] ) first.push_back(1);\\n                  else return false;\\n            }\\n\\n         }\\n                    return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool doesValidArrayExist(vector<int>& arr) {\\n        vector<int>first;\\n        if(arr.size() == 1  ){\\n             if(arr[0] == 1) return false;\\n             else return true;\\n        }       \\n        \\n       if(arr[0] == 1){\\n               first.push_back(0);\\n               first.push_back(1);\\n        }\\n        else {\\n               first.push_back(0);\\n               first.push_back(0);\\n        }\\n        for(int i = 1 ;i<arr.size();i++){\\n              \\n              if( i == arr.size() - 1){\\n                  bool flag1 = false;\\n                  if((first[0]^first[i]) == arr[i] ) return true;\\n                  else return false;\\n                  \\n              }\\n              else if( arr[i] == 1){\\n\\n                  if((first[i]^0) == arr[i] ) first.push_back(0);\\n                  else if((first[i]^1) == arr[i] ) first.push_back(1);\\n                  else return false;\\n                  \\n              }\\n             else {\\n                  if((first[i]^0) == arr[i] ) first.push_back(0);\\n                  else if((first[i]^1 )== arr[i] ) first.push_back(1);\\n                  else return false;\\n            }\\n\\n         }\\n                    return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3522265,
                "title": "c-o-n-solution",
                "content": "\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool doesValidArrayExist(vector<int>& der) {\\n        vector<int> org(der.size());\\n        for(int i = 0; i < der.size() - 1; i++) {\\n            if(i == 0) {\\n                if(der[i] == 1) {\\n                    org[i] = 0;\\n                    org[i + 1] = 1;\\n                }\\n            }\\n            else {\\n                if(der[i] == 1) {\\n                    if(org[i] == 0) org[i + 1] = 1;\\n                    else org[i + 1] = 0;\\n                }\\n                else {\\n                    if(org[i] == 1) org[i + 1] = 1;\\n                    else org[i + 1] = 0;\\n                }\\n            }\\n        }\\n        for(int i = 0; i < org.size(); i++) {\\n            if((i < org.size() - 1) && (org[i] ^ org[i + 1] != der[i])) return false;\\n            else if(i == org.size() - 1 && (org[i] ^ org[0] != der[i])) return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool doesValidArrayExist(vector<int>& der) {\\n        vector<int> org(der.size());\\n        for(int i = 0; i < der.size() - 1; i++) {\\n            if(i == 0) {\\n                if(der[i] == 1) {\\n                    org[i] = 0;\\n                    org[i + 1] = 1;\\n                }\\n            }\\n            else {\\n                if(der[i] == 1) {\\n                    if(org[i] == 0) org[i + 1] = 1;\\n                    else org[i + 1] = 0;\\n                }\\n                else {\\n                    if(org[i] == 1) org[i + 1] = 1;\\n                    else org[i + 1] = 0;\\n                }\\n            }\\n        }\\n        for(int i = 0; i < org.size(); i++) {\\n            if((i < org.size() - 1) && (org[i] ^ org[i + 1] != der[i])) return false;\\n            else if(i == org.size() - 1 && (org[i] ^ org[0] != der[i])) return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3522090,
                "title": "javascript-greedy-two-conditions-244ms",
                "content": "Main idea:\\n(1) original array only start with either 0 or 1\\n(2) how to build original array: xor formula\\n     derived[i] = original[i] ^ original[i + 1]\\n   => original[i + 1] = derived[i] ^ original[i]\\n```\\nconst aeq = (a, b) => a.length === b.length && a.every((v, i) => v === b[i]);\\n\\nconst doesValidArrayExist = (a) => {\\n    let n = a.length;\\n    let b = Array(n).fill(-1), b2 = Array(n).fill(-1); // (1) build orginal array\\n    b[0] = 0;\\n    b2[0] = 1;\\n    go(a, b)\\n    if (aeq(test(b), a)) return true;\\n    go(a, b2);\\n    if (aeq(test(b2), a)) return true;\\n    return false;\\n};\\n\\nconst go = (a, b) => {\\n    let n = a.length;\\n    for (let i = 0; i < n; i++) {\\n        if (i == n - 1) {\\n            b[i] = a[i] ^ b[0];\\n        } else {\\n            // a[i] = b[i] ^ b[i+1]\\n            b[i + 1] = a[i] ^ b[i]; // (2)\\n        }\\n    }\\n};\\n\\nconst test = (a) => {\\n    let n = a.length, res = Array(n).fill(-1);\\n    for (let i = 0; i + 1 < n; i++) res[i] = a[i] ^ a[i + 1];\\n    res[n - 1] = a[n - 1] ^ a[0];\\n    return res;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Greedy",
                    "Bit Manipulation"
                ],
                "code": "```\\nconst aeq = (a, b) => a.length === b.length && a.every((v, i) => v === b[i]);\\n\\nconst doesValidArrayExist = (a) => {\\n    let n = a.length;\\n    let b = Array(n).fill(-1), b2 = Array(n).fill(-1); // (1) build orginal array\\n    b[0] = 0;\\n    b2[0] = 1;\\n    go(a, b)\\n    if (aeq(test(b), a)) return true;\\n    go(a, b2);\\n    if (aeq(test(b2), a)) return true;\\n    return false;\\n};\\n\\nconst go = (a, b) => {\\n    let n = a.length;\\n    for (let i = 0; i < n; i++) {\\n        if (i == n - 1) {\\n            b[i] = a[i] ^ b[0];\\n        } else {\\n            // a[i] = b[i] ^ b[i+1]\\n            b[i + 1] = a[i] ^ b[i]; // (2)\\n        }\\n    }\\n};\\n\\nconst test = (a) => {\\n    let n = a.length, res = Array(n).fill(-1);\\n    for (let i = 0; i + 1 < n; i++) res[i] = a[i] ^ a[i + 1];\\n    res[n - 1] = a[n - 1] ^ a[0];\\n    return res;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3522077,
                "title": "easy-java-solution-100-faster-0ms",
                "content": "- Time complexity: O(n)\\n\\n- Space complexity: (1)\\n\\n```\\nclass Solution {\\n    public boolean doesValidArrayExist(int[] derived) {\\n        \\n    int sum=0;\\n    for(int num:derived)\\n    {\\n        sum+=num;\\n    }\\n    return sum%2==0?true:false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean doesValidArrayExist(int[] derived) {\\n        \\n    int sum=0;\\n    for(int num:derived)\\n    {\\n        sum+=num;\\n    }\\n    return sum%2==0?true:false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3522045,
                "title": "easy-simple-recursion-brute-force",
                "content": "# Code\\n```\\nclass Solution {\\n    public boolean doesValidArrayExist(int[] derived) {\\n        //first element can be 0 or 1\\n        return buildArray(derived,0,0,0) || buildArray(derived,0,1,1);\\n    }\\n    \\n    public boolean buildArray(int[] derived,int index,int currValue,int startValue){\\n        //for last index, check if it\\'s xor with first element matches with last element of derived array\\n        if(index==derived.length-1){\\n            if(derived[derived.length-1]==(startValue^currValue)){\\n                return true;\\n            }\\n            return false;\\n        }\\n\\n        int zero=0,one=1;\\n        //check for next element if it\\'s xor with currentElement matches element of derived array\\n         if(((currValue^0)==1 && derived[index]==1) || ((currValue^0)==0 && derived[index]==0)){\\n            if(buildArray(derived,index+1,0,startValue)){\\n                return true;\\n            }\\n        }\\n        if(((currValue^1)==1 && derived[index]==1) || ((currValue^1)==0 && derived[index]==0)){\\n            if(buildArray(derived,index+1,1,startValue)){\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean doesValidArrayExist(int[] derived) {\\n        //first element can be 0 or 1\\n        return buildArray(derived,0,0,0) || buildArray(derived,0,1,1);\\n    }\\n    \\n    public boolean buildArray(int[] derived,int index,int currValue,int startValue){\\n        //for last index, check if it\\'s xor with first element matches with last element of derived array\\n        if(index==derived.length-1){\\n            if(derived[derived.length-1]==(startValue^currValue)){\\n                return true;\\n            }\\n            return false;\\n        }\\n\\n        int zero=0,one=1;\\n        //check for next element if it\\'s xor with currentElement matches element of derived array\\n         if(((currValue^0)==1 && derived[index]==1) || ((currValue^0)==0 && derived[index]==0)){\\n            if(buildArray(derived,index+1,0,startValue)){\\n                return true;\\n            }\\n        }\\n        if(((currValue^1)==1 && derived[index]==1) || ((currValue^1)==0 && derived[index]==0)){\\n            if(buildArray(derived,index+1,1,startValue)){\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3521911,
                "title": "6431-neighboring-bitwise-xor-java-easy-peesy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean doesValidArrayExist(int[] derived) {\\n        int result=0;\\n        for(int e:derived){ result=result^e;} return result == 0;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean doesValidArrayExist(int[] derived) {\\n        int result=0;\\n        for(int e:derived){ result=result^e;} return result == 0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3521892,
                "title": "easy-java-solution-2-approaches",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    public boolean doesValidArrayExist(int[] derived) {\\n        int count=0;\\n        for(int i=0;i<derived.length;i++){\\n            if(derived[i]==1) count++;\\n        }\\n        return count%2==0;\\n    }\\n}\\n```\\n```\\nclass Solution {\\n    public boolean doesValidArrayExist(int[] derived) {\\n        int xor = 0;\\n        for(int val : derived) xor ^= val;\\n        return xor == 0;\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "Java",
                    "Math",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\n    public boolean doesValidArrayExist(int[] derived) {\\n        int count=0;\\n        for(int i=0;i<derived.length;i++){\\n            if(derived[i]==1) count++;\\n        }\\n        return count%2==0;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public boolean doesValidArrayExist(int[] derived) {\\n        int xor = 0;\\n        for(int val : derived) xor ^= val;\\n        return xor == 0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4082296,
                "title": "c-easy-solution",
                "content": "class Solution {\\npublic:\\n    bool doesValidArrayExist(vector<int>& nums) {\\n        int s=0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            s=s^nums[i];\\n        }\\n       for(int i=0;i<nums.size();i++)\\n       {\\n        int k=s^nums[i];\\n           if(k!=nums[i])\\n           {\\n               return false;\\n           }\\n       }\\n        return true;\\n        \\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    bool doesValidArrayExist(vector<int>& nums) {\\n        int s=0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            s=s^nums[i];\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 4065527,
                "title": "ruby-1-liner",
                "content": "```ruby\\n# @param {Integer[]} derived\\n# @return {Boolean}\\ndef does_valid_array_exist(derived)\\n  derived.inject(:^) == 0\\nend\\n```",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```ruby\\n# @param {Integer[]} derived\\n# @return {Boolean}\\ndef does_valid_array_exist(derived)\\n  derived.inject(:^) == 0\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 4065492,
                "title": "python-1-liner",
                "content": "```python\\nclass Solution:\\n    def doesValidArrayExist(self, derived: List[int]) -> bool:\\n        return not list(itertools.accumulate(derived, func=lambda a, b: a ^ b))[-1]\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```python\\nclass Solution:\\n    def doesValidArrayExist(self, derived: List[int]) -> bool:\\n        return not list(itertools.accumulate(derived, func=lambda a, b: a ^ b))[-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4026180,
                "title": "simple-solution-with-explanation-java-neighboring-bitwise-xor",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n=> In the derived array, each element is the XOR of the two elements that from the original array. \\n\\n=> So, if there exists an original array such that the derived array is formed by XORing consecutive elements of the original array, then the XOR of all the elements in the derived array must be 0.\\n\\n=> Because the xor of same element return 0 and by the description we can say that the every element of the original array exists two times in the derived array.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n=> Let\\'s say we have an original array `arr` with the following elements:\\n\\n```\\narr = [1, 2, 3]\\n```\\n\\n=> The derived array `der` is formed by XORing consecutive elements of `arr`. So, the elements of `der` are:\\n\\n```\\nder = [1 ^ 2, 2 ^ 3, 3 ^ 1]\\n```\\n\\n=> The XOR of all the elements in `der` is 0:\\n\\n```\\n1 ^ 2 ^ 2 ^ 3 ^ 3 ^ 1 = 0\\n```\\n\\n=> This means that all the elements in `der` are equal to each other. In this case, all the elements in `der` are equal to 0.\\n\\n=> So, we can see that if the XOR of all the elements in a derived array is 0, then all the elements in the derived array must be equal to each other.\\n\\n=> Now, let\\'s say there is no original array `arr` such that `der` is formed by XORing consecutive elements of `arr`. This means that the elements of `der` are not all equal to each other.\\n\\n=> But the XOR of all the elements in `der` is 0. This is a contradiction, because the XOR of two different numbers is never 0.\\n\\n=> Therefore, our assumption must be wrong. There must exist an original array `arr` such that `der` is formed by XORing consecutive \\nelements of `arr`.\\n\\n![Screenshot 2023-09-10 133650.png](https://assets.leetcode.com/users/images/4a7ac1ea-4aa5-41c3-a210-87d65a71ff1e_1694337411.0975177.png)\\n\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean doesValidArrayExist(int[] d) {\\n        int x = 0;\\n        for(int i : d)\\n        {\\n            x ^= i;\\n        }\\n        return x==0;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Bit Manipulation"
                ],
                "code": "```\\narr = [1, 2, 3]\\n```\n```\\nder = [1 ^ 2, 2 ^ 3, 3 ^ 1]\\n```\n```\\n1 ^ 2 ^ 2 ^ 3 ^ 3 ^ 1 = 0\\n```\n```\\nclass Solution {\\n    public boolean doesValidArrayExist(int[] d) {\\n        int x = 0;\\n        for(int i : d)\\n        {\\n            x ^= i;\\n        }\\n        return x==0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4018931,
                "title": "java-loop",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean doesValidArrayExist(int[] derived) {\\n        if(derived.length == 1 ) {\\n            if(derived[0] == 1)\\n            return false;\\n            else return true;\\n        } \\n       \\n        if(derived[0] == 1) {\\n            // there are two cases in this also\\n            if(solve(new StringBuilder(\"01\"),derived) || solve(new StringBuilder(\"10\"),derived)) {\\n                return true;\\n            }\\n            \\n        } else {\\n            if(solve(new StringBuilder(\"00\"),derived) || solve(new StringBuilder(\"11\"),derived)) {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n\\n    boolean solve(StringBuilder s , int[] derived) {\\n         if(s.length() == derived.length) {\\n             if((Integer.parseInt(\"\" + s.charAt(1 % derived.length)) ^\\n             Integer.parseInt(\"\" + s.charAt(0))) == derived[derived.length-1])  {\\n                    return true;\\n             }\\n              \\n              else {\\n                 return false;\\n             }\\n\\n    }\\n    \\n         \\n\\n        for(int i = 1 ; i < derived.length - 1 ;i++) {\\n\\n           \\n\\n            if(derived[i] == 1) {\\n                if(s.charAt(i) == \\'0\\') {\\n                    s = s.append(\"1\");\\n                } else {\\n                    s = s.append(\"0\");\\n                }\\n            } else {\\n                 if(s.charAt(i) == \\'0\\') {\\n                    s = s.append(\"0\");\\n                } else {\\n                 s = s.append(\"1\");\\n                }\\n            }\\n        }\\n        // System.out.println(s);\\n     if((Integer.parseInt(\"\" + s.charAt(s.length()-1)) ^\\n             Integer.parseInt(\"\" + s.charAt(0))) == derived[derived.length-1]) {\\n                 return true;\\n             } else {\\n                 return false;\\n             }\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean doesValidArrayExist(int[] derived) {\\n        if(derived.length == 1 ) {\\n            if(derived[0] == 1)\\n            return false;\\n            else return true;\\n        } \\n       \\n        if(derived[0] == 1) {\\n            // there are two cases in this also\\n            if(solve(new StringBuilder(\"01\"),derived) || solve(new StringBuilder(\"10\"),derived)) {\\n                return true;\\n            }\\n            \\n        } else {\\n            if(solve(new StringBuilder(\"00\"),derived) || solve(new StringBuilder(\"11\"),derived)) {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n\\n    boolean solve(StringBuilder s , int[] derived) {\\n         if(s.length() == derived.length) {\\n             if((Integer.parseInt(\"\" + s.charAt(1 % derived.length)) ^\\n             Integer.parseInt(\"\" + s.charAt(0))) == derived[derived.length-1])  {\\n                    return true;\\n             }\\n              \\n              else {\\n                 return false;\\n             }\\n\\n    }\\n    \\n         \\n\\n        for(int i = 1 ; i < derived.length - 1 ;i++) {\\n\\n           \\n\\n            if(derived[i] == 1) {\\n                if(s.charAt(i) == \\'0\\') {\\n                    s = s.append(\"1\");\\n                } else {\\n                    s = s.append(\"0\");\\n                }\\n            } else {\\n                 if(s.charAt(i) == \\'0\\') {\\n                    s = s.append(\"0\");\\n                } else {\\n                 s = s.append(\"1\");\\n                }\\n            }\\n        }\\n        // System.out.println(s);\\n     if((Integer.parseInt(\"\" + s.charAt(s.length()-1)) ^\\n             Integer.parseInt(\"\" + s.charAt(0))) == derived[derived.length-1]) {\\n                 return true;\\n             } else {\\n                 return false;\\n             }\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4002661,
                "title": "simply-count-1-s-and-0-s",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool doesValidArrayExist(vector<int>& derived) {\\n        int x=0;\\n        for(int i=0;i<derived.size();i++){\\n            x^=derived[i];\\n        }\\n        return (x==0);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool doesValidArrayExist(vector<int>& derived) {\\n        int x=0;\\n        for(int i=0;i<derived.size();i++){\\n            x^=derived[i];\\n        }\\n        return (x==0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3944373,
                "title": "java-iterative-resursive",
                "content": "# Intuition \\nwe can have 2 possiblities for start values of original array. \\n1. original array can start with 1\\n2. original array can start with zero\\n\\nsince every value of derived array is depends only only current value & next of original array, we can maintain 2 variables which stores current values original array at that index. \\n\\nand based on derived value of at that index , we can alter those 2 pointers. \\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(N$$) // $$N$$ is the length of the array\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean doesValidArrayExist(int[] derived) {\\n        int N = derived.length; \\n        \\n        int currentValueWhenOriginalStartsWithOne = 1;\\n        int currentValueWhenOriginalStartsWithZero = 0; \\n\\n        for(int index = 0; index < N-1 ;index++){\\n            if(derived[index] == 1){\\n                currentValueWhenOriginalStartsWithOne = currentValueWhenOriginalStartsWithOne == 1 ? 0 : 1; \\n                currentValueWhenOriginalStartsWithZero = currentValueWhenOriginalStartsWithZero == 1 ? 0 : 1; \\n            }\\n        }\\n\\n        if(derived[N-1] == 1){\\n            return (currentValueWhenOriginalStartsWithOne == 0) || (currentValueWhenOriginalStartsWithZero == 1);\\n        }else\\n            return (currentValueWhenOriginalStartsWithOne == 1) || (currentValueWhenOriginalStartsWithZero == 0);  \\n    }\\n}\\n\\nclass SolutionRecursive {\\n    public boolean doesValidArrayExist(int[] derived) {\\n        return solve(derived, 0, 1, 1) \\n             || solve(derived, 0, 0, 0);\\n    }\\n\\n    public boolean solve(int[] derived, int index, int first, int current){\\n        if(index == derived.length-1){\\n            if(derived[index]==1){\\n                return (current==1 && first==0) || (current==0 && first==1);\\n            }else{\\n                return (current==0 && first==0) || (current==1 && first==1);\\n            }\\n        }\\n        if(derived[index] == 1){\\n            return solve(derived, index+1, first, current == 1 ? 0 : 1);\\n        }else{\\n            return solve(derived, index+1, first, current);\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean doesValidArrayExist(int[] derived) {\\n        int N = derived.length; \\n        \\n        int currentValueWhenOriginalStartsWithOne = 1;\\n        int currentValueWhenOriginalStartsWithZero = 0; \\n\\n        for(int index = 0; index < N-1 ;index++){\\n            if(derived[index] == 1){\\n                currentValueWhenOriginalStartsWithOne = currentValueWhenOriginalStartsWithOne == 1 ? 0 : 1; \\n                currentValueWhenOriginalStartsWithZero = currentValueWhenOriginalStartsWithZero == 1 ? 0 : 1; \\n            }\\n        }\\n\\n        if(derived[N-1] == 1){\\n            return (currentValueWhenOriginalStartsWithOne == 0) || (currentValueWhenOriginalStartsWithZero == 1);\\n        }else\\n            return (currentValueWhenOriginalStartsWithOne == 1) || (currentValueWhenOriginalStartsWithZero == 0);  \\n    }\\n}\\n\\nclass SolutionRecursive {\\n    public boolean doesValidArrayExist(int[] derived) {\\n        return solve(derived, 0, 1, 1) \\n             || solve(derived, 0, 0, 0);\\n    }\\n\\n    public boolean solve(int[] derived, int index, int first, int current){\\n        if(index == derived.length-1){\\n            if(derived[index]==1){\\n                return (current==1 && first==0) || (current==0 && first==1);\\n            }else{\\n                return (current==0 && first==0) || (current==1 && first==1);\\n            }\\n        }\\n        if(derived[index] == 1){\\n            return solve(derived, index+1, first, current == 1 ? 0 : 1);\\n        }else{\\n            return solve(derived, index+1, first, current);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3931794,
                "title": "soln-in-cpp",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool doesValidArrayExist(vector<int>& derived) \\n    {\\n        int count=0;\\n        for(int i=0;i<derived.size();i++)\\n        {\\n            if(derived[i]==1)\\n                count++;\\n        }\\n        if(count%2==0)\\n            return true;\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool doesValidArrayExist(vector<int>& derived) \\n    {\\n        int count=0;\\n        for(int i=0;i<derived.size();i++)\\n        {\\n            if(derived[i]==1)\\n                count++;\\n        }\\n        if(count%2==0)\\n            return true;\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3906322,
                "title": "c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n public:\\n  bool doesValidArrayExist(vector<int>& derived) {\\n    //      original = [O[0], O[1], ..., O[n - 1]]\\n    //       derived = [O[0]^O[1], O[1]^O[2], ..., O[n - 1]^O[0]]\\n    // XOR(derivedd) = 0\\n    return accumulate(derived.begin(), derived.end(), 0, bit_xor<>()) == 0;\\n  }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n public:\\n  bool doesValidArrayExist(vector<int>& derived) {\\n    //      original = [O[0], O[1], ..., O[n - 1]]\\n    //       derived = [O[0]^O[1], O[1]^O[2], ..., O[n - 1]^O[0]]\\n    // XOR(derivedd) = 0\\n    return accumulate(derived.begin(), derived.end(), 0, bit_xor<>()) == 0;\\n  }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3893015,
                "title": "o-n-time-o-1-space-in-place-java",
                "content": "# Code\\n```\\nclass Solution {\\n    public boolean doesValidArrayExist(int[] derived) {\\n        int n = derived.length;\\n        int prevBit = derived[0];\\n        //int[] original = new int[n];\\n        for (int i = 1; i < n; i++) {\\n            int currentBit = derived[i];\\n            derived[i] = derived[i-1] ^ prevBit;\\n            prevBit = currentBit;\\n        }\\n        return (derived[n-1] ^ derived[0]) == prevBit;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean doesValidArrayExist(int[] derived) {\\n        int n = derived.length;\\n        int prevBit = derived[0];\\n        //int[] original = new int[n];\\n        for (int i = 1; i < n; i++) {\\n            int currentBit = derived[i];\\n            derived[i] = derived[i-1] ^ prevBit;\\n            prevBit = currentBit;\\n        }\\n        return (derived[n-1] ^ derived[0]) == prevBit;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3890443,
                "title": "cpp-simple-soln",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool doesValidArrayExist(vector<int>& d) {\\n        if(d.size()==1){\\n            if(d[0]==0) return true;return false;\\n        }\\n        int a,b,x;\\n        if(d[0]==0){\\n            a=0;b=0;x=0;\\n        }\\n        else{\\n            a=1;b=0;x=1;\\n        }\\n        for(int i=1;i<d.size()-1;i++){\\n            if(d[i]==1){\\n                if(b==0){\\n                    a=b;b=1;\\n                }\\n                else{\\n                    a=b;\\n                    b=0;\\n                }\\n            }\\n            else{\\n                 if(b==0){\\n                    a=b;b=0;\\n                }\\n                else{\\n                    a=b;\\n                    b=1;\\n                }\\n            }\\n        }\\n        if(d[d.size()-1]==0){\\n            if((x==0&&b==0)||(x==1&&b==1)) return true;\\n            return false;\\n        }\\n        else{\\n            if((x==0&&b==1)||(x==1&&b==0)) return true;\\n            return false;\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool doesValidArrayExist(vector<int>& d) {\\n        if(d.size()==1){\\n            if(d[0]==0) return true;return false;\\n        }\\n        int a,b,x;\\n        if(d[0]==0){\\n            a=0;b=0;x=0;\\n        }\\n        else{\\n            a=1;b=0;x=1;\\n        }\\n        for(int i=1;i<d.size()-1;i++){\\n            if(d[i]==1){\\n                if(b==0){\\n                    a=b;b=1;\\n                }\\n                else{\\n                    a=b;\\n                    b=0;\\n                }\\n            }\\n            else{\\n                 if(b==0){\\n                    a=b;b=0;\\n                }\\n                else{\\n                    a=b;\\n                    b=1;\\n                }\\n            }\\n        }\\n        if(d[d.size()-1]==0){\\n            if((x==0&&b==0)||(x==1&&b==1)) return true;\\n            return false;\\n        }\\n        else{\\n            if((x==0&&b==1)||(x==1&&b==0)) return true;\\n            return false;\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3889059,
                "title": "c-solution",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    bool doesValidArrayExist(vector<int>& derived) {\\n        int n = derived.size();\\n        vector<int>original(n + 1);\\n        for(int i = 0; i < n; i++){\\n            if(original[i] ^ 0 == derived[i]) original[i + 1] = 0;\\n            else original[i + 1] = 1;\\n        }\\n        for(int i = 0; i < n - 1; i++){\\n            if(original[i] ^ original[i + 1] != derived[i]) return false;\\n        }\\n        return original[0] ^ original[n - 1] == derived[n - 1];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool doesValidArrayExist(vector<int>& derived) {\\n        int n = derived.size();\\n        vector<int>original(n + 1);\\n        for(int i = 0; i < n; i++){\\n            if(original[i] ^ 0 == derived[i]) original[i + 1] = 0;\\n            else original[i + 1] = 1;\\n        }\\n        for(int i = 0; i < n - 1; i++){\\n            if(original[i] ^ original[i + 1] != derived[i]) return false;\\n        }\\n        return original[0] ^ original[n - 1] == derived[n - 1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3858582,
                "title": "o-n-solution-simplest-fastest-soln",
                "content": "# O(n) solution simplest & fastest soln\\nIf vector start with 1 derived[0] can be 1 or 0 both (1^0 = 1 1^1 = 0) so one soln will always start wit 1 another with 0 (if exist)\\n```\\n\\n\\nclass Solution {\\npublic:\\n    bool doesValidArrayExist(vector<int> derived) \\n    {\\n        vector<int> ans{1};\\n        for(int i=0;i<derived.size()-1;i++)\\n        if(derived[i]==0)\\n        ans.push_back(ans.back());\\n        else\\n        ans.push_back(!ans.back());\\n        \\n\\n        return ans.back()^ans[0]==derived.back();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n\\n\\nclass Solution {\\npublic:\\n    bool doesValidArrayExist(vector<int> derived) \\n    {\\n        vector<int> ans{1};\\n        for(int i=0;i<derived.size()-1;i++)\\n        if(derived[i]==0)\\n        ans.push_back(ans.back());\\n        else\\n        ans.push_back(!ans.back());\\n        \\n\\n        return ans.back()^ans[0]==derived.back();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3842124,
                "title": "beats-98-59-super-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\nvector<int> ans1,ans2;\\n    bool doesValidArrayExist(vector<int>& derived) {\\n        if(derived[0]==1)\\n        {\\n            ans1.push_back(0);\\n            ans1.push_back(1);\\n            ans2.push_back(1);\\n            ans2.push_back(0);\\n        }\\n        else\\n        {\\n            ans1.push_back(1);\\n            ans1.push_back(1);\\n            ans2.push_back(0);\\n            ans2.push_back(0);\\n        }\\n        for(int i=1;i<derived.size();i++)\\n        {\\n            int t = derived[i];\\n            if(t==1)\\n            {\\n                int val = (ans1.back()==1)?0:1;\\n                ans1.push_back(val);\\n                val = (ans2.back()==1)?0:1;\\n                ans2.push_back(val);\\n            }\\n            else\\n            {\\n                int val = (ans1.back()==1)?1:0;\\n                ans1.push_back(val);\\n                val = (ans2.back()==1)?1:0;\\n                ans2.push_back(val);\\n            }\\n        }\\n\\n        return ((ans1[0]==ans1[ans1.size()-1]) || (ans2[0]==ans2[ans2.size()-1]));\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nvector<int> ans1,ans2;\\n    bool doesValidArrayExist(vector<int>& derived) {\\n        if(derived[0]==1)\\n        {\\n            ans1.push_back(0);\\n            ans1.push_back(1);\\n            ans2.push_back(1);\\n            ans2.push_back(0);\\n        }\\n        else\\n        {\\n            ans1.push_back(1);\\n            ans1.push_back(1);\\n            ans2.push_back(0);\\n            ans2.push_back(0);\\n        }\\n        for(int i=1;i<derived.size();i++)\\n        {\\n            int t = derived[i];\\n            if(t==1)\\n            {\\n                int val = (ans1.back()==1)?0:1;\\n                ans1.push_back(val);\\n                val = (ans2.back()==1)?0:1;\\n                ans2.push_back(val);\\n            }\\n            else\\n            {\\n                int val = (ans1.back()==1)?1:0;\\n                ans1.push_back(val);\\n                val = (ans2.back()==1)?1:0;\\n                ans2.push_back(val);\\n            }\\n        }\\n\\n        return ((ans1[0]==ans1[ans1.size()-1]) || (ans2[0]==ans2[ans2.size()-1]));\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3835466,
                "title": "easiest-sol-c",
                "content": "bhailog dekho simple approach hai dekho je yeh\\noriginal array hai usme har ek element 2 bar aa raha hai matlab uske sare elements ka xor 0 hoga \\nab hum derived element ka xor check kar lenge kua vo 0 hai to return 1\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool doesValidArrayExist(vector<int>& d) {\\n       int m=0;\\n        for(auto x:d)\\n            m^=x;\\n        if(m==0)return 1;\\n        else return 0;\\n       \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool doesValidArrayExist(vector<int>& d) {\\n       int m=0;\\n        for(auto x:d)\\n            m^=x;\\n        if(m==0)return 1;\\n        else return 0;\\n       \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3815697,
                "title": "golang-bit-manipulation-solution",
                "content": "# Complexity\\n- Time complexity: O(N)\\n- Space complexity: O(N)\\n\\n# Code\\n```go\\nfunc doesValidArrayExist(derived []int) bool {\\n\\torigin0 := make([]int, len(derived))\\n\\torigin1 := make([]int, len(derived))\\n\\torigin1[0] = 1\\n\\tfor i := 0; i < len(derived)-1; i++ {\\n\\t\\torigin0[i+1] = derived[i] ^ origin0[i]\\n\\t\\torigin1[i+1] = derived[i] ^ origin1[i]\\n\\t}\\n\\tif derived[len(derived)-1] == origin0[len(derived)-1] ^ origin0[0] {\\n\\t\\treturn true\\n\\t}\\n\\tif derived[len(derived)-1] == origin1[len(derived)-1] ^ origin1[0] {\\n\\t\\treturn true\\n\\t}\\n\\treturn false\\n}\\n```",
                "solutionTags": [
                    "Go",
                    "Bit Manipulation"
                ],
                "code": "```go\\nfunc doesValidArrayExist(derived []int) bool {\\n\\torigin0 := make([]int, len(derived))\\n\\torigin1 := make([]int, len(derived))\\n\\torigin1[0] = 1\\n\\tfor i := 0; i < len(derived)-1; i++ {\\n\\t\\torigin0[i+1] = derived[i] ^ origin0[i]\\n\\t\\torigin1[i+1] = derived[i] ^ origin1[i]\\n\\t}\\n\\tif derived[len(derived)-1] == origin0[len(derived)-1] ^ origin0[0] {\\n\\t\\treturn true\\n\\t}\\n\\tif derived[len(derived)-1] == origin1[len(derived)-1] ^ origin1[0] {\\n\\t\\treturn true\\n\\t}\\n\\treturn false\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3811597,
                "title": "c-solution-simple-intuitive-construct-a-plausible-original-vector",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\nSince the \\'derived\\' binary array is the result of an XOR operation we have information about the original vector. Every bit in the derived vector contains comparison information about the original vector:\\n> every 1 must be the result of (0 xor 1) or (1 xor 0), i.e. neighbors were different \\n> every 0 must be the result of (0 xor 0) or (1 xor 1), i.e. neighbors were the same\\n\\nExample:\\nderived = [1, 1, 0]\\n> original [0] != original [1]\\n> original [1] != original [2]\\n> original [2] == original [0]\\n\\nderived = [1, 1]\\n> original [0] != original [1]\\n> original [1] != original [0]\\n\\nderived = [1, 0]\\n> original [0] != original [1]\\n> original [1] == original [0]\\n>> a contradiction!!\\n\\nderived = [1, 0, 1]\\n> original [0] != original [1]\\n> original [1] == original [2]\\n> original [2] != original [0]\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThis approach isn\\'t the fastest, but constructs a pluasible original vector.\\n\\nWe start by initializing our original vector with 0, (it doesn\\'t matter if the original vector is initialized with a 0 or 1, since we only know the comparison information anyways.)\\n\\nThen, we iterate through the derived vector, and keep adding bits to the original vector:\\n\\nThe next bit to add to the original vector will be:\\n> The same as the last bit added if the derived vector is (0)\\n> The opposite as the last bit added if the derived vector is (1)\\n\\nFinally, to see if the original vector is valid we look at the last bit of comparison information in the derived vector, which compares the first and last bits. \\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool doesValidArrayExist(vector<int>& derived) {\\n        vector<int> original;\\n        original.push_back(0); // assume a starting bit\\n\\n        // add bits to original vector, based on the comparison information in the derived bit vector.\\n        // if a bit in the derived vector is::\\n        //                 \\'1\\' -> meaning the neighbor bits in the original were different\\n        //                 \\'0\\' -> meaning the neighbor bits in the original were the same\\n        for(int i = 0; i < derived.size()-1; i ++){\\n            if (derived.at(i) == 0){\\n                original.push_back(original.at(i));\\n            } else {\\n                original.push_back(!original.at(i));\\n            }\\n        }\\n        // to determine if a valid array exists, we determine if the comparison information in the derived bit vector \\n        // is consistant with the start and end bits of our constructed \\'original\\' vector.\\n        if (derived.back() == 0){\\n            return original.front() == original.back();\\n        } else {\\n            return original.front() != original.back();\\n        }\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool doesValidArrayExist(vector<int>& derived) {\\n        vector<int> original;\\n        original.push_back(0); // assume a starting bit\\n\\n        // add bits to original vector, based on the comparison information in the derived bit vector.\\n        // if a bit in the derived vector is::\\n        //                 \\'1\\' -> meaning the neighbor bits in the original were different\\n        //                 \\'0\\' -> meaning the neighbor bits in the original were the same\\n        for(int i = 0; i < derived.size()-1; i ++){\\n            if (derived.at(i) == 0){\\n                original.push_back(original.at(i));\\n            } else {\\n                original.push_back(!original.at(i));\\n            }\\n        }\\n        // to determine if a valid array exists, we determine if the comparison information in the derived bit vector \\n        // is consistant with the start and end bits of our constructed \\'original\\' vector.\\n        if (derived.back() == 0){\\n            return original.front() == original.back();\\n        } else {\\n            return original.front() != original.back();\\n        }\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3781517,
                "title": "simple-approach",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool doesValidArrayExist(vector<int>& derived) {\\n        int n = derived.size();\\n        int temp1 = 0;\\n        int temp2 = 1;\\n        for(int i=0;i<n-1;i++)\\n        {\\n            temp1 ^= derived[i];\\n            temp2 ^= derived[i];\\n        }\\n        if(temp1 ^ 0 == derived[n-1])\\n            return true;\\n        if(temp2 ^ 1 == derived[n-1])\\n            return true;\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool doesValidArrayExist(vector<int>& derived) {\\n        int n = derived.size();\\n        int temp1 = 0;\\n        int temp2 = 1;\\n        for(int i=0;i<n-1;i++)\\n        {\\n            temp1 ^= derived[i];\\n            temp2 ^= derived[i];\\n        }\\n        if(temp1 ^ 0 == derived[n-1])\\n            return true;\\n        if(temp2 ^ 1 == derived[n-1])\\n            return true;\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3781146,
                "title": "just-straight-simulatiom",
                "content": "# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\nO(n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool doesValidArrayExist(vector<int>& derived) {\\n\\n        vector<int> actual (derived.size());\\n        actual[0] = 1;\\n\\n        for(int i = 0; i < derived.size(); i++){\\n\\n            if(i == derived.size() - 1){\\n                \\n                if(derived[i] == 1){\\n\\n                    if(actual[i] == actual[0]) return false;\\n                    return true;\\n                }else{\\n                     if(actual[i] == actual[0]) return true;\\n                     return false;\\n                }\\n\\n            }else{\\n\\n                if(derived[i] == 1){ //different\\n\\n                   actual[i + 1] = !actual[i];\\n                }else{\\n                    actual[i + 1] = actual[i]; //same\\n                }\\n            }\\n        }\\n        return false;\\n        \\n    }\\n};\\n\\n\\n/*\\n\\n[1, 1, 0]\\n\\n[1, 0, 1]\\n\\n*/\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool doesValidArrayExist(vector<int>& derived) {\\n\\n        vector<int> actual (derived.size());\\n        actual[0] = 1;\\n\\n        for(int i = 0; i < derived.size(); i++){\\n\\n            if(i == derived.size() - 1){\\n                \\n                if(derived[i] == 1){\\n\\n                    if(actual[i] == actual[0]) return false;\\n                    return true;\\n                }else{\\n                     if(actual[i] == actual[0]) return true;\\n                     return false;\\n                }\\n\\n            }else{\\n\\n                if(derived[i] == 1){ //different\\n\\n                   actual[i + 1] = !actual[i];\\n                }else{\\n                    actual[i + 1] = actual[i]; //same\\n                }\\n            }\\n        }\\n        return false;\\n        \\n    }\\n};\\n\\n\\n/*\\n\\n[1, 1, 0]\\n\\n[1, 0, 1]\\n\\n*/\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3755460,
                "title": "python-o-n-solution-just-simulated-easy-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n2 elements xor results in 1 means differ from previous one, xor results in 0 means same as previous element\\nso just simulated the processes:(presume first item is 1 or 0, both fine!)\\nfollow the derived generate next item until last one.\\ncompare the last item with first(presumed) if there is contradiction return Ture without conlict\\n\\n**if derived[-1]==1 means fist ans last ones must be different\\nif derived[-1]==0 means fist ans last one must be identical**\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(N)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    O(1)\\n\\n# Code\\n```\\nclass Solution(object):\\n    def doesValidArrayExist(self, derived):\\n        \"\"\"\\n        :type derived: List[int]\\n        :rtype: bool\\n        \"\"\"\\n        def _try(fst,derived):\\n            last=fst\\n            for d in derived[:-1]:last=1-last if d==1 else last\\n            return (derived[-1] and fst!=last) or (not derived[-1] and fst==last)\\n\\n        return _try(1,derived) \\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def doesValidArrayExist(self, derived):\\n        \"\"\"\\n        :type derived: List[int]\\n        :rtype: bool\\n        \"\"\"\\n        def _try(fst,derived):\\n            last=fst\\n            for d in derived[:-1]:last=1-last if d==1 else last\\n            return (derived[-1] and fst!=last) or (not derived[-1] and fst==last)\\n\\n        return _try(1,derived) \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3748194,
                "title": "easy-solution-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool doesValidArrayExist(vector<int>& d) {\\n        int m=0;\\n        for(int i=0;i<d.size();i++)\\n            m^=d[i];\\n        if(m==0)\\n            return 1;\\n        else\\n            return 0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool doesValidArrayExist(vector<int>& d) {\\n        int m=0;\\n        for(int i=0;i<d.size();i++)\\n            m^=d[i];\\n        if(m==0)\\n            return 1;\\n        else\\n            return 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3728272,
                "title": "easy-c-solution-just-by-calculating-xor",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1) Constant space\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool doesValidArrayExist(vector<int>& derived) {\\n        int xo=0;\\n        for(int i=0;i<derived.size();i++)\\n        {\\n            xo=xo^derived[i];\\n        }\\n        if(xo==0)\\n        return true;\\n        return false;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool doesValidArrayExist(vector<int>& derived) {\\n        int xo=0;\\n        for(int i=0;i<derived.size();i++)\\n        {\\n            xo=xo^derived[i];\\n        }\\n        if(xo==0)\\n        return true;\\n        return false;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3728271,
                "title": "easy-c-solution-just-by-calculating-xor",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1) Constant space\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool doesValidArrayExist(vector<int>& derived) {\\n        int xo=0;\\n        for(int i=0;i<derived.size();i++)\\n        {\\n            xo=xo^derived[i];\\n        }\\n        if(xo==0)\\n        return true;\\n        return false;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool doesValidArrayExist(vector<int>& derived) {\\n        int xo=0;\\n        for(int i=0;i<derived.size();i++)\\n        {\\n            xo=xo^derived[i];\\n        }\\n        if(xo==0)\\n        return true;\\n        return false;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3725939,
                "title": "3-line-solution-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool doesValidArrayExist(vector<int>& d) {\\n       int m=0;\\n        for(auto i:d)\\n            m ^= i;\\n        return m==0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool doesValidArrayExist(vector<int>& d) {\\n       int m=0;\\n        for(auto i:d)\\n            m ^= i;\\n        return m==0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3717699,
                "title": "1-liner",
                "content": "```\\nbool doesValidArrayExist(vector<int>& d)\\n{\\n\\treturn accumulate(begin(d), end(d), 1, bit_xor{});\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nbool doesValidArrayExist(vector<int>& d)\\n{\\n\\treturn accumulate(begin(d), end(d), 1, bit_xor{});\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3690129,
                "title": "easy-approach-using-xor-property",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nas cyclic every element of original  appear in twice in derived array so xorr of derived must be zero\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nwe are using property xor of same element is zero as derived[i]=original[i]^original[i+1] and cyclic so all come two times so if xor of derived array is zero then true otherwise false\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool doesValidArrayExist(vector<int>& derived) {\\n      int xorr = 0;\\n      for(auto it:derived) {\\n          xorr^=it;\\n      }\\nif(xorr==0){\\n    return true;\\n}\\nreturn false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool doesValidArrayExist(vector<int>& derived) {\\n      int xorr = 0;\\n      for(auto it:derived) {\\n          xorr^=it;\\n      }\\nif(xorr==0){\\n    return true;\\n}\\nreturn false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3684847,
                "title": "simplest-java-solution-beats-100-3-lines-clean-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean doesValidArrayExist(int[] derived) {\\n        int xor = 0;\\n        for(int i=0; i<derived.length; i++)\\n            xor=xor^derived[i];\\n        if(xor==0) return true;\\n        return false; \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\n    public boolean doesValidArrayExist(int[] derived) {\\n        int xor = 0;\\n        for(int i=0; i<derived.length; i++)\\n            xor=xor^derived[i];\\n        if(xor==0) return true;\\n        return false; \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3676427,
                "title": "logical-solution-with-explanation-cpp",
                "content": "# Intuition\\nSay we start from any of 0 or 1 in original array . Whenever we encounter a 1 in derived array that signifies we need to change the 0 to 1 or 1 to 0. So an odd number of 1 in derived array will change 0 or 1 in the begining odd number of time and this will not be equal to arr[0] when we return back.\\n\\n# Approach\\nSo if derived array contains odd number of 1\\'s then return false.Else true.(Do some dry run youself on notebook to better understad this).\\nNote: Last line (count&1) checks if count is odd or even.\\n\\n# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool doesValidArrayExist(vector<int>& derived) {\\n        int count=0;\\n        for(int i=0;i<derived.size();i++)\\n        {\\n            if(derived[i]==1)\\n            {\\n                count++;\\n            }\\n        }\\n        return (count&1)?false:true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool doesValidArrayExist(vector<int>& derived) {\\n        int count=0;\\n        for(int i=0;i<derived.size();i++)\\n        {\\n            if(derived[i]==1)\\n            {\\n                count++;\\n            }\\n        }\\n        return (count&1)?false:true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3673761,
                "title": "java-simple-solution-clean-code",
                "content": "# Complexity\\n- Time complexity: $O(n)$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $O(1)$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```java\\nclass Solution {\\n    public boolean doesValidArrayExist(int[] derived) {\\n        int xor = 0;\\n        for(var d:derived) xor ^= d;\\n        return xor == 0;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```java\\nclass Solution {\\n    public boolean doesValidArrayExist(int[] derived) {\\n        int xor = 0;\\n        for(var d:derived) xor ^= d;\\n        return xor == 0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3669959,
                "title": "easy-and-simple-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool doesValidArrayExist(vector<int>& derived) {\\n        int n=derived.size();\\n        int c=0;\\n        for(int i=0;i<n;i++){\\n            c^=derived[i];\\n        }\\n        if(c==0){\\n            return true;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool doesValidArrayExist(vector<int>& derived) {\\n        int n=derived.size();\\n        int c=0;\\n        for(int i=0;i<n;i++){\\n            c^=derived[i];\\n        }\\n        if(c==0){\\n            return true;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3663808,
                "title": "c-check-all-xor",
                "content": "```\\nclass Solution {\\npublic:\\n    bool doesValidArrayExist(vector<int>& derived) {\\n        int x=0;\\n        for(auto&i:derived)x^=i;\\n        return !x;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool doesValidArrayExist(vector<int>& derived) {\\n        int x=0;\\n        for(auto&i:derived)x^=i;\\n        return !x;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3654955,
                "title": "easy-to-understand-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    private:\\n    bool solve(int val,vector<int>& derived,vector<int>&original ){\\n        original[0]=val;\\n         for(int i=0;i<derived.size();i++){\\n             if(i==derived.size()-1){\\n                 if((~val^original[0])==derived[i]){\\n                     original[i]=~val;\\n                 }\\n                 if((val^original[0])==derived[i]){\\n                     original[i]=val;\\n                 }\\n             } \\n             else{\\n                 // original[i+1] = 0/1\\n                if((~val^original[i])==derived[i]){\\n                     original[i+1]=~val;\\n                 }\\n                if((val^original[i])==derived[i]){\\n                     original[i+1]=val;\\n                 }\\n             }\\n         }\\n         vector<int>dr(derived.size());\\n\\n         for(int i=0;i<original.size();i++){\\n             if(i==derived.size()-1){\\n                dr[i]=original[i]^original[0];\\n             }\\n             else{\\n                 dr[i]=original[i]^original[i+1];\\n             }\\n         }\\n         \\n         return derived==dr;\\n    }\\npublic:\\n    bool doesValidArrayExist(vector<int>& derived) {\\n        vector<int>original(derived.size());\\n        bool ans=solve(0,derived,original) or solve(1,derived,original);\\n        return ans;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n    private:\\n    bool solve(int val,vector<int>& derived,vector<int>&original ){\\n        original[0]=val;\\n         for(int i=0;i<derived.size();i++){\\n             if(i==derived.size()-1){\\n                 if((~val^original[0])==derived[i]){\\n                     original[i]=~val;\\n                 }\\n                 if((val^original[0])==derived[i]){\\n                     original[i]=val;\\n                 }\\n             } \\n             else{\\n                 // original[i+1] = 0/1\\n                if((~val^original[i])==derived[i]){\\n                     original[i+1]=~val;\\n                 }\\n                if((val^original[i])==derived[i]){\\n                     original[i+1]=val;\\n                 }\\n             }\\n         }\\n         vector<int>dr(derived.size());\\n\\n         for(int i=0;i<original.size();i++){\\n             if(i==derived.size()-1){\\n                dr[i]=original[i]^original[0];\\n             }\\n             else{\\n                 dr[i]=original[i]^original[i+1];\\n             }\\n         }\\n         \\n         return derived==dr;\\n    }\\npublic:\\n    bool doesValidArrayExist(vector<int>& derived) {\\n        vector<int>original(derived.size());\\n        bool ans=solve(0,derived,original) or solve(1,derived,original);\\n        return ans;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3614687,
                "title": "simplest-solution-with-simple-explanation",
                "content": "# Intuition\\n```\\nAll rests on the fact that x^x = 0 and x^0 = x.\\nHence, since  derived[i] = original[i] ^ original[(i+1)%n]\\n=> original[(i+1)%n] = derived[i] ^ original[i].  That is, the next element of original is completely determined by the current element of original and derived.\\n\\nHence, we simply test the two possible starting points: original[0] = 0 or original[0] = 1 and use those to compute the rest of the values and check that our endpoint is the same as our starting point.\\n```\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(1)$$\\n\\n# Code\\n```\\n\\nclass Solution:\\n    def doesValidArrayExist(self, derived: List[int]) -> bool:\\n        current = 0\\n        for i in range((n := len(derived))):\\n            current ^= derived[i] \\n\\n        if current == 0:\\n            return True\\n        \\n        current = 1\\n        for i in range((n := len(derived))):\\n            current ^= derived[i] \\n\\n        if current  == 1:\\n            return True\\n        \\n        return False\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nAll rests on the fact that x^x = 0 and x^0 = x.\\nHence, since  derived[i] = original[i] ^ original[(i+1)%n]\\n=> original[(i+1)%n] = derived[i] ^ original[i].  That is, the next element of original is completely determined by the current element of original and derived.\\n\\nHence, we simply test the two possible starting points: original[0] = 0 or original[0] = 1 and use those to compute the rest of the values and check that our endpoint is the same as our starting point.\\n```\n```\\n\\nclass Solution:\\n    def doesValidArrayExist(self, derived: List[int]) -> bool:\\n        current = 0\\n        for i in range((n := len(derived))):\\n            current ^= derived[i] \\n\\n        if current == 0:\\n            return True\\n        \\n        current = 1\\n        for i in range((n := len(derived))):\\n            current ^= derived[i] \\n\\n        if current  == 1:\\n            return True\\n        \\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3611505,
                "title": "solution-for-c",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool doesValidArrayExist(vector<int>& derived) {\\n      int i,j,k;\\n      vector<int>r(derived.size(),0);\\n      for(i=0;i<derived.size()-1;i++)\\n          {\\n                if(derived[i]==(r[i]^r[i+1])){\\n                    ;\\n                }\\n                else{\\n                    r[i+1]=1;\\n                }\\n          }\\nif(derived[derived.size()-1]==(r[0]^r[r.size()-1]))\\n    return true;\\n    \\n    return false;  \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool doesValidArrayExist(vector<int>& derived) {\\n      int i,j,k;\\n      vector<int>r(derived.size(),0);\\n      for(i=0;i<derived.size()-1;i++)\\n          {\\n                if(derived[i]==(r[i]^r[i+1])){\\n                    ;\\n                }\\n                else{\\n                    r[i+1]=1;\\n                }\\n          }\\nif(derived[derived.size()-1]==(r[0]^r[r.size()-1]))\\n    return true;\\n    \\n    return false;  \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3589661,
                "title": "c-1st-latter-is-1-or-0-take-possiblity-can-derived-a-i-a-i-1-givenarra-i-1-chek",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool doesValidArrayExist(vector<int>& derived) {\\n        \\n        int n = derived.size();\\n        vector<int> arr1(n,0) , arr2(n,0);\\n        arr2[0] = 1 ;\\n        \\n        for( int i = 1 ; i < n ; ++i )\\n        {\\n            arr1[i] = arr1[i-1] ^ derived[i-1] ; \\n            arr2[i] = arr2[i-1] ^ derived[i-1] ;   \\n        }\\n        \\n        if( arr1[n-1] ^ derived[n-1] == 0 )\\n        {\\n            return true;\\n        }\\n        \\n        if(arr2[n-1] ^ derived[n-1]  == 1 ) \\n        {\\n            return true;\\n        }\\n        \\n        return false;\\n        \\n        \\n        \\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool doesValidArrayExist(vector<int>& derived) {\\n        \\n        int n = derived.size();\\n        vector<int> arr1(n,0) , arr2(n,0);\\n        arr2[0] = 1 ;\\n        \\n        for( int i = 1 ; i < n ; ++i )\\n        {\\n            arr1[i] = arr1[i-1] ^ derived[i-1] ; \\n            arr2[i] = arr2[i-1] ^ derived[i-1] ;   \\n        }\\n        \\n        if( arr1[n-1] ^ derived[n-1] == 0 )\\n        {\\n            return true;\\n        }\\n        \\n        if(arr2[n-1] ^ derived[n-1]  == 1 ) \\n        {\\n            return true;\\n        }\\n        \\n        return false;\\n        \\n        \\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3574632,
                "title": "simple-xor-operation-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool doesValidArrayExist(vector<int>& d) {\\n        int x=1;\\n        int curr=x;\\n        int last;\\n        for(int i=0;i<d.size();i++){\\n            last=curr;\\n            if(d[i]==1){\\n                if(curr==1)curr=0;\\n                else{\\n                    curr=1;\\n                }\\n\\n            }\\n           \\n        }\\n        return (x==curr);\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool doesValidArrayExist(vector<int>& d) {\\n        int x=1;\\n        int curr=x;\\n        int last;\\n        for(int i=0;i<d.size();i++){\\n            last=curr;\\n            if(d[i]==1){\\n                if(curr==1)curr=0;\\n                else{\\n                    curr=1;\\n                }\\n\\n            }\\n           \\n        }\\n        return (x==curr);\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3574021,
                "title": "c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n  \\n    bool doesValidArrayExist(vector<int>& derived) {\\n        int k=0;\\n      for(int i=0;i<derived.size();i++)\\n      {\\n          if(derived[i]==1)\\n          {\\n            k++;  \\n          }\\n      }\\n  return k%2-1;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n  \\n    bool doesValidArrayExist(vector<int>& derived) {\\n        int k=0;\\n      for(int i=0;i<derived.size();i++)\\n      {\\n          if(derived[i]==1)\\n          {\\n            k++;  \\n          }\\n      }\\n  return k%2-1;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3570508,
                "title": "java-very-simple-solution-recursion",
                "content": "```\\nclass Solution {\\n    public boolean doesValidArrayExist(int[] arr) {\\n        ArrayList<Integer> al = new ArrayList<Integer>();\\n        al.add(1);\\n        if(comb(arr,0,al)==true)return true;\\n        return false;\\n    }\\n   private boolean comb(int arr[],int i,ArrayList<Integer> al)\\n   {\\n       if(al.size()==arr.length)\\n           if((al.get(i)^(al.get(0)))==arr[i]) return true;\\n           else return false;\\n       \\n       if((al.get(i)^0)==arr[i] || (al.get(0)^al.get(i))==arr[i])\\n       {\\n           if((al.get(i)^0)==arr[i])al.add(0);\\n           else al.add(al.get(0));\\n           if(comb(arr,i+1,al)==true)return true;\\n           else return false;\\n       } \\n       return false;\\n   }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public boolean doesValidArrayExist(int[] arr) {\\n        ArrayList<Integer> al = new ArrayList<Integer>();\\n        al.add(1);\\n        if(comb(arr,0,al)==true)return true;\\n        return false;\\n    }\\n   private boolean comb(int arr[],int i,ArrayList<Integer> al)\\n   {\\n       if(al.size()==arr.length)\\n           if((al.get(i)^(al.get(0)))==arr[i]) return true;\\n           else return false;\\n       \\n       if((al.get(i)^0)==arr[i] || (al.get(0)^al.get(i))==arr[i])\\n       {\\n           if((al.get(i)^0)==arr[i])al.add(0);\\n           else al.add(al.get(0));\\n           if(comb(arr,i+1,al)==true)return true;\\n           else return false;\\n       } \\n       return false;\\n   }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3568290,
                "title": "shortest-easiest-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool doesValidArrayExist(vector<int>& v) {\\n        int k=accumulate(v.begin(),v.end(),0);\\n        return k%2==0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool doesValidArrayExist(vector<int>& v) {\\n        int k=accumulate(v.begin(),v.end(),0);\\n        return k%2==0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3567069,
                "title": "easy-c-code-optimized",
                "content": "# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n### PLease Upvote if u liked my Solution\\uD83E\\uDD17\\n```\\nclass Solution {\\npublic:\\n    bool doesValidArrayExist(vector<int>& derived) {\\n        int XOR = 0;\\n        for(auto it:derived)\\n            XOR ^=it;\\n        if(XOR == 0) \\n            return true;\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool doesValidArrayExist(vector<int>& derived) {\\n        int XOR = 0;\\n        for(auto it:derived)\\n            XOR ^=it;\\n        if(XOR == 0) \\n            return true;\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3554791,
                "title": "accepted-swift",
                "content": "```\\nclass Solution {\\n    func doesValidArrayExist(_ derived: [Int]) -> Bool {\\n        derived.reduce(0, ^) == 0\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func doesValidArrayExist(_ derived: [Int]) -> Bool {\\n        derived.reduce(0, ^) == 0\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3549666,
                "title": "simple-o-n-brut-force-approach-beats-60",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool doesValidArrayExist(vector<int>& derived) {\\n        int num = 1;\\n        for(auto &d: derived){\\n            if(d == 1) num = 1-num;\\n        }\\n        return (num == 1);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool doesValidArrayExist(vector<int>& derived) {\\n        int num = 1;\\n        for(auto &d: derived){\\n            if(d == 1) num = 1-num;\\n        }\\n        return (num == 1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3546199,
                "title": "simple-go",
                "content": "# Intuition\\nAfter simulating a few examples by hand, realised it\\'s only about the number of 1 being odd\\n\\n# Code\\n```\\nfunc doesValidArrayExist(derived []int) bool {\\n    cntOne := 0\\n    for _,v := range derived {\\n        cntOne += v\\n    }\\n    return cntOne % 2 == 0\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc doesValidArrayExist(derived []int) bool {\\n    cntOne := 0\\n    for _,v := range derived {\\n        cntOne += v\\n    }\\n    return cntOne % 2 == 0\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3545987,
                "title": "simple-java-solution",
                "content": "# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean doesValidArrayExist(int[] derived) {\\n        int n=derived.length;\\n        if(n==1) return derived[0]!=0?false:true;    \\n        int[] original=new int[n];\\n        for(int i=1;i<n;i++) original[i]=(derived[i-1]^original[i-1]);\\n        if((original[n-1]^original[0])==derived[n-1]) return true;\\n        return false; \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean doesValidArrayExist(int[] derived) {\\n        int n=derived.length;\\n        if(n==1) return derived[0]!=0?false:true;    \\n        int[] original=new int[n];\\n        for(int i=1;i<n;i++) original[i]=(derived[i-1]^original[i-1]);\\n        if((original[n-1]^original[0])==derived[n-1]) return true;\\n        return false; \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3545808,
                "title": "one-liner-c-pattern-xorsum",
                "content": "\\n# Approach\\nxor sum should be zero.\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool doesValidArrayExist(vector<int>& nums) {\\n        int xo = 0;\\n        for(auto i: nums) xo = (xo^i);\\n        return !xo;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool doesValidArrayExist(vector<int>& nums) {\\n        int xo = 0;\\n        for(auto i: nums) xo = (xo^i);\\n        return !xo;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3545368,
                "title": "c-easy-to-understand",
                "content": "```\\n bool doesValidArrayExist(vector<int>& d) {\\n        \\n        int n=d.size();\\n        if(n==1){\\n            if(d[0]==0)\\n                return 1;\\n            else\\n                return 0;\\n        }\\n        vector<int>v(n);\\n        if(d[0]==0)\\n            v[0]=1,v[1]=1;\\n        else\\n            v[0]=1,v[1]=0;\\n        for(int i=1;i<n-1;i++){\\n            if(v[i]==1 && d[i]==1)\\n                v[i+1]=0;\\n            if(v[i]==0 && d[i]==1)\\n                v[i+1]=1;\\n            if(v[i]==1 && d[i]==0)\\n                v[i+1]=1;\\n            if(v[i]==0 && d[i]==0)\\n                v[i+1]=0;\\n        }\\n        return v[n-1]^v[0]==d[n-1];\\n        \\n    }\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n bool doesValidArrayExist(vector<int>& d) {\\n        \\n        int n=d.size();\\n        if(n==1){\\n            if(d[0]==0)\\n                return 1;\\n            else\\n                return 0;\\n        }\\n        vector<int>v(n);\\n        if(d[0]==0)\\n            v[0]=1,v[1]=1;\\n        else\\n            v[0]=1,v[1]=0;\\n        for(int i=1;i<n-1;i++){\\n            if(v[i]==1 && d[i]==1)\\n                v[i+1]=0;\\n            if(v[i]==0 && d[i]==1)\\n                v[i+1]=1;\\n            if(v[i]==1 && d[i]==0)\\n                v[i+1]=1;\\n            if(v[i]==0 && d[i]==0)\\n                v[i+1]=0;\\n        }\\n        return v[n-1]^v[0]==d[n-1];\\n        \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3545060,
                "title": "simple-property-of-bitwise-xor-easy-solution-best-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. --\\n>\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution\\n{\\npublic:\\n    bool doesValidArrayExist(vector<int> &derived)\\n    {\\n        vector<int> ans;\\n        ans.push_back(0);\\n        int cnt1 = 0;\\n        int n = derived.size();\\n        int val1=0;\\n        int val2=0;\\n        for (int i = 0; i < derived.size(); i++)\\n        {\\n            if (i == n - 1)\\n            {\\n                 val2= derived[i] ^ ans[0];\\n                 if(val1==val2){\\n                     return true;\\n                 }\\n                   ans.push_back(val2);\\n            }\\n            else\\n            {\\n                 val1 = derived[i] ^ ans[i];\\n                   ans.push_back(val1);\\n            }\\n          \\n        }\\n       \\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution\\n{\\npublic:\\n    bool doesValidArrayExist(vector<int> &derived)\\n    {\\n        vector<int> ans;\\n        ans.push_back(0);\\n        int cnt1 = 0;\\n        int n = derived.size();\\n        int val1=0;\\n        int val2=0;\\n        for (int i = 0; i < derived.size(); i++)\\n        {\\n            if (i == n - 1)\\n            {\\n                 val2= derived[i] ^ ans[0];\\n                 if(val1==val2){\\n                     return true;\\n                 }\\n                   ans.push_back(val2);\\n            }\\n            else\\n            {\\n                 val1 = derived[i] ^ ans[i];\\n                   ans.push_back(val1);\\n            }\\n          \\n        }\\n       \\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3545059,
                "title": "simple-property-of-bitwise-xor-easy-solution-best-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. --\\n>\\na^b=c then \\na^c=b\\nb^c=a...\\nbased on this property\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution\\n{\\npublic:\\n    bool doesValidArrayExist(vector<int> &derived)\\n    {\\n        vector<int> ans;\\n        ans.push_back(0);\\n        int cnt1 = 0;\\n        int n = derived.size();\\n        int val1=0;\\n        int val2=0;\\n        for (int i = 0; i < derived.size(); i++)\\n        {\\n            if (i == n - 1)\\n            {\\n                 val2= derived[i] ^ ans[0];\\n                 if(val1==val2){\\n                     return true;\\n                 }\\n                   ans.push_back(val2);\\n            }\\n            else\\n            {\\n                 val1 = derived[i] ^ ans[i];\\n                   ans.push_back(val1);\\n            }\\n          \\n        }\\n       \\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution\\n{\\npublic:\\n    bool doesValidArrayExist(vector<int> &derived)\\n    {\\n        vector<int> ans;\\n        ans.push_back(0);\\n        int cnt1 = 0;\\n        int n = derived.size();\\n        int val1=0;\\n        int val2=0;\\n        for (int i = 0; i < derived.size(); i++)\\n        {\\n            if (i == n - 1)\\n            {\\n                 val2= derived[i] ^ ans[0];\\n                 if(val1==val2){\\n                     return true;\\n                 }\\n                   ans.push_back(val2);\\n            }\\n            else\\n            {\\n                 val1 = derived[i] ^ ans[i];\\n                   ans.push_back(val1);\\n            }\\n          \\n        }\\n       \\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3544537,
                "title": "cpp-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    bool isvalid(bool first,bool pre,int ind ,vector<int>&v)\\n    {\\n        if(ind==v.size()-1)\\n        {\\n            if(v[v.size()-1]==1)\\n                return first!=pre;\\n            return first==pre;\\n        }\\n        if(v[ind]==1)\\n        {\\n           if(pre)\\n               return isvalid(first,0,ind+1,v);\\n            return isvalid(first,1,ind+1,v);\\n        }\\n        if(pre)\\n            return isvalid(first,1,ind+1,v);\\n        return isvalid(first,0,ind+1,v);\\n        \\n    }\\n    bool doesValidArrayExist(vector<int>& derived) {\\n        return isvalid(0,0,0,derived)||isvalid(1,1,0,derived);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    bool isvalid(bool first,bool pre,int ind ,vector<int>&v)\\n    {\\n        if(ind==v.size()-1)\\n        {\\n            if(v[v.size()-1]==1)\\n                return first!=pre;\\n            return first==pre;\\n        }\\n        if(v[ind]==1)\\n        {\\n           if(pre)\\n               return isvalid(first,0,ind+1,v);\\n            return isvalid(first,1,ind+1,v);\\n        }\\n        if(pre)\\n            return isvalid(first,1,ind+1,v);\\n        return isvalid(first,0,ind+1,v);\\n        \\n    }\\n    bool doesValidArrayExist(vector<int>& derived) {\\n        return isvalid(0,0,0,derived)||isvalid(1,1,0,derived);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3544296,
                "title": "go-with-truth-table-of-xor",
                "content": "Truth table of xor\\n\\ni1  i2  out\\n0   0   0\\n0   1   1\\n1   0   1\\n1   1   0\\n\\nAt 0th index or nth index of help 2d array one of the entry should match.\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(2n+2)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool doesValidArrayExist(vector<int>& derived) {\\n        int n = derived.size();\\n        // if(n == 1){\\n        //     if(derived[0] == 0)return true;\\n        //     else return false;\\n        // }\\n        vector<vector<int>> help(n+1, vector<int>(2));\\n        if(derived[0] == 0){\\n            help[0][0] = 0; help[1][0] = 0;\\n            help[0][1] = 1; help[1][1] = 1;\\n        }else{\\n            help[0][0] = 0; help[1][0] = 1;\\n            help[0][1] = 1; help[1][1] = 0;\\n        }\\n        for(int i = 1;i<n;i++){\\n            if(derived[i] == 0){// res = 0\\n                if(help[i][0] == 1){\\n                    help[i+1][0] = 1;\\n                    help[i+1][1] = 0;\\n                }else{\\n                    help[i+1][0] = 0;\\n                    help[i+1][1] = 1;\\n                }\\n            }else{\\n                if(help[i][0] == 1){\\n                    help[i+1][0] = 0;\\n                    help[i+1][1] = 1;\\n                }else{\\n                    help[i+1][0] = 1;\\n                    help[i+1][1] = 0;\\n                }\\n            }\\n        }\\n        \\n        if(help[n][0] == help[0][0] or help[n][1] == help[0][1])\\n            return true;\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool doesValidArrayExist(vector<int>& derived) {\\n        int n = derived.size();\\n        // if(n == 1){\\n        //     if(derived[0] == 0)return true;\\n        //     else return false;\\n        // }\\n        vector<vector<int>> help(n+1, vector<int>(2));\\n        if(derived[0] == 0){\\n            help[0][0] = 0; help[1][0] = 0;\\n            help[0][1] = 1; help[1][1] = 1;\\n        }else{\\n            help[0][0] = 0; help[1][0] = 1;\\n            help[0][1] = 1; help[1][1] = 0;\\n        }\\n        for(int i = 1;i<n;i++){\\n            if(derived[i] == 0){// res = 0\\n                if(help[i][0] == 1){\\n                    help[i+1][0] = 1;\\n                    help[i+1][1] = 0;\\n                }else{\\n                    help[i+1][0] = 0;\\n                    help[i+1][1] = 1;\\n                }\\n            }else{\\n                if(help[i][0] == 1){\\n                    help[i+1][0] = 0;\\n                    help[i+1][1] = 1;\\n                }else{\\n                    help[i+1][0] = 1;\\n                    help[i+1][1] = 0;\\n                }\\n            }\\n        }\\n        \\n        if(help[n][0] == help[0][0] or help[n][1] == help[0][1])\\n            return true;\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3543952,
                "title": "c",
                "content": "bool doesValidArrayExist(vector<int>& derived) {\\n        int n=derived.size();\\n        vector<int>original(n);\\n        original[0]=derived[0];\\n        for(int i=0;i<n-1;i++){\\n            if(derived[i]==1){\\n                original[i+1]=!original[i];\\n            }\\n            else{\\n                original[i+1]=original[i];\\n            }\\n        }\\n        if(original[0]^original[n-1]==derived[n-1])\\n            return true;\\n        return false;\\n\\n    }",
                "solutionTags": [],
                "code": "bool doesValidArrayExist(vector<int>& derived) {\\n        int n=derived.size();\\n        vector<int>original(n);\\n        original[0]=derived[0];\\n        for(int i=0;i<n-1;i++){\\n            if(derived[i]==1){\\n                original[i+1]=!original[i];\\n            }\\n            else{\\n                original[i+1]=original[i];\\n            }\\n        }\\n        if(original[0]^original[n-1]==derived[n-1])\\n            return true;\\n        return false;\\n\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3543670,
                "title": "complete-brute-force-and-optimized-code-100-working-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nif xor is 0 implies that input can be 1 1 or 0 0\\nelse if xor is 1 implies that input is 1 0 or 0 1\\naccording to the first derived we find out all the original nos and finally check the final derived element wrt to first and last element of the generated original array and return true or false accordingly.\\n\\nor else we can simply xor all the elemnts of the derived array and check if the result is 0 or not.\\n(a[0]^a[1]^a[1]^a[2] and so on a[n-1]^a[0]==0)\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool doesValidArrayExist(vector<int>& derived) {\\n        if(derived.size()==1)\\n        {\\n            if(derived[0]==0)\\n            {\\n                return true;\\n            }\\n            return false;\\n        }\\n        int n = derived.size();\\n        if(derived[0]==0)\\n        {\\n            int temp = 0;\\n            for(int i=1;i<derived.size()-1;i++)\\n            {\\n                temp = temp^derived[i];\\n            }\\n            \\n            if((temp^0)==derived[n-1])\\n            {\\n                return true;\\n            }\\n            \\n            temp = 1;\\n            for(int i=1;i<derived.size()-1;i++)\\n            {\\n                temp = temp^derived[i];\\n            }\\n            \\n            if((temp^1)==derived[n-1])\\n            {\\n                return true;\\n            }\\n            else\\n            {\\n                return false;\\n            }\\n        }\\n        else\\n        {\\n            int temp = 1;\\n            for(int i=1;i<derived.size()-1;i++)\\n            {\\n                temp = temp^derived[i];\\n            }\\n            \\n            if((temp^0)==derived[n-1])\\n            {\\n                return true;\\n            }\\n            \\n            temp = 0;\\n            for(int i=1;i<derived.size()-1;i++)\\n            {\\n                temp = temp^derived[i];\\n            }\\n            \\n            if((temp^1)==derived[n-1])\\n            {\\n                return true;\\n            }\\n            else\\n            {\\n                return false;\\n            }\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool doesValidArrayExist(vector<int>& derived) {\\n        if(derived.size()==1)\\n        {\\n            if(derived[0]==0)\\n            {\\n                return true;\\n            }\\n            return false;\\n        }\\n        int n = derived.size();\\n        if(derived[0]==0)\\n        {\\n            int temp = 0;\\n            for(int i=1;i<derived.size()-1;i++)\\n            {\\n                temp = temp^derived[i];\\n            }\\n            \\n            if((temp^0)==derived[n-1])\\n            {\\n                return true;\\n            }\\n            \\n            temp = 1;\\n            for(int i=1;i<derived.size()-1;i++)\\n            {\\n                temp = temp^derived[i];\\n            }\\n            \\n            if((temp^1)==derived[n-1])\\n            {\\n                return true;\\n            }\\n            else\\n            {\\n                return false;\\n            }\\n        }\\n        else\\n        {\\n            int temp = 1;\\n            for(int i=1;i<derived.size()-1;i++)\\n            {\\n                temp = temp^derived[i];\\n            }\\n            \\n            if((temp^0)==derived[n-1])\\n            {\\n                return true;\\n            }\\n            \\n            temp = 0;\\n            for(int i=1;i<derived.size()-1;i++)\\n            {\\n                temp = temp^derived[i];\\n            }\\n            \\n            if((temp^1)==derived[n-1])\\n            {\\n                return true;\\n            }\\n            else\\n            {\\n                return false;\\n            }\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3542361,
                "title": "c-simplest-solution-using-single-iteration-and-xor",
                "content": "# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool doesValidArrayExist(vector<int>& derived) {\\n\\n        int total = 0;\\n\\n        for(auto it : derived) \\n            total = total ^ it;\\n\\n        return total == 0;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool doesValidArrayExist(vector<int>& derived) {\\n\\n        int total = 0;\\n\\n        for(auto it : derived) \\n            total = total ^ it;\\n\\n        return total == 0;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3540056,
                "title": "java-simple-brut-force",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean doesValidArrayExist(int[] d) {\\n        //o[(i+1)%n]= (d[i]==0) ? o[i] : 1-o[i] now we can brut force start with 0 and then with 1\\n        return (check(d,0)||check(d,1));\\n    }\\n\\n\\n    public boolean check(int[] d, int start){\\n        int n = d.length;\\n        int o[] =new int [n];\\n        o[0]=start;\\n        for(int i=1;i<n;i++)\\n            o[i] = (d[i-1] == 0) ? o[i-1] : 1- o[i-1] ;\\n        if (d[n-1]==0 && o[n-1]==o[0] || d[n-1]==1 && o[n-1]!=o[0]) return true;\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean doesValidArrayExist(int[] d) {\\n        //o[(i+1)%n]= (d[i]==0) ? o[i] : 1-o[i] now we can brut force start with 0 and then with 1\\n        return (check(d,0)||check(d,1));\\n    }\\n\\n\\n    public boolean check(int[] d, int start){\\n        int n = d.length;\\n        int o[] =new int [n];\\n        o[0]=start;\\n        for(int i=1;i<n;i++)\\n            o[i] = (d[i-1] == 0) ? o[i-1] : 1- o[i-1] ;\\n        if (d[n-1]==0 && o[n-1]==o[0] || d[n-1]==1 && o[n-1]!=o[0]) return true;\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3539629,
                "title": "simple-clean-and-short-solution-c-easy-explanation",
                "content": "# Intuition\\nFor the Input derived array 110 original array is 010\\n\\nexplanation:-\\nderived array:\\n1 1 0 eqv 0^1 1^0 1^0\\nfrom here we can see that derived array is formed by orginal array where each element of the original elemnt repeted twice.\\n\\nso the sum of the array in which each elements repetead twice is = 0\\n(as XOR of two same vale is 0)\\n\\n1^1^0=(0^1)^(1^0)^(1^0)=0\\n\\n# Approach\\nIterate a single for loop and take a result of the XOR of all elements.\\n\\nreturn true if result is 0 else false.\\n\\n# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool doesValidArrayExist(vector<int>& derived) {\\n        int ops=derived[0];\\n        for(int i=1;i<derived.size();i++)\\n            ops^=derived[i];\\n        return ops^1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool doesValidArrayExist(vector<int>& derived) {\\n        int ops=derived[0];\\n        for(int i=1;i<derived.size();i++)\\n            ops^=derived[i];\\n        return ops^1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3538677,
                "title": "rust",
                "content": "```\\nimpl Solution {\\n    pub fn does_valid_array_exist(derived: Vec<i32>) -> bool {\\n        let mut original = vec![0; derived.len()];\\n\\n        for i in 1..derived.len() {\\n            if derived[i - 1] == 0 {\\n                original[i] = original[i - 1];\\n            } else {\\n                original[i] = 1 - original[i - 1];\\n            }\\n        }\\n        derived[derived.len() - 1] == original[0] ^ original[derived.len() - 1]\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn does_valid_array_exist(derived: Vec<i32>) -> bool {\\n        let mut original = vec![0; derived.len()];\\n\\n        for i in 1..derived.len() {\\n            if derived[i - 1] == 0 {\\n                original[i] = original[i - 1];\\n            } else {\\n                original[i] = 1 - original[i - 1];\\n            }\\n        }\\n        derived[derived.len() - 1] == original[0] ^ original[derived.len() - 1]\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3538198,
                "title": "xor-0-java-c-python",
                "content": "Java\\n```\\nclass Solution {\\n    public boolean doesValidArrayExist(List<Integer> derived) {\\n        int x = 0;\\n        for (int it : derived) {\\n            x = x ^ it;\\n        }\\n\\n        return (x == 0);\\n    }\\n}\\n\\n```\\nC++\\n```\\nclass Solution\\n{\\n    public:\\n        bool doesValidArrayExist(vector<int> &derived)\\n        {\\n            int x = 0;\\n            for (auto it: derived)\\n            {\\n                x = x ^ it;\\n            }\\n\\n            return (x == 0);\\n        }\\n};\\n```\\nPython\\n```\\nclass Solution:\\n    def doesValidArrayExist(self, derived):\\n        x = 0\\n        for it in derived:\\n            x = x ^ it\\n\\n        return x == 0\\n```",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public boolean doesValidArrayExist(List<Integer> derived) {\\n        int x = 0;\\n        for (int it : derived) {\\n            x = x ^ it;\\n        }\\n\\n        return (x == 0);\\n    }\\n}\\n\\n```\n```\\nclass Solution\\n{\\n    public:\\n        bool doesValidArrayExist(vector<int> &derived)\\n        {\\n            int x = 0;\\n            for (auto it: derived)\\n            {\\n                x = x ^ it;\\n            }\\n\\n            return (x == 0);\\n        }\\n};\\n```\n```\\nclass Solution:\\n    def doesValidArrayExist(self, derived):\\n        x = 0\\n        for it in derived:\\n            x = x ^ it\\n\\n        return x == 0\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3537572,
                "title": "xor-cpp-sol-2-liner",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool doesValidArrayExist(vector<int>& derived) {\\n        int s = 0;\\n        for (auto i:derived) s ^= i;\\n        return s == 0; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool doesValidArrayExist(vector<int>& derived) {\\n        int s = 0;\\n        for (auto i:derived) s ^= i;\\n        return s == 0; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3537042,
                "title": "c-solution-bit-manipulation",
                "content": "```\\nproperties of xor:\\nfor any number A\\n\\nA ^ A = 0\\nA ^ 0 = A\\n```\\n\\n```\\ngiven,\\nn -> length of array arr , derived\\nas derived[i] = arr[i]^arr[(i+1)%n]\\nfor a given array derived check is it possible to construct an array \"arr\"\\n```\\n\\n```\\nconsider this \\n\\nn = 3\\narr = {a,b,c}\\n\\nderived[0] = a ^ b\\nderived[1] = b ^ c\\nderived[2] = c ^ a\\n\\nthen xor of derived[0]^derived[1]^....derived[n-1] == 0 \\n```\\n\\n```\\nclass Solution {\\npublic:\\n    bool doesValidArrayExist(vector<int>& derived) {\\n        int val = 0;\\n        for(auto it : derived)\\n            val^=it;\\n        return val==0;\\n    }\\n};\\n```\\nupvote if it helps :)",
                "solutionTags": [
                    "C++",
                    "C",
                    "Array",
                    "Bit Manipulation"
                ],
                "code": "```\\nproperties of xor:\\nfor any number A\\n\\nA ^ A = 0\\nA ^ 0 = A\\n```\n```\\ngiven,\\nn -> length of array arr , derived\\nas derived[i] = arr[i]^arr[(i+1)%n]\\nfor a given array derived check is it possible to construct an array \"arr\"\\n```\n```\\nconsider this \\n\\nn = 3\\narr = {a,b,c}\\n\\nderived[0] = a ^ b\\nderived[1] = b ^ c\\nderived[2] = c ^ a\\n\\nthen xor of derived[0]^derived[1]^....derived[n-1] == 0 \\n```\n```\\nclass Solution {\\npublic:\\n    bool doesValidArrayExist(vector<int>& derived) {\\n        int val = 0;\\n        for(auto it : derived)\\n            val^=it;\\n        return val==0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3535138,
                "title": "easy-c-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool doesValidArrayExist(vector<int>& arr) {\\n        int sum=0;\\n        for(int i=0;i<arr.size();i++)\\n        {\\n            sum=sum^arr[i];\\n        }\\n        if(sum==0)\\n        {\\n            return true;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool doesValidArrayExist(vector<int>& arr) {\\n        int sum=0;\\n        for(int i=0;i<arr.size();i++)\\n        {\\n            sum=sum^arr[i];\\n        }\\n        if(sum==0)\\n        {\\n            return true;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3534491,
                "title": "simple-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool doesValidArrayExist(vector<int>& d) {\\n        int res=0;\\n        int n=d.size();\\n        for(int i=0;i<n-1;i++){\\n            res^=d[i];\\n        }\\n        return res==d[n-1];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool doesValidArrayExist(vector<int>& d) {\\n        int res=0;\\n        int n=d.size();\\n        for(int i=0;i<n-1;i++){\\n            res^=d[i];\\n        }\\n        return res==d[n-1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3534482,
                "title": "easy-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean doesValidArrayExist(int[] derived) {\\n        \\n        int n = derived.length;\\n        \\n        int arr1[] = new int[n+1];\\n        int arr2[] = new int[n+1];\\n        \\n        arr1[0] = 0;\\n        arr2[0] = 1;\\n        for(int i=1; i<=n; i++)\\n        {\\n            if(derived[i-1] == 1)\\n            {\\n                if(arr1[i-1]==0)\\n                {\\n                    arr1[i] = 1;\\n                }\\n                else\\n                {\\n                    arr1[i] = 0;\\n                }\\n                \\n                if(arr2[i-1] == 1)\\n                {\\n                    arr2[i] = 0;\\n                }\\n                else\\n                {\\n                    arr2[i] = 1;\\n                }\\n            }\\n            else\\n            {\\n                arr1[i] = arr1[i-1];\\n                arr2[i] = arr2[i-1];\\n            }\\n        }\\n        \\n        if(arr1[n] != arr1[0] && arr2[n] != arr2[0])\\n        {\\n            return false;\\n        }\\n        \\n        return true;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean doesValidArrayExist(int[] derived) {\\n        \\n        int n = derived.length;\\n        \\n        int arr1[] = new int[n+1];\\n        int arr2[] = new int[n+1];\\n        \\n        arr1[0] = 0;\\n        arr2[0] = 1;\\n        for(int i=1; i<=n; i++)\\n        {\\n            if(derived[i-1] == 1)\\n            {\\n                if(arr1[i-1]==0)\\n                {\\n                    arr1[i] = 1;\\n                }\\n                else\\n                {\\n                    arr1[i] = 0;\\n                }\\n                \\n                if(arr2[i-1] == 1)\\n                {\\n                    arr2[i] = 0;\\n                }\\n                else\\n                {\\n                    arr2[i] = 1;\\n                }\\n            }\\n            else\\n            {\\n                arr1[i] = arr1[i-1];\\n                arr2[i] = arr2[i-1];\\n            }\\n        }\\n        \\n        if(arr1[n] != arr1[0] && arr2[n] != arr2[0])\\n        {\\n            return false;\\n        }\\n        \\n        return true;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3533861,
                "title": "c-xor-all-elements-from-derived",
                "content": "# Intuition\\nIf derived is formed by using every element twice from original, so if we xor every element in derived, the result should be 0.\\n\\n# Approach\\nXor all elements from derived, and return true if the result is 0, otherwise false.\\n\\n# Complexity\\n- Time complexity: O(n)\\n\\n- Space complexity: O(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool doesValidArrayExist(vector<int>& derived) {\\n        int allXor = 0;\\n        for(int d : derived){\\n            allXor ^= d;\\n        }\\n\\n        return allXor == 0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool doesValidArrayExist(vector<int>& derived) {\\n        int allXor = 0;\\n        for(int d : derived){\\n            allXor ^= d;\\n        }\\n\\n        return allXor == 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3532567,
                "title": "very-easy-solution-only-3-lines-of-code",
                "content": "# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool doesValidArrayExist(vector<int>& derived) {\\n        int flag=0;\\n        for(auto it:derived) flag^=it;\\n        return flag==0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool doesValidArrayExist(vector<int>& derived) {\\n        int flag=0;\\n        for(auto it:derived) flag^=it;\\n        return flag==0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3530966,
                "title": "a-few-solutions",
                "content": "Use inversion: return `true` if-and-only-if the quantity of the value `1` in the derived array `A` is *even* (ie. it is impossible to create the derived array `A` otherwise).\\n\\n---\\n\\n*Kotlin*\\n```\\nclass Solution {\\n    var doesValidArrayExist = { A: IntArray -> A.sum() % 2 == 0 }\\n}\\n```\\n\\n*Javascript*\\n```\\nlet doesValidArrayExist = A => !(_.sum(A) & 1);\\n```\\n\\n*Python3*\\n```\\nclass Solution:\\n    doesValidArrayExist = lambda self, A: not(sum(A) & 1)\\n```\\n\\n*Rust*\\n```\\nimpl Solution {\\n    pub fn does_valid_array_exist(A: Vec<i32>) -> bool { A.into_iter().sum::<i32>() % 2 == 0 }\\n}\\n```\\n\\n*C++*\\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    bool doesValidArrayExist(VI& A) { return !(accumulate(A.begin(), A.end(), 0) & 1); }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    var doesValidArrayExist = { A: IntArray -> A.sum() % 2 == 0 }\\n}\\n```\n```\\nlet doesValidArrayExist = A => !(_.sum(A) & 1);\\n```\n```\\nclass Solution:\\n    doesValidArrayExist = lambda self, A: not(sum(A) & 1)\\n```\n```\\nimpl Solution {\\n    pub fn does_valid_array_exist(A: Vec<i32>) -> bool { A.into_iter().sum::<i32>() % 2 == 0 }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    bool doesValidArrayExist(VI& A) { return !(accumulate(A.begin(), A.end(), 0) & 1); }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3529638,
                "title": "xor-should-be-zero",
                "content": "```\\nclass Solution:\\n    def doesValidArrayExist(self, derived: List[int]) -> bool:\\n        xor=derived[0]\\n        for i in range(1,len(derived)):\\n            xor^=derived[i]\\n        return True if xor==0 else False",
                "solutionTags": [
                    "Python",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution:\\n    def doesValidArrayExist(self, derived: List[int]) -> bool:\\n        xor=derived[0]\\n        for i in range(1,len(derived)):\\n            xor^=derived[i]\\n        return True if xor==0 else False",
                "codeTag": "Java"
            },
            {
                "id": 3529351,
                "title": "python-start-equals-end",
                "content": "try first element in original with 0 and 1, respectively. After XOR with all the elements in derived, if the final value is equal to the start value we know there is an original.\\n\\n```\\nclass Solution:\\n    def doesValidArrayExist(self, derived: List[int]) -> bool:\\n        for start in [0, 1]:\\n            xor = start\\n            for i in derived:\\n                xor = xor ^ i\\n            if xor == start:\\n                return True\\n        return False\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def doesValidArrayExist(self, derived: List[int]) -> bool:\\n        for start in [0, 1]:\\n            xor = start\\n            for i in derived:\\n                xor = xor ^ i\\n            if xor == start:\\n                return True\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3528627,
                "title": "simple-o-n-solution",
                "content": "Assume that `original[0]=0`. Then we can pre-calculate the entire original array as `original[i+1] = original[i]^derived[i]`. At the end we must end up with zero as `original[0]` was assume to be zero. Essentially we are doing the entire simulation with an assumption. The same logic will also work with the assumption of `original[0]=1`.\\n\\n```\\nbool doesValidArrayExist(vector<int>& derived) \\n{\\n    int cur=0;\\n    for(int item: derived) cur^=item;\\n    return (cur==0);\\n}\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nbool doesValidArrayExist(vector<int>& derived) \\n{\\n    int cur=0;\\n    for(int item: derived) cur^=item;\\n    return (cur==0);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3528487,
                "title": "swift-one-liner-with-bool-explained",
                "content": "![XOR_TABLE.png](https://assets.leetcode.com/users/images/b5686452-517b-4059-86dc-623a17701ab3_1684176173.8591273.png)\\n\\n# Approach\\n###### Note that the function *xor* does not change its value when the input parameters are inverted, that is, for any $$A$$ and $$B$$ it is true that $$A \\u2295 B = notA \\u2295 notB$$. This means that if there is an original array that satisfies the condition of the problem, then an inverse of it will also be suitable. Hence we can safely assume that the original array, for example, starts with 1 and try to reconstruct it element by element.\\n###### Suppose that we have determined the value of the $$i$$-th element in the original array: `original[i]`. What can we say about the next, $$(i+1)$$-th element `original[i+1]`, looking at the result of *xor* of these two, that is `derived[i]`? It is easy to see that the output of the *xor* operation is 0 when the two input parameters are equal, and 1 when they are not. Thus, `if derived[i] == 0 { original[i+1] = original[i] } else { original[i+1] = !original[i] }`.\\n###### Proceed in this way through the whole array, determining the next element, until we get to the combination of the last element with the first one. Since the first element is already decided at the very beginning, the check if it gives the desired *xor* result with the last one will determine whether the reconstructed array is valid or not.\\n###### We don\\'t even need to store the whole reconstructed array during this process, the last current element is enough, as everything depends solely on it. Since we put that the first element must be 1 (*true*, in terms of Boolean logic), the final answer will be equal to the result of the last iteration: exists if that one is 1 (*true*), not exists if that one is 0 (*false*).\\n# Complexity\\n- Time complexity: $$O(n)$$\\n- Space complexity: $$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\n    func doesValidArrayExist(_ derived: [Int]) -> Bool {\\n        derived.reduce(true) { bool, num in num == 0 ? bool : !bool }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func doesValidArrayExist(_ derived: [Int]) -> Bool {\\n        derived.reduce(true) { bool, num in num == 0 ? bool : !bool }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3528078,
                "title": "java-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean doesValidArrayExist(int[] d) {\\n        int ans=0;\\n        for(int a:d){\\n            if(a==1)\\n                ans++;\\n        }\\n        return (ans%2==0);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean doesValidArrayExist(int[] d) {\\n        int ans=0;\\n        for(int a:d){\\n            if(a==1)\\n                ans++;\\n        }\\n        return (ans%2==0);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3527825,
                "title": "swift-simulate-generating-the-original-array",
                "content": "# Approach: Simulation\\n1. Simulate generating original array from derived array and check validity at each step.\\n1. Initialize the original array with `[false]` and the current index with 1. The initial value can be `[true]` as well, as long as it follows the `XOR` logic.\\n1. Loop through derived array and append new element based on previous rule.\\n1. Check last rule for first and last elements of original array.\\n1. Return `false` if any condition violated, else return `true`.\\n\\n# Code\\n```\\nclass Solution {\\n  func doesValidArrayExist(_ derived: [Int]) -> Bool {\\n    // If the derived array has only one element, then it must be 0 to have a valid array\\n    if derived.count == 1 {\\n      return derived.first! == 0\\n    }\\n    // Initialize the current index to 1 and the original array to [false]\\n    var currentIndex: Int = 1\\n    var original: [Bool] = [false]\\n    // Loop through the derived array\\n    for _ in 0..<derived.count {\\n      // If the current index is 0, then we have reached the end of the loop and need to check the last rule\\n      if currentIndex == 0 {\\n        // Get the last rule from the derived array\\n        let previousRule = derived.last!\\n        // If the last rule is 1, then the first and last elements of the original array must be different\\n        if previousRule == 1 {\\n          return original.last! != original.first!\\n        } else {\\n          // If the last rule is 0, then the first and last elements of the original array must be the same\\n          return original.first! == original.last!\\n        }\\n      } else {\\n        // If the current index is not 0, then we need to append a new element to the original array based on the previous rule\\n        if derived[currentIndex-1] == 1 {\\n          // If the previous rule is 1, then the new element must be the opposite of the previous element\\n          original.append(!original[currentIndex-1])\\n        } else {\\n          // If the previous rule is 0, then the new element must be the same as the previous element\\n          original.append(original[currentIndex-1])\\n        }\\n      }\\n      // Increment the current index by 1 and take modulo by the derived array count\\n      currentIndex = currentIndex + 1\\n      currentIndex = currentIndex % derived.count\\n    }\\n    // Return true if we reach this point without returning false earlier\\n    return true\\n  }\\n}\\n```",
                "solutionTags": [
                    "Swift",
                    "Array",
                    "Simulation"
                ],
                "code": "```\\nclass Solution {\\n  func doesValidArrayExist(_ derived: [Int]) -> Bool {\\n    // If the derived array has only one element, then it must be 0 to have a valid array\\n    if derived.count == 1 {\\n      return derived.first! == 0\\n    }\\n    // Initialize the current index to 1 and the original array to [false]\\n    var currentIndex: Int = 1\\n    var original: [Bool] = [false]\\n    // Loop through the derived array\\n    for _ in 0..<derived.count {\\n      // If the current index is 0, then we have reached the end of the loop and need to check the last rule\\n      if currentIndex == 0 {\\n        // Get the last rule from the derived array\\n        let previousRule = derived.last!\\n        // If the last rule is 1, then the first and last elements of the original array must be different\\n        if previousRule == 1 {\\n          return original.last! != original.first!\\n        } else {\\n          // If the last rule is 0, then the first and last elements of the original array must be the same\\n          return original.first! == original.last!\\n        }\\n      } else {\\n        // If the current index is not 0, then we need to append a new element to the original array based on the previous rule\\n        if derived[currentIndex-1] == 1 {\\n          // If the previous rule is 1, then the new element must be the opposite of the previous element\\n          original.append(!original[currentIndex-1])\\n        } else {\\n          // If the previous rule is 0, then the new element must be the same as the previous element\\n          original.append(original[currentIndex-1])\\n        }\\n      }\\n      // Increment the current index by 1 and take modulo by the derived array count\\n      currentIndex = currentIndex + 1\\n      currentIndex = currentIndex % derived.count\\n    }\\n    // Return true if we reach this point without returning false earlier\\n    return true\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3527360,
                "title": "easy-to-understand-for-beginners-fast-and-simple-o-n-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool doesValidArrayExist(vector<int>& derived) {\\n        int n= derived.size();\\n        int arr[n];\\n        arr[0]=1;\\n        \\n        for(int i=0; i<n-1; i++)\\n        {\\n            if(derived[i]==1)\\n                arr[i+1]= !(arr[i]);\\n            else\\n                arr[i+1]=arr[i];\\n        }\\n        \\n        if(arr[0]^arr[n-1]==derived[n-1])\\n            return true;\\n        else\\n            return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Math",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool doesValidArrayExist(vector<int>& derived) {\\n        int n= derived.size();\\n        int arr[n];\\n        arr[0]=1;\\n        \\n        for(int i=0; i<n-1; i++)\\n        {\\n            if(derived[i]==1)\\n                arr[i+1]= !(arr[i]);\\n            else\\n                arr[i+1]=arr[i];\\n        }\\n        \\n        if(arr[0]^arr[n-1]==derived[n-1])\\n            return true;\\n        else\\n            return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3527141,
                "title": "simple-java-solution",
                "content": "# Intuition\\n only two different cases are possible at index 0 for original array and remaining values at indices are dependent on previous index value.\\n# Approach\\nfirst try::\\n let first index of original array is 0\\n  every next index will be 1 or 0 depending on the value of derived[index-1] and original[index-1];\\n  for eg: original[index-1]=0,derived[index-1]=1\\n    original[index]=1 (because derived[index-1]=original[index-1]^original[index])\\nif operation (specified in problem statement) performed on original array gives derived array return true\\nsecond try ::\\nreeat above the process with first index of original array is 1\\nif two cases does not derive derived array return false;\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean doesValidArrayExist(int[] derived) {\\n        int n=derived.length;\\n        int[] answer=new int[n];\\n        answer[0]=0;\\n        for(int i=1;i<n;i++)\\n        {\\n            if(derived[i-1]==1)\\n            {\\n                answer[i]=(answer[i-1]==1)?0:1;\\n            }\\n            else\\n            {\\n                answer[i]=answer[i-1];\\n            }\\n        }\\n        if(check(answer,derived)) return true;\\n        answer[0]=1;\\n        for(int i=1;i<n;i++)\\n        {\\n            if(derived[i-1]==1)\\n            {\\n                answer[i]=(answer[i-1]==1)?0:1;\\n            }\\n            else\\n            {\\n                answer[i]=answer[i-1];\\n            }\\n        }\\n        if(check(answer,derived)) return true;\\n        return false;\\n    }\\n    public boolean check(int[] answer,int[] derived)\\n    {\\n        int[] temp=new int[answer.length];\\n        for(int i=0;i<answer.length;i++)\\n        {\\n            if(i==answer.length-1)\\n            {\\n                temp[i]=answer[i]^answer[0];\\n            }\\n            else\\n            temp[i]=answer[i]^answer[i+1];\\n            if(temp[i]!=derived[i])  return false;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean doesValidArrayExist(int[] derived) {\\n        int n=derived.length;\\n        int[] answer=new int[n];\\n        answer[0]=0;\\n        for(int i=1;i<n;i++)\\n        {\\n            if(derived[i-1]==1)\\n            {\\n                answer[i]=(answer[i-1]==1)?0:1;\\n            }\\n            else\\n            {\\n                answer[i]=answer[i-1];\\n            }\\n        }\\n        if(check(answer,derived)) return true;\\n        answer[0]=1;\\n        for(int i=1;i<n;i++)\\n        {\\n            if(derived[i-1]==1)\\n            {\\n                answer[i]=(answer[i-1]==1)?0:1;\\n            }\\n            else\\n            {\\n                answer[i]=answer[i-1];\\n            }\\n        }\\n        if(check(answer,derived)) return true;\\n        return false;\\n    }\\n    public boolean check(int[] answer,int[] derived)\\n    {\\n        int[] temp=new int[answer.length];\\n        for(int i=0;i<answer.length;i++)\\n        {\\n            if(i==answer.length-1)\\n            {\\n                temp[i]=answer[i]^answer[0];\\n            }\\n            else\\n            temp[i]=answer[i]^answer[i+1];\\n            if(temp[i]!=derived[i])  return false;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3527040,
                "title": "simplest-explained-solution-2-approaches",
                "content": "# Important things to understand\\n```\\nX ^ X = 0\\n2 ^ 2 = 0\\n\\nX ^ X ^ Y ^ Y = 0\\n2 ^ 5 ^ 2 ^ 5 = 0\\n\\n```\\nIt means that if same element is XORed even times then it becomes 0\\n\\n```\\nX ^ Y ^ X = Y  \\n1 ^ 5 ^ 1 = 5 \\n\\n```\\nHere the output becomes the element which appeard odd times and the elements appeared even times were cancelled out.\\n\\n# Derived Array\\nSuppose we have an `Original array` `[A B C D]`. The `Derived array`, by definition, will be `[A xor B, B xor C, C xor D, D xor A]`. Here we can see that every element of the `Original array` appears twice in the `Derived array`.\\n\\n# Approach\\nSo whenever we derive an array from `original array` consisting `1\\'s` and `0\\'s`. The `Derived array` will always contain `even` no. of `1\\'s`because we now know that every element appears twice to construct the`Derived array`\\n \\nSo it is not possible to contain`odd` number of `1\\'s` in the `Derived array` , if that is the case we will `return false` or else `return true`.\\n\\n# Solution\\n`Now we have 2 solutions: `\\n1. we can perform `XOR` operation on all elements of the `Derived array`\\n\\n    example 1: `[1,1,0]`    1 ^ 1 ^ 0 = 0, Ans is `True` because 1 appeared even times     \\n\\n    example 2: `[1,1,0,1]` 1 ^ 1 ^ 0 ^ 1 = 1, Ans is `False` because 1 appeared odd times\\n\\n```\\nclass Solution {\\n    public boolean doesValidArrayExist(int[] derived) {\\n        int ans = 0;\\n        for(int i=0; i<derived.length; i++){\\n            ans ^= derived[i];\\n        }\\n        return ans==0; \\n    }\\n} \\n```\\n2. We can simply count the number of `1\\'s `in the `derived array` and if the count of `1` is `even` we\\'ll return `true` or else `false`;\\n\\n```\\nclass Solution {\\n    public boolean doesValidArrayExist(int[] derived) {\\n        int ans = 0;\\n        for(int i=0; i<derived.length; i++){\\n            ans += derived[i];\\n        }\\n        return ans%2==0; \\n    }\\n} \\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Bit Manipulation"
                ],
                "code": "```\\nX ^ X = 0\\n2 ^ 2 = 0\\n\\nX ^ X ^ Y ^ Y = 0\\n2 ^ 5 ^ 2 ^ 5 = 0\\n\\n```\n```\\nX ^ Y ^ X = Y  \\n1 ^ 5 ^ 1 = 5 \\n\\n```\n```\\nclass Solution {\\n    public boolean doesValidArrayExist(int[] derived) {\\n        int ans = 0;\\n        for(int i=0; i<derived.length; i++){\\n            ans ^= derived[i];\\n        }\\n        return ans==0; \\n    }\\n} \\n```\n```\\nclass Solution {\\n    public boolean doesValidArrayExist(int[] derived) {\\n        int ans = 0;\\n        for(int i=0; i<derived.length; i++){\\n            ans += derived[i];\\n        }\\n        return ans%2==0; \\n    }\\n} \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3526849,
                "title": "c",
                "content": "```C []\\nstatic int sum_ints(const int * const nums, const int numsLen){\\n\\tint sum = 0;\\n\\tfor (int i = 0; i < numsLen; i += 1){\\n\\t\\tsum += nums[i];\\n\\t}\\n\\treturn sum;\\n}\\n\\nbool doesValidArrayExist(int* derived, int derivedSize){\\n\\treturn sum_ints(derived, derivedSize) % 2 == 0;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```C []\\nstatic int sum_ints(const int * const nums, const int numsLen){\\n\\tint sum = 0;\\n\\tfor (int i = 0; i < numsLen; i += 1){\\n\\t\\tsum += nums[i];\\n\\t}\\n\\treturn sum;\\n}\\n\\nbool doesValidArrayExist(int* derived, int derivedSize){\\n\\treturn sum_ints(derived, derivedSize) % 2 == 0;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3526791,
                "title": "o-n-single-pass-intuition-explanation",
                "content": "# Intuition\\nLook at the short examples, e.g. derived array of length 2.\\nIf original array was `1, 1`, then derived array would be `0, 0` (and also if original array was `0, 0`). If the elements in the original array of length two were different, then the derived array woul be `1, 1`. Notice that there is no original array which would result in `0, 1` or `1, 0` as derived array.\\n\\nCan we guess the original array knowing the derived array? Looking at the first element in the derived, what can we say about the first two elements in the original array? \\nAssuming the first element in the original array is `0`, what is the second element, given the derived array?\\n\\n# Approach\\nFollowing the intuition section, we notice that we can pick a value for the first element in the original array, and see if we reach the same value by solving for the next element in the original array.\\n\\nWe use the fact that xor is commutative and `a xor a = 0`, so `a xor b xor a = b`. That means, to compute the second element in derived, we xor `derived[0]` with our initial guess for `original[0]`.\\n\\nIf we repeat the steps for every element, we should obtain `original[0]` at the end. I.e. `xor(<all elements in derived>) == 0`.\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$, as we do one pass over the input array. \\n\\n- Space complexity:\\n$$O(1)$$ - we only store the xor result.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool doesValidArrayExist(vector<int>& derived) {\\n        int crt_guess = 0;\\n        for (int ii = 0; ii < derived.size(); ++ii) {\\n            crt_guess = crt_guess ^ derived[ii];\\n        }\\n        return crt_guess == 0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool doesValidArrayExist(vector<int>& derived) {\\n        int crt_guess = 0;\\n        for (int ii = 0; ii < derived.size(); ++ii) {\\n            crt_guess = crt_guess ^ derived[ii];\\n        }\\n        return crt_guess == 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3526771,
                "title": "kotlin-easy-solution",
                "content": "# Code\\n```\\nclass Solution {\\n    fun doesValidArrayExist(derived: IntArray): Boolean {\\n        val n = derived.size\\n\\n        val bits = BooleanArray(n){ false }\\n        bits[0] = true\\n\\n        for (i in 0 until n - 1) {\\n            if (derived[i] == 1) {\\n                bits[i + 1] = bits[i].not()\\n            } else {\\n                bits[i + 1] = bits[i]\\n            }\\n        }\\n\\n        return if(derived[n - 1] == 1) bits[n - 1] != bits[0] else bits[n - 1] == bits[0]\\n    }\\n}\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\nclass Solution {\\n    fun doesValidArrayExist(derived: IntArray): Boolean {\\n        val n = derived.size\\n\\n        val bits = BooleanArray(n){ false }\\n        bits[0] = true\\n\\n        for (i in 0 until n - 1) {\\n            if (derived[i] == 1) {\\n                bits[i + 1] = bits[i].not()\\n            } else {\\n                bits[i + 1] = bits[i]\\n            }\\n        }\\n\\n        return if(derived[n - 1] == 1) bits[n - 1] != bits[0] else bits[n - 1] == bits[0]\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3526687,
                "title": "neighboring-bitwise-xor",
                "content": "**Solution-1**\\n2 ways to make original array\\n\\noriginal1[0] = 0 (array starting with 0)\\noriginal2[0] = 1 (array starting wiht 1)\\n\\nand then keep building more on both of the arrays.\\n\\nIf any of the array (either original1 or original2) satifies then return true else false.\\n```\\nclass Solution {\\npublic:\\n    \\n    bool doesValidArrayExist(vector<int>& derived) {\\n        int n=derived.size();\\n        vector<int>original1(n);\\n        vector<int>original2(n);\\n        original1[0]=0;\\n        original2[0]=1;\\n        \\n        for(int i=1;i<n;i++)\\n        {\\n            original1[i]=derived[i-1] ^ original1[i-1];\\n            original2[i]=derived[i-1] ^ original2[i-1];\\n        }\\n        return ((derived[n-1]==original1[n-1]^original1[0]) || (derived[n-1]==original2[n-1]^original2[0]));\\n        \\n    }\\n};\\n```\\n\\n**Solution-2**\\nderived[0] = original[0] ^ original[1]\\nderived[1] = original[1] ^ original[2]\\nderived[2] = original[2] ^ original[3]\\n...\\nderived[n-2] = original[n-2] ^ original[n-1]\\nderived[n-1] = original[n-1] ^ original[0]\\n\\nOn xoring both the sides\\n\\nLHS\\nderived[0] ^ derived[1] ^ derived[2] ^ ... ^ derived[n-1] => same as xoring entire derived array.\\n\\nRHS\\nsince every element will appear twice so it will result into zero.\\n\\nHence valid binary array original will exist only when xor(derived) = zero.\\n\\nSummary:\\nEvery element is appearing twice in the entire process.\\nThat means at the end if xor of the entire element =0 then there exists a valid binary array, otherwise not.\\n\\n```\\n\\nclass Solution {\\npublic:\\n    bool doesValidArrayExist(vector<int>& derived) {\\n        int ans=0;\\n        for(auto x: derived)\\n        {\\n            ans=ans^x;\\n        }\\n        return (ans==0);\\n    }\\n```\\n\\none-liner code \\n```\\nclass Solution {\\npublic:\\n    bool doesValidArrayExist(vector<int>& derived) {\\n        return !accumulate(derived.begin(), derived.end(), 0, bit_xor<int>());\\n    }\\n};\\n```\\n\\n**Solution-3**\\nWhen original and derived is a binary sequence, then this equals to sum(derived)%2==0.\\n\\n```\\nclass Solution {\\npublic:\\n    bool doesValidArrayExist(vector<int>& derived) {\\n        return accumulate(begin(derived),end(derived),0)%2==0;\\n    }\\n};\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    bool doesValidArrayExist(vector<int>& derived) {\\n        int n=derived.size();\\n        vector<int>original1(n);\\n        vector<int>original2(n);\\n        original1[0]=0;\\n        original2[0]=1;\\n        \\n        for(int i=1;i<n;i++)\\n        {\\n            original1[i]=derived[i-1] ^ original1[i-1];\\n            original2[i]=derived[i-1] ^ original2[i-1];\\n        }\\n        return ((derived[n-1]==original1[n-1]^original1[0]) || (derived[n-1]==original2[n-1]^original2[0]));\\n        \\n    }\\n};\\n```\n```\\n\\nclass Solution {\\npublic:\\n    bool doesValidArrayExist(vector<int>& derived) {\\n        int ans=0;\\n        for(auto x: derived)\\n        {\\n            ans=ans^x;\\n        }\\n        return (ans==0);\\n    }\\n```\n```\\nclass Solution {\\npublic:\\n    bool doesValidArrayExist(vector<int>& derived) {\\n        return !accumulate(derived.begin(), derived.end(), 0, bit_xor<int>());\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    bool doesValidArrayExist(vector<int>& derived) {\\n        return accumulate(begin(derived),end(derived),0)%2==0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3526617,
                "title": "python-o-n-explained",
                "content": "1. If the answer is true, `derived` must contain even number of `1`.\\n<img src=\"https://assets.leetcode.com/users/images/04a2d0a8-16c2-429d-ac4a-1962354d57d1_1684141811.9305665.png\" width=\"60%\"  />\\n2. Given a `derived` with even number of `1`, we can form an `original` like following:\\n<img src=\"https://assets.leetcode.com/users/images/b26c1e2e-862c-420c-87ee-903b6bcb34dd_1684142462.5727298.png\" width=\"40%\" />\\nThe even number of `1` assures that a_0 = a_{n-1} ^ d_{n-1}.\\n3. Note that setting a_0 = 1 also works. \\nFor example, given `derived = [0,1,1,0,1,0,1]`, setting a_0 = 0 leads to `original = [0,0,1,0,0,1,1]`, while setting a_0 = 1 leads to `original = [1,1,0,1,1,0,0]`.\\n```\\nclass Solution:\\n    def doesValidArrayExist(self, derived: List[int]) -> bool:\\n        return False if sum(derived)&1 else True",
                "solutionTags": [
                    "Python3"
                ],
                "code": "1. If the answer is true, `derived` must contain even number of `1`.\\n<img src=\"https://assets.leetcode.com/users/images/04a2d0a8-16c2-429d-ac4a-1962354d57d1_1684141811.9305665.png\" width=\"60%\"  />\\n2. Given a `derived` with even number of `1`, we can form an `original` like following:\\n<img src=\"https://assets.leetcode.com/users/images/b26c1e2e-862c-420c-87ee-903b6bcb34dd_1684142462.5727298.png\" width=\"40%\" />\\nThe even number of `1` assures that a_0 = a_{n-1} ^ d_{n-1}.\\n3. Note that setting a_0 = 1 also works. \\nFor example, given `derived = [0,1,1,0,1,0,1]`, setting a_0 = 0 leads to `original = [0,0,1,0,0,1,1]`, while setting a_0 = 1 leads to `original = [1,1,0,1,1,0,0]`.\\n```\\nclass Solution:\\n    def doesValidArrayExist(self, derived: List[int]) -> bool:\\n        return False if sum(derived)&1 else True",
                "codeTag": "Java"
            },
            {
                "id": 3526548,
                "title": "c-solution-bit-manipulation",
                "content": "**C++** : \\n```\\nclass Solution {\\npublic:\\n    bool doesValidArrayExist(vector<int>& derived) {\\n        int n=derived.size();     //size \\n\\t\\t\\n\\t\\t//making two vector one starting from one and other starting from zero\\n        vector<int> startone(n,-1);\\n        vector<int> startzero(n,-1);\\n        \\n\\t\\t//setting first element as per two possibilities\\n        startone[0]=1;\\n        startzero[0]=0;\\n        \\n\\t\\t//for storing rest of the values running loop and checking condition as per XOR gate conditions\\n        for(int i=0;i<n-1;i++){\\n            if(derived[i]==1){\\n                startone[i+1]=(!startone[i]);\\n                startzero[i+1]=(!startzero[i]);\\n            }\\n            else{\\n                startone[i+1]=startone[i];\\n                startzero[i+1]=startzero[i];\\n            }\\n        }\\n        \\n\\t\\t//checking for last derived bit from first and last element of original array\\n        if(derived[n-1]==(startone[0]^startone[n-1]) || derived[n-1]==(startzero[0]^startzero[n-1])){\\n            return true;\\n        }\\n\\t\\t\\n        return false;        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Math",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool doesValidArrayExist(vector<int>& derived) {\\n        int n=derived.size();     //size \\n\\t\\t\\n\\t\\t//making two vector one starting from one and other starting from zero\\n        vector<int> startone(n,-1);\\n        vector<int> startzero(n,-1);\\n        \\n\\t\\t//setting first element as per two possibilities\\n        startone[0]=1;\\n        startzero[0]=0;\\n        \\n\\t\\t//for storing rest of the values running loop and checking condition as per XOR gate conditions\\n        for(int i=0;i<n-1;i++){\\n            if(derived[i]==1){\\n                startone[i+1]=(!startone[i]);\\n                startzero[i+1]=(!startzero[i]);\\n            }\\n            else{\\n                startone[i+1]=startone[i];\\n                startzero[i+1]=startzero[i];\\n            }\\n        }\\n        \\n\\t\\t//checking for last derived bit from first and last element of original array\\n        if(derived[n-1]==(startone[0]^startone[n-1]) || derived[n-1]==(startzero[0]^startzero[n-1])){\\n            return true;\\n        }\\n\\t\\t\\n        return false;        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3526228,
                "title": "c-beginners-friendly-with-explanation",
                "content": "```\\nclass Solution {\\npublic:\\n    bool doesValidArrayExist(vector<int>& derived) {\\n        int n = derived.size();\\n        /**\\n         original = [w,x,y,z] \\n         derived = [w^x,x^y,y^z,z^w] , xoring derived from [0 : n-2] ->\\n                   -> w^x ^ x^y ^ y^z = w^z ,\\n\\t\\t\\t\\t   w^z == z^w\\n                   if derived from [0 : n-2] == [n-1] return true. \\n         * */\\n         int xor_ = 0;\\n        for (int i = 0; i < n-1; ++i) {  // loop [0,n-2]\\n            xor_ ^= derived[i];\\n        }\\n        \\n        return xor_ == derived[n-1];\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool doesValidArrayExist(vector<int>& derived) {\\n        int n = derived.size();\\n        /**\\n         original = [w,x,y,z] \\n         derived = [w^x,x^y,y^z,z^w] , xoring derived from [0 : n-2] ->\\n                   -> w^x ^ x^y ^ y^z = w^z ,\\n\\t\\t\\t\\t   w^z == z^w\\n                   if derived from [0 : n-2] == [n-1] return true. \\n         * */\\n         int xor_ = 0;\\n        for (int i = 0; i < n-1; ++i) {  // loop [0,n-2]\\n            xor_ ^= derived[i];\\n        }\\n        \\n        return xor_ == derived[n-1];\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3526215,
                "title": "simple-c-sol",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool doesValidArrayExist(vector<int>& d) {\\n        int n=d.size(),count=0;\\n        for(int i=0;i<n;i++){\\n            if(d[i]==1)\\n                count++;\\n        }\\n        if(count%2)\\n            return false;\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool doesValidArrayExist(vector<int>& d) {\\n        int n=d.size(),count=0;\\n        for(int i=0;i<n;i++){\\n            if(d[i]==1)\\n                count++;\\n        }\\n        if(count%2)\\n            return false;\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3525951,
                "title": "two-diff-methods-c",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    bool doesValidArrayExist(vector<int>& derived) \\n{\\n        int n=derived.size();\\n        vector<int> temp(n);\\n        vector<bool> vis(n,false);\\n        for (int i=0;i<n-1;i++)\\n        {\\n            if (derived[i]==1 && vis[i]==false)\\n            {\\n                temp[i]=1;\\n                temp[i+1]=0;\\n                vis[i]=true;\\n                vis[i+1]=true;\\n            }\\n            else if (derived[i]==0 && vis[i]==false)\\n            {\\n                temp[i]=1;\\n                temp[i+1]=1;\\n                vis[i]=true;\\n                vis[i+1]=true;\\n            }\\n            else if (derived[i]==1 && vis[i]==true)\\n            {\\n                int curr=temp[i];\\n                temp[i+1]=1-curr;\\n                vis[i+1]=true;\\n            }\\n            else if (derived[i]==0 && vis[i]==true)\\n            {\\n                int curr=temp[i];\\n                temp[i+1]=curr;\\n                vis[i+1]=true;\\n            }\\n        }\\n        if (derived[n-1]==1)\\n            return (temp[0]!=temp[n-1]);\\n        else\\n            return (temp[0]==temp[n-1]);\\n            \\n        \\n    }\\n\\n\\n\\n//another method : the xor of all elements of derived should be zero beacuse we are using each element twice to construct the derived array.\\n\\n    bool doesValidArrayExist(vector<int>& derived) {\\n        int n=derived.size();\\n        int xori=0;\\n        for (int a:derived)\\n          xori^=a;\\n        return xori==0;\\n            \\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    bool doesValidArrayExist(vector<int>& derived) \\n{\\n        int n=derived.size();\\n        vector<int> temp(n);\\n        vector<bool> vis(n,false);\\n        for (int i=0;i<n-1;i++)\\n        {\\n            if (derived[i]==1 && vis[i]==false)\\n            {\\n                temp[i]=1;\\n                temp[i+1]=0;\\n                vis[i]=true;\\n                vis[i+1]=true;\\n            }\\n            else if (derived[i]==0 && vis[i]==false)\\n            {\\n                temp[i]=1;\\n                temp[i+1]=1;\\n                vis[i]=true;\\n                vis[i+1]=true;\\n            }\\n            else if (derived[i]==1 && vis[i]==true)\\n            {\\n                int curr=temp[i];\\n                temp[i+1]=1-curr;\\n                vis[i+1]=true;\\n            }\\n            else if (derived[i]==0 && vis[i]==true)\\n            {\\n                int curr=temp[i];\\n                temp[i+1]=curr;\\n                vis[i+1]=true;\\n            }\\n        }\\n        if (derived[n-1]==1)\\n            return (temp[0]!=temp[n-1]);\\n        else\\n            return (temp[0]==temp[n-1]);\\n            \\n        \\n    }\\n\\n\\n\\n//another method : the xor of all elements of derived should be zero beacuse we are using each element twice to construct the derived array.\\n\\n    bool doesValidArrayExist(vector<int>& derived) {\\n        int n=derived.size();\\n        int xori=0;\\n        for (int a:derived)\\n          xori^=a;\\n        return xori==0;\\n            \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3525849,
                "title": "easy-c-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool doesValidArrayExist(vector<int>& der) {\\n        \\n        if(der.size() == 1){\\n            if(der[0] == 0)\\n                return true;\\n            else\\n                return false;\\n        }\\n        vector<int> ori1, ori2;\\n        \\n        if(der[0] == 0){\\n            ori1.push_back(0);\\n            ori1.push_back(0);\\n            ori2.push_back(1);\\n            ori2.push_back(1);\\n        }\\n        else{\\n            ori1.push_back(1);\\n            ori1.push_back(0);\\n            ori2.push_back(0);\\n            ori2.push_back(1);\\n        }\\n        for(int i = 1; i < der.size() - 1; i++){\\n            if(der[i] == 0){\\n                if(ori1[i] == 0)\\n                    ori1.push_back(0);\\n                else if(ori1[i] == 1)\\n                    ori1.push_back(1);\\n                \\n                if(ori2[i] == 0)\\n                    ori2.push_back(0);\\n                else if(ori2[i] == 1)\\n                    ori2.push_back(1);\\n            }\\n            else{\\n                if(ori1[i] == 0)\\n                    ori1.push_back(1);\\n                else if(ori1[i] == 1)\\n                    ori1.push_back(0);\\n                \\n                if(ori2[i] == 0)\\n                    ori2.push_back(1);\\n                else if(ori2[i] == 1)\\n                    ori2.push_back(0);\\n            }\\n        }\\n        int n = ori1.size();\\n        if((ori1[0] ^ ori1[n - 1]) == der[n - 1])\\n            return true;\\n        \\n        else if((ori2[0] ^ ori2[n - 1]) == der[n - 1])\\n            return true;\\n        \\n        else\\n            return false;\\n        \\n    }\\n    \\n\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool doesValidArrayExist(vector<int>& der) {\\n        \\n        if(der.size() == 1){\\n            if(der[0] == 0)\\n                return true;\\n            else\\n                return false;\\n        }\\n        vector<int> ori1, ori2;\\n        \\n        if(der[0] == 0){\\n            ori1.push_back(0);\\n            ori1.push_back(0);\\n            ori2.push_back(1);\\n            ori2.push_back(1);\\n        }\\n        else{\\n            ori1.push_back(1);\\n            ori1.push_back(0);\\n            ori2.push_back(0);\\n            ori2.push_back(1);\\n        }\\n        for(int i = 1; i < der.size() - 1; i++){\\n            if(der[i] == 0){\\n                if(ori1[i] == 0)\\n                    ori1.push_back(0);\\n                else if(ori1[i] == 1)\\n                    ori1.push_back(1);\\n                \\n                if(ori2[i] == 0)\\n                    ori2.push_back(0);\\n                else if(ori2[i] == 1)\\n                    ori2.push_back(1);\\n            }\\n            else{\\n                if(ori1[i] == 0)\\n                    ori1.push_back(1);\\n                else if(ori1[i] == 1)\\n                    ori1.push_back(0);\\n                \\n                if(ori2[i] == 0)\\n                    ori2.push_back(1);\\n                else if(ori2[i] == 1)\\n                    ori2.push_back(0);\\n            }\\n        }\\n        int n = ori1.size();\\n        if((ori1[0] ^ ori1[n - 1]) == der[n - 1])\\n            return true;\\n        \\n        else if((ori2[0] ^ ori2[n - 1]) == der[n - 1])\\n            return true;\\n        \\n        else\\n            return false;\\n        \\n    }\\n    \\n\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3525632,
                "title": "c-bit-manipulation-with-explanation",
                "content": "let  `original` array as=[a,b,c,d] then by definition\\n`derived`  will be =[a^b,b^c,c^d,d^a] \\nsince every element in the derived array is appering twice xor of all the element will be 0\\nnecessary and sufficient condition for the derived array to be valid is `xor(derived)`=0\\n**xor of derived array is 0 means there will be even no of 1\\'s so sum of array is divisible by 2**\\n\\n```\\nclass Solution {\\npublic:\\n    bool doesValidArrayExist(vector<int>& derived) {\\n        int dxor = 0;\\n        for (int num : derived) {\\n            dxor ^= num;\\n        }\\n        return dxor==0;\\n    }\\n};\\n```\\n\\n```\\nclass Solution {\\npublic:\\n    bool doesValidArrayExist(vector<int>& derived) {\\n        return accumulate(derived.begin(),derived.end(),0)%2==0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Math",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool doesValidArrayExist(vector<int>& derived) {\\n        int dxor = 0;\\n        for (int num : derived) {\\n            dxor ^= num;\\n        }\\n        return dxor==0;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    bool doesValidArrayExist(vector<int>& derived) {\\n        return accumulate(derived.begin(),derived.end(),0)%2==0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3525593,
                "title": "easy-to-understand-memory-optimized-solution",
                "content": "# Intuition\\nTo create derieved from original initially 2 possible ways ( 0 , 1 ).\\nSo starting with 2 variables compute XOR till last , if last is same as start as XOR of last element with first is to be done . \\nIf same then derieved array can be produced else not. \\n\\n\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool doesValidArrayExist(vector<int>& d) {\\n        bool s1 = 0 , s2 = 1 ;\\n        bool e1 = s1 ^ d[0] , e2 = s2 ^ d[0] ;  \\n        for( int i = 1 ; i < d.size() ; i++ ){\\n            e1 ^= d[i] ; \\n            e2 ^= d[i] ; \\n        }\\n        if( s1 == e1 || s2 == e2 )\\n            return 1 ; \\n        return 0 ; \\n            \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool doesValidArrayExist(vector<int>& d) {\\n        bool s1 = 0 , s2 = 1 ;\\n        bool e1 = s1 ^ d[0] , e2 = s2 ^ d[0] ;  \\n        for( int i = 1 ; i < d.size() ; i++ ){\\n            e1 ^= d[i] ; \\n            e2 ^= d[i] ; \\n        }\\n        if( s1 == e1 || s2 == e2 )\\n            return 1 ; \\n        return 0 ; \\n            \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3525469,
                "title": "simple-java-solution-using-xor-with-tc-o-n-and-sc-o-1",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nAs we know the array is a binary array, so I just considered as the first element and then tried to find if it satisfies the given condition. If not then tried checking considering the first element as 1.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThis is a fairly simple approach. Just calculate the XOR of 0 to n-2 th element, and check for the condition.\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean doesValidArrayExist(int[] derived) {\\n        return check(0, derived) || check(1, derived);\\n    }\\n\\n    private boolean check(int start, int[] derived) {\\n        int n = derived.length;\\n        int curr = start;\\n\\n        for (int i = 0; i < n - 1; i++) {\\n            curr ^= derived[i];\\n        }\\n\\n        return (curr ^ start) == derived[n - 1];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean doesValidArrayExist(int[] derived) {\\n        return check(0, derived) || check(1, derived);\\n    }\\n\\n    private boolean check(int start, int[] derived) {\\n        int n = derived.length;\\n        int curr = start;\\n\\n        for (int i = 0; i < n - 1; i++) {\\n            curr ^= derived[i];\\n        }\\n\\n        return (curr ^ start) == derived[n - 1];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3525307,
                "title": "linear-time-constant-space-solution-in-c-with-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nObservations:\\n- For any valid array satisfying the constraints, the bitwise inversion of this array is also valid. Thus we can assume that if a valid array exists, its initial element is 0.\\n- If we know what `original[i]` should be, we can use `derived[i]` to compute what `original[i+1]` should be: (i) `derived[i]` $= 0 \\\\implies$ `original[i]` $=$ `original[i+1]` and (ii) `derived[i]` $= 1 \\\\implies$ `original[i]` $\\\\neq$ `original[i+1]`.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nAssume `original[0]` $=0$. From the second bullet point above, note that the rule for updating the next index precisely matches what XOR does. After looping through the entire derived array using this realization, we expect that the \"next\" element (which is actually `original[0]`) equals 0, else we contradict our initial assumption.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool doesValidArrayExist(vector<int>& derived) {\\n        bool next = 0;\\n        for (const int x : derived) {\\n            next ^= x;\\n        }\\n        return next == 0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool doesValidArrayExist(vector<int>& derived) {\\n        bool next = 0;\\n        for (const int x : derived) {\\n            next ^= x;\\n        }\\n        return next == 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3525081,
                "title": "determining-the-original-array-and-check-consistency-python-with-comments",
                "content": "**Idea: Initialization and Check Consistency**\\nWe can initialize the original[0] = 0 (1 is also good). Then\\nscan the derived to set the other elements in original. \\nIn general, derived[i] = org[i] ^ org[i+1]. If derived[i] == 0,\\nwe shall set org[i+1] = org[i]; If derived[i] == 1, we need to\\nset org[i+1] = 1 - org[i], i.e, org[i] and org[i+1] are different.\\n\\nWhen we at the index n - 1. Based on the val of derived[n-1] = org[n-1] ^ org[0], we need to check org[0] for consistency:\\n\\nif derived[n-1] == 0, it means org[n-1] and org[0] shall be the same. If not,\\nreturn False; if derived[n-1] == 1, it means org[n-1] and org[0] shall be different. If not, we need to return False.\\n\\nAfter the checks, if no return, we return True.\\n\\nRemark: we can set org[0] = 0 or org[0] = 1. Both options work. The difference\\nin the full org array is a flip of 0, 1.\\n\\nFor Eg.1, derived = [1, 1, 0]. If we set org[0] = 1, org = [1, 0, 1];\\nIf we set org[0] = 0, org = [0, 1, 0].\\n\\nFlipping of 0, 1 does not affect the resulted derived from org. This is due to\\noperation rule of XOR: same yield 0, different yield 1.\\n\\n1 ^ 1 = 0 ^ 0 = 0; 1 ^ 0 = 0 ^ 1 = 1.\\n\\n**Extension**: simplify the code.\\n\\n\\n```\\nclass Solution:\\n    def doesValidArrayExist(self, derived: List[int]) -> bool:\\n        \\n        n = len(derived)\\n        org = [-1] * n\\n        \\n        org[0] = 1 # you can start org[0] to be either 0 or 1. Both works.\\n        for i in range(n):\\n            cur = derived[i]\\n            if i < n-1:\\n                if cur == 0:\\n                    org[i+1] = org[i]\\n                else:\\n                    org[i+1] = 1 - org[i]\\n            if i == n-1:\\n                if cur == 0:\\n                    if org[0] != org[i]:\\n                        return False\\n                else:\\n                    if org[0] == org[i]:\\n                        return False\\n        # print(org)\\n        return True\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def doesValidArrayExist(self, derived: List[int]) -> bool:\\n        \\n        n = len(derived)\\n        org = [-1] * n\\n        \\n        org[0] = 1 # you can start org[0] to be either 0 or 1. Both works.\\n        for i in range(n):\\n            cur = derived[i]\\n            if i < n-1:\\n                if cur == 0:\\n                    org[i+1] = org[i]\\n                else:\\n                    org[i+1] = 1 - org[i]\\n            if i == n-1:\\n                if cur == 0:\\n                    if org[0] != org[i]:\\n                        return False\\n                else:\\n                    if org[0] == org[i]:\\n                        return False\\n        # print(org)\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3525070,
                "title": "java-easy-to-understand-solution-with-o-n-time-complexity",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n1. The first number of the original array only have two possible value: 0 or 1\\n2. when i < derived.length, derived[i] = original[i]^original[i+1]. original[i+1] = derived[i]^orginal[i];\\n3. init two array seperately represent first number is 0 or 1\\n4. use traverse to get all next number\\n5. check whether exists derived[n -1] == original[n-1] ^ orginal[0]\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nFor loop\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean doesValidArrayExist(int[] derived) {\\n        \\n        int[] o1 = new int[derived.length];\\n        int[] o2 = new int[derived.length];\\n        o1[0] = 0;\\n        o2[0] = 1;\\n        boolean f1 = false, f2 = false;\\n        for(int i = 0; i < derived.length; i++){\\n            if(i < derived.length - 1){\\n                o1[i+1] = o1[i]^derived[i];\\n                o2[i+1] = o2[i]^derived[i];\\n            }else{\\n                f1 = (derived[i] == (o1[i]^o1[0])) ? true : false;\\n                f2 = (derived[i] == (o2[i]^o2[0])) ? true: false;                \\n            }\\n        }\\n        return f1 || f2;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean doesValidArrayExist(int[] derived) {\\n        \\n        int[] o1 = new int[derived.length];\\n        int[] o2 = new int[derived.length];\\n        o1[0] = 0;\\n        o2[0] = 1;\\n        boolean f1 = false, f2 = false;\\n        for(int i = 0; i < derived.length; i++){\\n            if(i < derived.length - 1){\\n                o1[i+1] = o1[i]^derived[i];\\n                o2[i+1] = o2[i]^derived[i];\\n            }else{\\n                f1 = (derived[i] == (o1[i]^o1[0])) ? true : false;\\n                f2 = (derived[i] == (o2[i]^o2[0])) ? true: false;                \\n            }\\n        }\\n        return f1 || f2;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3525049,
                "title": "swift-one-liner",
                "content": "**One-Liner (accepted answer)**\\n```\\nclass Solution {\\n    func doesValidArrayExist(_ derived: [Int]) -> Bool {\\n        derived.reduce(0,^) == 0\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func doesValidArrayExist(_ derived: [Int]) -> Bool {\\n        derived.reduce(0,^) == 0\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3524559,
                "title": "just-snap-and-it-will-print-in-your-mind",
                "content": "# Intuition\\nso let a[] be an orignal array and the derived array is composed of\\n\\n```\\nderived[] = {a[0]^a[1] ,  a[1]^a[2] , a[2]^a[3] ,\\n.\\n.\\n.\\n.\\n a[n-1]^a[0]}\\n```\\n\\n\\n# Approach\\nSo the bitwise **XOR** operation is are as follows :\\nlet their be an element **X**\\n```\\n1. X^X=0\\n2. X^0=X\\n\\n```\\nSo threfore ,if we **Xor** the  derived array element it will result in **0** if their exist an orignal array ,i.e,\\n\\n```\\n(a[0]^a[1])^(a[1]^a[2])^(a[2]^a[3])^a[3]...............a[n-1]^\\n(a[n-1]^a[0])\\n```\\nSo everything will cancel and result is 0  if their exist an orignal array otherwise orignal array does\\'nt exist\\n# Complexity\\n- Time complexity:\\n**O(N)**,where N is the size of derived array\\n\\n- Space complexity:\\n**O(1)**,as no extra space have been taken \\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool doesValidArrayExist(vector<int>& derived) {\\n        int a=0;\\n       for(auto &c:derived){\\n           a=a^c;\\n       }\\n       return a==0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nderived[] = {a[0]^a[1] ,  a[1]^a[2] , a[2]^a[3] ,\\n.\\n.\\n.\\n.\\n a[n-1]^a[0]}\\n```\n```\\n1. X^X=0\\n2. X^0=X\\n\\n```\n```\\n(a[0]^a[1])^(a[1]^a[2])^(a[2]^a[3])^a[3]...............a[n-1]^\\n(a[n-1]^a[0])\\n```\n```\\nclass Solution {\\npublic:\\n    bool doesValidArrayExist(vector<int>& derived) {\\n        int a=0;\\n       for(auto &c:derived){\\n           a=a^c;\\n       }\\n       return a==0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3524540,
                "title": "beats-100-java-c-python-xor-all-deeply-explained",
                "content": "> \\u26A0\\uFE0F **Disclaimer**: The original solution was crafted in Java. Thus, when we mention \"Beats 100%\" it applies specifically to Java submissions. The performance may vary for other languages.\\n\\n#### Don\\'t forget to upvote if you like the content below. \\uD83D\\uDE43\\n\\n# Intuition\\nGiven an array, we are tasked with checking if there exists an array such that the XOR of every two neighboring elements equals the corresponding element in the given array. In the binary world, XOR essentially implies \\'sum without carry\\'. This fundamental property of XOR operation forms the cornerstone of our approach.\\n\\nLet\\'s first denote our original unknown array as `A[0], A[1], .... A[n-1]` and the derived array (the one we are given) as `A[0]^A[1], A[1]^A[2] .... A[n-1]^A[0]`. What we are essentially looking for is a way to get back to the original array from the derived one.\\n\\nA critical insight here is to observe that the XOR operation has a peculiar property: the sum of an odd number of 1\\'s is 1 and the sum of an even number of $$1$$\\'s is $$0$$. This is due to the XOR operation being equivalent to binary addition without carry. For example, consider four bits: `1 XOR 1 XOR 1 XOR 1 = 0`, and `1 XOR 1 XOR 1 = 1`. This pattern extends to any number of bits.\\n\\nNow, if we XOR all elements of the derived array, we would end up with 0 because every element from the original array would appear twice and thus cancel each other out. This forms the basis of our condition for the existence of a valid original array: `xor(derived) == 0`.\\n\\n# Approach\\nWith the above intuition, our approach becomes quite straightforward. We simply iterate through the given array and XOR all the elements. If the final result is $$0$$, we return `true` to indicate that a valid array exists; otherwise, we return `false`.\\n\\n# Complexity Analysis\\n- Time complexity: The time complexity for this approach is $$O(n)$$ because we\\'re traversing the array once. \\n- Space complexity: The space complexity is $$O(1)$$ because we\\'re only using a single variable to hold the sum.\\n\\n# Code\\n``` java []\\nclass Solution {\\n    public boolean doesValidArrayExist(int[] derived) {\\n        int sum = 0;\\n        for (int n: derived) {\\n            sum ^= n;\\n        }\\n        return sum == 0;\\n    }\\n}\\n```\\n``` cpp []\\nclass Solution {\\npublic:\\n    bool doesValidArrayExist(vector<int>& derived) {\\n        int sum = 0;\\n        for (int n: derived) {\\n            sum ^= n;\\n        }\\n        return sum == 0;\\n    }\\n};\\n```\\n``` python3 []\\nclass Solution:\\n    def doesValidArrayExist(self, derived: List[int]) -> bool:\\n        return reduce(lambda a, b: a ^ b, derived) == 0\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "Bit Manipulation"
                ],
                "code": "``` java []\\nclass Solution {\\n    public boolean doesValidArrayExist(int[] derived) {\\n        int sum = 0;\\n        for (int n: derived) {\\n            sum ^= n;\\n        }\\n        return sum == 0;\\n    }\\n}\\n```\n``` cpp []\\nclass Solution {\\npublic:\\n    bool doesValidArrayExist(vector<int>& derived) {\\n        int sum = 0;\\n        for (int n: derived) {\\n            sum ^= n;\\n        }\\n        return sum == 0;\\n    }\\n};\\n```\n``` python3 []\\nclass Solution:\\n    def doesValidArrayExist(self, derived: List[int]) -> bool:\\n        return reduce(lambda a, b: a ^ b, derived) == 0\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3524505,
                "title": "populating-original-vector-from-derived",
                "content": "# Intuition\\nExcept last digit , any other digit of derived can be obtained from original. The last digit of derived is dependent on first digit of original.\\nSo, let\\'s come up with the original vector. I start with original vector of size n+1 so as to get all n digits of derived.\\nWe can assume the starting value of original as 1 or 0. I chose 1.\\n\\n\\nNow to obtain derived[0]=1, \\n    original[1] needs to be different from original[0],\\n    else original[1]= original[0].\\n\\nRepeat above proces for all the digits of derived.\\n\\nAnd the original[n] needs be same as original[0] because the last bit of derived is supposed to be \\nderived[n-1] = original[n-1] XOR original[0];\\n\\n\\n# Code\\n```\\n bool doesValidArrayExist(vector<int>& derived) {\\n    int n = derived.size();\\n    vector<int> original(n+1,0);\\n    original[0]=1;\\n    for(int i=0;i<n;++i){\\n        if(derived[i]==1)\\n            original[i+1]=~original[i];\\n        else\\n            original[i+1]=original[i];\\n    }\\n    return original[n] == original[0];\\n}\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n bool doesValidArrayExist(vector<int>& derived) {\\n    int n = derived.size();\\n    vector<int> original(n+1,0);\\n    original[0]=1;\\n    for(int i=0;i<n;++i){\\n        if(derived[i]==1)\\n            original[i+1]=~original[i];\\n        else\\n            original[i+1]=original[i];\\n    }\\n    return original[n] == original[0];\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3524371,
                "title": "3-line-solution-greedy-approach-c",
                "content": "```\\nclass Solution {\\npublic:\\n    bool doesValidArrayExist(vector<int>& d) {\\n        int x=0;\\n        for(auto i:d)\\n            x=x^i;\\n        return x==0?1:0;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Greedy",
                    "Bit Manipulation"
                ],
                "code": "class Solution {\\npublic:\\n    bool doesValidArrayExist(vector<int>& d) {\\n        int x=0;\\n        for(auto i:d)\\n            x=x^i;\\n        return x==0?1:0;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 3524348,
                "title": "simulate-all-possible-cases",
                "content": "# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool firstCheck = true;\\n    bool secondCheck = true;\\n    void updateVariation(vector<vector<int>> & variation, int & target, int & index) {\\n        for (int i = 0; i < 2; i++) {\\n            if (i == 0 && !firstCheck || i == 1 && !secondCheck) {\\n                continue;\\n            }\\n            vector<int> & var = variation[i];\\n            if (var[index + 1] != -1 && var[index] ^ var[index + 1] != target) {\\n                i == 0 ? firstCheck = false : secondCheck = false;\\n            }\\n            if (target == 0) {\\n                var[index + 1] = var[index] == 0 ? 0 : 1;\\n            }\\n            else {\\n                var[index + 1] = var[index] == 0 ? 1 : 0;\\n            }\\n        }\\n    }\\n    \\n    bool doesValidArrayExist(vector<int>& derived) {\\n        int n = derived.size();\\n        if (n == 1 ) {\\n            return derived[0] == 0;\\n        }\\n        vector<vector<int>> variation(2, vector<int>(n, -1));\\n        if (derived[n - 1] == 1) {\\n            variation[0][0] = 1;\\n            variation[0][n - 1] = 0;\\n            variation[1][0] = 0;\\n            variation[1][n - 1] = 1;\\n        }\\n        else {\\n            variation[0][0] = 1;\\n            variation[0][n - 1] = 1;\\n            variation[1][0] = 0;\\n            variation[1][n - 1] = 0;\\n        }\\n        \\n        for (int i = 0; i < n - 1; i++) {\\n            updateVariation(variation, derived[i], i);\\n            if (!firstCheck && !secondCheck) {\\n                return false;\\n            }\\n        }\\n    \\n        return true;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool firstCheck = true;\\n    bool secondCheck = true;\\n    void updateVariation(vector<vector<int>> & variation, int & target, int & index) {\\n        for (int i = 0; i < 2; i++) {\\n            if (i == 0 && !firstCheck || i == 1 && !secondCheck) {\\n                continue;\\n            }\\n            vector<int> & var = variation[i];\\n            if (var[index + 1] != -1 && var[index] ^ var[index + 1] != target) {\\n                i == 0 ? firstCheck = false : secondCheck = false;\\n            }\\n            if (target == 0) {\\n                var[index + 1] = var[index] == 0 ? 0 : 1;\\n            }\\n            else {\\n                var[index + 1] = var[index] == 0 ? 1 : 0;\\n            }\\n        }\\n    }\\n    \\n    bool doesValidArrayExist(vector<int>& derived) {\\n        int n = derived.size();\\n        if (n == 1 ) {\\n            return derived[0] == 0;\\n        }\\n        vector<vector<int>> variation(2, vector<int>(n, -1));\\n        if (derived[n - 1] == 1) {\\n            variation[0][0] = 1;\\n            variation[0][n - 1] = 0;\\n            variation[1][0] = 0;\\n            variation[1][n - 1] = 1;\\n        }\\n        else {\\n            variation[0][0] = 1;\\n            variation[0][n - 1] = 1;\\n            variation[1][0] = 0;\\n            variation[1][n - 1] = 0;\\n        }\\n        \\n        for (int i = 0; i < n - 1; i++) {\\n            updateVariation(variation, derived[i], i);\\n            if (!firstCheck && !secondCheck) {\\n                return false;\\n            }\\n        }\\n    \\n        return true;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3524242,
                "title": "c-easy-implementation-o-n",
                "content": "# Complexity\\n- Time complexity:O(n)\\n\\n- Space complexity:O(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool doesValidArrayExist(vector<int>& derived) {\\n        vector <int> first(1,0);\\n        vector <int> second(1,1);\\n        int size=derived.size();\\n        for(int i=0;i<size-1;i++){\\n            if(derived[i]==0){\\n                if(first[i]==0) first.push_back(0);\\n                else first.push_back(1);\\n                if(second[i]==0) second.push_back(0);\\n                else second.push_back(1);                \\n            }\\n            else{\\n                if(first[i]==1)first.push_back(0);\\n                else first.push_back(1);\\n                if(second[i]==1)second.push_back(0);\\n                else second.push_back(1);\\n            }\\n        }\\n        if(first[0]^first[size-1]==derived[size-1]) return true;\\n        if(second[0]^second[size-1]==derived[size-1])return true;\\n        return false;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool doesValidArrayExist(vector<int>& derived) {\\n        vector <int> first(1,0);\\n        vector <int> second(1,1);\\n        int size=derived.size();\\n        for(int i=0;i<size-1;i++){\\n            if(derived[i]==0){\\n                if(first[i]==0) first.push_back(0);\\n                else first.push_back(1);\\n                if(second[i]==0) second.push_back(0);\\n                else second.push_back(1);                \\n            }\\n            else{\\n                if(first[i]==1)first.push_back(0);\\n                else first.push_back(1);\\n                if(second[i]==1)second.push_back(0);\\n                else second.push_back(1);\\n            }\\n        }\\n        if(first[0]^first[size-1]==derived[size-1]) return true;\\n        if(second[0]^second[size-1]==derived[size-1])return true;\\n        return false;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3523977,
                "title": "full-explanation-solution-in-c",
                "content": "```\\nclass Solution {\\npublic:\\n    bool doesValidArrayExist(vector<int>& derived) {\\n        int xor_val = 0;\\n        int count_ones = 0;\\n        for (int i = 0; i < derived.size(); i++) {\\n            xor_val ^= derived[i];\\n            if (derived[i] == 1) {\\n                count_ones++;\\n            }\\n        }\\n        if (xor_val != 0) {\\n            return false;\\n        }\\n        if (count_ones % 2 == 0) {\\n            return true;\\n        } else {\\n            return false;\\n        }\\n    }\\n};\\n```\\n\\n**Explanation -:**\\n```\\nint xor_val = 0;\\nint count_ones = 0;\\n```\\nThese two lines define two integer variables xor_val and count_ones and initialize them to 0. xor_val will be used to compute the XOR of all the elements in the derived vector, while count_ones will be used to count the number of elements in derived that have the value of 1.\\n\\n```\\nfor (int i = 0; i < derived.size(); i++) {\\n    xor_val ^= derived[i];\\n    if (derived[i] == 1) {\\n        count_ones++;\\n    }\\n}\\n```\\nThis loop iterates over each element derived[i] in the derived vector, computes the XOR of all the elements using the ^= operator, and counts the number of elements with the value of 1 using the if statement.\\n\\n```\\nif (xor_val != 0) {\\n    return false;\\n}\\n```\\nThis if statement checks if the XOR of all the elements in derived is not equal to 0. If it is not, then it means that a valid array cannot be created from derived, so the function returns false.\\n\\n```\\nif (count_ones % 2 == 0) {\\n    return true;\\n} else {\\n    return false;\\n}\\n```\\nThis if statement checks if the number of elements in derived that have the value of 1 is even. If it is even, then it means that a valid array can be created from derived, so the function returns true. Otherwise, it returns false.\\n\\nIn summary, this function checks if it is possible to create a valid array from the given vector by computing the XOR of all the elements and checking if it is equal to 0, and by counting the number of elements with the value of 1 and checking if it is even.\\n\\n",
                "solutionTags": [
                    "C",
                    "Array",
                    "Math",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool doesValidArrayExist(vector<int>& derived) {\\n        int xor_val = 0;\\n        int count_ones = 0;\\n        for (int i = 0; i < derived.size(); i++) {\\n            xor_val ^= derived[i];\\n            if (derived[i] == 1) {\\n                count_ones++;\\n            }\\n        }\\n        if (xor_val != 0) {\\n            return false;\\n        }\\n        if (count_ones % 2 == 0) {\\n            return true;\\n        } else {\\n            return false;\\n        }\\n    }\\n};\\n```\n```\\nint xor_val = 0;\\nint count_ones = 0;\\n```\n```\\nfor (int i = 0; i < derived.size(); i++) {\\n    xor_val ^= derived[i];\\n    if (derived[i] == 1) {\\n        count_ones++;\\n    }\\n}\\n```\n```\\nif (xor_val != 0) {\\n    return false;\\n}\\n```\n```\\nif (count_ones % 2 == 0) {\\n    return true;\\n} else {\\n    return false;\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3523933,
                "title": "1-line-even-sum-return-true",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    bool doesValidArrayExist(vector<int>& derived) {\\n       return accumulate(derived.begin(),derived.end(),0) % 2 == 0;\\n    }\\n}; \\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool doesValidArrayExist(vector<int>& derived) {\\n       return accumulate(derived.begin(),derived.end(),0) % 2 == 0;\\n    }\\n}; \\n\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1895888,
                "content": [
                    {
                        "username": "dmitryartux",
                        "content": "**Cool XOR understanding question**"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "It takes alot of time to deduce any solution where we try to develop the original array.\\nHowever the actual answer is completely out of the box."
                    },
                    {
                        "username": "Princesah999",
                        "content": "original array KMC :("
                    },
                    {
                        "username": "Lee_fan_Ak_The_Boss",
                        "content": "i take my whole time to find the original array and\\uD83D\\uDE2B\\uD83D\\uDE2B\\uD83D\\uDE2B\\uD83D\\uDE2B "
                    }
                ]
            },
            {
                "id": 1893625,
                "content": [
                    {
                        "username": "dmitryartux",
                        "content": "**Cool XOR understanding question**"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "It takes alot of time to deduce any solution where we try to develop the original array.\\nHowever the actual answer is completely out of the box."
                    },
                    {
                        "username": "Princesah999",
                        "content": "original array KMC :("
                    },
                    {
                        "username": "Lee_fan_Ak_The_Boss",
                        "content": "i take my whole time to find the original array and\\uD83D\\uDE2B\\uD83D\\uDE2B\\uD83D\\uDE2B\\uD83D\\uDE2B "
                    }
                ]
            },
            {
                "id": 1893430,
                "content": [
                    {
                        "username": "dmitryartux",
                        "content": "**Cool XOR understanding question**"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "It takes alot of time to deduce any solution where we try to develop the original array.\\nHowever the actual answer is completely out of the box."
                    },
                    {
                        "username": "Princesah999",
                        "content": "original array KMC :("
                    },
                    {
                        "username": "Lee_fan_Ak_The_Boss",
                        "content": "i take my whole time to find the original array and\\uD83D\\uDE2B\\uD83D\\uDE2B\\uD83D\\uDE2B\\uD83D\\uDE2B "
                    }
                ]
            },
            {
                "id": 1893191,
                "content": [
                    {
                        "username": "dmitryartux",
                        "content": "**Cool XOR understanding question**"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "It takes alot of time to deduce any solution where we try to develop the original array.\\nHowever the actual answer is completely out of the box."
                    },
                    {
                        "username": "Princesah999",
                        "content": "original array KMC :("
                    },
                    {
                        "username": "Lee_fan_Ak_The_Boss",
                        "content": "i take my whole time to find the original array and\\uD83D\\uDE2B\\uD83D\\uDE2B\\uD83D\\uDE2B\\uD83D\\uDE2B "
                    }
                ]
            }
        ]
    },
    {
        "title": "Differences Between Two Objects",
        "question_content": null,
        "solutions": [],
        "discussions": [
            {
                "id": 1903185,
                "content": [
                    {
                        "username": "aanand07",
                        "content": "I\\'m having a hard time understanding example 4, problem description states that  `Keys that exist in one object but not in the other should not be included in the returned object.` According to this, output should be `{}`. "
                    },
                    {
                        "username": "arthur326",
                        "content": "I also found this to be a weird case. It seems the key description is that arrays should be viewed as objects with their indices as keys \"when comparing two arrays\" (and only then, I guess)."
                    },
                    {
                        "username": "AloofSage",
                        "content": "Presumably if it was ```obj2 = {\\n  \"a\": {\"c\": 1},\\n}``` ,then we would ignore the changed keys, but since the value changed from object to array we log the difference. They should probably specify though since you could argue that the second object is equivalent to ```{\"a\":{\"0\":1}}```"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "It\\'s confusing to me that objects and arrays that are not \\'deeply equal\\' as per  \\'2628. JSON Deep Equal\\'. Are still considered equal here, like in:\\n`{\"a\":{\"b\": [1,2,3,4]}, \"c\": 2}`\\n`{\"a\":{\"b\": [1,2,3]}, \"c\": 1}`\\n\\nin my opinion those arrays are not equal. and we should return something with  {\"a\":{\"b\":[[1,2,3,4], [1,2,3]]}}, but instead we should just ignore it because the 4 is considered as an extra/removed key? I think that is a weird way to define equality. Maybe you could be more explicit about this in the description/examples. \\n"
                    },
                    {
                        "username": "juleshwar",
                        "content": "## Testcases to test your code\\n\\n```\\n{\"a\":[]}\\n{\"a\":[]}\\n{}\\n{\"a\": 1, \"b\": 2}\\n{\"a\": 1, \"v\": 3, \"x\": [], \"z\": {\"a\": null}}\\n{\"a\": 2, \"v\": 4, \"x\": [], \"z\": {\"a\": 2}}\\n{\"a\": 5, \"v\": 6, \"z\": [1,2,4, [2,5,7]]}\\n{\"a\": 5, \"v\": 7, \"z\": [1,2,3, [1]]}\\n{\"a\":{\"b\":1}}\\n{\"a\":{\"0\":1}}\\n{\"a\": [1, 2, {}],\"b\": false}\\n{\"b\": false, \"a\": [1, 2, {}]}\\n{}\\n{}\\n{\"a\":[1,{\"b\":[{\"4\":5}]}]}\\n{\"a\":[1,{\"b\":[{\"4\":5}]}]}\\n{\"a\":[1,{\"b\":[{\"4\":5}]}]}\\n{\"a\":[2,{\"b\":[{\"4\":6}]}]}\\n{\"a\":[2,{\"b\":[{\"4\":6}]}]}\\n{\"a\":[2,{\"b\":2}]}\\n{\"a\":[2,{\"b\":[{\"4\":6}]}]}\\n{\"a\":3}\\n{\"a\": \"c\", \"c\": [1,true], \"m\": 11}\\n{\"a\": \"f\", \"c\":[1,false], \"b\": 11}\\n```"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "this one was tough for me: \\n{\"a\":{\"b\": [1,2,3,4]}, \"c\": 2}\\n{\"a\":{\"b\": [1,2,3]}, \"c\": 1}"
                    },
                    {
                        "username": "luismendes070",
                        "content": "Case 1 and case 5 Answers OK. ChatGPT TypeScript function objDiff(obj1: any, obj2: any): any {\\n  try {\\n    const result: any = {};\\n\\n    const compare = (val1: any, val2: any, path: string): void => {\\n      if (val1 === null && val2 === null) {\\n        return;\\n      }\\n\\n      if (typeof val1 !== typeof val2 || Array.isArray(val1) !== Array.isArray(val2)) {\\n        result[path] = [val1, val2];\\n      } else if (typeof val1 === \\'object\\') {\\n        if (Array.isArray(val1)) {\\n          const length = Math.max(val1.length, val2.length);\\n          for (let i = 0; i < length; i++) {\\n            if (i < val1.length && i < val2.length) {\\n              compare(val1[i], val2[i], `${path}[${i}]`);\\n            } else if (i < val1.length) {\\n              result[`${path}[${i}]`] = [val1[i], undefined];\\n            } else {\\n              result[`${path}[${i}]`] = [undefined, val2[i]];\\n            }\\n          }\\n        } else {\\n          const keys = new Set([...Object.keys(val1), ...Object.keys(val2)]);\\n          for (const key of keys) {\\n            if (key in val1 && key in val2) {\\n              compare(val1[key], val2[key], `${path}.${key}`);\\n            } else if (key in val1) {\\n              result[`${path}.${key}`] = [val1[key], undefined];\\n            } else {\\n              result[`${path}.${key}`] = [undefined, val2[key]];\\n            }\\n          }\\n        }\\n\\n        // Omit keys with no differences in the leaves\\n        if (Object.keys(result[path]).length === 0) {\\n          delete result[path];\\n        }\\n      } else if (val1 !== val2) {\\n        result[path] = [val1, val2];\\n      }\\n    };\\n\\n    compare(obj1, obj2, \\'\\');\\n\\n    // Omit the top-level object if it has no differences\\n    if (Object.keys(result).length === 0) {\\n      return {};\\n    }\\n\\n    return result;\\n  } catch (error) {\\n    // Handle any errors that occur during the comparison\\n    console.error(\\'An error occurred during object comparison:\\', error);\\n    return {};\\n  }\\n}\\n\\n\\n"
                    },
                    {
                        "username": "Code_Sagar",
                        "content": "Day20 : Done Solving Today\\'s Question"
                    }
                ]
            },
            {
                "id": 1908990,
                "content": [
                    {
                        "username": "aanand07",
                        "content": "I\\'m having a hard time understanding example 4, problem description states that  `Keys that exist in one object but not in the other should not be included in the returned object.` According to this, output should be `{}`. "
                    },
                    {
                        "username": "arthur326",
                        "content": "I also found this to be a weird case. It seems the key description is that arrays should be viewed as objects with their indices as keys \"when comparing two arrays\" (and only then, I guess)."
                    },
                    {
                        "username": "AloofSage",
                        "content": "Presumably if it was ```obj2 = {\\n  \"a\": {\"c\": 1},\\n}``` ,then we would ignore the changed keys, but since the value changed from object to array we log the difference. They should probably specify though since you could argue that the second object is equivalent to ```{\"a\":{\"0\":1}}```"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "It\\'s confusing to me that objects and arrays that are not \\'deeply equal\\' as per  \\'2628. JSON Deep Equal\\'. Are still considered equal here, like in:\\n`{\"a\":{\"b\": [1,2,3,4]}, \"c\": 2}`\\n`{\"a\":{\"b\": [1,2,3]}, \"c\": 1}`\\n\\nin my opinion those arrays are not equal. and we should return something with  {\"a\":{\"b\":[[1,2,3,4], [1,2,3]]}}, but instead we should just ignore it because the 4 is considered as an extra/removed key? I think that is a weird way to define equality. Maybe you could be more explicit about this in the description/examples. \\n"
                    },
                    {
                        "username": "juleshwar",
                        "content": "## Testcases to test your code\\n\\n```\\n{\"a\":[]}\\n{\"a\":[]}\\n{}\\n{\"a\": 1, \"b\": 2}\\n{\"a\": 1, \"v\": 3, \"x\": [], \"z\": {\"a\": null}}\\n{\"a\": 2, \"v\": 4, \"x\": [], \"z\": {\"a\": 2}}\\n{\"a\": 5, \"v\": 6, \"z\": [1,2,4, [2,5,7]]}\\n{\"a\": 5, \"v\": 7, \"z\": [1,2,3, [1]]}\\n{\"a\":{\"b\":1}}\\n{\"a\":{\"0\":1}}\\n{\"a\": [1, 2, {}],\"b\": false}\\n{\"b\": false, \"a\": [1, 2, {}]}\\n{}\\n{}\\n{\"a\":[1,{\"b\":[{\"4\":5}]}]}\\n{\"a\":[1,{\"b\":[{\"4\":5}]}]}\\n{\"a\":[1,{\"b\":[{\"4\":5}]}]}\\n{\"a\":[2,{\"b\":[{\"4\":6}]}]}\\n{\"a\":[2,{\"b\":[{\"4\":6}]}]}\\n{\"a\":[2,{\"b\":2}]}\\n{\"a\":[2,{\"b\":[{\"4\":6}]}]}\\n{\"a\":3}\\n{\"a\": \"c\", \"c\": [1,true], \"m\": 11}\\n{\"a\": \"f\", \"c\":[1,false], \"b\": 11}\\n```"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "this one was tough for me: \\n{\"a\":{\"b\": [1,2,3,4]}, \"c\": 2}\\n{\"a\":{\"b\": [1,2,3]}, \"c\": 1}"
                    },
                    {
                        "username": "luismendes070",
                        "content": "Case 1 and case 5 Answers OK. ChatGPT TypeScript function objDiff(obj1: any, obj2: any): any {\\n  try {\\n    const result: any = {};\\n\\n    const compare = (val1: any, val2: any, path: string): void => {\\n      if (val1 === null && val2 === null) {\\n        return;\\n      }\\n\\n      if (typeof val1 !== typeof val2 || Array.isArray(val1) !== Array.isArray(val2)) {\\n        result[path] = [val1, val2];\\n      } else if (typeof val1 === \\'object\\') {\\n        if (Array.isArray(val1)) {\\n          const length = Math.max(val1.length, val2.length);\\n          for (let i = 0; i < length; i++) {\\n            if (i < val1.length && i < val2.length) {\\n              compare(val1[i], val2[i], `${path}[${i}]`);\\n            } else if (i < val1.length) {\\n              result[`${path}[${i}]`] = [val1[i], undefined];\\n            } else {\\n              result[`${path}[${i}]`] = [undefined, val2[i]];\\n            }\\n          }\\n        } else {\\n          const keys = new Set([...Object.keys(val1), ...Object.keys(val2)]);\\n          for (const key of keys) {\\n            if (key in val1 && key in val2) {\\n              compare(val1[key], val2[key], `${path}.${key}`);\\n            } else if (key in val1) {\\n              result[`${path}.${key}`] = [val1[key], undefined];\\n            } else {\\n              result[`${path}.${key}`] = [undefined, val2[key]];\\n            }\\n          }\\n        }\\n\\n        // Omit keys with no differences in the leaves\\n        if (Object.keys(result[path]).length === 0) {\\n          delete result[path];\\n        }\\n      } else if (val1 !== val2) {\\n        result[path] = [val1, val2];\\n      }\\n    };\\n\\n    compare(obj1, obj2, \\'\\');\\n\\n    // Omit the top-level object if it has no differences\\n    if (Object.keys(result).length === 0) {\\n      return {};\\n    }\\n\\n    return result;\\n  } catch (error) {\\n    // Handle any errors that occur during the comparison\\n    console.error(\\'An error occurred during object comparison:\\', error);\\n    return {};\\n  }\\n}\\n\\n\\n"
                    },
                    {
                        "username": "Code_Sagar",
                        "content": "Day20 : Done Solving Today\\'s Question"
                    }
                ]
            },
            {
                "id": 1904078,
                "content": [
                    {
                        "username": "aanand07",
                        "content": "I\\'m having a hard time understanding example 4, problem description states that  `Keys that exist in one object but not in the other should not be included in the returned object.` According to this, output should be `{}`. "
                    },
                    {
                        "username": "arthur326",
                        "content": "I also found this to be a weird case. It seems the key description is that arrays should be viewed as objects with their indices as keys \"when comparing two arrays\" (and only then, I guess)."
                    },
                    {
                        "username": "AloofSage",
                        "content": "Presumably if it was ```obj2 = {\\n  \"a\": {\"c\": 1},\\n}``` ,then we would ignore the changed keys, but since the value changed from object to array we log the difference. They should probably specify though since you could argue that the second object is equivalent to ```{\"a\":{\"0\":1}}```"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "It\\'s confusing to me that objects and arrays that are not \\'deeply equal\\' as per  \\'2628. JSON Deep Equal\\'. Are still considered equal here, like in:\\n`{\"a\":{\"b\": [1,2,3,4]}, \"c\": 2}`\\n`{\"a\":{\"b\": [1,2,3]}, \"c\": 1}`\\n\\nin my opinion those arrays are not equal. and we should return something with  {\"a\":{\"b\":[[1,2,3,4], [1,2,3]]}}, but instead we should just ignore it because the 4 is considered as an extra/removed key? I think that is a weird way to define equality. Maybe you could be more explicit about this in the description/examples. \\n"
                    },
                    {
                        "username": "juleshwar",
                        "content": "## Testcases to test your code\\n\\n```\\n{\"a\":[]}\\n{\"a\":[]}\\n{}\\n{\"a\": 1, \"b\": 2}\\n{\"a\": 1, \"v\": 3, \"x\": [], \"z\": {\"a\": null}}\\n{\"a\": 2, \"v\": 4, \"x\": [], \"z\": {\"a\": 2}}\\n{\"a\": 5, \"v\": 6, \"z\": [1,2,4, [2,5,7]]}\\n{\"a\": 5, \"v\": 7, \"z\": [1,2,3, [1]]}\\n{\"a\":{\"b\":1}}\\n{\"a\":{\"0\":1}}\\n{\"a\": [1, 2, {}],\"b\": false}\\n{\"b\": false, \"a\": [1, 2, {}]}\\n{}\\n{}\\n{\"a\":[1,{\"b\":[{\"4\":5}]}]}\\n{\"a\":[1,{\"b\":[{\"4\":5}]}]}\\n{\"a\":[1,{\"b\":[{\"4\":5}]}]}\\n{\"a\":[2,{\"b\":[{\"4\":6}]}]}\\n{\"a\":[2,{\"b\":[{\"4\":6}]}]}\\n{\"a\":[2,{\"b\":2}]}\\n{\"a\":[2,{\"b\":[{\"4\":6}]}]}\\n{\"a\":3}\\n{\"a\": \"c\", \"c\": [1,true], \"m\": 11}\\n{\"a\": \"f\", \"c\":[1,false], \"b\": 11}\\n```"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "this one was tough for me: \\n{\"a\":{\"b\": [1,2,3,4]}, \"c\": 2}\\n{\"a\":{\"b\": [1,2,3]}, \"c\": 1}"
                    },
                    {
                        "username": "luismendes070",
                        "content": "Case 1 and case 5 Answers OK. ChatGPT TypeScript function objDiff(obj1: any, obj2: any): any {\\n  try {\\n    const result: any = {};\\n\\n    const compare = (val1: any, val2: any, path: string): void => {\\n      if (val1 === null && val2 === null) {\\n        return;\\n      }\\n\\n      if (typeof val1 !== typeof val2 || Array.isArray(val1) !== Array.isArray(val2)) {\\n        result[path] = [val1, val2];\\n      } else if (typeof val1 === \\'object\\') {\\n        if (Array.isArray(val1)) {\\n          const length = Math.max(val1.length, val2.length);\\n          for (let i = 0; i < length; i++) {\\n            if (i < val1.length && i < val2.length) {\\n              compare(val1[i], val2[i], `${path}[${i}]`);\\n            } else if (i < val1.length) {\\n              result[`${path}[${i}]`] = [val1[i], undefined];\\n            } else {\\n              result[`${path}[${i}]`] = [undefined, val2[i]];\\n            }\\n          }\\n        } else {\\n          const keys = new Set([...Object.keys(val1), ...Object.keys(val2)]);\\n          for (const key of keys) {\\n            if (key in val1 && key in val2) {\\n              compare(val1[key], val2[key], `${path}.${key}`);\\n            } else if (key in val1) {\\n              result[`${path}.${key}`] = [val1[key], undefined];\\n            } else {\\n              result[`${path}.${key}`] = [undefined, val2[key]];\\n            }\\n          }\\n        }\\n\\n        // Omit keys with no differences in the leaves\\n        if (Object.keys(result[path]).length === 0) {\\n          delete result[path];\\n        }\\n      } else if (val1 !== val2) {\\n        result[path] = [val1, val2];\\n      }\\n    };\\n\\n    compare(obj1, obj2, \\'\\');\\n\\n    // Omit the top-level object if it has no differences\\n    if (Object.keys(result).length === 0) {\\n      return {};\\n    }\\n\\n    return result;\\n  } catch (error) {\\n    // Handle any errors that occur during the comparison\\n    console.error(\\'An error occurred during object comparison:\\', error);\\n    return {};\\n  }\\n}\\n\\n\\n"
                    },
                    {
                        "username": "Code_Sagar",
                        "content": "Day20 : Done Solving Today\\'s Question"
                    }
                ]
            },
            {
                "id": 1904498,
                "content": [
                    {
                        "username": "aanand07",
                        "content": "I\\'m having a hard time understanding example 4, problem description states that  `Keys that exist in one object but not in the other should not be included in the returned object.` According to this, output should be `{}`. "
                    },
                    {
                        "username": "arthur326",
                        "content": "I also found this to be a weird case. It seems the key description is that arrays should be viewed as objects with their indices as keys \"when comparing two arrays\" (and only then, I guess)."
                    },
                    {
                        "username": "AloofSage",
                        "content": "Presumably if it was ```obj2 = {\\n  \"a\": {\"c\": 1},\\n}``` ,then we would ignore the changed keys, but since the value changed from object to array we log the difference. They should probably specify though since you could argue that the second object is equivalent to ```{\"a\":{\"0\":1}}```"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "It\\'s confusing to me that objects and arrays that are not \\'deeply equal\\' as per  \\'2628. JSON Deep Equal\\'. Are still considered equal here, like in:\\n`{\"a\":{\"b\": [1,2,3,4]}, \"c\": 2}`\\n`{\"a\":{\"b\": [1,2,3]}, \"c\": 1}`\\n\\nin my opinion those arrays are not equal. and we should return something with  {\"a\":{\"b\":[[1,2,3,4], [1,2,3]]}}, but instead we should just ignore it because the 4 is considered as an extra/removed key? I think that is a weird way to define equality. Maybe you could be more explicit about this in the description/examples. \\n"
                    },
                    {
                        "username": "juleshwar",
                        "content": "## Testcases to test your code\\n\\n```\\n{\"a\":[]}\\n{\"a\":[]}\\n{}\\n{\"a\": 1, \"b\": 2}\\n{\"a\": 1, \"v\": 3, \"x\": [], \"z\": {\"a\": null}}\\n{\"a\": 2, \"v\": 4, \"x\": [], \"z\": {\"a\": 2}}\\n{\"a\": 5, \"v\": 6, \"z\": [1,2,4, [2,5,7]]}\\n{\"a\": 5, \"v\": 7, \"z\": [1,2,3, [1]]}\\n{\"a\":{\"b\":1}}\\n{\"a\":{\"0\":1}}\\n{\"a\": [1, 2, {}],\"b\": false}\\n{\"b\": false, \"a\": [1, 2, {}]}\\n{}\\n{}\\n{\"a\":[1,{\"b\":[{\"4\":5}]}]}\\n{\"a\":[1,{\"b\":[{\"4\":5}]}]}\\n{\"a\":[1,{\"b\":[{\"4\":5}]}]}\\n{\"a\":[2,{\"b\":[{\"4\":6}]}]}\\n{\"a\":[2,{\"b\":[{\"4\":6}]}]}\\n{\"a\":[2,{\"b\":2}]}\\n{\"a\":[2,{\"b\":[{\"4\":6}]}]}\\n{\"a\":3}\\n{\"a\": \"c\", \"c\": [1,true], \"m\": 11}\\n{\"a\": \"f\", \"c\":[1,false], \"b\": 11}\\n```"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "this one was tough for me: \\n{\"a\":{\"b\": [1,2,3,4]}, \"c\": 2}\\n{\"a\":{\"b\": [1,2,3]}, \"c\": 1}"
                    },
                    {
                        "username": "luismendes070",
                        "content": "Case 1 and case 5 Answers OK. ChatGPT TypeScript function objDiff(obj1: any, obj2: any): any {\\n  try {\\n    const result: any = {};\\n\\n    const compare = (val1: any, val2: any, path: string): void => {\\n      if (val1 === null && val2 === null) {\\n        return;\\n      }\\n\\n      if (typeof val1 !== typeof val2 || Array.isArray(val1) !== Array.isArray(val2)) {\\n        result[path] = [val1, val2];\\n      } else if (typeof val1 === \\'object\\') {\\n        if (Array.isArray(val1)) {\\n          const length = Math.max(val1.length, val2.length);\\n          for (let i = 0; i < length; i++) {\\n            if (i < val1.length && i < val2.length) {\\n              compare(val1[i], val2[i], `${path}[${i}]`);\\n            } else if (i < val1.length) {\\n              result[`${path}[${i}]`] = [val1[i], undefined];\\n            } else {\\n              result[`${path}[${i}]`] = [undefined, val2[i]];\\n            }\\n          }\\n        } else {\\n          const keys = new Set([...Object.keys(val1), ...Object.keys(val2)]);\\n          for (const key of keys) {\\n            if (key in val1 && key in val2) {\\n              compare(val1[key], val2[key], `${path}.${key}`);\\n            } else if (key in val1) {\\n              result[`${path}.${key}`] = [val1[key], undefined];\\n            } else {\\n              result[`${path}.${key}`] = [undefined, val2[key]];\\n            }\\n          }\\n        }\\n\\n        // Omit keys with no differences in the leaves\\n        if (Object.keys(result[path]).length === 0) {\\n          delete result[path];\\n        }\\n      } else if (val1 !== val2) {\\n        result[path] = [val1, val2];\\n      }\\n    };\\n\\n    compare(obj1, obj2, \\'\\');\\n\\n    // Omit the top-level object if it has no differences\\n    if (Object.keys(result).length === 0) {\\n      return {};\\n    }\\n\\n    return result;\\n  } catch (error) {\\n    // Handle any errors that occur during the comparison\\n    console.error(\\'An error occurred during object comparison:\\', error);\\n    return {};\\n  }\\n}\\n\\n\\n"
                    },
                    {
                        "username": "Code_Sagar",
                        "content": "Day20 : Done Solving Today\\'s Question"
                    }
                ]
            },
            {
                "id": 1903816,
                "content": [
                    {
                        "username": "aanand07",
                        "content": "I\\'m having a hard time understanding example 4, problem description states that  `Keys that exist in one object but not in the other should not be included in the returned object.` According to this, output should be `{}`. "
                    },
                    {
                        "username": "arthur326",
                        "content": "I also found this to be a weird case. It seems the key description is that arrays should be viewed as objects with their indices as keys \"when comparing two arrays\" (and only then, I guess)."
                    },
                    {
                        "username": "AloofSage",
                        "content": "Presumably if it was ```obj2 = {\\n  \"a\": {\"c\": 1},\\n}``` ,then we would ignore the changed keys, but since the value changed from object to array we log the difference. They should probably specify though since you could argue that the second object is equivalent to ```{\"a\":{\"0\":1}}```"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "It\\'s confusing to me that objects and arrays that are not \\'deeply equal\\' as per  \\'2628. JSON Deep Equal\\'. Are still considered equal here, like in:\\n`{\"a\":{\"b\": [1,2,3,4]}, \"c\": 2}`\\n`{\"a\":{\"b\": [1,2,3]}, \"c\": 1}`\\n\\nin my opinion those arrays are not equal. and we should return something with  {\"a\":{\"b\":[[1,2,3,4], [1,2,3]]}}, but instead we should just ignore it because the 4 is considered as an extra/removed key? I think that is a weird way to define equality. Maybe you could be more explicit about this in the description/examples. \\n"
                    },
                    {
                        "username": "juleshwar",
                        "content": "## Testcases to test your code\\n\\n```\\n{\"a\":[]}\\n{\"a\":[]}\\n{}\\n{\"a\": 1, \"b\": 2}\\n{\"a\": 1, \"v\": 3, \"x\": [], \"z\": {\"a\": null}}\\n{\"a\": 2, \"v\": 4, \"x\": [], \"z\": {\"a\": 2}}\\n{\"a\": 5, \"v\": 6, \"z\": [1,2,4, [2,5,7]]}\\n{\"a\": 5, \"v\": 7, \"z\": [1,2,3, [1]]}\\n{\"a\":{\"b\":1}}\\n{\"a\":{\"0\":1}}\\n{\"a\": [1, 2, {}],\"b\": false}\\n{\"b\": false, \"a\": [1, 2, {}]}\\n{}\\n{}\\n{\"a\":[1,{\"b\":[{\"4\":5}]}]}\\n{\"a\":[1,{\"b\":[{\"4\":5}]}]}\\n{\"a\":[1,{\"b\":[{\"4\":5}]}]}\\n{\"a\":[2,{\"b\":[{\"4\":6}]}]}\\n{\"a\":[2,{\"b\":[{\"4\":6}]}]}\\n{\"a\":[2,{\"b\":2}]}\\n{\"a\":[2,{\"b\":[{\"4\":6}]}]}\\n{\"a\":3}\\n{\"a\": \"c\", \"c\": [1,true], \"m\": 11}\\n{\"a\": \"f\", \"c\":[1,false], \"b\": 11}\\n```"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "this one was tough for me: \\n{\"a\":{\"b\": [1,2,3,4]}, \"c\": 2}\\n{\"a\":{\"b\": [1,2,3]}, \"c\": 1}"
                    },
                    {
                        "username": "luismendes070",
                        "content": "Case 1 and case 5 Answers OK. ChatGPT TypeScript function objDiff(obj1: any, obj2: any): any {\\n  try {\\n    const result: any = {};\\n\\n    const compare = (val1: any, val2: any, path: string): void => {\\n      if (val1 === null && val2 === null) {\\n        return;\\n      }\\n\\n      if (typeof val1 !== typeof val2 || Array.isArray(val1) !== Array.isArray(val2)) {\\n        result[path] = [val1, val2];\\n      } else if (typeof val1 === \\'object\\') {\\n        if (Array.isArray(val1)) {\\n          const length = Math.max(val1.length, val2.length);\\n          for (let i = 0; i < length; i++) {\\n            if (i < val1.length && i < val2.length) {\\n              compare(val1[i], val2[i], `${path}[${i}]`);\\n            } else if (i < val1.length) {\\n              result[`${path}[${i}]`] = [val1[i], undefined];\\n            } else {\\n              result[`${path}[${i}]`] = [undefined, val2[i]];\\n            }\\n          }\\n        } else {\\n          const keys = new Set([...Object.keys(val1), ...Object.keys(val2)]);\\n          for (const key of keys) {\\n            if (key in val1 && key in val2) {\\n              compare(val1[key], val2[key], `${path}.${key}`);\\n            } else if (key in val1) {\\n              result[`${path}.${key}`] = [val1[key], undefined];\\n            } else {\\n              result[`${path}.${key}`] = [undefined, val2[key]];\\n            }\\n          }\\n        }\\n\\n        // Omit keys with no differences in the leaves\\n        if (Object.keys(result[path]).length === 0) {\\n          delete result[path];\\n        }\\n      } else if (val1 !== val2) {\\n        result[path] = [val1, val2];\\n      }\\n    };\\n\\n    compare(obj1, obj2, \\'\\');\\n\\n    // Omit the top-level object if it has no differences\\n    if (Object.keys(result).length === 0) {\\n      return {};\\n    }\\n\\n    return result;\\n  } catch (error) {\\n    // Handle any errors that occur during the comparison\\n    console.error(\\'An error occurred during object comparison:\\', error);\\n    return {};\\n  }\\n}\\n\\n\\n"
                    },
                    {
                        "username": "Code_Sagar",
                        "content": "Day20 : Done Solving Today\\'s Question"
                    }
                ]
            }
        ]
    },
    {
        "title": "Remove Trailing Zeros From a String",
        "question_content": "<p>Given a <strong>positive</strong> integer <code>num</code> represented as a string, return <em>the integer </em><code>num</code><em> without trailing zeros as a string</em>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> num = &quot;51230100&quot;\n<strong>Output:</strong> &quot;512301&quot;\n<strong>Explanation:</strong> Integer &quot;51230100&quot; has 2 trailing zeros, we remove them and return integer &quot;512301&quot;.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> num = &quot;123&quot;\n<strong>Output:</strong> &quot;123&quot;\n<strong>Explanation:</strong> Integer &quot;123&quot; has no trailing zeros, we return integer &quot;123&quot;.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= num.length &lt;= 1000</code></li>\n\t<li><code>num</code> consists&nbsp;of only digits.</li>\n\t<li><code>num</code> doesn&#39;t&nbsp;have any leading zeros.</li>\n</ul>\n",
        "solutions": [
            {
                "id": 3570271,
                "title": "java-c-python-js-1-line-strip",
                "content": "# **Explanation**\\nStrip trailing characters by regax replacing.\\n<br>\\n\\n# **Complexity**\\nTime `O(n)`\\nSpace `O(n)` for output\\n<br>\\n\\n**Java**\\n```java\\n    public String removeTrailingZeros(String num) {\\n        return num.replaceAll(\"0+$\", \"\");\\n    }\\n```\\n\\n**C++**\\n```cpp\\n    string removeTrailingZeros(string num) {\\n        return regex_replace(num, regex(\"0+$\"), \"\");\\n    }\\n```\\n\\n**Python**\\n```py\\n    def removeTrailingZeros(self, num: str) -> str:\\n        return num.rstrip(\\'0\\')\\n```\\n\\n**JavaScript**\\n```js\\n\\tvar removeTrailingZeros = function(num) {\\n\\t    return num.replace(/0+$/, \\'\\');\\n\\t};\\n```\\n\\n**Go**\\n```go\\n\\tfunc removeTrailingZeros(num string) string {\\n\\t    return strings.TrimRight(num, \"0\")\\n\\t}\\n```\\n",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C",
                    "JavaScript",
                    "Go"
                ],
                "code": "```java\\n    public String removeTrailingZeros(String num) {\\n        return num.replaceAll(\"0+$\", \"\");\\n    }\\n```\n```cpp\\n    string removeTrailingZeros(string num) {\\n        return regex_replace(num, regex(\"0+$\"), \"\");\\n    }\\n```\n```py\\n    def removeTrailingZeros(self, num: str) -> str:\\n        return num.rstrip(\\'0\\')\\n```\n```js\\n\\tvar removeTrailingZeros = function(num) {\\n\\t    return num.replace(/0+$/, \\'\\');\\n\\t};\\n```\n```go\\n\\tfunc removeTrailingZeros(num string) string {\\n\\t    return strings.TrimRight(num, \"0\")\\n\\t}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3570456,
                "title": "iterate-very-simple-easy-to-understand",
                "content": "<b> Up vote if you like the solution </b>\\n\\nFind the ith index from last which is not equal to zero, then take substring up to (i + 1)th index.\\n\\n# Code\\n```\\nstring removeTrailingZeros(string num) {\\n    int i = num.size() -1; \\n    while(i >= 0 && num[i] == \\'0\\') i--;\\n    return num.substr(0, i+1);\\n}\\n```\\n\\n<b> Here is an article of my last interview experience - A Journey to FAANG Company, I recomand you to go through this to know which all resources I have used & how I cracked interview at Amazon:\\nhttps://leetcode.com/discuss/interview-experience/3171859/Journey-to-a-FAANG-Company-Amazon-or-SDE2-(L5)-or-Bangalore-or-Oct-2022-Accepted",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nstring removeTrailingZeros(string num) {\\n    int i = num.size() -1; \\n    while(i >= 0 && num[i] == \\'0\\') i--;\\n    return num.substr(0, i+1);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3571098,
                "title": "erase-find-if-and-base",
                "content": "TIL: the `base` function converts the reverse iterator to the corresponding forward iterator.\\n\\nThe `find_if` function below searches for the first non-zero character from the right (reverse).\\n\\n**C++**\\n```cpp\\nstring removeTrailingZeros(string num) {\\n    num.erase(find_if(rbegin(num), rend(num), [](char ch){\\n        return ch != \\'0\\';\\n    }).base(), end(num));\\n    return num;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```cpp\\nstring removeTrailingZeros(string num) {\\n    num.erase(find_if(rbegin(num), rend(num), [](char ch){\\n        return ch != \\'0\\';\\n    }).base(), end(num));\\n    return num;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3571226,
                "title": "python3-solution",
                "content": "\\n```\\nclass Solution:\\n    def removeTrailingZeros(self, num: str) -> str:\\n        return num.rstrip(\\'0\\')\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def removeTrailingZeros(self, num: str) -> str:\\n        return num.rstrip(\\'0\\')\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3570411,
                "title": "c-simple",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    string removeTrailingZeros(string num) {\\n        int j = num.length()-1;\\n        while(j >= 0 && num[j]==\\'0\\')j--;\\n        if(j<0)return \"\";\\n        return num.substr(0,j+1);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string removeTrailingZeros(string num) {\\n        int j = num.length()-1;\\n        while(j >= 0 && num[j]==\\'0\\')j--;\\n        if(j<0)return \"\";\\n        return num.substr(0,j+1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3571035,
                "title": "java-simple-while-checking-charat-from-end",
                "content": "# Code\\n```\\npublic String removeTrailingZeros(String num) {\\n    int len = num.length();\\n    while (--len >= 0) {\\n        if (num.charAt(len) != \\'0\\') break;\\n    }\\n    return num.substring(0, ++len);\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic String removeTrailingZeros(String num) {\\n    int len = num.length();\\n    while (--len >= 0) {\\n        if (num.charAt(len) != \\'0\\') break;\\n    }\\n    return num.substring(0, ++len);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3570865,
                "title": "rstrip-python-1-liner",
                "content": "\\n# Code\\n```\\nclass Solution:\\n    def removeTrailingZeros(self, num: str) -> str:\\n        return num.rstrip(\\'0\\')\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def removeTrailingZeros(self, num: str) -> str:\\n        return num.rstrip(\\'0\\')\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3570224,
                "title": "easiest-c-solution-with-explanation",
                "content": "\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\nFind the index of the first character which is not 0 from the last and then return the string from starting to that index.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string removeTrailingZeros(string num) {\\n        int n = num.length();\\n        int i;\\n        for(i = n - 1; i >= 0; i--){\\n            if(num[i] != \\'0\\') break;\\n        }\\n        \\n        return num.substr(0,i + 1);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string removeTrailingZeros(string num) {\\n        int n = num.length();\\n        int i;\\n        for(i = n - 1; i >= 0; i--){\\n            if(num[i] != \\'0\\') break;\\n        }\\n        \\n        return num.substr(0,i + 1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3998079,
                "title": "javascript-without-using-inbuilt-method-easy",
                "content": "# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {string} num\\n * @return {string}\\n */\\nvar removeTrailingZeros = function (num) {\\n  let result = \"\"\\n  for (i = num.length - 1; i >= 0; i--) {\\n    if (num[i] !== \"0\" || result.length > 0) {\\n      result = num[i] + result\\n    }\\n  }\\n  return result\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string} num\\n * @return {string}\\n */\\nvar removeTrailingZeros = function (num) {\\n  let result = \"\"\\n  for (i = num.length - 1; i >= 0; i--) {\\n    if (num[i] !== \"0\" || result.length > 0) {\\n      result = num[i] + result\\n    }\\n  }\\n  return result\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3764519,
                "title": "easy-cpp-solution-using-loops-beginer-friendly-with-stepwise-explanation",
                "content": "# Intuition\\n - Somehow use pop().\\n\\n# Approach\\n1. Initialize an integer `i` with the value of the length of the string `num` minus 1.\\n2. Start a while loop that continues as long as the character at index `i` in `num` is equal to `\\'0\\'`.\\n3. Inside the loop, remove the last character from `num` using the `pop_back()` function.\\n4. Decrement the value of `i` by 1 to move to the previous character in the string.\\n5. Once the loop ends, return the modified `num` string.\\n\\n\\n# Complexity\\n- Time complexity:\\n   - O(n)\\n\\n- Space complexity:\\n    - O(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string removeTrailingZeros(string num) {\\n       int i=num.length()-1;\\n        while(num[i]==\\'0\\')\\n        {\\n            num.pop_back();\\n            i--;\\n        }\\n        return num;\\n\\n    }\\n};\\n```\\n# Please upvote and feel free to ask doubts",
                "solutionTags": [
                    "C++",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string removeTrailingZeros(string num) {\\n       int i=num.length()-1;\\n        while(num[i]==\\'0\\')\\n        {\\n            num.pop_back();\\n            i--;\\n        }\\n        return num;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3570202,
                "title": "one-line-code-c-easy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string removeTrailingZeros(string num) {\\n        // ===============================first method=============\\n        \\n        // int j = num.size() - 1;\\n        //  while (j >= 0 && num[j] == \\'0\\') {\\n        //     j--;\\n        // }\\n        // return num.substr(0, j + 1);\\n        \\n        \\n        // ===================second method============================ \\n        return num.substr(0, num.find_last_not_of(\\'0\\') + 1);\\n         \\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string removeTrailingZeros(string num) {\\n        // ===============================first method=============\\n        \\n        // int j = num.size() - 1;\\n        //  while (j >= 0 && num[j] == \\'0\\') {\\n        //     j--;\\n        // }\\n        // return num.substr(0, j + 1);\\n        \\n        \\n        // ===================second method============================ \\n        return num.substr(0, num.find_last_not_of(\\'0\\') + 1);\\n         \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3570199,
                "title": "clean-short-java-solution",
                "content": "\\n``` java []\\nimport java.math.BigInteger;\\n\\nclass Solution {\\n    public String removeTrailingZeros(String num) {\\n        BigInteger n = new BigInteger(num);\\n        while(n.mod(BigInteger.TEN).equals(BigInteger.ZERO))\\n            n = n.divide(BigInteger.TEN);\\n        return n.toString();\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "``` java []\\nimport java.math.BigInteger;\\n\\nclass Solution {\\n    public String removeTrailingZeros(String num) {\\n        BigInteger n = new BigInteger(num);\\n        while(n.mod(BigInteger.TEN).equals(BigInteger.ZERO))\\n            n = n.divide(BigInteger.TEN);\\n        return n.toString();\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3782099,
                "title": "java-beats-100-easiest-solution",
                "content": "\\n\\n# Approach\\nWe start from the right end of the string and iterate backwards until we find the first non-zero digit. We keep track of the index of this non-zero digit. Finally, we return the substring from the beginning of the input string up to this index.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public String removeTrailingZeros(String num) {\\n    int i = num.length() - 1;\\n    while(i >= 0 && num.charAt(i) == \\'0\\') i --;\\n    return num.substring(0, i + 1);    \\n    }\\n}\\n```\\n# PLEASE UPVOTE IF IT WAS HELPFULL",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public String removeTrailingZeros(String num) {\\n    int i = num.length() - 1;\\n    while(i >= 0 && num.charAt(i) == \\'0\\') i --;\\n    return num.substring(0, i + 1);    \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3644499,
                "title": "easy-solution-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string removeTrailingZeros(string s) {\\n        for(int i=s.size()-1;i>=0;i--){\\n            if(s[i]!=\\'0\\')\\n            break;\\n           s.pop_back();\\n        }\\n        return s;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string removeTrailingZeros(string s) {\\n        for(int i=s.size()-1;i>=0;i--){\\n            if(s[i]!=\\'0\\')\\n            break;\\n           s.pop_back();\\n        }\\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3634061,
                "title": "easy-java-solution-beats-100",
                "content": "# Approach\\nWe start from the right end of the string and iterate backwards until we find the first non-zero digit. We keep track of the index of this non-zero digit. Finally, we return the substring from the beginning of the input string up to this index.\\n\\n\\n# Code\\n```\\nclass Solution {\\n    public String removeTrailingZeros(String num) {\\n        \\n        int i = num.length() - 1;\\n        while (i >= 0 && num.charAt(i) == \\'0\\') {\\n            i--;\\n        }\\n        return num.substring(0, i + 1);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String removeTrailingZeros(String num) {\\n        \\n        int i = num.length() - 1;\\n        while (i >= 0 && num.charAt(i) == \\'0\\') {\\n            i--;\\n        }\\n        return num.substring(0, i + 1);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3587459,
                "title": "c-in-place-resizing-8ms-8-8mb",
                "content": "Nice warmup problem, we can get it done by using a reading pointer `r` we will advance from the back up to the first position which is not a `\\'0\\'`; we will then resize `num` to be `r + 1` character and `return` it.\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n- Space complexity: $$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string removeTrailingZeros(string num) {\\n        // support variables\\n        int r = num.size();\\n        // moving r to the last non-\\'0\\' digit\\n        while (num[--r] == \\'0\\');\\n        // pruning the zeroes (if any) out of num\\n        num.resize(r + 1);\\n        return num;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string removeTrailingZeros(string num) {\\n        // support variables\\n        int r = num.size();\\n        // moving r to the last non-\\'0\\' digit\\n        while (num[--r] == \\'0\\');\\n        // pruning the zeroes (if any) out of num\\n        num.resize(r + 1);\\n        return num;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3573465,
                "title": "c-java-locating-the-first-non-zero-character-from-the-end",
                "content": "Start from the last character and continue backwards until you encounter the first character that is not zero.\\n\\nC++:\\n```\\nclass Solution {\\npublic:\\n    string removeTrailingZeros(string num) {\\n        int i = num.size() - 1;\\n        for (; i >= 0; i--)\\n            if (num[i] != \\'0\\')\\n                break;\\n        return num.substr(0, i + 1);\\n    }\\n};\\n```\\n\\nJava:\\n```\\nclass Solution {\\n    public String removeTrailingZeros(String num) {\\n        int i = num.length() - 1;\\n        for (; i >= 0; i--)\\n            if (num.charAt(i) != \\'0\\') \\n                break;\\n        return num.substring(0, i + 1);\\n    }\\n}\\n```\\n\\n",
                "solutionTags": [
                    "Java",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string removeTrailingZeros(string num) {\\n        int i = num.size() - 1;\\n        for (; i >= 0; i--)\\n            if (num[i] != \\'0\\')\\n                break;\\n        return num.substr(0, i + 1);\\n    }\\n};\\n```\n```\\nclass Solution {\\n    public String removeTrailingZeros(String num) {\\n        int i = num.length() - 1;\\n        for (; i >= 0; i--)\\n            if (num.charAt(i) != \\'0\\') \\n                break;\\n        return num.substring(0, i + 1);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3570656,
                "title": "easy-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    string removeTrailingZeros(string num) {\\n        int n= num.size();\\n        int i =n-1;\\n        while(num[i]==\\'0\\'){\\n            i--;\\n        }\\n        string ans=\"\";\\n        for(int k =0;k<=i;k++) ans+=num[k];\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string removeTrailingZeros(string num) {\\n        int n= num.size();\\n        int i =n-1;\\n        while(num[i]==\\'0\\'){\\n            i--;\\n        }\\n        string ans=\"\";\\n        for(int k =0;k<=i;k++) ans+=num[k];\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3570592,
                "title": "c-very-easy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string removeTrailingZeros(string num) {\\n        int i = num.size() - 1;  // Start from the last character index\\n\\n        // Remove trailing zeros\\n        while (i >= 0 && num[i] == \\'0\\') {\\n            num.pop_back();  // Remove the last character\\n            i--;\\n        }\\n\\n        return num;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string removeTrailingZeros(string num) {\\n        int i = num.size() - 1;  // Start from the last character index\\n\\n        // Remove trailing zeros\\n        while (i >= 0 && num[i] == \\'0\\') {\\n            num.pop_back();  // Remove the last character\\n            i--;\\n        }\\n\\n        return num;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3570559,
                "title": "2710-java-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n Remove all zeros in end of the String num;\\nex 1 : 51230100 (remove zeros from end) = 512301;\\nex 2: 67433430000 = 6743343;\\nex 2: 6743 (there are no zeros in the end)= 6743;\\n\\n# **code explanation**\\n**int i** is a last index in num\\nloop to travel right to left.\\n**num.charAt(--i) == \\'0\\'** = to find any non zero number loop will break;\\n\\n**num.substring( (star index) 0 , (end index) i);** num.substring is a method\\nreturn a string starting index to end index in num string;\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code using for loop\\n```\\nclass Solution {\\n    public String removeTrailingZeros(String num) {\\n        int i = num.length()-1;\\n        for(;num.charAt(i) == \\'0\\'; i--);\\n        return num.substring(0,i+1);\\n    }\\n}\\n```\\n# Code using while loop\\n```\\nclass Solution {\\n    public String removeTrailingZeros(String num) {\\n        int i = num.length();\\n        while(num.charAt(--i) == \\'0\\');\\n        return num.substring(0,i+1);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String removeTrailingZeros(String num) {\\n        int i = num.length()-1;\\n        for(;num.charAt(i) == \\'0\\'; i--);\\n        return num.substring(0,i+1);\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public String removeTrailingZeros(String num) {\\n        int i = num.length();\\n        while(num.charAt(--i) == \\'0\\');\\n        return num.substring(0,i+1);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3570255,
                "title": "python-c",
                "content": "\\n```python []\\nclass Solution:\\n    def removeTrailingZeros(self, num: str) -> str:\\n        while num[-1] == \\'0\\': \\n            num = num[:-1]\\n        return num\\n```\\n```C++ []\\nclass Solution {\\npublic:\\n    string removeTrailingZeros(string num) {\\n        while(num[num.size() - 1] == \\'0\\')   \\n            num.pop_back();\\n        return num;\\n    }\\n};\\n```\\n\\n",
                "solutionTags": [
                    "C++",
                    "Python3"
                ],
                "code": "```python []\\nclass Solution:\\n    def removeTrailingZeros(self, num: str) -> str:\\n        while num[-1] == \\'0\\': \\n            num = num[:-1]\\n        return num\\n```\n```C++ []\\nclass Solution {\\npublic:\\n    string removeTrailingZeros(string num) {\\n        while(num[num.size() - 1] == \\'0\\')   \\n            num.pop_back();\\n        return num;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3570186,
                "title": "easy-beginner-friendly-c-direct",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    string removeTrailingZeros(string num) {\\n        int i;\\n        for(i=num.size()-1;i>=0;i--){\\n            if(num[i]!=\\'0\\')\\n                break;\\n        }\\n        return num.substr(0,i+1);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string removeTrailingZeros(string num) {\\n        int i;\\n        for(i=num.size()-1;i>=0;i--){\\n            if(num[i]!=\\'0\\')\\n                break;\\n        }\\n        return num.substr(0,i+1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3993550,
                "title": "c-easy-to-understand",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    string removeTrailingZeros(string num) {\\n        while(num.back() == \\'0\\') {\\n            num.pop_back();\\n        }\\n        return num;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string removeTrailingZeros(string num) {\\n        while(num.back() == \\'0\\') {\\n            num.pop_back();\\n        }\\n        return num;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3950961,
                "title": "python-code-for-beginner-s",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n I simply used the strip function which removes the trailing character from the string you may also use rstrip that will provide the same result.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:95%\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:95.4%\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def removeTrailingZeros(self, num: str) -> str:\\n        return num.strip(\\'0\\')\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def removeTrailingZeros(self, num: str) -> str:\\n        return num.strip(\\'0\\')\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3874649,
                "title": "one-liner-beats-94-python3",
                "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def removeTrailingZeros(self, num: str) -> str:\\n        return str(int(str(num)[::-1]))[::-1]\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def removeTrailingZeros(self, num: str) -> str:\\n        return str(int(str(num)[::-1]))[::-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3846783,
                "title": "approach-for-all-languages-easy-c-code-tryithindi",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. simply socho piche jb tk 0 hoga hatana hai 0\\n2. loop lagao, last element check karo\\n3. 0 mila to last element to 0 hatao aur last element = last element - 1, otherwise return the same string.\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string removeTrailingZeros(string num) {\\n        int n = num.length()-1;\\n        while(num[n] ==\\'0\\'){\\n            num.pop_back();\\n            n--;\\n        }\\n\\n        return num;\\n    }\\n};\\n```\\n![upvote.jpg](https://assets.leetcode.com/users/images/1cfb7537-2330-4d9c-a411-8c55b8693eed_1690877287.7127228.jpeg)\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string removeTrailingZeros(string num) {\\n        int n = num.length()-1;\\n        while(num[n] ==\\'0\\'){\\n            num.pop_back();\\n            n--;\\n        }\\n\\n        return num;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3801485,
                "title": "python-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def removeTrailingZeros(self, num: str) -> str:\\n\\n        while(num[-1] == \\'0\\'):\\n            num = num[:-1]\\n        return num\\n        \\n```\\n## Other Problem Solutions:\\n\\n- For Python: https://github.com/Abu-bakr-Siddiqh/leetcode_solutions_python\\n\\n- For Java : https://github.com/Abu-bakr-Siddiqh/leetcode_solutions_java",
                "solutionTags": [
                    "Python3",
                    "String"
                ],
                "code": "```\\nclass Solution:\\n    def removeTrailingZeros(self, num: str) -> str:\\n\\n        while(num[-1] == \\'0\\'):\\n            num = num[:-1]\\n        return num\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3735458,
                "title": "2710-remove-trailing-zeros-from-a-string",
                "content": "```\\nclass Solution {\\npublic:\\n    string removeTrailingZeros(string num) { // 51230100\\n    //  int size= num.length();  //8\\n    // we can use  .length() function also\\n        int size= num.size();  //8\\n        // we will use simple pointer for backward traversal\\n        int i; \\n       // declaring i before loop to use the value of i after the for loop ends\\n        for( i=size-1;i>=0;i--){   // 7 > 0 6>0 5>0 \\n            if(num[i] !=\\'0\\'){   // 0 0 1\\n                break;    // at i=5 value = 1 it breaks from the for loop\\n            }\\n        }\\n        // substr = substring which returns a part of the string\\n// variable.substr(starting position, size of substring);\\n        return num.substr(0,i+1);  // starting position = 0 == first index\\n        // size of the substring = i+ 1 = 5+1 =6 == \"512301\"\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string removeTrailingZeros(string num) { // 51230100\\n    //  int size= num.length();  //8\\n    // we can use  .length() function also\\n        int size= num.size();  //8\\n        // we will use simple pointer for backward traversal\\n        int i; \\n       // declaring i before loop to use the value of i after the for loop ends\\n        for( i=size-1;i>=0;i--){   // 7 > 0 6>0 5>0 \\n            if(num[i] !=\\'0\\'){   // 0 0 1\\n                break;    // at i=5 value = 1 it breaks from the for loop\\n            }\\n        }\\n        // substr = substring which returns a part of the string\\n// variable.substr(starting position, size of substring);\\n        return num.substr(0,i+1);  // starting position = 0 == first index\\n        // size of the substring = i+ 1 = 5+1 =6 == \"512301\"\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3673621,
                "title": "easy-java-solution",
                "content": "\\n\\n# Approach\\nChecking the string from backwards if the last character is not zero return the entire string else chech the string character by character if the character is \\'0\\' assign the index value to the pointer if the character is not \\'0\\' come out of the loop and the return the string from the starting index uptill to the pointer.\\n\\nOriginal string : 51230100\\nIterate the string from backwards\\nEx  : 00103215\\n\\nInititally i points to the left most end \\'0\\' .\\nAccording to our condition if the character is \\'0\\' assign the value of pointer(Ex : l) to the index value.Here i = num.length()-1 (here length = 8-1 = 7),therefore l = num.length()-1.\\ncontinue the process\\ncheck the next character if it is \\'0\\' update the l value.\\nIf the character is not zero exit the loop.\\nNow the value of l = 6\\nReturn the substring from 0 to l.\\n\\n\\n\\n# Code\\n```\\nclass Solution {\\n    public String removeTrailingZeros(String num) {\\n         int l =num.length()-1;\\n         String s=\"\";\\n        if(num.charAt(num.length()-1)!=\\'0\\')\\n        return num;\\n        else{\\n        for(int i=num.length()-1;i>=0;i--){  \\n            char ch = num.charAt(i);\\n            if(ch==\\'0\\')\\n              l = i;\\n            else\\n                break;\\n        }\\n        s+= num.substring(0,l);\\n        }\\n        return s;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public String removeTrailingZeros(String num) {\\n         int l =num.length()-1;\\n         String s=\"\";\\n        if(num.charAt(num.length()-1)!=\\'0\\')\\n        return num;\\n        else{\\n        for(int i=num.length()-1;i>=0;i--){  \\n            char ch = num.charAt(i);\\n            if(ch==\\'0\\')\\n              l = i;\\n            else\\n                break;\\n        }\\n        s+= num.substring(0,l);\\n        }\\n        return s;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3656623,
                "title": "2710-remove-trailing-zeros-from-a-string-100-easy-java-code",
                "content": "# Code\\n```\\nclass Solution {\\n    public String removeTrailingZeros(String num) {\\n        int n = num.length()-1;\\n        for(int i = n ;i>0; i--){\\n            if(num.charAt(i) != \\'0\\'){\\n                break;\\n            }\\n            n--;\\n        }\\n        return num.substring(0,n+1);\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String removeTrailingZeros(String num) {\\n        int n = num.length()-1;\\n        for(int i = n ;i>0; i--){\\n            if(num.charAt(i) != \\'0\\'){\\n                break;\\n            }\\n            n--;\\n        }\\n        return num.substring(0,n+1);\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3595097,
                "title": "very-easy-c-solution",
                "content": "# Code\\n```\\nclass Solution \\n{\\npublic:\\n    string removeTrailingZeros(string num) \\n    {\\n        int i=num.size()-1;\\n        while(i>0 && num[i]==\\'0\\') i--;\\n        num=num.substr(0,i+1);\\n        return num;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution \\n{\\npublic:\\n    string removeTrailingZeros(string num) \\n    {\\n        int i=num.size()-1;\\n        while(i>0 && num[i]==\\'0\\') i--;\\n        num=num.substr(0,i+1);\\n        return num;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3589455,
                "title": "my-solution-for-java-javascript",
                "content": "```java []\\nclass Solution {\\n    public String removeTrailingZeros(String num) {\\n        int remove = 0;\\n\\n        for(int i = num.length() - 1; i > 0;i--){\\n            if(num.charAt(i) == \\'0\\'){\\n                remove++;\\n            }else {\\n                break;\\n            }\\n        }\\n        String result = num.substring(0,num.length() - remove);\\n        return result;\\n    }\\n}\\n```\\n```javascript []\\n/**\\n * @param {string} num\\n * @return {string}\\n */\\nvar removeTrailingZeros = function(num) {\\n    let remove = 0;\\n\\n    for(let i = num.length - 1; i > 0; i--){\\n        if(num.charAt(i) === \\'0\\') remove ++;\\n        else break;\\n    }\\n\\n    let result = num.substring(0,num.length - remove);\\n    return result;\\n};\\n```\\n\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```java []\\nclass Solution {\\n    public String removeTrailingZeros(String num) {\\n        int remove = 0;\\n\\n        for(int i = num.length() - 1; i > 0;i--){\\n            if(num.charAt(i) == \\'0\\'){\\n                remove++;\\n            }else {\\n                break;\\n            }\\n        }\\n        String result = num.substring(0,num.length() - remove);\\n        return result;\\n    }\\n}\\n```\n```javascript []\\n/**\\n * @param {string} num\\n * @return {string}\\n */\\nvar removeTrailingZeros = function(num) {\\n    let remove = 0;\\n\\n    for(let i = num.length - 1; i > 0; i--){\\n        if(num.charAt(i) === \\'0\\') remove ++;\\n        else break;\\n    }\\n\\n    let result = num.substring(0,num.length - remove);\\n    return result;\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3587250,
                "title": "c-1-line-super-easy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string removeTrailingZeros(string num) {\\n        while(num.back() == \\'0\\') num.pop_back();\\n        return num;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string removeTrailingZeros(string num) {\\n        while(num.back() == \\'0\\') num.pop_back();\\n        return num;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3585983,
                "title": "one-liner-code-c-beginner-friendly",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe are concerned only with the zeroes at the end of the number. The constraints mention that the number does not have any leading zeroes. So, we must start from the last index.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nKeep traversing the string from the end. Continue the traversal only till you reach a point where the character at that index represents a non zero integer\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(K)$$, where K represents the number of trailing zeroes in the number\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(1)$$\\nNo extra data structures used\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string removeTrailingZeros(string num) {\\n        while(num[num.size()-1]==\\'0\\') num.pop_back();\\n        return num;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string removeTrailingZeros(string num) {\\n        while(num[num.size()-1]==\\'0\\') num.pop_back();\\n        return num;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3585324,
                "title": "regular-expression-runtime-beats-78-memory-usage-beats-91-71",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. First we open an expression using //\\n2. 0+ matches one or more consecutive zero characters.\\n3. $ denotes the end of the string\\n\\n# Code\\n```\\n/**\\n * @param {string} num\\n * @return {string}\\n */\\nvar removeTrailingZeros = function(num) {\\n    return num.replace(/0+$/, \"\")\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string} num\\n * @return {string}\\n */\\nvar removeTrailingZeros = function(num) {\\n    return num.replace(/0+$/, \"\")\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3582595,
                "title": "java-o-n-solution",
                "content": "# Solution:\\n```\\nclass Solution {\\n    public String removeTrailingZeros(String num) {\\n        int i = num.length();\\n        while (num.charAt(i - 1) == \\'0\\') i--;\\n        return num.substring(0, i);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public String removeTrailingZeros(String num) {\\n        int i = num.length();\\n        while (num.charAt(i - 1) == \\'0\\') i--;\\n        return num.substring(0, i);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3579564,
                "title": "javascript-indirect-approach",
                "content": "```\\n/**\\n * @param {string} num\\n * @return {string}\\n */\\nvar removeTrailingZeros = function(num) {\\n    let i = -1; //index for zeros counting back from the end of num\\n    while (num.at(i) === \"0\") i--;\\n     \\n    return num.substring(0, num.length + i + 1);\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string} num\\n * @return {string}\\n */\\nvar removeTrailingZeros = function(num) {\\n    let i = -1; //index for zeros counting back from the end of num\\n    while (num.at(i) === \"0\") i--;\\n     \\n    return num.substring(0, num.length + i + 1);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3576438,
                "title": "javascript-2-solutions",
                "content": "# Approach 1 - Iterate\\n```\\nfunction removeTrailingZeros(num) {\\n    const result = String(num);\\n\\n    let i = result.length - 1;\\n    while (num[i] == \\'0\\') i--;\\n\\n    return result.slice(0, i + 1);\\n};\\n```\\n\\n# Approach 2 - Regular Expression\\n```\\nfunction removeTrailingZeros(num) {\\n    return num.replace(/0+$/, \\'\\');\\n};\\n```\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nfunction removeTrailingZeros(num) {\\n    const result = String(num);\\n\\n    let i = result.length - 1;\\n    while (num[i] == \\'0\\') i--;\\n\\n    return result.slice(0, i + 1);\\n};\\n```\n```\\nfunction removeTrailingZeros(num) {\\n    return num.replace(/0+$/, \\'\\');\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3576237,
                "title": "java-solution",
                "content": "# Code\\n```\\nclass Solution {\\n    public String removeTrailingZeros(String num) {\\n        int i = num.length()-1;\\n        while(num.charAt(i)==\\'0\\'){\\n            i--;\\n        }\\n        return num.substring(0,i+1);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public String removeTrailingZeros(String num) {\\n        int i = num.length()-1;\\n        while(num.charAt(i)==\\'0\\'){\\n            i--;\\n        }\\n        return num.substring(0,i+1);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3573527,
                "title": "easy-one-line-solution",
                "content": "\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nRemove 0 at the end by trimming the string.\\n# Complexity\\n- Time complexity:$$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\npublic class Solution {\\n    public string RemoveTrailingZeros(string num) {\\n       return num.TrimEnd(\\'0\\'); \\n    }\\n}\\n```",
                "solutionTags": [
                    "C#",
                    "String"
                ],
                "code": "```\\npublic class Solution {\\n    public string RemoveTrailingZeros(string num) {\\n       return num.TrimEnd(\\'0\\'); \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3572709,
                "title": "easy-to-understand-simple-for-loop-o-n-javascript",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nfunction removeTrailingZeros(num: string): string {\\n    let start = -1;\\n    for (let i = num.length - 1; i >= 0; i--) {\\n        if (num[i] === \\'0\\') {\\n            start = i;\\n        } else {\\n            break;\\n        }\\n    }\\n\\n    return start >= 0 ? num.slice(0, start): num;\\n};\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\nfunction removeTrailingZeros(num: string): string {\\n    let start = -1;\\n    for (let i = num.length - 1; i >= 0; i--) {\\n        if (num[i] === \\'0\\') {\\n            start = i;\\n        } else {\\n            break;\\n        }\\n    }\\n\\n    return start >= 0 ? num.slice(0, start): num;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3571965,
                "title": "easy-solution-with-a-pointer-and-substring-method",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(k), where k - number of zero\\'s\\n- Space complexity: O(1)\\n\\n# Code\\n```\\npublic class Solution {\\n    public string RemoveTrailingZeros(string s) {\\n        int n = s.Length-1;\\n        while( s[n]==\\'0\\' && n>-1 ) { n--; }\\n        return s.Substring(0, n+1);\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public string RemoveTrailingZeros(string s) {\\n        int n = s.Length-1;\\n        while( s[n]==\\'0\\' && n>-1 ) { n--; }\\n        return s.Substring(0, n+1);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3570958,
                "title": "python3-straightforward-solution",
                "content": "Find the difference between the length of the string obtained by reversing the string and converting it to numerical form and the original string. Then cut the original string at the corresponding index.\\n\\n```\\nclass Solution:\\n    def removeTrailingZeros(self, num: str) -> str:\\n        idx = len(str(int(num[::-1]))) - len(num)\\n        \\n        return num[:idx] if idx < 0 else num\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def removeTrailingZeros(self, num: str) -> str:\\n        idx = len(str(int(num[::-1]))) - len(num)\\n        \\n        return num[:idx] if idx < 0 else num\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3570899,
                "title": "easy-fastest-java-solution",
                "content": "```\\nclass Solution {\\n    public String removeTrailingZeros(String num) {\\n    int ind=0;\\n    for(int i=num.length()-1;i>=0;i--){\\n            if(num.charAt(i)!=\\'0\\'){\\n                ind=i;\\n                break;\\n            }\\n            }\\n            return num.substring(0, ind+1);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public String removeTrailingZeros(String num) {\\n    int ind=0;\\n    for(int i=num.length()-1;i>=0;i--){\\n            if(num.charAt(i)!=\\'0\\'){\\n                ind=i;\\n                break;\\n            }\\n            }\\n            return num.substring(0, ind+1);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3570362,
                "title": "c-simple-solution",
                "content": "# Intuition\\nJust find the 1st non-zero char from the right side.\\n\\n# Approach\\nJust find the 1st non-zero char from the right side:\\n```\\nwhile (num[index] == \\'0\\')\\n{\\n    index--;\\n}\\n```\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```\\npublic class Solution {\\n    public string RemoveTrailingZeros(string num) {\\n        var index = num.Length - 1;\\n        while (num[index] == \\'0\\')\\n        {\\n            index--;\\n        }\\n        return num.Substring(0, index + 1);\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\nwhile (num[index] == \\'0\\')\\n{\\n    index--;\\n}\\n```\n```\\npublic class Solution {\\n    public string RemoveTrailingZeros(string num) {\\n        var index = num.Length - 1;\\n        while (num[index] == \\'0\\')\\n        {\\n            index--;\\n        }\\n        return num.Substring(0, index + 1);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3570344,
                "title": "beginner-friendly-solution-100ms-faster",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    string removeTrailingZeros(string num) {\\n        string ans ;\\n        int j = num.size()-1;\\n        \\n        while(num[j] == \\'0\\' && j >= 0){\\n            j--;\\n        }\\n        ans = num.substr(0,j+1);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string removeTrailingZeros(string num) {\\n        string ans ;\\n        int j = num.size()-1;\\n        \\n        while(num[j] == \\'0\\' && j >= 0){\\n            j--;\\n        }\\n        ans = num.substr(0,j+1);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3570324,
                "title": "short-intuitive-c",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    string removeTrailingZeros(string num) \\n    {\\n        int i=num.size()-1;\\n        while(i>=0 && num[i]==\\'0\\')\\n        {\\n            num.pop_back();\\n            i--;\\n        }\\n        return num;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string removeTrailingZeros(string num) \\n    {\\n        int i=num.size()-1;\\n        while(i>=0 && num[i]==\\'0\\')\\n        {\\n            num.pop_back();\\n            i--;\\n        }\\n        return num;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3570286,
                "title": "c-solutions-explained-line-by-line-easy-to-understand-beginner-friendly",
                "content": "# Intuition\\nStart from the end of the string representation of the number.\\n\\nIterate through the characters of the string from right to left.\\n\\nCheck if the current character is \\'0\\'.\\n\\nIf the current character is \\'0\\', remove it by using the pop_back() function, which removes the last character from the string.\\n\\nRepeat steps 3-4 until a non-zero character is encountered or until the end of the string is reached.\\n\\nReturn the modified string without the trailing zeros\\n\\n\\n\\n# Approach\\nThe approach focuses on removing trailing zeros from the string representation of the number by iterating from the end and removing the \\'0\\' characters until a non-zero character is encountered. This ensures that all trailing zeros are removed, leaving the modified string without any trailing zeros.\\n\\n# Complexity\\n\\n\\n\\n\\n\\n- Time complexity:\\nThe code iterates through the characters of the string representation of the number once, from right to left. Therefore, the time complexity is proportional to the length of the input string, which is O(n), where n is the length of the string.\\n\\nWithin the loop, the code performs a constant-time check for each character to determine if it is \\'0\\' and removes it using pop_back(). These operations do not depend on the input size and do not affect the overall time complexity.\\n\\nTherefore, the overall time complexity of the code is O(n), where n is the length of the string representation of the number.\\n\\n- Space complexity:\\nThe code does not use any additional data structures that scale with the input size. It only modifies the input string in place.\\n\\nThe space complexity is determined by the input string itself. Since the string is modified in place and no additional space is used, the space complexity is O(1), which is constant.\\n\\n\\nIn summary, the time complexity of the code is O(n), where n is the length of the input string, and the space complexity is O(1), which is constant.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string removeTrailingZeros(string num) {\\n        // Loop until the last character of the string is \\'0\\'\\n        while (num.back() == \\'0\\')\\n            num.pop_back(); // Remove the trailing \\'0\\' from the string\\n        \\n        return num; // Return the modified string without trailing zeros\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string removeTrailingZeros(string num) {\\n        // Loop until the last character of the string is \\'0\\'\\n        while (num.back() == \\'0\\')\\n            num.pop_back(); // Remove the trailing \\'0\\' from the string\\n        \\n        return num; // Return the modified string without trailing zeros\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3570278,
                "title": "explained-2-liner-c-easiest-approach",
                "content": "# Code\\n```\\n string removeTrailingZeros(string num) {\\n        int i=num.length()-1; //Fix a pointer at the end of string\\n        while(i>=0 && num[i]==\\'0\\') //While last character is 0 and i>=0\\n        {\\n            num=num.substr(0,i); //Remove last character\\n            i--; //Shift pointer to left\\n        }\\n        return num;\\n    }\\n```\\n# \\u2B06\\uFE0F **PLEASE UPVOTE IF YOU UNDERSTOOD!** \\u2764\\uFE0F",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n string removeTrailingZeros(string num) {\\n        int i=num.length()-1; //Fix a pointer at the end of string\\n        while(i>=0 && num[i]==\\'0\\') //While last character is 0 and i>=0\\n        {\\n            num=num.substr(0,i); //Remove last character\\n            i--; //Shift pointer to left\\n        }\\n        return num;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3570263,
                "title": "easy-java-solution-100-faster-0ms",
                "content": "\\n- Time complexity: O(n)\\n\\n- Space complexity: O(1)\\n\\n```\\nclass Solution {\\n    public String removeTrailingZeros(String num) {\\n      \\n       int i=num.length()-1; \\n       while(i>=0 && num.charAt(i)==\\'0\\')\\n       {\\n            i--;\\n       }\\n        return num.substring(0,i+1);\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String removeTrailingZeros(String num) {\\n      \\n       int i=num.length()-1; \\n       while(i>=0 && num.charAt(i)==\\'0\\')\\n       {\\n            i--;\\n       }\\n        return num.substring(0,i+1);\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4102277,
                "title": "1-ms-solution-beats-100-users",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public String removeTrailingZeros(String num) {\\n       int count = 0;\\n        for(int i=num.length()-1;i>=0;i--){\\n            if(num.charAt(i) == \\'0\\'){\\n                count++;\\n            }\\n            else{\\n                return  num.substring(0,num.length()-count);\\n            }\\n        }\\n        return \"\"; \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String removeTrailingZeros(String num) {\\n       int count = 0;\\n        for(int i=num.length()-1;i>=0;i--){\\n            if(num.charAt(i) == \\'0\\'){\\n                count++;\\n            }\\n            else{\\n                return  num.substring(0,num.length()-count);\\n            }\\n        }\\n        return \"\"; \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4101781,
                "title": "easy-c-concept-beats-90",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string removeTrailingZeros(string num) {\\n        int pos;\\n        for(int i=num.length()-1;i>=0;i--){\\n            if(num[i]!=\\'0\\'){\\n                pos = i;\\n                break;\\n            } \\n        }\\n        return num.substr(0,pos+1);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string removeTrailingZeros(string num) {\\n        int pos;\\n        for(int i=num.length()-1;i>=0;i--){\\n            if(num[i]!=\\'0\\'){\\n                pos = i;\\n                break;\\n            } \\n        }\\n        return num.substr(0,pos+1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4098148,
                "title": "php-solution-with-best",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n# Memory\\n19.16MB\\nBeats 44.44%of users with PHP\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n> **10ms**\\nBeats 61.11%of users with PHP\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    /**\\n     * @param String $num\\n     * @return String\\n     */\\n    function removeTrailingZeros($num) {\\n        $arr = str_split($num);\\n        $count = count($arr);\\n        \\n        $lastNonZeroIndex = $count - 1;\\n        while ($lastNonZeroIndex >= 0 && $arr[$lastNonZeroIndex] === \\'0\\') {\\n            $lastNonZeroIndex--;\\n        }\\n\\n\\n        if ($lastNonZeroIndex < 0) {\\n            return \"0\";\\n        }\\n        return implode(\"\", array_slice($arr, 0, $lastNonZeroIndex + 1));\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "PHP",
                    "String",
                    "String Matching"
                ],
                "code": "```\\nclass Solution {\\n    /**\\n     * @param String $num\\n     * @return String\\n     */\\n    function removeTrailingZeros($num) {\\n        $arr = str_split($num);\\n        $count = count($arr);\\n        \\n        $lastNonZeroIndex = $count - 1;\\n        while ($lastNonZeroIndex >= 0 && $arr[$lastNonZeroIndex] === \\'0\\') {\\n            $lastNonZeroIndex--;\\n        }\\n\\n\\n        if ($lastNonZeroIndex < 0) {\\n            return \"0\";\\n        }\\n        return implode(\"\", array_slice($arr, 0, $lastNonZeroIndex + 1));\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4095437,
                "title": "solution-in-javascript",
                "content": "\\n# Code\\n```\\n/**\\n * @param {string} num\\n * @return {string}\\n */\\nvar removeTrailingZeros = function(num) {\\n  let res = num.match(/(\\\\d+)?[^0]/g);\\n  return(`${res}`);\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string} num\\n * @return {string}\\n */\\nvar removeTrailingZeros = function(num) {\\n  let res = num.match(/(\\\\d+)?[^0]/g);\\n  return(`${res}`);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4094027,
                "title": "ruby-solution-using-pointer",
                "content": "# Code\\n```\\n# @param {String} num\\n# @return {String}\\ndef remove_trailing_zeros(num)\\n    i = -1\\n    while num[i] == \"0\"\\n      i -= 1\\n    end\\n\\n    num[0..i]\\nend\\n```",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```\\n# @param {String} num\\n# @return {String}\\ndef remove_trailing_zeros(num)\\n    i = -1\\n    while num[i] == \"0\"\\n      i -= 1\\n    end\\n\\n    num[0..i]\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 4093898,
                "title": "c-solution",
                "content": "\\n\\n# Complexity\\n- Time complexity:\\n    O(n)\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string removeTrailingZeros(string num) {\\n        int n = num.size();\\n        for(int i = n-1;i<n;i--){\\n            if(num[i]==\\'0\\'){\\n                num.pop_back();\\n            }\\n            if(num[i]!=0){\\n                break;\\n            }\\n        }\\n        return num;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string removeTrailingZeros(string num) {\\n        int n = num.size();\\n        for(int i = n-1;i<n;i--){\\n            if(num[i]==\\'0\\'){\\n                num.pop_back();\\n            }\\n            if(num[i]!=0){\\n                break;\\n            }\\n        }\\n        return num;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4092420,
                "title": "o-n-easy-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public String removeTrailingZeros(String num) {\\n        int c=0;\\n        for(int i=num.length()-1;i>=0;i--){\\n            if(num.charAt(i)!=\\'0\\'){\\n               c=i;\\n               break;\\n            }\\n        }\\n    return num.substring(0,c+1);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String removeTrailingZeros(String num) {\\n        int c=0;\\n        for(int i=num.length()-1;i>=0;i--){\\n            if(num.charAt(i)!=\\'0\\'){\\n               c=i;\\n               break;\\n            }\\n        }\\n    return num.substring(0,c+1);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4088716,
                "title": "one-liner",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def removeTrailingZeros(self, num: str) -> str:\\n        num = str(int(num[::-1])) return num[::-1]\\n        \\n        \\n\\n            \\n\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def removeTrailingZeros(self, num: str) -> str:\\n        num = str(int(num[::-1])) return num[::-1]\\n        \\n        \\n\\n            \\n\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 4086008,
                "title": "swift-iterating-over-string-indices",
                "content": "# Intuition\\nInstead of cranking out a regular expression or making a custom `trimRight()` function, or type-juggling between `Int` and `String`, I opted to treat this like an interview problem.\\n\\n# Approach\\nIterate over each character, track the position of the last non-zero number, and returning a substring. (But not a Swift `Substring`!)\\n\\n# Complexity\\n\\n- Time complexity: $$O(n)$$ -- we\\'re iterating over an array of `String.Index`\\n\\n- Space complexity: $$O(1)$$ -- we\\'re storing one `String.Index` (Correct me if I\\'m wrong.)\\n\\n# Tips\\n\\n* Unlike most languages, you can\\'t grab the `i`th character of an array.\\n* Swift creates a `Substring` object [(read more)](https://docs.swift.org/swift-book/documentation/the-swift-programming-language/stringsandcharacters/#Substrings) which is a pretty neat way to handle string manipulation with less memory. I always feel bad for needlessly manhandling strings and arrays.\\n* A lot of solutions use `String.lastIndex {}` which solves the problem but doesn\\'t show that *you* know how to do it, which is what interviewers are testing you for.\\n\\n# Code\\n```\\nclass Solution {\\n    func removeTrailingZeros(_ num: String) -> String {\\n\\n        var end = num.startIndex;\\n\\n        for index in num.indices {\\n            if (num[index] != \"0\") {\\n                end = index\\n            }\\n        }\\n\\n        return String(num[...end]);\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func removeTrailingZeros(_ num: String) -> String {\\n\\n        var end = num.startIndex;\\n\\n        for index in num.indices {\\n            if (num[index] != \"0\") {\\n                end = index\\n            }\\n        }\\n\\n        return String(num[...end]);\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4079529,
                "title": "solution-with-regex",
                "content": "Just solution.\\n\\n# Code\\n```\\nclass Solution {\\n    fun removeTrailingZeros(num: String): String {\\n       return Regex(\"0+$\").replace (num, \"\")        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\nclass Solution {\\n    fun removeTrailingZeros(num: String): String {\\n       return Regex(\"0+$\").replace (num, \"\")        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4077172,
                "title": "remove-trailing-zeros-from-a-string-in-java",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public String removeTrailingZeros(String num) {\\n        while(num.charAt(num.length()-1)==\\'0\\')\\n        num=num.substring(0,num.length()-1);\\n        return num;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String removeTrailingZeros(String num) {\\n        while(num.charAt(num.length()-1)==\\'0\\')\\n        num=num.substring(0,num.length()-1);\\n        return num;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4072188,
                "title": "60-days-leetcode-day-2",
                "content": "Simply iterating from back and removing the zeroes.\\n\\n```class Solution {\\npublic:\\n    string removeTrailingZeros(string num) {\\n        while(num.back()==\\'0\\')\\n            num.pop_back();\\n        return num;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "String"
                ],
                "code": "class Solution {\\npublic:\\n    string removeTrailingZeros(string num) {\\n        while(num.back()==\\'0\\')\\n            num.pop_back();\\n        return num;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 4069292,
                "title": "2710-remove-trailing-zeros-from-a-string-easy-simple-solutions",
                "content": "# Code\\n```Python []\\nclass Solution(object):\\n    def removeTrailingZeros(self, num):\\n        num = int(num)\\n        while num % 10 == 0:\\n            num = num // 10\\n        return str(num)\\n```\\n```JavaScript []\\nvar removeTrailingZeros = function(num) {\\n    return num.replace(/0+$/, \\'\\')\\n};\\n```",
                "solutionTags": [
                    "Python",
                    "JavaScript"
                ],
                "code": "```Python []\\nclass Solution(object):\\n    def removeTrailingZeros(self, num):\\n        num = int(num)\\n        while num % 10 == 0:\\n            num = num // 10\\n        return str(num)\\n```\n```JavaScript []\\nvar removeTrailingZeros = function(num) {\\n    return num.replace(/0+$/, \\'\\')\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4069232,
                "title": "easy-python-solution",
                "content": "# Code\\n```\\nclass Solution(object):\\n    def removeTrailingZeros(self, num):\\n        for i in range(len(num)-1,-1,-1):\\n            if num[i] == \\'0\\':\\n                num = num[:-1]\\n            else:\\n                break\\n        return num\\n\\n        \\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def removeTrailingZeros(self, num):\\n        for i in range(len(num)-1,-1,-1):\\n            if num[i] == \\'0\\':\\n                num = num[:-1]\\n            else:\\n                break\\n        return num\\n\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 4068261,
                "title": "simple-and-easy-java-solution-100-beats",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n    Please upvote.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public String removeTrailingZeros(String num) {\\n        int i = num.length()-1;\\n        while(num.charAt(i) == \\'0\\') i--;\\n        return num.substring(0,i+1);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public String removeTrailingZeros(String num) {\\n        int i = num.length()-1;\\n        while(num.charAt(i) == \\'0\\') i--;\\n        return num.substring(0,i+1);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4068000,
                "title": "easy-code-using-stl-funtion-c-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string removeTrailingZeros(string num) {\\n        while(num.back()==\\'0\\'){\\n            num.pop_back();\\n        }\\n        return num;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string removeTrailingZeros(string num) {\\n        while(num.back()==\\'0\\'){\\n            num.pop_back();\\n        }\\n        return num;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4067668,
                "title": "easy-explained-beginner-friendly-solution",
                "content": "# Intuition\\nThe problem is asking to remove trailing zeros from a given string. Trailing zeros are the zeros that appear at the end of a number. For example, in the number \"1200\", \"00\" are trailing zeros.\\n\\n# Approach\\nThe approach used in this code is straightforward. It starts from the end of the string and checks each character. If the character is a zero and we haven\\'t encountered any non-zero character yet (indicated by `t` being 1), it removes that character from the string using `pop_back()`. As soon as it encounters a non-zero character, it sets `t` to 0, indicating that we have encountered a non-zero character and should stop removing characters.\\n\\nHere\\'s a step-by-step breakdown:\\n1. Initialize `t` to 1. This variable acts as a flag to indicate whether we have encountered a non-zero character.\\n2. Iterate over the string from the end to the beginning.\\n3. For each character, check if it\\'s a zero and `t` is still 1.\\n4. If it is, remove that character from the string.\\n5. If it\\'s not a zero, set `t` to 0.\\n\\n# Complexity\\n- Time complexity: The time complexity is $$O(n)$$ because we\\'re iterating over the string once, where $$n$$ is the length of the string.\\n- Space complexity: The space complexity is $$O(1)$$ because we\\'re not using any additional space that scales with the input size. The input string is being modified in place.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string removeTrailingZeros(string num) {\\n        int t=1;\\n        for(int i=num.size()-1;i>=0;i--)\\n            if(num[i]==\\'0\\'&&t)\\n            num.pop_back();\\n            else\\n            t=0;\\n        return num;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Python3",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string removeTrailingZeros(string num) {\\n        int t=1;\\n        for(int i=num.size()-1;i>=0;i--)\\n            if(num[i]==\\'0\\'&&t)\\n            num.pop_back();\\n            else\\n            t=0;\\n        return num;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4067201,
                "title": "easy-solution-c-simple-logic",
                "content": "```\\nclass Solution {\\npublic:\\n    string removeTrailingZeros(string num) {\\n        string ans;\\n        int k ;\\n        for(int i=num.size()-1;i>=0;i--) {\\n                if(num[i]!=\\'0\\') {\\n                    k = i;\\n                    break;\\n                }\\n        }\\n        ans = num.substr(0,k+1);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string removeTrailingZeros(string num) {\\n        string ans;\\n        int k ;\\n        for(int i=num.size()-1;i>=0;i--) {\\n                if(num[i]!=\\'0\\') {\\n                    k = i;\\n                    break;\\n                }\\n        }\\n        ans = num.substr(0,k+1);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4066840,
                "title": "one-line-replace-js-solution",
                "content": "\\n# Code\\n```\\n/**\\n * @param {string} num\\n * @return {string}\\n */\\nvar removeTrailingZeros = function(num) {\\n    return num.replace(/0+$/, \\'\\')\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string} num\\n * @return {string}\\n */\\nvar removeTrailingZeros = function(num) {\\n    return num.replace(/0+$/, \\'\\')\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4066131,
                "title": "3-liner-just-skip-last-consecutive-0s",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n\\n- Space complexity: $$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string removeTrailingZeros(string num) {\\n        int i = num.length()-1;\\n        while(i >= 0 && num[i] == \\'0\\') //skip all consecutive 0s from the last\\n         i--;\\n        return num.substr(0,i+1);\\n    } //return string start from \\'0\\' index anh having \\'i+1\\' length\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string removeTrailingZeros(string num) {\\n        int i = num.length()-1;\\n        while(i >= 0 && num[i] == \\'0\\') //skip all consecutive 0s from the last\\n         i--;\\n        return num.substr(0,i+1);\\n    } //return string start from \\'0\\' index anh having \\'i+1\\' length\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4065372,
                "title": "java-easiest-solution-beats-100-of-users-simple-while-loop",
                "content": "# Intuition\\nCheck zeroes from last of string\\n\\n# Approach\\nuse while loop as far as you encounter zeroes ; maintain an index variable initialized from last index of string ; after that , stop ; return the substring from starting upto that particular index ; and that\\'s it...!\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public String removeTrailingZeros(String num) {\\n        int i = num.length()-1;\\n        while(num.charAt(i) == \\'0\\') {\\n            i--;\\n        }\\n        return num.substring(0 , i+1);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String removeTrailingZeros(String num) {\\n        int i = num.length()-1;\\n        while(num.charAt(i) == \\'0\\') {\\n            i--;\\n        }\\n        return num.substring(0 , i+1);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4065106,
                "title": "simple-c-solution",
                "content": "\\n\\n# Code\\n```\\npublic class Solution {\\n    public string RemoveTrailingZeros(string num) {\\n        for(int i = num.Length - 1; i>=0; i--)\\n        {\\n            if (num[i] != \\'0\\') return num;\\n            else num = num.Remove(num.Length - 1);\\n        }\\n        return num;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public string RemoveTrailingZeros(string num) {\\n        for(int i = num.Length - 1; i>=0; i--)\\n        {\\n            if (num[i] != \\'0\\') return num;\\n            else num = num.Remove(num.Length - 1);\\n        }\\n        return num;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4064515,
                "title": "python-slicing-approach-beats-92-15ms-13mb",
                "content": "# Code\\n```\\nclass Solution(object):\\n    def removeTrailingZeros(self, num):\\n        cursor = -1\\n        while True:\\n            if num[cursor] == \"0\":\\n                cursor -= 1\\n            else:\\n                break\\n\\n        return num[0:(cursor + 1)] if cursor != -1 else num[0:]\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def removeTrailingZeros(self, num):\\n        cursor = -1\\n        while True:\\n            if num[cursor] == \"0\":\\n                cursor -= 1\\n            else:\\n                break\\n\\n        return num[0:(cursor + 1)] if cursor != -1 else num[0:]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4063814,
                "title": "simple-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nusing reverse loop to detedct if there is any number other than 0 that means tailing zero are ending here, so we will just slice the string from there\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {string} num\\n * @return {string}\\n */\\nvar removeTrailingZeros = function(num) {\\n    let newS = \\'\\'\\n    for(let i = num.length -1; i=>0; i--){\\n        if(num[i]!==\\'0\\'){\\n            return num.slice(0,i+1)\\n        }\\n    }\\n    \\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string} num\\n * @return {string}\\n */\\nvar removeTrailingZeros = function(num) {\\n    let newS = \\'\\'\\n    for(let i = num.length -1; i=>0; i--){\\n        if(num[i]!==\\'0\\'){\\n            return num.slice(0,i+1)\\n        }\\n    }\\n    \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4062184,
                "title": "beat-88-and-easy-for-beginners",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def removeTrailingZeros(self, num: str) -> str:\\n        pos=0\\n        for i in range(len(num)-1,-1,-1):\\n            if num[i]!=\\'0\\':\\n                pos=i\\n                break\\n        return num[:pos+1]\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def removeTrailingZeros(self, num: str) -> str:\\n        pos=0\\n        for i in range(len(num)-1,-1,-1):\\n            if num[i]!=\\'0\\':\\n                pos=i\\n                break\\n        return num[:pos+1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4061476,
                "title": "java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public String removeTrailingZeros(String num) {\\n        int i = 0;\\n        int j = num.length() - 1;\\n        while (i < num.length() && num.charAt(i) == \\'0\\') {\\n            i++;\\n        }\\n        while (j >= 0 && num.charAt(j) == \\'0\\') {\\n            j--;\\n        }\\n        return num.substring(0, j + 1);\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String removeTrailingZeros(String num) {\\n        int i = 0;\\n        int j = num.length() - 1;\\n        while (i < num.length() && num.charAt(i) == \\'0\\') {\\n            i++;\\n        }\\n        while (j >= 0 && num.charAt(j) == \\'0\\') {\\n            j--;\\n        }\\n        return num.substring(0, j + 1);\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4052010,
                "title": "python3-one-liner-rstrip",
                "content": "# Intuition/Approach\\n- Right Strip (Remove All Trailing Zeros/Zeros at the End) the *num* String.\\n- Python Already Has the Built-in Function *rstrip()*.\\n\\n# Complexity\\n- Time Complexity: $$O(k)$$ where *k = number of 0\\'s at the end of num*.\\n    - Absolute Worst Case Would be $$O(n)$$ where *n = the len(num)* if *num* only contained *0\\'s*.\\n- Space Complexity: $$O(n)$$\\n\\n# Code\\n```\\nclass Solution:\\n    def removeTrailingZeros(self, num: str) -> str:\\n        return num.rstrip(\\'0\\')\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def removeTrailingZeros(self, num: str) -> str:\\n        return num.rstrip(\\'0\\')\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 4051789,
                "title": "python-easy-to-understand-beginner-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def removeTrailingZeros(self, num: str) -> str:\\n        numlen=len(num)-1\\n        i =numlen\\n        count=0\\n        while i >= 0:\\n            if int(num[i]) < 1:\\n                count +=1\\n            else:\\n                break\\n            i -=1\\n        return num[0:len(num)-count]\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def removeTrailingZeros(self, num: str) -> str:\\n        numlen=len(num)-1\\n        i =numlen\\n        count=0\\n        while i >= 0:\\n            if int(num[i]) < 1:\\n                count +=1\\n            else:\\n                break\\n            i -=1\\n        return num[0:len(num)-count]\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 4050827,
                "title": "beats-100-00-of-users-with-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public String removeTrailingZeros(String num) {\\n        \\n        int i=num.length()-1;\\n        while(num.charAt(i)==\\'0\\'){\\n            i--;\\n        }\\n\\n        return num.substring(0,i+1);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String removeTrailingZeros(String num) {\\n        \\n        int i=num.length()-1;\\n        while(num.charAt(i)==\\'0\\'){\\n            i--;\\n        }\\n\\n        return num.substring(0,i+1);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4050492,
                "title": "easy-solution-beginner-friendly",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nwe need to only trailing zeros  simply we think about that we have to loop over string until we find character other then zero .\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n    1. start loop from string length to 0 \\n    2. check if the ith character is zero then remove it \\n    3. remove character by using substring method \\n    4. num will re assign with num.substring(0,i) which exclude last character automaticaly \\n    5.  if not the case return num\\n    6. edge case if all the character of string is zero the  we return empty string .\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public String removeTrailingZeros(String num) {\\n        \\n        for(int i=num.length()-1;i>=0;i--){\\n            if(num.charAt(i)==\\'0\\'){\\n                num=num.substring(0,i);\\n            }else return num;\\n        }\\n        return \"\";\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String removeTrailingZeros(String num) {\\n        \\n        for(int i=num.length()-1;i>=0;i--){\\n            if(num.charAt(i)==\\'0\\'){\\n                num=num.substring(0,i);\\n            }else return num;\\n        }\\n        return \"\";\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4048584,
                "title": "java-1-ms-solution-beats-100-of-users",
                "content": "\\n# Complexity\\n\\n<!-- Add your time complexity here, e.g. $$O(n)$$ --> \\n## Time complexity:  1 ms\\n\\n\\n# Code\\n```\\nclass Solution {\\n    public String removeTrailingZeros(String num) {\\n        int length = num.length();\\n        if (length == 1 && num.charAt(0) == \\'0\\') {\\n            return \"0\";\\n        }\\n        int endIndex = length - 1;\\n        while (endIndex >= 0 && num.charAt(endIndex) == \\'0\\') {\\n            endIndex--;\\n        }\\n        if (endIndex == -1) {\\n            return \"0\";\\n        }\\n        return num.substring(0, endIndex + 1);\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String removeTrailingZeros(String num) {\\n        int length = num.length();\\n        if (length == 1 && num.charAt(0) == \\'0\\') {\\n            return \"0\";\\n        }\\n        int endIndex = length - 1;\\n        while (endIndex >= 0 && num.charAt(endIndex) == \\'0\\') {\\n            endIndex--;\\n        }\\n        if (endIndex == -1) {\\n            return \"0\";\\n        }\\n        return num.substring(0, endIndex + 1);\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4046635,
                "title": "js",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {string} num\\n * @return {string}\\n */\\nvar removeTrailingZeros = function(num) {\\n  let result = \"\"\\n  for (i = num.length - 1; i >= 0; i--) {\\n    if (num[i] !== \"0\" || result.length > 0) {\\n      result = num[i] + result\\n    }\\n  }\\n  return result\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string} num\\n * @return {string}\\n */\\nvar removeTrailingZeros = function(num) {\\n  let result = \"\"\\n  for (i = num.length - 1; i >= 0; i--) {\\n    if (num[i] !== \"0\" || result.length > 0) {\\n      result = num[i] + result\\n    }\\n  }\\n  return result\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4045077,
                "title": "const-js-ts-great-explanation",
                "content": "**CODE**\\n```typescript\\nfunction removeTrailingZeros(num: string): string {\\n    let index = -1;\\n    for (let i = num.length - 1; i >= 0; --i) {\\n        debugger;\\n        if (num[i] !== \\'0\\') {\\n            index = i;\\n            break;\\n        }\\n    }\\n    return num.slice(0, index + 1);\\n}\\n```\\n\\nExplanation:\\n\\n1. The function `removeTrailingZeros` takes a string `num` as input and aims to remove trailing zeros from it.\\n\\n2. It initializes an `index` variable to -1. This variable will be used to keep track of the position of the last non-zero digit in the input string.\\n\\n3. The function enters a loop that iterates through the characters of the input string `num` from right to left using the variable `i`.\\n\\n4. Within the loop, it uses the `debugger` statement to pause execution for debugging purposes.\\n\\n5. It checks if the current character `num[i]` is not equal to \\'0\\'. If it\\'s not \\'0\\', it updates the `index` variable with the current position `i` and breaks out of the loop. This effectively finds the rightmost non-zero digit in the string.\\n\\n6. Finally, it uses the `index` to slice the original string from the beginning to the `index` position (inclusive) using `num.slice(0, index + 1)` and returns the resulting string.\\n\\nTime Complexity:\\n- The loop iterates through the input string from right to left once. In the worst case, it iterates through the entire string. Therefore, the time complexity of this function is O(n), where n is the length of the input string.\\n\\nSpace Complexity:\\n- The function only uses a few integer variables (`index`, `i`) and does not create any data structures that depend on the input size. It returns a new string, but the space used for this new string is proportional to the length of the output, so the space complexity is O(n), where n is the length of the output string.\\n\\nHere\\'s a diagram to illustrate the function\\'s behavior:\\n```\\nInput: \"120500\"\\n                   ^ (Last non-zero digit at index 3)\\nOutput: \"1205\"\\n```\\n\\nIn this example, the function removes the trailing zeros and returns the modified string \"1205.\"",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "```typescript\\nfunction removeTrailingZeros(num: string): string {\\n    let index = -1;\\n    for (let i = num.length - 1; i >= 0; --i) {\\n        debugger;\\n        if (num[i] !== \\'0\\') {\\n            index = i;\\n            break;\\n        }\\n    }\\n    return num.slice(0, index + 1);\\n}\\n```\n```\\nInput: \"120500\"\\n                   ^ (Last non-zero digit at index 3)\\nOutput: \"1205\"\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4044133,
                "title": "easy-approach-using-java-beats-100-1-ms-runtime",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nTo count the tailing zeroes \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n   To count the tailing zeroes and return the substring by removing the zeros count from the length of the string \\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public String removeTrailingZeros(String num) {\\n      int len = num.length()-1;int c=0;\\n      while(true)\\n      {\\n          if(num.charAt(len)==\\'0\\')\\n          {\\n                c++;\\n          }\\n          else\\n          {\\n              break;\\n          }\\n          len = len-1;\\n      }\\n      return num.substring(0,num.length()-c);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String removeTrailingZeros(String num) {\\n      int len = num.length()-1;int c=0;\\n      while(true)\\n      {\\n          if(num.charAt(len)==\\'0\\')\\n          {\\n                c++;\\n          }\\n          else\\n          {\\n              break;\\n          }\\n          len = len-1;\\n      }\\n      return num.substring(0,num.length()-c);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4043661,
                "title": "c-clean-code-fully-explained-solution",
                "content": "In this problem , we have a positive integer , note that the parameter is given in the form of a string. We need to remove trailing zeros , i.e the 0\\'s from the end. Note that in the constraints section we are guarenteed that the number >= 1 , so we don\\'t consider the case of 0 , and also it does not contain any leading zeros.\\n\\nSo we can just check the current last digit of the number and if it is zero remove it.\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string removeTrailingZeros(string num) {\\n        while(num.back() == \\'0\\') num.pop_back();\\n        return num;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string removeTrailingZeros(string num) {\\n        while(num.back() == \\'0\\') num.pop_back();\\n        return num;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4042198,
                "title": "c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string removeTrailingZeros(string num) {\\n        int i=num.size()-1;\\n            while(num[i]==\\'0\\')\\n                i--;\\n                return num.substr(0,i+1);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string removeTrailingZeros(string num) {\\n        int i=num.size()-1;\\n            while(num[i]==\\'0\\')\\n                i--;\\n                return num.substr(0,i+1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4041467,
                "title": "easy-understandable-java-solution-using-flag",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public String removeTrailingZeros(String num) {\\n\\n        if(num.equals(\"0\") || num.charAt(num.length()-1) != \\'0\\')\\n            return num;\\n\\n        boolean firstTrailingZero = false;\\n        int endIndex = 0;\\n\\n        for(int i=num.length()-1; i>=0; i--) {\\n            if(firstTrailingZero==false && num.charAt(i) == \\'0\\') {\\n                firstTrailingZero = true;\\n                continue;\\n            } if(firstTrailingZero==true && num.charAt(i) == \\'0\\') {\\n                continue;\\n            } if(firstTrailingZero==true && num.charAt(i) != \\'0\\') {\\n                endIndex = i;\\n                break;\\n            }\\n        } return num.substring(0, endIndex+1);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String removeTrailingZeros(String num) {\\n\\n        if(num.equals(\"0\") || num.charAt(num.length()-1) != \\'0\\')\\n            return num;\\n\\n        boolean firstTrailingZero = false;\\n        int endIndex = 0;\\n\\n        for(int i=num.length()-1; i>=0; i--) {\\n            if(firstTrailingZero==false && num.charAt(i) == \\'0\\') {\\n                firstTrailingZero = true;\\n                continue;\\n            } if(firstTrailingZero==true && num.charAt(i) == \\'0\\') {\\n                continue;\\n            } if(firstTrailingZero==true && num.charAt(i) != \\'0\\') {\\n                endIndex = i;\\n                break;\\n            }\\n        } return num.substring(0, endIndex+1);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4040422,
                "title": "java-easy-fast-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public String removeTrailingZeros(String num) {\\n\\n        int count = 0;\\n        for (int i = num.length() - 1; i > 0; i--)\\n            if (num.charAt(i) == \\'0\\') count++;\\n            else break;\\n\\n        return num.substring(0, num.length() - count);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String removeTrailingZeros(String num) {\\n\\n        int count = 0;\\n        for (int i = num.length() - 1; i > 0; i--)\\n            if (num.charAt(i) == \\'0\\') count++;\\n            else break;\\n\\n        return num.substring(0, num.length() - count);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4036351,
                "title": "beats-easy-beginner-friendly-solution-simple-and-easy-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public String removeTrailingZeros(String num) {\\n        for(int i=num.length()-1;i>=0;i--){\\n            if(num.charAt(i)!=\\'0\\'){\\n                return num.substring(0,i+1);\\n            }\\n        }\\n        return \"\";\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String removeTrailingZeros(String num) {\\n        for(int i=num.length()-1;i>=0;i--){\\n            if(num.charAt(i)!=\\'0\\'){\\n                return num.substring(0,i+1);\\n            }\\n        }\\n        return \"\";\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4035496,
                "title": "easy-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public String removeTrailingZeros(String num) {\\n         \\n       int i=num.length()-1; \\n       while(i>=0 && num.charAt(i)==\\'0\\')\\n       {\\n            i--;\\n       }\\n        return num.substring(0,i+1);\\n    }\\n        \\n }\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String removeTrailingZeros(String num) {\\n         \\n       int i=num.length()-1; \\n       while(i>=0 && num.charAt(i)==\\'0\\')\\n       {\\n            i--;\\n       }\\n        return num.substring(0,i+1);\\n    }\\n        \\n }\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4032517,
                "title": "beginners-friendly-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public String removeTrailingZeros(String num) {\\n        String res =num;\\n\\t        for(int i = num.length()-1 ; i>=0 ; i--) {\\n\\t        \\tif(num.charAt(i)!=\\'0\\') {\\n\\t        \\t\\tres = num.substring(0, i+1);\\n\\t        \\t\\tbreak;\\n\\t        \\t}\\n\\t        }\\n\\t        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String removeTrailingZeros(String num) {\\n        String res =num;\\n\\t        for(int i = num.length()-1 ; i>=0 ; i--) {\\n\\t        \\tif(num.charAt(i)!=\\'0\\') {\\n\\t        \\t\\tres = num.substring(0, i+1);\\n\\t        \\t\\tbreak;\\n\\t        \\t}\\n\\t        }\\n\\t        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4027541,
                "title": "simple-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe goal of this code is to remove trailing zeros from a given string representation of a number. Trailing zeros are zeros that appear at the end of the number and do not affect its value. The code aims to trim these trailing zeros while preserving the rest of the number\\'s digits.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Initialize a variable n to store the length of the input string num.\\n\\n2. Start a loop from the end of the string (rightmost character) and iterate towards the beginning.\\n\\n3. Within the loop, check each character from right to left. If the character is not \\'0\\', it means we have reached a non-zero digit that is not part of the trailing zeros.\\n\\n4. When a non-zero digit is encountered, update the value of n to the index of this digit plus one (i.e., n = i + 1) to indicate the new length of the string after removing trailing zeros. Break out of the loop since there is no need to continue checking the remaining characters.\\n\\n5. Finally, return a substring of the input string num from index 0 to n. This substring contains the original number without trailing zeros.\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public String removeTrailingZeros(String num) {\\n        int n = num.length();\\n\\n        for (int i = n - 1; i >= 0; i--){\\n            if (num.charAt(i) != \\'0\\'){\\n                n = i + 1;\\n                break;\\n            }\\n        }        \\n\\n        return num.substring(0, n);\\n    }\\n}\\n\\n```\\n![Frame 76.png](https://assets.leetcode.com/users/images/71a1b987-2ac3-4610-82ee-d6dddd301d6e_1694360602.6338625.png)\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String removeTrailingZeros(String num) {\\n        int n = num.length();\\n\\n        for (int i = n - 1; i >= 0; i--){\\n            if (num.charAt(i) != \\'0\\'){\\n                n = i + 1;\\n                break;\\n            }\\n        }        \\n\\n        return num.substring(0, n);\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4024104,
                "title": "easy-and-clean-solution-swift",
                "content": "# Code\\n```\\nclass Solution {\\n    func removeTrailingZeros(_ num: String) -> String {\\n    var res = num\\n    while res.last == \"0\" {\\n        res.removeLast()\\n    }\\n    return res\\n}\\n}\\n```",
                "solutionTags": [
                    "Swift",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    func removeTrailingZeros(_ num: String) -> String {\\n    var res = num\\n    while res.last == \"0\" {\\n        res.removeLast()\\n    }\\n    return res\\n}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4024072,
                "title": "simple-java-solution-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public String removeTrailingZeros(String num) {\\n        StringBuilder sb = new StringBuilder();\\n        for(int i= num.length()-1; i>=0; i--){\\n            if(num.charAt(i) != \\'0\\'){\\n                sb.append(num.substring(0,i+1));\\n                break;\\n            }\\n        }\\n        return sb.toString();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String removeTrailingZeros(String num) {\\n        StringBuilder sb = new StringBuilder();\\n        for(int i= num.length()-1; i>=0; i--){\\n            if(num.charAt(i) != \\'0\\'){\\n                sb.append(num.substring(0,i+1));\\n                break;\\n            }\\n        }\\n        return sb.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4019875,
                "title": "5-steps-solution",
                "content": "# Intuition\\nConvert String to Array to use array methods\\n\\n---\\n\\n# Approach\\n1. Convert String to Array\\n2. Loop through array in reverse order \\n3. If you find a \"0\" then pop it\\n4. else break from the loop\\n5. Convert Array to string and return it\\n\\n---\\n\\n# Code\\n```\\n/**\\n * @param {string} num\\n * @return {string}\\n */\\nvar removeTrailingZeros = function(num) {\\n    <!-- 1. Convert String to Array -->\\n    let arr = num.split(\"\");\\n    <!-- 2. Loop through array in reverse order  -->\\n    for(let i=arr.length-1; i>=0; i--){\\n    <!-- 3. If you find a \"0\" then pop it -->\\n        if(arr[i]===\"0\"){\\n            arr.pop();\\n    <!-- 4. else break from the loop -->\\n        }else{\\n            break;\\n        }\\n    }\\n    <!-- 5. Convert Array to string and return it -->\\n    return arr.join(\"\");\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string} num\\n * @return {string}\\n */\\nvar removeTrailingZeros = function(num) {\\n    <!-- 1. Convert String to Array -->\\n    let arr = num.split(\"\");\\n    <!-- 2. Loop through array in reverse order  -->\\n    for(let i=arr.length-1; i>=0; i--){\\n    <!-- 3. If you find a \"0\" then pop it -->\\n        if(arr[i]===\"0\"){\\n            arr.pop();\\n    <!-- 4. else break from the loop -->\\n        }else{\\n            break;\\n        }\\n    }\\n    <!-- 5. Convert Array to string and return it -->\\n    return arr.join(\"\");\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4019431,
                "title": "one-liner-ts-js-solution",
                "content": "```ts\\nfunction removeTrailingZeros(num: string): string {\\n    return num.replace(/^0+|0+$/g, \\'\\');\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "```ts\\nfunction removeTrailingZeros(num: string): string {\\n    return num.replace(/^0+|0+$/g, \\'\\');\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4011125,
                "title": "java-solution-100-faster",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public String removeTrailingZeros(String num) {\\n\\n        int i = num.length() - 1;\\n        \\n        for( ; i >= 0; i--) {\\n            if(num.charAt(i) != \\'0\\') break;\\n        }\\n\\n        return num.substring(0, i + 1);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String removeTrailingZeros(String num) {\\n\\n        int i = num.length() - 1;\\n        \\n        for( ; i >= 0; i--) {\\n            if(num.charAt(i) != \\'0\\') break;\\n        }\\n\\n        return num.substring(0, i + 1);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4011089,
                "title": "c-easy-solution",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string removeTrailingZeros(string num) {\\n        string ansString=\"\";\\n        int lastIndex;\\n        int i;\\n        for(i=num.length()-1;i>0;i--){\\n            if(num[i]!=\\'0\\'){\\n                lastIndex=i;\\n                break;\\n            }\\n        }\\n        for(int j=0;j<=lastIndex;j++){\\n            ansString += num[j];\\n        }\\n        //.substr can be used instead of mainitaing last index and running for loop\\n        //ansString = num.substr(0, i+1);\\n\\n        return ansString;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string removeTrailingZeros(string num) {\\n        string ansString=\"\";\\n        int lastIndex;\\n        int i;\\n        for(i=num.length()-1;i>0;i--){\\n            if(num[i]!=\\'0\\'){\\n                lastIndex=i;\\n                break;\\n            }\\n        }\\n        for(int j=0;j<=lastIndex;j++){\\n            ansString += num[j];\\n        }\\n        //.substr can be used instead of mainitaing last index and running for loop\\n        //ansString = num.substr(0, i+1);\\n\\n        return ansString;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4009534,
                "title": "java-one-line-regular-expression",
                "content": "# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public String removeTrailingZeros(String num) {\\n        return num.replaceAll(\"0+$\", \"\");\\n    }\\n}\\n```\\n\\n**0** :  This matches the \"0\" character only.\\n**+**:  The \"+\" sign means to match the character \"0\" one or more times.\\n**\\\\$**:  The \\\\$ sign indicates that the match must be at the end of the string.\\n\\n***So, \"0+$\" is a regex expression that only matches \"0\" characters at the end of a string.***\\n\\n```\\nbool shouldYouUpvote(){ return (I helped == true) ? upvote : nothing; }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String removeTrailingZeros(String num) {\\n        return num.replaceAll(\"0+$\", \"\");\\n    }\\n}\\n```\n```\\nbool shouldYouUpvote(){ return (I helped == true) ? upvote : nothing; }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4006454,
                "title": "java-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nJava Easy Solution\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public String removeTrailingZeros(String num) {\\n\\n        int zeroCount =0;\\n\\t\\tfor(int i = num.length()-1;i>=0;i--)\\n\\t\\t{\\n\\t\\t\\tif(num.charAt(i) != \\'0\\') \\n\\t\\t\\t{\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}else\\n\\t\\t\\t{\\n\\t\\t\\t\\tzeroCount ++;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\t\\n\\n\\t    String str = num.substring(0, num.length()-zeroCount);\\n        return str; \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String removeTrailingZeros(String num) {\\n\\n        int zeroCount =0;\\n\\t\\tfor(int i = num.length()-1;i>=0;i--)\\n\\t\\t{\\n\\t\\t\\tif(num.charAt(i) != \\'0\\') \\n\\t\\t\\t{\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}else\\n\\t\\t\\t{\\n\\t\\t\\t\\tzeroCount ++;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\t\\n\\n\\t    String str = num.substring(0, num.length()-zeroCount);\\n        return str; \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4005178,
                "title": "removing-trailing-zeroes-from-a-string",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public String removeTrailingZeros(String num) {\\n       StringBuilder sb = new StringBuilder();\\n       int i=0;\\n       for( i=num.length()-1;i>=0;i--){\\n           \\n           if(num.charAt(i) != \\'0\\'){\\n               break;\\n           }\\n           \\n       }\\n       \\n\\n       return num.substring(0,i+1);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String removeTrailingZeros(String num) {\\n       StringBuilder sb = new StringBuilder();\\n       int i=0;\\n       for( i=num.length()-1;i>=0;i--){\\n           \\n           if(num.charAt(i) != \\'0\\'){\\n               break;\\n           }\\n           \\n       }\\n       \\n\\n       return num.substring(0,i+1);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4001756,
                "title": "1ms-beats-100-00-3-lines-code-substring",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public String removeTrailingZeros(String num) {\\n        int endIndex = num.length() - 1;\\n        while (endIndex >= 0 && num.charAt(endIndex) == \\'0\\') {\\n            endIndex--;\\n        }\\n        return num.substring(0, endIndex + 1);\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String removeTrailingZeros(String num) {\\n        int endIndex = num.length() - 1;\\n        while (endIndex >= 0 && num.charAt(endIndex) == \\'0\\') {\\n            endIndex--;\\n        }\\n        return num.substring(0, endIndex + 1);\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3999881,
                "title": "using-for-loop",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public String removeTrailingZeros(String num) {\\n        for(int i=num.length()-1;i>=0;i--){\\n           \\n                if(num.charAt(i)!=\\'0\\'){\\n                  return num.substring(0,i+1);}\\n        }\\n       return \"\";\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String removeTrailingZeros(String num) {\\n        for(int i=num.length()-1;i>=0;i--){\\n           \\n                if(num.charAt(i)!=\\'0\\'){\\n                  return num.substring(0,i+1);}\\n        }\\n       return \"\";\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3995823,
                "title": "simple-java-solution-beats-100",
                "content": "# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public String removeTrailingZeros(String num) {\\n\\n        for(int i = num.length() - 1; i>=0; i--){\\n            if(num.charAt(i)!=\\'0\\'){\\n                return num.substring(0,i+1);\\n            }\\n        }\\n\\n        return num;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String removeTrailingZeros(String num) {\\n\\n        for(int i = num.length() - 1; i>=0; i--){\\n            if(num.charAt(i)!=\\'0\\'){\\n                return num.substring(0,i+1);\\n            }\\n        }\\n\\n        return num;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3995194,
                "title": "typescript-javascript-two-simple-solutions-regexp-and-loop",
                "content": "# Code\\n```\\nfunction removeTrailingZeros(num: string): string {\\n    return num.replace(/0+$/, \\'\\');\\n};\\n\\n```\\n\\n```\\nfunction removeTrailingZeros(num: string): string {\\n    for (let i = num.length - 1; i >= 0; i--) {\\n        if (num[i] !== \\'0\\') {\\n            return num.slice(0, i + 1)\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "```\\nfunction removeTrailingZeros(num: string): string {\\n    return num.replace(/0+$/, \\'\\');\\n};\\n\\n```\n```\\nfunction removeTrailingZeros(num: string): string {\\n    for (let i = num.length - 1; i >= 0; i--) {\\n        if (num[i] !== \\'0\\') {\\n            return num.slice(0, i + 1)\\n        }\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3990030,
                "title": "easiest-solution-java-one-line-code-direct-approch",
                "content": "\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\ncheck from last of string if last element =0;\\nreturn that substring else continue\\n\\n# Complexity\\n- Time complexity:O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1);\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public String removeTrailingZeros(String num) {\\n        for(int i=0;i<num.length();i++){\\n            if(num.charAt(num.length()-i-1)!=\\'0\\'){\\n                return num.substring(0,num.length()-i);\\n            }\\n        } return num;\\n        \\n\\n        \\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public String removeTrailingZeros(String num) {\\n        for(int i=0;i<num.length();i++){\\n            if(num.charAt(num.length()-i-1)!=\\'0\\'){\\n                return num.substring(0,num.length()-i);\\n            }\\n        } return num;\\n        \\n\\n        \\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3983815,
                "title": "100-efficient-java-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public String removeTrailingZeros(String num) {\\n        int c=num.length();\\n        int n=0;\\n        int t=0;\\n        String s=\"\";\\n    for(int i= num.length();i>=0;i--)\\n    {\\n        if(num.charAt(i-1)==\\'0\\')\\n        {\\n            n++;  \\n        }\\n        else\\n        {\\n            break;\\n        }\\n    }\\n        t=c-n;\\n        \\n       \\n      return num.substring(0,t);\\n    }\\n        \\n    \\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String removeTrailingZeros(String num) {\\n        int c=num.length();\\n        int n=0;\\n        int t=0;\\n        String s=\"\";\\n    for(int i= num.length();i>=0;i--)\\n    {\\n        if(num.charAt(i-1)==\\'0\\')\\n        {\\n            n++;  \\n        }\\n        else\\n        {\\n            break;\\n        }\\n    }\\n        t=c-n;\\n        \\n       \\n      return num.substring(0,t);\\n    }\\n        \\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3983635,
                "title": "java-easy-and-optimised-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public String removeTrailingZeros(String num) {\\n        String s=\"\";\\n     \\n        char a=\\'0\\';\\n        for(int i=num.length()-1;i>=0;i--){\\n            char b=num.charAt(i);\\n            if(a!=b){\\n                s=num.substring(0,i+1);\\n                break;\\n            }\\n        }\\n        return s;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String removeTrailingZeros(String num) {\\n        String s=\"\";\\n     \\n        char a=\\'0\\';\\n        for(int i=num.length()-1;i>=0;i--){\\n            char b=num.charAt(i);\\n            if(a!=b){\\n                s=num.substring(0,i+1);\\n                break;\\n            }\\n        }\\n        return s;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3982900,
                "title": "java-easy-one-line",
                "content": "\\tclass Solution {\\n\\t\\tpublic String removeTrailingZeros(String num) {\\n\\t\\t\\tint i = num.length()-1; \\n\\t\\t\\t// check index out of bound and match the character\\n\\t\\t\\twhile(i>=0 && num.charAt(i) == \\'0\\')i--;\\n\\t\\t\\treturn num.substring(0, i+1);\\n\\t\\t}\\n\\t}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n\\t\\tpublic String removeTrailingZeros(String num) {\\n\\t\\t\\tint i = num.length()-1; \\n\\t\\t\\t// check index out of bound and match the character\\n\\t\\t\\twhile(i>=0 && num.charAt(i) == \\'0\\')i--;\\n\\t\\t\\treturn num.substring(0, i+1);\\n\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 3981344,
                "title": "easy-java-solution",
                "content": "****Bold****# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\no(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public String removeTrailingZeros(String num) {\\n        int i=num.length()-1;\\n        String res=num;\\n        while(i>=0 && num.charAt(i)==\\'0\\'){\\n            res=num.substring(0,i);\\n            i--;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String removeTrailingZeros(String num) {\\n        int i=num.length()-1;\\n        String res=num;\\n        while(i>=0 && num.charAt(i)==\\'0\\'){\\n            res=num.substring(0,i);\\n            i--;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3972219,
                "title": "java-intuitive-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public String removeTrailingZeros(String num) {\\n        int endIndex = num.length();\\n        for (int i = num.length() - 1; i >= 0; i--) {\\n            if (num.charAt(i) == \\'0\\') {\\n                endIndex = i;\\n            } else break;\\n        }\\n        return num.substring(0, endIndex);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String removeTrailingZeros(String num) {\\n        int endIndex = num.length();\\n        for (int i = num.length() - 1; i >= 0; i--) {\\n            if (num.charAt(i) == \\'0\\') {\\n                endIndex = i;\\n            } else break;\\n        }\\n        return num.substring(0, endIndex);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3972180,
                "title": "easy-cpp-solution-beginner-friendly",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string removeTrailingZeros(string num) {\\n        while(num.size() > 0 && num.back() == \\'0\\'){\\n            num.pop_back();\\n        }\\n        return num;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string removeTrailingZeros(string num) {\\n        while(num.size() > 0 && num.back() == \\'0\\'){\\n            num.pop_back();\\n        }\\n        return num;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3971465,
                "title": "simple-c-code",
                "content": "# Code\\n```\\nchar * removeTrailingZeros(char * num){\\n    int end = strlen(num) - 1;\\n    while(end >= 0 )\\n    {\\n        if(num[end] != \\'0\\')\\n            break;\\n        end--;\\n    }\\n    num[end+1] = \\'\\\\0\\';\\n    return num;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nchar * removeTrailingZeros(char * num){\\n    int end = strlen(num) - 1;\\n    while(end >= 0 )\\n    {\\n        if(num[end] != \\'0\\')\\n            break;\\n        end--;\\n    }\\n    num[end+1] = \\'\\\\0\\';\\n    return num;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3970674,
                "title": "best-sollution-in-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public String removeTrailingZeros(String num) {\\n        ArrayList<Character> list = new ArrayList<>();\\n        char ch[] = num.toCharArray();\\n        for(char c:ch){\\n            list.add(c);\\n        }\\n\\n        for(int i=list.size()-1;i>=0;i--){\\n            if(list.get(i)==\\'0\\'){\\n                list.remove(i);\\n            }\\n            else{\\n                break;\\n            }\\n        }\\n        String s = \"\";\\n        for(char c:list){\\n            System.out.print(c+\" \");\\n            s = s + c;\\n        }\\n        return s;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String removeTrailingZeros(String num) {\\n        ArrayList<Character> list = new ArrayList<>();\\n        char ch[] = num.toCharArray();\\n        for(char c:ch){\\n            list.add(c);\\n        }\\n\\n        for(int i=list.size()-1;i>=0;i--){\\n            if(list.get(i)==\\'0\\'){\\n                list.remove(i);\\n            }\\n            else{\\n                break;\\n            }\\n        }\\n        String s = \"\";\\n        for(char c:list){\\n            System.out.print(c+\" \");\\n            s = s + c;\\n        }\\n        return s;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3963036,
                "title": "easy-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nimport java.math.BigInteger;\\nclass Solution {\\n    public String removeTrailingZeros(String num) {\\n        int l = num.length();\\n        int count = 0;\\n       for(int i=l-1; i>=0; i--)\\n       {\\n           count = i+1;\\n           if(num.charAt(i)!=\\'0\\')\\n                 break;\\n       }\\n       return num.substring(0,count);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nimport java.math.BigInteger;\\nclass Solution {\\n    public String removeTrailingZeros(String num) {\\n        int l = num.length();\\n        int count = 0;\\n       for(int i=l-1; i>=0; i--)\\n       {\\n           count = i+1;\\n           if(num.charAt(i)!=\\'0\\')\\n                 break;\\n       }\\n       return num.substring(0,count);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3962841,
                "title": "java-faster-o-n-solution-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nFirst Thought of solving this problem is to start from LHS of String but that will create difficulty to find index from where trailing zeros has started. \\n\\nSo, Starting from RHS will make task easier. \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n Start checking for character other than 0 from the right hand side of the String.\\nIf character other  than 0 is found take substring from 0 to that index+1 and break the loop.\\n\\nAt last return the String.\\n   \\n\\n\\n# Complexity\\n- Time complexity:\\n O(n)\\n\\n- Space complexity:\\n O(1)\\n\\n\\n# Code\\n```\\nclass Solution {\\n    public String removeTrailingZeros(String num) {\\n\\n       for(int i=num.length()-1;i>=0;i--)\\n       {\\n         if(num.charAt(i)!=\\'0\\')\\n         {\\n             num=num.substring(0,i+1);\\n             break;\\n         }\\n       } \\n       return num;\\n    }\\n}\\n```\\n\\n\\n\\n\\n![7abc56.jpg](https://assets.leetcode.com/users/images/4dce6875-509b-4802-b150-1203a1ab14e1_1693052737.0256257.jpeg)\\n\\n\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String removeTrailingZeros(String num) {\\n\\n       for(int i=num.length()-1;i>=0;i--)\\n       {\\n         if(num.charAt(i)!=\\'0\\')\\n         {\\n             num=num.substring(0,i+1);\\n             break;\\n         }\\n       } \\n       return num;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3952443,
                "title": "simple-java-solution-faster-than-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public String removeTrailingZeros(String num) {\\n        int count=0;\\n        for(int i=num.length()-1;i>=0;i--){\\n            char ch=num.charAt(i);\\n            if(ch==\\'0\\'){\\n                count++;\\n            }else{\\n                break;\\n            }\\n        }\\n        return num.substring(0,num.length()-count);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String removeTrailingZeros(String num) {\\n        int count=0;\\n        for(int i=num.length()-1;i>=0;i--){\\n            char ch=num.charAt(i);\\n            if(ch==\\'0\\'){\\n                count++;\\n            }else{\\n                break;\\n            }\\n        }\\n        return num.substring(0,num.length()-count);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3950800,
                "title": "easy-c-approach-using-linear-search-beats-90",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string removeTrailingZeros(string s) {\\n     int idx=0;\\n    for(int i=0;i<s.size();i++)\\n    {\\n        if(s[i]!=\\'0\\')\\n        {\\n            idx=i;\\n        }\\n    }\\n    cout<<idx<<endl;\\n    string ans=\"\";\\n    for(int i=0;i<idx+1;i++)\\n    {\\n        ans+=s[i];\\n    }\\n    return ans;   \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string removeTrailingZeros(string s) {\\n     int idx=0;\\n    for(int i=0;i<s.size();i++)\\n    {\\n        if(s[i]!=\\'0\\')\\n        {\\n            idx=i;\\n        }\\n    }\\n    cout<<idx<<endl;\\n    string ans=\"\";\\n    for(int i=0;i<idx+1;i++)\\n    {\\n        ans+=s[i];\\n    }\\n    return ans;   \\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3949261,
                "title": "remove-trailing-zeros-from-a-string-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public String removeTrailingZeros(String num) {\\n        int lastIndex = num.length() - 1;\\n        while(lastIndex >= 0 && num.charAt(lastIndex) == \\'0\\')\\n        {\\n            lastIndex--;\\n        }\\n        return num.substring(0,lastIndex+1);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String removeTrailingZeros(String num) {\\n        int lastIndex = num.length() - 1;\\n        while(lastIndex >= 0 && num.charAt(lastIndex) == \\'0\\')\\n        {\\n            lastIndex--;\\n        }\\n        return num.substring(0,lastIndex+1);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3947631,
                "title": "simple-c-solution-beats-99",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string removeTrailingZeros(string num) {\\n        bool seen = false;\\n        int i = num.size() - 1;\\n      \\n        while(!seen){\\n          if(!seen && num[i] == \\'0\\'){\\n            i--;\\n          }\\n          else if(!seen && num[i] != \\'0\\'){\\n            seen = true;\\n          }\\n        }\\n\\n        return {num.begin(), num.begin() + (i + 1)};\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string removeTrailingZeros(string num) {\\n        bool seen = false;\\n        int i = num.size() - 1;\\n      \\n        while(!seen){\\n          if(!seen && num[i] == \\'0\\'){\\n            i--;\\n          }\\n          else if(!seen && num[i] != \\'0\\'){\\n            seen = true;\\n          }\\n        }\\n\\n        return {num.begin(), num.begin() + (i + 1)};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3946303,
                "title": "most-optimal-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\njust simple\\n# Complexity\\n- Time complexity:\\nO(n)\\n- Space complexity:\\nO(1)\\n# Code\\n```\\nclass Solution(object):\\n    def removeTrailingZeros(self, num):\\n        r = len(num)-1\\n        while num[r]==\"0\":\\n            r-=1\\n        return num[:r+1]\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Greedy"
                ],
                "code": "```\\nclass Solution(object):\\n    def removeTrailingZeros(self, num):\\n        r = len(num)-1\\n        while num[r]==\"0\":\\n            r-=1\\n        return num[:r+1]\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3943570,
                "title": "java-solution",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n\\n- Space complexity: $$O(n)$$\\n\\n# Code\\n```\\nclass Solution {\\n    public String removeTrailingZeros(String num) {\\n        for (int i = num.length() - 1; i >= 0; i--) {\\n            if (num.charAt(i) != \\'0\\') {\\n                return num.substring(0, i + 1);\\n            } \\n        }\\n\\n        return \"\";\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String removeTrailingZeros(String num) {\\n        for (int i = num.length() - 1; i >= 0; i--) {\\n            if (num.charAt(i) != \\'0\\') {\\n                return num.substring(0, i + 1);\\n            } \\n        }\\n\\n        return \"\";\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3942832,
                "title": "dart-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n  String removeTrailingZeros(String num) {\\n      var c = 0;\\n      for (int i = num.length - 1; i >= 0; i--) {\\n          if (num[i] == \"0\") {\\n              c += 1;\\n          } else {\\n              break;\\n          }\\n      }\\n\\n      return num.substring(0, num.length - c);\\n  }\\n}\\n```",
                "solutionTags": [
                    "Dart"
                ],
                "code": "```\\nclass Solution {\\n  String removeTrailingZeros(String num) {\\n      var c = 0;\\n      for (int i = num.length - 1; i >= 0; i--) {\\n          if (num[i] == \"0\") {\\n              c += 1;\\n          } else {\\n              break;\\n          }\\n      }\\n\\n      return num.substring(0, num.length - c);\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3942817,
                "title": "dart-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIf we reverse the string, any trailing zeroes would now be \"leading\"\\nFor example:\\n\"1230\" -> \"0321\"\\n\\nWe can parse this to a BigInt which will get rid of any \"leading\" zeroes and convert it back to a string\\n\\nBigInt.parse(\"0321\") -> 321 -> \"321\"\\n\\nAfterwards, we reverse the string again, getting the answer without the trailing zeroes\\n\\n\"321\" -> \"123\"\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n  String removeTrailingZeros(String num) {\\n      final r = num.split(\\'\\').reversed.join();\\n      final s = BigInt.parse(r).toString();\\n      return s.split(\\'\\').reversed.join();\\n  }\\n}\\n```",
                "solutionTags": [
                    "Dart"
                ],
                "code": "```\\nclass Solution {\\n  String removeTrailingZeros(String num) {\\n      final r = num.split(\\'\\').reversed.join();\\n      final s = BigInt.parse(r).toString();\\n      return s.split(\\'\\').reversed.join();\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3933742,
                "title": "easy-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public String removeTrailingZeros(String num) {\\n        int count=0;\\n        int n=num.length();\\n        for(int i=0;i<n;i++){\\n\\n            if(num.charAt(i)==\\'0\\'){\\n            count++;\\n            }else{\\n                count=0;\\n            }\\n\\n        }\\n       \\n\\n        return num.substring(0,n-count);\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String removeTrailingZeros(String num) {\\n        int count=0;\\n        int n=num.length();\\n        for(int i=0;i<n;i++){\\n\\n            if(num.charAt(i)==\\'0\\'){\\n            count++;\\n            }else{\\n                count=0;\\n            }\\n\\n        }\\n       \\n\\n        return num.substring(0,n-count);\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3930765,
                "title": "dart-regexp-solution",
                "content": "# Code\\n```\\nclass Solution {\\n  String removeTrailingZeros(String num) {\\n    final index = num.indexOf(RegExp(r\\'0+$\\'));\\n    if(index == -1) return num;\\n    return num.substring(0, index);\\n  }\\n}\\n```",
                "solutionTags": [
                    "Dart"
                ],
                "code": "```\\nclass Solution {\\n  String removeTrailingZeros(String num) {\\n    final index = num.indexOf(RegExp(r\\'0+$\\'));\\n    if(index == -1) return num;\\n    return num.substring(0, index);\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3928924,
                "title": "algorithmic-way-of-solving-it-in-python-3",
                "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def removeTrailingZeros(self, num: str) -> str:\\n        rev = num[::-1]\\n        count_zero = 0\\n        for i in range(len(rev)):\\n            if rev[i] in \\'123456789\\':\\n                break\\n            if rev[i] == \\'0\\':\\n                count_zero+=1\\n                continue\\n\\n        print(int(num))\\n        return str(int(num) // 10 ** count_zero)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def removeTrailingZeros(self, num: str) -> str:\\n        rev = num[::-1]\\n        count_zero = 0\\n        for i in range(len(rev)):\\n            if rev[i] in \\'123456789\\':\\n                break\\n            if rev[i] == \\'0\\':\\n                count_zero+=1\\n                continue\\n\\n        print(int(num))\\n        return str(int(num) // 10 ** count_zero)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3927825,
                "title": "hacky-one-liner-in-ruby",
                "content": "# Code\\n```\\n# @param {String} num\\n# @return {String}\\ndef remove_trailing_zeros(num)\\n  num.to_s.reverse.to_i.to_s.reverse\\nend\\n```",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```\\n# @param {String} num\\n# @return {String}\\ndef remove_trailing_zeros(num)\\n  num.to_s.reverse.to_i.to_s.reverse\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3924662,
                "title": "simple-elixir-solution",
                "content": "```\\ndefmodule Solution do\\n  @spec remove_trailing_zeros(num :: String.t()) :: String.t()\\n  def remove_trailing_zeros(num) do\\n    # step 1 - Convert string into an integer\\n    int_val = String.to_integer(num)\\n    lose_trailing_zeros(int_val)\\n  end\\n\\n  defp lose_trailing_zeros(n) when rem(n, 10) != 0 do\\n    Integer.to_string(n)\\n  end\\n\\n  defp lose_trailing_zeros(n) do\\n    lose_trailing_zeros(div(n, 10))\\n  end\\nend\\n```",
                "solutionTags": [],
                "code": "```\\ndefmodule Solution do\\n  @spec remove_trailing_zeros(num :: String.t()) :: String.t()\\n  def remove_trailing_zeros(num) do\\n    # step 1 - Convert string into an integer\\n    int_val = String.to_integer(num)\\n    lose_trailing_zeros(int_val)\\n  end\\n\\n  defp lose_trailing_zeros(n) when rem(n, 10) != 0 do\\n    Integer.to_string(n)\\n  end\\n\\n  defp lose_trailing_zeros(n) do\\n    lose_trailing_zeros(div(n, 10))\\n  end\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3923240,
                "title": "c-solution-easy-approach",
                "content": "```\\nclass Solution {\\npublic:\\n    string removeTrailingZeros(string num) {\\n        int i = 0;\\n        for(i = num.size()-1;i>= 0;i--){\\n            if(num[i] != \\'0\\'){\\n                break;\\n            }\\n        }\\n        return num.substr(0,i+1);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string removeTrailingZeros(string num) {\\n        int i = 0;\\n        for(i = num.size()-1;i>= 0;i--){\\n            if(num[i] != \\'0\\'){\\n                break;\\n            }\\n        }\\n        return num.substr(0,i+1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3922529,
                "title": "easy-solution-in-two-line",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string removeTrailingZeros(string num) {\\n        int n = num.size()-1;\\n        while(n>=0){\\n            // int val = (num[n]-\\'0\\');\\n            if(num[n]-\\'0\\'==0){\\n             num.pop_back();\\n              n--;\\n            }else{\\n                // n--;\\n                break;\\n            }\\n        }\\n        return num;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string removeTrailingZeros(string num) {\\n        int n = num.size()-1;\\n        while(n>=0){\\n            // int val = (num[n]-\\'0\\');\\n            if(num[n]-\\'0\\'==0){\\n             num.pop_back();\\n              n--;\\n            }else{\\n                // n--;\\n                break;\\n            }\\n        }\\n        return num;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3921171,
                "title": "easy-solution-using-java",
                "content": "\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public String removeTrailingZeros(String num) {\\n        for(int i = num.length() - 1; i >= 0; i--){\\n            if(num.charAt(i) != \\'0\\'){\\n                return num.substring(0,i + 1);\\n            }\\n        }\\n        return \"\";\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String removeTrailingZeros(String num) {\\n        for(int i = num.length() - 1; i >= 0; i--){\\n            if(num.charAt(i) != \\'0\\'){\\n                return num.substring(0,i + 1);\\n            }\\n        }\\n        return \"\";\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3919702,
                "title": "beats-95-in-runtime",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def removeTrailingZeros(self, num: str) -> str:\\n        j= len(num) -1\\n        while j >= 0:\\n            if num[j] == \"0\":\\n                j -= 1\\n            else:\\n                break\\n\\n        return num[:j+1]\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def removeTrailingZeros(self, num: str) -> str:\\n        j= len(num) -1\\n        while j >= 0:\\n            if num[j] == \"0\":\\n                j -= 1\\n            else:\\n                break\\n\\n        return num[:j+1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3919397,
                "title": "one-line-python-solution-python",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution(object):\\n    def removeTrailingZeros(self, num):\\n        return num.rstrip(\\'0\\') if num != \\'0\\' else \\'0\\'\\n\\n\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def removeTrailingZeros(self, num):\\n        return num.rstrip(\\'0\\') if num != \\'0\\' else \\'0\\'\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3918653,
                "title": "python-here-is-my-simple-solution-easy-understanding",
                "content": "Thanks for reading :)\\n\\n# Code\\n```\\nclass Solution:\\n    def removeTrailingZeros(self, num: str) -> str:\\n        num = list(num)\\n        if num[-1] == \\'0\\':\\n            while True:\\n                num.pop()\\n                if num[-1] != \\'0\\':\\n                    break\\n        return \\'\\'.join(num)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def removeTrailingZeros(self, num: str) -> str:\\n        num = list(num)\\n        if num[-1] == \\'0\\':\\n            while True:\\n                num.pop()\\n                if num[-1] != \\'0\\':\\n                    break\\n        return \\'\\'.join(num)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3917375,
                "title": "simple-solution-with-indexes",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    func removeTrailingZeros(_ num: String) -> String {\\n        if let lastNonZeroIndex = num.lastIndex(where: { $0 != \"0\" }) {\\n            return String(num[num.startIndex...lastNonZeroIndex])\\n        }\\n        return \"0\" \\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func removeTrailingZeros(_ num: String) -> String {\\n        if let lastNonZeroIndex = num.lastIndex(where: { $0 != \"0\" }) {\\n            return String(num[num.startIndex...lastNonZeroIndex])\\n        }\\n        return \"0\" \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3916196,
                "title": "swift-simple-way-don-t-use-any-swift-api",
                "content": "# Code\\n\\n### Simple way (Don\\'t use any Swift API)\\n\\n```\\nclass Solution {\\n    func removeTrailingZeros(_ num: String) -> String {\\n        var nums = Array(num)\\n        for i in 0..<nums.count {\\n            if nums[nums.count-1-i] != \"0\" {\\n                var sum = \"\"\\n                for char in nums[0...nums.count-1-i] {\\n                    sum += String(char)\\n                }\\n                return sum\\n            }\\n        }\\n        return num\\n    }\\n}\\n```\\n\\n### More Swify code\\n\\n```\\nclass Solution {\\n    func removeTrailingZeros(_ num: String) -> String {\\n        var nums = Array(num)\\n        for i in 0..<nums.count where nums[nums.count-1-i] != \"0\" {\\n            return nums[0...nums.count-1-i].map { String($0) }.reduce(into: String(), +=)\\n        }\\n        return num\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func removeTrailingZeros(_ num: String) -> String {\\n        var nums = Array(num)\\n        for i in 0..<nums.count {\\n            if nums[nums.count-1-i] != \"0\" {\\n                var sum = \"\"\\n                for char in nums[0...nums.count-1-i] {\\n                    sum += String(char)\\n                }\\n                return sum\\n            }\\n        }\\n        return num\\n    }\\n}\\n```\n```\\nclass Solution {\\n    func removeTrailingZeros(_ num: String) -> String {\\n        var nums = Array(num)\\n        for i in 0..<nums.count where nums[nums.count-1-i] != \"0\" {\\n            return nums[0...nums.count-1-i].map { String($0) }.reduce(into: String(), +=)\\n        }\\n        return num\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3915890,
                "title": "bye-bye-trailing-zeros-in-numbers-a-simple-and-subtle-string-solution",
                "content": "# Intuition\\nTrailing zeros are those extra \\'0\\' digits that hang out at the end of a number. Like, in the number \\'1023000\\', there are three of these trailing zeros. When we talk about numbers as words, these trailing zeros are just the \\'0\\' characters you find at the very end of the number. \\n# Approach\\nSo try to imagine you\\'ve this number written down, but in a sneaky way \\u2013 as a bunch of characters in a row, like when you\\'re texting. We\\'re talking about a number like \"1023000\". Now, those zeros at the end? They\\'re like the stragglers that kinda just chill there and got nothing to do with anyone. We\\'re calling them \"trailing zeros\" because they\\'re just tagging along at the back, doing their thing.\\n\\nSo, what we wanna do is kick these trailing zeros out, but not mess with the other numbers. We\\'re keeping it cool, preserving the order of the digits. To do that, we\\'re gonna have a look at those characters, one by one. But here\\'s the twist: we\\'re gonna do it from the end to the beginning, like you\\'re rewinding a movie.\\n\\nAs we rewind, we\\'re gonna check if the character is a zero. And if it is, we\\'re just gonna keep moving. But here\\'s where it gets interesting: as soon as we hit a character that\\'s not a zero \\u2013 that\\'s where the real action starts. Because all those trailing zeros are officially done, and we remember the spot where things got exciting.\\n\\nNow that we know where the non-zero party begins, we\\'ll take all the characters from the start to that party spot and put them together. This new bunch of characters is like the same number but with all the trailing zeros gone. It\\'s like we\\'ve tidied up the place and kicked out the uninvited zeros.\\n\\nAnd there you have it \\u2013 a super chill way to deal with trailing zeros in a number string!\\n\\n# Complexity\\n- Time complexity:\\nThe time complexity is linear or O(n) \\n\\n- Space complexity:\\nO(n) \\n\\n# Code\\n```\\nclass Solution {\\n    public String removeTrailingZeros(String num) {\\n        int endIndex = num.length() - 1;\\n\\n        // Find the index where the trailing zeros end\\n        for (int i = num.length() - 1; i >= 0; i--) {\\n            if (num.charAt(i) != \\'0\\') {\\n                endIndex = i;\\n                break;\\n            }\\n        }\\n\\n        // Create a new string without trailing zeros\\n        return num.substring(0, endIndex + 1);\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String removeTrailingZeros(String num) {\\n        int endIndex = num.length() - 1;\\n\\n        // Find the index where the trailing zeros end\\n        for (int i = num.length() - 1; i >= 0; i--) {\\n            if (num.charAt(i) != \\'0\\') {\\n                endIndex = i;\\n                break;\\n            }\\n        }\\n\\n        // Create a new string without trailing zeros\\n        return num.substring(0, endIndex + 1);\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3915306,
                "title": "easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string removeTrailingZeros(string num) {\\n        int i=num.size()-1;\\n        while(num[i]==\\'0\\'){\\n            i--;\\n        }\\n        return num.substr(0,i+1);\\n        \\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string removeTrailingZeros(string num) {\\n        int i=num.size()-1;\\n        while(num[i]==\\'0\\'){\\n            i--;\\n        }\\n        return num.substr(0,i+1);\\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3914686,
                "title": "converting-to-array-method-javascript",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {string} num\\n * @return {string}\\n */\\nvar removeTrailingZeros = function(num) {\\n\\n    let number= Array.from(num);\\n\\n   \\n    for(let i=number.length-1;i>=0;i--) {\\n\\n        if(number[i]==\\'0\\') {\\n            number.splice(i, 1);\\n        }\\n        else if(number[i]!=\\'0\\') {\\n            break;\\n        }\\n\\n\\n\\n\\n\\n    }\\n    return number.join(\\'\\');\\n    \\n    \\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string} num\\n * @return {string}\\n */\\nvar removeTrailingZeros = function(num) {\\n\\n    let number= Array.from(num);\\n\\n   \\n    for(let i=number.length-1;i>=0;i--) {\\n\\n        if(number[i]==\\'0\\') {\\n            number.splice(i, 1);\\n        }\\n        else if(number[i]!=\\'0\\') {\\n            break;\\n        }\\n\\n\\n\\n\\n\\n    }\\n    return number.join(\\'\\');\\n    \\n    \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3912342,
                "title": "java-fastest-solution",
                "content": "\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public String removeTrailingZeros(String num) {\\n        char[] chars = num.toCharArray();\\n        int i = chars.length;\\n\\n        while(i > 0){\\n            i--;\\n            if(chars[i] == \\'0\\')\\n              continue;\\n            else\\n              break;\\n        }\\n\\n        return num.substring(0, i+1);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String removeTrailingZeros(String num) {\\n        char[] chars = num.toCharArray();\\n        int i = chars.length;\\n\\n        while(i > 0){\\n            i--;\\n            if(chars[i] == \\'0\\')\\n              continue;\\n            else\\n              break;\\n        }\\n\\n        return num.substring(0, i+1);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3909887,
                "title": "easy-while-loop-soln",
                "content": "# Intuition \\nEasy question, can be done with for loop also.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nUse while loop, break from it if last char of string is not zero. \\nIf zero check second last char, and so on.\\nReturn string from beginning till last non-zero\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public String removeTrailingZeros(String s) {\\n        int n = s.length();\\n        while(n>=0){\\n            if(s.charAt(n-1) != \\'0\\')\\n            break;\\n            n--;\\n        }\\n        return s.substring(0,n);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String removeTrailingZeros(String s) {\\n        int n = s.length();\\n        while(n>=0){\\n            if(s.charAt(n-1) != \\'0\\')\\n            break;\\n            n--;\\n        }\\n        return s.substring(0,n);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3903801,
                "title": "easy-java-solution-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public String removeTrailingZeros(String num) {\\n        int len = num.length();\\n        while(len>=0)\\n        {\\n            if(num.charAt(len-1)!=\\'0\\')\\n            {\\n                break;\\n            }\\n            len--;\\n        }\\n        return num.substring(0,len);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String removeTrailingZeros(String num) {\\n        int len = num.length();\\n        while(len>=0)\\n        {\\n            if(num.charAt(len-1)!=\\'0\\')\\n            {\\n                break;\\n            }\\n            len--;\\n        }\\n        return num.substring(0,len);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3902246,
                "title": "o-n-beginner-friendly-solution-with-o-1-space-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nJust traverse character array from back and find an element which is not equal to \\'0\\',In c array size is fixed so just replace i + 1 th character with \\'\\\\0\\' that is string terminator\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nchar * removeTrailingZeros(char * num){\\n    if(num[strlen(num) - 1] != \\'0\\'){\\n        return(num);\\n    }\\n    for(int i = strlen(num) - 1;i >= 0;i--){\\n        if(num[i] != \\'0\\'){\\n           num[i+1] = \\'\\\\0\\';\\n           break;\\n        }\\n    }\\n    return(num);\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nchar * removeTrailingZeros(char * num){\\n    if(num[strlen(num) - 1] != \\'0\\'){\\n        return(num);\\n    }\\n    for(int i = strlen(num) - 1;i >= 0;i--){\\n        if(num[i] != \\'0\\'){\\n           num[i+1] = \\'\\\\0\\';\\n           break;\\n        }\\n    }\\n    return(num);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3896479,
                "title": "java-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public String removeTrailingZeros(String num) {\\n        StringBuilder str=new StringBuilder(num);\\n        for(int i=num.length()-1;i>=0;i--){\\n            if(num.charAt(i)==\\'0\\'){\\n                str.deleteCharAt(i);\\n            }\\n            else{\\n                break;\\n            }\\n        }\\n        return str.toString();\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String removeTrailingZeros(String num) {\\n        StringBuilder str=new StringBuilder(num);\\n        for(int i=num.length()-1;i>=0;i--){\\n            if(num.charAt(i)==\\'0\\'){\\n                str.deleteCharAt(i);\\n            }\\n            else{\\n                break;\\n            }\\n        }\\n        return str.toString();\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3895905,
                "title": "simple-and-clear-python-solution-beat-96",
                "content": "# Is it need explanation?\\n### Approach\\nWe turn over the string - we count the first characters and as soon as we meet something that is not equal to zero, we interrupt the cycle, then we cut off the zeros using a slice and rotate the string back.\\n\\n# Code\\n```\\nclass Solution:\\n    def removeTrailingZeros(self, num: str) -> str:\\n        num = num[::-1]\\n        zeros = 0\\n        for s in num:\\n            if s != \\'0\\':\\n                break\\n            zeros += 1\\n        return num[zeros:][::-1]\\n\\n```",
                "solutionTags": [
                    "Python3",
                    "String"
                ],
                "code": "```\\nclass Solution:\\n    def removeTrailingZeros(self, num: str) -> str:\\n        num = num[::-1]\\n        zeros = 0\\n        for s in num:\\n            if s != \\'0\\':\\n                break\\n            zeros += 1\\n        return num[zeros:][::-1]\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3893458,
                "title": "easy-to-understand-solution-in-cpp",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string removeTrailingZeros(string num) {\\n       int i = num.size()-1;\\n       string str=num;\\n    while(i >= 0)\\n    {\\n       if(str[i]==\\'0\\')\\n       {\\n        str.erase(i);\\n       }\\n       else\\n       {\\n           break;\\n       }\\n       i--;\\n    }\\n    return str;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string removeTrailingZeros(string num) {\\n       int i = num.size()-1;\\n       string str=num;\\n    while(i >= 0)\\n    {\\n       if(str[i]==\\'0\\')\\n       {\\n        str.erase(i);\\n       }\\n       else\\n       {\\n           break;\\n       }\\n       i--;\\n    }\\n    return str;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3893202,
                "title": "clean-short-simple-java-solution-beats-100",
                "content": "# Code\\n```\\nclass Solution {\\n    public String removeTrailingZeros(String num) {\\n        int j = num.length()-1;\\n        while(num.charAt(j) == \\'0\\') {\\n            j--;\\n        }\\n        return num.substring(0, j+1);\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String removeTrailingZeros(String num) {\\n        int j = num.length()-1;\\n        while(num.charAt(j) == \\'0\\') {\\n            j--;\\n        }\\n        return num.substring(0, j+1);\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3893000,
                "title": "c-ez-brute-force-100-solution",
                "content": "\\n\\n# Code\\n```\\npublic class Solution {\\n    public string RemoveTrailingZeros(string num) {\\n        char[] nArr = num.ToCharArray();\\n        for(int i = nArr.Length - 1; i >= 0; i--)\\n            if(nArr[i] == \\'0\\')\\n                nArr[i] = \\'@\\';\\n            else\\n                break;\\n        StringBuilder sb = new StringBuilder();\\n        for(int i = 0; i < nArr.Length; i++)\\n            if(nArr[i] != \\'@\\')\\n                sb.Append(nArr[i]);\\n            else\\n                break;\\n        return sb.ToString();\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public string RemoveTrailingZeros(string num) {\\n        char[] nArr = num.ToCharArray();\\n        for(int i = nArr.Length - 1; i >= 0; i--)\\n            if(nArr[i] == \\'0\\')\\n                nArr[i] = \\'@\\';\\n            else\\n                break;\\n        StringBuilder sb = new StringBuilder();\\n        for(int i = 0; i < nArr.Length; i++)\\n            if(nArr[i] != \\'@\\')\\n                sb.Append(nArr[i]);\\n            else\\n                break;\\n        return sb.ToString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3889986,
                "title": "simple-java-solution-o-n-time-complexity-beats-100-in-time-complexity",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    public String removeTrailingZeros(String num) {\\n\\n        int count=0;\\n\\n        for(int i=num.length()-1; i>=0; i--){\\n            if(num.charAt(i)==\\'0\\'){\\n                count++;\\n            } else{\\n                break;\\n            }\\n        }\\n\\n        return num.substring(0,(num.length()-count));\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String removeTrailingZeros(String num) {\\n\\n        int count=0;\\n\\n        for(int i=num.length()-1; i>=0; i--){\\n            if(num.charAt(i)==\\'0\\'){\\n                count++;\\n            } else{\\n                break;\\n            }\\n        }\\n\\n        return num.substring(0,(num.length()-count));\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1909037,
                "content": [
                    {
                        "username": "Vishal_chandravanshi",
                        "content": "Count the Trailing Zeros (from back) From a String and return the substring of length (0 to length-count )\n"
                    },
                    {
                        "username": "sprenten",
                        "content": "For people who are attempting to post a C solution, this uses a horrible input format of the char num[] = \"51230100\" and then being cast as char * ptr = &num[0] with the ptr variable which is then being passed passed into the function.  This is only way to get a valid solution to work the way they want to and in IMO is not the way you should write C as you will get seg faults.  Sorry but if you are telling me num = \"123\" in C I have to assume it is being assigned to a char* and not a char[].  I used valgrind over 30000 random integers I have in a program using clang, gcc, and icc and each version had zero memory leaks with the calloc submission I used because I freed the return value after use.  "
                    },
                    {
                        "username": "olehn",
                        "content": "I see that folks (including me, haha) are mostly using one of the Python's built-in functions... Is this the preferred way of doing, or should we reinvent the wheel?"
                    },
                    {
                        "username": "Aditya560",
                        "content": "Scan from back if it is 0 then pop it otherwise break the loop"
                    },
                    {
                        "username": "almostmonday",
                        "content": "It would be more interesting if `\"0\"` was allowed."
                    },
                    {
                        "username": "rastogiyash461",
                        "content": "Try to find the index of last non-zero digit."
                    },
                    {
                        "username": "Khudoyshukur",
                        "content": "i am getting \\n[0.013s][warning][os,thread] Failed to start thread \"Unknown thread\" - pthread_create failed (EAGAIN) for attributes: stacksize: 195316k, guardsize: 0k, detached.\\nError occurred during initialization of VM\\njava.lang.OutOfMemoryError: unable to create native thread: possibly out of memory or process/resource limits reached\\nerror does anybody why this is happening."
                    }
                ]
            },
            {
                "id": 1917169,
                "content": [
                    {
                        "username": "Vishal_chandravanshi",
                        "content": "Count the Trailing Zeros (from back) From a String and return the substring of length (0 to length-count )\n"
                    },
                    {
                        "username": "sprenten",
                        "content": "For people who are attempting to post a C solution, this uses a horrible input format of the char num[] = \"51230100\" and then being cast as char * ptr = &num[0] with the ptr variable which is then being passed passed into the function.  This is only way to get a valid solution to work the way they want to and in IMO is not the way you should write C as you will get seg faults.  Sorry but if you are telling me num = \"123\" in C I have to assume it is being assigned to a char* and not a char[].  I used valgrind over 30000 random integers I have in a program using clang, gcc, and icc and each version had zero memory leaks with the calloc submission I used because I freed the return value after use.  "
                    },
                    {
                        "username": "olehn",
                        "content": "I see that folks (including me, haha) are mostly using one of the Python's built-in functions... Is this the preferred way of doing, or should we reinvent the wheel?"
                    },
                    {
                        "username": "Aditya560",
                        "content": "Scan from back if it is 0 then pop it otherwise break the loop"
                    },
                    {
                        "username": "almostmonday",
                        "content": "It would be more interesting if `\"0\"` was allowed."
                    },
                    {
                        "username": "rastogiyash461",
                        "content": "Try to find the index of last non-zero digit."
                    },
                    {
                        "username": "Khudoyshukur",
                        "content": "i am getting \\n[0.013s][warning][os,thread] Failed to start thread \"Unknown thread\" - pthread_create failed (EAGAIN) for attributes: stacksize: 195316k, guardsize: 0k, detached.\\nError occurred during initialization of VM\\njava.lang.OutOfMemoryError: unable to create native thread: possibly out of memory or process/resource limits reached\\nerror does anybody why this is happening."
                    }
                ]
            },
            {
                "id": 1925673,
                "content": [
                    {
                        "username": "Vishal_chandravanshi",
                        "content": "Count the Trailing Zeros (from back) From a String and return the substring of length (0 to length-count )\n"
                    },
                    {
                        "username": "sprenten",
                        "content": "For people who are attempting to post a C solution, this uses a horrible input format of the char num[] = \"51230100\" and then being cast as char * ptr = &num[0] with the ptr variable which is then being passed passed into the function.  This is only way to get a valid solution to work the way they want to and in IMO is not the way you should write C as you will get seg faults.  Sorry but if you are telling me num = \"123\" in C I have to assume it is being assigned to a char* and not a char[].  I used valgrind over 30000 random integers I have in a program using clang, gcc, and icc and each version had zero memory leaks with the calloc submission I used because I freed the return value after use.  "
                    },
                    {
                        "username": "olehn",
                        "content": "I see that folks (including me, haha) are mostly using one of the Python's built-in functions... Is this the preferred way of doing, or should we reinvent the wheel?"
                    },
                    {
                        "username": "Aditya560",
                        "content": "Scan from back if it is 0 then pop it otherwise break the loop"
                    },
                    {
                        "username": "almostmonday",
                        "content": "It would be more interesting if `\"0\"` was allowed."
                    },
                    {
                        "username": "rastogiyash461",
                        "content": "Try to find the index of last non-zero digit."
                    },
                    {
                        "username": "Khudoyshukur",
                        "content": "i am getting \\n[0.013s][warning][os,thread] Failed to start thread \"Unknown thread\" - pthread_create failed (EAGAIN) for attributes: stacksize: 195316k, guardsize: 0k, detached.\\nError occurred during initialization of VM\\njava.lang.OutOfMemoryError: unable to create native thread: possibly out of memory or process/resource limits reached\\nerror does anybody why this is happening."
                    }
                ]
            },
            {
                "id": 1910909,
                "content": [
                    {
                        "username": "Vishal_chandravanshi",
                        "content": "Count the Trailing Zeros (from back) From a String and return the substring of length (0 to length-count )\n"
                    },
                    {
                        "username": "sprenten",
                        "content": "For people who are attempting to post a C solution, this uses a horrible input format of the char num[] = \"51230100\" and then being cast as char * ptr = &num[0] with the ptr variable which is then being passed passed into the function.  This is only way to get a valid solution to work the way they want to and in IMO is not the way you should write C as you will get seg faults.  Sorry but if you are telling me num = \"123\" in C I have to assume it is being assigned to a char* and not a char[].  I used valgrind over 30000 random integers I have in a program using clang, gcc, and icc and each version had zero memory leaks with the calloc submission I used because I freed the return value after use.  "
                    },
                    {
                        "username": "olehn",
                        "content": "I see that folks (including me, haha) are mostly using one of the Python's built-in functions... Is this the preferred way of doing, or should we reinvent the wheel?"
                    },
                    {
                        "username": "Aditya560",
                        "content": "Scan from back if it is 0 then pop it otherwise break the loop"
                    },
                    {
                        "username": "almostmonday",
                        "content": "It would be more interesting if `\"0\"` was allowed."
                    },
                    {
                        "username": "rastogiyash461",
                        "content": "Try to find the index of last non-zero digit."
                    },
                    {
                        "username": "Khudoyshukur",
                        "content": "i am getting \\n[0.013s][warning][os,thread] Failed to start thread \"Unknown thread\" - pthread_create failed (EAGAIN) for attributes: stacksize: 195316k, guardsize: 0k, detached.\\nError occurred during initialization of VM\\njava.lang.OutOfMemoryError: unable to create native thread: possibly out of memory or process/resource limits reached\\nerror does anybody why this is happening."
                    }
                ]
            },
            {
                "id": 1908820,
                "content": [
                    {
                        "username": "Vishal_chandravanshi",
                        "content": "Count the Trailing Zeros (from back) From a String and return the substring of length (0 to length-count )\n"
                    },
                    {
                        "username": "sprenten",
                        "content": "For people who are attempting to post a C solution, this uses a horrible input format of the char num[] = \"51230100\" and then being cast as char * ptr = &num[0] with the ptr variable which is then being passed passed into the function.  This is only way to get a valid solution to work the way they want to and in IMO is not the way you should write C as you will get seg faults.  Sorry but if you are telling me num = \"123\" in C I have to assume it is being assigned to a char* and not a char[].  I used valgrind over 30000 random integers I have in a program using clang, gcc, and icc and each version had zero memory leaks with the calloc submission I used because I freed the return value after use.  "
                    },
                    {
                        "username": "olehn",
                        "content": "I see that folks (including me, haha) are mostly using one of the Python's built-in functions... Is this the preferred way of doing, or should we reinvent the wheel?"
                    },
                    {
                        "username": "Aditya560",
                        "content": "Scan from back if it is 0 then pop it otherwise break the loop"
                    },
                    {
                        "username": "almostmonday",
                        "content": "It would be more interesting if `\"0\"` was allowed."
                    },
                    {
                        "username": "rastogiyash461",
                        "content": "Try to find the index of last non-zero digit."
                    },
                    {
                        "username": "Khudoyshukur",
                        "content": "i am getting \\n[0.013s][warning][os,thread] Failed to start thread \"Unknown thread\" - pthread_create failed (EAGAIN) for attributes: stacksize: 195316k, guardsize: 0k, detached.\\nError occurred during initialization of VM\\njava.lang.OutOfMemoryError: unable to create native thread: possibly out of memory or process/resource limits reached\\nerror does anybody why this is happening."
                    }
                ]
            },
            {
                "id": 2040134,
                "content": [
                    {
                        "username": "Vishal_chandravanshi",
                        "content": "Count the Trailing Zeros (from back) From a String and return the substring of length (0 to length-count )\n"
                    },
                    {
                        "username": "sprenten",
                        "content": "For people who are attempting to post a C solution, this uses a horrible input format of the char num[] = \"51230100\" and then being cast as char * ptr = &num[0] with the ptr variable which is then being passed passed into the function.  This is only way to get a valid solution to work the way they want to and in IMO is not the way you should write C as you will get seg faults.  Sorry but if you are telling me num = \"123\" in C I have to assume it is being assigned to a char* and not a char[].  I used valgrind over 30000 random integers I have in a program using clang, gcc, and icc and each version had zero memory leaks with the calloc submission I used because I freed the return value after use.  "
                    },
                    {
                        "username": "olehn",
                        "content": "I see that folks (including me, haha) are mostly using one of the Python's built-in functions... Is this the preferred way of doing, or should we reinvent the wheel?"
                    },
                    {
                        "username": "Aditya560",
                        "content": "Scan from back if it is 0 then pop it otherwise break the loop"
                    },
                    {
                        "username": "almostmonday",
                        "content": "It would be more interesting if `\"0\"` was allowed."
                    },
                    {
                        "username": "rastogiyash461",
                        "content": "Try to find the index of last non-zero digit."
                    },
                    {
                        "username": "Khudoyshukur",
                        "content": "i am getting \\n[0.013s][warning][os,thread] Failed to start thread \"Unknown thread\" - pthread_create failed (EAGAIN) for attributes: stacksize: 195316k, guardsize: 0k, detached.\\nError occurred during initialization of VM\\njava.lang.OutOfMemoryError: unable to create native thread: possibly out of memory or process/resource limits reached\\nerror does anybody why this is happening."
                    }
                ]
            },
            {
                "id": 1932253,
                "content": [
                    {
                        "username": "Vishal_chandravanshi",
                        "content": "Count the Trailing Zeros (from back) From a String and return the substring of length (0 to length-count )\n"
                    },
                    {
                        "username": "sprenten",
                        "content": "For people who are attempting to post a C solution, this uses a horrible input format of the char num[] = \"51230100\" and then being cast as char * ptr = &num[0] with the ptr variable which is then being passed passed into the function.  This is only way to get a valid solution to work the way they want to and in IMO is not the way you should write C as you will get seg faults.  Sorry but if you are telling me num = \"123\" in C I have to assume it is being assigned to a char* and not a char[].  I used valgrind over 30000 random integers I have in a program using clang, gcc, and icc and each version had zero memory leaks with the calloc submission I used because I freed the return value after use.  "
                    },
                    {
                        "username": "olehn",
                        "content": "I see that folks (including me, haha) are mostly using one of the Python's built-in functions... Is this the preferred way of doing, or should we reinvent the wheel?"
                    },
                    {
                        "username": "Aditya560",
                        "content": "Scan from back if it is 0 then pop it otherwise break the loop"
                    },
                    {
                        "username": "almostmonday",
                        "content": "It would be more interesting if `\"0\"` was allowed."
                    },
                    {
                        "username": "rastogiyash461",
                        "content": "Try to find the index of last non-zero digit."
                    },
                    {
                        "username": "Khudoyshukur",
                        "content": "i am getting \\n[0.013s][warning][os,thread] Failed to start thread \"Unknown thread\" - pthread_create failed (EAGAIN) for attributes: stacksize: 195316k, guardsize: 0k, detached.\\nError occurred during initialization of VM\\njava.lang.OutOfMemoryError: unable to create native thread: possibly out of memory or process/resource limits reached\\nerror does anybody why this is happening."
                    }
                ]
            }
        ]
    },
    {
        "title": "Is Object Empty",
        "question_content": "<p>Given an object or an array, return if it is empty.</p>\n\n<ul>\n\t<li>An empty object contains no key-value pairs.</li>\n\t<li>An empty array contains no elements.</li>\n</ul>\n\n<p>You may assume the object or array is the output of&nbsp;<code>JSON.parse</code>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> obj = {&quot;x&quot;: 5, &quot;y&quot;: 42}\n<strong>Output:</strong> false\n<strong>Explanation:</strong> The object has 2 key-value pairs so it is not empty.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> obj = {}\n<strong>Output:</strong> true\n<strong>Explanation:</strong> The object doesn&#39;t have any key-value pairs so it is empty.\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> obj = [null, false, 0]\n<strong>Output:</strong> false\n<strong>Explanation:</strong> The array has 3 elements so it is not empty.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>obj</code> is a valid JSON object or array</li>\n\t<li><code>2 &lt;= JSON.stringify(obj).length &lt;= 10<sup>5</sup></code></li>\n</ul>\n\n<p>&nbsp;</p>\n<strong>Can you solve it in O(1) time?</strong>",
        "solutions": [
            {
                "id": 3609695,
                "title": "javascript-for-iterator-time-o-1-generator-function",
                "content": "# Complexity\\n- Time complexity: $$O(1)$$\\n- Space complexity: $$O(1)$$\\n\\n# Code\\n```\\nvar isEmpty = function(obj) {\\n    for (const _ in obj) return false;\\n    return true;\\n};\\n```\\n#### Only for Arrays\\n```\\nvar isEmpty = function(obj) {\\n    return obj[Symbol.iterator]().next().done;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar isEmpty = function(obj) {\\n    for (const _ in obj) return false;\\n    return true;\\n};\\n```\n```\\nvar isEmpty = function(obj) {\\n    return obj[Symbol.iterator]().next().done;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3607988,
                "title": "simple-o-1-without-using-object-keys-or-json-stringify",
                "content": "Time/Space complexity of `JSON.stringify` and `Object.keys` depend on the size of the object/array hence execution time/space of above methods is not O(1)\\n\\nWe can instead use for-in loop since it works on both array as well as objects.\\n\\n# Code\\n```\\nvar isEmpty = function(obj) {\\n    for (let key in obj)\\n        return false;\\n    return true;\\n};\\n```\\n\\n- If array/object is not empty, interpreter will enter the for-in loop and hence first return statement (false) will be executed.\\n- If array/object is empty, interpreter won\\'t enter for-in loop and hence second return statement (true) will be executed.\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar isEmpty = function(obj) {\\n    for (let key in obj)\\n        return false;\\n    return true;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3607720,
                "title": "simple-implementation",
                "content": "\\n\\n# Code\\n```\\n/**\\n * @param {Object | Array} obj\\n * @return {boolean}\\n */\\nvar isEmpty = function(obj) {\\n  if (Array.isArray(obj)) {\\n    return obj.length === 0;\\n  } else if (typeof obj === \\'object\\' && obj !== null) {\\n    return Object.keys(obj).length === 0;\\n  }\\n  return false; \\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Object | Array} obj\\n * @return {boolean}\\n */\\nvar isEmpty = function(obj) {\\n  if (Array.isArray(obj)) {\\n    return obj.length === 0;\\n  } else if (typeof obj === \\'object\\' && obj !== null) {\\n    return Object.keys(obj).length === 0;\\n  }\\n  return false; \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3616283,
                "title": "javascript-one-liner",
                "content": "# Code\\n```\\nvar isEmpty = function(obj) {\\n    return !Object.keys(obj).length;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar isEmpty = function(obj) {\\n    return !Object.keys(obj).length;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3645833,
                "title": "js-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Object | Array} obj\\n * @return {boolean}\\n */\\nvar isEmpty = function(obj) {\\n    return Object.keys(obj).length === 0 ? true : false;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Object | Array} obj\\n * @return {boolean}\\n */\\nvar isEmpty = function(obj) {\\n    return Object.keys(obj).length === 0 ? true : false;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4033593,
                "title": "easy-js-solution-for-is-object-empty",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Object | Array} obj\\n * @return {boolean}\\n */\\nvar isEmpty = function(obj) {\\n    if(Object.entries(obj).length === 0){\\n        return true\\n    }else{\\n        return false\\n    }\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Object | Array} obj\\n * @return {boolean}\\n */\\nvar isEmpty = function(obj) {\\n    if(Object.entries(obj).length === 0){\\n        return true\\n    }else{\\n        return false\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4032347,
                "title": "one-line-solution-using-javascript-full-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nAs this question is about Object then it is obvious that we will first think of Object methods. we look what object mehods can help us to get our desired answer.\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1)In JavaScript we have Object.keys() method which gives us all the keys available in the object.\\n\\nFor example:\\n```\\nconst person = {\\n  firstName: \\'John\\',\\n  lastName: \\'Doe\\',\\n  age: 30,\\n  email: \\'john@example.com\\'\\n};\\n\\nconst keys = Object.keys(person); //here it will give all the keys in our console\\n\\nconsole.log(keys);\\n```\\nOutput:\\n```\\n[ \\'firstName\\', \\'lastName\\', \\'age\\', \\'email\\' ]\\n```\\n2) Now we got the array of keys in further part we take use of length method available in JavaScript to get the length of this array and we will check if it is equals to 0 it will return true as mentioned in question otherwise if object have some keys then return false. \\n\\n# Code\\n```\\n/**\\n * @param {Object | Array} obj\\n * @return {boolean}\\n */\\nvar isEmpty = function(obj) {\\n   return Object.keys(obj).length === 0;\\n};\\n```\\n# **Please Upvote the solution if\\'d find it useful\\u2764\\uD83D\\uDC4D**",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nconst person = {\\n  firstName: \\'John\\',\\n  lastName: \\'Doe\\',\\n  age: 30,\\n  email: \\'john@example.com\\'\\n};\\n\\nconst keys = Object.keys(person); //here it will give all the keys in our console\\n\\nconsole.log(keys);\\n```\n```\\n[ \\'firstName\\', \\'lastName\\', \\'age\\', \\'email\\' ]\\n```\n```\\n/**\\n * @param {Object | Array} obj\\n * @return {boolean}\\n */\\nvar isEmpty = function(obj) {\\n   return Object.keys(obj).length === 0;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3752822,
                "title": "super-easy-and-simple-solution-in-js-0-0-wow",
                "content": "# Easy solution\\nIn Object.keys you can check not only object\\'s keys but also array\\'s keys. So it is very easy\\n# Code\\n```\\n/**\\n * @param {Object | Array} obj\\n * @return {boolean}\\n */\\nvar isEmpty = function(obj) {\\n    return Object.keys(obj).length == 0 ? true : false\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Object | Array} obj\\n * @return {boolean}\\n */\\nvar isEmpty = function(obj) {\\n    return Object.keys(obj).length == 0 ? true : false\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3689771,
                "title": "simple-one-line-solution-using-object-keys-method",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Object | Array} obj\\n * @return {boolean}\\n */\\nvar isEmpty = function(obj) {\\n   return Object.keys(obj).length === 0 ? true : false;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Object | Array} obj\\n * @return {boolean}\\n */\\nvar isEmpty = function(obj) {\\n   return Object.keys(obj).length === 0 ? true : false;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3680834,
                "title": "return-json-stringify-2",
                "content": "```js\\nvar isEmpty = function(obj) {\\n    return JSON.stringify(obj).length === 2;  \\n};\\n```",
                "solutionTags": [],
                "code": "```js\\nvar isEmpty = function(obj) {\\n    return JSON.stringify(obj).length === 2;  \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3637796,
                "title": "easy-typescript-solution-with-iteration",
                "content": "# Code\\n```\\nfunction isEmpty(obj: Record<string, any> | any[]): boolean {\\n  for (let value in obj) {\\n    return false;\\n  }\\n\\n  return true;\\n};\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\nfunction isEmpty(obj: Record<string, any> | any[]): boolean {\\n  for (let value in obj) {\\n    return false;\\n  }\\n\\n  return true;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3608457,
                "title": "one-line-solution-ternary-operator-javascript",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Object | Array} obj\\n * @return {boolean}\\n */\\nvar isEmpty = function(obj) {\\n   return Array.isArray(obj) ? obj.length === 0 : Object.keys(obj).length === 0; \\n};\\n      \\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Object | Array} obj\\n * @return {boolean}\\n */\\nvar isEmpty = function(obj) {\\n   return Array.isArray(obj) ? obj.length === 0 : Object.keys(obj).length === 0; \\n};\\n      \\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3607209,
                "title": "javascript-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Object | Array} obj\\n * @return {boolean}\\n */\\nvar isEmpty = function(obj) {\\n    if(Array.isArray(obj)){\\n        return !(obj.length);\\n    }\\n    return !(Object.keys(obj).length);\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Object | Array} obj\\n * @return {boolean}\\n */\\nvar isEmpty = function(obj) {\\n    if(Array.isArray(obj)){\\n        return !(obj.length);\\n    }\\n    return !(Object.keys(obj).length);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3823667,
                "title": "worst-javascript-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(1)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Object | Array} obj\\n * @return {boolean}\\n */\\nvar isEmpty = function(obj) {\\n    if(Array.isArray(obj))\\n        return (!obj.length);\\n    // console.log(Object.values(obj))\\n    return (!Object.values(obj).length);\\n};\\n```\\n![\\u043F\\u04350.jfif](https://assets.leetcode.com/users/images/65018b70-c72f-4501-9aef-bf9c89cf0a5b_1690460779.7540426.jpeg)\\n",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "```\\n/**\\n * @param {Object | Array} obj\\n * @return {boolean}\\n */\\nvar isEmpty = function(obj) {\\n    if(Array.isArray(obj))\\n        return (!obj.length);\\n    // console.log(Object.values(obj))\\n    return (!Object.values(obj).length);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3749956,
                "title": "one-liner-js-const-isempty-obj-object-keys-obj-length-0",
                "content": "<!-- # Intuition -->\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n<!-- # Approach -->\\n<!-- Describe your approach to solving the problem. -->\\n\\n<!-- # Complexity -->\\n<!-- - Time complexity: -->\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n<!-- - Space complexity: -->\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Object | Array} obj\\n * @return {boolean}\\n */\\nconst isEmpty = obj => Object.keys(obj).length === 0\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Object | Array} obj\\n * @return {boolean}\\n */\\nconst isEmpty = obj => Object.keys(obj).length === 0\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3665842,
                "title": "javascript",
                "content": "\\n\\n# Code\\n```\\nvar isEmpty = function(obj) {\\n    obj = JSON.stringify(obj);\\n    return obj.length == 2;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar isEmpty = function(obj) {\\n    obj = JSON.stringify(obj);\\n    return obj.length == 2;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4100665,
                "title": "2727-is-object-empty",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\ntype JSONValue = null | boolean | number | string | JSONValue[] | { [key: string]: JSONValue };\\ntype Obj = Record<string, JSONValue> | JSONValue[]\\n\\nfunction isEmpty(obj: Obj): boolean {\\n    if(Object.keys(obj).length === 0 ){\\n        return true\\n    }else{\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\ntype JSONValue = null | boolean | number | string | JSONValue[] | { [key: string]: JSONValue };\\ntype Obj = Record<string, JSONValue> | JSONValue[]\\n\\nfunction isEmpty(obj: Obj): boolean {\\n    if(Object.keys(obj).length === 0 ){\\n        return true\\n    }else{\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4100662,
                "title": "2727-is-object-empty",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\ntype JSONValue = null | boolean | number | string | JSONValue[] | { [key: string]: JSONValue };\\ntype Obj = Record<string, JSONValue> | JSONValue[]\\n\\nfunction isEmpty(obj: Obj): boolean {\\n    console.log(obj.length, Object.keys(obj).length,\"if condition\")\\n    if(Object.keys(obj).length === 0 ){\\n        return true\\n    }else{\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\ntype JSONValue = null | boolean | number | string | JSONValue[] | { [key: string]: JSONValue };\\ntype Obj = Record<string, JSONValue> | JSONValue[]\\n\\nfunction isEmpty(obj: Obj): boolean {\\n    console.log(obj.length, Object.keys(obj).length,\"if condition\")\\n    if(Object.keys(obj).length === 0 ){\\n        return true\\n    }else{\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4100189,
                "title": "1-line-js-ts-solution-best-ever",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\ntype JSONValue = null | boolean | number | string | JSONValue[] | { [key: string]: JSONValue };\\ntype Obj = Record<string, JSONValue> | JSONValue[]\\n\\nconst isEmpty = (obj: Obj): boolean => Object.keys(obj).length === 0;\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\ntype JSONValue = null | boolean | number | string | JSONValue[] | { [key: string]: JSONValue };\\ntype Obj = Record<string, JSONValue> | JSONValue[]\\n\\nconst isEmpty = (obj: Obj): boolean => Object.keys(obj).length === 0;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4092524,
                "title": "solution-using-js-object-values",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Object|Array} obj\\n * @return {boolean}\\n */\\nvar isEmpty = function(obj) {\\n   return ( Object.values(obj).length === 0 ? true : false );\\n};\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Object|Array} obj\\n * @return {boolean}\\n */\\nvar isEmpty = function(obj) {\\n   return ( Object.values(obj).length === 0 ? true : false );\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4075371,
                "title": "2727-is-object-empty",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Object|Array} obj\\n * @return {boolean}\\n */\\nvar isEmpty = function(obj) {\\n    return !(Object.keys(obj).length);\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Object|Array} obj\\n * @return {boolean}\\n */\\nvar isEmpty = function(obj) {\\n    return !(Object.keys(obj).length);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4074575,
                "title": "truly-a-one-liner",
                "content": "# Intuition\\n\\nUse `!` to negate the length of the Object.keys method and cast it as a boolean. If it\\'s `0` then it\\'ll flip to `true` and if it\\'s greater than zero, it\\'ll flip to `false`.\\n\\nUse the anonymous arrow function syntax because it\\'s 2023.\\n\\n# Code\\n```\\nconst isEmpty = (o => !Object.keys(o).length);\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nconst isEmpty = (o => !Object.keys(o).length);\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4073752,
                "title": "beats-96-64-of-users-runtime-and-beats-73-51-of-users-memory",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nTo solve the problem we need to check whether obj is empty or not.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nconvert provided obj to string and you will get either \"{}\" or \"[]\",\\nput an if statement to check if the provided obj match these return true else return false\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Object|Array} obj\\n * @return {boolean}\\n */\\nvar isEmpty = function(obj) {\\n    const objStr = JSON.stringify(obj)\\n    if(objStr === \\'{}\\' || objStr ===\\'[]\\'){\\n        return true\\n    }\\n    return false;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Object|Array} obj\\n * @return {boolean}\\n */\\nvar isEmpty = function(obj) {\\n    const objStr = JSON.stringify(obj)\\n    if(objStr === \\'{}\\' || objStr ===\\'[]\\'){\\n        return true\\n    }\\n    return false;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4067278,
                "title": "easy-javascript-solution",
                "content": "# Code\\n```\\n/**\\n * @param {Object|Array} obj\\n * @return {boolean}\\n */\\nvar isEmpty = function(obj) {\\n    if(Object.keys(obj).length === 0) return true;\\n    else return false;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Object|Array} obj\\n * @return {boolean}\\n */\\nvar isEmpty = function(obj) {\\n    if(Object.keys(obj).length === 0) return true;\\n    else return false;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4067112,
                "title": "is-object-empty-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Object|Array} obj\\n * @return {boolean}\\n */\\nvar isEmpty = function(obj) {\\n    if(Object.entries(obj).length === 0){\\n        return true;\\n    }else{\\n        return false;\\n    }\\n}; \\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Object|Array} obj\\n * @return {boolean}\\n */\\nvar isEmpty = function(obj) {\\n    if(Object.entries(obj).length === 0){\\n        return true;\\n    }else{\\n        return false;\\n    }\\n}; \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4061537,
                "title": "easy-typescript-solution",
                "content": "\\n\\n# Code\\n```\\ntype JSONValue = null | boolean | number | string | JSONValue[] | { [key: string]: JSONValue };\\ntype Obj = Record<string, JSONValue> | JSONValue[]\\n\\nfunction isEmpty(obj: Obj): boolean {\\n    if(Object.keys(obj).length === 0) return true;\\n    else return false;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "```\\ntype JSONValue = null | boolean | number | string | JSONValue[] | { [key: string]: JSONValue };\\ntype Obj = Record<string, JSONValue> | JSONValue[]\\n\\nfunction isEmpty(obj: Obj): boolean {\\n    if(Object.keys(obj).length === 0) return true;\\n    else return false;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4058603,
                "title": "js-one-liner",
                "content": "# Code\\n```\\n/**\\n * @param {Object|Array} obj\\n * @return {boolean}\\n */\\nvar isEmpty = (obj) => !Object.keys(obj).length;\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Object|Array} obj\\n * @return {boolean}\\n */\\nvar isEmpty = (obj) => !Object.keys(obj).length;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4052731,
                "title": "easiest-way",
                "content": "\\nvar isEmpty = function (obj) {\\n\\n\\n// methode 1  by using object Entries \\n   const res = Object.entries(obj);\\n   if (res.length === 0) {\\n      return true;\\n   }\\n   else {\\n      return false;\\n   }\\n\\n\\n// methode 2 using object keys \\n\\n   const res2 = Object.keys(obj)\\n   if (res2.length === 0) {\\n      return true;\\n   }\\n   else {\\n      return false;\\n   }\\n\\n\\n};",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "\\nvar isEmpty = function (obj) {\\n\\n\\n// methode 1  by using object Entries \\n   const res = Object.entries(obj);\\n   if (res.length === 0) {\\n      return true;\\n   }\\n   else {\\n      return false;\\n   }\\n\\n\\n// methode 2 using object keys \\n\\n   const res2 = Object.keys(obj)\\n   if (res2.length === 0) {\\n      return true;\\n   }\\n   else {\\n      return false;\\n   }\\n\\n\\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 4049648,
                "title": "solution-with-isarray-and-object-keys",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Object|Array} obj\\n * @return {boolean}\\n */\\nvar isEmpty = function(obj) {\\n    if(Array.isArray(obj) && obj.length) return false\\n    if(Object.keys(obj).length) return false\\n    return true\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Object|Array} obj\\n * @return {boolean}\\n */\\nvar isEmpty = function(obj) {\\n    if(Array.isArray(obj) && obj.length) return false\\n    if(Object.keys(obj).length) return false\\n    return true\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4049094,
                "title": "d",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Object|Array} obj\\n * @return {boolean}\\n */\\nvar isEmpty = function(obj) {\\nreturn Object.keys(obj).length == 0\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Object|Array} obj\\n * @return {boolean}\\n */\\nvar isEmpty = function(obj) {\\nreturn Object.keys(obj).length == 0\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4048078,
                "title": "best-of-js",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Object|Array} obj\\n * @return {boolean}\\n */\\nvar isEmpty = function(obj) {\\n    for (const _ in obj)\\n    return false;\\n    return true;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Object|Array} obj\\n * @return {boolean}\\n */\\nvar isEmpty = function(obj) {\\n    for (const _ in obj)\\n    return false;\\n    return true;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4046410,
                "title": "easiest-way-to-the-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Object | Array} obj\\n * @return {boolean}\\n */\\nvar isEmpty = function(obj) {\\n    if((Object.entries(obj).length)===0){\\n        return true\\n    }\\n    else{\\n        return false\\n    }\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Object | Array} obj\\n * @return {boolean}\\n */\\nvar isEmpty = function(obj) {\\n    if((Object.entries(obj).length)===0){\\n        return true\\n    }\\n    else{\\n        return false\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4042467,
                "title": "easy-javascript-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Object | Array} obj\\n * @return {boolean}\\n */\\nvar isEmpty = function(obj) {\\n\\n    <!-- using Object.keys() Method -->\\n    // let length = Object.keys(obj).length;\\n    // return length > 0 ? false : true\\n\\n    <!-- using JSON.stringify() -->\\n    return JSON.stringify(obj).length > 2 ? false :true\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Object | Array} obj\\n * @return {boolean}\\n */\\nvar isEmpty = function(obj) {\\n\\n    <!-- using Object.keys() Method -->\\n    // let length = Object.keys(obj).length;\\n    // return length > 0 ? false : true\\n\\n    <!-- using JSON.stringify() -->\\n    return JSON.stringify(obj).length > 2 ? false :true\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4041315,
                "title": "javascript-1-liner-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Object | Array} obj\\n * @return {boolean}\\n */\\nvar isEmpty = function(obj) {\\n    return !Object.keys(obj)?.length \\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Object | Array} obj\\n * @return {boolean}\\n */\\nvar isEmpty = function(obj) {\\n    return !Object.keys(obj)?.length \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4041282,
                "title": "oneline",
                "content": "```\\nconst  isEmpty = (obj)=> !Object.values(obj).length \\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nconst  isEmpty = (obj)=> !Object.values(obj).length \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4035278,
                "title": "neat-solution-with-explanation",
                "content": "# Explanation\\n`Object.keys(obj)` provided the key in an array. Fo instance, if the object is like below\\n```\\nconst obj = {\\n a: 1,\\n b: 2,\\n}\\n```\\n`Object.keys(obj)` returns `[\"a\",\"b\"]`. Now simply checking if the length of the array is 0 should suffice the need.\\n# Code\\n```\\n/**\\n * @param {Object | Array} obj\\n * @return {boolean}\\n */\\nvar isEmpty = function(obj) {\\n    return Object.keys(obj).length === 0\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nconst obj = {\\n a: 1,\\n b: 2,\\n}\\n```\n```\\n/**\\n * @param {Object | Array} obj\\n * @return {boolean}\\n */\\nvar isEmpty = function(obj) {\\n    return Object.keys(obj).length === 0\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4033127,
                "title": "detailed-explanation-detecting-empty-objects-in-javascript",
                "content": "# Intuition\\nIn this problem, we are trying to determine whether an object in JavaScript is empty or not. An empty object in JavaScript has no properties. The intuition behind this approach is that we can use the Object.keys(obj) method to obtain all the keys (properties) of the object as an array and then check if the length of that array is equal to zero. If the length is zero, we can conclude that the object is empty.\\n\\n# Approach\\nThe approach to solving this problem is quite straightforward:\\n\\n1 We use Object.keys(obj) to obtain an array of the keys of the obj object.\\n2 Then, we compare the length of that array with zero.\\n3 If the length is equal to zero, the function returns true, indicating that the object is empty.\\n4 If the length is not equal to zero, the function returns false, indicating that the object is not empty.\\n\\n# Complexity\\nTime complexity: O(n)\\n\\nWhere \\'n\\' is the number of properties in the object. The Object.keys(obj) method iterates through all the object\\'s properties once to obtain the keys, which has a linear time complexity in terms of the number of properties.\\n\\nSpace complexity: O(n)\\nThe space used depends on the number of properties in the object because we are creating an array with those keys. Therefore, the space complexity is also linear in terms of the number of properties.\\n\\n# Code\\n```\\nfunction isEmpty(obj){\\n    return Object.keys(obj).length === 0\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nfunction isEmpty(obj){\\n    return Object.keys(obj).length === 0\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4028445,
                "title": "typescript-solution-easy-simple-explained",
                "content": "# Intuition\\n\\nThe first thing I considered is that we have two data structures which are arrays and objects.\\n\\n# Approach\\n\\n1. Check the first the type of the input ( object or array).\\n2. If `isArray` then check its length.\\n3. If `isObject` then check the length of keys.\\n\\n\\n\\n# Complexity\\n- Time complexity: **O(1)**\\n\\n- Space complexity: **O(1)**\\n\\n# Code\\n```\\nfunction isEmpty(obj: Record<string, any> | any[]): boolean {\\n    if (Array.isArray(obj)) {\\n        return obj.length === 0;\\n    }\\n    return Object.keys(obj).length === 0;\\n};\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\nfunction isEmpty(obj: Record<string, any> | any[]): boolean {\\n    if (Array.isArray(obj)) {\\n        return obj.length === 0;\\n    }\\n    return Object.keys(obj).length === 0;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4028115,
                "title": "first-check-for-whether-obj-is-empty-or-not-with-object-entries-obj-then-check-the-length",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Object | Array} obj\\n * @return {boolean}\\n */\\nvar isEmpty = function (obj) {\\n    let value = Object.entries(obj)\\n    if (value.length) {\\n        return false;\\n    } else {\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Object | Array} obj\\n * @return {boolean}\\n */\\nvar isEmpty = function (obj) {\\n    let value = Object.entries(obj)\\n    if (value.length) {\\n        return false;\\n    } else {\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4022197,
                "title": "simple-and-one-liner",
                "content": "\\n# Code\\n```\\n/**\\n * @param {Object | Array} obj\\n * @return {boolean}\\n */\\nvar isEmpty = function (obj) {\\n    return Object.keys(obj).length == 0 && true;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Object | Array} obj\\n * @return {boolean}\\n */\\nvar isEmpty = function (obj) {\\n    return Object.keys(obj).length == 0 && true;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4021588,
                "title": "is-object-empty-solution",
                "content": "# Intuition\\nChecking  if an object or array is empty.\\n\\n# Approach\\nWe can use the `Object.keys(obj).length` method to determine the number of keys in the object or the length of the array.\\nIf the length is equal to 0, the object or array is empty, and we return true. Otherwise, we return false.\\n\\n# Complexity\\n- Time complexity:\\n Time complexity: O(n), where n is the number of keys in the object or the length of the array.\\n- Space complexity: O(1), as we don\\'t use any additional data structures.\\n\\n# Code\\n```\\n/**\\n * @param {Object | Array} obj\\n * @return {boolean}\\n */\\nvar isEmpty = function(obj) {\\n   if(Object.keys(obj).length === 0){\\n       return true;\\n   }\\n   else {\\n       return false; \\n   }\\n     \\n    \\n    \\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Object | Array} obj\\n * @return {boolean}\\n */\\nvar isEmpty = function(obj) {\\n   if(Object.keys(obj).length === 0){\\n       return true;\\n   }\\n   else {\\n       return false; \\n   }\\n     \\n    \\n    \\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4018904,
                "title": "simple-elegant-one-liner",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Object | Array} obj\\n * @return {boolean}\\n */\\nvar isEmpty = function(obj) {\\n  return !Object.entries(obj).length;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Object | Array} obj\\n * @return {boolean}\\n */\\nvar isEmpty = function(obj) {\\n  return !Object.entries(obj).length;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4006524,
                "title": "javascript-easy-simple-and-fast",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Object | Array} obj\\n * @return {boolean}\\n */\\nvar isEmpty = function(obj) {\\n    if(Array.isArray(obj) && obj.length>0){return false;}\\n    else if ( Object.keys(obj).length>0){return false}\\n    return true;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Object | Array} obj\\n * @return {boolean}\\n */\\nvar isEmpty = function(obj) {\\n    if(Array.isArray(obj) && obj.length>0){return false;}\\n    else if ( Object.keys(obj).length>0){return false}\\n    return true;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4001417,
                "title": "one-line-solution",
                "content": "# Code\\n```\\nconst isEmpty = (obj) => Object.keys(obj).length <= 0;\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nconst isEmpty = (obj) => Object.keys(obj).length <= 0;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4000086,
                "title": "fastest-1-liner",
                "content": "# Intuition\\n![isEmpty.png](https://assets.leetcode.com/users/images/002b1ee6-0a88-46c6-a8e7-916a651723c7_1693811414.3990874.png)\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Object | Array} obj\\n * @return {boolean}\\n */\\nvar isEmpty =  obj => Object.keys(obj).length === 0;\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Object | Array} obj\\n * @return {boolean}\\n */\\nvar isEmpty =  obj => Object.keys(obj).length === 0;\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3999432,
                "title": "every-case-checked-and-commented",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Object | Array} obj\\n * @return {boolean}\\n */\\nvar isEmpty = function(obj) {\\n  if (Array.isArray(obj)) {\\n    return obj.length === 0; // Check for empty array\\n  }\\n\\n  if (typeof obj === \"object\") {\\n    for (var prop in obj) {\\n      if (obj.hasOwnProperty(prop)) {\\n        return false; // Return false if any property is found\\n      }\\n    }\\n  }\\n\\n  return true; // If no properties were found (or not an array), return true\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Object | Array} obj\\n * @return {boolean}\\n */\\nvar isEmpty = function(obj) {\\n  if (Array.isArray(obj)) {\\n    return obj.length === 0; // Check for empty array\\n  }\\n\\n  if (typeof obj === \"object\") {\\n    for (var prop in obj) {\\n      if (obj.hasOwnProperty(prop)) {\\n        return false; // Return false if any property is found\\n      }\\n    }\\n  }\\n\\n  return true; // If no properties were found (or not an array), return true\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3997312,
                "title": "interview-tips",
                "content": "# Interview Tips:\\n\\n- What is the difference between an empty object and an object with no properties?\\n    - An empty object refers to an object that does not have any key-value pairs. It means that the object does not contain any properties. On the other hand, an object with no properties still exists and may have properties in the future. It simply means that it currently does not have any properties defined.\\n\\n- How can you check if an object is empty in JavaScript without using the length of its keys?\\n    - Another way to check if an object is empty without using the length of its keys is by using the Object.keys() method. This method returns an array of the object\\'s own enumerable property names (keys). You can then check if the length of the array is zero to determine if the object is empty.\\n\\n- What is a Plain Old JavaScript Object (POJO)?\\n    - A Plain Old JavaScript Object (POJO) is a term used to describe a simple JavaScript object that is created using the object literal syntax or the Object() constructor. It refers to an object that does not have any specialized behavior or methods inherited from custom prototypes or built-in JavaScript classes. POJOs are often used as data transfer objects (DTOs) or as simple containers for storing and accessing data.\\n",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "# Interview Tips:\\n\\n- What is the difference between an empty object and an object with no properties?\\n    - An empty object refers to an object that does not have any key-value pairs. It means that the object does not contain any properties. On the other hand, an object with no properties still exists and may have properties in the future. It simply means that it currently does not have any properties defined.\\n\\n- How can you check if an object is empty in JavaScript without using the length of its keys?\\n    - Another way to check if an object is empty without using the length of its keys is by using the Object.keys() method. This method returns an array of the object\\'s own enumerable property names (keys). You can then check if the length of the array is zero to determine if the object is empty.\\n\\n- What is a Plain Old JavaScript Object (POJO)?\\n    - A Plain Old JavaScript Object (POJO) is a term used to describe a simple JavaScript object that is created using the object literal syntax or the Object() constructor. It refers to an object that does not have any specialized behavior or methods inherited from custom prototypes or built-in JavaScript classes. POJOs are often used as data transfer objects (DTOs) or as simple containers for storing and accessing data.\\n",
                "codeTag": "Java"
            },
            {
                "id": 3995984,
                "title": "javascript-object-keys",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Object | Array} obj\\n * @return {boolean}\\n */\\nvar isEmpty = function(obj) {\\n    if(Object.keys(obj).length > 0){\\n        return false;\\n    }else{\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Object | Array} obj\\n * @return {boolean}\\n */\\nvar isEmpty = function(obj) {\\n    if(Object.keys(obj).length > 0){\\n        return false;\\n    }else{\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3995785,
                "title": "typescript-one-liner-using-object-keys-static-method-and-bitwise-operator",
                "content": "# Intuition\\n\\nThe built-in static method `Object.keys` returns an array iterable of all of the property names of an object, and the property names of an array object are the values in the array.\\n\\n# Approach\\n\\nSimply check if `Object.keys(obj)` returns an empty iterable.\\n\\n# Complexity\\n\\n* Time Complexity\\n$$O(n)$$\\n* Space complexity\\n$$O(1)$$\\n\\n# Code\\n```\\nfunction isEmpty(obj: Record<string, any> | any[]): boolean {\\n    return Object.keys(obj).reduce((acc, _) => acc | 1, 0) == 0\\n};\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\nfunction isEmpty(obj: Record<string, any> | any[]): boolean {\\n    return Object.keys(obj).reduce((acc, _) => acc | 1, 0) == 0\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3987308,
                "title": "javascript-simple-solution",
                "content": "# Complexity\\n- Time complexity: $$O(1)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Object | Array} obj\\n * @return {boolean}\\n */\\nvar isEmpty = function(obj) {\\n    for (const _ in obj) return false;\\n    return true;\\n};\\n```\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Object | Array} obj\\n * @return {boolean}\\n */\\nvar isEmpty = function(obj) {\\n    for (const _ in obj) return false;\\n    return true;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3985362,
                "title": "typescript-solution",
                "content": "```\\nfunction isEmpty(obj: Record<string, any> | any[]): boolean {\\n    const keys: any[] = Object.keys(obj);\\n    return !keys.length;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "```\\nfunction isEmpty(obj: Record<string, any> | any[]): boolean {\\n    const keys: any[] = Object.keys(obj);\\n    return !keys.length;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3982890,
                "title": "simple-one-liner-solution",
                "content": "# Simple One-liner Solution\\n\\n```\\n/**\\n * @param {Object | Array} obj\\n * @return {boolean}\\n */\\nconst isEmpty = (obj) => [\"{}\", \"[]\"].includes(JSON.stringify(obj));\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Object | Array} obj\\n * @return {boolean}\\n */\\nconst isEmpty = (obj) => [\"{}\", \"[]\"].includes(JSON.stringify(obj));\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3979934,
                "title": "solution-in-one-line-using-javascript",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Object | Array} obj\\n * @return {boolean}\\n */\\nlet isEmpty = obj => {return Object.keys(obj).length === 0};\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Object | Array} obj\\n * @return {boolean}\\n */\\nlet isEmpty = obj => {return Object.keys(obj).length === 0};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3977398,
                "title": "js-most-descriptive-and-understandable-instanceof",
                "content": "# Intuition\\nNot the shortest but the most descriptive. All the solutions submitted cause some sort of cognitive load.\\n\\n# Approach\\n- Check if it\\'s an object\\n    - Check item length \\n- Check if it\\'s an array\\n    - Check item length\\n\\n# Code\\n```\\n/**\\n * @param {Object | Array} obj\\n * @return {boolean}\\n */\\nvar isEmpty = function(obj) {\\n    if (obj instanceof Object)\\n        return Object.values(obj).length === 0;\\n    \\n    if (obj instanceof Array)\\n        return array.length === 0;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Object | Array} obj\\n * @return {boolean}\\n */\\nvar isEmpty = function(obj) {\\n    if (obj instanceof Object)\\n        return Object.values(obj).length === 0;\\n    \\n    if (obj instanceof Array)\\n        return array.length === 0;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3971775,
                "title": "",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Object | Array} obj\\n * @return {boolean}\\n */\\nvar isEmpty = function(obj) {\\n  return !Object.keys(obj).length ? true : false\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Object | Array} obj\\n * @return {boolean}\\n */\\nvar isEmpty = function(obj) {\\n  return !Object.keys(obj).length ? true : false\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3970491,
                "title": "ezz-js-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Object | Array} obj\\n * @return {boolean}\\n */\\nvar isEmpty = function (obj) {\\n    if (Object.keys(obj).length !== 0)\\n        return false\\n    else\\n        return true\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Object | Array} obj\\n * @return {boolean}\\n */\\nvar isEmpty = function (obj) {\\n    if (Object.keys(obj).length !== 0)\\n        return false\\n    else\\n        return true\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3962807,
                "title": "one-line-solution-with-object-keys",
                "content": "```\\n/**\\n * @param {Object | Array} obj\\n * @return {boolean}\\n */\\nvar isEmpty = function(obj) {\\n    return Object.keys(obj).length === 0\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Object | Array} obj\\n * @return {boolean}\\n */\\nvar isEmpty = function(obj) {\\n    return Object.keys(obj).length === 0\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3962080,
                "title": "object-empty-solution",
                "content": "# Code\\n```\\n/**\\n * @param {Object | Array} obj\\n * @return {boolean}\\n */\\nvar isEmpty = function(obj) {\\n    return Object.keys(obj).length === 0;\\n};\\n\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Object | Array} obj\\n * @return {boolean}\\n */\\nvar isEmpty = function(obj) {\\n    return Object.keys(obj).length === 0;\\n};\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3961705,
                "title": "oneline-liner-very-easy-javascript-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Object | Array} obj\\n * @return {boolean}\\n */\\nvar isEmpty = function(obj) {\\n  return Object.keys(obj).length == 0  \\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Object | Array} obj\\n * @return {boolean}\\n */\\nvar isEmpty = function(obj) {\\n  return Object.keys(obj).length == 0  \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3958628,
                "title": "js-clear-one-line-solution",
                "content": "\\n\\n# Code\\n```\\n\\nvar isEmpty = function(obj) {\\n    return Object.keys(obj).length === 0;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n\\nvar isEmpty = function(obj) {\\n    return Object.keys(obj).length === 0;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3955685,
                "title": "js-easy-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Object | Array} obj\\n * @return {boolean}\\n */\\nvar isEmpty = function(obj) {\\n    \\n    var c=0;\\n    for(var k in obj){\\n        c++;\\n    }\\n\\n    return c==0;\\n\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Object | Array} obj\\n * @return {boolean}\\n */\\nvar isEmpty = function(obj) {\\n    \\n    var c=0;\\n    for(var k in obj){\\n        c++;\\n    }\\n\\n    return c==0;\\n\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3953511,
                "title": "using-object-keys-method",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Object | Array} obj\\n * @return {boolean}\\n */\\nvar isEmpty = function(obj) {\\n   return !Object.keys(obj).length \\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Object | Array} obj\\n * @return {boolean}\\n */\\nvar isEmpty = function(obj) {\\n   return !Object.keys(obj).length \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3952456,
                "title": "simple-1-liner-return-object-keys-obj-length-0",
                "content": "```\\nvar isEmpty = function(obj) {\\n    return Object.keys(obj).length == 0;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar isEmpty = function(obj) {\\n    return Object.keys(obj).length == 0;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3952376,
                "title": "2-simple-approaches-with-tc-o-1",
                "content": "\\n# Complexity\\n- Time complexity:$$O(1)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n//TC,SC - O(1) \\n/**\\n * @param {Object | Array} obj\\n * @return {boolean}\\n */\\nvar isEmpty = function(obj) {\\n    for(const _ in obj)\\n      return false;\\n    \\n    return true;\\n};\\n```\\n```\\n//TC,SC - O(n) \\nvar isEmpty = function(obj) {\\n    return !(Object.keys(obj).length);\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n//TC,SC - O(1) \\n/**\\n * @param {Object | Array} obj\\n * @return {boolean}\\n */\\nvar isEmpty = function(obj) {\\n    for(const _ in obj)\\n      return false;\\n    \\n    return true;\\n};\\n```\n```\\n//TC,SC - O(n) \\nvar isEmpty = function(obj) {\\n    return !(Object.keys(obj).length);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3949321,
                "title": "simple-basic-solution-in-o-1",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Object | Array} obj\\n * @return {boolean}\\n */\\nvar isEmpty = function(obj) {\\n  let isEmpty = true  \\n  let length = Object.keys(obj).length;\\n  if(length>0){\\n      isEmpty = false;\\n  }\\n  let lengthofArray = obj.length;\\n  if(lengthofArray >0){\\n      isEmpty = false;\\n  }\\n  return isEmpty;\\n    \\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Object | Array} obj\\n * @return {boolean}\\n */\\nvar isEmpty = function(obj) {\\n  let isEmpty = true  \\n  let length = Object.keys(obj).length;\\n  if(length>0){\\n      isEmpty = false;\\n  }\\n  let lengthofArray = obj.length;\\n  if(lengthofArray >0){\\n      isEmpty = false;\\n  }\\n  return isEmpty;\\n    \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3944928,
                "title": "javascript-one-liner",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Object | Array} obj\\n * @return {boolean}\\n */\\nvar isEmpty = function(obj) {\\n    return !Object.keys(obj).length\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Object | Array} obj\\n * @return {boolean}\\n */\\nvar isEmpty = function(obj) {\\n    return !Object.keys(obj).length\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3943632,
                "title": "my-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Object | Array} obj\\n * @return {boolean}\\n */\\nvar isEmpty = function(obj) {\\n    if(Object.keys(obj).length==0)\\n    return true\\n    else\\n    return false\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Object | Array} obj\\n * @return {boolean}\\n */\\nvar isEmpty = function(obj) {\\n    if(Object.keys(obj).length==0)\\n    return true\\n    else\\n    return false\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3942150,
                "title": "solution-using-built-in-methods",
                "content": "# Intuition\\nI done this with bulit-in method\\n\\n# Approach\\ntype of the object and array are \"object\" so we cant understand it is array or not!.\\nThere is a function in js called isArray() that checks given value is array or not. if it not that means it is a object, i\\'m getting the keys and its length, if it has keys the length not be 0 (obj is not empty)\\n\\n# Complexity\\n- Time complexity:\\nO(1)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\n// is Object Empty\\n\\n/**\\n * @param {Object | Array} obj\\n * @return {boolean}\\n */\\nvar isEmpty = function (obj) {\\n    if (Array.isArray(obj)) {\\n        return obj.length === 0;\\n    } else {\\n       return Object.keys(obj).length === 0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n// is Object Empty\\n\\n/**\\n * @param {Object | Array} obj\\n * @return {boolean}\\n */\\nvar isEmpty = function (obj) {\\n    if (Array.isArray(obj)) {\\n        return obj.length === 0;\\n    } else {\\n       return Object.keys(obj).length === 0;\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3941712,
                "title": "simple-one-liner",
                "content": "# Code\\n```\\n/**\\n * @param {Object | Array} obj\\n * @return {boolean}\\n */\\nvar isEmpty = function(obj) {\\n    return !Object.keys(obj).length\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Object | Array} obj\\n * @return {boolean}\\n */\\nvar isEmpty = function(obj) {\\n    return !Object.keys(obj).length\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3940749,
                "title": "simple-solution-using-javascript-concept",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(1)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    O(1)\\n    here no extra space is used so space Complexity O(1)\\n# Code\\n```\\n/**\\n * @param {Object | Array} obj\\n * @return {boolean}\\n */\\nvar isEmpty = function(obj) {\\n    if(Object.keys(obj).length === 0)\\n        return true\\n    else\\n        return false    \\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Object | Array} obj\\n * @return {boolean}\\n */\\nvar isEmpty = function(obj) {\\n    if(Object.keys(obj).length === 0)\\n        return true\\n    else\\n        return false    \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3940712,
                "title": "easy-simple-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Object | Array} obj\\n * @return {boolean}\\n */\\nvar isEmpty = function(obj) {\\n    if(Object.keys(obj).length===0)\\n        return true;\\n    else\\n        return false;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Object | Array} obj\\n * @return {boolean}\\n */\\nvar isEmpty = function(obj) {\\n    if(Object.keys(obj).length===0)\\n        return true;\\n    else\\n        return false;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3938582,
                "title": "simple-solution-using-object-entries-method",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Object | Array} obj\\n * @return {boolean}\\n */\\nvar isEmpty = function(obj) {\\n    return Object.entries(obj).length == 0 ? true : false;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Object | Array} obj\\n * @return {boolean}\\n */\\nvar isEmpty = function(obj) {\\n    return Object.entries(obj).length == 0 ? true : false;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3937201,
                "title": "solution",
                "content": "# Code\\n```\\n/**\\n * @param {Object | Array} obj\\n * @return {boolean}\\n */\\nvar isEmpty = function(obj) {\\n    return !Object.keys(obj).length > 0;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Object | Array} obj\\n * @return {boolean}\\n */\\nvar isEmpty = function(obj) {\\n    return !Object.keys(obj).length > 0;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3934448,
                "title": "beats-99-commented",
                "content": "# Code\\n```\\n// If the length is zero, it returns true\\nvar isEmpty = (obj) => !Object.keys(obj).length\\n```\\n![image.png](https://assets.leetcode.com/users/images/ab0bbbe6-ad0d-4a3b-910f-3df474859793_1692506773.1769793.png)\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n// If the length is zero, it returns true\\nvar isEmpty = (obj) => !Object.keys(obj).length\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3932708,
                "title": "typescript-simple-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nfunction isEmpty(obj: Record<string, any> | any[]): boolean {\\n    return Object.keys( obj ).length === 0\\n};\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\nfunction isEmpty(obj: Record<string, any> | any[]): boolean {\\n    return Object.keys( obj ).length === 0\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3928159,
                "title": "one-line",
                "content": "\\n# Code\\n```\\n/**\\n * @param {Object | Array} obj\\n * @return {boolean}\\n */\\nconst isEmpty = (obj) => !Boolean(Object.keys(obj).length)\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Object | Array} obj\\n * @return {boolean}\\n */\\nconst isEmpty = (obj) => !Boolean(Object.keys(obj).length)\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3927767,
                "title": "my-solution-to-the-is-object-empty-question",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe problem just wanted us to output true if the object was empty and false of it had a key value pair which is simply just a property. My first intuituon was to use the `Object.key()` method that allows us find the properties of the object that we pass.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe approach that i took here composed of assigning the length of the array that is produced form the `Object.key()` method. From there I just used some reverse logic to evaluate whether was empty and therefore return  the results as required by the problem.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Object | Array} obj\\n * @return {boolean}\\n */\\nvar isEmpty = function(obj) {\\n    let Empty = Object.keys(obj).length;\\n\\n    if(Empty> 0) return false;\\n    return true;\\n    \\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Object | Array} obj\\n * @return {boolean}\\n */\\nvar isEmpty = function(obj) {\\n    let Empty = Object.keys(obj).length;\\n\\n    if(Empty> 0) return false;\\n    return true;\\n    \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3924590,
                "title": "beginner-solution",
                "content": "# Explanation\\n\\n1st check if obj is an Object and has keys\\n2nd check if obj is an Array and its length is 0\\n\\n\\n# Code\\n```\\n/**\\n * @param {Object | Array} obj\\n * @return {boolean}\\n */\\nvar isEmpty = function(obj) {\\n    return Object.keys(obj).length === 0 ||\\n        Array.isArray(obj) && !obj.length;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Object | Array} obj\\n * @return {boolean}\\n */\\nvar isEmpty = function(obj) {\\n    return Object.keys(obj).length === 0 ||\\n        Array.isArray(obj) && !obj.length;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3918891,
                "title": "beats-80-15-of-users-with-javascript",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Object | Array} obj\\n * @return {boolean}\\n */\\nvar isEmpty = function(obj) {\\n    return !Object.values(obj).length\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Object | Array} obj\\n * @return {boolean}\\n */\\nvar isEmpty = function(obj) {\\n    return !Object.values(obj).length\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3917090,
                "title": "easy-javascript-solution-one-line-code",
                "content": "> Vote Up If You Like the Solution\\n\\n# Code\\n```\\n/**\\n * @param {Object | Array} obj\\n * @return {boolean}\\n */\\nvar isEmpty = function(obj) {\\n    // console.log(Object.keys(obj))\\n    if(Object.values(obj).length){\\n        return false\\n    }\\n    return true\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Object | Array} obj\\n * @return {boolean}\\n */\\nvar isEmpty = function(obj) {\\n    // console.log(Object.keys(obj))\\n    if(Object.values(obj).length){\\n        return false\\n    }\\n    return true\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3915138,
                "title": "easy-way-to-solve-without-ternary-operator-just-boolean",
                "content": "# Intuition\\nTransform the object into array and then check if there is elements in it. \\nIf the array is empty then Object.values(object).length will give 0 and the reverse of 0 is 1 wich is true. The reverse of any other number is false\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Code\\n```\\n/**\\n * @param {Object | Array} obj\\n * @return {boolean}\\n */\\nvar isEmpty = function(obj) {\\n    return !Object.values(obj).length\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Object | Array} obj\\n * @return {boolean}\\n */\\nvar isEmpty = function(obj) {\\n    return !Object.values(obj).length\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3914291,
                "title": "typescript-solution-3-different-ways",
                "content": "**for\\u2026in**\\nThis statement will loop through the enumerable property of the object.\\n```\\nfunction isEmpty(obj: Record<string, any> | any[]): boolean {\\n    for (const prop in obj) {\\n        if (obj.hasOwnProperty(prop)) {\\n            return false;\\n        }   \\n    }\\n    return true;\\n};\\n```\\n\\n**Object.keys**\\nIt will return an array, which contains the property names of the object. If the length of the array is 0, then we know that the object is empty. **(In my opinion, this is the easiest)**\\n```\\nfunction isEmpty(obj: Record<string, any> | any[]): boolean {\\n    return Object.keys(obj).length === 0;\\n};\\n```\\n\\n**JSON.stringify**\\nThe object and the result is simply an opening and closing bracket, we know the object is empty.\\n```\\nfunction isEmpty(obj: Record<string, any> | any[]): boolean {\\n   return JSON.stringify(obj) === \\'{}\\' || JSON.stringify(obj) === \\'[]\\';\\n};\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\nfunction isEmpty(obj: Record<string, any> | any[]): boolean {\\n    for (const prop in obj) {\\n        if (obj.hasOwnProperty(prop)) {\\n            return false;\\n        }   \\n    }\\n    return true;\\n};\\n```\n```\\nfunction isEmpty(obj: Record<string, any> | any[]): boolean {\\n    return Object.keys(obj).length === 0;\\n};\\n```\n```\\nfunction isEmpty(obj: Record<string, any> | any[]): boolean {\\n   return JSON.stringify(obj) === \\'{}\\' || JSON.stringify(obj) === \\'[]\\';\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3913712,
                "title": "easy-solution-please-upvote-if-its-help",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Object | Array} obj\\n * @return {boolean}\\n */\\nvar isEmpty = function(obj) {\\n    return Object.keys(obj).length==0 ?true:false\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Object | Array} obj\\n * @return {boolean}\\n */\\nvar isEmpty = function(obj) {\\n    return Object.keys(obj).length==0 ?true:false\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3910995,
                "title": "using-error-handling",
                "content": "\\n\\n# Code\\n```\\nvar isEmpty = function(obj) {\\n    try{\\n       if(Object.keys(obj).length==0){\\n           return true;\\n       }\\n       return false;\\n    }catch(err){\\n        return obj.length===0\\n    }\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar isEmpty = function(obj) {\\n    try{\\n       if(Object.keys(obj).length==0){\\n           return true;\\n       }\\n       return false;\\n    }catch(err){\\n        return obj.length===0\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3899162,
                "title": "easy-fast-javascript",
                "content": "\\n\\n# Code\\n```\\n/**\\n * @param {Object | Array} obj\\n * @return {boolean}\\n */\\nvar isEmpty = function(obj) {\\n    for(let o in obj ){return false;}return true;};\\n\\n\\n\\n\\n2nd approach\\n\\n/** var isEmpty = function(obj) {\\n    if(Object.keys(obj).length === 0){\\n        return true;\\n    }\\n    else{\\n        return false;\\n    }\\n}; */*\\n```\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Object | Array} obj\\n * @return {boolean}\\n */\\nvar isEmpty = function(obj) {\\n    for(let o in obj ){return false;}return true;};\\n\\n\\n\\n\\n2nd approach\\n\\n/** var isEmpty = function(obj) {\\n    if(Object.keys(obj).length === 0){\\n        return true;\\n    }\\n    else{\\n        return false;\\n    }\\n}; */*\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3897592,
                "title": "simple-solution",
                "content": "\\n# Code\\n```\\n/**\\n * @param {Object | Array} obj\\n * @return {boolean}\\n */\\nvar isEmpty = function(obj) {\\n    // Check if obj is an object or an array\\n    if (typeof obj === \"object\" && obj !== null) {\\n        // Get the keys of the object or the length of the array\\n        var keys = Object.keys(obj);\\n        // Return true if there are no keys or false otherwise\\n        return keys.length === 0;\\n    } else {\\n        // Return false for invalid input\\n        return false;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Object | Array} obj\\n * @return {boolean}\\n */\\nvar isEmpty = function(obj) {\\n    // Check if obj is an object or an array\\n    if (typeof obj === \"object\" && obj !== null) {\\n        // Get the keys of the object or the length of the array\\n        var keys = Object.keys(obj);\\n        // Return true if there are no keys or false otherwise\\n        return keys.length === 0;\\n    } else {\\n        // Return false for invalid input\\n        return false;\\n    }\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3894009,
                "title": "1-line-code-with-explanation-simplest-solution-with-minimal-code",
                "content": "# Intuition\\nThese approach emphasizes achieving **performance with minimal code**.\\n\\n# Approach\\nTo better comprehend the solution, it\\'s crucial to grasp the nature of arrays in JavaScript.\\n\\n**What are Arrays In Javasript?**\\n\\nArrays in JavaScript are a **specific type of object**. While arrays have a numeric index that starts from 0 and continues sequentially, they are still objects and can have additional properties and methods.\\n\\nWhen we call Object.keys(array), **it works because arrays are objects** that inherit properties and methods from the Object prototype. The Object.keys() function retrieves the enumerable property names (keys) of an object, including its prototype chain.\\n\\n**Concept in Action:**\\n\\nGiven that arrays are essentially objects, we can **avoid adding specific conditions** for array vs. object differentiation. Instead, we can directly Object.keys, simplifying the solution to a single line using **Arrow functions** and an **implicit return statement**.\\n\\nPlease **Upvote** if you find helpful.\\n\\n# Code\\n```\\n/**\\n * @param {Object | Array} obj\\n * @return {boolean}\\n */\\nvar isEmpty = (obj) => Object.keys(obj).length ? false : true;\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Object | Array} obj\\n * @return {boolean}\\n */\\nvar isEmpty = (obj) => Object.keys(obj).length ? false : true;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3890276,
                "title": "excellent-best-answer-than-almost-95-javascript-users",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWow best answer than almost 95% javascript users!\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nDetermines the length of the given object or array and returns true or false. Since it is not possible to determine the direct length of the object, we use the Object.keys() method, which returns us an array of the keys of this object.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    46ms Beats 94.77% of users with JavaScript\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    42.20mb Beats 93.07% of users with JavaScript\\n# Code\\n```\\n/**\\n * @param {Object | Array} obj\\n * @return {boolean}\\n */\\nvar isEmpty = function(obj) {\\n    let leng = Object.keys(obj).length\\n    return leng > 0 ? false : true\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Object | Array} obj\\n * @return {boolean}\\n */\\nvar isEmpty = function(obj) {\\n    let leng = Object.keys(obj).length\\n    return leng > 0 ? false : true\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3886411,
                "title": "beats-99-42-users-tc-and-sc-is-o-1",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nFirst make sure that the obj is Array or object and will check for its length and the length is in negative then return true else false\\n\\n# Complexity\\n- Time complexity:O(1)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Object | Array} obj\\n * @return {boolean}\\n */\\nvar isEmpty = function(obj) {\\n    const isArray = Array.isArray(obj)\\n    const isObj = obj instanceof Object\\n    if(isArray){\\n        return !obj.length\\n    }\\n    else if(isObj){\\n     return !Object.keys(obj).length\\n    }\\n    return false\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Object | Array} obj\\n * @return {boolean}\\n */\\nvar isEmpty = function(obj) {\\n    const isArray = Array.isArray(obj)\\n    const isObj = obj instanceof Object\\n    if(isArray){\\n        return !obj.length\\n    }\\n    else if(isObj){\\n     return !Object.keys(obj).length\\n    }\\n    return false\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3885062,
                "title": "javascript-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Object | Array} obj\\n * @return {boolean}\\n */\\nvar isEmpty = function(obj) {\\n    return Object.keys(obj).length ? false : true\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Object | Array} obj\\n * @return {boolean}\\n */\\nvar isEmpty = function(obj) {\\n    return Object.keys(obj).length ? false : true\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3880782,
                "title": "accepted-javascript",
                "content": "```\\nvar isEmpty = function(obj) {\\n    let json = JSON.stringify(obj);\\n    return json == \"{}\" || json == \"[]\";\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar isEmpty = function(obj) {\\n    let json = JSON.stringify(obj);\\n    return json == \"{}\" || json == \"[]\";\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3880519,
                "title": "solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Object | Array} obj\\n * @return {boolean}\\n */\\nvar isEmpty = function(obj) {\\n    if(Object.keys(obj).length == 0) {\\n       return true\\n    }else{\\n       return false\\n    }\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Object | Array} obj\\n * @return {boolean}\\n */\\nvar isEmpty = function(obj) {\\n    if(Object.keys(obj).length == 0) {\\n       return true\\n    }else{\\n       return false\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3879304,
                "title": "simple-javascript",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nWe can find the length of an Object literals by Object.keys(OBJ_NAME).legnth\\nif the value > 0 which means it has keys and values so we return false\\notherwise we return true;\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Object | Array} obj\\n * @return {boolean}\\n */\\nvar isEmpty = function(obj) {\\n    var l = Object.keys(obj).length;\\n    return l == 0;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Object | Array} obj\\n * @return {boolean}\\n */\\nvar isEmpty = function(obj) {\\n    var l = Object.keys(obj).length;\\n    return l == 0;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3878900,
                "title": "very-easy-short-solution-javascript",
                "content": "# Code\\n```\\nvar isEmpty = (obj) => Object.values(obj).length === 0 ? true : false;\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar isEmpty = (obj) => Object.values(obj).length === 0 ? true : false;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3876868,
                "title": "2727-is-object-empty",
                "content": "```\\n/**\\n * @param {Object | Array} obj\\n * @return {boolean}\\n */\\nvar isEmpty = function(obj) {\\n    return Object.keys(obj).length === 0;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Object | Array} obj\\n * @return {boolean}\\n */\\nvar isEmpty = function(obj) {\\n    return Object.keys(obj).length === 0;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3872416,
                "title": "javascript-one-liner-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Object | Array} obj\\n * @return {boolean}\\n */\\nvar isEmpty = function(obj) {\\n    return !(Object.keys(obj).length)\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Object | Array} obj\\n * @return {boolean}\\n */\\nvar isEmpty = function(obj) {\\n    return !(Object.keys(obj).length)\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3867295,
                "title": "js-easy-solution",
                "content": "\\n```\\n/**\\n * @param {Object | Array} obj\\n * @return {boolean}\\n */\\nvar isEmpty = function(obj) {\\n    if(Object.values(obj).length==0 && Object.keys(obj).length==0)return true;\\n    return false;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Object | Array} obj\\n * @return {boolean}\\n */\\nvar isEmpty = function(obj) {\\n    if(Object.values(obj).length==0 && Object.keys(obj).length==0)return true;\\n    return false;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3858207,
                "title": "for-loop",
                "content": "# Code\\n```\\n/**\\n * @param {Object | Array} obj\\n * @return {boolean}\\n */\\nvar isEmpty = function(obj) {\\n    for (let i in obj) \\n        return false\\n    return true\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Object | Array} obj\\n * @return {boolean}\\n */\\nvar isEmpty = function(obj) {\\n    for (let i in obj) \\n        return false\\n    return true\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3855741,
                "title": "simple-js-solution",
                "content": "\\n```\\n/**\\n * @param {Object | Array} obj\\n * @return {boolean}\\n */\\nvar isEmpty = function(obj) {\\n  const length = Array.isArray(obj) ? obj.length : Object.keys(obj).length;\\n  return !length;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Object | Array} obj\\n * @return {boolean}\\n */\\nvar isEmpty = function(obj) {\\n  const length = Array.isArray(obj) ? obj.length : Object.keys(obj).length;\\n  return !length;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3855669,
                "title": "fast-solution-50ms",
                "content": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/keys\\n# Code\\n```\\nvar isEmpty = function(obj) {\\n    return Object.keys(obj).length === 0;\\n};\\n```\\n### Runner up\\n```\\nvar isEmpty = function(obj) {\\n    return !Object.keys(obj).length;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar isEmpty = function(obj) {\\n    return Object.keys(obj).length === 0;\\n};\\n```\n```\\nvar isEmpty = function(obj) {\\n    return !Object.keys(obj).length;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3850733,
                "title": "easy-solution-using-object-keys-length",
                "content": "# Approach\\nUse Object.keys().length\\n\\n# Code\\n```\\nfunction isEmpty(obj: Record<string, any> | any[]): boolean {\\n    return Object.keys(obj).length == 0 ? true : false;\\n};\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\nfunction isEmpty(obj: Record<string, any> | any[]): boolean {\\n    return Object.keys(obj).length == 0 ? true : false;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3840465,
                "title": "is-object-empty-easy-javascript",
                "content": "\\n\\n# Code\\n```\\n/**\\n * @param {Object | Array} obj\\n * @return {boolean}\\n */\\nvar isEmpty = function(obj) {\\nif (Array.isArray(obj))\\n        return obj.length === 0;\\n    \\n    return Object.values(obj).length === 0;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Object | Array} obj\\n * @return {boolean}\\n */\\nvar isEmpty = function(obj) {\\nif (Array.isArray(obj))\\n        return obj.length === 0;\\n    \\n    return Object.values(obj).length === 0;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3837705,
                "title": "simple-solution-object-keys",
                "content": "# Code\\n```\\n/**\\n * @param {Object | Array} obj\\n * @return {boolean}\\n */\\nvar isEmpty = function (obj) {\\n  return !Object.keys(obj).length;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Object | Array} obj\\n * @return {boolean}\\n */\\nvar isEmpty = function (obj) {\\n  return !Object.keys(obj).length;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3837268,
                "title": "easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n\\nvar isEmpty = function(obj) {\\n  if (Array.isArray(obj)) {\\n    return obj.length === 0;\\n  } else if (typeof obj === \\'object\\' && obj !== null) {\\n    return Object.keys(obj).length === 0;\\n  }\\n  return false;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n\\nvar isEmpty = function(obj) {\\n  if (Array.isArray(obj)) {\\n    return obj.length === 0;\\n  } else if (typeof obj === \\'object\\' && obj !== null) {\\n    return Object.keys(obj).length === 0;\\n  }\\n  return false;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3831518,
                "title": "is-object-empty",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nfunction isEmpty(obj) {\\n  // Check if the input is an object\\n  if (typeof obj === \\'object\\' && obj !== null) {\\n    // For objects, check if it has any keys\\n    return Object.keys(obj).length === 0;\\n  } else if (Array.isArray(obj)) {\\n    // For arrays, check if it has any elements\\n    return obj.length === 0;\\n  }\\n\\n  // If the input is neither an object nor an array, consider it as empty\\n  return true;\\n}\\n\\n// Test with objects and arrays\\nconst emptyObject = {};\\nconst nonEmptyObject = { key: \\'value\\' };\\nconsole.log(isEmpty(emptyObject)); // Output: true\\nconsole.log(isEmpty(nonEmptyObject)); // Output: false\\n\\nconst emptyArray = [];\\nconst nonEmptyArray = [1, 2, 3];\\nconsole.log(isEmpty(emptyArray)); // Output: true\\nconsole.log(isEmpty(nonEmptyArray)); // Output: false\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nfunction isEmpty(obj) {\\n  // Check if the input is an object\\n  if (typeof obj === \\'object\\' && obj !== null) {\\n    // For objects, check if it has any keys\\n    return Object.keys(obj).length === 0;\\n  } else if (Array.isArray(obj)) {\\n    // For arrays, check if it has any elements\\n    return obj.length === 0;\\n  }\\n\\n  // If the input is neither an object nor an array, consider it as empty\\n  return true;\\n}\\n\\n// Test with objects and arrays\\nconst emptyObject = {};\\nconst nonEmptyObject = { key: \\'value\\' };\\nconsole.log(isEmpty(emptyObject)); // Output: true\\nconsole.log(isEmpty(nonEmptyObject)); // Output: false\\n\\nconst emptyArray = [];\\nconst nonEmptyArray = [1, 2, 3];\\nconsole.log(isEmpty(emptyArray)); // Output: true\\nconsole.log(isEmpty(nonEmptyArray)); // Output: false\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3830946,
                "title": "interesting-json-stringify-solution",
                "content": "# Code\\n```\\n/**\\n * @param {Object | Array} obj\\n * @return {boolean}\\n */\\nvar isEmpty = (obj) => JSON.stringify(obj).length === 2\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Object | Array} obj\\n * @return {boolean}\\n */\\nvar isEmpty = (obj) => JSON.stringify(obj).length === 2\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3830905,
                "title": "obj-length-for-arrays-objects-keys-obj-length-for-objects",
                "content": "# Code\\n```\\n/**\\n * @param {Object | Array} obj\\n * @return {boolean}\\n */\\nvar isEmpty = function(obj) {\\n    if(obj.length>0 || Object.keys(obj).length>0){\\n        return false\\n    }else{\\n        return true\\n    }\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Object | Array} obj\\n * @return {boolean}\\n */\\nvar isEmpty = function(obj) {\\n    if(obj.length>0 || Object.keys(obj).length>0){\\n        return false\\n    }else{\\n        return true\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3830647,
                "title": "ts-one-line-ternary-operator",
                "content": "# Code\\n```\\nfunction isEmpty(obj: Record<string, any> | any[]): boolean {\\n    return !(Array.isArray(obj) ? obj.length > 0 : Object.keys(obj).length > 0);\\n};\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\nfunction isEmpty(obj: Record<string, any> | any[]): boolean {\\n    return !(Array.isArray(obj) ? obj.length > 0 : Object.keys(obj).length > 0);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3830271,
                "title": "typescript-hasownproperty-beats-85-74",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nA quick foreach loop with a .hasOwnProperty check is all we need. https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/hasOwnProperty\\n\\nNote: .hasOwn is preferred over .hasOwnProperty, but the LeetCode backend doesn\\'t support that method yet. See: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/hasOwn\\n\\n# Approach\\nOne for loop with the hasOwnProperty check.\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```\\nfunction isEmpty(obj: Record<string, any> | any[]): boolean {\\n    for(let prop in obj) {\\n        if (obj.hasOwnProperty(prop)) {\\n            return false;\\n        }\\n    }\\n    return true;\\n};\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\nfunction isEmpty(obj: Record<string, any> | any[]): boolean {\\n    for(let prop in obj) {\\n        if (obj.hasOwnProperty(prop)) {\\n            return false;\\n        }\\n    }\\n    return true;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3827075,
                "title": "one-liner",
                "content": "# Code\\n```\\nfunction isEmpty(obj: Record<string, any> | any[]): boolean {\\n    return (Array.isArray(obj) && obj?.length === 0) \\n        || Object.getOwnPropertyNames(obj).length === 0;\\n};\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\nfunction isEmpty(obj: Record<string, any> | any[]): boolean {\\n    return (Array.isArray(obj) && obj?.length === 0) \\n        || Object.getOwnPropertyNames(obj).length === 0;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3826362,
                "title": "easy-to-understand-javascript-solution-with-simple-explanation",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. First we can check the type either if it\\'s object or array.\\n2. After getting the type if it\\'s object. We can use for in loop to traverse the object. If the execution goes inside the for in loop that\\'s mean the object is not empty it has key value pair.\\n3. If it\\'s array we can simply use the length check to determine if it\\'s empty or not.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Object | Array} obj\\n * @return {boolean}\\n */\\nvar isEmpty = function(obj) {\\n    const type = Array.isArray(obj);\\n    if(!type) {\\n        for(let key in obj) {\\n            return false;\\n        } return true;\\n    }\\n    return obj.length > 0 ? false : true;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Object | Array} obj\\n * @return {boolean}\\n */\\nvar isEmpty = function(obj) {\\n    const type = Array.isArray(obj);\\n    if(!type) {\\n        for(let key in obj) {\\n            return false;\\n        } return true;\\n    }\\n    return obj.length > 0 ? false : true;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3825094,
                "title": "js-solution-with-57-ms-runtime",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIterate through object to see if there is at least one key. \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nIf there is at least one key in the object, return true. Check edge case where the key is an empty string. Otherwise, the object is empty.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Object | Array} obj\\n * @return {boolean}\\n */\\nvar isEmpty = function(obj) {\\n\\n    console.log(\\'typeof obj= \\', typeof obj)\\n    for(key in obj){\\n        console.log(\\'key= \\', key)\\n        if(key === \"\"){\\n            return false;\\n        }\\n        if(key){\\n            return false;\\n        }\\n    }\\n    return true;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Object | Array} obj\\n * @return {boolean}\\n */\\nvar isEmpty = function(obj) {\\n\\n    console.log(\\'typeof obj= \\', typeof obj)\\n    for(key in obj){\\n        console.log(\\'key= \\', key)\\n        if(key === \"\"){\\n            return false;\\n        }\\n        if(key){\\n            return false;\\n        }\\n    }\\n    return true;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3823997,
                "title": "best-solution-to-find-empty-object",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSince they are asking to get the length, why not check if there are any keys in the object. If its an array then index will be the keys, and if its object then key specifically, will be tehe key.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe will here use the property of Object, Object.key(objName) which returns an array of keys, then we can apply Array.length to get the length of the array of keys.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n# Code\\n```\\n/**\\n * @param {Object | Array} obj\\n * @return {boolean}\\n */\\nvar isEmpty = function(obj) {\\n     return (Object.keys(obj).length === 0 ? true : false)\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Object | Array} obj\\n * @return {boolean}\\n */\\nvar isEmpty = function(obj) {\\n     return (Object.keys(obj).length === 0 ? true : false)\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3823293,
                "title": "easy-ts-solution",
                "content": "\\n\\n# Code\\n```\\nfunction isEmpty(obj: Record<string, any> | any[]): boolean {\\n  if (Array.isArray(obj)) return !obj.length;\\n  return !Object.keys(obj).length;\\n}\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\nfunction isEmpty(obj: Record<string, any> | any[]): boolean {\\n  if (Array.isArray(obj)) return !obj.length;\\n  return !Object.keys(obj).length;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3821673,
                "title": "answer-with-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nfunction isEmpty(obj) {\\n  if (Array.isArray(obj)) {\\n    return obj.length === 0;\\n  } else if (typeof obj === \"object\" && obj !== null) {\\n    return Object.keys(obj).length === 0;\\n  }\\n  return false;\\n}\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nfunction isEmpty(obj) {\\n  if (Array.isArray(obj)) {\\n    return obj.length === 0;\\n  } else if (typeof obj === \"object\" && obj !== null) {\\n    return Object.keys(obj).length === 0;\\n  }\\n  return false;\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3819089,
                "title": "a-very-easy-and-concise-code-with-a-simple-time-and-space-complexity",
                "content": "# Approach\\nThe function takes an input obj, which can be either an array or an object.\\n\\nIt first checks whether the input obj is an array using the Array.\\n\\nisArray(obj) method. If it is an array, it directly returns true if the array\\'s length is 0, indicating that the array is empty.\\n\\nIf the input obj is not an array (i.e., an object), it proceeds to the else block and converts the object\\'s values into an array using Object.values(obj).\\n\\nIt then checks whether the array\\'s length is 0. If it is 0, it means the object has no properties and is considered empty, so the function returns true.\\n\\nIf the array\\'s length is not 0, it means the object has properties, and the function returns false, indicating that the object is not empty.\\n\\n# Complexity\\n- Time complexity: O(1)\\n\\n- Space complexity: O(1)\\n\\n# Code\\n```\\n/**\\n * @param {Object | Array} obj\\n * @return {boolean}\\n */\\nvar isEmpty = function (obj) {\\n    if (Array.isArray(obj))\\n        return obj.length === 0;\\n    \\n    return Object.values(obj).length === 0;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Object | Array} obj\\n * @return {boolean}\\n */\\nvar isEmpty = function (obj) {\\n    if (Array.isArray(obj))\\n        return obj.length === 0;\\n    \\n    return Object.values(obj).length === 0;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3815886,
                "title": "easy-and-simple",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Object | Array} obj\\n * @return {boolean}\\n */\\nvar isEmpty = function(obj) {\\n    if(Array.isArray(obj) && !obj.length) return true\\n    if(!Object.entries(obj).length) return true;\\n    return false\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Object | Array} obj\\n * @return {boolean}\\n */\\nvar isEmpty = function(obj) {\\n    if(Array.isArray(obj) && !obj.length) return true\\n    if(!Object.entries(obj).length) return true;\\n    return false\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3814389,
                "title": "solution-using-object-keys-time-complexity-o-n-space-complexity-o-n",
                "content": "\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Object | Array} obj\\n * @return {boolean}\\n */\\nvar isEmpty = function(obj) {\\n    return Object.keys(obj).length === 0\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Object | Array} obj\\n * @return {boolean}\\n */\\nvar isEmpty = function(obj) {\\n    return Object.keys(obj).length === 0\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3811279,
                "title": "o-1-with-easy-approach",
                "content": "# Intuition\\nSince ES `Object` has the inbuilt `keys(k)` to check the properties, we do not need further code to check the available objects.\\n\\n# Approach\\nUsing `Object.keys(obj)` is sufficient for object types.\\n\\n# Complexity\\n- Time complexity:\\n$$O(1)$$\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```\\n/**\\n * @param {Object | Array} obj\\n * @return {boolean}\\n */\\nvar isEmpty = (obj) => Object.keys(obj).length < 1\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Object | Array} obj\\n * @return {boolean}\\n */\\nvar isEmpty = (obj) => Object.keys(obj).length < 1\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3809793,
                "title": "extra-simple-solution-to-determine-whether-your-object-is-empty-or-not",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Object | Array} obj\\n * @return {boolean}\\n */\\nconst isEmpty = (obj) => {\\n    return Object.keys(obj).length === 0\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Object | Array} obj\\n * @return {boolean}\\n */\\nconst isEmpty = (obj) => {\\n    return Object.keys(obj).length === 0\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3809425,
                "title": "soln-in-js",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Object | Array} obj\\n * @return {boolean}\\n */\\nvar isEmpty = function(obj)\\n{\\n    // return Object.keys(obj).lenght === 0;\\n    return Object.keys(obj).length === 0;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Object | Array} obj\\n * @return {boolean}\\n */\\nvar isEmpty = function(obj)\\n{\\n    // return Object.keys(obj).lenght === 0;\\n    return Object.keys(obj).length === 0;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3809343,
                "title": "is-object-empty",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Object | Array} obj\\n * @return {boolean}\\n */\\nvar isEmpty = function(obj) {\\n    return Object.keys(obj).length == 0 ? true : false\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Object | Array} obj\\n * @return {boolean}\\n */\\nvar isEmpty = function(obj) {\\n    return Object.keys(obj).length == 0 ? true : false\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3808989,
                "title": "simple-one-line-solution-using-object-keys-method",
                "content": "``` \\n return Object.keys(obj).length<1\\n \\n ```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "``` \\n return Object.keys(obj).length<1\\n \\n ```",
                "codeTag": "Unknown"
            },
            {
                "id": 3808803,
                "title": "study-what-object-entries-means-solution-by-junior",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Object | Array} obj\\n * @return {boolean}\\n */\\nvar isEmpty = function(obj) {\\n    return Object.entries(obj).length ? 0 : true\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Object | Array} obj\\n * @return {boolean}\\n */\\nvar isEmpty = function(obj) {\\n    return Object.entries(obj).length ? 0 : true\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3806607,
                "title": "simple-js-logic-beats-90",
                "content": "<!-- # Intuition -->\\nThe code defines a JavaScript function named isEmpty that takes an object obj as input.\\n\\nInside the function, it uses the Object.keys(obj) method to obtain an array containing all the property names (keys) of the input object.\\nThe length of the keys array is then checked using the keys.length property.\\nIf the length of keys is equal to zero, it means the object has no properties and is considered empty.\\nIn that case, the function returns true, indicating that the object is empty.\\nIf the keys array has a length greater than zero, it means the object has one or more properties and is not empty.\\nIn that case, the function returns false, indicating that the object is not empty.\\nThe function effectively determines if the object has any properties by checking the length of the keys array.\\nNote that the function does not consider properties from the object\\'s prototype chain, only its own properties.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n<!-- # Approach -->\\n<!-- Describe your approach to solving the problem. -->\\n\\n<!-- # Complexity -->\\n<!-- - Time complexity: -->\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n<!-- - Space complexity: -->\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Object | Array} obj\\n * @return {boolean}\\n */\\nvar isEmpty = function(obj) {\\n    const keys = Object.keys(obj)\\n    if(keys.length===0){\\n        return true\\n    }\\n    return false\\n    \\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Object | Array} obj\\n * @return {boolean}\\n */\\nvar isEmpty = function(obj) {\\n    const keys = Object.keys(obj)\\n    if(keys.length===0){\\n        return true\\n    }\\n    return false\\n    \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3805376,
                "title": "typescript-o-n",
                "content": "# Code\\n```ts\\nfunction isEmpty(obj: Record<string, any> | any[]): boolean {\\n    for (const _ in obj) return false;\\n    return true;\\n}\\n```\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n- Space complexity: $$O(n)$$",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```ts\\nfunction isEmpty(obj: Record<string, any> | any[]): boolean {\\n    for (const _ in obj) return false;\\n    return true;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3802523,
                "title": "clean-and-crisp",
                "content": "\\n# Code\\n```\\n/**\\n * @param {Object | Array} obj\\n * @return {boolean}\\n */\\nconst isEmpty = obj=> Object.keys(obj).length === 0\\n\\n\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Object | Array} obj\\n * @return {boolean}\\n */\\nconst isEmpty = obj=> Object.keys(obj).length === 0\\n\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3798750,
                "title": "simple-javascript-solution",
                "content": "# Approach\\nSimply, use length method to see if there is any element in object or array.If if it is 0,return true else false.\\n\\n# Code\\n```\\n/**\\n * @param {Object | Array} obj\\n * @return {boolean}\\n */\\nvar isEmpty = function(obj) {\\n    return Object.keys(obj).length === 0 ? true : false;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Object | Array} obj\\n * @return {boolean}\\n */\\nvar isEmpty = function(obj) {\\n    return Object.keys(obj).length === 0 ? true : false;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3789851,
                "title": "simple-js-check-if-the-object-is-empty-without-using-json",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nI recommend you please check the use of json also and come up with that solution also ok bye i should also do it.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Object | Array} obj\\n * @return {boolean}\\n */\\nvar isEmpty = function(obj) {\\n     if(Object.keys(obj).length == 0){\\n         return true;\\n     }\\n     return false;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Object | Array} obj\\n * @return {boolean}\\n */\\nvar isEmpty = function(obj) {\\n     if(Object.keys(obj).length == 0){\\n         return true;\\n     }\\n     return false;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3789134,
                "title": "easy-solution-javascript",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Object | Array} obj\\n * @return {boolean}\\n */\\nvar isEmpty = function(obj) {\\n    return !Object.keys(obj).length;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Object | Array} obj\\n * @return {boolean}\\n */\\nvar isEmpty = function(obj) {\\n    return !Object.keys(obj).length;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3786483,
                "title": "easysolutions-0",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nfunction isEmpty(obj: Record<string, any> | any[]): boolean {\\nreturn Object.keys(obj).length==0? true: false \\n};\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\nfunction isEmpty(obj: Record<string, any> | any[]): boolean {\\nreturn Object.keys(obj).length==0? true: false \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3780336,
                "title": "pragmatic-checks-that-beat-92",
                "content": "# Approach\\nWe first check for the type we have to deal with, so either an object or an array. For an array its very straight forward, just check the lenght. For an Object it can also be simplified by using Object.keys() and checking the length of the returning array again.\\n\\n# Code\\n```\\n/**\\n * @param {Object | Array} obj\\n * @return {boolean}\\n */\\nvar isEmpty = function(obj) {\\n    if (Array.isArray(obj)) {\\n        return obj.length <= 0;\\n    }\\n    return Object.keys(obj).length <= 0;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Object | Array} obj\\n * @return {boolean}\\n */\\nvar isEmpty = function(obj) {\\n    if (Array.isArray(obj)) {\\n        return obj.length <= 0;\\n    }\\n    return Object.keys(obj).length <= 0;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3777105,
                "title": "very-basic-easy-to-understand-solution",
                "content": "# Approach\\nFirst we will check whether obj is an array or not and then if its length is zero then true will be returned. Same goes if obj is an object but to find length of object, Object.keys().length method is used.\\n\\n# Code\\n```\\n/**\\n * @param {Object | Array} obj\\n * @return {boolean}\\n */\\nvar isEmpty = function(obj) {\\n    if(Array.isArray(obj) && obj.length == 0) return true\\n    else if (Object.keys(obj).length == 0) return true\\n    else return false\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Object | Array} obj\\n * @return {boolean}\\n */\\nvar isEmpty = function(obj) {\\n    if(Array.isArray(obj) && obj.length == 0) return true\\n    else if (Object.keys(obj).length == 0) return true\\n    else return false\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3769921,
                "title": "simple-program-using-ternary-operator-in-js",
                "content": "\\n\\n# Code\\n```\\n/**\\n * @param {Object | Array} obj\\n * @return {boolean}\\n */\\nvar isEmpty = function(obj) {\\n    return Object.keys(obj).length ==0 ? true : false\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Object | Array} obj\\n * @return {boolean}\\n */\\nvar isEmpty = function(obj) {\\n    return Object.keys(obj).length ==0 ? true : false\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3765886,
                "title": "cleanest-simplest-solution",
                "content": "# Intuition\\nObject.keys can be used on arrays because arrays are also objects in JS.\\n\\n# Approach\\nIf there are any keys then the object is not empty. We can simply return the result of the comparison because it will be true or false.\\n\\n\\n# Code\\n```\\n/**\\n * @param {Object | Array} obj\\n * @return {boolean}\\n */\\nvar isEmpty = function (obj) {\\n    return Object.keys(obj).length == 0\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Object | Array} obj\\n * @return {boolean}\\n */\\nvar isEmpty = function (obj) {\\n    return Object.keys(obj).length == 0\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3765046,
                "title": "super-simple-code",
                "content": "# Intuition\\nThe code asks to check if the key value pairs are present in the object\\n\\n# Approach\\nThe isEmpty function takes an object obj as input.\\n\\nIt uses a for...of loop to iterate over the keys of the object using the Object.entries(obj) method.\\n\\nIn each iteration, it checks the length property of the key variable, which represents each key-value pair in the form [key, value].\\n\\nIf the length of key is greater than 0, it means at least one key exists in the object.\\n\\nIn this case, the function immediately returns false, indicating that the object is not empty.\\n\\nIf the loop completes without finding any keys, it means the object is empty.\\n\\nIn that case, the function exits the loop and returns true, indicating that the object is indeed empty\\n# Complexity\\n- Time complexity:\\nTime Complexity: O(n)\\n\\nThe function iterates over the keys of the object using a for...of loop, which has a time complexity of O(n). It checks each key in the loop to determine if there are any keys present.\\nIn the worst case, when the object has n keys, the loop will iterate n times.\\nTherefore, the time complexity of the isEmpty function is O(n), as it has a linear relationship with the number of keys in the object.\\n\\n\\n- Space complexity:\\nSpace Complexity: O(1)\\n\\nThe function uses a constant amount of space for storing the key variable during each iteration of the loop.\\nIt does not use any additional data structures or memory that grow with the input size.\\nHence, the space complexity of the isEmpty function is O(1), indicating constant space usage regardless of the size of the object\\n\\n# Code\\n```\\n\\'use strict\\'\\nfunction isEmpty(obj) {\\n    for (const key of Object.entries(obj)) {\\n        if (key.length > 0) return false\\n    }\\n    return true\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n\\'use strict\\'\\nfunction isEmpty(obj) {\\n    for (const key of Object.entries(obj)) {\\n        if (key.length > 0) return false\\n    }\\n    return true\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3760369,
                "title": "is-object-empty",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Object | Array} obj\\n * @return {boolean}\\n */\\nvar isEmpty = function(obj) {\\n    for(let key in obj){\\n      if(key!==null){\\n        return false\\n      }\\n    }\\n    return true\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Object | Array} obj\\n * @return {boolean}\\n */\\nvar isEmpty = function(obj) {\\n    for(let key in obj){\\n      if(key!==null){\\n        return false\\n      }\\n    }\\n    return true\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3753147,
                "title": "is-there-a-more-efficient-solution-for-this-task-i-m-looking-forward-to-your-replies",
                "content": "\\n```\\n\\nconst isEmpty = (obj) => {\\n   return Object.keys(obj).length === 0\\n};\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n\\nconst isEmpty = (obj) => {\\n   return Object.keys(obj).length === 0\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3751395,
                "title": "simple-one-line-solution",
                "content": "var isEmpty = function(obj) {\\n   return Object.keys(obj).length <=0? true:false\\n};",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "var isEmpty = function(obj) {\\n   return Object.keys(obj).length <=0? true:false\\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 3750567,
                "title": "easiest-way-to-solve",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Object | Array} obj\\n * @return {boolean}\\n */\\nvar isEmpty = function(obj) {\\n    return Object.keys(obj).length === 0 ? true : false;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Object | Array} obj\\n * @return {boolean}\\n */\\nvar isEmpty = function(obj) {\\n    return Object.keys(obj).length === 0 ? true : false;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3749378,
                "title": "2727-is-object-empty-umarbek-s-solution",
                "content": "# Code\\n```\\n/**\\n * @param {Object | Array} obj\\n * @return {boolean}\\n */\\nvar isEmpty = function(obj) {\\n    return Object.keys(obj).length===0;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Object | Array} obj\\n * @return {boolean}\\n */\\nvar isEmpty = function(obj) {\\n    return Object.keys(obj).length===0;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3747713,
                "title": "easy-js-one-liner",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Object | Array} obj\\n * @return {boolean}\\n */\\nvar isEmpty = function (obj) {\\n    return !Boolean(Object.keys(obj).length)\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Object | Array} obj\\n * @return {boolean}\\n */\\nvar isEmpty = function (obj) {\\n    return !Boolean(Object.keys(obj).length)\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3746118,
                "title": "easy-1-line-solution-just-return",
                "content": "# Code\\n```\\n/**\\n * @param {Object | Array} obj\\n * @return {boolean}\\n */\\nvar isEmpty = function(obj) {\\n    return Object.keys(obj).length === 0\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Object | Array} obj\\n * @return {boolean}\\n */\\nvar isEmpty = function(obj) {\\n    return Object.keys(obj).length === 0\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3743876,
                "title": "solved",
                "content": "# Noob Approches \\n# Code\\n```\\n/**\\n * @param {Object | Array} obj\\n * @return {boolean}\\n */\\nvar isEmpty = function(obj) {\\n     if (Object.keys(obj).length>=1) \\n        return false;\\n    if(Object.keys(obj).length===0) return true;\\n    if(Array.isArray(obj)){\\n        if(obj.length>=1)\\n            return false;\\n        else return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Object | Array} obj\\n * @return {boolean}\\n */\\nvar isEmpty = function(obj) {\\n     if (Object.keys(obj).length>=1) \\n        return false;\\n    if(Object.keys(obj).length===0) return true;\\n    if(Array.isArray(obj)){\\n        if(obj.length>=1)\\n            return false;\\n        else return true;\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3740484,
                "title": "js",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Object | Array} obj\\n * @return {boolean}\\n */\\nvar isEmpty = function(obj) {\\n    switch(typeof(obj)){\\n        case \"array\":\\n            if(obj.length === 0){\\n             return true\\n            }\\n            return false\\n        break\\n        case \"object\":\\n            if(Object.entries(obj).length === 0){\\n                return true\\n            }\\n             return false\\n        break\\n    }\\n    \\n   \\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Object | Array} obj\\n * @return {boolean}\\n */\\nvar isEmpty = function(obj) {\\n    switch(typeof(obj)){\\n        case \"array\":\\n            if(obj.length === 0){\\n             return true\\n            }\\n            return false\\n        break\\n        case \"object\":\\n            if(Object.entries(obj).length === 0){\\n                return true\\n            }\\n             return false\\n        break\\n    }\\n    \\n   \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3739672,
                "title": "object-keys-obj-returns-an-array-of-keys",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Object | Array} obj\\n * @return {boolean}\\n */\\nvar isEmpty = function(obj) {\\n    return !Object.keys(obj).length;\\n\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Object | Array} obj\\n * @return {boolean}\\n */\\nvar isEmpty = function(obj) {\\n    return !Object.keys(obj).length;\\n\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3737869,
                "title": "actual-isempty-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe problem is only asking two things\\n1. If input is an object and if it has atleast one object return true else return false\\n2. If input is an array and if it\\'s length is greater than `0` return true else return false\\n\\n\\nI\\'ve realised this later.\\n\\nAnyway i\\'m sharing my solution, which will work for more depth cases and hope someone find it useful.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Object | Array} obj\\n * @return {boolean}\\n */\\nvar isEmpty = function(obj) {\\n    if(!obj){\\n        return true;\\n    }\\n\\n    if(Array.isArray(obj)){\\n        return isEmptyArray(obj);\\n    }\\n\\n    return isEmptyObject(obj);\\n    \\n};\\n\\nconst isEmptyArray = (arr) => {\\n    if(arr.length === 0){\\n        return true;\\n    }\\n\\n    for(let ele of arr){\\n        if(ele === false || ele === 0 || ele === \"\" || ele){\\n            return false;\\n        }\\n    }\\n    return true;\\n}\\n\\nconst isEmptyObject = (obj) => {\\n    if(!obj){\\n        return true;\\n    }\\n\\n    for(key in obj){\\n        if(obj[key] === false || obj[key] === 0 || obj[key] === \"\" || obj[key]){\\n            return false;\\n        }\\n    }\\n    return true;\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Object | Array} obj\\n * @return {boolean}\\n */\\nvar isEmpty = function(obj) {\\n    if(!obj){\\n        return true;\\n    }\\n\\n    if(Array.isArray(obj)){\\n        return isEmptyArray(obj);\\n    }\\n\\n    return isEmptyObject(obj);\\n    \\n};\\n\\nconst isEmptyArray = (arr) => {\\n    if(arr.length === 0){\\n        return true;\\n    }\\n\\n    for(let ele of arr){\\n        if(ele === false || ele === 0 || ele === \"\" || ele){\\n            return false;\\n        }\\n    }\\n    return true;\\n}\\n\\nconst isEmptyObject = (obj) => {\\n    if(!obj){\\n        return true;\\n    }\\n\\n    for(key in obj){\\n        if(obj[key] === false || obj[key] === 0 || obj[key] === \"\" || obj[key]){\\n            return false;\\n        }\\n    }\\n    return true;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3734443,
                "title": "simplest-method-in-one-line",
                "content": "\\n# Code\\n```\\n/**\\n * @param {Object | Array} obj\\n * @return {boolean}\\n */\\nvar isEmpty = function(obj) {\\n    return !Object.keys(obj).length;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Object | Array} obj\\n * @return {boolean}\\n */\\nvar isEmpty = function(obj) {\\n    return !Object.keys(obj).length;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3734250,
                "title": "js-solution",
                "content": "```\\nlet isEmpty = o => !Object.entries(o).length;\\n```",
                "solutionTags": [],
                "code": "```\\nlet isEmpty = o => !Object.entries(o).length;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3733688,
                "title": "well-explained-solution",
                "content": "## Solution Approach\\nThe isEmpty function is defined with a parameter obj, which represents the object or array that we want to check for emptiness.\\n\\nThe function starts with an if statement to check if the obj is an array using the Array.isArray method:\\n\\n- If obj is an array, it checks if the length of the array (obj.length) is equal to 0. If it is, it means the array is empty, so the function returns true.\\n- If the length is not 0, it means the array has elements, so the function returns false.\\n\\nIf the obj is not an array, the function proceeds to the next if statement, which checks if the obj is an object and not null using typeof and the null check:\\n\\n- If obj is an object and not null, it uses Object.keys(obj) to retrieve an array of keys for the object. The Object.keys method returns an empty array if the object has no enumerable keys.\\n- The function then checks if the length of the keys array (Object.keys(obj).length) is equal to 0. If it is, it means the object has no key-value pairs and is empty, so the function returns true.\\n- If the length is not 0, it means the object has keys and is not empty, so the function returns false.\\n\\nIf the obj is neither an array nor an object, the function reaches the return false statement, indicating that it is not empty.\\n\\n# Code\\n```\\n/**\\n * @param {Object | Array} obj\\n * @return {boolean}\\n */\\nvar isEmpty = function(obj) {\\n    if (Array.isArray(obj)) {\\n        return obj.length === 0;\\n    }\\n\\n    if (typeof obj === \\'object\\' && obj !== null) {\\n        return Object.keys(obj).length === 0;\\n    }\\n\\n    return false;\\n};\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Object | Array} obj\\n * @return {boolean}\\n */\\nvar isEmpty = function(obj) {\\n    if (Array.isArray(obj)) {\\n        return obj.length === 0;\\n    }\\n\\n    if (typeof obj === \\'object\\' && obj !== null) {\\n        return Object.keys(obj).length === 0;\\n    }\\n\\n    return false;\\n};\\n\\n```",
                "codeTag": "Unknown"
            }
        ],
        "discussions": [
            {
                "id": 2033378,
                "content": [
                    {
                        "username": "ategale",
                        "content": "How to catch {\"\": \"\"} without using an if statement?"
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "if it is also an array then why can\\'t i simply find if the length of the array is zero and return true."
                    },
                    {
                        "username": "akv11",
                        "content": "But it can also be an object. So we have to use conditions for both array and object."
                    }
                ]
            },
            {
                "id": 1977750,
                "content": [
                    {
                        "username": "ategale",
                        "content": "How to catch {\"\": \"\"} without using an if statement?"
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "if it is also an array then why can\\'t i simply find if the length of the array is zero and return true."
                    },
                    {
                        "username": "akv11",
                        "content": "But it can also be an object. So we have to use conditions for both array and object."
                    }
                ]
            }
        ]
    },
    {
        "title": "Find the Closest Marked Node",
        "question_content": null,
        "solutions": [],
        "discussions": []
    }
]