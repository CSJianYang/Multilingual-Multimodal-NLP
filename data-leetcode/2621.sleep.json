[
    {
        "title": "Sleep",
        "question_content": "Given&nbsp;a positive integer millis, write an asynchronous function that sleeps for millis&nbsp;milliseconds. It can resolve any value.\n&nbsp;\nExample 1:\n\nInput: millis = 100\nOutput: 100\nExplanation: It should return a promise that resolves after 100ms.\nlet t = Date.now();\nsleep(100).then(() => {\n  console.log(Date.now() - t); // 100\n});\n\nExample 2:\n\nInput: millis = 200\nOutput: 200\nExplanation: It should return a promise that resolves after 200ms.\n\n&nbsp;\nConstraints:\n\n\t1 <= millis <= 1000",
        "solutions": [
            {
                "id": 3406493,
                "title": "detailed-explanation-important-question",
                "content": "# Explanation\\nExplanation:\\n\\n1. The sleep function takes a positive integer millis as input.\\n2. It then creates a Promise that resolves after millis milliseconds using the setTimeout function.\\n3. The Promise is then awaited using the await keyword, which allows the function to pause execution until the Promise is resolved.\\n\\nIf you are not familar with \\'await\\' then you may use \\'return\\' instead like this:\\nreturn new Promise(resolve => setTimeout(resolve, millis));\\n\\n# Code\\n```\\n/**\\n * @param {number} millis\\n */\\nasync function sleep(millis) {\\n    await new Promise(resolve => setTimeout(resolve, millis));\\n}\\n\\n/** \\n * let t = Date.now()\\n * sleep(100).then(() => console.log(Date.now() - t)) // 100\\n */\\n```\\nPlease upvote if you found this helpful.",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} millis\\n */\\nasync function sleep(millis) {\\n    await new Promise(resolve => setTimeout(resolve, millis));\\n}\\n\\n/** \\n * let t = Date.now()\\n * sleep(100).then(() => console.log(Date.now() - t)) // 100\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3525419,
                "title": "promise-examples-dry-run-usecase-o-1-js-ts-beginner-friendly-day11",
                "content": "## Problem summary:\\nWe need to write an `asynchronous` function that sleeps for the given number of `milliseconds` and then resolves any `value`.\\n***\\n## Examples:\\n```\\nsleep(2000) -> waits for 2 seconds and then resolves\\nsleep(500) -> waits for 0.5 seconds and then resolves\\n```\\n***\\n## Approach:\\nTo implement the `sleep` function, we can use the `setTimeout` function which waits for a given number of `milliseconds` and then **executes a callback function**. We can then wrap this logic in a `Promise` and use `async/await` to wait for the `Promise` to resolve.\\n***\\n## Concepts:\\n* **Asynchronous functions:** The question specifies that the `sleep` function should be an `asynchronous` function. In simple terms, `Asynchronous` functions allow code to execute non-blocking `I/O` operations and other time-consuming tasks without blocking the main thread.\\n* **Promises:** `Asynchronous operations` typically return a `Promise` object. `Promises` are a way of handling asynchronous operations and specifying what should happen when the operation completes (either successfully or with an error).\\n* **setTimeout:** The `setTimeout` function is a built-in function that can be used to schedule a function to run after a certain amount of time has elapsed. In our question we will use `setTimeout` to implement the `sleep` function.\\n* **Error handling:** `Asynchronous` operations can fail for various reasons **(e.g. network errors, invalid input)**. `Error handling` is important as its like a fallback mechanism if the code doesn\\'t work.\\n* **Async/await:** `Async/await` is a syntactic feature that makes it easier to write `asynchronous` code that looks like `synchronous` code. It allows us to write code that `\"waits\"` for a `Promise` to resolve before continuing execution.\\n***\\n## Solutions: \\n***\\n1. **Javascript Solution without using error handling and Async/await:** \\n```\\n/**\\n * @param {number} millis\\n */\\nasync function sleep(millis) {\\n  return new Promise(delayresolve => setTimeout(delayresolve, millis));\\n}\\n\\n/** \\n * let t = Date.now()\\n * sleep(100).then(() => console.log(Date.now() - t)) // 100\\n */\\n```\\n\\n2. **Typescript Solution without using error handling and uses async/await:**\\n```\\nasync function sleep(millis: number): Promise<void> {\\n    return new Promise<void>(delayresolve => {\\n        setTimeout(delayresolve, millis);\\n    });\\n}\\n/** \\n * let t = Date.now()\\n * sleep(100).then(() => console.log(Date.now() - t)) // 100\\n */\\n```\\n***\\n3. **Javascript solution using error handling and async/await:**\\n```\\n/**\\n * @param {number} millis\\n */\\nasync function sleep(millis) {\\n  return new Promise((delayresolve, reject) => {\\n    if (typeof millis !== \\'number\\' || isNaN(millis)) {\\n      reject(new Error(\\'Invalid argument. Expected a number.\\'));\\n    } else {\\n      setTimeout(delayresolve, millis);\\n    }\\n  });\\n}\\n/** \\n * let t = Date.now()\\n * sleep(100).then(() => console.log(Date.now() - t)) // 100\\n */\\n```\\n\\n4. **Typescript solution using error handling and async/await:**\\n```\\nasync function sleep(millis: number): Promise<void> {\\n  return new Promise<void>((delayresolve, reject) => {\\n    if (typeof millis !== \\'number\\' || isNaN(millis)) {\\n      reject(new Error(\\'Invalid argument. Expected a number.\\'));\\n    } else {\\n      setTimeout(delayresolve, millis);\\n    }\\n  });\\n}\\n\\n/** \\n * let t = Date.now()\\n * sleep(100).then(() => console.log(Date.now() - t)) // 100\\n */\\n```\\n***\\n## Dry Run:\\nFor dry run lets take the above solution as a reference and call the `delay` function with the required arguments:\\n```\\nfunction delay(value, millis) {\\n  return new Promise((delayresolve) => {\\n    setTimeout(() => delayresolve(value), millis);\\n  });\\n}\\n\\ndelay(\\'hello\\', 1000).then((result) => console.log(result));\\n```\\nThis creates a `promise` that resolves to the value `\\'hello\\'` after a delay of `1000` milliseconds (`1` second). The `.then()` method is used for handling the resolved value.\\n\\n***\\n**Time Complexity: O(1)\\nSpace Complexity: O(1)**\\n***\\n*We are all beginners in some area, hence we all have silly questions, so don\\'t be afraid to ask them. I will gladly answer them!!*",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "```\\nsleep(2000) -> waits for 2 seconds and then resolves\\nsleep(500) -> waits for 0.5 seconds and then resolves\\n```\n```\\n/**\\n * @param {number} millis\\n */\\nasync function sleep(millis) {\\n  return new Promise(delayresolve => setTimeout(delayresolve, millis));\\n}\\n\\n/** \\n * let t = Date.now()\\n * sleep(100).then(() => console.log(Date.now() - t)) // 100\\n */\\n```\n```\\nasync function sleep(millis: number): Promise<void> {\\n    return new Promise<void>(delayresolve => {\\n        setTimeout(delayresolve, millis);\\n    });\\n}\\n/** \\n * let t = Date.now()\\n * sleep(100).then(() => console.log(Date.now() - t)) // 100\\n */\\n```\n```\\n/**\\n * @param {number} millis\\n */\\nasync function sleep(millis) {\\n  return new Promise((delayresolve, reject) => {\\n    if (typeof millis !== \\'number\\' || isNaN(millis)) {\\n      reject(new Error(\\'Invalid argument. Expected a number.\\'));\\n    } else {\\n      setTimeout(delayresolve, millis);\\n    }\\n  });\\n}\\n/** \\n * let t = Date.now()\\n * sleep(100).then(() => console.log(Date.now() - t)) // 100\\n */\\n```\n```\\nasync function sleep(millis: number): Promise<void> {\\n  return new Promise<void>((delayresolve, reject) => {\\n    if (typeof millis !== \\'number\\' || isNaN(millis)) {\\n      reject(new Error(\\'Invalid argument. Expected a number.\\'));\\n    } else {\\n      setTimeout(delayresolve, millis);\\n    }\\n  });\\n}\\n\\n/** \\n * let t = Date.now()\\n * sleep(100).then(() => console.log(Date.now() - t)) // 100\\n */\\n```\n```\\nfunction delay(value, millis) {\\n  return new Promise((delayresolve) => {\\n    setTimeout(() => delayresolve(value), millis);\\n  });\\n}\\n\\ndelay(\\'hello\\', 1000).then((result) => console.log(result));\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3525318,
                "title": "1-line-code-learn-asynchronous-programming-using-promise-settimeout-day-11",
                "content": "# Intuition\\n- `sleep function` pauses program execution for a specified number of `milliseconds`.\\n- setTimeout function can be used to wait for a specified number of milliseconds before calling a function.\\n- Wrapping `setTimeout` in a promise makes the function` asynchronous` and compatible with `async/await` syntax.\\n\\n# Approach\\n1. Create a new promise using the Promise constructor.\\n2. The promise executor function takes a single argument, which is a function that will be called when the promise is resolved.\\n3. Use setTimeout to wait for the specified number of milliseconds before calling the resolve function provided by the promise executor.\\n4. Return the promise from the sleep function.\\n5. This allows us to pause the execution of a program for a given amount of time, which can be useful in a variety of scenarios.\\n\\n# Complexity\\n- Time complexity:\\n`sleep function` is O(1), which means that the time it takes to execute the function is constant and independent of the input size. This is because the function uses the `setTimeout` function to pause the execution of the program for the specified amount of time in `milliseconds`. \\n\\n- Space complexity:\\nO(1), which means that the amount of memory used by the function is constant and independent of the input size.\\n\\n# Today\\'s Learning \\n\\n1. **Asynchronous Programming:** \\n- Asynchronous programming in JavaScript allows us to execute code without blocking the main thread of execution.\\n- Asynchronous programming can be achieved using callbacks, promises, or async/await syntax.\\n2. **Promise:**\\n- A promise is a JavaScript object that represents a value that may not be available yet.\\n- Promises have three states: pending, fulfilled, and rejected.\\n- Promises are useful for asynchronous operations because they allow us to handle the results of an operation once it completes.\\n\\n**Example**\\n```\\nconst promise = new Promise((resolve, reject) => {\\n  setTimeout(() => {\\n    resolve(\\'Hello, world!\\');\\n  }, 1000);\\n});\\n\\npromise.then(result => {\\n  console.log(result); // \\'Hello, world!\\'\\n});\\n\\n```\\n3.  **setTimeout:**\\n- setTimeout is a built-in JavaScript function that allows us to delay the execution of a function for a specified number of milliseconds.\\n- setTimeout takes two arguments: a callback function to be executed after the delay, and a number of milliseconds to wait before executing the callback.\\n\\n**Example** \\n```\\nsetTimeout(() => {\\n  console.log(\\'Hello, world!\\');\\n}, 1000);\\n\\n```\\n\\n\\n# Code In JS\\n```\\nasync function sleep(millis: number): Promise<void> {\\n    return new Promise((resolve) => setTimeout(resolve, millis));\\n}\\n\\n\\n\\n let t = Date.now()\\n sleep(100).then(() => console.log(Date.now() - t)) // 100\\n \\n```\\n# Code In TypeScript \\n\\n```\\nasync function sleep(millis: number): Promise<void> {\\n    return new Promise((resolve) => setTimeout(resolve, millis));\\n}\\n\\n let t = Date.now()\\n sleep(100).then(() => console.log(Date.now() - t)) // 100\\n```\\n\\n![upvote-2.png](https://assets.leetcode.com/users/images/3c100e99-0181-4862-92bf-f0b72f1bfe2b_1684116640.2871475.png)\\n\\n",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "```\\nconst promise = new Promise((resolve, reject) => {\\n  setTimeout(() => {\\n    resolve(\\'Hello, world!\\');\\n  }, 1000);\\n});\\n\\npromise.then(result => {\\n  console.log(result); // \\'Hello, world!\\'\\n});\\n\\n```\n```\\nsetTimeout(() => {\\n  console.log(\\'Hello, world!\\');\\n}, 1000);\\n\\n```\n```\\nasync function sleep(millis: number): Promise<void> {\\n    return new Promise((resolve) => setTimeout(resolve, millis));\\n}\\n\\n\\n\\n let t = Date.now()\\n sleep(100).then(() => console.log(Date.now() - t)) // 100\\n \\n```\n```\\nasync function sleep(millis: number): Promise<void> {\\n    return new Promise((resolve) => setTimeout(resolve, millis));\\n}\\n\\n let t = Date.now()\\n sleep(100).then(() => console.log(Date.now() - t)) // 100\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3526560,
                "title": "code-video-2-easy-solution-in-js-ts-concept-comments",
                "content": "# content\\n* Video\\n* Concepts\\n* Intution\\n* Approach\\n* Code in javascript\\n* Code in typescript\\n\\n\\n# Video\\n\\nOn my youtube channel - youtube/@anshulontech\\n\\n![Copy of Copy of Copy of Copy of Copy of Copy of Copy of Copy of JavaScritp30 (1).png](https://assets.leetcode.com/users/images/bd7fd39c-fc9a-40a2-95c0-af571d5fbab4_1684113358.1523113.png)\\n\\n\\n# Concepts\\n\\n### Settimeout\\nIn JavaScript, setTimeout is a function that allows you to schedule a piece of code to run after a certain amount of time has passed.\\n\\nWhen you call setTimeout, you pass in two arguments: a function to run, and a number of milliseconds to wait before running that function.\\n\\nsetTimeout is often used to create delays in code execution, or to schedule code to run at a later time.\\n\\nFor example, you could use setTimeout to create a delay before displaying a message to the user:\\n\\n\\n\\n### Promises\\nIn JavaScript, a promise is an object that represents a value that may not be available yet, but will be at some point in the future.\\n\\nWhen you create a promise, you can attach functions to it that will run when the value is available. These functions are called \"callbacks\".\\n\\nPromises are often used to handle asynchronous operations, like fetching data from a server or reading a file from disk. Instead of blocking the code and waiting for the operation to finish, you can create a promise that will be resolved (or rejected) when the operation is complete.\\n\\nPromises have three states: \"pending\", \"fulfilled\", and \"rejected\". When a promise is pending, it means the operation is still in progress. When a promise is fulfilled, it means the operation succeeded and the value is available. When a promise is rejected, it means the operation failed and an error occurred.\\n\\nWith async/await syntax, you can write asynchronous code that looks and behaves like synchronous code. You use the async keyword to define a function as asynchronous, and the await keyword to wait for a promise to be resolved or rejected before continuing.\\n\\n\\n![Screenshot 2023-05-15 at 5.27.57 AM.png](https://assets.leetcode.com/users/images/fcc0dfc0-084d-4422-9140-c9690a0022a4_1684113130.583549.png)\\n\\n\\n\\n# Intuition\\n\\n* We need to mimic `SLEEP`, i.e something like our code got blocked due to some code but we need to make it active after `millis`.\\n* The function signature has a `async` keyword, hence it will use a promise somewhere\\n* The argument is a number `millis`, which is the time we need to hold the excecution of code.\\n* This can we done by async-await, but we need to create a promise for that\\n* After creating promise we will resolve the promise after the given time\\n* We can use `setttimeout` to make sure it resolves after the given time.\\n\\n# Approach\\n* We will wrap the function in async (already there but just know that we need it to await any promise )\\n* We can start by creating a new promise, this can be done by using `new Promise` syntax.\\n* We can use `setttimeout` to resolve the promise to success after `millis` of time.\\n* by the time it\\'s not getting resolved, await will hold the exceution and it will look like the code went to `SLEEP`\\n* DONE. \\uD83C\\uDFB8\\n\\n\\n# Complexity\\n- Time complexity:\\nIt depends on the millis, we are waiting for that period\\n\\n- Space complexity:\\nO(1), we are not using any space.\\n\\n# Code\\n``` javascript []\\n/**\\n * @param {number} millis\\n */\\n\\n\\nasync function sleep(millis) {\\n    await new Promise(resolve => setTimeout(resolve, millis));\\n}\\n\\n/** \\n * let t = Date.now()\\n * sleep(100).then(() => console.log(Date.now() - t)) // 100\\n */\\n```\\n\\n``` typescript []\\nasync function sleep(millis:number): Promsie<void> {\\n    await new Promise(resolve => setTimeout(resolve, millis));\\n}\\n```\\n\\nSolution 2 \\n\\n``` javascript []\\nasync function sleep(millis) {\\n    // create a new promise, we don\\'t need reject here, but wrote it for syntax\\n    const result = new Promise((resolve, reject)=>{\\n        // A way to resolve the promise after x millis\\n        setTimeout(()=>{\\n            resolve()\\n        },millis)\\n    })\\n\\n    return result\\n}\\n```\\n\\n---\\n# Please upvote \\uD83D\\uDC4D\\uD83C\\uDFFB\\n\\n![ps.jpeg](https://assets.leetcode.com/users/images/c96c3af2-489c-4ea7-b2ec-d20641c804e7_1684113408.4488964.jpeg)\\n\\n\\nThanks \\nAnshul \\uD83D\\uDE80",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "``` javascript []\\n/**\\n * @param {number} millis\\n */\\n\\n\\nasync function sleep(millis) {\\n    await new Promise(resolve => setTimeout(resolve, millis));\\n}\\n\\n/** \\n * let t = Date.now()\\n * sleep(100).then(() => console.log(Date.now() - t)) // 100\\n */\\n```\n``` typescript []\\nasync function sleep(millis:number): Promsie<void> {\\n    await new Promise(resolve => setTimeout(resolve, millis));\\n}\\n```\n``` javascript []\\nasync function sleep(millis) {\\n    // create a new promise, we don\\'t need reject here, but wrote it for syntax\\n    const result = new Promise((resolve, reject)=>{\\n        // A way to resolve the promise after x millis\\n        setTimeout(()=>{\\n            resolve()\\n        },millis)\\n    })\\n\\n    return result\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3407176,
                "title": "async-sleep-function",
                "content": "The given code defines an asynchronous sleep function named `sleep` that returns a promise. The function takes a parameter `millis` which specifies the number of milliseconds to sleep.\\n\\n# Approach:\\nThe function `sleep` creates a promise that resolves after a specified number of milliseconds using the `setTimeout` function. The promise is then returned to the caller.\\n\\nThe `setTimeout` function is used to delay the execution of the function for the specified number of milliseconds. It takes two arguments - a callback function that will be executed after the specified time has elapsed and the time in milliseconds to wait before executing the callback.\\n\\nThe `sleep` function returns a promise that resolves after the specified time has elapsed. The `Promise` constructor takes a function with two parameters `resolve` and `reject`. In this case, `resolve` is called after the specified time has elapsed.\\n\\n# Intuition:\\nThe `sleep` function is commonly used in asynchronous programming to introduce a delay or to simulate a long-running operation. The function can be used to pause the execution of code for a specified amount of time.\\n\\n# Code\\n```\\n/**\\n * @param {number} millis\\n */\\nasync function sleep(millis) {\\n    const promise = new Promise((resolve, reject)=>{\\n        setTimeout(()=>{\\n            resolve()\\n        },millis)\\n    })\\n\\n    return promise\\n}\\n\\n/*\\n// TypeScript\\nasync function sleep(millis: number): Promise<void> {\\n    const promise = new Promise<void>((resolve, reject)=>{\\n        setTimeout(()=>{\\n            resolve();\\n        },millis);\\n    });\\n\\n    return promise;\\n}\\n*/\\n\\n/** \\n * let t = Date.now()\\n * sleep(100).then(() => console.log(Date.now() - t)) // 100\\n */\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "```\\n/**\\n * @param {number} millis\\n */\\nasync function sleep(millis) {\\n    const promise = new Promise((resolve, reject)=>{\\n        setTimeout(()=>{\\n            resolve()\\n        },millis)\\n    })\\n\\n    return promise\\n}\\n\\n/*\\n// TypeScript\\nasync function sleep(millis: number): Promise<void> {\\n    const promise = new Promise<void>((resolve, reject)=>{\\n        setTimeout(()=>{\\n            resolve();\\n        },millis);\\n    });\\n\\n    return promise;\\n}\\n*/\\n\\n/** \\n * let t = Date.now()\\n * sleep(100).then(() => console.log(Date.now() - t)) // 100\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3628041,
                "title": "sleep-timed-asynchronous-delay-o-1-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nTo implement the `sleep` function that sleeps for a given number of milliseconds, we can utilize the `setTimeout` function in JavaScript. By creating a promise and resolving it after the specified time, we can achieve the desired sleep behavior.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe `sleep` function takes a parameter `millis` representing the number of milliseconds to sleep.\\nInside the `sleep` function, a new `Promise` is created that represents the asynchronous operation.\\nThe `setTimeout` function is used to introduce a delay based on the `millis` parameter value. After the specified time elapses, the promise is resolved.\\nThe resolved promise can be considered as the sleep completing after `millis` milliseconds.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nThe time complexity of the `sleep` function is O(1) since it only performs a single `setTimeout` operation.\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nThe space complexity of the `sleep` function is O(1) since it doesn\\'t use any additional data structures.\\n# Code\\n```\\n/**\\n * @param {number} millis\\n */\\nlet t = Date.now();\\n\\nasync function sleep(millis) {\\n  let promise = new Promise((resolve, reject) => {\\n    setTimeout(() => {\\n      resolve(\"done\");\\n    }, millis);\\n  });\\n\\n  let response = await promise;\\n}\\n\\nsleep(100).then(() => console.log(Date.now() - t));\\n\\n\\n/** \\n * let t = Date.now()\\n * sleep(100).then(() => console.log(Date.now() - t)) // 100\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} millis\\n */\\nlet t = Date.now();\\n\\nasync function sleep(millis) {\\n  let promise = new Promise((resolve, reject) => {\\n    setTimeout(() => {\\n      resolve(\"done\");\\n    }, millis);\\n  });\\n\\n  let response = await promise;\\n}\\n\\nsleep(100).then(() => console.log(Date.now() - t));\\n\\n\\n/** \\n * let t = Date.now()\\n * sleep(100).then(() => console.log(Date.now() - t)) // 100\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3407884,
                "title": "leetcode-the-hard-way-1-line",
                "content": "Javascript\\n\\n```js\\nasync function sleep(millis) {\\n    return new Promise(resolve => setTimeout(resolve, millis))\\n}\\n```\\n\\nTypescript\\n\\n```ts\\nasync function sleep(millis: number): Promise<void> {\\n    return new Promise(resolve => setTimeout(resolve, millis))\\n}\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "```js\\nasync function sleep(millis) {\\n    return new Promise(resolve => setTimeout(resolve, millis))\\n}\\n```\n```ts\\nasync function sleep(millis: number): Promise<void> {\\n    return new Promise(resolve => setTimeout(resolve, millis))\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3407298,
                "title": "using-promise-and-settimeout",
                "content": "# Code\\n```\\n/**\\n * @param {number} millis\\n */\\nasync function sleep(millis) {\\n  return new Promise((resolve) => {\\n    setTimeout(() => {\\n      resolve()\\n    }, millis);\\n  });\\n}\\n\\n/** \\n * let t = Date.now()\\n * sleep(100).then(() => console.log(Date.now() - t)) // 100\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} millis\\n */\\nasync function sleep(millis) {\\n  return new Promise((resolve) => {\\n    setTimeout(() => {\\n      resolve()\\n    }, millis);\\n  });\\n}\\n\\n/** \\n * let t = Date.now()\\n * sleep(100).then(() => console.log(Date.now() - t)) // 100\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3406462,
                "title": "simplest-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nSimply return an instance of the promise class resolve it with any value and create a delay using setTimeout Web Api and thats it... good question for Front_end Interviews great addition by leetcode.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number} millis\\n */\\n\\nasync function sleep(millis) {\\n   return new Promise((resolve,reject)=>{\\n       setTimeout(()=>{\\n          resolve(1);\\n       },millis);\\n   })\\n}\\n\\n/** \\n * let t = Date.now()\\n * sleep(100).then(() => console.log(Date.now() - t)) // 100\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} millis\\n */\\n\\nasync function sleep(millis) {\\n   return new Promise((resolve,reject)=>{\\n       setTimeout(()=>{\\n          resolve(1);\\n       },millis);\\n   })\\n}\\n\\n/** \\n * let t = Date.now()\\n * sleep(100).then(() => console.log(Date.now() - t)) // 100\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3527779,
                "title": "easy-to-understand-js",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number} millis\\n */\\nasync function sleep(millis) {\\n return new Promise((resolve)=>{\\n     setTimeout(()=>{\\n         resolve();\\n     },millis);\\n })   \\n}\\n\\n/** \\n return new Promise((resolve) => {\\n        setTimeout(()=>{\\n            resolve();\\n        },millis);\\n    })\\n * let t = Date.now()\\n * sleep(100).then(() => console.log(Date.now() - t)) // 100\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} millis\\n */\\nasync function sleep(millis) {\\n return new Promise((resolve)=>{\\n     setTimeout(()=>{\\n         resolve();\\n     },millis);\\n })   \\n}\\n\\n/** \\n return new Promise((resolve) => {\\n        setTimeout(()=>{\\n            resolve();\\n        },millis);\\n    })\\n * let t = Date.now()\\n * sleep(100).then(() => console.log(Date.now() - t)) // 100\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3508551,
                "title": "two-solution-using-eat-five-star-and-do-nothing-approach",
                "content": "## 1.**Using Straight Forward Approach**\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n 1. let T=Date.now();\\n 1. Eat five Star and Do Nothing till currTime-T+1<Millis\\n 1. Once over , return any resolve value.\\n# Complexity\\n- Time complexity: O(millis)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number} millis\\n */\\nasync function sleep(millis) {\\n      let T=Date.now();\\n      while(Date.now()-T+1<millis)\\n      {   \\n            //do nothing\\n      }\\n      return Promise.resolve({});\\n}\\n\\n/** \\n * let t = Date.now()\\n * sleep(100).then(() => console.log(Date.now() - t)) // 100\\n */\\n```\\n\\n---\\n## 2.**Using Promise and SetTimeout**\\n# Intution\\n  1. We will create a promise which resolve after `milis` ms\\n# Complexity\\n- Time complexity: O(millis)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number} millis\\n */\\nasync function sleep(millis) {\\n      return new Promise((resolve,reject)=>{\\n             setTimeout(resolve,millis);\\n      });\\n}\\n\\n/** \\n * let t = Date.now()\\n * sleep(100).then(() => console.log(Date.now() - t)) // 100\\n */\\n``\\n\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} millis\\n */\\nasync function sleep(millis) {\\n      let T=Date.now();\\n      while(Date.now()-T+1<millis)\\n      {   \\n            //do nothing\\n      }\\n      return Promise.resolve({});\\n}\\n\\n/** \\n * let t = Date.now()\\n * sleep(100).then(() => console.log(Date.now() - t)) // 100\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3525545,
                "title": "day-2-o-1-o-9-commented-examples",
                "content": "This code is a JavaScript function that introduces a delay using the `setTimeout` function and returns the duration of the delay. Let\\'s break it down step by step:\\n\\n1. `await new Promise(resolve => setTimeout(resolve, millis));`: This line creates a new `Promise` object and uses the `setTimeout` function to introduce a delay. The `setTimeout` function takes two parameters: a callback function (`resolve` in this case) and a duration in milliseconds (`millis`).\\n\\n   The `resolve` function is used as the callback, and it is the function that will be called once the specified duration (`millis`) has passed. It signals the completion of the promise.\\n\\n   The `await` keyword is used to pause the execution of the function until the promise is resolved. This allows for an asynchronous delay.\\n\\n2. `return millis;`: After the delay has completed and the promise is resolved, the function returns the duration of the delay (`millis`).\\n\\nHere\\'s an example usage of this code:\\n\\n```javascript\\nasync function delayExample() {\\n  console.log(\\'Before delay\\');\\n  const millis = 2000; // 2 seconds\\n  await new Promise(resolve => setTimeout(resolve, millis));\\n  console.log(\\'After delay\\');\\n  return millis;\\n}\\n\\ndelayExample().then(duration => {\\n  console.log(`Delay of ${duration} milliseconds completed.`);\\n});\\n```\\n\\nIn this example, the function `delayExample` is defined. It logs \"Before delay\" to the console, introduces a 2-second delay using `setTimeout`, and then logs \"After delay\" to the console. Finally, it returns the duration of the delay.\\n\\nWhen `delayExample` is called, it pauses execution at the `await` line for 2 seconds. Once the delay is complete, it logs \"After delay\" and returns the duration (2 seconds in this case). The `then` method is used to handle the returned duration and logs \"Delay of 2000 milliseconds completed.\" to the console.\\n\\n\\n\\n\\n***Here is the code to the current problem : -***\\n\\n```\\nawait new Promise(resolve => setTimeout(resolve , millis));\\n    return millis;\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "```javascript\\nasync function delayExample() {\\n  console.log(\\'Before delay\\');\\n  const millis = 2000; // 2 seconds\\n  await new Promise(resolve => setTimeout(resolve, millis));\\n  console.log(\\'After delay\\');\\n  return millis;\\n}\\n\\ndelayExample().then(duration => {\\n  console.log(`Delay of ${duration} milliseconds completed.`);\\n});\\n```\n```\\nawait new Promise(resolve => setTimeout(resolve , millis));\\n    return millis;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3528186,
                "title": "promise",
                "content": "```\\nasync function sleep(millis) {\\n    await new Promise((resolve) => {\\n        setTimeout(resolve, millis)\\n    });\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nasync function sleep(millis) {\\n    await new Promise((resolve) => {\\n        setTimeout(resolve, millis)\\n    });\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3526515,
                "title": "solution-using-settimeout",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number} millis\\n */\\nasync function sleep(millis) {\\n    return new Promise(resolve => {\\n    setTimeout(resolve, millis);\\n  });\\n}\\n\\n/** \\n * let t = Date.now()\\n * sleep(100).then(() => console.log(Date.now() - t)) // 100\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} millis\\n */\\nasync function sleep(millis) {\\n    return new Promise(resolve => {\\n    setTimeout(resolve, millis);\\n  });\\n}\\n\\n/** \\n * let t = Date.now()\\n * sleep(100).then(() => console.log(Date.now() - t)) // 100\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3526299,
                "title": "simple-javascript-solution-day-11",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe sleep function is used to make a program wait for a certain amount of time before continuing to execute the next line of code. It works by using a combination of the Promise and setTimeout functions to achieve the desired delay.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- The sleep function takes a parameter called \"millis\" which is the duration (in milliseconds) for which the code execution should be paused.\\n- Inside the function, a Promise is created that will resolve after the specified duration using the setTimeout function.\\n- The \"await\" keyword is used to pause the execution of the code until the Promise is resolved.\\n- After the Promise is resolved (i.e., the specified duration has passed), the sleep function completes its execution and the program continues to run from the next line of code.\\n\\n# Complexity\\n- Time complexity: O(1)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number} millis\\n */\\nasync function sleep(millis) {\\n    return new Promise((resolve) => {\\n        setTimeout(() => {\\n            resolve()\\n        }, millis)\\n    });\\n}\\n\\n/** \\n * let t = Date.now()\\n * sleep(100).then(() => console.log(Date.now() - t)) // 100\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} millis\\n */\\nasync function sleep(millis) {\\n    return new Promise((resolve) => {\\n        setTimeout(() => {\\n            resolve()\\n        }, millis)\\n    });\\n}\\n\\n/** \\n * let t = Date.now()\\n * sleep(100).then(() => console.log(Date.now() - t)) // 100\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3525461,
                "title": "java-script-solution-for-sleep-problem",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe sleep function allows for pausing the execution of code for a specified duration of time (in milliseconds). It utilizes the Promise and setTimeout functions to achieve the desired delay.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. The sleep function takes a parameter millis, which represents the duration in milliseconds for which the code execution should be paused.\\n2. It creates a Promise that resolves after the specified duration using the setTimeout function.\\n3. The await keyword is used to pause the execution of code until the Promise is resolved.\\n4. After the Promise is resolved, the sleep function completes its execution.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n O(1)\\nThe time complexity of the sleep function is constant because the execution is paused for a fixed duration specified by the millis parameter.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n O(1)\\nThe sleep function does not require any additional space that grows with the input or time complexity.\\nHence, the space complexity is constant.\\n\\n# Code\\n```\\n/**\\n * @param {number} millis\\n */\\nasync function sleep(millis) {\\n    await new Promise(res => setTimeout(res, millis));\\n}\\n\\n/** \\n * let t = Date.now()\\n * sleep(100).then(() => console.log(Date.now() - t)) // 100\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} millis\\n */\\nasync function sleep(millis) {\\n    await new Promise(res => setTimeout(res, millis));\\n}\\n\\n/** \\n * let t = Date.now()\\n * sleep(100).then(() => console.log(Date.now() - t)) // 100\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3525312,
                "title": "one-line-solution-in-javascript",
                "content": "\\n# Code\\n```\\n/**\\n * @param {number} millis\\n */\\nasync function sleep(millis) {\\n    return new Promise(resolve => setTimeout(resolve, millis))\\n}\\n\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} millis\\n */\\nasync function sleep(millis) {\\n    return new Promise(resolve => setTimeout(resolve, millis))\\n}\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3447745,
                "title": "easy-to-understand-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(1)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number} millis\\n */\\nasync function sleep(millis) {\\n    return new Promise(function (resolve, reject){\\n        setTimeout(()=>{\\n            resolve(millis);\\n        }, millis);\\n    })\\n}\\n\\n/** \\n * let t = Date.now()\\n * sleep(100).then(() => console.log(Date.now() - t)) // 100\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} millis\\n */\\nasync function sleep(millis) {\\n    return new Promise(function (resolve, reject){\\n        setTimeout(()=>{\\n            resolve(millis);\\n        }, millis);\\n    })\\n}\\n\\n/** \\n * let t = Date.now()\\n * sleep(100).then(() => console.log(Date.now() - t)) // 100\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3429443,
                "title": "easy-simple-javascript-solution",
                "content": "\\n```\\n/**\\n * @param {number} millis\\n */\\nasync function sleep(millis) {\\n    await new Promise(resolve=>setTimeout(resolve,millis));\\n    \\n}\\n\\n/** \\n * let t = Date.now()\\n * sleep(100).then(() => console.log(Date.now() - t)) // 100\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} millis\\n */\\nasync function sleep(millis) {\\n    await new Promise(resolve=>setTimeout(resolve,millis));\\n    \\n}\\n\\n/** \\n * let t = Date.now()\\n * sleep(100).then(() => console.log(Date.now() - t)) // 100\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3428070,
                "title": "sleep",
                "content": "<!-- # Intuition -->\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n<!-- # Approach -->\\n<!-- Describe your approach to solving the problem. -->\\n\\n<!-- # Complexity\\n- Time complexity: -->\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n<!-- - Space complexity: -->\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number} millis\\n */\\nasync function sleep(millis) {\\n  let myPromise = new Promise(function (resolve) {\\n    setTimeout(() => resolve(), millis);\\n  });\\n  await myPromise;\\n}\\n/** \\n * let t = Date.now()\\n * sleep(100).then(() => console.log(Date.now() - t)) // 100\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} millis\\n */\\nasync function sleep(millis) {\\n  let myPromise = new Promise(function (resolve) {\\n    setTimeout(() => resolve(), millis);\\n  });\\n  await myPromise;\\n}\\n/** \\n * let t = Date.now()\\n * sleep(100).then(() => console.log(Date.now() - t)) // 100\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3414914,
                "title": "easy-to-understand-solution-beats-70",
                "content": "# Approach\\nThe function sleep takes an input parameter millis which is the number of milliseconds to wait/sleep. It creates a new promise using the Promise constructor which receives a callback function as a parameter. This callback function resolves the promise after waiting for millis milliseconds.\\n\\nThe setTimeout function is used to wait for the specified amount of time (millis) before resolving the promise. Once millis milliseconds have passed, the callback function passed to setTimeout is called, and it resolves the promise by calling the resolve function which is passed to the Promise constructor as a parameter.\\n\\nWhen we use the await keyword to call the sleep function, the current execution context is paused until the promise returned by the sleep function is resolved or rejected. In this case, since the promise is always resolved after the specified number of milliseconds, the await statement waits for that amount of time before continuing with the execution of the code.\\n# Code\\n```\\nfunction sleep(millis) {\\n  return new Promise(resolve => setTimeout(resolve, millis));\\n}\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nfunction sleep(millis) {\\n  return new Promise(resolve => setTimeout(resolve, millis));\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3409722,
                "title": "100-best-solution-in-terms-of-s-t-and-t-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. --> The function is simple that use a inbuilt function in js library\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->The sleep function is an asynchronous function that provides a way to pause the execution of a program for a specified amount of time without blocking other operations.\\n\\nThe function uses the setTimeout function to delay the execution of the resolve function passed to the Promise constructor by millis milliseconds. The resolve function is called once the delay has completed, indicating that the specified amount of time has passed.\\n\\nBy wrapping this setTimeout function call inside a Promise, the sleep function returns a Promise that can be awaited by the calling code, allowing the program to continue executing other tasks until the delay has completed. Once the delay has completed, the sleep function resolves the Promise with the string \"Sleep finished\", indicating that the specified amount of time has elapsed.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->O(millis) \\n\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ --> O(1)\\n\\nplease upvote as it helps us .\\n\\n\\n# Code\\n```\\n/**\\n * @param {number} millis\\n */\\nasync function sleep(millis) {\\n    await new Promise(resolve => setTimeout(resolve , millis));\\n    return millis;\\n}\\n\\n/** \\n * let t = Date.now()\\n * sleep(100).then(() => console.log(Date.now() - t)) // 100\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} millis\\n */\\nasync function sleep(millis) {\\n    await new Promise(resolve => setTimeout(resolve , millis));\\n    return millis;\\n}\\n\\n/** \\n * let t = Date.now()\\n * sleep(100).then(() => console.log(Date.now() - t)) // 100\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3406466,
                "title": "make-a-promise",
                "content": "```\\n/**\\n * @param {number} millis\\n */\\nasync function sleep(millis) {\\n    return new Promise(resolve => setTimeout(resolve, millis));\\n}\\n\\n/** \\n * let t = Date.now()\\n * sleep(100).then(() => console.log(Date.now() - t)) // 100\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} millis\\n */\\nasync function sleep(millis) {\\n    return new Promise(resolve => setTimeout(resolve, millis));\\n}\\n\\n/** \\n * let t = Date.now()\\n * sleep(100).then(() => console.log(Date.now() - t)) // 100\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3914351,
                "title": "simple-short-solution",
                "content": "# Code\\n```\\n/**\\n * @param {number} millis\\n */\\nasync function sleep(millis) {\\n    await new Promise((resolve) => {\\n        setTimeout(resolve, millis)\\n    });\\n}\\n\\n/** \\n * let t = Date.now()\\n * sleep(100).then(() => console.log(Date.now() - t)) // 100\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} millis\\n */\\nasync function sleep(millis) {\\n    await new Promise((resolve) => {\\n        setTimeout(resolve, millis)\\n    });\\n}\\n\\n/** \\n * let t = Date.now()\\n * sleep(100).then(() => console.log(Date.now() - t)) // 100\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3882252,
                "title": "javascript",
                "content": "# Code\\n```\\n/**\\n * @param {number} millis\\n */\\nasync function sleep(millis) {\\n    return new Promise(resolve => setTimeout(resolve, millis));\\n}\\n\\n/** \\n * let t = Date.now()\\n * sleep(100).then(() => console.log(Date.now() - t)) // 100\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} millis\\n */\\nasync function sleep(millis) {\\n    return new Promise(resolve => setTimeout(resolve, millis));\\n}\\n\\n/** \\n * let t = Date.now()\\n * sleep(100).then(() => console.log(Date.now() - t)) // 100\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3816991,
                "title": "solution-with-detailed-explanation",
                "content": "# Intuition\\nThis `sleep` function is an `asynchronous` function that introduces a delay to program execution.\\n## How to know `sleep` is an `asynchronous` function?\\n`async` keyword is used to define a function as asynchronous. An asynchronous function returns a `Promise`, even if we don\\'t explicitly define one inside the function.\\n\\n`await` keyword can only be used inside the `async` function. It is used to pause the function execution until the awaited Promise is resolved.\\n## Why need a `delay`?\\nBecause the function needs to wait for users to input specified time `millis` to be executed.\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. To introduce a delay, we use the `await` keyword\\n2. Promise.resolve() is used to create a `resolved` Promise at once, allowing use to chain `.then()` right after\\n3. `.then()` method is used to define what should happen when a Promise is resolved\\n4. An `arrow` function is passed inside `.then()` to create a `new` Promise\\n5. Inside the new Promise, `setTimeout` function is used to achieve the desired `millis`\\n6. `setTimeout` function is a built-in feature inside JavaScript that allow us to schedule the function execution after a specified delay.\\n```\\n// `setTimeout` function syntax\\n\\nsetTimeout(callbackFunction, delayInMilliseconds, ...args)\\n\\n//`callbackFunction`: function to execute after the delay\\n//`delayInMilliseconds`: delayed time\\n//`...args`: any arguments passed to callbackFunction\\n\\n```\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n`O(1)`: Big O\\'s of one - a constant time complexity because the `millis` value is the main factor determining the function\\'s execution time. In simple terms, it means the execution time remains the same, regardless of the input size\\n\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n`O(1)`: constant space complexity indicates that memory/space amount used by an algorithm or a function remains regardless of the input size. (in this case is `millis`)\\nSpace Usage in the `sleep` function breakdown:\\n`Function Overhead`: requires some memory space for execution\\n`Promises and Callback`: This function uses `Promises` and `asynchronous callback`, but these don\\'t affect the space complexity because they are managed by the JS runtime environment\\n# Code\\n```\\n/**\\n * @param {number} millis\\n */\\nasync function sleep(millis) {\\n    await Promise.resolve().then(() => new Promise(resolve => setTimeout(resolve, millis)));\\n}\\n\\n/** \\n * let t = Date.now()\\n * sleep(100).then(() => console.log(Date.now() - t)) // 100\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n// `setTimeout` function syntax\\n\\nsetTimeout(callbackFunction, delayInMilliseconds, ...args)\\n\\n//`callbackFunction`: function to execute after the delay\\n//`delayInMilliseconds`: delayed time\\n//`...args`: any arguments passed to callbackFunction\\n\\n```\n```\\n/**\\n * @param {number} millis\\n */\\nasync function sleep(millis) {\\n    await Promise.resolve().then(() => new Promise(resolve => setTimeout(resolve, millis)));\\n}\\n\\n/** \\n * let t = Date.now()\\n * sleep(100).then(() => console.log(Date.now() - t)) // 100\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3749917,
                "title": "javascript-easy-readable-code",
                "content": "\\n\\n# Code\\n```\\n/**\\n * @param {number} millis\\n */\\nasync function sleep(millis) {\\n  return new Promise(resolve => {\\n    setTimeout(() => {\\n      resolve(millis);\\n    }, millis);\\n  });\\n}\\n\\n\\n\\n let t = Date.now()\\n sleep(100).then(() => console.log(Date.now() - t)) // 100\\n \\n```",
                "solutionTags": [
                    "JavaScript",
                    "String",
                    "Number Theory"
                ],
                "code": "```\\n/**\\n * @param {number} millis\\n */\\nasync function sleep(millis) {\\n  return new Promise(resolve => {\\n    setTimeout(() => {\\n      resolve(millis);\\n    }, millis);\\n  });\\n}\\n\\n\\n\\n let t = Date.now()\\n sleep(100).then(() => console.log(Date.now() - t)) // 100\\n \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3733118,
                "title": "one-liner-easy-solution",
                "content": "<!-- # Intuition -->\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n<!-- # Approach -->\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n<!-- - Time complexity: -->\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number} millis\\n */\\nconst sleep = async (millis) => new Promise( resolve => setTimeout(()=> resolve(millis), millis))\\n\\n/** \\n * let t = Date.now()\\n * sleep(100).then(() => console.log(Date.now() - t)) // 100\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} millis\\n */\\nconst sleep = async (millis) => new Promise( resolve => setTimeout(()=> resolve(millis), millis))\\n\\n/** \\n * let t = Date.now()\\n * sleep(100).then(() => console.log(Date.now() - t)) // 100\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3565258,
                "title": "easy-solution",
                "content": "# Code\\n```\\n/**\\n * @param {number} millis\\n */\\nasync function sleep(millis) {\\n    return new Promise((resolve, reject)=>{\\n        setTimeout(()=>{\\n            resolve()\\n        }, millis)\\n    })\\n}\\n\\n/** \\n * let t = Date.now()\\n * sleep(100).then(() => console.log(Date.now() - t)) // 100\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} millis\\n */\\nasync function sleep(millis) {\\n    return new Promise((resolve, reject)=>{\\n        setTimeout(()=>{\\n            resolve()\\n        }, millis)\\n    })\\n}\\n\\n/** \\n * let t = Date.now()\\n * sleep(100).then(() => console.log(Date.now() - t)) // 100\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3525203,
                "title": "javascript-day-11-of-30-days-challange",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number} millis\\n */\\nasync function sleep(millis) {\\n    \\n    return new Promise((resolve, reject) => {\\n        setTimeout(()=>{\\n            resolve(millis);\\n        }, millis);\\n    });\\n    \\n}\\n\\n/** \\n * let t = Date.now()\\n * sleep(100).then(() => console.log(Date.now() - t)) // 100\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} millis\\n */\\nasync function sleep(millis) {\\n    \\n    return new Promise((resolve, reject) => {\\n        setTimeout(()=>{\\n            resolve(millis);\\n        }, millis);\\n    });\\n    \\n}\\n\\n/** \\n * let t = Date.now()\\n * sleep(100).then(() => console.log(Date.now() - t)) // 100\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3502946,
                "title": "using-while-loop-blocked-the-main-thread",
                "content": "\\n\\n```\\nasync function sleep(millis) {\\n    let t=Date.now();\\n    let newT=millis+t;\\n    while(Date.now()<newT){\\n\\t   // blocked the main thread\\n    }\\n}",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "\\n\\n```\\nasync function sleep(millis) {\\n    let t=Date.now();\\n    let newT=millis+t;\\n    while(Date.now()<newT){\\n\\t   // blocked the main thread\\n    }\\n}",
                "codeTag": "Unknown"
            },
            {
                "id": 3454956,
                "title": "settimeout",
                "content": "```\\n/**\\n * @param {number} millis\\n */\\nasync function sleep(millis) {\\n    // Returning the promise after millis second \\n      return new Promise(function(resolve) {\\n          setTimeout(resolve,millis);\\n      })\\n}\\n\\n/** \\n * let t = Date.now()\\n * sleep(100).then(() => console.log(Date.now() - t)) // 100\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} millis\\n */\\nasync function sleep(millis) {\\n    // Returning the promise after millis second \\n      return new Promise(function(resolve) {\\n          setTimeout(resolve,millis);\\n      })\\n}\\n\\n/** \\n * let t = Date.now()\\n * sleep(100).then(() => console.log(Date.now() - t)) // 100\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3413720,
                "title": "async-function-promises-concept-types",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWhen an async function is called in javascript, it always returns a Promise, which resolves with the return value of the function or rejects with an error if the function throws an exception.\\n\\n**Now, What are promises exactly?**\\nPromises are a feature in JavaScript used to handle asynchronous operations. They are objects that represent the eventual completion (or failure) of an asynchronous operation and allow you to handle the result of that operation when it\\'s ready.\\n\\nA Promise has $$three$$ states:\\n\\n**Pending:** The initial state of a Promise, before it\\'s either resolved or rejected.\\n**Resolved:** The state of a Promise when it has successfully completed.\\n**Rejected:** The state of a Promise when it has failed.\\n\\nPromises are commonly used with asynchronous operations like fetching data from a server or reading a file. They make it easier to write and read asynchronous code by allowing you to chain operations together and handle errors in a centralized way.\\n\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe are creating a Promise that resolves after a delay of $$millis$$:\\n\\n# Code\\n```\\n/**\\n * @param {number} millis\\n */\\n\\nasync function sleep(millis) {\\n    const promise = new Promise((resolve, reject) => {\\n        setTimeout(()=>{\\n            resolve(millis);\\n        }, millis)\\n    });\\n\\n    return promise;\\n}\\n/** \\n * let t = Date.now()\\n * sleep(100).then(() => console.log(Date.now() - t)) // 100\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} millis\\n */\\n\\nasync function sleep(millis) {\\n    const promise = new Promise((resolve, reject) => {\\n        setTimeout(()=>{\\n            resolve(millis);\\n        }, millis)\\n    });\\n\\n    return promise;\\n}\\n/** \\n * let t = Date.now()\\n * sleep(100).then(() => console.log(Date.now() - t)) // 100\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3411865,
                "title": "easy-solution-using-promise",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number} millis\\n */\\nasync function sleep(millis) {\\n    return new Promise((resolve) => {\\n        setTimeout(() => resolve(), millis)\\n    })\\n}\\n\\n/** \\n * let t = Date.now()\\n * sleep(100).then(() => console.log(Date.now() - t)) // 100\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} millis\\n */\\nasync function sleep(millis) {\\n    return new Promise((resolve) => {\\n        setTimeout(() => resolve(), millis)\\n    })\\n}\\n\\n/** \\n * let t = Date.now()\\n * sleep(100).then(() => console.log(Date.now() - t)) // 100\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3408556,
                "title": "100-fast-and-concise-solution",
                "content": "\\n# Complexity\\n- Time complexity: O(1)\\n- Space complexity: O(1)\\n\\n# Code\\n```\\n/**\\n * @param {number} millis\\n */\\n \\nasync function sleep(millis) {\\n    let t = Date.now();\\n    await new Promise(resolve => setTimeout(resolve, millis));\\n    console.log(Date.now() - t);\\n}\\n\\n\\n/** \\n * let t = Date.now()\\n * sleep(100).then(() => console.log(Date.now() - t)) // 100\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} millis\\n */\\n \\nasync function sleep(millis) {\\n    let t = Date.now();\\n    await new Promise(resolve => setTimeout(resolve, millis));\\n    console.log(Date.now() - t);\\n}\\n\\n\\n/** \\n * let t = Date.now()\\n * sleep(100).then(() => console.log(Date.now() - t)) // 100\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3407435,
                "title": "settimeout",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number} millis\\n */\\nasync function sleep(millis) {\\n    return new Promise((resolve) => {\\n        setTimeout(() => {\\n            resolve()\\n        }, millis)\\n    });\\n}\\n\\n/** \\n * let t = Date.now()\\n * sleep(100).then(() => console.log(Date.now() - t)) // 100\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} millis\\n */\\nasync function sleep(millis) {\\n    return new Promise((resolve) => {\\n        setTimeout(() => {\\n            resolve()\\n        }, millis)\\n    });\\n}\\n\\n/** \\n * let t = Date.now()\\n * sleep(100).then(() => console.log(Date.now() - t)) // 100\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4098760,
                "title": "2621-sleep-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe solution should be a promise\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nCreate a promise that resolves after a cetrain time\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n(o)1\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n(o)1\\n\\n# Code\\n```\\n/**\\n * @param {number} millis\\n */\\nasync function sleep(millis) {\\n     return new Promise(resolve => setTimeout(resolve, millis))\\n}\\n\\n/** \\n * let t = Date.now()\\n * sleep(100).then(() => console.log(Date.now() - t)) // 100\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} millis\\n */\\nasync function sleep(millis) {\\n     return new Promise(resolve => setTimeout(resolve, millis))\\n}\\n\\n/** \\n * let t = Date.now()\\n * sleep(100).then(() => console.log(Date.now() - t)) // 100\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4097829,
                "title": "solution-without-keyword-promise",
                "content": "\\nMy solution:\\n\\n# Code\\n```\\n// Return Thenable object\\nasync function sleep(millis) {\\n  return { then(resolve) { setTimeout(resolve, millis) } }\\n}\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n// Return Thenable object\\nasync function sleep(millis) {\\n  return { then(resolve) { setTimeout(resolve, millis) } }\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4096941,
                "title": "sleep-problem-with-constant-time-complexity-using-ts",
                "content": "\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$Big-O = O(1) - Constant$$\\n# Code\\n```\\n    /**\\n * @param {number} millis\\n * @return {Promise}\\n */\\nasync function sleep(millis: number) : Promise<void> {\\n  return new Promise<void>((resolve) => {\\n    setTimeout(() => {\\n      resolve();\\n    }, millis);\\n  });\\n}\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\n    /**\\n * @param {number} millis\\n * @return {Promise}\\n */\\nasync function sleep(millis: number) : Promise<void> {\\n  return new Promise<void>((resolve) => {\\n    setTimeout(() => {\\n      resolve();\\n    }, millis);\\n  });\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4096167,
                "title": "easy-and-straight-forward-answer",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number} millis\\n * @return {Promise}\\n */\\nasync function sleep(millis) {\\n    let promise = new Promise(function(resolve){\\n        setTimeout (()=>resolve(),millis)\\n    });\\n    await promise;\\n}\\n\\n/** \\n * let t = Date.now()\\n * sleep(100).then(() => console.log(Date.now() - t)) // 100\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} millis\\n * @return {Promise}\\n */\\nasync function sleep(millis) {\\n    let promise = new Promise(function(resolve){\\n        setTimeout (()=>resolve(),millis)\\n    });\\n    await promise;\\n}\\n\\n/** \\n * let t = Date.now()\\n * sleep(100).then(() => console.log(Date.now() - t)) // 100\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4093316,
                "title": "typescript-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nasync function sleep(millis: number): Promise<void> {\\n   return new Promise<void>((resolve) => {\\n    setTimeout(resolve, millis);\\n  });\\n}\\n\\n\\n/** \\n * let t = Date.now()\\n * sleep(100).then(() => console.log(Date.now() - t)) // 100\\n */\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\nasync function sleep(millis: number): Promise<void> {\\n   return new Promise<void>((resolve) => {\\n    setTimeout(resolve, millis);\\n  });\\n}\\n\\n\\n/** \\n * let t = Date.now()\\n * sleep(100).then(() => console.log(Date.now() - t)) // 100\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4087020,
                "title": "asynchronous-sleep-function-in-javascript",
                "content": "# Intuition\\nThe problem requires us to create an asynchronous function that sleeps for a specified number of milliseconds before resolving. To do this, we can use JavaScript\\'s setTimeout function to introduce a delay.\\n\\n# Approach\\n1. Define an asynchronous function sleep that takes a millis parameter.\\n2. Inside the function, create a Promise that resolves after millis milliseconds.\\n3. Use setTimeout to delay the resolution of the Promise by the specified time.\\n4. Return the Promise.\\n5. In the example usage, measure the time elapsed between the start time and the time when the Promise resolves.\\n\\n# Complexity\\n- Time complexity:\\n$$O(1)$$ \\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```\\n/**\\n * @param {number} millis\\n */\\nasync function sleep(millis) {\\n  return new Promise((resolve) => {\\n    setTimeout(() => {\\n      resolve(millis);\\n    }, millis);\\n  });\\n}\\n\\nlet t = Date.now();\\nsleep(100).then(() => {\\n  console.log(Date.now() - t);\\n});\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} millis\\n */\\nasync function sleep(millis) {\\n  return new Promise((resolve) => {\\n    setTimeout(() => {\\n      resolve(millis);\\n    }, millis);\\n  });\\n}\\n\\nlet t = Date.now();\\nsleep(100).then(() => {\\n  console.log(Date.now() - t);\\n});\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4084385,
                "title": "sleep-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number} millis\\n */\\nasync function sleep(millis) {\\n    let delay =  new Promise(resolve => setTimeout(()=>\\n    resolve(),millis\\n    ))\\n    return await delay;\\n}\\n\\n/** \\n * let t = Date.now()\\n * sleep(100).then(() => console.log(Date.now() - t)) // 100\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} millis\\n */\\nasync function sleep(millis) {\\n    let delay =  new Promise(resolve => setTimeout(()=>\\n    resolve(),millis\\n    ))\\n    return await delay;\\n}\\n\\n/** \\n * let t = Date.now()\\n * sleep(100).then(() => console.log(Date.now() - t)) // 100\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4084316,
                "title": "using-promise-and-timeout",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number} millis\\n */\\nasync function sleep(millis) {\\n    return new Promise((resolve)=>{\\n        setTimeout(() =>{\\n            resolve()\\n        },millis);\\n    })\\n    \\n}\\n\\n/** \\n * let t = Date.now()\\n * sleep(100).then(() => console.log(Date.now() - t)) // 100\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} millis\\n */\\nasync function sleep(millis) {\\n    return new Promise((resolve)=>{\\n        setTimeout(() =>{\\n            resolve()\\n        },millis);\\n    })\\n    \\n}\\n\\n/** \\n * let t = Date.now()\\n * sleep(100).then(() => console.log(Date.now() - t)) // 100\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4082354,
                "title": "sleep-js-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nletter by letter. \\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number} millis\\n */\\nasync function sleep(millis) {\\n    let t = Date.now();\\n    await new Promise((resolve)=>{\\n        setTimeout(()=>{\\n            resolve(Date.now())   \\n        }, millis)\\n    }).then((result) => console.log(result - t));\\n}\\n\\n/** \\n * let t = Date.now()\\n * sleep(100).then(() => console.log(Date.now() - t)) // 100\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} millis\\n */\\nasync function sleep(millis) {\\n    let t = Date.now();\\n    await new Promise((resolve)=>{\\n        setTimeout(()=>{\\n            resolve(Date.now())   \\n        }, millis)\\n    }).then((result) => console.log(result - t));\\n}\\n\\n/** \\n * let t = Date.now()\\n * sleep(100).then(() => console.log(Date.now() - t)) // 100\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4081928,
                "title": "promises-with-timeout",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number} millis\\n */\\nasync function sleep(millis) {\\n    return new Promise((resolve, reject) => setTimeout(resolve, millis))\\n}\\n\\n/** \\n * let t = Date.now()\\n * sleep(100).then(() => console.log(Date.now() - t)) // 100\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} millis\\n */\\nasync function sleep(millis) {\\n    return new Promise((resolve, reject) => setTimeout(resolve, millis))\\n}\\n\\n/** \\n * let t = Date.now()\\n * sleep(100).then(() => console.log(Date.now() - t)) // 100\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4081212,
                "title": "js-1line",
                "content": "\\n\\n# Code\\n```\\n/**\\n * @param {number} millis\\n */\\nasync function sleep(millis) {\\n    return new Promise((resolve) => setTimeout(() => resolve(), millis));\\n}\\n\\n/** \\n * let t = Date.now()\\n * sleep(100).then(() => console.log(Date.now() - t)) // 100\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} millis\\n */\\nasync function sleep(millis) {\\n    return new Promise((resolve) => setTimeout(() => resolve(), millis));\\n}\\n\\n/** \\n * let t = Date.now()\\n * sleep(100).then(() => console.log(Date.now() - t)) // 100\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4076249,
                "title": "javascript-sleep-promise",
                "content": "\\n```\\n/**\\n * @param {number} millis\\n */\\nconst sleep = async (millis) => new Promise((resolve) => setTimeout(() => resolve(), millis))\\n\\n/** \\n * let t = Date.now()\\n * sleep(100).then(() => console.log(Date.now() - t)) // 100\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} millis\\n */\\nconst sleep = async (millis) => new Promise((resolve) => setTimeout(() => resolve(), millis))\\n\\n/** \\n * let t = Date.now()\\n * sleep(100).then(() => console.log(Date.now() - t)) // 100\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4067466,
                "title": "only-one-line-of-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number} millis\\n */\\nasync function sleep(millis) {\\n    await new Promise(solve => setTimeout(solve, millis));\\n}\\n\\n/** \\n * let t = Date.now()\\n * sleep(100).then(() => console.log(Date.now() - t)) // 100\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} millis\\n */\\nasync function sleep(millis) {\\n    await new Promise(solve => setTimeout(solve, millis));\\n}\\n\\n/** \\n * let t = Date.now()\\n * sleep(100).then(() => console.log(Date.now() - t)) // 100\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4067270,
                "title": "my-first-leetcode-problem-solved-as-a-self-taught-coder",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number} millis\\n */\\nasync function sleep(millis) {\\n    return new Promise(resolve => {\\n      setTimeout(() => {\\n        resolve(millis);\\n      }, millis);\\n    });\\n  }\\n  \\n  let t = Date.now();\\n  sleep(100).then(() => {\\n    console.log(Date.now() - t); // 100\\n  });\\n/** \\n * let t = Date.now()\\n * sleep(100).then(() => console.log(Date.now() - t)) // 100\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} millis\\n */\\nasync function sleep(millis) {\\n    return new Promise(resolve => {\\n      setTimeout(() => {\\n        resolve(millis);\\n      }, millis);\\n    });\\n  }\\n  \\n  let t = Date.now();\\n  sleep(100).then(() => {\\n    console.log(Date.now() - t); // 100\\n  });\\n/** \\n * let t = Date.now()\\n * sleep(100).then(() => console.log(Date.now() - t)) // 100\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4060726,
                "title": "simple-solution-in-js-ts",
                "content": "# Code\\n```\\nasync function sleep(millis: number): Promise<void> {\\n    return new Promise((res) => {\\n      setTimeout(() => {\\n        res();\\n      }, millis)\\n    })\\n}\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\nasync function sleep(millis: number): Promise<void> {\\n    return new Promise((res) => {\\n      setTimeout(() => {\\n        res();\\n      }, millis)\\n    })\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4057118,
                "title": "meh",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number} millis\\n */\\n \\nasync function sleep(millis) {\\n    return new Promise((resolve, reject) => {\\n        const interval = setInterval(() => {\\n            resolve();\\n            clearInterval(interval);\\n        }, millis)\\n    })\\n}\\n\\n/** \\n * let t = Date.now()\\n * sleep(100).then(() => console.log(Date.now() - t)) // 100\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} millis\\n */\\n \\nasync function sleep(millis) {\\n    return new Promise((resolve, reject) => {\\n        const interval = setInterval(() => {\\n            resolve();\\n            clearInterval(interval);\\n        }, millis)\\n    })\\n}\\n\\n/** \\n * let t = Date.now()\\n * sleep(100).then(() => console.log(Date.now() - t)) // 100\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4052913,
                "title": "sleep",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number} millis\\n */\\nasync function sleep(millis) {\\n    return new Promise(resolve=>setTimeout(resolve,millis))\\n}\\n\\n/** \\n * let t = Date.now()\\n * sleep(100).then(() => console.log(Date.now() - t)) // 100\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} millis\\n */\\nasync function sleep(millis) {\\n    return new Promise(resolve=>setTimeout(resolve,millis))\\n}\\n\\n/** \\n * let t = Date.now()\\n * sleep(100).then(() => console.log(Date.now() - t)) // 100\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4047892,
                "title": "challenge-1",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number} millis\\n */\\nasync function sleep(millis) {\\n   return new Promise((resolve) => {\\n     setTimeout(() => {\\n       resolve()\\n     }, millis)\\n   }) \\n}\\n\\n \\nlet t = Date.now()\\nsleep(100).then(() => console.log(Date.now() - t)) // 100\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} millis\\n */\\nasync function sleep(millis) {\\n   return new Promise((resolve) => {\\n     setTimeout(() => {\\n       resolve()\\n     }, millis)\\n   }) \\n}\\n\\n \\nlet t = Date.now()\\nsleep(100).then(() => console.log(Date.now() - t)) // 100\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4047270,
                "title": "as",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number} millis\\n */\\nasync function sleep(millis) {\\n await new Promise(resolve => setTimeout(resolve, millis));\\n}\\n\\n/** \\n * let t = Date.now()\\n * sleep(100).then(() => console.log(Date.now() - t)) // 100\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} millis\\n */\\nasync function sleep(millis) {\\n await new Promise(resolve => setTimeout(resolve, millis));\\n}\\n\\n/** \\n * let t = Date.now()\\n * sleep(100).then(() => console.log(Date.now() - t)) // 100\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4046005,
                "title": "96-99-speed-97-47-memory",
                "content": "The test allows for some variance in the timeout up to -10,  just keep running and get lucky.\\n\\n# Code\\n```\\nconst sleep = async (millis: number): Promise<void> => new Promise((resolve) => setTimeout(() => { resolve() }, millis - 10));\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\nconst sleep = async (millis: number): Promise<void> => new Promise((resolve) => setTimeout(() => { resolve() }, millis - 10));\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4041303,
                "title": "javascript-simple-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number} millis\\n */\\nasync function sleep(millis) {\\n    return new Promise((resolve) => {\\n        setTimeout(resolve, millis);\\n    });\\n}\\n\\n/** \\n * let t = Date.now()\\n * sleep(100).then(() => console.log(Date.now() - t)) // 100\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} millis\\n */\\nasync function sleep(millis) {\\n    return new Promise((resolve) => {\\n        setTimeout(resolve, millis);\\n    });\\n}\\n\\n/** \\n * let t = Date.now()\\n * sleep(100).then(() => console.log(Date.now() - t)) // 100\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4039382,
                "title": "simple-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number} millis\\n */\\nasync function sleep(millis) {\\n    return new Promise((resolve,reject)=>{\\n             setTimeout(resolve,millis);\\n      });\\n}\\n\\n/** \\n * let t = Date.now()\\n * sleep(100).then(() => console.log(Date.now() - t)) // 100\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} millis\\n */\\nasync function sleep(millis) {\\n    return new Promise((resolve,reject)=>{\\n             setTimeout(resolve,millis);\\n      });\\n}\\n\\n/** \\n * let t = Date.now()\\n * sleep(100).then(() => console.log(Date.now() - t)) // 100\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4039332,
                "title": "milies",
                "content": "**Intuition**\\nThe intuition behind this code is to create an asynchronous `function` that allows the program to sleep (pause execution) for a specified number of milliseconds. This is achieved using JavaScript\\'s setTimeout function, which schedules a callback to be executed after a given delay.\\n\\n![codeimage](https://www.thecoderpedia.com/wp-content/uploads/2020/06/Programming-Memes-Programmer-while-sleeping.jpg?x86257)\\n**Approach**\\nThe approach involves defining an asynchronous function named sleep that takes a parameter millis, representing the number of milliseconds to sleep. Inside this function, we create a Promise and use setTimeout to resolve the Promise after the specified duration, effectively pausing the execution of the program for that duration.\\n\\nComplexity\\nTime complexity: The time complexity of this code is `O(1)`. The setTimeout function schedules the execution of resolve after a fixed delay, so the time it takes to execute does not depend on the value of millis.\\n\\nSpace complexity: The space complexity is `O(1)` as well. We are not using any additional data structures that grow with the input. The memory usage is constant.\\n# Code\\n```\\nasync function sleep(millis) {\\n  return new Promise((resolve) => {\\n    setTimeout(resolve, millis);\\n  });\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nasync function sleep(millis) {\\n  return new Promise((resolve) => {\\n    setTimeout(resolve, millis);\\n  });\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4038179,
                "title": "javascript-solution",
                "content": "# Code\\n```\\n/**\\n * @param {number} millis\\n */\\nfunction sleep(millis) {\\n    return new Promise((resolve) => {\\n        setTimeout(resolve, millis);\\n    });\\n}\\n\\n/** \\n * let t = Date.now()\\n * sleep(100).then(() => console.log(Date.now() - t)) // 100\\n */\\n```\\nOR\\n```\\nasync function sleep(millis) {\\n    await new Promise((resolve) => {\\n        setTimeout(resolve, millis);\\n    });\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} millis\\n */\\nfunction sleep(millis) {\\n    return new Promise((resolve) => {\\n        setTimeout(resolve, millis);\\n    });\\n}\\n\\n/** \\n * let t = Date.now()\\n * sleep(100).then(() => console.log(Date.now() - t)) // 100\\n */\\n```\n```\\nasync function sleep(millis) {\\n    await new Promise((resolve) => {\\n        setTimeout(resolve, millis);\\n    });\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4034263,
                "title": "using-settimeout",
                "content": "# Intuition\\nWhen we want to simulate a delay in JavaScript, we typically think of the setTimeout function. However, setTimeout is non-blocking and doesn\\'t play well with the modern async/await syntax out of the box. To make setTimeout work with async/await, we can wrap it in a Promise. This will allow us to introduce delays in our async functions seamlessly.\\n\\n# Approach\\n1. Create a new Promise.\\n2. Use setTimeout to introduce a delay.\\n3. Once the delay is over, resolve the promise.\\n4. Since the promise is resolved and not rejected, we don\\'t need a reject function.\\n5. By doing this, we can now use the sleep function with the await keyword in async functions to introduce a delay.\\n\\n\\n\\n# Complexity\\n- Time complexity: O(1)\\nThe function always introduces a delay based on the millis parameter, and the time it takes to set this up is constant.\\n\\n- Space complexity:O(1)\\nThe function only uses a constant amount of space regardless of the input size.\\n\\n# Code\\n```\\n/**\\n * @param {number} millis\\n */\\nfunction sleep(millis) {\\n    return new Promise(resolve => setTimeout(resolve, millis));\\n}\\n\\n/** \\n * let t = Date.now()\\n * sleep(100).then(() => console.log(Date.now() - t)) // 100\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} millis\\n */\\nfunction sleep(millis) {\\n    return new Promise(resolve => setTimeout(resolve, millis));\\n}\\n\\n/** \\n * let t = Date.now()\\n * sleep(100).then(() => console.log(Date.now() - t)) // 100\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4030929,
                "title": "simple",
                "content": "# Intuition\\n\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number} millis\\n */\\nasync function sleep(millis) {\\n    const promise = new Promise((resolve,reject)=>{\\n    setTimeout(()=>{\\n    resolve(millis)\\n    },millis)\\n    })\\n\\n    return await promise\\n}\\n\\n/** \\n * let t = Date.now()\\n * sleep(100).then(() => console.log(Date.now() - t)) // 100\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} millis\\n */\\nasync function sleep(millis) {\\n    const promise = new Promise((resolve,reject)=>{\\n    setTimeout(()=>{\\n    resolve(millis)\\n    },millis)\\n    })\\n\\n    return await promise\\n}\\n\\n/** \\n * let t = Date.now()\\n * sleep(100).then(() => console.log(Date.now() - t)) // 100\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4030129,
                "title": "js-simple-solution",
                "content": "# Code\\n```\\n/**\\n * @param {number} millis\\n */\\nasync function sleep(millis) {\\n    return new Promise(resolve => setTimeout(resolve, millis));\\n}",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "# Code\\n```\\n/**\\n * @param {number} millis\\n */\\nasync function sleep(millis) {\\n    return new Promise(resolve => setTimeout(resolve, millis));\\n}",
                "codeTag": "Unknown"
            },
            {
                "id": 4025428,
                "title": "1-line-best-ts-js-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nconst sleep = async (n: number): Promise<void> => new Promise(e => setTimeout(() => e(), n));\\n\\n\\n\\n/** \\n * let t = Date.now()\\n * sleep(100).then(() => console.log(Date.now() - t)) // 100\\n */\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\nconst sleep = async (n: number): Promise<void> => new Promise(e => setTimeout(() => e(), n));\\n\\n\\n\\n/** \\n * let t = Date.now()\\n * sleep(100).then(() => console.log(Date.now() - t)) // 100\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4015609,
                "title": "sleep-function-with-ukrainian-explanation",
                "content": "# Intuition\\n\\u041E\\u0441\\u043D\\u043E\\u0432\\u043D\\u0430 \\u0444\\u0443\\u043D\\u043A\\u0446\\u0456\\u044F sleep \\u043F\\u0440\\u0438\\u0439\\u043C\\u0430\\u0454 \\u0437\\u043D\\u0430\\u0447\\u0435\\u043D\\u043D\\u044F \\u0437\\u0430\\u0442\\u0440\\u0438\\u043C\\u043A\\u0438 \\u044F\\u043A \\u0430\\u0440\\u0433\\u0443\\u043C\\u0435\\u043D\\u0442. \\u0426\\u044F \\u0444\\u0443\\u043D\\u043A\\u0446\\u0456\\u044F \\u043F\\u043E\\u0432\\u0435\\u0440\\u0442\\u0430\\u0454 Promise, \\u044F\\u043A\\u0438\\u0439 \\u0431\\u0443\\u0434\\u0435 \\u0432\\u0438\\u0440\\u0456\\u0448\\u0435\\u043D\\u0438\\u0439 \\u0447\\u0435\\u0440\\u0435\\u0437 \\u043F\\u0440\\u043E\\u043C\\u0456\\u0436\\u043E\\u043A \\u0447\\u0430\\u0441\\u0443, \\u044F\\u043A\\u0438\\u0439 \\u043C\\u0438 \\u043F\\u0435\\u0440\\u0435\\u0434\\u0430\\u0454\\u043C\\u043E \\u044F\\u043A \\u0430\\u0440\\u0433\\u0443\\u043C\\u0435\\u043D\\u0442 millis. \\u041C\\u0438 \\u0434\\u043E\\u0441\\u044F\\u0433\\u0430\\u0454\\u043C\\u043E \\u0446\\u044C\\u043E\\u0433\\u043E \\u0437\\u0430 \\u0434\\u043E\\u043F\\u043E\\u043C\\u043E\\u0433\\u043E\\u044E setTimeout, \\u0434\\u0435 \\u043F\\u0435\\u0440\\u0448\\u0438\\u043C \\u0430\\u0440\\u0433\\u0443\\u043C\\u0435\\u043D\\u0442\\u043E\\u043C \\u043F\\u0435\\u0440\\u0435\\u0434\\u0430\\u0454\\u043C\\u043E \\u043A\\u043E\\u043B\\u0431\\u0435\\u043A, \\u044F\\u043A\\u0438\\u0439 \\u0432\\u0438\\u0440\\u0456\\u0448\\u0438\\u0442\\u044C \\u043E\\u0431\\u0456\\u0446\\u044F\\u043D\\u043A\\u0443 \\u0431\\u0443\\u0434\\u044C-\\u044F\\u043A\\u0438\\u043C \\u0437\\u043D\\u0430\\u0447\\u0435\\u043D\\u043D\\u044F\\u043C, \\u0430 \\u0434\\u0440\\u0443\\u0433\\u0438\\u043C - \\u0437\\u0430\\u0442\\u0440\\u0438\\u043C\\u043A\\u0443.\\n\\n# Approach\\n1. \\u0421\\u0442\\u0432\\u043E\\u0440\\u044E\\u0454\\u0442\\u044C\\u0441\\u044F \\u0430\\u0441\\u0438\\u043D\\u0445\\u0440\\u043E\\u043D\\u043D\\u0430 \\u0444\\u0443\\u043D\\u043A\\u0446\\u0456\\u044F `sleep` \\u0437 \\u043F\\u0430\\u0440\\u0430\\u043C\\u0435\\u0442\\u0440\\u043E\\u043C `millis`.\\n2. \\u041F\\u043E\\u0442\\u0456\\u043C \\u0441\\u0442\\u0432\\u043E\\u0440\\u044E\\u0454\\u0442\\u044C\\u0441\\u044F Promise, \\u044F\\u043A\\u0438\\u0439 \\u0432\\u0438\\u0440\\u0456\\u0448\\u0443\\u0454\\u0442\\u044C\\u0441\\u044F \\u0447\\u0435\\u0440\\u0435\\u0437 \\u0432\\u043A\\u0430\\u0437\\u0430\\u043D\\u0438\\u0439 \\u043F\\u0440\\u043E\\u043C\\u0456\\u0436\\u043E\\u043A \\u0447\\u0430\\u0441\\u0443 \\u0437\\u0430 \\u0434\\u043E\\u043F\\u043E\\u043C\\u043E\\u0433\\u043E\\u044E \\u0444\\u0443\\u043D\\u043A\\u0446\\u0456\\u0457 setTimeout.\\n3. \\u041E\\u043F\\u0435\\u0440\\u0430\\u0442\\u043E\\u0440 `await` \\u0434\\u043E\\u0437\\u0432\\u043E\\u043B\\u044F\\u0454 \\u0444\\u0443\\u043D\\u043A\\u0446\\u0456\\u0457 \\u043F\\u0440\\u0438\\u0437\\u0443\\u043F\\u0438\\u043D\\u0438\\u0442\\u0438 \\u0432\\u0438\\u043A\\u043E\\u043D\\u0430\\u043D\\u043D\\u044F, \\u0434\\u043E\\u043A\\u0438 \\u043D\\u0435 \\u0431\\u0443\\u0434\\u0435 \\u0432\\u0438\\u0440\\u0456\\u0448\\u0435\\u043D\\u043E \\u043E\\u0431\\u0456\\u0446\\u044F\\u043D\\u043A\\u0443.\\n\\n\\n# Code\\n```\\nasync function sleep(millis: number): Promise<void> { \\n    await new Promise((resolve) => setTimeout(resolve, millis) )\\n}\\n\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "```\\nasync function sleep(millis: number): Promise<void> { \\n    await new Promise((resolve) => setTimeout(resolve, millis) )\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4014031,
                "title": "beats-90-09-of-users-with-javascript",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number} millis\\n */\\nasync function sleep(n){return new Promise(e=>{setTimeout(()=>{e()},n)})}\\n/** \\n * let t = Date.now()\\n * sleep(100).then(() => console.log(Date.now() - t)) // 100\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} millis\\n */\\nasync function sleep(n){return new Promise(e=>{setTimeout(()=>{e()},n)})}\\n/** \\n * let t = Date.now()\\n * sleep(100).then(() => console.log(Date.now() - t)) // 100\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4011888,
                "title": "o-1-solution-to-sleep-in-js",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nCreate a promise object with parameters resolve and reject, call a timeout within that promise using resolve and millis, and then return that promise.\\n\\n# Complexity\\n- Time complexity: O(1)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number} millis\\n */\\nasync function sleep(millis) {\\n    const prom = new Promise((resolve, reject) => {\\n        setTimeout(() => {\\n            resolve();\\n        }, millis);\\n    });\\n    return prom;\\n}\\n\\n/** \\n * let t = Date.now()\\n * sleep(100).then(() => console.log(Date.now() - t)) // 100\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} millis\\n */\\nasync function sleep(millis) {\\n    const prom = new Promise((resolve, reject) => {\\n        setTimeout(() => {\\n            resolve();\\n        }, millis);\\n    });\\n    return prom;\\n}\\n\\n/** \\n * let t = Date.now()\\n * sleep(100).then(() => console.log(Date.now() - t)) // 100\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4010707,
                "title": "simple-solution-50ms",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number} millis\\n */\\nasync function sleep(millis) {\\n    return new Promise((resolve)=>{\\n        setTimeout(()=>{\\n            resolve(millis)\\n        },millis)\\n    })\\n}\\n\\n/** \\n * let t = Date.now()\\n * sleep(100).then(() => console.log(Date.now() - t)) // 100\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} millis\\n */\\nasync function sleep(millis) {\\n    return new Promise((resolve)=>{\\n        setTimeout(()=>{\\n            resolve(millis)\\n        },millis)\\n    })\\n}\\n\\n/** \\n * let t = Date.now()\\n * sleep(100).then(() => console.log(Date.now() - t)) // 100\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4010248,
                "title": "best-of-js",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number} millis\\n */\\nasync function sleep(millis) {\\n    await new Promise(resolve => setTimeout(resolve, millis));\\n}\\n\\n/** \\n * let t = Date.now()\\n * sleep(100).then(() => console.log(Date.now() - t)) // 100\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} millis\\n */\\nasync function sleep(millis) {\\n    await new Promise(resolve => setTimeout(resolve, millis));\\n}\\n\\n/** \\n * let t = Date.now()\\n * sleep(100).then(() => console.log(Date.now() - t)) // 100\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4006067,
                "title": "one-line-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number} millis\\n */\\nasync function sleep(n){return new Promise(e=>{setTimeout(()=>{e()},n)})}\\n/** \\n * let t = Date.now()\\n * sleep(100).then(() => console.log(Date.now() - t)) // 100\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} millis\\n */\\nasync function sleep(n){return new Promise(e=>{setTimeout(()=>{e()},n)})}\\n/** \\n * let t = Date.now()\\n * sleep(100).then(() => console.log(Date.now() - t)) // 100\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3982861,
                "title": "a-simple-solution",
                "content": "\\n# Code\\n```\\n/**\\n * @param {number} millis\\n */\\nasync function sleep(millis) {\\n    return new Promise((resolve) => {\\n        setTimeout(() => {\\n            resolve(\"Done...\")\\n        }, millis)\\n    })\\n}\\n\\n/** \\n * let t = Date.now()\\n * sleep(100).then(() => console.log(Date.now() - t)) // 100\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} millis\\n */\\nasync function sleep(millis) {\\n    return new Promise((resolve) => {\\n        setTimeout(() => {\\n            resolve(\"Done...\")\\n        }, millis)\\n    })\\n}\\n\\n/** \\n * let t = Date.now()\\n * sleep(100).then(() => console.log(Date.now() - t)) // 100\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3981318,
                "title": "simple-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number} millis\\n */\\nasync function sleep(millis) {\\n    return new Promise((resolve) => {\\n        setTimeout(resolve, millis);\\n    });\\n}\\n\\n/** \\n * let t = Date.now()\\n * sleep(100).then(() => console.log(Date.now() - t)) // 100\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} millis\\n */\\nasync function sleep(millis) {\\n    return new Promise((resolve) => {\\n        setTimeout(resolve, millis);\\n    });\\n}\\n\\n/** \\n * let t = Date.now()\\n * sleep(100).then(() => console.log(Date.now() - t)) // 100\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3980879,
                "title": "using-settimeout-built-in-function",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number} millis\\n */\\nasync function sleep(millis) {\\n    return new Promise((resolve) => {\\n        setTimeout(resolve, millis);\\n    })\\n}\\n\\n/** \\n * let t = Date.now()\\n * sleep(100).then(() => console.log(Date.now() - t)) // 100\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} millis\\n */\\nasync function sleep(millis) {\\n    return new Promise((resolve) => {\\n        setTimeout(resolve, millis);\\n    })\\n}\\n\\n/** \\n * let t = Date.now()\\n * sleep(100).then(() => console.log(Date.now() - t)) // 100\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3977366,
                "title": "very-easy",
                "content": "\\n# Code\\n```\\n/**\\n * @param {number} millis\\n */\\nasync function sleep(millis) {\\n    return new Promise(resolve=>\\n    setTimeout(resolve,millis)\\n)}\\n\\n/** \\n * let t = Date.now()\\n * sleep(100).then(() => console.log(Date.now() - t)) // 100\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} millis\\n */\\nasync function sleep(millis) {\\n    return new Promise(resolve=>\\n    setTimeout(resolve,millis)\\n)}\\n\\n/** \\n * let t = Date.now()\\n * sleep(100).then(() => console.log(Date.now() - t)) // 100\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3977008,
                "title": "titan",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number} millis\\n */\\nasync function sleep(millis) {\\n    await new Promise(resolve => setTimeout(resolve, millis));\\n}\\n\\n/** \\n * let t = Date.now()\\n * sleep(100).then(() => console.log(Date.now() - t)) // 100\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} millis\\n */\\nasync function sleep(millis) {\\n    await new Promise(resolve => setTimeout(resolve, millis));\\n}\\n\\n/** \\n * let t = Date.now()\\n * sleep(100).then(() => console.log(Date.now() - t)) // 100\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3976043,
                "title": "my-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nMake a promise that delays 3000 milisecond.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nOur function need a promise. So create a new promise. Need to resolve in 3000 milisecond, \\nso use setTimeout(resolve, 3000) to delay execution of our resolve function.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number} millis\\n */\\nasync function sleep(millis) {\\n    const neededPromise = new Promise((resolve) => {\\n        setTimeout(resolve, millis);\\n    })\\n    return neededPromise;\\n}\\n\\n/** \\n * let t = Date.now()\\n * sleep(100).then(() => console.log(Date.now() - t)) // 100\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} millis\\n */\\nasync function sleep(millis) {\\n    const neededPromise = new Promise((resolve) => {\\n        setTimeout(resolve, millis);\\n    })\\n    return neededPromise;\\n}\\n\\n/** \\n * let t = Date.now()\\n * sleep(100).then(() => console.log(Date.now() - t)) // 100\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3972650,
                "title": "solution-beats-90",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number} millis\\n */\\nasync function sleep(millis) {\\n      return new Promise(resolve => setTimeout(resolve, millis));\\n}\\n\\n/** \\n * let t = Date.now()\\n * sleep(100).then(() => console.log(Date.now() - t)) // 100\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} millis\\n */\\nasync function sleep(millis) {\\n      return new Promise(resolve => setTimeout(resolve, millis));\\n}\\n\\n/** \\n * let t = Date.now()\\n * sleep(100).then(() => console.log(Date.now() - t)) // 100\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3965515,
                "title": "promise-with-sleep-wait",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number} millis\\n */\\nasync function sleep(millis) {\\n   return new Promise(resolve=>{\\n       setTimeout(()=>resolve(millis),millis)\\n   })\\n}\\n\\n/** \\n * let t = Date.now()\\n * sleep(100).then(() => console.log(Date.now() - t)) // 100\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} millis\\n */\\nasync function sleep(millis) {\\n   return new Promise(resolve=>{\\n       setTimeout(()=>resolve(millis),millis)\\n   })\\n}\\n\\n/** \\n * let t = Date.now()\\n * sleep(100).then(() => console.log(Date.now() - t)) // 100\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3961223,
                "title": "solution-using-promise-concept",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number} millis\\n */\\nasync function sleep(millis) {\\n    return new Promise((resolve, reject) => {\\n        setTimeout(function (){\\n            resolve()\\n        },millis)\\n    })\\n}\\n\\n/** \\n * let t = Date.now()\\n * sleep(100).then(() => console.log(Date.now() - t)) // 100\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} millis\\n */\\nasync function sleep(millis) {\\n    return new Promise((resolve, reject) => {\\n        setTimeout(function (){\\n            resolve()\\n        },millis)\\n    })\\n}\\n\\n/** \\n * let t = Date.now()\\n * sleep(100).then(() => console.log(Date.now() - t)) // 100\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3957771,
                "title": "simple-solution-using-javascript",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number} millis\\n */\\nasync function sleep(millis) {\\n    return new Promise(\\n        resolve => setTimeout(() => resolve(), millis)\\n    )\\n}\\n\\n/** \\n * let t = Date.now()\\n * sleep(100).then(() => console.log(Date.now() - t)) // 100\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} millis\\n */\\nasync function sleep(millis) {\\n    return new Promise(\\n        resolve => setTimeout(() => resolve(), millis)\\n    )\\n}\\n\\n/** \\n * let t = Date.now()\\n * sleep(100).then(() => console.log(Date.now() - t)) // 100\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3956034,
                "title": "settimeout-1-liner",
                "content": "# Approach\\nAwait a promise that resolves after x miliseconds using a setTimeout function.\\n\\n# Code\\n```\\n/**\\n * @param {number} millis\\n */\\nasync function sleep(millis) {\\n    await new Promise(resolve => setTimeout(() => resolve(1), millis))\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} millis\\n */\\nasync function sleep(millis) {\\n    await new Promise(resolve => setTimeout(() => resolve(1), millis))\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3953898,
                "title": "2621-sleep",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number} millis\\n */\\nasync function sleep(millis) {\\n    return new Promise(res => setTimeout(res, millis));\\n}\\n\\n/** \\n * let t = Date.now()\\n * sleep(100).then(() => console.log(Date.now() - t)) // 100\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} millis\\n */\\nasync function sleep(millis) {\\n    return new Promise(res => setTimeout(res, millis));\\n}\\n\\n/** \\n * let t = Date.now()\\n * sleep(100).then(() => console.log(Date.now() - t)) // 100\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3950586,
                "title": "one-line",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number} millis\\n */\\n// async function sleep(millis) {\\n//     return new Promise((resolve) => setTimeout(() => resolve(), millis));\\n// }\\n\\n// single line \\nconst sleep = async(millis) => await new Promise(resolve => setTimeout(resolve, millis));\\n\\n/** \\n * let t = Date.now()\\n * sleep(100).then(() => console.log(Date.now() - t)) // 100\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} millis\\n */\\n// async function sleep(millis) {\\n//     return new Promise((resolve) => setTimeout(() => resolve(), millis));\\n// }\\n\\n// single line \\nconst sleep = async(millis) => await new Promise(resolve => setTimeout(resolve, millis));\\n\\n/** \\n * let t = Date.now()\\n * sleep(100).then(() => console.log(Date.now() - t)) // 100\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3949484,
                "title": "one-line-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nasync function sleep(millis: number): Promise<void> {\\n    await new Promise(resolve => setTimeout(resolve, millis));\\n}\\n\\n\\n/** \\n * let t = Date.now()\\n * sleep(100).then(() => console.log(Date.now() - t)) // 100\\n */\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\nasync function sleep(millis: number): Promise<void> {\\n    await new Promise(resolve => setTimeout(resolve, millis));\\n}\\n\\n\\n/** \\n * let t = Date.now()\\n * sleep(100).then(() => console.log(Date.now() - t)) // 100\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3949237,
                "title": "easy-way-to-solve-promise-with-settimeout",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number} millis\\n */\\nasync function sleep(millis) {\\n     await new Promise(res => setTimeout(res, millis));\\n}\\n\\n/** \\n * let t = Date.now()\\n * sleep(100).then(() => console.log(Date.now() - t)) // 100\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} millis\\n */\\nasync function sleep(millis) {\\n     await new Promise(res => setTimeout(res, millis));\\n}\\n\\n/** \\n * let t = Date.now()\\n * sleep(100).then(() => console.log(Date.now() - t)) // 100\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3940713,
                "title": "solution-using-javascript",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(1)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    O(1)\\n# Code\\n```\\n/**\\n * @param {number} millis\\n */\\nasync function sleep(millis) {\\n    await new Promise(res => setTimeout(res,millis));\\n}\\n\\n/** \\n * let t = Date.now()\\n * sleep(100).then(() => console.log(Date.now() - t)) // 100\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} millis\\n */\\nasync function sleep(millis) {\\n    await new Promise(res => setTimeout(res,millis));\\n}\\n\\n/** \\n * let t = Date.now()\\n * sleep(100).then(() => console.log(Date.now() - t)) // 100\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3939347,
                "title": "javascript-simple-solution",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number} millis\\n */\\nasync function sleep(millis) {\\n    await new Promise(resolve => setTimeout(resolve, millis));\\n}\\n\\n/** \\n * let t = Date.now()\\n * sleep(100).then(() => console.log(Date.now() - t)) // 100\\n */\\n```\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} millis\\n */\\nasync function sleep(millis) {\\n    await new Promise(resolve => setTimeout(resolve, millis));\\n}\\n\\n/** \\n * let t = Date.now()\\n * sleep(100).then(() => console.log(Date.now() - t)) // 100\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3938679,
                "title": "my-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number} millis\\n */\\nasync function sleep(millis) {\\n    await new Promise((res)=>{\\n        setTimeout(res,millis)\\n    })\\n\\n    \\n    \\n}\\n\\n/** \\n * let t = Date.now()\\n * sleep(100).then(() => console.log(Date.now() - t)) // 100\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} millis\\n */\\nasync function sleep(millis) {\\n    await new Promise((res)=>{\\n        setTimeout(res,millis)\\n    })\\n\\n    \\n    \\n}\\n\\n/** \\n * let t = Date.now()\\n * sleep(100).then(() => console.log(Date.now() - t)) // 100\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3938400,
                "title": "wtf",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number} millis\\n */\\nasync function sleep(millis) {\\n    return new Promise((resolve) => setTimeout(resolve, millis))\\n}\\n\\n/** \\n * let t = Date.now()\\n * sleep(100).then(() => console.log(Date.now() - t)) // 100\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} millis\\n */\\nasync function sleep(millis) {\\n    return new Promise((resolve) => setTimeout(resolve, millis))\\n}\\n\\n/** \\n * let t = Date.now()\\n * sleep(100).then(() => console.log(Date.now() - t)) // 100\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3936814,
                "title": "one-line-promise-with-settimeout",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number} millis\\n */\\nasync function sleep(millis) {\\n   return await  new  Promise(resolve=>setTimeout(resolve,millis))\\n}\\n\\n/** \\n * let t = Date.now()\\n * sleep(100).then(() => console.log(Date.now() - t)) // 100\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} millis\\n */\\nasync function sleep(millis) {\\n   return await  new  Promise(resolve=>setTimeout(resolve,millis))\\n}\\n\\n/** \\n * let t = Date.now()\\n * sleep(100).then(() => console.log(Date.now() - t)) // 100\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3931455,
                "title": "result",
                "content": "# Code\\n```\\n/**\\n * @param {number} millis\\n */\\nasync function sleep(millis) {\\n    return new Promise(resolve => {\\n        setTimeout(() => resolve(), millis)\\n    })\\n}\\n\\n/** \\n * let t = Date.now()\\n * sleep(100).then(() => console.log(Date.now() - t)) // 100\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} millis\\n */\\nasync function sleep(millis) {\\n    return new Promise(resolve => {\\n        setTimeout(() => resolve(), millis)\\n    })\\n}\\n\\n/** \\n * let t = Date.now()\\n * sleep(100).then(() => console.log(Date.now() - t)) // 100\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3924577,
                "title": "beginner-solution-with-explanation",
                "content": "I am learning javascript with this leetcode study plan, so if you see anything to help please do so :) \\n\\n\\n# Explanation\\n* Promise() in javascript is used to handle asynchronous operations.\\n* setTimeout() in javascript sets a timer which executes a function or specified piece of code once the timer expires.\\nMeaning, we can call our promise with setTimeout() with given milliseconds.\\n\\n\\n# Code\\n```\\n/**\\n * @param {number} millis\\n */\\nasync function sleep(millis) {\\n    return new Promise(resolve => setTimeout(resolve, millis));\\n}\\n\\n/** \\n * let t = Date.now()\\n * sleep(100).then(() => console.log(Date.now() - t)) // 100\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} millis\\n */\\nasync function sleep(millis) {\\n    return new Promise(resolve => setTimeout(resolve, millis));\\n}\\n\\n/** \\n * let t = Date.now()\\n * sleep(100).then(() => console.log(Date.now() - t)) // 100\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3919279,
                "title": "sleep-timer",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number} millis\\n */\\nasync function sleep(millis) {\\n    return new Promise((resolve) => {\\n        setTimeout(() => {\\n            resolve(millis);\\n        }, millis)\\n    });\\n}\\n\\n/** \\n * let t = Date.now()\\n * sleep(100).then(() => console.log(Date.now() - t)) // 100\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} millis\\n */\\nasync function sleep(millis) {\\n    return new Promise((resolve) => {\\n        setTimeout(() => {\\n            resolve(millis);\\n        }, millis)\\n    });\\n}\\n\\n/** \\n * let t = Date.now()\\n * sleep(100).then(() => console.log(Date.now() - t)) // 100\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3899606,
                "title": "",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number} millis\\n */\\n\\n    \\n    async function sleep(millis) {\\n    await new Promise((resolve  =>  setTimeout(resolve, millis)\\n    ))\\n}\\n    \\n\\n    \\n    \\n\\n\\n/** \\n * let t = Date.now()\\n * sleep(100).then(() => console.log(Date.now() - t)) // 100\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} millis\\n */\\n\\n    \\n    async function sleep(millis) {\\n    await new Promise((resolve  =>  setTimeout(resolve, millis)\\n    ))\\n}\\n    \\n\\n    \\n    \\n\\n\\n/** \\n * let t = Date.now()\\n * sleep(100).then(() => console.log(Date.now() - t)) // 100\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3894625,
                "title": "understand-before-you-write-the-code",
                "content": "# Intuition\\nNot let the task intimidate me. Every porblem in programming has a logical solution that obey the rules of programming in the given programming language. Simply udnerstand the task and make a list of the tools you would need.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nStep 1 Understand the problem, before I write any code. By doing so I was able to use my imagination and think what I could possibly do to solve this.\\nStep 2. I was not familiar with async functions, hence I used chatGPT to quickly help me find the syntax of an async function and to understand deeply why this function exists and what are the benefits of using it.\\n\\nI quickly found out that the syntax is, where reject wouldn\\'t be necessary since in this example the chance for an error is virtually ZERO.\\n\\n**async function sleep(duration) {\\n    await new Promise((resolve, reject) => {\\n        setTimeout(resolve, duration);\\n        // If there was an error scenario, you\\'d call reject here.\\n        // But for setTimeout, there\\'s no anticipated error.\\n    });\\n}**\\n\\nI also quickly learned that Promise is not your typical Object, because resolve and reject should/could be seen as states even though they are methods of the object.\\n\\nOnce I learned about the syntax of the async function, it allowed me to quickly solve the solution since I spent 90% of my time talking with my \"tutor\" to understand this concept, once I did, I was able to use my logic and solve the problem.\\n\\n\\n# Complexity\\n- Time complexity:\\n1 hour of which 90% was spent researching and trying to understand the async function and the Promise object as deeply as  I could.\\n\\n\\n# Code\\n```\\n/**\\n * @param {number} millis\\n */\\nasync function sleep(millis) {\\n    await new Promise((resolve) => setTimeout(resolve, millis));\\n    \\n}\\n\\n\\n let t = Date.now()\\n sleep(100).then(() => console.log(Date.now() - t)) // 100\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} millis\\n */\\nasync function sleep(millis) {\\n    await new Promise((resolve) => setTimeout(resolve, millis));\\n    \\n}\\n\\n\\n let t = Date.now()\\n sleep(100).then(() => console.log(Date.now() - t)) // 100\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3891420,
                "title": "best-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number} millis\\n */\\nasync function sleep(millis) {\\n    await new Promise((resolve )=>{\\n        setTimeout(resolve,millis)\\n    })\\n}\\n\\n/** \\n * let t = Date.now()\\n * sleep(100).then(() => console.log(Date.now() - t)) // 100\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} millis\\n */\\nasync function sleep(millis) {\\n    await new Promise((resolve )=>{\\n        setTimeout(resolve,millis)\\n    })\\n}\\n\\n/** \\n * let t = Date.now()\\n * sleep(100).then(() => console.log(Date.now() - t)) // 100\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3888125,
                "title": "millis",
                "content": "# Code\\n```\\n/**\\n * @param {number} millis\\n */\\n\\nconst wait = async (milli) => {\\n    await new Promise((resolve) => setTimeout(resolve, milli) );\\n};\\n\\nasync function sleep(millis) {\\n    await wait(millis);\\n}\\n\\n/** \\n * let t = Date.now()\\n * sleep(100).then(() => console.log(Date.now() - t)) // 100\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} millis\\n */\\n\\nconst wait = async (milli) => {\\n    await new Promise((resolve) => setTimeout(resolve, milli) );\\n};\\n\\nasync function sleep(millis) {\\n    await wait(millis);\\n}\\n\\n/** \\n * let t = Date.now()\\n * sleep(100).then(() => console.log(Date.now() - t)) // 100\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3886105,
                "title": "simple-solution-with-an-explanation",
                "content": "# The explanation for this code is as follows:\\n\\nThe async keyword indicates that the function returns a promise. This allows us to use the await keyword inside the function to wait for another promise to resolve.\\nThe Promise constructor takes an executor function that receives two arguments: resolve and reject. The executor function is executed immediately when the promise is created.\\nThe setTimeout function takes a callback function and a delay in milliseconds as arguments and executes the callback function after the delay. In this case, the callback function is the resolve function, which resolves the promise with no value.\\nThe sleep function returns the promise that resolves after the given delay. This means that we can use the then method or the await keyword to wait for the promise to resolve before executing other code.\\n\\n\\n# Code\\n```\\n/**\\n * @param {number} millis\\n */\\nasync function sleep(millis) {\\n  // Return a new promise that resolves after the given delay\\n  return new Promise((resolve, reject) => {\\n    // Use setTimeout to execute the resolve function after the delay\\n    setTimeout(resolve, millis);\\n  });\\n}\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} millis\\n */\\nasync function sleep(millis) {\\n  // Return a new promise that resolves after the given delay\\n  return new Promise((resolve, reject) => {\\n    // Use setTimeout to execute the resolve function after the delay\\n    setTimeout(resolve, millis);\\n  });\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3885646,
                "title": "easy-solution-that-beats-98-of-the-solutions-august-2023",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nTo create an asynchronous function that sleeps for a given number of milliseconds, you can use the setTimeout function along with the Promise object.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nMy approach would be to create the sleep function which takes a positive integer millis as its argument. Inside the function, we create a Promise that will be resolved after the specified number of milliseconds using the setTimeout function.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number} millis\\n */\\nasync function sleep(millis) {\\n    return new Promise(resolve => setTimeout(resolve, millis))\\n}\\n\\n/** \\n * let t = Date.now()\\n * sleep(100).then(() => console.log(Date.now() - t)) // 100\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} millis\\n */\\nasync function sleep(millis) {\\n    return new Promise(resolve => setTimeout(resolve, millis))\\n}\\n\\n/** \\n * let t = Date.now()\\n * sleep(100).then(() => console.log(Date.now() - t)) // 100\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3885495,
                "title": "sleep-function-in-javascript",
                "content": "# Intuition\\nIn JavaScript, the language itself doesn\\'t provide a built-in sleep function like some other programming languages. However, you can achieve a similar effect using setTimeout or async/await in combination with Promise.\\n\\nHere\\'s how you can create a sleep function using setTimeout:\\n\\n# Code\\n```\\n/**\\n * @param {number} millis\\n */\\n//let t = Date.now()\\nasync function sleep(millis) {\\n   return new Promise(resolve=>setTimeout(resolve,millis))\\n}\\n\\n/** \\n * let t = Date.now()\\n * sleep(100).then(() => console.log(Date.now() - t)) // 100\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} millis\\n */\\n//let t = Date.now()\\nasync function sleep(millis) {\\n   return new Promise(resolve=>setTimeout(resolve,millis))\\n}\\n\\n/** \\n * let t = Date.now()\\n * sleep(100).then(() => console.log(Date.now() - t)) // 100\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3883019,
                "title": "two-easy-and-short-solutions-javascript-beat-over-90-return-instead-of-await",
                "content": "# Intuition\\nSleep only when the target time is approached instead of constantly waiting for the target time to decrease the memory.\\n\\n# Approach\\nReturn new Promise only when the setTimeout resolve approaches the target time.\\n\\n# Complexity\\nTime complexity:\\nRuntime 55 ms Beats 73.10%\\n\\nSpace complexity:\\nMemory 41.2 mb Beats 91.25%\\n\\n# Code\\n```\\n/**\\n * @param {number} millis\\n */\\nasync function sleep(millis) {\\n     return new Promise(res => setTimeout(res, millis));\\n}\\n\\n/** \\n * let t = Date.now()\\n * sleep(100).then(() => console.log(Date.now() - t)) // 100\\n */\\n```\\n\\n# Approach\\nIncrease time. Create a constant, p, and return p when the new Promise setTimeout resolve approaches the target time to reduce the runtime.\\n\\n# Complexity\\nTime complexity:\\nRuntime 44 ms Beats 97.71%\\n\\nSpace complexity:\\nMemory 41.4 mb Beats 85.77%\\n\\n# Code\\n```\\n/**\\n * @param {number} millis\\n */\\nasync function sleep(millis) {\\n    const p = new Promise(res => setTimeout(res, millis));\\n    return p; }\\n\\n/** \\n * let t = Date.now()\\n * sleep(100).then(() => console.log(Date.now() - t)) // 100\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} millis\\n */\\nasync function sleep(millis) {\\n     return new Promise(res => setTimeout(res, millis));\\n}\\n\\n/** \\n * let t = Date.now()\\n * sleep(100).then(() => console.log(Date.now() - t)) // 100\\n */\\n```\n```\\n/**\\n * @param {number} millis\\n */\\nasync function sleep(millis) {\\n    const p = new Promise(res => setTimeout(res, millis));\\n    return p; }\\n\\n/** \\n * let t = Date.now()\\n * sleep(100).then(() => console.log(Date.now() - t)) // 100\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3882317,
                "title": "one-liner-solution-detailed-explanation-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe sleep() function works by first creating a new promise object. The new promise object is then attached to a callback that will be called after the specified number of milliseconds have elapsed. The callback then calls the resolve() method on the promise, which indicates that the sleep function has completed.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe sleep() function is made async by using the async keyword. This keyword tells the JavaScript interpreter that the function will return a promise. The await keyword is then used to pause the execution of the code until the promise has resolved.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nThe time complexity of the solution is O(1). This is because the solution only needs to call the setTimeout() function once.\\n\\n\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nThe space complexity of the solution is O(1). This is because the solution only needs to create a new promise object.\\n\\n\\n# Code\\n```\\n/**\\n * @param {number} millis\\n */\\nasync function sleep(millis) {\\n    return new Promise(resolve => {\\n    setTimeout(resolve, millis);\\n  });\\n}\\n\\n/** \\n * let t = Date.now()\\n * sleep(100).then(() => console.log(Date.now() - t)) // 100\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} millis\\n */\\nasync function sleep(millis) {\\n    return new Promise(resolve => {\\n    setTimeout(resolve, millis);\\n  });\\n}\\n\\n/** \\n * let t = Date.now()\\n * sleep(100).then(() => console.log(Date.now() - t)) // 100\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3879459,
                "title": "explanation-why-doesn-t-it-work-if-we-only-use-settimeout",
                "content": "# Intuition\\nThe first thought that jumped into my(our) mind was use a simple setTimeout. However, it doesn\\'t work. \\n```\\nasync function sleep(millis) {\\n    setTimeout(()=>(), millis);\\n}\\n```\\n\\nThe reason why it doesn\\'t work is that JS is a non-blocking language(If you don\\'t know what non-blocking is, don\\'t worry, this question is not for you for the time being. You can revisit it after learning AJAX of JS). SetTimeout will be executed in asynchronously, and the program will jump to the next line (return ...) immediately instead of waiting for setTimeout being executed.\\n\\nAfter understanding why simply using setTimeout doesn\\'t work, we now know that we need a way to \"block\" our program from bypassing setTimeout and jumping to next line. There is only one way to do it (at least for beginner), which is Promise and await. await allows us to consume a Promise in a seemingly synchronous way (executing code line by line). Namely:\\n\\n# Correct Answer\\n```\\n/**\\n * @param {number} millis\\n */\\nasync function sleep1(millis) {\\n    await new Promise((resolve, reject) => setTimeout(resolve, millis));\\n}\\n```\\n\\nPS1: The reason why we new a Promise is not because we need to return a Promise. async keyword ensures that our function will return a Promise. In this case, it will return a Promise whose \"value\" is undefined because we don\\'t specify a return value. The return value of our function has NOTHING to do with the resolve value of the Promise we created within our function unless your code is \\n```\\nasync function sleep2(millis) {\\n    return new Promise((resolve, reject) => setTimeout(resolve, millis));\\n\\n    /** it is equivalent to \\n    *   const res = new Promise((resolve, reject) => setTimeout (resolve, millis))\\n    *   return res;\\n    */  \\n}\\n```\\nBoth code snippets above happen to return the same value undefined. It is 100% coincidence. They will return different things if you modify codes.\\n```\\n// always return a Promise whose value is undefined\\nasync function sleep1(millis) {\\n    await new Promise((resolve, reject) => setTimeout(()=> resolve(999), millis));\\n}\\n\\n\\n// return a Promise whose value is 999(or whatever you put in the argument of resolve())\\nasync function sleep2(millis) {\\n    return new Promise((resolve, reject) => setTimeout(()=> resolve(999), millis));\\n}\\n```\\n\\nPS2: Someone might ask why I can\\'t write code like this\\n```\\nasync function sleep2(millis) {\\n    await new Promise((resolve, _) => setTimeout(resolve(999), millis));\\n}\\n```\\nWe need a callback function in the first argument of setTimeout. If you put resolve(999) instead of ()=>(resolve(999)) there, the former will be evaluated immediately and resolve our Promise, and our program will go to the next line. Technically, resolve(999) is just a value rather than a callback function. However, functions are also first-class citizens in JS. In interpreter\\'s eyes, a value has no difference than a function. That\\'s why you don\\'t receivce any error but couldn\\'t pass the test case.\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nasync function sleep(millis) {\\n    setTimeout(()=>(), millis);\\n}\\n```\n```\\n/**\\n * @param {number} millis\\n */\\nasync function sleep1(millis) {\\n    await new Promise((resolve, reject) => setTimeout(resolve, millis));\\n}\\n```\n```\\nasync function sleep2(millis) {\\n    return new Promise((resolve, reject) => setTimeout(resolve, millis));\\n\\n    /** it is equivalent to \\n    *   const res = new Promise((resolve, reject) => setTimeout (resolve, millis))\\n    *   return res;\\n    */  \\n}\\n```\n```\\n// always return a Promise whose value is undefined\\nasync function sleep1(millis) {\\n    await new Promise((resolve, reject) => setTimeout(()=> resolve(999), millis));\\n}\\n\\n\\n// return a Promise whose value is 999(or whatever you put in the argument of resolve())\\nasync function sleep2(millis) {\\n    return new Promise((resolve, reject) => setTimeout(()=> resolve(999), millis));\\n}\\n```\n```\\nasync function sleep2(millis) {\\n    await new Promise((resolve, _) => setTimeout(resolve(999), millis));\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3873672,
                "title": "beats-99-96-of-users-with-javascript",
                "content": "# Code\\n```\\n/**\\n * @param {number} millis\\n */\\nfunction sleep(millis) \\n{\\n    return new Promise((res,rej)=>{setTimeout(res, millis)})\\n}\\n\\n/** \\n * let t = Date.now()\\n * sleep(100).then(() => console.log(Date.now() - t)) // 100\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} millis\\n */\\nfunction sleep(millis) \\n{\\n    return new Promise((res,rej)=>{setTimeout(res, millis)})\\n}\\n\\n/** \\n * let t = Date.now()\\n * sleep(100).then(() => console.log(Date.now() - t)) // 100\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3869362,
                "title": "1-line-beat-98-57-simple-solution-with-minimum-code",
                "content": "# Intuition\\nThese approach emphasizes achieving **performance with minimal code**.\\n\\n# Code\\n```\\n/**\\n * @param {number} millis\\n */\\nasync function sleep(millis) {\\n    await new Promise(resolve => setTimeout(() => resolve(), millis));\\n}\\n\\n/** \\n * let t = Date.now()\\n * sleep(100).then(() => console.log(Date.now() - t)) // 100\\n */\\n```\\n\\nPlease **Upvote** if you find helpful.",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} millis\\n */\\nasync function sleep(millis) {\\n    await new Promise(resolve => setTimeout(() => resolve(), millis));\\n}\\n\\n/** \\n * let t = Date.now()\\n * sleep(100).then(() => console.log(Date.now() - t)) // 100\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3867917,
                "title": "sleep",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number} millis\\n */\\nfunction wait(ms) {\\n  return new Promise(function (resolve) {\\n    setTimeout(resolve, ms);\\n  });\\n}\\nasync function sleep(millis) {\\n  if (millis >= 1 && millis <= 1000) {\\n    await wait(millis);\\n  }\\n}\\n\\n/** \\n * let t = Date.now()\\n * sleep(100).then(() => console.log(Date.now() - t)) // 100\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} millis\\n */\\nfunction wait(ms) {\\n  return new Promise(function (resolve) {\\n    setTimeout(resolve, ms);\\n  });\\n}\\nasync function sleep(millis) {\\n  if (millis >= 1 && millis <= 1000) {\\n    await wait(millis);\\n  }\\n}\\n\\n/** \\n * let t = Date.now()\\n * sleep(100).then(() => console.log(Date.now() - t)) // 100\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3863473,
                "title": "idk",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number} millis\\n */\\n function sleep (time) {\\n  return new Promise((resolve) => setTimeout(resolve, time));\\n\\nasync function sleep(millis) {\\n    sleeptime(100)\\n    var x = 9\\n    var y = 10\\n    var s = x + y\\n    console.log(s)\\n}\\n}\\n\\n/** \\n * let t = Date.now()\\n * sleep(100).then(() => console.log(Date.now() - t)) // 100\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} millis\\n */\\n function sleep (time) {\\n  return new Promise((resolve) => setTimeout(resolve, time));\\n\\nasync function sleep(millis) {\\n    sleeptime(100)\\n    var x = 9\\n    var y = 10\\n    var s = x + y\\n    console.log(s)\\n}\\n}\\n\\n/** \\n * let t = Date.now()\\n * sleep(100).then(() => console.log(Date.now() - t)) // 100\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3850244,
                "title": "a-nice-solution-for-resolving-promise",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number} millis\\n */\\nasync function sleep(millis) {\\n    return new Promise((resolve, reject) => {\\n        setTimeout(() => {\\n            resolve();\\n        }, millis);\\n    });\\n}\\n\\n/** \\n * let t = Date.now()\\n * sleep(100).then(() => console.log(Date.now() - t)) // 100\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} millis\\n */\\nasync function sleep(millis) {\\n    return new Promise((resolve, reject) => {\\n        setTimeout(() => {\\n            resolve();\\n        }, millis);\\n    });\\n}\\n\\n/** \\n * let t = Date.now()\\n * sleep(100).then(() => console.log(Date.now() - t)) // 100\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3835483,
                "title": "solution-for-sleep-problem-easy-solution-javascript-beats-92-10-of-users-with-javascript",
                "content": "\\n****Given a positive integer millis, write an asynchronous function that sleeps for millis milliseconds. It can resolve any value.****\\n\\n\\n\\n# Code\\n```\\n/**\\n * @param {number} millis\\n */\\nasync function sleep(millis) {\\n      await new Promise(res => setTimeout(res, millis));\\n}\\n\\n/** \\n * let t = Date.now()\\n * sleep(100).then(() => console.log(Date.now() - t)) // 100\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} millis\\n */\\nasync function sleep(millis) {\\n      await new Promise(res => setTimeout(res, millis));\\n}\\n\\n/** \\n * let t = Date.now()\\n * sleep(100).then(() => console.log(Date.now() - t)) // 100\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3833274,
                "title": "sleep-function",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number} millis\\n */\\nasync function sleep(millis) {\\n    const myPromise = new Promise((resolve, reject) => {\\n        setTimeout(() => {\\n            resolve(millis)\\n        },millis)\\n    })\\n    return myPromise    \\n};\\n\\n/** \\n * let t = Date.now()\\n * sleep(100).then(() => console.log(Date.now() - t)) // 100\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} millis\\n */\\nasync function sleep(millis) {\\n    const myPromise = new Promise((resolve, reject) => {\\n        setTimeout(() => {\\n            resolve(millis)\\n        },millis)\\n    })\\n    return myPromise    \\n};\\n\\n/** \\n * let t = Date.now()\\n * sleep(100).then(() => console.log(Date.now() - t)) // 100\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3824158,
                "title": "typescript-solution",
                "content": "```\\nasync function sleep(millis: number): Promise<void> {\\n    await new Promise((resolve, reject) => {\\n        setTimeout(resolve, millis)\\n    })\\n}",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\nasync function sleep(millis: number): Promise<void> {\\n    await new Promise((resolve, reject) => {\\n        setTimeout(resolve, millis)\\n    })\\n}",
                "codeTag": "Unknown"
            },
            {
                "id": 3823994,
                "title": "simplest-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(1)\\n\\n- Space complexity: $$O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number} millis\\n */\\nasync function sleep(millis) {\\n    return new Promise(resolve => setTimeout(resolve, millis));\\n}\\n\\n/** \\n * let t = Date.now()\\n * sleep(100).then(() => console.log(Date.now() - t)) // 100\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} millis\\n */\\nasync function sleep(millis) {\\n    return new Promise(resolve => setTimeout(resolve, millis));\\n}\\n\\n/** \\n * let t = Date.now()\\n * sleep(100).then(() => console.log(Date.now() - t)) // 100\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3823342,
                "title": "easy-javascript-solution",
                "content": "# Intuition\\nWe do not need to do any error checking because we know that `millis` will always be a positive integer.\\n\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$ - n is the duration (`millis`) passed to the sleep function\\n\\n- Space complexity:\\n$$O(?)$$ - I\\'m not sure\\n\\n# Code\\n```\\n/**\\n * @param {number} millis\\n */\\nasync function sleep(millis){\\n  return new Promise((resolve) => setTimeout(resolve, millis));\\n}\\n\\n/** \\n * let t = Date.now()\\n * sleep(100).then(() => console.log(Date.now() - t)) // 100\\n */\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} millis\\n */\\nasync function sleep(millis){\\n  return new Promise((resolve) => setTimeout(resolve, millis));\\n}\\n\\n/** \\n * let t = Date.now()\\n * sleep(100).then(() => console.log(Date.now() - t)) // 100\\n */\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3821071,
                "title": "one-line-solution-faster-than-81-of-submissions",
                "content": "# Introduction\\n\\nLeetCode gives us an **async** function, and asks us to resolve a **promise** after a given amount of time. Let\\'s define both of these terms before we move forward with a solution.\\n\\n# Async\\n\\n*\"The await keyword is permitted within the function body, enabling asynchronous, promise-based behavior to be written in a cleaner style and avoiding the need to explicitly configure promise chains.\" - [MDN Web Docs (1.)](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/async_function)*\\n\\nThis means that the async keyword enables a function to use asynchronous features built into JavaScript, without the clunky, outdated promise chains.\\n\\n# Promise\\n\\n*\"The Promise object represents the eventual completion (or failure) of an asynchronous operation and its resulting value.\" [MDN Web Docs (2.)](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise)*\\n\\nPromise objects allow us to start an asynchronous task, and automatically execute code when it fulfills or rejects.\\n\\n![promises.png](https://assets.leetcode.com/users/images/3d0b5fd4-5d96-4c68-ae34-9e4b7372dcc7_1690403909.2997563.png)\\n\\n# Solution\\n\\nFor a simple problem, like asynchronously waiting a given amount of time, the async keyword is not necessary. Instead we can return a promise that will will resolve after waiting for the number of milliseconds specified.\\n\\n\\n# Code\\n```\\n\\nfunction sleep(millis) {\\n    return new Promise(resolve => setTimeout(resolve, millis))\\n}\\n\\n```\\n\\n# Sources\\n[1. MDN Web Docs - Async Function](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/async_function)\\n[2. MDN Web Docs - Promise](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise)",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n\\nfunction sleep(millis) {\\n    return new Promise(resolve => setTimeout(resolve, millis))\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3813237,
                "title": "simple-promise-sleep-implementation",
                "content": "\\n# Code\\n```\\n/**\\n * @param {number} millis\\n */\\nasync function sleep(millis) {\\n    return new Promise((resolve)=>{\\n        setTimeout(resolve,millis)\\n    })\\n}\\n\\n/** \\n * let t = Date.now()\\n * sleep(100).then(() => console.log(Date.now() - t)) // 100\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} millis\\n */\\nasync function sleep(millis) {\\n    return new Promise((resolve)=>{\\n        setTimeout(resolve,millis)\\n    })\\n}\\n\\n/** \\n * let t = Date.now()\\n * sleep(100).then(() => console.log(Date.now() - t)) // 100\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3812073,
                "title": "beginner-friendly",
                "content": "\\n\\n# Code\\n```\\nconst sleep = async (millis) => {\\n  return new Promise((resolve, reject) => {\\n    setTimeout(() => {\\n      resolve()\\n    }, millis)\\n  })\\n}\\n\\nlet t = Date.now();\\n\\n\\nsleep(100).then(() => {\\n  console.log(Date.now() - t) \\n});\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nconst sleep = async (millis) => {\\n  return new Promise((resolve, reject) => {\\n    setTimeout(() => {\\n      resolve()\\n    }, millis)\\n  })\\n}\\n\\nlet t = Date.now();\\n\\n\\nsleep(100).then(() => {\\n  console.log(Date.now() - t) \\n});\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3810170,
                "title": "sleep-aync-await-sleep",
                "content": "\\n# Code\\n```\\n/**\\n * @param {number} millis\\n */\\nasync function sleep(millis) {\\n\\n//1.\\uBE44\\uB3D9\\uAE30\\uB85C \\uC791\\uC131\\uD558\\uB77C.\\n//2. setTimeOut \\uC744\\uC774\\uC6A9\\uD558\\uC5EC millis \\uC774\\uD6C4\\uC5D0 \\uC2E4\\uD589\\uB418\\uB3C4\\uB85D\\n await new Promise(res =>setTimeout(res,millis))\\n  \\n    \\n}\\n\\n/** \\n * let t = Date.now()\\n * sleep(100).then(() => console.log(Date.now() - t)) // 100\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} millis\\n */\\nasync function sleep(millis) {\\n\\n//1.\\uBE44\\uB3D9\\uAE30\\uB85C \\uC791\\uC131\\uD558\\uB77C.\\n//2. setTimeOut \\uC744\\uC774\\uC6A9\\uD558\\uC5EC millis \\uC774\\uD6C4\\uC5D0 \\uC2E4\\uD589\\uB418\\uB3C4\\uB85D\\n await new Promise(res =>setTimeout(res,millis))\\n  \\n    \\n}\\n\\n/** \\n * let t = Date.now()\\n * sleep(100).then(() => console.log(Date.now() - t)) // 100\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3802219,
                "title": "sleep",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number} millis\\n */\\nasync function sleep(millis) {\\n    return new Promise((resolve) => {\\n    setTimeout(resolve, millis);\\n  });\\n}\\n\\n/** \\n * let t = Date.now()\\n * sleep(100).then(() => console.log(Date.now() - t)) // 100\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} millis\\n */\\nasync function sleep(millis) {\\n    return new Promise((resolve) => {\\n    setTimeout(resolve, millis);\\n  });\\n}\\n\\n/** \\n * let t = Date.now()\\n * sleep(100).then(() => console.log(Date.now() - t)) // 100\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3797450,
                "title": "sleep-settimeout-simple-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nJust return promise as needed and resolve after time using setTimeout api.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number} millis\\n */\\nasync function sleep(millis) {\\n    return new Promise((resolve,reject)=>{\\n        setTimeout(function(){\\n            resolve()\\n        },millis)\\n    })\\n}\\n\\n/** \\n * let t = Date.now()\\n * sleep(100).then(() => console.log(Date.now() - t)) // 100\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} millis\\n */\\nasync function sleep(millis) {\\n    return new Promise((resolve,reject)=>{\\n        setTimeout(function(){\\n            resolve()\\n        },millis)\\n    })\\n}\\n\\n/** \\n * let t = Date.now()\\n * sleep(100).then(() => console.log(Date.now() - t)) // 100\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3785331,
                "title": "one-line-solution-in-javascript",
                "content": "# Intuition\\nAn asynchronous function that sleeps for milliseconds given.\\n\\n# Approach\\nSimply return Promise and use resolve attribute of Promise in order to make function sleep for miliseconds\\n\\n# Code\\n```\\n/**\\n * @param {number} millis\\n */\\nasync function sleep(millis) {\\n    return new Promise(resolve=> setTimeout(resolve,millis))\\n}\\n\\n/** \\n * let t = Date.now()\\n * sleep(100).then(() => console.log(Date.now() - t)) // 100\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} millis\\n */\\nasync function sleep(millis) {\\n    return new Promise(resolve=> setTimeout(resolve,millis))\\n}\\n\\n/** \\n * let t = Date.now()\\n * sleep(100).then(() => console.log(Date.now() - t)) // 100\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3784551,
                "title": "2621-sleep",
                "content": "```\\n/**\\n * @param {number} millis\\n */\\nasync function sleep(millis) {\\n    return new Promise((resolve) => setTimeout(resolve, millis));\\n}\\n\\n/** \\n * let t = Date.now()\\n * sleep(100).then(() => console.log(Date.now() - t)) // 100\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} millis\\n */\\nasync function sleep(millis) {\\n    return new Promise((resolve) => setTimeout(resolve, millis));\\n}\\n\\n/** \\n * let t = Date.now()\\n * sleep(100).then(() => console.log(Date.now() - t)) // 100\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3775170,
                "title": "2621-sleep",
                "content": "# Code\\n```\\n/**\\n * @param {number} millis\\n */\\n\\nconst sleep = async (millis) =>{\\n   return new Promise((resolve) => {\\n        setTimeout(() => {\\n            resolve();\\n        }, millis);\\n    });\\n}\\n\\n/** \\n * let t = Date.now()\\n * sleep(100).then(() => console.log(Date.now() - t)) // 100\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} millis\\n */\\n\\nconst sleep = async (millis) =>{\\n   return new Promise((resolve) => {\\n        setTimeout(() => {\\n            resolve();\\n        }, millis);\\n    });\\n}\\n\\n/** \\n * let t = Date.now()\\n * sleep(100).then(() => console.log(Date.now() - t)) // 100\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3772396,
                "title": "js-soloution",
                "content": "# Code\\n```\\n/**\\n * @param {number} millis\\n */\\nasync function sleep(millis) {\\n  \\n  const promise = new Promise((res,rej)=>{\\n   setTimeout(()=>{\\n    res(\"done\")\\n   },millis)\\n  })\\n\\n  await promise;\\n\\n} \\n let t = Date.now();\\n sleep(100).then(() => console.log(Date.now() - t)) \\n\\n\\n/** \\n * let t = Date.now()\\n * sleep(100).then(() => console.log(Date.now() - t)) // 100\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} millis\\n */\\nasync function sleep(millis) {\\n  \\n  const promise = new Promise((res,rej)=>{\\n   setTimeout(()=>{\\n    res(\"done\")\\n   },millis)\\n  })\\n\\n  await promise;\\n\\n} \\n let t = Date.now();\\n sleep(100).then(() => console.log(Date.now() - t)) \\n\\n\\n/** \\n * let t = Date.now()\\n * sleep(100).then(() => console.log(Date.now() - t)) // 100\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3765765,
                "title": "await-promise",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSince it uses the `.then` handler, I thought of using an async function.\\nAnd I also thought of using `setTimeout`, since that is what I would normally use.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nSince the program ***waits*** for the `sleep` function to be done, I thought of using ***`await`***. \\nThen I thought of using a `promise`. \\nSince my first intuition was to use `setTimeout`, I used `setTimeout` in the `promise`.\\nThe last thing I did was use `await` to wait for the promise to finish.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number} millis\\n */\\nasync function sleep(millis) {\\n    let myPromise = new Promise(function(resolve, reject) {\\n        \\n        setTimeout(function() { resolve(\\'Hello?\\'); }, millis);  \\n    });  \\n    let val = await myPromise;\\n}\\n\\n/** \\n * let t = Date.now()\\n * sleep(100).then(() => console.log(Date.now() - t)) // 100\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} millis\\n */\\nasync function sleep(millis) {\\n    let myPromise = new Promise(function(resolve, reject) {\\n        \\n        setTimeout(function() { resolve(\\'Hello?\\'); }, millis);  \\n    });  \\n    let val = await myPromise;\\n}\\n\\n/** \\n * let t = Date.now()\\n * sleep(100).then(() => console.log(Date.now() - t)) // 100\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3765591,
                "title": "2621-sleep",
                "content": "# Code\\n```\\n/**\\n * @param {number} millis\\n */\\nasync function sleep(millis) {\\n    await new Promise(resolve => setTimeout(resolve, millis));\\n}\\n\\n/** \\n * let t = Date.now()\\n * sleep(100).then(() => console.log(Date.now() - t)) // 100\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} millis\\n */\\nasync function sleep(millis) {\\n    await new Promise(resolve => setTimeout(resolve, millis));\\n}\\n\\n/** \\n * let t = Date.now()\\n * sleep(100).then(() => console.log(Date.now() - t)) // 100\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3761361,
                "title": "typescript-following-the-hints",
                "content": "# Code\\n```\\nasync function sleep(millis: number): Promise<void> {\\n    return new Promise<void>((resolve, reject)=>{\\n        setTimeout(resolve, millis);\\n    })\\n}\\n\\n\\n/** \\n * let t = Date.now()\\n * sleep(100).then(() => console.log(Date.now() - t)) // 100\\n */\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\nasync function sleep(millis: number): Promise<void> {\\n    return new Promise<void>((resolve, reject)=>{\\n        setTimeout(resolve, millis);\\n    })\\n}\\n\\n\\n/** \\n * let t = Date.now()\\n * sleep(100).then(() => console.log(Date.now() - t)) // 100\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3749335,
                "title": "simple-solution-try-and-catch",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number} millis\\n */\\nasync function sleep(millis) {\\n    return new Promise((resolve, reject) =>{\\n      try {\\n        setTimeout(() => {\\n          resolve()\\n        }, millis);\\n      } catch (error) {\\n        reject(error)\\n      }\\n    })\\n}\\n\\n/** \\n * let t = Date.now()\\n * sleep(100).then(() => console.log(Date.now() - t)) // 100\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} millis\\n */\\nasync function sleep(millis) {\\n    return new Promise((resolve, reject) =>{\\n      try {\\n        setTimeout(() => {\\n          resolve()\\n        }, millis);\\n      } catch (error) {\\n        reject(error)\\n      }\\n    })\\n}\\n\\n/** \\n * let t = Date.now()\\n * sleep(100).then(() => console.log(Date.now() - t)) // 100\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3749313,
                "title": "2621-sleep-umarbek-s-solution",
                "content": "# Code\\n```\\n/**\\n * @param {number} millis\\n */\\nasync function sleep(millis) {\\n        return new Promise(resolve => setTimeout(resolve, millis));\\n}\\n\\n/** \\n * let t = Date.now()\\n * sleep(100).then(() => console.log(Date.now() - t)) // 100\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} millis\\n */\\nasync function sleep(millis) {\\n        return new Promise(resolve => setTimeout(resolve, millis));\\n}\\n\\n/** \\n * let t = Date.now()\\n * sleep(100).then(() => console.log(Date.now() - t)) // 100\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3745793,
                "title": "precise-and-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number} millis\\n */\\nasync function sleep(millis) {\\n    await new Promise((resolve) => {\\n        setTimeout(() => {\\n            resolve();\\n        },\\n        millis)\\n    })\\n}\\n\\n/** \\n * let t = Date.now()\\n * sleep(100).then(() => console.log(Date.now() - t)) // 100\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} millis\\n */\\nasync function sleep(millis) {\\n    await new Promise((resolve) => {\\n        setTimeout(() => {\\n            resolve();\\n        },\\n        millis)\\n    })\\n}\\n\\n/** \\n * let t = Date.now()\\n * sleep(100).then(() => console.log(Date.now() - t)) // 100\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3745007,
                "title": "easy-solution",
                "content": "\\n\\n# Code\\n```\\n/**\\n * @param {number} millis\\n */\\nasync function sleep(millis) {\\n    const time = await new Promise((resolve, reject) => {\\n        setTimeout(resolve, millis)\\n    })\\n    return time;\\n}\\n\\n/** \\n * let t = Date.now()\\n * sleep(100).then(() => console.log(Date.now() - t)) // 100\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} millis\\n */\\nasync function sleep(millis) {\\n    const time = await new Promise((resolve, reject) => {\\n        setTimeout(resolve, millis)\\n    })\\n    return time;\\n}\\n\\n/** \\n * let t = Date.now()\\n * sleep(100).then(() => console.log(Date.now() - t)) // 100\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3743048,
                "title": "easiest-javascript-solution-using-settimeout",
                "content": "\\n# Code\\n```\\n/**\\n * @param {number} millis\\n */\\nasync function sleep(millis) {\\n    return new Promise((resolve)=>{\\n        setTimeout(()=>{\\n            resolve(10);\\n        },millis)\\n    })\\n}\\n\\n/** \\n * let t = Date.now()\\n * sleep(100).then(() => console.log(Date.now() - t)) // 100\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} millis\\n */\\nasync function sleep(millis) {\\n    return new Promise((resolve)=>{\\n        setTimeout(()=>{\\n            resolve(10);\\n        },millis)\\n    })\\n}\\n\\n/** \\n * let t = Date.now()\\n * sleep(100).then(() => console.log(Date.now() - t)) // 100\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3738426,
                "title": "js-solution",
                "content": "```\\nlet sleep = async (ms) => new Promise(res => setTimeout(res, ms));\\n```",
                "solutionTags": [],
                "code": "```\\nlet sleep = async (ms) => new Promise(res => setTimeout(res, ms));\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3725927,
                "title": "sleep",
                "content": "**Solution**\\nThe sleep function takes a parameter millis representing the number of milliseconds to sleep. It returns a new Promise that resolves after the specified number of milliseconds.\\n\\n# Code\\n```\\n/**\\n * @param {number} millis\\n */\\nasync function sleep(millis) {\\n    return new Promise(resolve =>{\\n        setTimeout(()=>{\\n            resolve(millis)\\n        }, millis)\\n    })\\n}\\n\\n/** \\n * let t = Date.now()\\n * sleep(100).then(() => console.log(Date.now() - t)) // 100\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} millis\\n */\\nasync function sleep(millis) {\\n    return new Promise(resolve =>{\\n        setTimeout(()=>{\\n            resolve(millis)\\n        }, millis)\\n    })\\n}\\n\\n/** \\n * let t = Date.now()\\n * sleep(100).then(() => console.log(Date.now() - t)) // 100\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3721733,
                "title": "easiest-way-to-solve-it",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number} millis\\n */\\nasync function sleep(millis) {\\n  await new Promise(resolve => setTimeout(resolve, millis));\\n  \\n    \\n}\\n\\n/** \\n * let t = Date.now()\\n * sleep(100).then(() => console.log(Date.now() - t)) // 100\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} millis\\n */\\nasync function sleep(millis) {\\n  await new Promise(resolve => setTimeout(resolve, millis));\\n  \\n    \\n}\\n\\n/** \\n * let t = Date.now()\\n * sleep(100).then(() => console.log(Date.now() - t)) // 100\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3721509,
                "title": "javascript-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe sleep function takes a positive integer millis as input and returns a promise that resolves after millis milliseconds. It utilizes the setTimeout function to delay the resolution of the promise.\\n\\nIn this example, the sleep(100) call waits for 100 milliseconds and then resolves the promise. The then method is called when the promise is resolved, and it logs the elapsed time since t was set to the console.\\n\\nSimilarly, you can use the sleep function with different millisecond values to achieve the desired delays.\\n\\n# Complexity\\n- Time complexity: O(1)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nfunction sleep(millis) {\\n  return new Promise(resolve => setTimeout(resolve, millis));\\n}\\nlet t = Date.now();\\nsleep(100).then(() => {\\n  console.log(Date.now() - t); // Output: 100\\n});\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nfunction sleep(millis) {\\n  return new Promise(resolve => setTimeout(resolve, millis));\\n}\\nlet t = Date.now();\\nsleep(100).then(() => {\\n  console.log(Date.now() - t); // Output: 100\\n});\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3707286,
                "title": "simple-solution",
                "content": "The setTimeout function in JavaScript allows you to delay the execution of a piece of code (a function) for a specified amount of time. It\\'s like saying, \"Wait for a while, and then do this.\"\\n# Code\\n```\\n/**\\n * @param {number} millis\\n */\\nasync function sleep(millis) \\n{\\n    return new Promise((res) => \\n{\\n        setTimeout(res, millis);\\n    });\\n}\\n/** \\n * let t = Date.now()\\n * sleep(100).then(() => console.log(Date.now() - t)) // 100\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} millis\\n */\\nasync function sleep(millis) \\n{\\n    return new Promise((res) => \\n{\\n        setTimeout(res, millis);\\n    });\\n}\\n/** \\n * let t = Date.now()\\n * sleep(100).then(() => console.log(Date.now() - t)) // 100\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3706085,
                "title": "javascript-simple-solution-with-promise-settimeout-runtime-beats-95-6-memory-beats-70-6",
                "content": "At the time of posting:\\nRuntime - beats 95.6%; Memory - beats 70.6% \\n\\n# Code\\n```\\n/**\\n * @param {number} millis\\n */\\nasync function sleep(millis) {\\n    return new Promise((resolve, reject) => {\\n      setTimeout(() => {\\n        resolve();\\n      }, millis);\\n    });\\n}\\n\\n/** \\n * let t = Date.now()\\n * sleep(100).then(() => console.log(Date.now() - t)) // 100\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} millis\\n */\\nasync function sleep(millis) {\\n    return new Promise((resolve, reject) => {\\n      setTimeout(() => {\\n        resolve();\\n      }, millis);\\n    });\\n}\\n\\n/** \\n * let t = Date.now()\\n * sleep(100).then(() => console.log(Date.now() - t)) // 100\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3691951,
                "title": "sleep",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number} millis\\n */\\nasync function sleep(millis) {\\n    await new Promise(resolve => setTimeout(resolve, millis))\\n}\\n\\n/** \\n * let t = Date.now()\\n * sleep(100).then(() => console.log(Date.now() - t)) // 100\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} millis\\n */\\nasync function sleep(millis) {\\n    await new Promise(resolve => setTimeout(resolve, millis))\\n}\\n\\n/** \\n * let t = Date.now()\\n * sleep(100).then(() => console.log(Date.now() - t)) // 100\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3690200,
                "title": "one-line-javascript-sleep",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe will be using promise with delay ( setTimeout ) to solve the problem.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nmaking a new promise and then resolve after giving the parameter value as delay\\n\\n\\n# Code\\n```\\n/**\\n * @param {number} millis\\n */\\nasync function sleep(millis) {\\n    return  new Promise((resolve) => setTimeout(resolve,millis))  \\n}\\n\\n/** \\n * let t = Date.now()\\n * sleep(100).then(() => console.log(Date.now() - t)) // 100\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} millis\\n */\\nasync function sleep(millis) {\\n    return  new Promise((resolve) => setTimeout(resolve,millis))  \\n}\\n\\n/** \\n * let t = Date.now()\\n * sleep(100).then(() => console.log(Date.now() - t)) // 100\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3681923,
                "title": "easliy-understand-sleep",
                "content": "# Approach\\nIn the solution code, the sleep function returns a Promise that resolves after the specified number of milliseconds. \\n\\nIt achieves this by using the setTimeout function, which takes a callback function (resolve in this case) and a duration in milliseconds (millis). \\n\\nThe setTimeout function schedules the execution of the callback function after the specified duration.\\n\\n# Code\\n```\\n/**\\n * @param {number} millis\\n */\\nasync function sleep(millis) {\\n    return new Promise((resolve) => {\\n    setTimeout(resolve, millis);\\n  });\\n        \\n}\\n\\n/** \\n * let t = Date.now()\\n * sleep(100).then(() => console.log(Date.now() - t)) // 100\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} millis\\n */\\nasync function sleep(millis) {\\n    return new Promise((resolve) => {\\n    setTimeout(resolve, millis);\\n  });\\n        \\n}\\n\\n/** \\n * let t = Date.now()\\n * sleep(100).then(() => console.log(Date.now() - t)) // 100\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3680228,
                "title": "one-line-of-code-using-promise",
                "content": "\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe sleep() function returns a Promise that resolves after the specified number of milliseconds using setTimeout(). The setTimeout() function waits for the specified time interval before invoking the resolve function, which resolves the Promise.\\n\\n\\n# Code\\n```\\n/**\\n * @param {number} millis\\n */\\nasync function sleep(millis) {\\n    return new Promise(resolve => setTimeout(resolve, millis));\\n}\\n\\n/** \\n * let t = Date.now()\\n * sleep(100).then(() => console.log(Date.now() - t)) // 100\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} millis\\n */\\nasync function sleep(millis) {\\n    return new Promise(resolve => setTimeout(resolve, millis));\\n}\\n\\n/** \\n * let t = Date.now()\\n * sleep(100).then(() => console.log(Date.now() - t)) // 100\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3677877,
                "title": "promise-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number} millis\\n */\\nasync function sleep(millis) {\\n    let promise = await new Promise((resolve, reject)=>{\\n        setTimeout(()=>{\\n            resolve()\\n        },millis)\\n    })\\n    \\n}\\n\\n/** \\n * let t = Date.now()\\n * sleep(100).then(() => console.log(Date.now() - t)) // 100\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} millis\\n */\\nasync function sleep(millis) {\\n    let promise = await new Promise((resolve, reject)=>{\\n        setTimeout(()=>{\\n            resolve()\\n        },millis)\\n    })\\n    \\n}\\n\\n/** \\n * let t = Date.now()\\n * sleep(100).then(() => console.log(Date.now() - t)) // 100\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3670347,
                "title": "easy-solution-javascript",
                "content": "# Intuition\\nWe need to return Promise after \"millis\"\\n\\n# Code\\n```\\nasync function sleep(millis) {\\n    return new Promise((resolve, reject) => {\\n        setTimeout(() => {\\n            resolve(millis);\\n        }, millis);\\n    });\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nasync function sleep(millis) {\\n    return new Promise((resolve, reject) => {\\n        setTimeout(() => {\\n            resolve(millis);\\n        }, millis);\\n    });\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3665844,
                "title": "sleep",
                "content": "\\n# Code\\n```\\n/**\\n * @param {number} millis\\n */\\nasync function sleep(millis) {\\n    await new Promise(resolve => setTimeout(resolve, millis+1));\\n}\\n\\n/** \\n * let t = Date.now()\\n * sleep(100).then(() => console.log(Date.now() - t)) // 100\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} millis\\n */\\nasync function sleep(millis) {\\n    await new Promise(resolve => setTimeout(resolve, millis+1));\\n}\\n\\n/** \\n * let t = Date.now()\\n * sleep(100).then(() => console.log(Date.now() - t)) // 100\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3665648,
                "title": "",
                "content": "# Have fun with my Code\\n```\\n/**\\n * @param {number} millis\\n */\\nasync function sleep(millis) {\\n    return new Promise((res) => setTimeout(() => res(\\'hi\\'), millis)).then(res => res)\\n}\\n\\n/** \\n * let t = Date.now()\\n * sleep(100).then(() => console.log(Date.now() - t)) // 100\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} millis\\n */\\nasync function sleep(millis) {\\n    return new Promise((res) => setTimeout(() => res(\\'hi\\'), millis)).then(res => res)\\n}\\n\\n/** \\n * let t = Date.now()\\n * sleep(100).then(() => console.log(Date.now() - t)) // 100\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3665243,
                "title": "simple-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number} millis\\n */\\nasync function sleep(millis) {\\n    return new Promise((res,rej) => setTimeout(res,millis))\\n}\\n\\n/** \\n * let t = Date.now()\\n * sleep(100).then(() => console.log(Date.now() - t)) // 100\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} millis\\n */\\nasync function sleep(millis) {\\n    return new Promise((res,rej) => setTimeout(res,millis))\\n}\\n\\n/** \\n * let t = Date.now()\\n * sleep(100).then(() => console.log(Date.now() - t)) // 100\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3661879,
                "title": "one-line-simple-javascript-typescript-solution",
                "content": "\\n```\\nconst sleep = async (millis) => new Promise((resolve) => setTimeout(resolve, millis));\\n\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "```\\nconst sleep = async (millis) => new Promise((resolve) => setTimeout(resolve, millis));\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3642482,
                "title": "using-the-setimeout-and-promise",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nFirst of all they have mentioned in the problem that you have to return resolved promise, so you have to create the Promise and then use the setTimeout.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nI have solved the problme using the new Promise, put the seTimeout,The setTimeout() method calls a function after a number of milliseconds.Then, it will resolve the promise and return the millis.\\n\\n# Code\\n```\\n/**\\n * @param {number} millis\\n */\\nasync function sleep(millis) {\\n    return new Promise((resolve) => {\\n        setTimeout(() => {\\n           resolve(millis)\\n        }, millis);\\n    })\\n}\\n\\n/** \\n * let t = Date.now()\\n * sleep(100).then(() => console.log(Date.now() - t)) // 100\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} millis\\n */\\nasync function sleep(millis) {\\n    return new Promise((resolve) => {\\n        setTimeout(() => {\\n           resolve(millis)\\n        }, millis);\\n    })\\n}\\n\\n/** \\n * let t = Date.now()\\n * sleep(100).then(() => console.log(Date.now() - t)) // 100\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3641057,
                "title": "i-m-beginners",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number} millis\\n */\\nasync function sleep(millis) {\\n   \\n  await new Promise(resolve=>setTimeout(resolve,millis));\\n  \\n  return millis\\n}\\n\\n\\n\\n\\n/** \\n * let t = Date.now()\\n * sleep(100).then(() => console.log(Date.now() - t)) // 100\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} millis\\n */\\nasync function sleep(millis) {\\n   \\n  await new Promise(resolve=>setTimeout(resolve,millis));\\n  \\n  return millis\\n}\\n\\n\\n\\n\\n/** \\n * let t = Date.now()\\n * sleep(100).then(() => console.log(Date.now() - t)) // 100\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3628177,
                "title": "solution-with-detailed-explanation",
                "content": "\\n\\n# Approach\\nDemonstrates a simple approach for implementing a sleep function using promises and asynchronous JavaScript. The main steps involved are:\\n\\nCreating a new Promise: The code creates a new Promise instance using the Promise constructor. The promise takes a callback function with two parameters, resolve and reject.\\n\\nScheduling the delay: Inside the promise, the setTimeout function is used to schedule a delay. The setTimeout function receives a callback function and a delay in milliseconds. In this case, the callback function calls resolve(\"done\") after the specified delay.\\n\\nAwaiting the promise: The await keyword is used to pause the execution of the sleep function until the promise is resolved. This allows the code to simulate a delay without blocking the execution of other code.\\n\\nObtaining the resolved value: The resolved value of the promise is stored in the res variable, although it is not used or returned in the provided code snippet.\\n\\n# Complexity\\n- Time complexity:\\n**O(1)**\\nthe actual execution time of the setTimeout function is not influenced by the size of the input or any other factors. Therefore, the time complexity remains constant.\\n\\n- Space complexity:\\n**O(1)**\\n\\n# Code\\n```\\n/**\\n * @param {number} millis\\n */\\nasync function sleep(millis) {\\n     let promise = new Promise((resolve, reject) => {\\n    setTimeout(() => {\\n      resolve(\"done\");\\n    }, millis);\\n  });\\n  let res = await promise;\\n}\\n\\n/** \\n * let t = Date.now()\\n * sleep(100).then(() => console.log(Date.now() - t)) // 100\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} millis\\n */\\nasync function sleep(millis) {\\n     let promise = new Promise((resolve, reject) => {\\n    setTimeout(() => {\\n      resolve(\"done\");\\n    }, millis);\\n  });\\n  let res = await promise;\\n}\\n\\n/** \\n * let t = Date.now()\\n * sleep(100).then(() => console.log(Date.now() - t)) // 100\\n */\\n```",
                "codeTag": "Unknown"
            }
        ],
        "discussions": [
            {
                "id": 1873383,
                "content": [
                    {
                        "username": "angeldeveloper09",
                        "content": "actually when I see this problem I\\'m confusing..."
                    },
                    {
                        "username": "Code_Sagar",
                        "content": "Day 11 : Done Solving Today\\'s Question \\n\\nTip : The function sleep will wait for millis second that is setTimeout will be used with the a function enclosed in an promise object "
                    },
                    {
                        "username": "Aditya-Naresh",
                        "content": "A nice question to just make a promise"
                    },
                    {
                        "username": "aaryandewan",
                        "content": "I'm confused, can someone explain why this doesn't work? \n\n\n`\nasync function sleep(millis) {\n\n   setTimeout(() => new Promise((resolve, reject) => {\n       resolve();\n   }), millis); \n}\n`"
                    },
                    {
                        "username": "aaryandewan",
                        "content": "[@Aditya-Naresh](/Aditya-Naresh) Understood, thanks a ton :) "
                    },
                    {
                        "username": "Aditya-Naresh",
                        "content": "The code you provided defines an async function called sleep that takes a parameter millis representing the number of milliseconds to sleep.\\n\\nInside the function, it uses the setTimeout function to schedule a callback after the specified number of milliseconds. The callback creates a new Promise that immediately resolves using the resolve function. However, since the setTimeout function itself doesn\\'t return a promise, the created promise doesn\\'t have any impact on the asynchronous behavior of setTimeout.\\n\\n\\nI\\'d suggest checking out other solutions if you are still confused and try to compare it with it"
                    },
                    {
                        "username": "shurfee",
                        "content": "Authors should fix the description - they should mention that slightly inaccuracy is acceptable. Because it is impossible to solve it with 100% accuracy due to how the javascript engines work."
                    },
                    {
                        "username": "BrownCarter",
                        "content": "they say it should resolve any value but the solution cannot resolve any value"
                    },
                    {
                        "username": "amancse1",
                        "content": "solution 1 hint : - \\ncreate a callback function where you have to pass resolve and reject as an parameter and inside that fuction use setTimeout \\n\\nafter this return new Promise with callback fuction \\n\\n\\nsolution 2  hint : - use await and setTimeout \\nno need to return anything"
                    },
                    {
                        "username": "Narkaa",
                        "content": "You can use await !!\\n"
                    },
                    {
                        "username": "Gamal_mohamed_2001",
                        "content": "One possible way to solve this problem is to use the setTimeout function, which takes a callback function and a delay in milliseconds as arguments and executes the callback function after the delay. We can wrap the setTimeout function in a promise constructor, which takes an executor function that receives two arguments: resolve and reject. The resolve function is used to resolve the promise with a value, and the reject function is used to reject the promise with a reason."
                    }
                ]
            },
            {
                "id": 1894617,
                "content": [
                    {
                        "username": "angeldeveloper09",
                        "content": "actually when I see this problem I\\'m confusing..."
                    },
                    {
                        "username": "Code_Sagar",
                        "content": "Day 11 : Done Solving Today\\'s Question \\n\\nTip : The function sleep will wait for millis second that is setTimeout will be used with the a function enclosed in an promise object "
                    },
                    {
                        "username": "Aditya-Naresh",
                        "content": "A nice question to just make a promise"
                    },
                    {
                        "username": "aaryandewan",
                        "content": "I'm confused, can someone explain why this doesn't work? \n\n\n`\nasync function sleep(millis) {\n\n   setTimeout(() => new Promise((resolve, reject) => {\n       resolve();\n   }), millis); \n}\n`"
                    },
                    {
                        "username": "aaryandewan",
                        "content": "[@Aditya-Naresh](/Aditya-Naresh) Understood, thanks a ton :) "
                    },
                    {
                        "username": "Aditya-Naresh",
                        "content": "The code you provided defines an async function called sleep that takes a parameter millis representing the number of milliseconds to sleep.\\n\\nInside the function, it uses the setTimeout function to schedule a callback after the specified number of milliseconds. The callback creates a new Promise that immediately resolves using the resolve function. However, since the setTimeout function itself doesn\\'t return a promise, the created promise doesn\\'t have any impact on the asynchronous behavior of setTimeout.\\n\\n\\nI\\'d suggest checking out other solutions if you are still confused and try to compare it with it"
                    },
                    {
                        "username": "shurfee",
                        "content": "Authors should fix the description - they should mention that slightly inaccuracy is acceptable. Because it is impossible to solve it with 100% accuracy due to how the javascript engines work."
                    },
                    {
                        "username": "BrownCarter",
                        "content": "they say it should resolve any value but the solution cannot resolve any value"
                    },
                    {
                        "username": "amancse1",
                        "content": "solution 1 hint : - \\ncreate a callback function where you have to pass resolve and reject as an parameter and inside that fuction use setTimeout \\n\\nafter this return new Promise with callback fuction \\n\\n\\nsolution 2  hint : - use await and setTimeout \\nno need to return anything"
                    },
                    {
                        "username": "Narkaa",
                        "content": "You can use await !!\\n"
                    },
                    {
                        "username": "Gamal_mohamed_2001",
                        "content": "One possible way to solve this problem is to use the setTimeout function, which takes a callback function and a delay in milliseconds as arguments and executes the callback function after the delay. We can wrap the setTimeout function in a promise constructor, which takes an executor function that receives two arguments: resolve and reject. The resolve function is used to resolve the promise with a value, and the reject function is used to reject the promise with a reason."
                    }
                ]
            },
            {
                "id": 1861362,
                "content": [
                    {
                        "username": "angeldeveloper09",
                        "content": "actually when I see this problem I\\'m confusing..."
                    },
                    {
                        "username": "Code_Sagar",
                        "content": "Day 11 : Done Solving Today\\'s Question \\n\\nTip : The function sleep will wait for millis second that is setTimeout will be used with the a function enclosed in an promise object "
                    },
                    {
                        "username": "Aditya-Naresh",
                        "content": "A nice question to just make a promise"
                    },
                    {
                        "username": "aaryandewan",
                        "content": "I'm confused, can someone explain why this doesn't work? \n\n\n`\nasync function sleep(millis) {\n\n   setTimeout(() => new Promise((resolve, reject) => {\n       resolve();\n   }), millis); \n}\n`"
                    },
                    {
                        "username": "aaryandewan",
                        "content": "[@Aditya-Naresh](/Aditya-Naresh) Understood, thanks a ton :) "
                    },
                    {
                        "username": "Aditya-Naresh",
                        "content": "The code you provided defines an async function called sleep that takes a parameter millis representing the number of milliseconds to sleep.\\n\\nInside the function, it uses the setTimeout function to schedule a callback after the specified number of milliseconds. The callback creates a new Promise that immediately resolves using the resolve function. However, since the setTimeout function itself doesn\\'t return a promise, the created promise doesn\\'t have any impact on the asynchronous behavior of setTimeout.\\n\\n\\nI\\'d suggest checking out other solutions if you are still confused and try to compare it with it"
                    },
                    {
                        "username": "shurfee",
                        "content": "Authors should fix the description - they should mention that slightly inaccuracy is acceptable. Because it is impossible to solve it with 100% accuracy due to how the javascript engines work."
                    },
                    {
                        "username": "BrownCarter",
                        "content": "they say it should resolve any value but the solution cannot resolve any value"
                    },
                    {
                        "username": "amancse1",
                        "content": "solution 1 hint : - \\ncreate a callback function where you have to pass resolve and reject as an parameter and inside that fuction use setTimeout \\n\\nafter this return new Promise with callback fuction \\n\\n\\nsolution 2  hint : - use await and setTimeout \\nno need to return anything"
                    },
                    {
                        "username": "Narkaa",
                        "content": "You can use await !!\\n"
                    },
                    {
                        "username": "Gamal_mohamed_2001",
                        "content": "One possible way to solve this problem is to use the setTimeout function, which takes a callback function and a delay in milliseconds as arguments and executes the callback function after the delay. We can wrap the setTimeout function in a promise constructor, which takes an executor function that receives two arguments: resolve and reject. The resolve function is used to resolve the promise with a value, and the reject function is used to reject the promise with a reason."
                    }
                ]
            },
            {
                "id": 1941668,
                "content": [
                    {
                        "username": "angeldeveloper09",
                        "content": "actually when I see this problem I\\'m confusing..."
                    },
                    {
                        "username": "Code_Sagar",
                        "content": "Day 11 : Done Solving Today\\'s Question \\n\\nTip : The function sleep will wait for millis second that is setTimeout will be used with the a function enclosed in an promise object "
                    },
                    {
                        "username": "Aditya-Naresh",
                        "content": "A nice question to just make a promise"
                    },
                    {
                        "username": "aaryandewan",
                        "content": "I'm confused, can someone explain why this doesn't work? \n\n\n`\nasync function sleep(millis) {\n\n   setTimeout(() => new Promise((resolve, reject) => {\n       resolve();\n   }), millis); \n}\n`"
                    },
                    {
                        "username": "aaryandewan",
                        "content": "[@Aditya-Naresh](/Aditya-Naresh) Understood, thanks a ton :) "
                    },
                    {
                        "username": "Aditya-Naresh",
                        "content": "The code you provided defines an async function called sleep that takes a parameter millis representing the number of milliseconds to sleep.\\n\\nInside the function, it uses the setTimeout function to schedule a callback after the specified number of milliseconds. The callback creates a new Promise that immediately resolves using the resolve function. However, since the setTimeout function itself doesn\\'t return a promise, the created promise doesn\\'t have any impact on the asynchronous behavior of setTimeout.\\n\\n\\nI\\'d suggest checking out other solutions if you are still confused and try to compare it with it"
                    },
                    {
                        "username": "shurfee",
                        "content": "Authors should fix the description - they should mention that slightly inaccuracy is acceptable. Because it is impossible to solve it with 100% accuracy due to how the javascript engines work."
                    },
                    {
                        "username": "BrownCarter",
                        "content": "they say it should resolve any value but the solution cannot resolve any value"
                    },
                    {
                        "username": "amancse1",
                        "content": "solution 1 hint : - \\ncreate a callback function where you have to pass resolve and reject as an parameter and inside that fuction use setTimeout \\n\\nafter this return new Promise with callback fuction \\n\\n\\nsolution 2  hint : - use await and setTimeout \\nno need to return anything"
                    },
                    {
                        "username": "Narkaa",
                        "content": "You can use await !!\\n"
                    },
                    {
                        "username": "Gamal_mohamed_2001",
                        "content": "One possible way to solve this problem is to use the setTimeout function, which takes a callback function and a delay in milliseconds as arguments and executes the callback function after the delay. We can wrap the setTimeout function in a promise constructor, which takes an executor function that receives two arguments: resolve and reject. The resolve function is used to resolve the promise with a value, and the reject function is used to reject the promise with a reason."
                    }
                ]
            },
            {
                "id": 1894744,
                "content": [
                    {
                        "username": "angeldeveloper09",
                        "content": "actually when I see this problem I\\'m confusing..."
                    },
                    {
                        "username": "Code_Sagar",
                        "content": "Day 11 : Done Solving Today\\'s Question \\n\\nTip : The function sleep will wait for millis second that is setTimeout will be used with the a function enclosed in an promise object "
                    },
                    {
                        "username": "Aditya-Naresh",
                        "content": "A nice question to just make a promise"
                    },
                    {
                        "username": "aaryandewan",
                        "content": "I'm confused, can someone explain why this doesn't work? \n\n\n`\nasync function sleep(millis) {\n\n   setTimeout(() => new Promise((resolve, reject) => {\n       resolve();\n   }), millis); \n}\n`"
                    },
                    {
                        "username": "aaryandewan",
                        "content": "[@Aditya-Naresh](/Aditya-Naresh) Understood, thanks a ton :) "
                    },
                    {
                        "username": "Aditya-Naresh",
                        "content": "The code you provided defines an async function called sleep that takes a parameter millis representing the number of milliseconds to sleep.\\n\\nInside the function, it uses the setTimeout function to schedule a callback after the specified number of milliseconds. The callback creates a new Promise that immediately resolves using the resolve function. However, since the setTimeout function itself doesn\\'t return a promise, the created promise doesn\\'t have any impact on the asynchronous behavior of setTimeout.\\n\\n\\nI\\'d suggest checking out other solutions if you are still confused and try to compare it with it"
                    },
                    {
                        "username": "shurfee",
                        "content": "Authors should fix the description - they should mention that slightly inaccuracy is acceptable. Because it is impossible to solve it with 100% accuracy due to how the javascript engines work."
                    },
                    {
                        "username": "BrownCarter",
                        "content": "they say it should resolve any value but the solution cannot resolve any value"
                    },
                    {
                        "username": "amancse1",
                        "content": "solution 1 hint : - \\ncreate a callback function where you have to pass resolve and reject as an parameter and inside that fuction use setTimeout \\n\\nafter this return new Promise with callback fuction \\n\\n\\nsolution 2  hint : - use await and setTimeout \\nno need to return anything"
                    },
                    {
                        "username": "Narkaa",
                        "content": "You can use await !!\\n"
                    },
                    {
                        "username": "Gamal_mohamed_2001",
                        "content": "One possible way to solve this problem is to use the setTimeout function, which takes a callback function and a delay in milliseconds as arguments and executes the callback function after the delay. We can wrap the setTimeout function in a promise constructor, which takes an executor function that receives two arguments: resolve and reject. The resolve function is used to resolve the promise with a value, and the reject function is used to reject the promise with a reason."
                    }
                ]
            },
            {
                "id": 1901359,
                "content": [
                    {
                        "username": "angeldeveloper09",
                        "content": "actually when I see this problem I\\'m confusing..."
                    },
                    {
                        "username": "Code_Sagar",
                        "content": "Day 11 : Done Solving Today\\'s Question \\n\\nTip : The function sleep will wait for millis second that is setTimeout will be used with the a function enclosed in an promise object "
                    },
                    {
                        "username": "Aditya-Naresh",
                        "content": "A nice question to just make a promise"
                    },
                    {
                        "username": "aaryandewan",
                        "content": "I'm confused, can someone explain why this doesn't work? \n\n\n`\nasync function sleep(millis) {\n\n   setTimeout(() => new Promise((resolve, reject) => {\n       resolve();\n   }), millis); \n}\n`"
                    },
                    {
                        "username": "aaryandewan",
                        "content": "[@Aditya-Naresh](/Aditya-Naresh) Understood, thanks a ton :) "
                    },
                    {
                        "username": "Aditya-Naresh",
                        "content": "The code you provided defines an async function called sleep that takes a parameter millis representing the number of milliseconds to sleep.\\n\\nInside the function, it uses the setTimeout function to schedule a callback after the specified number of milliseconds. The callback creates a new Promise that immediately resolves using the resolve function. However, since the setTimeout function itself doesn\\'t return a promise, the created promise doesn\\'t have any impact on the asynchronous behavior of setTimeout.\\n\\n\\nI\\'d suggest checking out other solutions if you are still confused and try to compare it with it"
                    },
                    {
                        "username": "shurfee",
                        "content": "Authors should fix the description - they should mention that slightly inaccuracy is acceptable. Because it is impossible to solve it with 100% accuracy due to how the javascript engines work."
                    },
                    {
                        "username": "BrownCarter",
                        "content": "they say it should resolve any value but the solution cannot resolve any value"
                    },
                    {
                        "username": "amancse1",
                        "content": "solution 1 hint : - \\ncreate a callback function where you have to pass resolve and reject as an parameter and inside that fuction use setTimeout \\n\\nafter this return new Promise with callback fuction \\n\\n\\nsolution 2  hint : - use await and setTimeout \\nno need to return anything"
                    },
                    {
                        "username": "Narkaa",
                        "content": "You can use await !!\\n"
                    },
                    {
                        "username": "Gamal_mohamed_2001",
                        "content": "One possible way to solve this problem is to use the setTimeout function, which takes a callback function and a delay in milliseconds as arguments and executes the callback function after the delay. We can wrap the setTimeout function in a promise constructor, which takes an executor function that receives two arguments: resolve and reject. The resolve function is used to resolve the promise with a value, and the reject function is used to reject the promise with a reason."
                    }
                ]
            },
            {
                "id": 1894313,
                "content": [
                    {
                        "username": "angeldeveloper09",
                        "content": "actually when I see this problem I\\'m confusing..."
                    },
                    {
                        "username": "Code_Sagar",
                        "content": "Day 11 : Done Solving Today\\'s Question \\n\\nTip : The function sleep will wait for millis second that is setTimeout will be used with the a function enclosed in an promise object "
                    },
                    {
                        "username": "Aditya-Naresh",
                        "content": "A nice question to just make a promise"
                    },
                    {
                        "username": "aaryandewan",
                        "content": "I'm confused, can someone explain why this doesn't work? \n\n\n`\nasync function sleep(millis) {\n\n   setTimeout(() => new Promise((resolve, reject) => {\n       resolve();\n   }), millis); \n}\n`"
                    },
                    {
                        "username": "aaryandewan",
                        "content": "[@Aditya-Naresh](/Aditya-Naresh) Understood, thanks a ton :) "
                    },
                    {
                        "username": "Aditya-Naresh",
                        "content": "The code you provided defines an async function called sleep that takes a parameter millis representing the number of milliseconds to sleep.\\n\\nInside the function, it uses the setTimeout function to schedule a callback after the specified number of milliseconds. The callback creates a new Promise that immediately resolves using the resolve function. However, since the setTimeout function itself doesn\\'t return a promise, the created promise doesn\\'t have any impact on the asynchronous behavior of setTimeout.\\n\\n\\nI\\'d suggest checking out other solutions if you are still confused and try to compare it with it"
                    },
                    {
                        "username": "shurfee",
                        "content": "Authors should fix the description - they should mention that slightly inaccuracy is acceptable. Because it is impossible to solve it with 100% accuracy due to how the javascript engines work."
                    },
                    {
                        "username": "BrownCarter",
                        "content": "they say it should resolve any value but the solution cannot resolve any value"
                    },
                    {
                        "username": "amancse1",
                        "content": "solution 1 hint : - \\ncreate a callback function where you have to pass resolve and reject as an parameter and inside that fuction use setTimeout \\n\\nafter this return new Promise with callback fuction \\n\\n\\nsolution 2  hint : - use await and setTimeout \\nno need to return anything"
                    },
                    {
                        "username": "Narkaa",
                        "content": "You can use await !!\\n"
                    },
                    {
                        "username": "Gamal_mohamed_2001",
                        "content": "One possible way to solve this problem is to use the setTimeout function, which takes a callback function and a delay in milliseconds as arguments and executes the callback function after the delay. We can wrap the setTimeout function in a promise constructor, which takes an executor function that receives two arguments: resolve and reject. The resolve function is used to resolve the promise with a value, and the reject function is used to reject the promise with a reason."
                    }
                ]
            },
            {
                "id": 2006930,
                "content": [
                    {
                        "username": "angeldeveloper09",
                        "content": "actually when I see this problem I\\'m confusing..."
                    },
                    {
                        "username": "Code_Sagar",
                        "content": "Day 11 : Done Solving Today\\'s Question \\n\\nTip : The function sleep will wait for millis second that is setTimeout will be used with the a function enclosed in an promise object "
                    },
                    {
                        "username": "Aditya-Naresh",
                        "content": "A nice question to just make a promise"
                    },
                    {
                        "username": "aaryandewan",
                        "content": "I'm confused, can someone explain why this doesn't work? \n\n\n`\nasync function sleep(millis) {\n\n   setTimeout(() => new Promise((resolve, reject) => {\n       resolve();\n   }), millis); \n}\n`"
                    },
                    {
                        "username": "aaryandewan",
                        "content": "[@Aditya-Naresh](/Aditya-Naresh) Understood, thanks a ton :) "
                    },
                    {
                        "username": "Aditya-Naresh",
                        "content": "The code you provided defines an async function called sleep that takes a parameter millis representing the number of milliseconds to sleep.\\n\\nInside the function, it uses the setTimeout function to schedule a callback after the specified number of milliseconds. The callback creates a new Promise that immediately resolves using the resolve function. However, since the setTimeout function itself doesn\\'t return a promise, the created promise doesn\\'t have any impact on the asynchronous behavior of setTimeout.\\n\\n\\nI\\'d suggest checking out other solutions if you are still confused and try to compare it with it"
                    },
                    {
                        "username": "shurfee",
                        "content": "Authors should fix the description - they should mention that slightly inaccuracy is acceptable. Because it is impossible to solve it with 100% accuracy due to how the javascript engines work."
                    },
                    {
                        "username": "BrownCarter",
                        "content": "they say it should resolve any value but the solution cannot resolve any value"
                    },
                    {
                        "username": "amancse1",
                        "content": "solution 1 hint : - \\ncreate a callback function where you have to pass resolve and reject as an parameter and inside that fuction use setTimeout \\n\\nafter this return new Promise with callback fuction \\n\\n\\nsolution 2  hint : - use await and setTimeout \\nno need to return anything"
                    },
                    {
                        "username": "Narkaa",
                        "content": "You can use await !!\\n"
                    },
                    {
                        "username": "Gamal_mohamed_2001",
                        "content": "One possible way to solve this problem is to use the setTimeout function, which takes a callback function and a delay in milliseconds as arguments and executes the callback function after the delay. We can wrap the setTimeout function in a promise constructor, which takes an executor function that receives two arguments: resolve and reject. The resolve function is used to resolve the promise with a value, and the reject function is used to reject the promise with a reason."
                    }
                ]
            }
        ]
    }
]