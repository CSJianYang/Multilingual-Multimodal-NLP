[
    {
        "title": "Append Characters to String to Make Subsequence",
        "question_content": "You are given two strings s and t consisting of only lowercase English letters.\nReturn the minimum number of characters that need to be appended to the end of s so that t becomes a subsequence of s.\nA subsequence is a string that can be derived from another string by deleting some or no characters without changing the order of the remaining characters.\n&nbsp;\nExample 1:\n\nInput: s = \"coaching\", t = \"coding\"\nOutput: 4\nExplanation: Append the characters \"ding\" to the end of s so that s = \"coachingding\".\nNow, t is a subsequence of s (\"coachingding\").\nIt can be shown that appending any 3 characters to the end of s will never make t a subsequence.\n\nExample 2:\n\nInput: s = \"abcde\", t = \"a\"\nOutput: 0\nExplanation: t is already a subsequence of s (\"abcde\").\n\nExample 3:\n\nInput: s = \"z\", t = \"abcde\"\nOutput: 5\nExplanation: Append the characters \"abcde\" to the end of s so that s = \"zabcde\".\nNow, t is a subsequence of s (\"zabcde\").\nIt can be shown that appending any 4 characters to the end of s will never make t a subsequence.\n\n&nbsp;\nConstraints:\n\n\t1 <= s.length, t.length <= 105\n\ts and t consist only of lowercase English letters.",
        "solutions": [
            {
                "id": 2852055,
                "title": "python-c-java-find-common-prefix-using-two-pointers-explained",
                "content": "**\\u2705 IF YOU LIKE THIS SOLUTION, PLEASE UPVOTE.**\\n****\\nThis solution employs two pointers to iterate over sequences in order to find their common prefix subsequence. Time complexity is linear: **O(N)**. Space complexity is constant: **O(1)**. \\n****\\n**Comment.** First, we should find common prefix subsequence (without skipping characters from `t`). This is achieved by iterating over characters in `s` (first pointer) and moving to the next character in `t` (second pointer) once we found a match (see code). For example, for `s=catheatscodtoeat` and `t=cheatcoding`, the common prefix would be (in brackets) `s=[c]at[heat]s[cod]` and `t=[cheatcod]ing`. In the end, we add missing characters to reach full length.\\n\\n**Python.**\\n```\\nclass Solution:\\n    def appendCharacters(self, s: str, t: str) -> int:\\n        \\n        i = j = 0                         \\n        while i < len(s) and j < len(t):     # find characters from \\'t\\' in \\'s\\':\\n            j += s[i] == t[j]                # - characters in \\'t\\' can\\'t be skipped\\n            i += 1                           # - characters in \\'s\\' can be skipped\\n\\n        return len(t) - j                    # return missing characters\\n```\\n\\n**C++.**\\n```\\nclass Solution \\n{\\npublic:\\n    int appendCharacters(string s, string t, int j = 0) \\n    {\\n        for (int i = 0; i < s.size() && j < t.size(); i++)\\n            j += s[i] == t[j];\\n        return t.size() - j;\\n    }\\n};\\n```\\n\\n**Java.**\\n```\\nclass Solution \\n{\\n    public int appendCharacters(String s, String t) \\n    {\\n        int j = 0;\\n        for (int i = 0; i < s.length() && j < t.length(); i++)\\n            j += s.charAt(i) == t.charAt(j) ? 1 : 0;\\n        return t.length() - j;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def appendCharacters(self, s: str, t: str) -> int:\\n        \\n        i = j = 0                         \\n        while i < len(s) and j < len(t):     # find characters from \\'t\\' in \\'s\\':\\n            j += s[i] == t[j]                # - characters in \\'t\\' can\\'t be skipped\\n            i += 1                           # - characters in \\'s\\' can be skipped\\n\\n        return len(t) - j                    # return missing characters\\n```\n```\\nclass Solution \\n{\\npublic:\\n    int appendCharacters(string s, string t, int j = 0) \\n    {\\n        for (int i = 0; i < s.size() && j < t.size(); i++)\\n            j += s[i] == t[j];\\n        return t.size() - j;\\n    }\\n};\\n```\n```\\nclass Solution \\n{\\n    public int appendCharacters(String s, String t) \\n    {\\n        int j = 0;\\n        for (int i = 0; i < s.length() && j < t.length(); i++)\\n            j += s.charAt(i) == t.charAt(j) ? 1 : 0;\\n        return t.length() - j;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2852295,
                "title": "java-simple-greedy",
                "content": "just taking two pointers when the characters at both string equal incrementing the j pointer (which maintains the no of chars are equal with first string)\\n```\\nclass Solution {\\n    public int appendCharacters(String s, String t) {\\n        int m=s.length();\\n        int n=t.length();\\n        int j=0;int i=0;\\n        while(i<m && j<n){\\n            if(s.charAt(i)==t.charAt(j)){\\n                j++;\\n            }  \\n            i++;  \\n        }\\n        return t.length()-j;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\n    public int appendCharacters(String s, String t) {\\n        int m=s.length();\\n        int n=t.length();\\n        int j=0;int i=0;\\n        while(i<m && j<n){\\n            if(s.charAt(i)==t.charAt(j)){\\n                j++;\\n            }  \\n            i++;  \\n        }\\n        return t.length()-j;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2851966,
                "title": "c-solution-with-o-n-very-simple-and-easy-to-understand",
                "content": "```\\n/*\\nKeep on finding each character of t in s from the bbegining and number of letters not found of string t are need to be \\nreturned as answer.\\n*/\\n\\nclass Solution {\\npublic:\\n    int appendCharacters(string s, string t) {\\n        int j = 0;\\n        for(int i = 0; i < s.size(); ++i){\\n            if(s[i] == t[j]) j++;\\n            if(j == t.size()) return 0;\\n        }\\n        return t.size() - j;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/*\\nKeep on finding each character of t in s from the bbegining and number of letters not found of string t are need to be \\nreturned as answer.\\n*/\\n\\nclass Solution {\\npublic:\\n    int appendCharacters(string s, string t) {\\n        int j = 0;\\n        for(int i = 0; i < s.size(); ++i){\\n            if(s[i] == t[j]) j++;\\n            if(j == t.size()) return 0;\\n        }\\n        return t.size() - j;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2852026,
                "title": "c-two-pointers-simple-traversal",
                "content": "```\\nclass Solution {\\npublic:\\n    int appendCharacters(string s, string t) {\\n        int n = s.size();\\n        int m = t.size();\\n        int j  = 0;\\n        for(int i = 0 ; i < n && j < m ; i++)\\n        {\\n            if(s[i] == t[j])\\n            {\\n                j++;\\n            }\\n            \\n        }\\n        return (m-j);\\n    }\\n};\\n```\\n**Please upvote if it was helpful for you, thank you!**",
                "solutionTags": [
                    "C",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int appendCharacters(string s, string t) {\\n        int n = s.size();\\n        int m = t.size();\\n        int j  = 0;\\n        for(int i = 0 ; i < n && j < m ; i++)\\n        {\\n            if(s[i] == t[j])\\n            {\\n                j++;\\n            }\\n            \\n        }\\n        return (m-j);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2852101,
                "title": "java-c-python-two-pointers",
                "content": "# **Explanation**\\nFind the subsequence `t` in `s`:\\nfor each character `s[i]`,\\ncheck if it matches `t[j]`.\\nIf `t[j]` is matched a character in `s`,\\nthen we update `j++`,\\ncontinue to match the next `t[j]`.\\nFinally we return the length string unmatched in `t`.\\n<br>\\n\\n# **Complexity**\\nTime `O(n)`\\nSpace `O(n)`\\n<br>\\n\\n**Java**\\n```java\\n    public int appendCharacters(String s, String t) {\\n        int j = 0, n = s.length(), m = t.length();\\n        for (int i = 0; i < n && j < m; ++i)\\n            if (s.charAt(i) == t.charAt(j))\\n                j++;\\n        return m - j;\\n    }\\n```\\n\\n**C++**\\n```cpp\\n    int appendCharacters(string s, string t) {\\n        int j = 0, n = s.size(), m = t.size();\\n        for (int i = 0; i < n && j < m; ++i)\\n            j += s[i] == t[j];\\n        return m - j;\\n    }\\n```\\n\\n**Python**\\n```py\\n    def appendCharacters(self, s, t):\\n        it = iter(s)\\n        for i,c in enumerate(t):\\n            if c not in it:\\n                return len(t) - i\\n        return 0\\n```\\n",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C"
                ],
                "code": "```java\\n    public int appendCharacters(String s, String t) {\\n        int j = 0, n = s.length(), m = t.length();\\n        for (int i = 0; i < n && j < m; ++i)\\n            if (s.charAt(i) == t.charAt(j))\\n                j++;\\n        return m - j;\\n    }\\n```\n```cpp\\n    int appendCharacters(string s, string t) {\\n        int j = 0, n = s.size(), m = t.size();\\n        for (int i = 0; i < n && j < m; ++i)\\n            j += s[i] == t[j];\\n        return m - j;\\n    }\\n```\n```py\\n    def appendCharacters(self, s, t):\\n        it = iter(s)\\n        for i,c in enumerate(t):\\n            if c not in it:\\n                return len(t) - i\\n        return 0\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2851984,
                "title": "two-pointers",
                "content": "\\nPointer `i` goes through `s`, and we advance pointer `j` when `s[i] == t[j]`.\\n    \\nIn the end, we need to add `len(t) - j` characters.\\n    \\n**C++**\\n```cpp\\nint appendCharacters(string s, string t) {\\n    int j = 0;\\n    for (int i = 0; i < s.size() && j < t.size(); ++i)\\n        j += s[i] == t[j];\\n    return t.size() - j;\\n}\\n```",
                "solutionTags": [],
                "code": "```cpp\\nint appendCharacters(string s, string t) {\\n    int j = 0;\\n    for (int i = 0; i < s.size() && j < t.size(); ++i)\\n        j += s[i] == t[j];\\n    return t.size() - j;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2851936,
                "title": "c-simple-approach",
                "content": "```\\nclass Solution \\n{\\npublic:\\n    int appendCharacters(string s, string t) \\n    {\\n        int m=s.size(), n=t.size();\\n        int i=0, j=0; \\n        \\n        while(i<m && j<n)\\n        {\\n            if(s[i]==t[j]) //if character of both strings match move both pointers\\n            {\\n                i++;\\n                j++;\\n            }\\n            else //if character doesn\\'t match then move string s pointer only\\n                i++;\\n        }\\n        \\n        if((j==n)) return 0; //if we covered whole t string then no need to append character\\n        return n-j;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "String"
                ],
                "code": "```\\nclass Solution \\n{\\npublic:\\n    int appendCharacters(string s, string t) \\n    {\\n        int m=s.size(), n=t.size();\\n        int i=0, j=0; \\n        \\n        while(i<m && j<n)\\n        {\\n            if(s[i]==t[j]) //if character of both strings match move both pointers\\n            {\\n                i++;\\n                j++;\\n            }\\n            else //if character doesn\\'t match then move string s pointer only\\n                i++;\\n        }\\n        \\n        if((j==n)) return 0; //if we covered whole t string then no need to append character\\n        return n-j;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2852023,
                "title": "java-python-3-two-pointers-o-n-codes-w-brief-explanation-and-analysis",
                "content": "\\n1. Traverse `s`, if current char is same as current char of `t`, increase by 1 the pointer for `t`, `idx`.\\n2. Deducting the size of `t` by `idx` is the answer.\\n\\n```java\\n    public int appendCharacters(String s, String t) {\\n        int idx = 0;\\n        for (int i = 0; i < s.length(); ++i) {\\n            if (idx < t.length() && s.charAt(i) == t.charAt(idx)) {\\n                ++idx;\\n            }\\n        }\\n        return t.length() - idx;\\n    }\\n```\\n```python\\n    def appendCharacters(self, s: str, t: str) -> int:\\n        idx, n = 0, len(t)\\n        for c in s:\\n            if idx < n and t[idx] == c:\\n                idx += 1\\n        return n - idx\\n```\\n\\n**Analysis:**\\n\\nTime: `O(n)`, space: `O(1)`",
                "solutionTags": [
                    "Java",
                    "Python3"
                ],
                "code": "```java\\n    public int appendCharacters(String s, String t) {\\n        int idx = 0;\\n        for (int i = 0; i < s.length(); ++i) {\\n            if (idx < t.length() && s.charAt(i) == t.charAt(idx)) {\\n                ++idx;\\n            }\\n        }\\n        return t.length() - idx;\\n    }\\n```\n```python\\n    def appendCharacters(self, s: str, t: str) -> int:\\n        idx, n = 0, len(t)\\n        for c in s:\\n            if idx < n and t[idx] == c:\\n                idx += 1\\n        return n - idx\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2852628,
                "title": "simple-two-pointer-approach",
                "content": "```\\nclass Solution {\\npublic:\\n    int appendCharacters(string s, string t) {\\n        int n = s.size();\\n        int m = t.size();\\n        int i = 0;\\n        int j = 0;\\n        while(i < n)\\n        {\\n            if(s[i] == t[j])\\n            {\\n                i++;\\n                j++;\\n            }\\n            else\\n                i++;\\n        }\\n        return (m-j);\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Two Pointers"
                ],
                "code": "class Solution {\\npublic:\\n    int appendCharacters(string s, string t) {\\n        int n = s.size();\\n        int m = t.size();\\n        int i = 0;\\n        int j = 0;\\n        while(i < n)\\n        {\\n            if(s[i] == t[j])\\n            {\\n                i++;\\n                j++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2851941,
                "title": "c-using-pointers",
                "content": "```\\nclass Solution {\\npublic:\\n    int appendCharacters(string s, string t) \\n    {\\n        int m = s.length();\\n        int n = t.length();\\n        \\n        int i=0;\\n        int j=0;\\n        \\n        while(i<m && j<n)\\n        {\\n            // match string t char in s\\n            if(s[i]==t[j])\\n                j++;\\n            i++;\\n        }\\n        \\n        return n-j;            // (length of t - number of matching char of t in s)\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int appendCharacters(string s, string t) \\n    {\\n        int m = s.length();\\n        int n = t.length();\\n        \\n        int i=0;\\n        int j=0;\\n        \\n        while(i<m && j<n)\\n        {\\n            // match string t char in s\\n            if(s[i]==t[j])\\n                j++;\\n            i++;\\n        }\\n        \\n        return n-j;            // (length of t - number of matching char of t in s)\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2854244,
                "title": "c-straight-forward-two-pointers-fast-5ms",
                "content": "# Approach 1: straight forward (two pointers)\\nThis is a variation of computing the length of the common subsequence. This is a solution with two pointers, even if one of them is implicit as we are using a range based loop to loop over the string ```s```.\\n\\n```cpp\\n    static int appendCharacters(const string& s, const string& t) noexcept {\\n        int i = 0;\\n        for (char ch : s)\\n            if (ch == t[i])\\n                if (++i == size(t)) break;\\n        return size(t) - i;\\n    }\\n```\\n\\nInstead of \\n```cpp\\nif (++i == size(t)) break; \\n```\\nwould could also do\\n```cpp\\nif (++i == size(t)) return 0;\\n```\\nwhich might makes the code a bit easier to understand.\\n\\n**Complexity Analysis**\\nLet $$n$$ be the length of the string ```s``` then the\\n  * Time complexity is $$O(n)$$ as we need to loop over all of ```s``` and the\\n  * Space complexity is $$O(1)$$ because we only need a few fixed sized variables to solve the problem.\\n\\n_As always: Feedback, questions, and comments are welcome. Leaving an up-vote sparks joy! :)_\\n\\n**p.s. Join us on the [LeetCode The Hard Way Discord Server](https://discord.gg/hFUyVyWy2E)!**\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```s```\n```cpp\\n    static int appendCharacters(const string& s, const string& t) noexcept {\\n        int i = 0;\\n        for (char ch : s)\\n            if (ch == t[i])\\n                if (++i == size(t)) break;\\n        return size(t) - i;\\n    }\\n```\n```cpp\\nif (++i == size(t)) break; \\n```\n```cpp\\nif (++i == size(t)) return 0;\\n```\n```s```\n```s```",
                "codeTag": "Unknown"
            },
            {
                "id": 2854491,
                "title": "python-3-5-lines-single-pointer-w-explanation-t-m-62-ms-15-1-mb",
                "content": "```\\nclass Solution:\\n    def appendCharacters(self, s: str, t: str) -> int:\\n \\n        tLen, i = len(t), 0             # <-- tLen is the single pointer\\n\\n        for ch in s:                    # <-- iterate thru s\\n\\n            if ch == t[i]: i += 1       # <-- if a match, increment the t pointer\\n                \\n            if i == tLen: return 0      # <-- if we hit the end of t no later than\\n                                        #     the end of s, no charsneed be appended\\n\\n        return tLen - i                 # <-- if not, return the count of chars in t\\n                                        #     past the t pointer\\n```\\n[https://leetcode.com/submissions/detail/850780226/](http://)\\n\\nI could be wrong, but I think it\\'s *O*(*N*) / *O*(1).\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def appendCharacters(self, s: str, t: str) -> int:\\n \\n        tLen, i = len(t), 0             # <-- tLen is the single pointer\\n\\n        for ch in s:                    # <-- iterate thru s\\n\\n            if ch == t[i]: i += 1       # <-- if a match, increment the t pointer\\n                \\n            if i == tLen: return 0      # <-- if we hit the end of t no later than\\n                                        #     the end of s, no charsneed be appended\\n\\n        return tLen - i                 # <-- if not, return the count of chars in t\\n                                        #     past the t pointer\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2852009,
                "title": "c-string-matching-o-n-simple",
                "content": "```\\nclass Solution {\\npublic:\\n    int appendCharacters(string s, string t) {\\n        //string matching\\n        int j= 0;\\n        \\n        int n = t.size(), cnt = 0;   //this much we have to match\\n        for(int i=0; i<s.size(); i++){\\n            // cout<<s[i]<<\" \"<<t[j]<<endl;\\n            //check how many char are matching\\n            while(i<s.size() && j<t.size() && s[i] == t[j]){\\n                cnt++;\\n                i++; j++;\\n            }\\n                \\n        }\\n        \\n       //total - matched\\n        return n-cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int appendCharacters(string s, string t) {\\n        //string matching\\n        int j= 0;\\n        \\n        int n = t.size(), cnt = 0;   //this much we have to match\\n        for(int i=0; i<s.size(); i++){\\n            // cout<<s[i]<<\" \"<<t[j]<<endl;\\n            //check how many char are matching\\n            while(i<s.size() && j<t.size() && s[i] == t[j]){\\n                cnt++;\\n                i++; j++;\\n            }\\n                \\n        }\\n        \\n       //total - matched\\n        return n-cnt;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2852046,
                "title": "python-two-pointers-o-n",
                "content": "```\\nclass Solution:\\n    def appendCharacters(self, s: str, t: str) -> int:\\n        i = 0                                           # Two Pointers for string s & t\\n        j = 0\\n        \\n        while i < len(s) and j<len(t):                  # We check if current chars at s & t match.\\n            if s[i]==t[j]:                              \\n                i+=1                                    # If they match, then we update our pointers for both\\n                j+=1\\n            else:\\n                i+=1                                    # If they don\\'t, then we update pointer for only s and try again.\\n                \\n                                                        # The answer would be the number of unmatched chars in t.\\n        return len(t) - j                               # We can get that by the differene of length and matched pointer of t.",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution:\\n    def appendCharacters(self, s: str, t: str) -> int:\\n        i = 0                                           # Two Pointers for string s & t\\n        j = 0\\n        \\n        while i < len(s) and j<len(t):                  # We check if current chars at s & t match.\\n            if s[i]==t[j]:                              \\n                i+=1                                    # If they match, then we update our pointers for both\\n                j+=1\\n            else:\\n                i+=1                                    # If they don\\'t, then we update pointer for only s and try again.\\n                \\n                                                        # The answer would be the number of unmatched chars in t.\\n        return len(t) - j                               # We can get that by the differene of length and matched pointer of t.",
                "codeTag": "Java"
            },
            {
                "id": 2852002,
                "title": "c-no-extra-space-easy",
                "content": "\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int appendCharacters(string s, string t) {\\n        \\n        int j=0,cur=0;\\n        \\n        for(int i=0;i<t.length() && j<s.length();i++){\\n            while(j<s.length() && t[i] != s[j]){\\n                j++;\\n            }\\n            if(j<s.length()){\\n                cur++;  //matching elements\\n                j++;\\n            }\\n        }\\n        return t.length()-cur;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int appendCharacters(string s, string t) {\\n        \\n        int j=0,cur=0;\\n        \\n        for(int i=0;i<t.length() && j<s.length();i++){\\n            while(j<s.length() && t[i] != s[j]){\\n                j++;\\n            }\\n            if(j<s.length()){\\n                cur++;  //matching elements\\n                j++;\\n            }\\n        }\\n        return t.length()-cur;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2852644,
                "title": "c-brute-force-simple-traversal",
                "content": "class Solution {\\npublic:\\n    int appendCharacters(string s, string t) {\\n        int n1=s.length(),n2=t.length(),i,j,cnt=0,ind=0;\\n        bool f=false;\\n        for(i=0;i<n2;i++){  // for loop to traverse string t\\n            char c=t[i];\\n            f=false;\\n            for(j=ind;j<n1;){\\n                if(c==s[j]){    \\n                    cnt++;\\n                    ind=j+1;     **//if character matches then we traverse from next index**\\n                    f=true;\\n                    break;      \\n                }\\n                else j++;\\n            }\\n            if(!f) break;     **// if character is not match then remaining subsequence not found so we terminate the loop**\\n        }\\n        return n2-cnt;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int appendCharacters(string s, string t) {\\n        int n1=s.length(),n2=t.length(),i,j,cnt=0,ind=0;\\n        bool f=false;\\n        for(i=0;i<n2;i++){  // for loop to traverse string t\\n            char c=t[i];\\n            f=false;\\n            for(j=ind;j<n1;){\\n                if(c==s[j]){    \\n                    cnt++;\\n                    ind=j+1;     **//if character matches then we traverse from next index**\\n                    f=true;\\n                    break;      \\n                }",
                "codeTag": "Java"
            },
            {
                "id": 2852381,
                "title": "c-easy-approch",
                "content": "# Code\\n```\\n    int appendCharacters(string s, string t) {\\n      int sp=0, tp=0,c=0;\\n        while(sp<s.size()){\\n            if(s[sp]==t[tp])c++,tp++,sp++;\\n            else \\n                sp++;\\n        }\\n        return t.size()-c;\\n    }\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n    int appendCharacters(string s, string t) {\\n      int sp=0, tp=0,c=0;\\n        while(sp<s.size()){\\n            if(s[sp]==t[tp])c++,tp++,sp++;\\n            else \\n                sp++;\\n        }\\n        return t.size()-c;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2852168,
                "title": "java-o-n-easy-peasy-solution",
                "content": "\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Check for common characters and then return length of uncommon characters to make string t subsequence of s\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity \\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int appendCharacters(String s, String t) {\\n        int diff = 0;\\n        for(int a = 0; a<s.length(); a++){\\n            if(s.charAt(a) == t.charAt(diff))\\n                diff++;\\n            if(diff == t.length()) return 0;\\n        }\\n        return t.length()-diff;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public int appendCharacters(String s, String t) {\\n        int diff = 0;\\n        for(int a = 0; a<s.length(); a++){\\n            if(s.charAt(a) == t.charAt(diff))\\n                diff++;\\n            if(diff == t.length()) return 0;\\n        }\\n        return t.length()-diff;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3795605,
                "title": "easy-solution-in-python",
                "content": "class Solution:\\n    def appendCharacters(self, s: str, t: str) -> int:\\n        t=list(t)\\n        for i in s:\\n            if len(t)==0:\\n                return 0\\n            if(i==t[0]):\\n                t.pop(0)\\n        return len(t)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "class Solution:\\n    def appendCharacters(self, s: str, t: str) -> int:\\n        t=list(t)\\n        for i in s:\\n            if len(t)==0:\\n                return 0\\n            if(i==t[0]):\\n                t.pop(0)\\n        return len(t)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3620244,
                "title": "beats-100-very-easy-soln-single-iteration-o-n",
                "content": "\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nKeep matching the strings s and t , now let\\'s say ith charcter of t matches upto last character of s , now we have to add (i+1)-last charcter of string t so that both will have same subsequence.\\n\\n# Complexity\\n- Time complexity:\\n O(n)\\n\\n\\n- Space complexity:\\n O(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int appendCharacters(string s, string t) {\\n        int j=0;\\n        for(int i=0;i<s.size();i++)\\n        {\\n            if(s[i]==t[j])\\n            {\\n                j++;\\n                cout<<\"jis\";\\n            }\\n        }\\n        return t.size()-j;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int appendCharacters(string s, string t) {\\n        int j=0;\\n        for(int i=0;i<s.size();i++)\\n        {\\n            if(s[i]==t[j])\\n            {\\n                j++;\\n                cout<<\"jis\";\\n            }\\n        }\\n        return t.size()-j;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3254705,
                "title": "time-space-o-n-o-1-c-find-common-prefix-using-two-pointers",
                "content": "```\\nclass Solution {\\npublic:\\n    int appendCharacters(string s, string t) {\\n        int i = 0, j = 0, m = s.length(), n = t.length();\\n        while(i<m&&j<n){\\n            if(s[i]==t[j]){\\n                j++;\\n            }i++;\\n        }return n-j;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Two Pointers",
                    "String",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int appendCharacters(string s, string t) {\\n        int i = 0, j = 0, m = s.length(), n = t.length();\\n        while(i<m&&j<n){\\n            if(s[i]==t[j]){\\n                j++;\\n            }i++;\\n        }return n-j;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3236906,
                "title": "basic-string-comparison",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n- Basic String Comparison\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- Declare a pointer \\'j\\' which points to the very first character of string t.\\n- Upon the traversal of string s, when the character at s[i] matches with character at t[j], then decrement the length of string t.\\n- At last, return the size of string t(i.e.. value of \"n\" in my code) which clearly indicates \"n\" number of characters to be appended.\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int appendCharacters(string s, string t) \\n    {\\n        int m = s.size();\\n        int n = t.size();\\n        int j = 0;\\n\\n        for(int i = 0; i < m; i++)\\n        {\\n            if(s[i] == t[j])\\n            {\\n                n--;\\n                j++;\\n            }\\n        }\\n        return n;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int appendCharacters(string s, string t) \\n    {\\n        int m = s.size();\\n        int n = t.size();\\n        int j = 0;\\n\\n        for(int i = 0; i < m; i++)\\n        {\\n            if(s[i] == t[j])\\n            {\\n                n--;\\n                j++;\\n            }\\n        }\\n        return n;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2960166,
                "title": "js-easy-o-n-2-pointer-faster-than-100",
                "content": "# Approach\\ni -> Fast Pointer \\nj -> Slow Pointer\\n\\n\\n# Code\\n```\\n/**\\n * @param {string} s\\n * @param {string} t\\n * @return {number}\\n */\\nvar appendCharacters = function(s, t) {\\n    let j =0, len = t.length\\n    for(let i=0;i<s.length;i++){\\n        s[i]===t[j] && j++\\n        if(len===j) return 0\\n    }\\n    return len-j\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string} s\\n * @param {string} t\\n * @return {number}\\n */\\nvar appendCharacters = function(s, t) {\\n    let j =0, len = t.length\\n    for(let i=0;i<s.length;i++){\\n        s[i]===t[j] && j++\\n        if(len===j) return 0\\n    }\\n    return len-j\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2922618,
                "title": "c-easy-to-use",
                "content": "```\\n    int appendCharacters(string s, string t) {\\n        int k=0;\\n        for(char m:s){\\n            if(m==t[k]){\\n                k++;\\n            }\\n        }\\n        return t.size()-k;\\n    }\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n    int appendCharacters(string s, string t) {\\n        int k=0;\\n        for(char m:s){\\n            if(m==t[k]){\\n                k++;\\n            }\\n        }\\n        return t.size()-k;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2883360,
                "title": "missing-subsequence",
                "content": "# Intuition\\nTo get the min characters that need to be appended we find the how much subsequence of `t` is already present in `s`.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nThe missing length is the number of characters that need to be added.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: *`O(n)`*\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: *`O(1)`*\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int appendCharacters(string s, string t) {\\n        int i = 0, m = t.length();\\n        for(char ch: s) {\\n            if(i < m && t[i] == ch)\\n                i++;\\n        }\\n        return m - i;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int appendCharacters(string s, string t) {\\n        int i = 0, m = t.length();\\n        for(char ch: s) {\\n            if(i < m && t[i] == ch)\\n                i++;\\n        }\\n        return m - i;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2856280,
                "title": "all-languages-2-pointers-iterators-and-recursion",
                "content": "This is honestly a nice question because there are a lot of ways to approach this! These methods can be generalized to a diverse array of languages, which is something I\\'d like to highlight here.\\n\\n**Two Pointers**\\nThe two-pointer approach is fairly straightforward. In your language of choice, you can initialize a pointer that starts at the heads of `s` and `t`. Scan through the characters in `s`, incrementing the pointer in `t` whenever you encounter a match. The answer ends up being the number of unscanned characters in `t`, and you can simply calculate this using a bit of pointer (or index) math.\\n\\nThis approach can be taken up by a bunch of languages, particularly by the imperative languages we all know and love:\\n\\n<iframe src=\"https://leetcode.com/playground/c35k9pqD/shared\" frameBorder=\"0\" width=\"900\" height=\"300\"></iframe>\\n\\n---\\n\\n**Iterators**\\nWe can be less explicit about our iteration by using iterators! The procedure is still fairly similar to the above approach, except we\\'re not doing any manual index math anymore. (This is particularly useful for Rust, because the language treats their strings differently from just a vector of characters. Maybe that\\'s a good thing, but that means we *must* use iterators if we don\\'t want to explicitly allocate a separate array.)\\n\\n<iframe src=\"https://leetcode.com/playground/TGhu4WKh/shared\" frameBorder=\"0\" width=\"900\" height=\"300\"></iframe>\\n\\n---\\n\\n**Recursion**\\nWith functional languages, we can adapt some ideas from the above iterator approach! We can treat the two input strings as an abstract list/iterator type, and consider the cases for our two inputs:\\n\\n* If `s` is empty, we return the remaining length of `t`.\\n* If `t` is empty, we simply short-circuit and return 0.\\n* If the heads of `s` and `t` are the same, recurse with the tails of both lists.\\n* Otherwise, recurse on the tail of `s` and the given list `t`.\\n\\nThis gives us a pretty easy recursive definition to go by. Here are a few implementations of this idea:\\n\\n<iframe src=\"https://leetcode.com/playground/BiGP9WQF/shared\" frameBorder=\"0\" width=\"900\" height=\"300\"></iframe>",
                "solutionTags": [
                    "Two Pointers",
                    "Iterator"
                ],
                "code": "This is honestly a nice question because there are a lot of ways to approach this! These methods can be generalized to a diverse array of languages, which is something I\\'d like to highlight here.\\n\\n**Two Pointers**\\nThe two-pointer approach is fairly straightforward. In your language of choice, you can initialize a pointer that starts at the heads of `s` and `t`. Scan through the characters in `s`, incrementing the pointer in `t` whenever you encounter a match. The answer ends up being the number of unscanned characters in `t`, and you can simply calculate this using a bit of pointer (or index) math.\\n\\nThis approach can be taken up by a bunch of languages, particularly by the imperative languages we all know and love:\\n\\n<iframe src=\"https://leetcode.com/playground/c35k9pqD/shared\" frameBorder=\"0\" width=\"900\" height=\"300\"></iframe>\\n\\n---\\n\\n**Iterators**\\nWe can be less explicit about our iteration by using iterators! The procedure is still fairly similar to the above approach, except we\\'re not doing any manual index math anymore. (This is particularly useful for Rust, because the language treats their strings differently from just a vector of characters. Maybe that\\'s a good thing, but that means we *must* use iterators if we don\\'t want to explicitly allocate a separate array.)\\n\\n<iframe src=\"https://leetcode.com/playground/TGhu4WKh/shared\" frameBorder=\"0\" width=\"900\" height=\"300\"></iframe>\\n\\n---\\n\\n**Recursion**\\nWith functional languages, we can adapt some ideas from the above iterator approach! We can treat the two input strings as an abstract list/iterator type, and consider the cases for our two inputs:\\n\\n* If `s` is empty, we return the remaining length of `t`.\\n* If `t` is empty, we simply short-circuit and return 0.\\n* If the heads of `s` and `t` are the same, recurse with the tails of both lists.\\n* Otherwise, recurse on the tail of `s` and the given list `t`.\\n\\nThis gives us a pretty easy recursive definition to go by. Here are a few implementations of this idea:\\n\\n<iframe src=\"https://leetcode.com/playground/BiGP9WQF/shared\" frameBorder=\"0\" width=\"900\" height=\"300\"></iframe>",
                "codeTag": "Unknown"
            },
            {
                "id": 2854351,
                "title": "c-solution-two-pointer-easy-to-understand-faster-than-100",
                "content": "```\\nclass Solution {\\npublic:\\n    int appendCharacters(string s, string t) {\\n        long long t1=0,t2=0;\\n        long long n1=size(s),n2=size(t);\\n        while(t1<n1)\\n        {\\n            if(s[t1]==t[t2])   //if character of both strings match increment both pointers\\n            {\\n                t1++,t2++;\\n            }\\n            else if(s[t1]!=t[t2])   //if character doesn\\'t match then move string s pointer only\\n            {\\n                t1++;\\n            }\\n        }\\n        return (n2-t2);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Two Pointers",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int appendCharacters(string s, string t) {\\n        long long t1=0,t2=0;\\n        long long n1=size(s),n2=size(t);\\n        while(t1<n1)\\n        {\\n            if(s[t1]==t[t2])   //if character of both strings match increment both pointers\\n            {\\n                t1++,t2++;\\n            }\\n            else if(s[t1]!=t[t2])   //if character doesn\\'t match then move string s pointer only\\n            {\\n                t1++;\\n            }\\n        }\\n        return (n2-t2);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2854189,
                "title": "java-o-n-100",
                "content": "```\\nclass Solution {\\n    public int appendCharacters(String s, String t) {\\n        \\n        int idx = 0;\\n        \\n        for(int i = 0;i<s.length();)\\n        {\\n            while(idx<t.length() && i<s.length() && s.charAt(i) == t.charAt(idx))\\n            {\\n                idx++;\\n                i++;\\n            }\\n            i++;\\n        }\\n        \\n        return t.length() - idx;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int appendCharacters(String s, String t) {\\n        \\n        int idx = 0;\\n        \\n        for(int i = 0;i<s.length();)\\n        {\\n            while(idx<t.length() && i<s.length() && s.charAt(i) == t.charAt(idx))\\n            {\\n                idx++;\\n                i++;\\n            }\\n            i++;\\n        }\\n        \\n        return t.length() - idx;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2853046,
                "title": "easy-to-understand-two-pointer-5-line-code-c-o-n-solution",
                "content": "\\n\\n\\n\\n int appendCharacters(string s, string t) {\\n        int n1=t.size(),n=s.size(),i1=0;\\n        for(int i=0;i<n;i++)\\n            if(i1<n1 && s[i]==t[i1])    i1++;\\n        return n1-i1;   }",
                "solutionTags": [],
                "code": "\\n\\n\\n\\n int appendCharacters(string s, string t) {\\n        int n1=t.size(),n=s.size(),i1=0;\\n        for(int i=0;i<n;i++)\\n            if(i1<n1 && s[i]==t[i1])    i1++;\\n        return n1-i1;   }",
                "codeTag": "Unknown"
            },
            {
                "id": 2852567,
                "title": "clean-python-solution-two-pointers-faster-than-99",
                "content": "```\\nclass Solution:\\n    def appendCharacters(self, s: str, t: str) -> int:\\n        \\n        i = 0\\n        j = 0\\n        \\n        while i<len(s) and j< len(t):\\n            if s[i] == t[j]:\\n                i += 1\\n                j += 1\\n            else:\\n                i += 1\\n                \\n        return len(t) - j\\n```",
                "solutionTags": [
                    "Python",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution:\\n    def appendCharacters(self, s: str, t: str) -> int:\\n        \\n        i = 0\\n        j = 0\\n        \\n        while i<len(s) and j< len(t):\\n            if s[i] == t[j]:\\n                i += 1\\n                j += 1\\n            else:\\n                i += 1\\n                \\n        return len(t) - j\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2852178,
                "title": "c-easiest-beginners-approach-brute-force",
                "content": "# Intuition\\nOnly you should know about the subsequences just google learn if u don\\'t know it hardly takes 5 min.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int appendCharacters(string s, string t) {\\n        int s_size=s.size();\\n        int t_size=t.size();\\n        int i=0,j=0;\\n        while(i<s_size && j<t_size)\\n        {\\n            if(s[i]==t[j])\\n            {\\n                j++;\\n            }\\n            i++;\\n        }\\n        return t_size-j;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int appendCharacters(string s, string t) {\\n        int s_size=s.size();\\n        int t_size=t.size();\\n        int i=0,j=0;\\n        while(i<s_size && j<t_size)\\n        {\\n            if(s[i]==t[j])\\n            {\\n                j++;\\n            }\\n            i++;\\n        }\\n        return t_size-j;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2852144,
                "title": "c-beginners-friendly-easy-to-undersatnd-concise",
                "content": "// s= coaching\\n//t=  coding\\n\\nupdated t will be:- 00ding\\nthe number of character that are not 0 is 4 so the answer\\n```\\nclass Solution {\\npublic:\\n    int appendCharacters(string s, string t) {\\n        int ans=0,j=0;\\n        for(int i=0;i<s.length();i++)\\n        {\\n            if(t[j]==s[i])//if the t string contains same character as s mark it as 0\\n            {\\n                t[j]=\\'0\\';\\n                j++;\\n            }\\n        }\\n        for(auto &it:t)\\n        {\\n            if(it!=\\'0\\') ans++;// simple just calculate number of character  in string t that are not 0 \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Math",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int appendCharacters(string s, string t) {\\n        int ans=0,j=0;\\n        for(int i=0;i<s.length();i++)\\n        {\\n            if(t[j]==s[i])//if the t string contains same character as s mark it as 0\\n            {\\n                t[j]=\\'0\\';\\n                j++;\\n            }\\n        }\\n        for(auto &it:t)\\n        {\\n            if(it!=\\'0\\') ans++;// simple just calculate number of character  in string t that are not 0 \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2852036,
                "title": "c-vary-easy-10-line-code",
                "content": "class Solution {\\npublic:\\n    int appendCharacters(string s1, string t1) {\\n        \\n        int i,j;\\n        i=j=0;\\n        while(i<s1.size() && j<t1.size())\\n        {\\n            if(s1[i]==t1[j])\\n            {\\n                j++;\\n            }\\n            i++;\\n        }\\n        return (t1.size()-j);\\n        \\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    int appendCharacters(string s1, string t1) {\\n        \\n        int i,j;\\n        i=j=0;\\n        while(i<s1.size() && j<t1.size())\\n        {\\n            if(s1[i]==t1[j])\\n            {\\n                j++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2852011,
                "title": "java-easy-solution",
                "content": "```\\nclass Solution {\\n    public int appendCharacters(String s, String t) {\\n        char[] sArray = s.toCharArray();\\n        char[] tArray = t.toCharArray();\\n        int count = 0;\\n        \\n        for (int i = 0; i < sArray.length; i++) {\\n            if (t.length() == count) {\\n                return 0;\\n            }\\n            if (sArray[i] == tArray[count]) {\\n                count++;\\n            }\\n        }        \\n        return t.length()-count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public int appendCharacters(String s, String t) {\\n        char[] sArray = s.toCharArray();\\n        char[] tArray = t.toCharArray();\\n        int count = 0;\\n        \\n        for (int i = 0; i < sArray.length; i++) {\\n            if (t.length() == count) {\\n                return 0;\\n            }\\n            if (sArray[i] == tArray[count]) {\\n                count++;\\n            }\\n        }        \\n        return t.length()-count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4077884,
                "title": "java-simple-two-pointer-approach",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public int appendCharacters(String s, String t) {\\n        int i = 0, j = 0;\\n        while(i<s.length() && j < t.length()){\\n            if(s.charAt(i) == t.charAt(j)){\\n                i++;\\n                j++;\\n            }\\n            else{\\n                i++;\\n            }\\n        }\\n        if(j == t.length()){\\n            return 0;\\n        }\\n        return t.length() - j;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int appendCharacters(String s, String t) {\\n        int i = 0, j = 0;\\n        while(i<s.length() && j < t.length()){\\n            if(s.charAt(i) == t.charAt(j)){\\n                i++;\\n                j++;\\n            }\\n            else{\\n                i++;\\n            }\\n        }\\n        if(j == t.length()){\\n            return 0;\\n        }\\n        return t.length() - j;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3943073,
                "title": "coolest-way-of-doing-this-map-upper-bound",
                "content": "First u should Go through the Code it\\'s more fun in this solution if u figur out first by your self :)\\n\\n\\nIDEA: idea is vary simply u can\\'t utilize the same char again right so any any char in t u will try to use the lowest possible index available in s such that ur previous selected index in s should be less than this new selection \\nSo here we go...\\nintialise i=-1\\nstore everything in map <char - >vector of indexes>  // vector is by default sorted bcz i is increasing always.\\nadd n to each of char vector in map so that if anything runs out then we need to return then remaining length of t from here\\n\\nk=0;\\nstart searching for nxt i with keeping a check that new i should be more that previous i (hense upper_bound)\\n\\n```\\nclass Solution {\\npublic:\\n    int appendCharacters(string s, string t) \\n    {\\n        unordered_map<char, vector<int>> m;\\n        int n=s.size();\\n        \\n        for(int i=0; i<n; i++)\\n        {\\n            m[s[i]].push_back(i);\\n        }\\n        \\n        for(auto &i: m)\\n        {\\n            i.second.push_back(n);\\n        }\\n        \\n        int k=0;\\n        int i=-1;\\n        int tn=t.size();\\n        while(i<n && k<tn)\\n        {\\n            if(m.find(t[k])==m.end()) return tn-k;\\n            else\\n            {\\n                int idx= upper_bound(m[t[k]].begin(),m[t[k]].end(),i)-m[t[k]].begin();\\n                if(m[t[k]][idx]==n) return tn-k;\\n                else\\n                {\\n                    i=m[t[k]][idx];\\n                    k++;\\n                }\\n            }\\n        }\\n    \\n        return tn-k;\\n        \\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int appendCharacters(string s, string t) \\n    {\\n        unordered_map<char, vector<int>> m;\\n        int n=s.size();\\n        \\n        for(int i=0; i<n; i++)\\n        {\\n            m[s[i]].push_back(i);\\n        }\\n        \\n        for(auto &i: m)\\n        {\\n            i.second.push_back(n);\\n        }\\n        \\n        int k=0;\\n        int i=-1;\\n        int tn=t.size();\\n        while(i<n && k<tn)\\n        {\\n            if(m.find(t[k])==m.end()) return tn-k;\\n            else\\n            {\\n                int idx= upper_bound(m[t[k]].begin(),m[t[k]].end(),i)-m[t[k]].begin();\\n                if(m[t[k]][idx]==n) return tn-k;\\n                else\\n                {\\n                    i=m[t[k]][idx];\\n                    k++;\\n                }\\n            }\\n        }\\n    \\n        return tn-k;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3564855,
                "title": "solution-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int appendCharacters(string s, string t) \\n    {\\n        int ans=0,j=0;\\n        for(int i=0;i<s.length();i++)\\n        {\\n            if(t[j]==s[i])\\n            {\\n                t[j]=\\'0\\';\\n                j++;\\n            }\\n        }\\n        for(auto &it:t)\\n        {\\n            if(it!=\\'0\\') ans++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int appendCharacters(string s, string t) \\n    {\\n        int ans=0,j=0;\\n        for(int i=0;i<s.length();i++)\\n        {\\n            if(t[j]==s[i])\\n            {\\n                t[j]=\\'0\\';\\n                j++;\\n            }\\n        }\\n        for(auto &it:t)\\n        {\\n            if(it!=\\'0\\') ans++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3540692,
                "title": "easy-2-pointer-approach",
                "content": "\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\ndeclare 2 pointers, one for string s another for string t. Now we need to compare each character in those two strings. If both chars match increment both pointers otherwise increment only the pointer of string s. Now after the pointer reach end of string s come out of loop and return the difference between size of string t and its pointer\\n\\n# Complexity\\n- Time complexity:$$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int appendCharacters(string s, string t) \\n    {\\n        int a=0,b=0;\\n    while(a!=s.size())\\n    {\\n        if(s[a]==t[b])\\n        {\\n            a++;\\n            b++;\\n        }\\n        else\\n        {\\n            a++;\\n        }\\n    }\\n        return t.size()-b;\\n    //cout<<t.size()-b<<\"\\\\n\";\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int appendCharacters(string s, string t) \\n    {\\n        int a=0,b=0;\\n    while(a!=s.size())\\n    {\\n        if(s[a]==t[b])\\n        {\\n            a++;\\n            b++;\\n        }\\n        else\\n        {\\n            a++;\\n        }\\n    }\\n        return t.size()-b;\\n    //cout<<t.size()-b<<\"\\\\n\";\\n        \\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3523329,
                "title": "easy-solution-c-two-poiners",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int appendCharacters(string s, string t) {\\n        int p1 = 0, p2 = 0;\\n        while(p1<s.size() && p2<t.size()){\\n            if(s[p1]==t[p2]){\\n                p2++;\\n            }\\n            p1++;\\n        }\\n        int ans =t.size()-p2;\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int appendCharacters(string s, string t) {\\n        int p1 = 0, p2 = 0;\\n        while(p1<s.size() && p2<t.size()){\\n            if(s[p1]==t[p2]){\\n                p2++;\\n            }\\n            p1++;\\n        }\\n        int ans =t.size()-p2;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3306820,
                "title": "accepted-swift",
                "content": "```\\nclass Solution {\\n    func appendCharacters(_ s: String, _ t: String) -> Int {\\n        \\n        var si = s.startIndex\\n        var ti = t.startIndex\\n\\n        while si != s.endIndex, ti != t.endIndex {\\n            if s[si] == t[ti] {\\n                ti = t.index(after: ti)\\n            }\\n            si = s.index(after: si)\\n        }\\n\\n        return t.distance(from: ti, to: t.endIndex)\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func appendCharacters(_ s: String, _ t: String) -> Int {\\n        \\n        var si = s.startIndex\\n        var ti = t.startIndex\\n\\n        while si != s.endIndex, ti != t.endIndex {\\n            if s[si] == t[ti] {\\n                ti = t.index(after: ti)\\n            }\\n            si = s.index(after: si)\\n        }\\n\\n        return t.distance(from: ti, to: t.endIndex)\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3279682,
                "title": "c-solution-o-n-time-o-1-space-easy-solution-with-complete-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe have to see what prefix of string t is also a subsequence of string s, then the remaining part of string t will be our result.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe will consider two index i, j belonging to string s, t. Initially both the index point to 0. As we iterate through string s, if s[i] == t[j] we increase the value of j as we have found this much prefix in s, else we just increase i.\\nAt end our result is t.length() - j because that much part is still to be discovered \\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int appendCharacters(string s, string t) {\\n        //find the length of both strings\\n        int n = s.length(), m = t.length();\\n        //Initialise both index with 0\\n        int i =0, j = 0;\\n        while(i<n && j < m){\\n            //If both characters are same we increment j \\n            if(s[i] == t[j]) {\\n                i++;\\n                j++;\\n            }else i++;\\n        }\\n        //the remaining part of t needed to be append at back\\n        return m - j;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int appendCharacters(string s, string t) {\\n        //find the length of both strings\\n        int n = s.length(), m = t.length();\\n        //Initialise both index with 0\\n        int i =0, j = 0;\\n        while(i<n && j < m){\\n            //If both characters are same we increment j \\n            if(s[i] == t[j]) {\\n                i++;\\n                j++;\\n            }else i++;\\n        }\\n        //the remaining part of t needed to be append at back\\n        return m - j;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3078040,
                "title": "javascript-simple-88-faster-95-less-memory",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe need to look for each letter of \"t\" in \"s\" as they occur in order\\nWe cannot check for any other letters until the next/first one from \"t\" is found\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- Get our initial expected letter which is the first one from \"t\"\\n- Look at \"s\" until we find the first letter. If we find it, increase a pointer that points to the next letter in \"t\" that we need to find\\n- Continue searching through \"s\"\\n- If our pointer increses past the size of \"t\" then we found all letters and can return 0 early\\n- If we did not find all letters in \"s\" then the answer for how many we would need to append is the length of \"t\" minus the current pointer of \"t\" that we left off on\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nThis has a Time Complexity of $$O(n)$$ based on the input size of \"s\" as we need to iterate over all of \"s\" no matter what\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nThis has a constant Space Complexity $$O(1)$$ as we are only keeping track of variables and no additional data structures\\n\\n# Code\\n```\\n/**\\n * @param {string} s\\n * @param {string} t\\n * @return {number}\\n */\\nvar appendCharacters = function(s, t) {\\n    \\n    const tSize = t.length;\\n    let tPointer = 0;\\n    let expectedLetter = t[0];\\n\\n    for (let i = 0; i < s.length; i++) {\\n        let currentLetter = s[i];\\n\\n        if (currentLetter == expectedLetter) {\\n            tPointer++;\\n            if (tPointer > tSize)\\n                return 0;\\n            expectedLetter = t[tPointer];\\n        }\\n    }\\n\\n    return tSize - tPointer;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string} s\\n * @param {string} t\\n * @return {number}\\n */\\nvar appendCharacters = function(s, t) {\\n    \\n    const tSize = t.length;\\n    let tPointer = 0;\\n    let expectedLetter = t[0];\\n\\n    for (let i = 0; i < s.length; i++) {\\n        let currentLetter = s[i];\\n\\n        if (currentLetter == expectedLetter) {\\n            tPointer++;\\n            if (tPointer > tSize)\\n                return 0;\\n            expectedLetter = t[tPointer];\\n        }\\n    }\\n\\n    return tSize - tPointer;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3035604,
                "title": "simple-two-pointer-approach",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int appendCharacters(string s, string t) {\\n        int n=s.length();\\n        int m=t.length();\\n        int i=0,j=0;\\n        while(i<n && j<m){\\n            if(s[i]==t[j]){\\n                i++;\\n                j++;\\n            }else{\\n                i++;\\n            }\\n        }\\n        if(j==m){\\n            return 0;\\n        }\\n        return m-j;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int appendCharacters(string s, string t) {\\n        int n=s.length();\\n        int m=t.length();\\n        int i=0,j=0;\\n        while(i<n && j<m){\\n            if(s[i]==t[j]){\\n                i++;\\n                j++;\\n            }else{\\n                i++;\\n            }\\n        }\\n        if(j==m){\\n            return 0;\\n        }\\n        return m-j;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2989747,
                "title": "easy-to-understand-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int appendCharacters(string s, string t) {\\n        int k = 0, n = s.length(),x=0;\\n        for(auto &i: t){\\n            while(k<n && s[k] != i){\\n                k++;\\n            }\\n            if(k==n)break;\\n            if(i == s[k]){\\n                k++;\\n                x++;\\n            }\\n        }\\n        return t.length()-x;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int appendCharacters(string s, string t) {\\n        int k = 0, n = s.length(),x=0;\\n        for(auto &i: t){\\n            while(k<n && s[k] != i){\\n                k++;\\n            }\\n            if(k==n)break;\\n            if(i == s[k]){\\n                k++;\\n                x++;\\n            }\\n        }\\n        return t.length()-x;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2889197,
                "title": "java-clean-code-two-pointer",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int appendCharacters(String s, String t) {\\n        int i=0;\\n        int j=0;\\n        int c=0;\\n        while(i<s.length()&&j<t.length())\\n        {\\n            if(s.charAt(i)==t.charAt(j))\\n            {\\n                i++;\\n                j++;\\n            }else{\\n                i++;\\n            }\\n        }\\n        return t.length()-j;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int appendCharacters(String s, String t) {\\n        int i=0;\\n        int j=0;\\n        int c=0;\\n        while(i<s.length()&&j<t.length())\\n        {\\n            if(s.charAt(i)==t.charAt(j))\\n            {\\n                i++;\\n                j++;\\n            }else{\\n                i++;\\n            }\\n        }\\n        return t.length()-j;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2860953,
                "title": "golang-6-ms-5-5-mb",
                "content": "```\\nfunc appendCharacters(s string, t string) int {\\n\\tj := 0\\n\\tfor i := 0; i < len(s); i++ {\\n\\t\\tif s[i] == t[j] {\\n\\t\\t\\tj++\\n\\t\\t\\tif j == len(t) {\\n\\t\\t\\t\\treturn 0\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn len(t) - j\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc appendCharacters(s string, t string) int {\\n\\tj := 0\\n\\tfor i := 0; i < len(s); i++ {\\n\\t\\tif s[i] == t[j] {\\n\\t\\t\\tj++\\n\\t\\t\\tif j == len(t) {\\n\\t\\t\\t\\treturn 0\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn len(t) - j\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2854242,
                "title": "two-pointer-approach-detailed-explanation-with-different-test-cases-commented-code",
                "content": "**Intuition**: Let\\'s understand with an example string s = ```coaching```, string t = ```coding```. Now for string s to be a subsequence of string t, string s must contain all the characters in the same order(Definition of subsequence).\\n**Definition of Subsequence**: A subsequence is a string that can be derived from another string by deleting some or no characters without changing the order of the remaining characters.\\n```\\n    int appendCharacters(string s, string t) {\\n        int n = s.length(), m = t.length();\\n        int ans = m; // In the worst case, string s can be empty and we have to append full string t at the end of string s\\n        int i = 0, j = 0; // We start from 0th index\\n        while(i < n && j < m){ \\n            if(s[i] == t[j]){  // If the character are same means we have got the subsequence till t[j] and we don\\'t have to append it to the end\\n                i++;\\n                j++;\\n                if(ans == 0) return 0; // Base case handling inputs like -> s = \"abcde\", t = \"a\". (Do dry run if not understood)\\n                ans--; // Since we don\\'t have to append character till t[j], the characters till t[j] won\\'t be counted in the ans (Remember we have initialized ans = t.length()\\n            }else{ // The characters are not equal\\n                i++; // Since we want the character to be present in the given sequence we will find the character at t[j] in the string s. Sample input for this case: s = \"z\", t = \"abcde\"\\n            }\\n        }\\n        return ans; // Done!\\n    }\\n```\\n\\n**Time complexity:** ```O(min(n,m)) where n, m = lengths of string```\\n**Space complexity:** ```O(1)```\\n**Thank You**",
                "solutionTags": [
                    "Array",
                    "Two Pointers"
                ],
                "code": "```coaching```\n```coding```\n```\\n    int appendCharacters(string s, string t) {\\n        int n = s.length(), m = t.length();\\n        int ans = m; // In the worst case, string s can be empty and we have to append full string t at the end of string s\\n        int i = 0, j = 0; // We start from 0th index\\n        while(i < n && j < m){ \\n            if(s[i] == t[j]){  // If the character are same means we have got the subsequence till t[j] and we don\\'t have to append it to the end\\n                i++;\\n                j++;\\n                if(ans == 0) return 0; // Base case handling inputs like -> s = \"abcde\", t = \"a\". (Do dry run if not understood)\\n                ans--; // Since we don\\'t have to append character till t[j], the characters till t[j] won\\'t be counted in the ans (Remember we have initialized ans = t.length()\\n            }else{ // The characters are not equal\\n                i++; // Since we want the character to be present in the given sequence we will find the character at t[j] in the string s. Sample input for this case: s = \"z\", t = \"abcde\"\\n            }\\n        }\\n        return ans; // Done!\\n    }\\n```\n```O(min(n,m)) where n, m = lengths of string```\n```O(1)```",
                "codeTag": "Unknown"
            },
            {
                "id": 2854038,
                "title": "python-two-pointer-o-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\ntwo pointer\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution(object):\\n    def appendCharacters(self, s, t):\\n        \"\"\"\\n        :type s: str\\n        :type t: str\\n        :rtype: int\\n        \"\"\"\\n        i = 0\\n        j = 0\\n        m, n = len(s), len(t)\\n\\n        while i < m and j < n:\\n            if s[i] == t[j]:\\n                i+=1\\n                j+=1\\n            else:\\n                i+=1\\n        return n - j\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def appendCharacters(self, s, t):\\n        \"\"\"\\n        :type s: str\\n        :type t: str\\n        :rtype: int\\n        \"\"\"\\n        i = 0\\n        j = 0\\n        m, n = len(s), len(t)\\n\\n        while i < m and j < n:\\n            if s[i] == t[j]:\\n                i+=1\\n                j+=1\\n            else:\\n                i+=1\\n        return n - j\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2853951,
                "title": "c-o-n-easy-to-understand-beginner-friendly",
                "content": "\\nApproach:- Checking when we get the first mismatch in the strings, from that index to the end would be the length of the string that should be appended\\nTime complexity:- O(N)\\n```\\nclass Solution {\\npublic:\\n    int appendCharacters(string s, string t) {\\n        //Calculating the length of both the strings\\n        int n=s.length();\\n        int m=t.length();\\n        int i=0,j=0;\\n        //Approach:- Checking when we get the first mismatch\\n        //From that index to the end would be the length of the string\\n        //that should be appended\\n        while(i<n and j<m){\\n            if(s[i]==t[j]){\\n                j++;\\n            }\\n            i++;\\n        }\\n        return j==m?0:m-j; \\n    }\\n};\\n```\\n***Pls upvote if you find this useful :)***\\n",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int appendCharacters(string s, string t) {\\n        //Calculating the length of both the strings\\n        int n=s.length();\\n        int m=t.length();\\n        int i=0,j=0;\\n        //Approach:- Checking when we get the first mismatch\\n        //From that index to the end would be the length of the string\\n        //that should be appended\\n        while(i<n and j<m){\\n            if(s[i]==t[j]){\\n                j++;\\n            }\\n            i++;\\n        }\\n        return j==m?0:m-j; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2853904,
                "title": "two-pointers",
                "content": "```\\nclass Solution {\\npublic:\\n    int appendCharacters(string s, string t) {\\n        int i=0;\\n        int j=0;\\n        while(i<s.length()){\\n            if(t[j]==s[i])  j++;\\n             i++;\\n        }\\n        return t.length()-j;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int appendCharacters(string s, string t) {\\n        int i=0;\\n        int j=0;\\n        while(i<s.length()){\\n            if(t[j]==s[i])  j++;\\n             i++;\\n        }\\n        return t.length()-j;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2853680,
                "title": "simple-c-try-with-lcs",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    int appendCharacters(string s, string t) {\\n        int j=0;\\n        int n=s.size();\\n        for(int i=0;i<n;i++){\\n            if(s[i]==t[j]){\\n                j++;\\n            }\\n        }\\n        return t.size()-j;\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    \\n    int appendCharacters(string s, string t) {\\n        int j=0;\\n        int n=s.size();\\n        for(int i=0;i<n;i++){\\n            if(s[i]==t[j]){\\n                j++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2853031,
                "title": "python3",
                "content": "```\\nclass Solution:\\n    def appendCharacters(self, s: str, t: str) -> int:\\n        a = iter(s)\\n        for i,j in  enumerate(t):\\n            if j not in a:\\n                return len(t)-i\\n        return 0\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def appendCharacters(self, s: str, t: str) -> int:\\n        a = iter(s)\\n        for i,j in  enumerate(t):\\n            if j not in a:\\n                return len(t)-i\\n        return 0\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2852745,
                "title": "rust-2-pointers-o-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\ncheck how long of leading t is subsequence of s.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nimpl Solution {\\n    pub fn append_characters(s: String, t: String) -> i32 {\\n        let mut ans = 0;\\n        let mut i = 0;\\n        let mut j = 0;\\n        let sa: Vec<char> = s.chars().collect();\\n        let ta: Vec<char> = t.chars().collect();\\n        let n1 = s.len();\\n        let n2 = t.len();\\n        \\n        while i < n1 && j < n2 {\\n            if sa[i] == ta[j] {\\n                i += 1;\\n                j += 1;\\n            } else {\\n                i += 1;\\n            }\\n        }\\n        (n2 - j) as i32\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn append_characters(s: String, t: String) -> i32 {\\n        let mut ans = 0;\\n        let mut i = 0;\\n        let mut j = 0;\\n        let sa: Vec<char> = s.chars().collect();\\n        let ta: Vec<char> = t.chars().collect();\\n        let n1 = s.len();\\n        let n2 = t.len();\\n        \\n        while i < n1 && j < n2 {\\n            if sa[i] == ta[j] {\\n                i += 1;\\n                j += 1;\\n            } else {\\n                i += 1;\\n            }\\n        }\\n        (n2 - j) as i32\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2852459,
                "title": "2486-append-characters-to-string-to-make-subsequence-java",
                "content": "```\\nclass Solution {\\n    public int appendCharacters(String s, String t) {\\n        \\n        int count = 0;\\n        int n = s.length();\\n        int m = t.length();\\n\\n        int j = 0;\\n        for(int i = 0 ; i < n && j < m ; i++)\\n        {\\n            if(s.charAt(i) == t.charAt(j))\\n            {\\n                j++;\\n            }\\n        }\\n        return (m-j);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int appendCharacters(String s, String t) {\\n        \\n        int count = 0;\\n        int n = s.length();\\n        int m = t.length();\\n\\n        int j = 0;\\n        for(int i = 0 ; i < n && j < m ; i++)\\n        {\\n            if(s.charAt(i) == t.charAt(j))\\n            {\\n                j++;\\n            }\\n        }\\n        return (m-j);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2852438,
                "title": "easy-c-solution-two-pointers-strings",
                "content": "Here is my C++ Solution:\\n```\\nclass Solution {\\npublic:\\n    int appendCharacters(string s, string t) {\\n        int j=0; int n= s.size();\\n        int ans=t.size();\\n        for (int i=0; i<n; i++){\\n            if (j== t.size())break;\\n            if (s[i]==t[j]){\\n                ans--; j++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Two Pointers",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int appendCharacters(string s, string t) {\\n        int j=0; int n= s.size();\\n        int ans=t.size();\\n        for (int i=0; i<n; i++){\\n            if (j== t.size())break;\\n            if (s[i]==t[j]){\\n                ans--; j++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2852364,
                "title": "java-two-pointers-easy",
                "content": "### **Please Upvote** :D\\n```\\nclass Solution {\\n    public int appendCharacters(String s, String t) {        \\n        int i = 0, j = 0;\\n        \\n        while (i < s.length() && j < t.length()) {\\n            if (s.charAt(i) == t.charAt(j)) {\\n                j++;\\n            }\\n            \\n            i++;\\n        }\\n        \\n        return t.length() - j;\\n    }\\n}\\n\\n// TC: O(n), SC: O(1)\\n```",
                "solutionTags": [
                    "Java",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\n    public int appendCharacters(String s, String t) {        \\n        int i = 0, j = 0;\\n        \\n        while (i < s.length() && j < t.length()) {\\n            if (s.charAt(i) == t.charAt(j)) {\\n                j++;\\n            }\\n            \\n            i++;\\n        }\\n        \\n        return t.length() - j;\\n    }\\n}\\n\\n// TC: O(n), SC: O(1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2852352,
                "title": "java-easy-and-simple-solution-runtime-o-n-space-o-1",
                "content": "```\\nclass Solution {\\n    public int appendCharacters(String s, String t) {\\n        int sLen = s.length();\\n        int tLen = t.length();\\n\\n        int res = 0;\\n        int tIndex = 0;\\n\\n        for (int i = 0; i < sLen; i++) \\n            if (tIndex<tLen && s.charAt(i) == t.charAt(tIndex)) \\n                tIndex++;\\n\\n        res+=tLen-tIndex;\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int appendCharacters(String s, String t) {\\n        int sLen = s.length();\\n        int tLen = t.length();\\n\\n        int res = 0;\\n        int tIndex = 0;\\n\\n        for (int i = 0; i < sLen; i++) \\n            if (tIndex<tLen && s.charAt(i) == t.charAt(tIndex)) \\n                tIndex++;\\n\\n        res+=tLen-tIndex;\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2852274,
                "title": "python-two-pointer-explained-o-n",
                "content": "# Approach\\n- we will check each character of `t` one by one in `s`.\\n- If `t[i]==s[i]` then count it, and stop when the character is not present in `s`.\\n- return number of remaing characters in `t`.\\n\\n# Complexity\\n- Time complexity: O(n)\\n\\n- Space complexity: O(1)\\n\\n# Code\\n```\\nclass Solution:\\n    def appendCharacters(self, s: str, t: str) -> int:\\n        count = 0\\n        i=j=0\\n        \\n        while i<len(s) and j<len(t):\\n            if s[i]==t[j]:\\n                count += 1\\n                i += 1\\n                j += 1\\n            else:\\n                i += 1\\n                \\n        if j==len(t):\\n            return 0\\n        elif i==len(s):\\n            return len(t)-count\\n        \\n```\\n--------------------\\nUpvote the post if you find it helpful.\\nHappy coding.",
                "solutionTags": [
                    "Python3",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution:\\n    def appendCharacters(self, s: str, t: str) -> int:\\n        count = 0\\n        i=j=0\\n        \\n        while i<len(s) and j<len(t):\\n            if s[i]==t[j]:\\n                count += 1\\n                i += 1\\n                j += 1\\n            else:\\n                i += 1\\n                \\n        if j==len(t):\\n            return 0\\n        elif i==len(s):\\n            return len(t)-count\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2852143,
                "title": "c-code-faster-than-100",
                "content": "***If you find this helpful, Please Upvote \\uD83D\\uDD3C\\nThank You !***\\n\\n```\\nclass Solution {\\npublic:\\n    int appendCharacters(string s, string t) {\\n        \\n        int len1 = s.length();\\n        int len2 = t.length();\\n        \\n        int i=0;\\n        int j=0;\\n        \\n        while(i<len1 && j<len2) {\\n            \\n            if(s[i] == t[j]) {\\n                i++;\\n                j++;\\n            }\\n            else {\\n                i++;\\n            }\\n            \\n        }\\n        \\n        if(j==len2) return 0;\\n        \\n        return len2-j;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int appendCharacters(string s, string t) {\\n        \\n        int len1 = s.length();\\n        int len2 = t.length();\\n        \\n        int i=0;\\n        int j=0;\\n        \\n        while(i<len1 && j<len2) {\\n            \\n            if(s[i] == t[j]) {\\n                i++;\\n                j++;\\n            }\\n            else {\\n                i++;\\n            }\\n            \\n        }\\n        \\n        if(j==len2) return 0;\\n        \\n        return len2-j;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2852126,
                "title": "two-pointers-easy-java-solution",
                "content": "```\\n//         usint two pointer on two of the strings and if characters matches increase both and if not then just increase pointer of s string \\n        int i=0,j=0;\\n        while(i<s.length() && j<t.length()){\\n            if(s.charAt(i)==t.charAt(j)){\\n                i++;\\n                j++;\\n            }\\n            else i++;\\n        }\\n        return t.length()-j;",
                "solutionTags": [
                    "Java",
                    "Two Pointers"
                ],
                "code": "```\\n//         usint two pointer on two of the strings and if characters matches increase both and if not then just increase pointer of s string \\n        int i=0,j=0;\\n        while(i<s.length() && j<t.length()){\\n            if(s.charAt(i)==t.charAt(j)){\\n                i++;\\n                j++;\\n            }\\n            else i++;\\n        }\\n        return t.length()-j;",
                "codeTag": "Unknown"
            },
            {
                "id": 2852098,
                "title": "c-easy-and-clean-approach",
                "content": "Here is my c++ code for this problem.\\n\\'\\'\\'\\n\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tint appendCharacters(string s, string t) {\\n\\t\\t\\tint j=0;\\n\\t\\t\\tfor(int i=0; i<s.size(); i++){\\n\\t\\t\\t\\tif(s[i]==t[j]){\\n\\t\\t\\t\\t\\tj++;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\t//cout<<j<<endl;\\n\\t\\t\\treturn t.size()-j;\\n\\t\\t}\\n\\t};\\n\\'\\'\\'",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tint appendCharacters(string s, string t) {\\n\\t\\t\\tint j=0;\\n\\t\\t\\tfor(int i=0; i<s.size(); i++){\\n\\t\\t\\t\\tif(s[i]==t[j]){\\n\\t\\t\\t\\t\\tj++;\\n\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2852093,
                "title": "javascript-tc-o-min-slen-tlen-sc-o-1",
                "content": "```\\n/**\\n * @param {string} s\\n * @param {string} t\\n * @return {number}\\n */\\nvar appendCharacters = function(s, t) {\\n    let i = 0, j = 0;\\n    \\n    while (i < s.length && j < t.length) {\\n        if (s[i] === t[j]) {\\n            j++;\\n        }\\n        i++;\\n    }\\n    \\n    return t.length - j;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string} s\\n * @param {string} t\\n * @return {number}\\n */\\nvar appendCharacters = function(s, t) {\\n    let i = 0, j = 0;\\n    \\n    while (i < s.length && j < t.length) {\\n        if (s[i] === t[j]) {\\n            j++;\\n        }\\n        i++;\\n    }\\n    \\n    return t.length - j;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2852061,
                "title": "c-java-python3-pointer",
                "content": "Please pull this [commit](https://github.com/gaosanyong/leetcode/commit/e728a9f475e5742bea7cf67ac2d1a98ab99fb206) for solutions of weekly 321. \\n\\n**Intuition**\\nHere, we can simply check if the characters of t are sequentially present in s. If not, the length of remaining characters in t is the answer. \\n**Implementation\\n**C++**\\n```\\nclass Solution {\\npublic:\\n    int appendCharacters(string s, string t) {\\n        int i = 0; \\n        for (auto& ch : s) \\n            if (i < t.size() && ch == t[i]) ++i; \\n        return t.size() - i; \\n    }\\n};\\n```\\n**Java**\\n```\\nclass Solution {\\n    public int appendCharacters(String s, String t) {\\n        int i = 0; \\n        for (char ch : s.toCharArray()) \\n            if (i < t.length() && ch == t.charAt(i)) ++i; \\n        return t.length()-i; \\n    }\\n}\\n```\\n**Python3**\\n```\\t\\t\\nclass Solution:\\n    def appendCharacters(self, s: str, t: str) -> int:\\n        it = iter(s)\\n        return next((len(t)-i for i, ch in enumerate(t) if ch not in it), 0)\\n```\\t\\t\\n**Complexity**\\nTime O(N)\\nSpace O(1)",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int appendCharacters(string s, string t) {\\n        int i = 0; \\n        for (auto& ch : s) \\n            if (i < t.size() && ch == t[i]) ++i; \\n        return t.size() - i; \\n    }\\n};\\n```\n```\\nclass Solution {\\n    public int appendCharacters(String s, String t) {\\n        int i = 0; \\n        for (char ch : s.toCharArray()) \\n            if (i < t.length() && ch == t.charAt(i)) ++i; \\n        return t.length()-i; \\n    }\\n}\\n```\n```\\t\\t\\nclass Solution:\\n    def appendCharacters(self, s: str, t: str) -> int:\\n        it = iter(s)\\n        return next((len(t)-i for i, ch in enumerate(t) if ch not in it), 0)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2852053,
                "title": "java-o-n-easy",
                "content": "```\\nclass Solution {\\n    public int appendCharacters(String s, String t) {\\n        int i = 0;\\n        int j = 0;\\n        while(i<s.length()&& j<t.length())\\n        {\\n        \\tif(s.charAt(i)==t.charAt(j))\\n        \\t{\\n        \\t\\ti++;\\n        \\t\\tj++;\\n        \\t}\\n        \\telse {\\n        \\t\\ti++;\\n        \\t}\\n        }\\n        if(j == t.length())\\n        \\treturn 0;\\n        return t.length()-j;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public int appendCharacters(String s, String t) {\\n        int i = 0;\\n        int j = 0;\\n        while(i<s.length()&& j<t.length())\\n        {\\n        \\tif(s.charAt(i)==t.charAt(j))\\n        \\t{\\n        \\t\\ti++;\\n        \\t\\tj++;\\n        \\t}",
                "codeTag": "Java"
            },
            {
                "id": 2852045,
                "title": "c-two-pointers",
                "content": "```\\nclass Solution {\\npublic:\\n    int appendCharacters(string s, string t) {\\n        int i=0,j=0;\\n        while(i<s.size() && j<t.size()){\\n            // compare s[i] and t[j] if equal then increment j \\n            if(s[i]==t[j]){\\n                j++;\\n            }\\n            i++;\\n        }\\n        return t.size()-j;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int appendCharacters(string s, string t) {\\n        int i=0,j=0;\\n        while(i<s.size() && j<t.size()){\\n            // compare s[i] and t[j] if equal then increment j \\n            if(s[i]==t[j]){\\n                j++;\\n            }\\n            i++;\\n        }\\n        return t.size()-j;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2852038,
                "title": "python-clean-code-o-n-time-and-o-1-space",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n\\n- Space complexity: $$O(1)$$\\n\\n# Code\\n```\\nclass Solution:\\n    def appendCharacters(self, s: str, t: str) -> int:\\n        count = 0\\n        j = 0\\n        for i in s:\\n            if j == len(t):\\n                return 0\\n            if i == t[j]:\\n                j += 1\\n                count += 1\\n        return len(t) - count\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def appendCharacters(self, s: str, t: str) -> int:\\n        count = 0\\n        j = 0\\n        for i in s:\\n            if j == len(t):\\n                return 0\\n            if i == t[j]:\\n                j += 1\\n                count += 1\\n        return len(t) - count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2852033,
                "title": "simple-o-n-java-solution",
                "content": "\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public int appendCharacters(String s, String t) {\\n        // tracking t with j\\n        int j=0;\\n        \\n        //tracking s with i\\n        for(int i=0;i<s.length();i++){\\n            \\n            if(t.charAt(j)==s.charAt(i)) j++;\\n            \\n            if(j==t.length()) return 0;\\n        }\\n        return t.length()-j;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int appendCharacters(String s, String t) {\\n        // tracking t with j\\n        int j=0;\\n        \\n        //tracking s with i\\n        for(int i=0;i<s.length();i++){\\n            \\n            if(t.charAt(j)==s.charAt(i)) j++;\\n            \\n            if(j==t.length()) return 0;\\n        }\\n        return t.length()-j;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2852004,
                "title": "python-two-pointers-solution",
                "content": "# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$(O(min(length(s), length(t))))$$\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$(O(1))$$\\n\\n# Code\\n```\\nclass Solution:\\n    def appendCharacters(self, s: str, t: str) -> int:\\n        i = j = 0\\n        \\n        while i<len(s) and j<len(t):\\n            if s[i] == t[j]:\\n                i+=1\\n                j+=1\\n            else:\\n                i+=1\\n                    \\n        return len(t) - j\\n```",
                "solutionTags": [
                    "Python3",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution:\\n    def appendCharacters(self, s: str, t: str) -> int:\\n        i = j = 0\\n        \\n        while i<len(s) and j<len(t):\\n            if s[i] == t[j]:\\n                i+=1\\n                j+=1\\n            else:\\n                i+=1\\n                    \\n        return len(t) - j\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2851980,
                "title": "two-pointer-o-n",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int appendCharacters(string s, string t) {\\n        int j = 0;\\n        for(int i = 0;i<s.size();i++){\\n            if(s[i] == t[j]){\\n                ++j;\\n            }\\n        };\\n        return t.size()-j;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int appendCharacters(string s, string t) {\\n        int j = 0;\\n        for(int i = 0;i<s.size();i++){\\n            if(s[i] == t[j]){\\n                ++j;\\n            }\\n        };\\n        return t.size()-j;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2851973,
                "title": "easy-2-pointers-o-n-time-o-1-space",
                "content": "```java\\nclass Solution {\\n    public int appendCharacters(String s, String t) {\\n        int p1 = 0;\\n\\t\\tint p2 = 0;\\n\\t\\t\\n\\t\\twhile (p1 < s.length() && p2 < t.length()) {\\n\\t\\t\\tif (s.charAt(p1) == t.charAt(p2)) {\\n\\t\\t\\t\\tp1++;\\n\\t\\t\\t\\tp2++;\\n\\t\\t\\t}\\n\\t\\t\\telse {\\n\\t\\t\\t\\tp1++;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\t\\n\\t\\treturn t.length()-p2;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```java\\nclass Solution {\\n    public int appendCharacters(String s, String t) {\\n        int p1 = 0;\\n\\t\\tint p2 = 0;\\n\\t\\t\\n\\t\\twhile (p1 < s.length() && p2 < t.length()) {\\n\\t\\t\\tif (s.charAt(p1) == t.charAt(p2)) {\\n\\t\\t\\t\\tp1++;\\n\\t\\t\\t\\tp2++;\\n\\t\\t\\t}\\n\\t\\t\\telse {\\n\\t\\t\\t\\tp1++;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\t\\n\\t\\treturn t.length()-p2;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2851934,
                "title": "python3-greedy-five-lines",
                "content": "**Weekly Contest 321 Submission**\\n\\n**Greedy Five Lines**\\n\\n**Algorithm**\\n1. Find the largest *subsequence* initial fragment of `t` from `s`. This can be done greedily by consistently popping the front character of `t` when iterating `s` if `c` == `t[0]`.\\n2. If all characters of `t` are popped during the iteration of `s` then `t` is already a *subsequence* of `s` (no needed additions - return 0).\\n3. The left over characters of `t` (those not in the largest *subsequence* initial fragment) must be appended to `s` (return the length of the resulting `t` after iterating `s`).\\n\\n**Code**\\n```Python3 []\\nclass Solution:\\n    def appendCharacters(self, s: str, t: str) -> int:\\n        #Reversed in order to pop the first character each time\\n        t = list(t)[::-1]\\n        \\n        for c in s:\\n            #t is already a subsequence\\n            if not t: return 0\\n            #pop t if c == \"first character\" of t \\n            if c == t[-1]: t.pop()\\n                \\n        #Return the left over t length\\n        return len(t)           \\n```\\n",
                "solutionTags": [
                    "Python3",
                    "Greedy"
                ],
                "code": "```Python3 []\\nclass Solution:\\n    def appendCharacters(self, s: str, t: str) -> int:\\n        #Reversed in order to pop the first character each time\\n        t = list(t)[::-1]\\n        \\n        for c in s:\\n            #t is already a subsequence\\n            if not t: return 0\\n            #pop t if c == \"first character\" of t \\n            if c == t[-1]: t.pop()\\n                \\n        #Return the left over t length\\n        return len(t)           \\n```",
                "codeTag": "Java"
            },
            {
                "id": 4085485,
                "title": "very-easy-best-c-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int appendCharacters(string s, string t) {\\n        int i=0, j=0,cnt=0;\\n            while(i<s.size()&&j<t.size()){\\n                if(s[i]==t[j]){\\n                    \\n                    j++;\\n                    cnt++;\\n                }\\n                    i++;  \\n            }\\n        return t.size()-cnt;\\n    }\\n};        \\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int appendCharacters(string s, string t) {\\n        int i=0, j=0,cnt=0;\\n            while(i<s.size()&&j<t.size()){\\n                if(s[i]==t[j]){\\n                    \\n                    j++;\\n                    cnt++;\\n                }\\n                    i++;  \\n            }\\n        return t.size()-cnt;\\n    }\\n};        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 4081418,
                "title": "simple-solution-using-two-pointers-rust-tm",
                "content": "# Code\\n```\\nimpl Solution {\\n    pub fn append_characters(s: String, t: String) -> i32 {\\n      let mut s_idx: usize = 0;\\n      let mut t_idx: usize = 0;\\n\\n      while s_idx < s.len() && t_idx < t.len() {\\n        if s.as_bytes()[s_idx] == t.as_bytes()[t_idx] {\\n          t_idx += 1; \\n        }\\n        \\n        s_idx += 1;\\n      }\\n      // println!(\"s_idx:{}\\\\nt_idx:{}\", s_idx, t_idx);\\n\\n      (t.len() - t_idx) as i32\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust",
                    "Two Pointers",
                    "String",
                    "Greedy"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn append_characters(s: String, t: String) -> i32 {\\n      let mut s_idx: usize = 0;\\n      let mut t_idx: usize = 0;\\n\\n      while s_idx < s.len() && t_idx < t.len() {\\n        if s.as_bytes()[s_idx] == t.as_bytes()[t_idx] {\\n          t_idx += 1; \\n        }\\n        \\n        s_idx += 1;\\n      }\\n      // println!(\"s_idx:{}\\\\nt_idx:{}\", s_idx, t_idx);\\n\\n      (t.len() - t_idx) as i32\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4081301,
                "title": "very-easy-2-pointers-method",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int appendCharacters(string s, string t) {\\n        int lent=t.size();int lens=s.size();\\n        int i=0;int j=0;\\n        while(i!=lent && j!=lens){\\n            if(t[i]==s[j]){\\n                i++;\\n                j++;\\n            }\\n            else{\\n                j++;\\n            }\\n        }\\n        return (lent-i);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int appendCharacters(string s, string t) {\\n        int lent=t.size();int lens=s.size();\\n        int i=0;int j=0;\\n        while(i!=lent && j!=lens){\\n            if(t[i]==s[j]){\\n                i++;\\n                j++;\\n            }\\n            else{\\n                j++;\\n            }\\n        }\\n        return (lent-i);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4080329,
                "title": "easiest-python-code",
                "content": "# Code\\n```\\nclass Solution:\\n    def appendCharacters(self, s: str, t: str) -> int:\\n        i = j = 0\\n        while i < len(t) and j < len(s):\\n            if t[i] == s[j]:\\n                i += 1\\n            j += 1\\n        return len(t) - i\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def appendCharacters(self, s: str, t: str) -> int:\\n        i = j = 0\\n        while i < len(t) and j < len(s):\\n            if t[i] == s[j]:\\n                i += 1\\n            j += 1\\n        return len(t) - i\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4079455,
                "title": "easy-to-understand-c-solution-using-two-pointers",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int appendCharacters(string s, string t) {\\n        int ans=0;\\n        int j=0;\\n        int n=t.size();\\n        for(int i=0;i<s.size();i++){\\n           if(j==n) break;\\n           if(t[j]==s[i]){\\n               j++;\\n               ans++;\\n           }\\n        }\\n        return n-ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Two Pointers",
                    "String",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int appendCharacters(string s, string t) {\\n        int ans=0;\\n        int j=0;\\n        int n=t.size();\\n        for(int i=0;i<s.size();i++){\\n           if(j==n) break;\\n           if(t[j]==s[i]){\\n               j++;\\n               ans++;\\n           }\\n        }\\n        return n-ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4078134,
                "title": "damn-damn-easy",
                "content": "# \\uD83D\\uDE09Don\\'t just watch & move away, also give an Upvote.\\uD83D\\uDE09\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int appendCharacters(string s, string t) {\\n        int m = size(s);\\n        int n = size(t);\\n\\n        int cnt = 0;\\n\\n        int i=0,j=0;\\n\\n        while(i<m && j<n)\\n        {\\n            if(s[i] == t[j])\\n            {\\n                j++;\\n                cnt++;\\n            }\\n            i++;\\n        }\\n\\n<!-- \\u2705Well before returning answer don\\'t forget to UPVOTE.\\u2705 -->\\n        return n-cnt;\\n    }\\n};\\n```\\n![Leetcode Upvote.gif](https://assets.leetcode.com/users/images/c4beab68-5d1b-4612-a88b-131d252bc15d_1695410886.5501049.gif)\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "C",
                    "JavaScript"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int appendCharacters(string s, string t) {\\n        int m = size(s);\\n        int n = size(t);\\n\\n        int cnt = 0;\\n\\n        int i=0,j=0;\\n\\n        while(i<m && j<n)\\n        {\\n            if(s[i] == t[j])\\n            {\\n                j++;\\n                cnt++;\\n            }\\n            i++;\\n        }\\n\\n<!-- \\u2705Well before returning answer don\\'t forget to UPVOTE.\\u2705 -->\\n        return n-cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4077816,
                "title": "append-characters-to-string-to-make-subsequence-simple-and-easy-solution-using-count",
                "content": "# Approach\\n1. Traverse through s and t simultaneously\\n2. if char of \\'t\\' and char of \\'s\\' matches then increment t[j] to t[j+1].\\n3. Increment s[i] to s[i+1] in each iteration.\\n4. if size of t is going out of bound then return 0 because it has reached to end means t is subsequence of s\\n5. else subtract the current index of char of \\'t\\' from t.size(). Return the value;\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int appendCharacters(string s, string t) {\\n        int cnt=0,x=0;\\n        for(int i=0;i<s.size();i++){\\n            if(t[x]==s[i]){\\n                cnt++;\\n                x++;\\n            }\\n            if(cnt==t.size()) return 0;\\n        }\\n        return t.size()-x;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int appendCharacters(string s, string t) {\\n        int cnt=0,x=0;\\n        for(int i=0;i<s.size();i++){\\n            if(t[x]==s[i]){\\n                cnt++;\\n                x++;\\n            }\\n            if(cnt==t.size()) return 0;\\n        }\\n        return t.size()-x;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4076872,
                "title": "1-loop-solution",
                "content": "\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int appendCharacters(String s, String t) {\\n        int count=0;\\n        int j=0;\\n        int i=0;\\n        while(i<s.length() && j<t.length())\\n        {\\n            if(s.charAt(i)==t.charAt(j)){\\n                j++;\\n            }\\n            i++;\\n        }\\n        return t.length()-j;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public int appendCharacters(String s, String t) {\\n        int count=0;\\n        int j=0;\\n        int i=0;\\n        while(i<s.length() && j<t.length())\\n        {\\n            if(s.charAt(i)==t.charAt(j)){\\n                j++;\\n            }\\n            i++;\\n        }\\n        return t.length()-j;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4076135,
                "title": "o-n-time-complexity-sunil-king",
                "content": "# Code\\n```\\nclass Solution:\\n    def appendCharacters(self, s: str, t: str) -> int:\\n        i,j=0,0\\n\\n        while j<len(s) and i<len(t):\\n            if s[j]==t[i]:\\n                i+=1\\n            j+=1\\n        if i==len(t):\\n            return 0\\n        else:\\n            return len(t)-i\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def appendCharacters(self, s: str, t: str) -> int:\\n        i,j=0,0\\n\\n        while j<len(s) and i<len(t):\\n            if s[j]==t[i]:\\n                i+=1\\n            j+=1\\n        if i==len(t):\\n            return 0\\n        else:\\n            return len(t)-i\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4075901,
                "title": "easy-two-pointer-solution-c",
                "content": "# Intuition\\n2 pointer approach\\n\\n\\n\\n# Complexity\\n- Time complexity:\\nO(l) where l is maximun(n,m)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int appendCharacters(string s, string t) {\\n        int n=s.length(),m=t.length(),i=0,j=0;\\n        int count=0;cout<<m;\\n        while(i<n && j<m)\\n        {\\n            if(s[i]==t[j])\\n            {i++;j++;}\\n            else{i++;}\\n        }\\n        return m-j;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int appendCharacters(string s, string t) {\\n        int n=s.length(),m=t.length(),i=0,j=0;\\n        int count=0;cout<<m;\\n        while(i<n && j<m)\\n        {\\n            if(s[i]==t[j])\\n            {i++;j++;}\\n            else{i++;}\\n        }\\n        return m-j;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 4075202,
                "title": "simple-one-while-loop",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int appendCharacters(string s, string t) {\\n        int i=0;\\n        int j=0;\\n\\n        while(i<s.size())\\n        {\\n            if(s[i]==t[j])\\n            {\\n                j++;\\n                i++;\\n                if(j==t.size())\\n                return 0;\\n            }\\n            else\\n            i++;\\n        }\\n        return t.size()-j;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int appendCharacters(string s, string t) {\\n        int i=0;\\n        int j=0;\\n\\n        while(i<s.size())\\n        {\\n            if(s[i]==t[j])\\n            {\\n                j++;\\n                i++;\\n                if(j==t.size())\\n                return 0;\\n            }\\n            else\\n            i++;\\n        }\\n        return t.size()-j;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4074951,
                "title": "append-characters-to-string-to-make-subsequence",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int appendCharacters(String s, String t) {\\n        int tindex =0;\\n        int sindex =0;\\n        while(tindex<t.length()&&sindex<s.length())\\n        {\\n            if(s.charAt(sindex)==t.charAt(tindex))\\n            {\\n                sindex++;\\n                tindex++;\\n            }\\n            else\\n            sindex++;\\n        }\\n        return t.length()-tindex;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int appendCharacters(String s, String t) {\\n        int tindex =0;\\n        int sindex =0;\\n        while(tindex<t.length()&&sindex<s.length())\\n        {\\n            if(s.charAt(sindex)==t.charAt(tindex))\\n            {\\n                sindex++;\\n                tindex++;\\n            }\\n            else\\n            sindex++;\\n        }\\n        return t.length()-tindex;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4074780,
                "title": "two-pointer",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int appendCharacters(string t, string s) {\\n        int n=t.length();\\n        int m=s.length();\\n        int i=0,j=0;\\n        while(i<n && j<m)\\n        {\\n            if(s[j]!=t[i])\\n            {\\n                i++;\\n            }\\n            else\\n            {\\n                i++;\\n                j++;\\n            }\\n        }\\n         return (m-j);\\n    }                                                 \\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int appendCharacters(string t, string s) {\\n        int n=t.length();\\n        int m=s.length();\\n        int i=0,j=0;\\n        while(i<n && j<m)\\n        {\\n            if(s[j]!=t[i])\\n            {\\n                i++;\\n            }\\n            else\\n            {\\n                i++;\\n                j++;\\n            }\\n        }\\n         return (m-j);\\n    }                                                 \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4074583,
                "title": "easy-java-solution-beginners-friendly-append-characters-to-string-to-make-subsequence",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int appendCharacters(String s, String t) {\\n        if(s.length()==0)\\n            return t.length();\\n        int j=0;\\n        for(int i=0;i<s.length() && j<t.length();i++){\\n            if(s.charAt(i)==t.charAt(j)){\\n                j++;\\n            }\\n        }\\n        return t.length()-j;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Two Pointers",
                    "String",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\n    public int appendCharacters(String s, String t) {\\n        if(s.length()==0)\\n            return t.length();\\n        int j=0;\\n        for(int i=0;i<s.length() && j<t.length();i++){\\n            if(s.charAt(i)==t.charAt(j)){\\n                j++;\\n            }\\n        }\\n        return t.length()-j;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4070837,
                "title": "easiest-approach-beats-90",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nvery easy iterative approach\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ --> O(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->O(1);\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int appendCharacters(string s, string t) {\\n        int index=0,count=0;\\n        int n=s.length(),j=0;\\n        for(int i=0;i<n;i++){\\n            if(s[i]==t[j]){\\n                j++;\\n            }\\n        }\\n        return (j==t.length())? 0: t.length()-j;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int appendCharacters(string s, string t) {\\n        int index=0,count=0;\\n        int n=s.length(),j=0;\\n        for(int i=0;i<n;i++){\\n            if(s[i]==t[j]){\\n                j++;\\n            }\\n        }\\n        return (j==t.length())? 0: t.length()-j;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4066866,
                "title": "optimize-solution-using-greedy-and-two-pointer-approch-3-line-solution-98-beats",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int appendCharacters(String s, String t) {\\n        int i=0, j=0;\\n\\n        while(i<s.length() && j<t.length()){\\n            if(s.charAt(i) == t.charAt(j)) j++;\\n            i++;\\n        }\\n\\n        return t.length()-j;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Two Pointers",
                    "String",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\n    public int appendCharacters(String s, String t) {\\n        int i=0, j=0;\\n\\n        while(i<s.length() && j<t.length()){\\n            if(s.charAt(i) == t.charAt(j)) j++;\\n            i++;\\n        }\\n\\n        return t.length()-j;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4059939,
                "title": "c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int appendCharacters(string s, string t) {\\n        int i=0,j=0;\\n        int cnt=0;\\n        \\n        while(j<t.size())\\n        {\\n            if(i==s.size())\\n            {\\n                j++;\\n                cnt++;\\n            }\\n            else if(s[i]==t[j])\\n            {\\n                i++;\\n                j++;\\n            }\\n            else \\n            {\\n                i++;\\n            }\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int appendCharacters(string s, string t) {\\n        int i=0,j=0;\\n        int cnt=0;\\n        \\n        while(j<t.size())\\n        {\\n            if(i==s.size())\\n            {\\n                j++;\\n                cnt++;\\n            }\\n            else if(s[i]==t[j])\\n            {\\n                i++;\\n                j++;\\n            }\\n            else \\n            {\\n                i++;\\n            }\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4053680,
                "title": "solution-for-dummies",
                "content": "# Intuition\\ns = \"coaching\", t = \"coding\"\\n\\nWhile we scan s, we keep track of substring of t that already exists in s. Return len of t minus the len of subsubstring from previous step\\n\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution:\\n    def appendCharacters(self, s: str, t: str) -> int:\\n        curr = 0 \\n\\n        for i in range(len(s)):\\n            if curr == len(t):\\n                break;\\n            if s[i] == t[curr]:\\n                curr += 1\\n        \\n        return (len(t)) - curr\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def appendCharacters(self, s: str, t: str) -> int:\\n        curr = 0 \\n\\n        for i in range(len(s)):\\n            if curr == len(t):\\n                break;\\n            if s[i] == t[curr]:\\n                curr += 1\\n        \\n        return (len(t)) - curr\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4052419,
                "title": "python-solution",
                "content": "# Code\\n```\\nclass Solution:\\n    def appendCharacters(self, s: str, t: str) -> int:\\n        p=0\\n        for i in s:\\n            if(p<len(t) and i==t[p]):\\n                p+=1\\n        return len(t)-p\\n            \\n```",
                "solutionTags": [
                    "Python3",
                    "Greedy"
                ],
                "code": "```\\nclass Solution:\\n    def appendCharacters(self, s: str, t: str) -> int:\\n        p=0\\n        for i in s:\\n            if(p<len(t) and i==t[p]):\\n                p+=1\\n        return len(t)-p\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 4041363,
                "title": "simple-and-clean-rust-solution-with-o-1-space",
                "content": "# Intuition\\nThis problem is a variation of simply testing if `t` is already a subsequence of `s`.  The critical difference is that we simply need to return how much of `t` is leftover after we test if it is a subsequence.  If a non-zero number of characters in `t` are leftover then it is not currently a subsequence of `s` but can be by adding the remaining characters.\\n\\n# Approach\\nUsing a two pointers strategy, we iterate of `s` and `t` together but only advancing `t` if we find a match.  Then at the end of this loop when either `s` or `t` are exhausted, we know that `t` will be a subsequence of `s` if the remaining characters in `t` _were_ to be found in `s`.  If `t` is exhausted, then we know it is currently a subsequence and no extra characters are needed.\\n\\nWe use a `peekable()` iterator to avoid using $$O(n)$$ space to store the char array, but we could also use `String::as_bytes()` to iterate over a `&[u8]` slice.\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n\\n- Space complexity: $$O(1)$$\\n\\n# Code\\n```\\nuse std::convert::TryInto;\\n\\nimpl Solution {\\n    pub fn append_characters(s: String, t: String) -> i32 {\\n        let mut s_iter = s.chars().peekable();\\n        let mut t_iter = t.chars().peekable();\\n\\n        while let Some(s_c) = s_iter.next() {\\n            match t_iter.peek() {\\n                Some(&t_c) => {\\n                    if t_c == s_c {\\n                        let _ = t_iter.next();\\n                    }\\n                }\\n                None => break,\\n            }\\n        }\\n\\n        t_iter.count().try_into().unwrap()\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nuse std::convert::TryInto;\\n\\nimpl Solution {\\n    pub fn append_characters(s: String, t: String) -> i32 {\\n        let mut s_iter = s.chars().peekable();\\n        let mut t_iter = t.chars().peekable();\\n\\n        while let Some(s_c) = s_iter.next() {\\n            match t_iter.peek() {\\n                Some(&t_c) => {\\n                    if t_c == s_c {\\n                        let _ = t_iter.next();\\n                    }\\n                }\\n                None => break,\\n            }\\n        }\\n\\n        t_iter.count().try_into().unwrap()\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4011956,
                "title": "c-time-o-n-space-o-1",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- Have a pointer for t to mark the substring is not found in s\\n- Iterate each character in s and if it is equal to t[tIdx], advance tIdx\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    O(1)\\n\\n# Code\\n```\\npublic class Solution {\\n    public int AppendCharacters(string s, string t) {\\n        int tIdx = 0;\\n\\n        foreach(char c in s)\\n        {\\n            if (tIdx < t.Length)\\n            {\\n                if (c == t[tIdx])\\n                {\\n                    tIdx++;\\n                }\\n            }\\n            else\\n            {\\n                break;\\n            }\\n        }\\n\\n        return t.Length - tIdx;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int AppendCharacters(string s, string t) {\\n        int tIdx = 0;\\n\\n        foreach(char c in s)\\n        {\\n            if (tIdx < t.Length)\\n            {\\n                if (c == t[tIdx])\\n                {\\n                    tIdx++;\\n                }\\n            }\\n            else\\n            {\\n                break;\\n            }\\n        }\\n\\n        return t.Length - tIdx;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4010712,
                "title": "beats-99-single-pass-5-lines-easy-to-understand-with-explanation-50ms",
                "content": "# Intuition\\nFind the first character in the str2 that doesn\\'t exist in str1\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nLets call that character index as max_ind\\nThere is another variable called ind which is the index of every character from str2 to find in str1\\n1. Initialise ind and max_ind as -1\\n2. Loop through all characters in str2\\n3. For every char in str2 find it in str1\\n4. Syntax Explanation:\\n    str.find(char,startingIndex) $$Takes O(len(str1)) Time$$\\n    returns index of the found char if found \\n    else returns -1\\n5. Keep in mind That every time we find a char at some index and store it in\"ind\" ,For the next character lookup we do not need to find in the entire string but the string after ind character . Hence I put startingIndex as ind+1. This is a little optimization and is not necessary\\n6. If character is not found str.find will return -1 and -1 is stored in ind(i.e. why we initialised ind to be -1)\\n7. Great Job now we can store the index of non found character from str2(not str1) in maxind\\n<!-- Describe your approach to solving the problem. -->\\n\\nLast line is self explanatory:\\nreturn 0 if max_ind==-1 else len(str2)-max_ind\\n# Complexity\\n- Time complexity:\\nO(M*N) M and N are lengths of str1 and str2\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\nO(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def appendCharacters(self, str1: str, str2: str) -> int:\\n        ind,max_ind=-1,-1\\n        for i,ch in enumerate(str2):\\n            ind=str1.find(ch,ind+1)\\n            if ind==-1:\\n                max_ind=i\\n                break\\n        return 0 if max_ind==-1 else len(str2)-max_ind\\n        \\n```\\n![giphy (1).gif](https://assets.leetcode.com/users/images/b80cf37c-6912-4194-b138-a1b9feb958c3_1694429443.3442395.gif)\\n",
                "solutionTags": [
                    "Python3",
                    "String",
                    "Greedy"
                ],
                "code": "```\\nclass Solution:\\n    def appendCharacters(self, str1: str, str2: str) -> int:\\n        ind,max_ind=-1,-1\\n        for i,ch in enumerate(str2):\\n            ind=str1.find(ch,ind+1)\\n            if ind==-1:\\n                max_ind=i\\n                break\\n        return 0 if max_ind==-1 else len(str2)-max_ind\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3995768,
                "title": "easy-c-single-loop-two-pointer-solution",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int appendCharacters(string s, string t) {\\n        int n = s.length();\\n        int m = t.length();\\n        int i = 0, j = 0;\\n\\n        while(i < n && j < m){\\n            if(s[i] == t[j]){\\n                j++;\\n            } \\n            i++;\\n        }\\n        return m-j;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int appendCharacters(string s, string t) {\\n        int n = s.length();\\n        int m = t.length();\\n        int i = 0, j = 0;\\n\\n        while(i < n && j < m){\\n            if(s[i] == t[j]){\\n                j++;\\n            } \\n            i++;\\n        }\\n        return m-j;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3995387,
                "title": "simple-pointer-increment-o-n-o-1",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nJust observed that once the common part of the two strings end, the latter part of `t` can be appended to the end of `s`, which implies that we can return the length of the remaining part of `t`. However, if `t`exhausts before `s`, we return 0, because s must already contain `t` in that case.\\n\\n# Complexity\\n- Time complexity: **O(max(s.length(), t.length()))**\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: **O(1)**\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int appendCharacters(String s, String t) {\\n        int sp = 0, st = 0;\\n        while(true){\\n            if(s.charAt(sp)==(t.charAt(st))){\\n                while(sp<s.length() && st<t.length() && s.charAt(sp)==(t.charAt(st))){sp++; st++;}\\n            }\\n            else{\\n                sp++;\\n            }\\n            if(sp>=s.length()){return t.substring(st).length();}\\n            else if(st>=t.length()){return 0;}\\n        }    \\n    }\\n} \\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int appendCharacters(String s, String t) {\\n        int sp = 0, st = 0;\\n        while(true){\\n            if(s.charAt(sp)==(t.charAt(st))){\\n                while(sp<s.length() && st<t.length() && s.charAt(sp)==(t.charAt(st))){sp++; st++;}\\n            }\\n            else{\\n                sp++;\\n            }\\n            if(sp>=s.length()){return t.substring(st).length();}\\n            else if(st>=t.length()){return 0;}\\n        }    \\n    }\\n} \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3985249,
                "title": "c-o-n-is-subsequence-application",
                "content": "# Intuition\\nThis is just an application of https://leetcode.com/problems/is-subsequence/description/\\n\\n# Approach\\nTake 2 pointers iT for t and iS for S.\\nif s[iS] == t[iT] --> character matched, hence, increment iS and iT by 1 to check next character of t.\\nelse, increment iS by 1 to check if next character is same as current character of t\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int appendCharacters(string s, string t) {\\n        int iT = 0;\\n        int iS = 0;\\n        while(iS < s.size() && iT < t.size())\\n        {\\n            if(s[iS] == t[iT])\\n                iT++;\\n            iS++;\\n        }\\n        return t.size() - iT;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int appendCharacters(string s, string t) {\\n        int iT = 0;\\n        int iS = 0;\\n        while(iS < s.size() && iT < t.size())\\n        {\\n            if(s[iS] == t[iT])\\n                iT++;\\n            iS++;\\n        }\\n        return t.size() - iT;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3979353,
                "title": "java-two-pointers-solution-with-example",
                "content": "# Complexity\\n- Time complexity: O(m + n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int appendCharacters(String s, String t) {\\n        /*\\n        coadhiab \\n             m\\n        coding \\n           n = 3\\n        */\\n        int m = 0, n = 0;\\n        while(m < s.length() && n < t.length()) {\\n            if (s.charAt(m) == t.charAt(n)) {\\n                m++;\\n                n++;\\n            } else {\\n                m++;\\n            }\\n        }\\n\\n        if (n < t.length()) {\\n            return t.length() - n;\\n        }\\n\\n        return 0;\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int appendCharacters(String s, String t) {\\n        /*\\n        coadhiab \\n             m\\n        coding \\n           n = 3\\n        */\\n        int m = 0, n = 0;\\n        while(m < s.length() && n < t.length()) {\\n            if (s.charAt(m) == t.charAt(n)) {\\n                m++;\\n                n++;\\n            } else {\\n                m++;\\n            }\\n        }\\n\\n        if (n < t.length()) {\\n            return t.length() - n;\\n        }\\n\\n        return 0;\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3966272,
                "title": "simple-o-n-5-lines",
                "content": "# Intuition\\n\\nCheck whatever characters you can match in both and once you reach the string `s` end then you will have to add extra characters (remaining in string `t`) which were not covered earlier.\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int appendCharacters(string s, string t) {\\n        int i = 0, j = 0;\\n        while(i < s.size() && j < t.size()) {\\n            if(s[i] == t[j]) {\\n                i++;j++;\\n            } else i++;\\n        }\\n\\n        return t.size()-j;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int appendCharacters(string s, string t) {\\n        int i = 0, j = 0;\\n        while(i < s.size() && j < t.size()) {\\n            if(s[i] == t[j]) {\\n                i++;j++;\\n            } else i++;\\n        }\\n\\n        return t.size()-j;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3961879,
                "title": "c-javascript-easy-solution",
                "content": "# Complexity\\n- Time complexity: O(n) where n is the length of string \\'s\\'\\n- Space complexity: O(1)\\n\\n\\n# Code\\n# C++\\n```\\nclass Solution {\\npublic:\\n    int appendCharacters(string s, string t) {\\n        int k=0;\\n        for(int i=0;i<s.size();i++){\\n            if(s[i]==t[k]) k++;  \\n        }\\n        return t.size()-k;\\n    }\\n};\\n```\\n\\n---\\n\\n\\n# JavaScript\\n```\\n/**\\n * @param {string} s\\n * @param {string} t\\n * @return {number}\\n */\\nvar appendCharacters = function(s, t) {\\n    let k=0;\\n    for(let i=0;i<s.length;i++){\\n        if(s[i]==t[k]) k++;  \\n    }\\n    return t.length-k;\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "JavaScript",
                    "Two Pointers",
                    "String",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int appendCharacters(string s, string t) {\\n        int k=0;\\n        for(int i=0;i<s.size();i++){\\n            if(s[i]==t[k]) k++;  \\n        }\\n        return t.size()-k;\\n    }\\n};\\n```\n```\\n/**\\n * @param {string} s\\n * @param {string} t\\n * @return {number}\\n */\\nvar appendCharacters = function(s, t) {\\n    let k=0;\\n    for(let i=0;i<s.length;i++){\\n        if(s[i]==t[k]) k++;  \\n    }\\n    return t.length-k;\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3960540,
                "title": "c-o-n-using-two-pointers",
                "content": "\\n# Code\\n```\\npublic class Solution {\\n    public int AppendCharacters(string s, string t) {\\n        var si = 0;\\n        var ti = 0;\\n        while(si < s.Length)\\n        {\\n            if(ti == t.Length) return 0;\\n\\n            if(t[ti] == s[si])\\n            {\\n                ti++;\\n            }\\n            si++;\\n        }\\n\\n        return t.Length - ti;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#",
                    "Two Pointers"
                ],
                "code": "```\\npublic class Solution {\\n    public int AppendCharacters(string s, string t) {\\n        var si = 0;\\n        var ti = 0;\\n        while(si < s.Length)\\n        {\\n            if(ti == t.Length) return 0;\\n\\n            if(t[ti] == s[si])\\n            {\\n                ti++;\\n            }\\n            si++;\\n        }\\n\\n        return t.Length - ti;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3955666,
                "title": "linear-2-pointers-approach-very-fast-and-easy-to-understand",
                "content": "# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\ntime complexity $$O(n)$$ with constant space complexity\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int appendCharacters(string s, string t) {\\n        int i = 0, j = 0;\\n        while( i < s.size() && j < t.size()){\\n            if (s[i] == t[j]){\\n                j++;\\n            }\\n            i++;\\n        }\\n        return t.size() - j;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int appendCharacters(string s, string t) {\\n        int i = 0, j = 0;\\n        while( i < s.size() && j < t.size()){\\n            if (s[i] == t[j]){\\n                j++;\\n            }\\n            i++;\\n        }\\n        return t.size() - j;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3954312,
                "title": "java-easy-solution-99-with-comments",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int appendCharacters(String s, String t) {\\n        \\n        int n = s.length();\\n        int m = t.length();\\n        int j = 0;\\n        for(int i=0;i<n;i++){\\n            if(s.charAt(i) == t.charAt(j)){ // count kitne same hai \\n                j++;\\n            }\\n            if(j==m) break; // when it equal to length means all subsequence is there \\n        }\\n        return m-j;  // lenght se sub jitne same hai \\n    }\\n}\\n\\n// its like ek baar bi alag hua tho jitne bache hai saare output hoga  \\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int appendCharacters(String s, String t) {\\n        \\n        int n = s.length();\\n        int m = t.length();\\n        int j = 0;\\n        for(int i=0;i<n;i++){\\n            if(s.charAt(i) == t.charAt(j)){ // count kitne same hai \\n                j++;\\n            }\\n            if(j==m) break; // when it equal to length means all subsequence is there \\n        }\\n        return m-j;  // lenght se sub jitne same hai \\n    }\\n}\\n\\n// its like ek baar bi alag hua tho jitne bache hai saare output hoga  \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3941337,
                "title": "a-very-basic-pythonic-solution",
                "content": "# Intuition\\nVery basic 2 Pointer technique in Python\\n# Approach\\n - Iterate over all Characters of S and increment counter of T for a match.\\n\\n - If we reach end of T then return 0, as it is fully contained in S.\\n\\n - Else return the length of T that has not been found contained in S\\n\\n# Complexity\\n- Time complexity:\\nWe run the loop over S, O(n), n being the length of S\\n\\n- Space complexity:\\nConstant Space as just the counters are needed for this algorithm to work.\\n\\n# Code\\n```\\nclass Solution:\\n    def appendCharacters(self, s: str, t: str) -> int:\\n        ptrT = 0\\n        for ptrS in range(len(s)):\\n            if s[ptrS] == t[ptrT]:\\n                if ptrT == len(t)-1:\\n                    return 0\\n                ptrT+=1\\n        return len(t)-ptrT\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def appendCharacters(self, s: str, t: str) -> int:\\n        ptrT = 0\\n        for ptrS in range(len(s)):\\n            if s[ptrS] == t[ptrT]:\\n                if ptrT == len(t)-1:\\n                    return 0\\n                ptrT+=1\\n        return len(t)-ptrT\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3936632,
                "title": "easy-c-beginner-friendly-solution",
                "content": "# Intuition\\nTraverse the string s and find how much string t is present if the some chars are missing then return the remaining length of t which we can find in s as the answer\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nused two pointer approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:$$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int appendCharacters(string s, string t) \\n    {\\n        int j=0;\\n        int N=s.size();\\n        int K=t.size();\\n        //using two pointer to check how much t is already in the s\\n        for(int i=0;i<N;i++)\\n        {\\n            if(s[i]==t[j])\\n            {\\n                j++;\\n            }\\n        }\\n        //if the WHole t is present in s then return 0\\n        if(j==K)\\n        {\\n            return 0;\\n        }\\n        //else return the remaining length of t which we cant find in s\\n        else\\n        {\\n            return K-j;\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int appendCharacters(string s, string t) \\n    {\\n        int j=0;\\n        int N=s.size();\\n        int K=t.size();\\n        //using two pointer to check how much t is already in the s\\n        for(int i=0;i<N;i++)\\n        {\\n            if(s[i]==t[j])\\n            {\\n                j++;\\n            }\\n        }\\n        //if the WHole t is present in s then return 0\\n        if(j==K)\\n        {\\n            return 0;\\n        }\\n        //else return the remaining length of t which we cant find in s\\n        else\\n        {\\n            return K-j;\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3936053,
                "title": "python-3-two-pointer",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def appendCharacters(self, s: str, t: str) -> int:\\n\\n        m=len(s)\\n        n=len(t)\\n\\n        i=0\\n        j=0\\n\\n        while i<m and j<n:\\n            if s[i]==t[j]:j+=1\\n            i+=1\\n       \\n        return n-j    \\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def appendCharacters(self, s: str, t: str) -> int:\\n\\n        m=len(s)\\n        n=len(t)\\n\\n        i=0\\n        j=0\\n\\n        while i<m and j<n:\\n            if s[i]==t[j]:j+=1\\n            i+=1\\n       \\n        return n-j    \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3935541,
                "title": "2-pointer-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nA two-pointer approach can be used. Initialize two pointers, i for s and j for t. Iterate through both strings while comparing characters. If a match is found, move both pointers. If not, increment the count and move only the pointer for t. After exhausting characters in s, add the remaining characters from t to the count.\\n\\n# Complexity\\n- Time complexity:\\nO(max(n, m)), where n and m are the lengths of s and t.\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public int appendCharacters(String s, String t) {\\n        int i = 0;\\n        int j = 0;\\n        while(i < s.length() && j < t.length()){\\n            if(s.charAt(i) == t.charAt(j)){\\n                j++;\\n            }\\n            i++;\\n        }\\n        return t.length() - j;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int appendCharacters(String s, String t) {\\n        int i = 0;\\n        int j = 0;\\n        while(i < s.length() && j < t.length()){\\n            if(s.charAt(i) == t.charAt(j)){\\n                j++;\\n            }\\n            i++;\\n        }\\n        return t.length() - j;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3861852,
                "title": "c-greedy-faster-than-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\npublic class Solution {    \\n    public int AppendCharacters(string s, string t)\\n    {\\n        var sIterator = 0;\\n        var tIterator = 0;\\n\\n        while (sIterator < s.Length && tIterator < t.Length)\\n        {\\n            if (s[sIterator] == t[tIterator])\\n            {\\n                tIterator++;\\n            }\\n\\n            sIterator++;\\n        }\\n\\n        return t.Length - tIterator;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {    \\n    public int AppendCharacters(string s, string t)\\n    {\\n        var sIterator = 0;\\n        var tIterator = 0;\\n\\n        while (sIterator < s.Length && tIterator < t.Length)\\n        {\\n            if (s[sIterator] == t[tIterator])\\n            {\\n                tIterator++;\\n            }\\n\\n            sIterator++;\\n        }\\n\\n        return t.Length - tIterator;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3858600,
                "title": "easy-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int appendCharacters(string s, string t) {\\n        int j=0;\\n        for(int i=0;i<s.size();i++){\\n            if(j==t.size()) return 0;\\n            if(t[j]==s[i]) j++;\\n        }\\n        return t.size()-j;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int appendCharacters(string s, string t) {\\n        int j=0;\\n        for(int i=0;i<s.size();i++){\\n            if(j==t.size()) return 0;\\n            if(t[j]==s[i]) j++;\\n        }\\n        return t.size()-j;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3857722,
                "title": "binary-search-c-solution",
                "content": "First store the occurance of all the character of the first string in a 2-d vector. Now iterate through the 2nd string.\\nWhen will we come to know that we can\\'t get any of the next character as a subsequence?\\n    Case-1) If the character is not present in the 1st string.\\n\\tCase-2) If last occurance of the 2nd string character in the 1st string is smaller than the occurance of previous character.\\n\\tIn these cases, simply return (length of 2nd string - till now iterated character);\\nOtherwise return 0.\\n```\\nclass Solution {\\npublic:\\n    int solve(vector<int>& v, int& p)\\n    {\\n        int l=0,h=v.size()-1;\\n        if(v[h]<p)\\n            return -2;\\n        while(l<=h)\\n        {\\n            int m=l+(h-l)/2;\\n            if(v[m]>p)\\n                h=m-1;\\n            else\\n                l=m+1;\\n        }\\n        return l;\\n    }\\n    int appendCharacters(string s, string t) {\\n        vector<vector<int>> v(26);\\n        for(int i=0; i<s.length(); i++)\\n            v[s[i]-\\'a\\'].push_back(i);\\n        int p=-1,n=t.length();\\n        vector<int> d;\\n        for(int i=0; i<n; i++){\\n            d=v[t[i]-\\'a\\'];\\n            if(d.size()==0)\\n                return n-i;\\n            int k=solve(d,p);\\n            // cout<<i<<\" \"<<k<<endl;\\n            if(k<0 || d[k]<=p)\\n                return n-i;\\n            p=max(p,d[k]);\\n        }\\n        return 0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int solve(vector<int>& v, int& p)\\n    {\\n        int l=0,h=v.size()-1;\\n        if(v[h]<p)\\n            return -2;\\n        while(l<=h)\\n        {\\n            int m=l+(h-l)/2;\\n            if(v[m]>p)\\n                h=m-1;\\n            else\\n                l=m+1;\\n        }\\n        return l;\\n    }\\n    int appendCharacters(string s, string t) {\\n        vector<vector<int>> v(26);\\n        for(int i=0; i<s.length(); i++)\\n            v[s[i]-\\'a\\'].push_back(i);\\n        int p=-1,n=t.length();\\n        vector<int> d;\\n        for(int i=0; i<n; i++){\\n            d=v[t[i]-\\'a\\'];\\n            if(d.size()==0)\\n                return n-i;\\n            int k=solve(d,p);\\n            // cout<<i<<\" \"<<k<<endl;\\n            if(k<0 || d[k]<=p)\\n                return n-i;\\n            p=max(p,d[k]);\\n        }\\n        return 0;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3855966,
                "title": "beats-96-81-in-time-and-99-41-in-space-best-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int appendCharacters(string s, string t) {\\n        int n = s.length();\\n        int m = t.length();\\n        int i=0,j=0;\\n        while(i<n && j<m)\\n        {\\n            if(s[i]==t[j])\\n            {\\n                i++;\\n                j++;\\n            }\\n            else\\n            {\\n                i++;\\n            }\\n        }\\n        int ans;\\n        if(j==m)\\n        {\\n            ans = 0;\\n        }\\n        else\\n        {\\n            ans = m-j;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int appendCharacters(string s, string t) {\\n        int n = s.length();\\n        int m = t.length();\\n        int i=0,j=0;\\n        while(i<n && j<m)\\n        {\\n            if(s[i]==t[j])\\n            {\\n                i++;\\n                j++;\\n            }\\n            else\\n            {\\n                i++;\\n            }\\n        }\\n        int ans;\\n        if(j==m)\\n        {\\n            ans = 0;\\n        }\\n        else\\n        {\\n            ans = m-j;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3854196,
                "title": "very-easy-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n## <!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int appendCharacters(string s, string t) {\\n       int n=s.length(),m=t.length();\\n        int i=0,j=0;\\n        while(i<n&&j<m)\\n        {\\n            if(t[j]==s[i])\\n            {\\n                j++;\\n            }\\n            i++;\\n        }\\n        return m-j;\\n    \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int appendCharacters(string s, string t) {\\n       int n=s.length(),m=t.length();\\n        int i=0,j=0;\\n        while(i<n&&j<m)\\n        {\\n            if(t[j]==s[i])\\n            {\\n                j++;\\n            }\\n            i++;\\n        }\\n        return m-j;\\n    \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3835730,
                "title": "java-time-optimized-3ms-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nThe actual problem solution is obviously straightforward. To make it faster I just use getBytes, and iterate over the arrays. It works faster, that toCharArray, or iterating over strings.\\n\\n\\n# Code\\n```\\nclass Solution {\\n    public int appendCharacters(String s, String t) {\\n\\n        if (t == null || t.length() == 0) return 0;\\n        int a=0, b=0;\\n        // extra space?? but faster \\n        byte[] sBytes = s.getBytes();\\n        byte[] tBytes = t.getBytes();\\n\\n        while (a<sBytes.length && b<tBytes.length) if (sBytes[a++] == tBytes[b]) b++;\\n\\n        return tBytes.length-b;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int appendCharacters(String s, String t) {\\n\\n        if (t == null || t.length() == 0) return 0;\\n        int a=0, b=0;\\n        // extra space?? but faster \\n        byte[] sBytes = s.getBytes();\\n        byte[] tBytes = t.getBytes();\\n\\n        while (a<sBytes.length && b<tBytes.length) if (sBytes[a++] == tBytes[b]) b++;\\n\\n        return tBytes.length-b;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3834021,
                "title": "java-solution-easy-for-beginners",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n\\u2B55(n)\\n\\n- Space complexity:\\n\\u2B55(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public int appendCharacters(String s, String t) {\\n        int i = 0, k = 0;\\n        while (i < s.length() && k < t.length()) {\\n            if (s.charAt(i) == t.charAt(k)) {\\n                i++;\\n                k++;\\n            } else {\\n                i++;\\n            }\\n        }\\n        return t.length() - k;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int appendCharacters(String s, String t) {\\n        int i = 0, k = 0;\\n        while (i < s.length() && k < t.length()) {\\n            if (s.charAt(i) == t.charAt(k)) {\\n                i++;\\n                k++;\\n            } else {\\n                i++;\\n            }\\n        }\\n        return t.length() - k;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3829932,
                "title": "python3-sol",
                "content": "\\n# Code\\n```\\nclass Solution:\\n    def appendCharacters(self, s: str, t: str) -> int:\\n        i,j=0,0\\n        while i<len(s) and j<len(t):\\n            if s[i]==t[j]:\\n                i+=1\\n                j+=1\\n            else:\\n                i+=1\\n        return len(t)-j\\n```",
                "solutionTags": [
                    "Python3",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution:\\n    def appendCharacters(self, s: str, t: str) -> int:\\n        i,j=0,0\\n        while i<len(s) and j<len(t):\\n            if s[i]==t[j]:\\n                i+=1\\n                j+=1\\n            else:\\n                i+=1\\n        return len(t)-j\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3778129,
                "title": "easy-2-pointer-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int appendCharacters(string s, string t) {\\n        int n=s.size();\\n        int i=0,b=0;\\n        while(i<n){\\n            if(s[i]==t[b]){\\n                b++;\\n            }\\n            i++;\\n        }\\n        return t.size()-b;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int appendCharacters(string s, string t) {\\n        int n=s.size();\\n        int i=0,b=0;\\n        while(i<n){\\n            if(s[i]==t[b]){\\n                b++;\\n            }\\n            i++;\\n        }\\n        return t.size()-b;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3772043,
                "title": "python-easy-solution-two-pointer",
                "content": "# Complexity\\n- Time complexity:\\nO(n+m)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution:\\n    def appendCharacters(self, s: str, t: str) -> int:\\n        first=0\\n        second=0\\n        while(first<len(s) and second<len(t)):\\n            if s[first]==t[second]:\\n                second+=1\\n            first+=1\\n        return len(t)-second\\n```",
                "solutionTags": [
                    "Python3",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution:\\n    def appendCharacters(self, s: str, t: str) -> int:\\n        first=0\\n        second=0\\n        while(first<len(s) and second<len(t)):\\n            if s[first]==t[second]:\\n                second+=1\\n            first+=1\\n        return len(t)-second\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3752911,
                "title": "simple-8-line-c-with-comments-and-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe most characters that could be appended is the total length of t. Each character we find from the start of s, that appears in the same order as in t, can be subtracted from the total number of characters to append.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\ninitialize the minimum to the number of characters in t\\nstart at the beginning of s\\nfor each character in t: while there are characters left in s, and the current letter doesn\\'t match the character from t, move to the next character in s, if we have exhaused all of s, break. decrease the number of characters we need, as a character in s matches a character in t, and move to the next character in s\\n\\nthen return the minimum\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(max(n, m)) where n is the length of t, and m is the length of s\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1) I use 2 variables, and no recursive calls.\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int appendCharacters(string s, string t) {\\n        // initialize the minimum to the number of characters in t\\n        int min = t.size();\\n        // start at the beginning of s\\n        int sIndex = 0;\\n\\n        // for each character in t\\n        for(auto c : t){\\n            // while there are characters left in s, and the current letter doesn\\'t match the character from t\\n            while(sIndex < s.size() && s[sIndex] != c){\\n                // move to the next character in s\\n                sIndex++;\\n            }\\n\\n            // if we have exhaused all of s, break\\n            if (sIndex >= s.size()) break;\\n\\n            // decrease the number of characters we need, as a character in s matches a character in t\\n            min--;\\n            // and move to the next character in s\\n            sIndex++;\\n        }\\n\\n        return min;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int appendCharacters(string s, string t) {\\n        // initialize the minimum to the number of characters in t\\n        int min = t.size();\\n        // start at the beginning of s\\n        int sIndex = 0;\\n\\n        // for each character in t\\n        for(auto c : t){\\n            // while there are characters left in s, and the current letter doesn\\'t match the character from t\\n            while(sIndex < s.size() && s[sIndex] != c){\\n                // move to the next character in s\\n                sIndex++;\\n            }\\n\\n            // if we have exhaused all of s, break\\n            if (sIndex >= s.size()) break;\\n\\n            // decrease the number of characters we need, as a character in s matches a character in t\\n            min--;\\n            // and move to the next character in s\\n            sIndex++;\\n        }\\n\\n        return min;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3751219,
                "title": "c-two-pointer-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int appendCharacters(string s, string t) {\\n        //INTUTION: Take two pointer i and j, i point to character in s\\n        //and j poins to t, when there is match i.e s[i]==t[j], \\n        //inreament both i and j otherwise increament i only\\n        int i=0,j=0;\\n        while(i<s.size() && j<t.size()){\\n            if(s[i]==t[j]){\\n                i++;\\n                j++;\\n            }\\n            else{\\n                i++;\\n            }\\n        }\\n        if(j==t.size()){\\n            return 0;\\n        }\\n        return t.size()-j;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int appendCharacters(string s, string t) {\\n        //INTUTION: Take two pointer i and j, i point to character in s\\n        //and j poins to t, when there is match i.e s[i]==t[j], \\n        //inreament both i and j otherwise increament i only\\n        int i=0,j=0;\\n        while(i<s.size() && j<t.size()){\\n            if(s[i]==t[j]){\\n                i++;\\n                j++;\\n            }\\n            else{\\n                i++;\\n            }\\n        }\\n        if(j==t.size()){\\n            return 0;\\n        }\\n        return t.size()-j;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3749270,
                "title": "simple-java-solution",
                "content": "# Code\\n```\\nclass Solution {\\n    public int appendCharacters(String s, String t) {\\n        int j = 0;\\n        for(int i=0;i<s.length();i++){\\n            if(j<=t.length()-1){\\n                if(s.charAt(i)==t.charAt(j)) j++;\\n            }\\n            else break;\\n        }\\n        return t.length()-j;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int appendCharacters(String s, String t) {\\n        int j = 0;\\n        for(int i=0;i<s.length();i++){\\n            if(j<=t.length()-1){\\n                if(s.charAt(i)==t.charAt(j)) j++;\\n            }\\n            else break;\\n        }\\n        return t.length()-j;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3734100,
                "title": "python-one-pointer-with-one-for-loop",
                "content": "\\n\\n# Code\\n```\\n\"\"\"\\n\\nThe point of this problem is to find the common prefix subsequence between two sequences (\"s\" and \"t\") without skipping any characters from \"t\"\\n\\nTherefore, I use two pointer approach. \\n\\nIt seems like the longest prefix subsequence but it is different in terms of that we cannot skip the character from t\\n\\nso I iterate the string s at first, and If the character in \"s\" matches the character in \"t\" at the current index, increment both pointer_s and pointer_t by 1. This means you have found a matching character in both sequences, so you move both pointers forward.\\n\\nBut if not, If the character in \"s\" doesn\\'t match the character in \"t\" at the current index, stop iterating. At this point, pointer_t will be pointing to the first character in \"t\" that is not part of the common prefix subsequence.\\n\\nAnd return length - index\\n\\nThe time complexity is O(N) and space complexity is O(1)\\n\\n\"\"\"\\n\\nclass Solution:\\n    def appendCharacters(self, s: str, t: str) -> int:\\n        target = 0\\n        for char in s :\\n            if target < len(t) and char == t[target]:\\n                target += 1\\n        return len(t) - target\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n\"\"\"\\n\\nThe point of this problem is to find the common prefix subsequence between two sequences (\"s\" and \"t\") without skipping any characters from \"t\"\\n\\nTherefore, I use two pointer approach. \\n\\nIt seems like the longest prefix subsequence but it is different in terms of that we cannot skip the character from t\\n\\nso I iterate the string s at first, and If the character in \"s\" matches the character in \"t\" at the current index, increment both pointer_s and pointer_t by 1. This means you have found a matching character in both sequences, so you move both pointers forward.\\n\\nBut if not, If the character in \"s\" doesn\\'t match the character in \"t\" at the current index, stop iterating. At this point, pointer_t will be pointing to the first character in \"t\" that is not part of the common prefix subsequence.\\n\\nAnd return length - index\\n\\nThe time complexity is O(N) and space complexity is O(1)\\n\\n\"\"\"\\n\\nclass Solution:\\n    def appendCharacters(self, s: str, t: str) -> int:\\n        target = 0\\n        for char in s :\\n            if target < len(t) and char == t[target]:\\n                target += 1\\n        return len(t) - target\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3727827,
                "title": "append-characters-to-string-to-make-subsequence-easy-approach-fast-simple",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int appendCharacters(string s, string t) \\n    {\\n        int j = 0;\\n        for(int i = 0; i<s.size(); i++)\\n        {\\n            if(s[i]==t[j])\\n            {\\n                j++;\\n            }\\n        }\\n\\n        return t.size()-j;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Two Pointers",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int appendCharacters(string s, string t) \\n    {\\n        int j = 0;\\n        for(int i = 0; i<s.size(); i++)\\n        {\\n            if(s[i]==t[j])\\n            {\\n                j++;\\n            }\\n        }\\n\\n        return t.size()-j;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3709696,
                "title": "solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {string} s\\n * @param {string} t\\n * @return {number}\\n */\\nvar appendCharacters = function(s, t) {\\n    let lst = s.split(\\'\\');\\n    let lst2 = t.split(\\'\\');\\n    let j = 0;\\n\\n    for(let i=0;i<lst.length;i++){\\n        if (lst[i]=== lst2[j])j+=1;\\n    }\\n\\n    return t.substring(j).length;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string} s\\n * @param {string} t\\n * @return {number}\\n */\\nvar appendCharacters = function(s, t) {\\n    let lst = s.split(\\'\\');\\n    let lst2 = t.split(\\'\\');\\n    let j = 0;\\n\\n    for(let i=0;i<lst.length;i++){\\n        if (lst[i]=== lst2[j])j+=1;\\n    }\\n\\n    return t.substring(j).length;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3705750,
                "title": "o-n-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int appendCharacters(String s, String t) {\\n        int i = 0;\\n        int j = 0;\\n        while(i!=s.length() && j!=t.length()) {\\n            if(s.charAt(i) == t.charAt(j)) {\\n                i++;\\n                j++;\\n            }\\n            else {\\n                i++;\\n            }\\n        }\\n        return t.length() - j;\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int appendCharacters(String s, String t) {\\n        int i = 0;\\n        int j = 0;\\n        while(i!=s.length() && j!=t.length()) {\\n            if(s.charAt(i) == t.charAt(j)) {\\n                i++;\\n                j++;\\n            }\\n            else {\\n                i++;\\n            }\\n        }\\n        return t.length() - j;\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3700640,
                "title": "append-characters-to-string-to-make-subsequence",
                "content": "# Code\\n```\\nclass Solution:\\n    def appendCharacters(self, f: str, t: str) -> int:\\n        s = [i for i in f]\\n        l = 0\\n        count  = 0\\n        while l<len(f):\\n            if count==len(t):\\n                break\\n            if f[l]==t[count]:\\n                count+=1\\n                l+=1\\n            else:\\n                l+=1\\n            print(count)\\n        return len(t) - count\\n\\n\\n\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def appendCharacters(self, f: str, t: str) -> int:\\n        s = [i for i in f]\\n        l = 0\\n        count  = 0\\n        while l<len(f):\\n            if count==len(t):\\n                break\\n            if f[l]==t[count]:\\n                count+=1\\n                l+=1\\n            else:\\n                l+=1\\n            print(count)\\n        return len(t) - count\\n\\n\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3695619,
                "title": "c-easy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int appendCharacters(string s, string t) {\\n        int p=0;\\n    for(char ch: s)\\n    {\\n        if(t[p]==ch)\\n        {\\n            p++;\\n        }\\n    }\\n    return t.size()-p;   \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int appendCharacters(string s, string t) {\\n        int p=0;\\n    for(char ch: s)\\n    {\\n        if(t[p]==ch)\\n        {\\n            p++;\\n        }\\n    }\\n    return t.size()-p;   \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3695536,
                "title": "very-much-easy-beginner-friendly",
                "content": "# Approach\\n- We are gonna have two pointers `i,j` at beginning of each string\\n- We are converting the string actually to char Array because of  complexity (accessing array is easy than `charAt()` method ..also `charAt()` method **may** give TLE)\\n- We are moving our pointers like this\\n  - if at `both i,j` we have same char we are moving forward in both the arrays\\n  - else not match , we are moving only `i` because \"*number of characters that need to be appended to the end of s so that t becomes a subsequence of s.* we have to modify char `array of s` but not the `array t`\\n- Our breaking conditions are :\\n  - First one is reaching `j > our array t length` which will happening only when we recieved eb=very char of  `t array` in `s array` which is goal so need of **adding extras** to `s` so we return 0 in that case\\n  - Secondly , when `i > s array length`, this can happen either its satisfy the goal or not so we have to check where our j has stopped in our t array. if the difference `charst.length-j > 0` means our j stopped in between so we have add that many chars to `s array` back side to achieve goal.\\n\\n# Complexity\\n- Time complexity: $$O(min(s.length(),t.length())$$\\n\\n\\n# Code\\n```\\nclass Solution {\\n    public int appendCharacters(String s, String t) {\\n        int i= 0, j=0;\\n        char [] charst =t.toCharArray();\\n        char [] charss =s.toCharArray();\\n        while(j<charst.length && i<charss.length){\\n            if(charst[j]==charss[i]){\\n                i++;j++;\\n            }\\n            else if(charst[j]!=charss[i]){\\n                 i++;\\n             }\\n        }\\n        return charst.length-j > 0 ? charst.length-j : 0;\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Two Pointers",
                    "String",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\n    public int appendCharacters(String s, String t) {\\n        int i= 0, j=0;\\n        char [] charst =t.toCharArray();\\n        char [] charss =s.toCharArray();\\n        while(j<charst.length && i<charss.length){\\n            if(charst[j]==charss[i]){\\n                i++;j++;\\n            }\\n            else if(charst[j]!=charss[i]){\\n                 i++;\\n             }\\n        }\\n        return charst.length-j > 0 ? charst.length-j : 0;\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3692029,
                "title": "simplest-c",
                "content": "\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nTwo pointers :\\nuse a pointer \\'i\\' to track current character of first string and \\'j\\' to track the current character of another string. \\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int appendCharacters(string s, string t) {\\n        int i=0,j=0;\\n        int n=s.length(),m=t.length();\\n        while(i<n && j<m){\\n            if(s[i]==t[j]){\\n                i++;\\n                j++;\\n            }else{\\n                i++;\\n            }\\n        }\\n        return m-j;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int appendCharacters(string s, string t) {\\n        int i=0,j=0;\\n        int n=s.length(),m=t.length();\\n        while(i<n && j<m){\\n            if(s[i]==t[j]){\\n                i++;\\n                j++;\\n            }else{\\n                i++;\\n            }\\n        }\\n        return m-j;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3678089,
                "title": "too-easy-to-handle-python",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\ntake 2 pointers ,one for s and one for t .Check every value(must maintain the sequence) of t if it is present in s .\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:0(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def appendCharacters(self, s: str, t: str) -> int:\\n        i=0\\n        j=0\\n        value=0\\n        while i <len(s) and j<len(t):\\n            if s[i]==t[j]:\\n                i+=1\\n                j+=1\\n                value+=1\\n            else:\\n                i+=1\\n        return (len(t)-value)\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def appendCharacters(self, s: str, t: str) -> int:\\n        i=0\\n        j=0\\n        value=0\\n        while i <len(s) and j<len(t):\\n            if s[i]==t[j]:\\n                i+=1\\n                j+=1\\n                value+=1\\n            else:\\n                i+=1\\n        return (len(t)-value)\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3675210,
                "title": "c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int appendCharacters(string s, string t) {\\n        int ans = 0;\\n        int i=0 , j=0;\\n        while (i<s.length() && j<t.length()){\\n            if (s[i]==t[j])\\n                i++ , j++;\\n            else\\n                i++;\\n        }    \\n        if (j==t.length())\\n            return ans;\\n        \\n        if (i==s.length() && j!=t.length())\\n            ans = t.length()-j;\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int appendCharacters(string s, string t) {\\n        int ans = 0;\\n        int i=0 , j=0;\\n        while (i<s.length() && j<t.length()){\\n            if (s[i]==t[j])\\n                i++ , j++;\\n            else\\n                i++;\\n        }    \\n        if (j==t.length())\\n            return ans;\\n        \\n        if (i==s.length() && j!=t.length())\\n            ans = t.length()-j;\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3673501,
                "title": "straight-forward-approach-with-time-o-n",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int appendCharacters(string s, string t) {\\n        \\n        int j=0;\\n        for(int i=0;i<s.length();i++){\\n            if(t[j]==s[i]){\\n                j++;\\n            }\\n        }\\n        return t.length()-j;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int appendCharacters(string s, string t) {\\n        \\n        int j=0;\\n        for(int i=0;i<s.length();i++){\\n            if(t[j]==s[i]){\\n                j++;\\n            }\\n        }\\n        return t.length()-j;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3671509,
                "title": "easy-simple-small-2-pointer-c",
                "content": "# Intuition\\nSimple two Pointer\\n\\n# Approach\\n1.  2-pointer approach\\n2.  i for string s, j for string t\\n\\n# Complexity\\n- Time complexity:  $$O(m+n)$$ \\n- Space complexity:  $$O(1)$$ \\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int appendCharacters(string s, string t) \\n    {\\n        int i=0;           //i - s iterator\\n        int j=0;           //j - t iterator\\n\\n        while(i<s.size())\\n        {\\n            if(s[i]==t[j])\\n            {\\n                i++;\\n                j++;\\n            }\\n            else if(s[i]!=t[j])\\n            {\\n                i++;\\n            }\\n        }\\n        return t.size()-j;    //elements to append        \\n    }\\n};\\n```\\n![grid_0_640_N.jpg](https://assets.leetcode.com/users/images/77426f97-2ab6-44ba-b493-f1c6b6e50f37_1687478069.99225.png)\\n",
                "solutionTags": [
                    "C++",
                    "Two Pointers",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int appendCharacters(string s, string t) \\n    {\\n        int i=0;           //i - s iterator\\n        int j=0;           //j - t iterator\\n\\n        while(i<s.size())\\n        {\\n            if(s[i]==t[j])\\n            {\\n                i++;\\n                j++;\\n            }\\n            else if(s[i]!=t[j])\\n            {\\n                i++;\\n            }\\n        }\\n        return t.size()-j;    //elements to append        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3671508,
                "title": "easy-simple-small-2-pointer-c",
                "content": "# Intuition\\nSimple two Pointer\\n\\n# Approach\\n1.  2-pointer approach\\n2.  i for string s, j for string t\\n\\n# Complexity\\n- Time complexity:  $$O(m+n)$$ \\n- Space complexity:  $$O(1)$$ \\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int appendCharacters(string s, string t) \\n    {\\n        int i=0;           //i - s iterator\\n        int j=0;           //j - t iterator\\n\\n        while(i<s.size())\\n        {\\n            if(s[i]==t[j])\\n            {\\n                i++;\\n                j++;\\n            }\\n            else if(s[i]!=t[j])\\n            {\\n                i++;\\n            }\\n        }\\n        return t.size()-j;    //elements to append        \\n    }\\n};\\n```\\n![grid_0_640_N.jpg](https://assets.leetcode.com/users/images/77426f97-2ab6-44ba-b493-f1c6b6e50f37_1687478069.99225.png)\\n",
                "solutionTags": [
                    "C++",
                    "Two Pointers",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int appendCharacters(string s, string t) \\n    {\\n        int i=0;           //i - s iterator\\n        int j=0;           //j - t iterator\\n\\n        while(i<s.size())\\n        {\\n            if(s[i]==t[j])\\n            {\\n                i++;\\n                j++;\\n            }\\n            else if(s[i]!=t[j])\\n            {\\n                i++;\\n            }\\n        }\\n        return t.size()-j;    //elements to append        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3664301,
                "title": "c-easy-and-clean-3-lines",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int appendCharacters(string s, string t) {\\n        int j=0;\\n        for(auto i : s)\\n        if(i==t[j])\\n        j++;\\n        return t.size()-j;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int appendCharacters(string s, string t) {\\n        int j=0;\\n        for(auto i : s)\\n        if(i==t[j])\\n        j++;\\n        return t.size()-j;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3663505,
                "title": "simple-python-solution-2-pointers-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution:\\n    def appendCharacters(self, s: str, t: str) -> int:\\n        l, r, chs = 0, 0, len(t)\\n        while l < len(s) and r < len(t):\\n            if s[l] == t[r]:\\n                chs -= 1\\n                r += 1\\n            l += 1\\n        return chs\\n```",
                "solutionTags": [
                    "Python3",
                    "Two Pointers",
                    "Greedy"
                ],
                "code": "```\\nclass Solution:\\n    def appendCharacters(self, s: str, t: str) -> int:\\n        l, r, chs = 0, 0, len(t)\\n        while l < len(s) and r < len(t):\\n            if s[l] == t[r]:\\n                chs -= 1\\n                r += 1\\n            l += 1\\n        return chs\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3658606,
                "title": "c-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int appendCharacters(string s, string t) {\\n        int l=s.size();\\n        int n=t.size();\\n        stack<char> st;\\n        reverse(s.begin(),s.end());\\n        for(int i=0;i<l;i++){\\n            st.push(s[i]);\\n        }\\n        int i=0,val=n;\\n        while(i<n){\\n            char c=t[i];\\n            while(!st.empty()){\\n                char temp=st.top();\\n                st.pop();\\n                if(temp==c){\\n                    val--;\\n                    break;\\n                }\\n            }\\n            i++;\\n        }\\n        return val;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int appendCharacters(string s, string t) {\\n        int l=s.size();\\n        int n=t.size();\\n        stack<char> st;\\n        reverse(s.begin(),s.end());\\n        for(int i=0;i<l;i++){\\n            st.push(s[i]);\\n        }\\n        int i=0,val=n;\\n        while(i<n){\\n            char c=t[i];\\n            while(!st.empty()){\\n                char temp=st.top();\\n                st.pop();\\n                if(temp==c){\\n                    val--;\\n                    break;\\n                }\\n            }\\n            i++;\\n        }\\n        return val;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3657813,
                "title": "python-using-pointers-increments",
                "content": "# Approach\\n- Take two pointers, one for each string, starting at 0\\n- If character at p1 and p2 are same, we increment both.\\n- Else, we increment p1 to see if character at p2 can be matched.\\n- Once done, we were able to conver p2 number of characters in t. The remaining are len(t)-p2\\n\\n# Complexity\\n- Time complexity:\\n$$O(n+m)$$: Where n is len(s) and m is len(t)\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```\\n# Our goal is to make as many characters of t as possible\\n# Find the longest common subsequence and subtract that from len(t)\\n# The above logic fails.\\n# Let\\'s take example: coaching, coding. \\n# LCS = coing(5). len(t) - 5 = 1\\n# Which is wrong.\\n# We need to see how many are matching from left to right\\n\\nclass Solution:\\n    def appendCharacters(self, s: str, t: str) -> int:\\n        p1, p2 = 0,0\\n        while p1 < len(s) and p2 < len(t):\\n            if s[p1] == t[p2]:\\n                p2 += 1\\n            p1 += 1                \\n        return len(t)-p2\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n# Our goal is to make as many characters of t as possible\\n# Find the longest common subsequence and subtract that from len(t)\\n# The above logic fails.\\n# Let\\'s take example: coaching, coding. \\n# LCS = coing(5). len(t) - 5 = 1\\n# Which is wrong.\\n# We need to see how many are matching from left to right\\n\\nclass Solution:\\n    def appendCharacters(self, s: str, t: str) -> int:\\n        p1, p2 = 0,0\\n        while p1 < len(s) and p2 < len(t):\\n            if s[p1] == t[p2]:\\n                p2 += 1\\n            p1 += 1                \\n        return len(t)-p2\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3652630,
                "title": "easy-solution-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nitne easy Code ki approach samjhani pade to bhai tu coding chhod de \\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(max(s.size(),t.size()))\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int appendCharacters(string s, string t) {\\n        int i=0,j=0;\\n        while(i<s.size() && j<t.size())\\n        {\\n            if(s[i]==t[j])\\n            {\\n                j++;\\n            }\\n            i++;\\n        }\\n        return t.size()-j;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int appendCharacters(string s, string t) {\\n        int i=0,j=0;\\n        while(i<s.size() && j<t.size())\\n        {\\n            if(s[i]==t[j])\\n            {\\n                j++;\\n            }\\n            i++;\\n        }\\n        return t.size()-j;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3648641,
                "title": "python-simple-solution-using-greedy",
                "content": "Here is my solution.\\n\\n```\\nclass Solution:\\n    def appendCharacters(self, s: str, t: str) -> int:\\n        index = 0\\n\\n        for char in s:\\n            if index >= len(t):\\n                break\\n\\n            if char == t[index]:\\n                index += 1\\n\\n        return 0 if index >= len(t) else len(t[index:])\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def appendCharacters(self, s: str, t: str) -> int:\\n        index = 0\\n\\n        for char in s:\\n            if index >= len(t):\\n                break\\n\\n            if char == t[index]:\\n                index += 1\\n\\n        return 0 if index >= len(t) else len(t[index:])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3623711,
                "title": "minimum-characters-to-append-for-subsequence-formation",
                "content": "\\n# Code\\n```two\\nvar appendCharacters = function(s, t) {\\n    let j = 0;\\n    for (let i = 0; i < s.length; i++) {\\n        if (s[i] === t[j]) j++;\\n    }\\n    return t.substring(j).length;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Two Pointers",
                    "String",
                    "Greedy"
                ],
                "code": "```two\\nvar appendCharacters = function(s, t) {\\n    let j = 0;\\n    for (let i = 0; i < s.length; i++) {\\n        if (s[i] === t[j]) j++;\\n    }\\n    return t.substring(j).length;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3623252,
                "title": "easy-and-simple-code-and-explanation",
                "content": "# Intuition\\nSimple character matching.\\n\\n# Approach\\nIterate through the string s and match with string t.\\nKeep pointer for t. If matches icrease the pointer.\\n\\n# Complexity\\n- Time complexity:\\nO(N).\\n\\n- Space complexity:\\nO(1).\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int appendCharacters(string s, string t) {\\n        int j = 0;\\n        char c = t[j];\\n        for(int i=0;i<s.size();i++) {\\n            if(s[i] == c) {\\n                j++;\\n                c = t[j];\\n            }\\n        }\\n        return t.size() - j;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int appendCharacters(string s, string t) {\\n        int j = 0;\\n        char c = t[j];\\n        for(int i=0;i<s.size();i++) {\\n            if(s[i] == c) {\\n                j++;\\n                c = t[j];\\n            }\\n        }\\n        return t.size() - j;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3618359,
                "title": "c-easy-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int appendCharacters(string s, string t) {\\n        int ct = t.length();\\n        int tp = 0;\\n        for(int i = 0; i < t.length(); i++)\\n        {\\n            int flag = 0;\\n            for(int j = tp; j < s.length(); j++)\\n            {\\n                if(t[i]==s[j])\\n                {\\n                    tp = j+1;\\n                    ct--;\\n                    flag = 1;\\n                    break;\\n                }\\n            }\\n            if(flag==0) return ct;\\n        }\\n        return ct;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int appendCharacters(string s, string t) {\\n        int ct = t.length();\\n        int tp = 0;\\n        for(int i = 0; i < t.length(); i++)\\n        {\\n            int flag = 0;\\n            for(int j = tp; j < s.length(); j++)\\n            {\\n                if(t[i]==s[j])\\n                {\\n                    tp = j+1;\\n                    ct--;\\n                    flag = 1;\\n                    break;\\n                }\\n            }\\n            if(flag==0) return ct;\\n        }\\n        return ct;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3616308,
                "title": "python3-very-simple-solution",
                "content": "# Code\\n```\\nclass Solution:\\n    def appendCharacters(self, s: str, t: str) -> int:\\n        i = 0\\n        j = 0\\n\\n        while i<len(s) and j<len(t):\\n            if s[i]==t[j]:\\n                i+=1\\n                j+=1\\n            else:\\n                i+=1\\n        \\n        return len(t)-j\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def appendCharacters(self, s: str, t: str) -> int:\\n        i = 0\\n        j = 0\\n\\n        while i<len(s) and j<len(t):\\n            if s[i]==t[j]:\\n                i+=1\\n                j+=1\\n            else:\\n                i+=1\\n        \\n        return len(t)-j\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3557392,
                "title": "c-approach-by-decrementing-length-of-string-t",
                "content": "# Approach\\nBecause string t is being appended to string s, the maximum value that can be returned would be the length of string t, and the minimum would be 0. \\n\\nDeclare a variable tLen for the length of string t. Compare the characters between strings s and t, starting from indices of 0. If they are the same, we move to the right for both strings by incrementing the indices and decrement tLen. Otherwise, we only move to the right for string s. This way, we eliminate the \\'duplicate\\' characters to find the minimum number of characters for the subsequence. \\n\\nWe can assert that tLen would never be decremented below 0, assuming this would happen if the length of string s, sLen, is more than tLen. If we decremented tLen all the way to 0, t[tPos] == \\'\\\\0\\', so the if statement is skipped and tLen would not be further decremented below 0.\\n\\nFeel free to comment on how my code can be improved!\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int appendCharacters(string s, string t) {\\n        int tLen = t.size();\\n        int tPos = 0;\\n        for (char c : s) {\\n            if (c == t[tPos]) {\\n                tLen--;\\n                tPos++;\\n            }\\n        }\\n        return tLen;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int appendCharacters(string s, string t) {\\n        int tLen = t.size();\\n        int tPos = 0;\\n        for (char c : s) {\\n            if (c == t[tPos]) {\\n                tLen--;\\n                tPos++;\\n            }\\n        }\\n        return tLen;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3555259,
                "title": "js-simple-commented",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {string} s\\n * @param {string} t\\n * @return {number}\\n */\\nvar appendCharacters = function(s, t) {\\n    let sPointer = 0;\\n    let tPointer = 0;\\n\\n    while (sPointer < s.length && tPointer < t.length) {\\n        // If there\\'s a match, you covered a letter of the subsequence\\n        if (s[sPointer] === t[tPointer]) {\\n            sPointer++;\\n            tPointer++;\\n        // Otherwise, keep looking for the same letter in the remainder of s\\n        } else {\\n            sPointer++;\\n        }\\n    }\\n\\n    // In the end, the tPointer will point at the start of the subsequence that we were unable to match\\n    // Return the length of that subsequence\\n    return t.length - tPointer;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string} s\\n * @param {string} t\\n * @return {number}\\n */\\nvar appendCharacters = function(s, t) {\\n    let sPointer = 0;\\n    let tPointer = 0;\\n\\n    while (sPointer < s.length && tPointer < t.length) {\\n        // If there\\'s a match, you covered a letter of the subsequence\\n        if (s[sPointer] === t[tPointer]) {\\n            sPointer++;\\n            tPointer++;\\n        // Otherwise, keep looking for the same letter in the remainder of s\\n        } else {\\n            sPointer++;\\n        }\\n    }\\n\\n    // In the end, the tPointer will point at the start of the subsequence that we were unable to match\\n    // Return the length of that subsequence\\n    return t.length - tPointer;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3554562,
                "title": "c-solution",
                "content": "# CODE\\n```\\nclass Solution {\\npublic:\\n    int appendCharacters(string s, string t) {\\n        int i = 0, j = 0;\\n        int n = s.size(), m = t.size();\\n\\n        while(i < n and j < m) {\\n            if(s[i] == t[j]) i++, j++;\\n            else i++;\\n        }\\n\\n        return t.substr(j).size();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int appendCharacters(string s, string t) {\\n        int i = 0, j = 0;\\n        int n = s.size(), m = t.size();\\n\\n        while(i < n and j < m) {\\n            if(s[i] == t[j]) i++, j++;\\n            else i++;\\n        }\\n\\n        return t.substr(j).size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3544719,
                "title": "chopping-the-t-away",
                "content": "# Approach\\nslice s each time we find first occurenace of char from t\\n\\n# Complexity\\n- Time complexity: \\nO(n)\\n\\n- Space complexity: \\nO(1)\\n\\n# Code\\n```\\nclass Solution(object):\\n    def appendCharacters(self, s, t):\\n        \"\"\"\\n        :type s: str\\n        :type t: str\\n        :rtype: int\\n        \"\"\"\\n\\n        if s == t:\\n            return 0\\n\\n        for i, c in enumerate(t[:len(s)]):\\n            c_index = s.find(c)\\n            if c_index > -1:\\n                s = s[c_index+1:]\\n            else:\\n                return len(t) - i\\n        return 0\\n                \\n\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def appendCharacters(self, s, t):\\n        \"\"\"\\n        :type s: str\\n        :type t: str\\n        :rtype: int\\n        \"\"\"\\n\\n        if s == t:\\n            return 0\\n\\n        for i, c in enumerate(t[:len(s)]):\\n            c_index = s.find(c)\\n            if c_index > -1:\\n                s = s[c_index+1:]\\n            else:\\n                return len(t) - i\\n        return 0\\n                \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3541913,
                "title": "cant-get-easier",
                "content": "# Intuition\\n<!-- First we need to cleary understand what subsequence is -->\\n\\n# Approach\\n<!-- Find how many characters are already part of the given string.\\n     Add the remaining elements to the string.\\n -->\\n\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int appendCharacters(string s, string t) \\n    {\\n        int j=0;\\n        for(int i=0;i<s.size();i++)\\n        {\\n            if(s[i]==t[j])  j++;\\n        }\\n        return t.size()-j;    \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int appendCharacters(string s, string t) \\n    {\\n        int j=0;\\n        for(int i=0;i<s.size();i++)\\n        {\\n            if(s[i]==t[j])  j++;\\n        }\\n        return t.size()-j;    \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3533071,
                "title": "easy-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int appendCharacters(string s, string t) {\\n        //string matching\\n        int j= 0;\\n        \\n        int n = t.size(), cnt = 0;   //this much we have to match\\n        for(int i=0; i<s.size(); i++){\\n            // cout<<s[i]<<\" \"<<t[j]<<endl;\\n            //check how many char are matching\\n            while(i<s.size() && j<t.size() && s[i] == t[j]){\\n                cnt++;\\n                i++; j++;\\n            }\\n                \\n        }\\n        \\n       //total - matched\\n        return n-cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int appendCharacters(string s, string t) {\\n        //string matching\\n        int j= 0;\\n        \\n        int n = t.size(), cnt = 0;   //this much we have to match\\n        for(int i=0; i<s.size(); i++){\\n            // cout<<s[i]<<\" \"<<t[j]<<endl;\\n            //check how many char are matching\\n            while(i<s.size() && j<t.size() && s[i] == t[j]){\\n                cnt++;\\n                i++; j++;\\n            }\\n                \\n        }\\n        \\n       //total - matched\\n        return n-cnt;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3531345,
                "title": "java-6ms-85-and-clear-explanations",
                "content": "# Approach\\n 1. In order for t to be a subsequence of s, all character of t need to be found in s in the given order.\\n2. Traverse s and t with i and j and advance j only if s[i] == t[j].\\n3. At the end, check how far j has reached. If it reached the end of t, it means all the chars have ben found in the order they are in t, \\n    - Else, t.length() - j chars still need to be appended.\\n\\n# Complexity\\n- Time complexity:$$O(s+t)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int appendCharacters(String s, String t) {\\n        int i = 0, j = 0;\\n        while (i < s.length() && j < t.length()) {\\n            if (s.charAt(i) == t.charAt(j)) {\\n                j++;\\n            }\\n            i++;\\n        }\\n        return t.length() - j;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int appendCharacters(String s, String t) {\\n        int i = 0, j = 0;\\n        while (i < s.length() && j < t.length()) {\\n            if (s.charAt(i) == t.charAt(j)) {\\n                j++;\\n            }\\n            i++;\\n        }\\n        return t.length() - j;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3526555,
                "title": "js-javascript-simple-solution",
                "content": "\\n# Code\\n```\\n/**\\n * @param {string} s\\n * @param {string} t\\n * @return {number}\\n */\\nvar appendCharacters = function(s, t) {\\n    let curr = 0\\n    let i = 0\\n    while(curr < t.length && i < s.length){\\n        if (s[i] === t[curr]) curr++\\n        i++\\n    }\\n    return t.length - curr\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string} s\\n * @param {string} t\\n * @return {number}\\n */\\nvar appendCharacters = function(s, t) {\\n    let curr = 0\\n    let i = 0\\n    while(curr < t.length && i < s.length){\\n        if (s[i] === t[curr]) curr++\\n        i++\\n    }\\n    return t.length - curr\\n};\\n```",
                "codeTag": "Unknown"
            }
        ],
        "discussions": [
            {
                "id": 1699934,
                "content": [
                    {
                        "username": "Imperial_Lord",
                        "content": "Seriously, this is toooo easy to be ranked medium"
                    },
                    {
                        "username": "jain_gaurav",
                        "content": "i encountered this question in OA of Amazon."
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "u\\'ve aced it!"
                    },
                    {
                        "username": "sabonett",
                        "content": "Return the minimum number of characters that need to be `appended to the end of s` so that t becomes a subsequence of s. How t become substring of s by appending only two characters?\n\nInput:\n`s = \"ajkhe\"`\n`t = \"juh\"`\n`Output 3`\n`Expected 2`\n"
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "Its not substring.. its needs to be a Subsequence"
                    },
                    {
                        "username": "vaibh_1406",
                        "content": "because \\'j\\' already exists and you need to insert only two characters i.e \\'u\\' and \\'h\\'..!!"
                    },
                    {
                        "username": "GhostInDanger",
                        "content": " test case :https://drive.google.com/file/d/1fI0OiWFtJyRtAaPUgm-4eVn86XEq3Q09/view?usp=sharing\noutput= 96017\nExpected  output =96063 how to debug and check existing code  78 test case are passed"
                    },
                    {
                        "username": "JustinMei",
                        "content": "Thanks for your test case! It helped me a lot."
                    },
                    {
                        "username": "upretim",
                        "content": "prev =x+1; will fix this one, actually we need to search for next+1 index and not next, for details, please have a look at my JavaScript solution at line no 12\\n\\n"
                    },
                    {
                        "username": "gattemvenkatalakshmi",
                        "content": "same what is ur code "
                    },
                    {
                        "username": "nhienlh94",
                        "content": "It\\'s so simple to be a medium question, crazy"
                    },
                    {
                        "username": "yuangaonyc",
                        "content": "Why is this medium? "
                    },
                    {
                        "username": "MichaelChan2417",
                        "content": "should be labeled EZ\\n"
                    },
                    {
                        "username": "vaibh_1406",
                        "content": "where is my code wrong, can anyone please suggest me ?? (PYTHON 3)\\n\\nclass Solution:\\n    def appendCharacters(self, s: str, t: str) -> int:\\n        res = \\'\\'\\n\\n        for i in range(len(t)):\\n            if t[i] in s:\\n                res+=t[i]\\n            else:\\n                break\\n        return (len(t) -len(res))"
                    },
                    {
                        "username": "magnusbarata",
                        "content": "A subsequence must keep the original order of appearance, while the `t[i] in s` part in your code will evaluate to `True` regardless of order in s.\\nFor the simplest case, your code will fail given the input `s=\"ab\", t=\"ba\"`. For this input, your code will return 0 (i.e every element on t exist on s, without thinking the order of appearance in s), while the expected result will be 1 (i.e. s should be \"aba\", so that t is a subsequence of s)."
                    },
                    {
                        "username": "Krishrx",
                        "content": "[@Vaibhav Verma](/vaibh_1406) I am not a python guy but according to my understanding from ur code ,ur code fails for the testcase where s=\"abcde\" t=\"abab\"  ur o/p=0 expected o/p = 2\\nthe code doesnt check for duplicates where we need to make s as abcdeab,I think u need to rewrite ur logic.\\nkindly check my java solution if u are comfortable with java\\nhttps://leetcode.com/problems/append-characters-to-string-to-make-subsequence/solutions/3749270/simple-java-solution/"
                    },
                    {
                        "username": "kmp1084",
                        "content": "gave me a chance to realize why 1143. Longest Common Subsequence cannot be used to solve this problem."
                    },
                    {
                        "username": "gattemvenkatalakshmi",
                        "content": "can anyone tell why this is wrong 78 test cases were passed\n  \n\nint i =0;\n          int prev =  s.indexOf(t.charAt(i));\n           i++;\n           if( prev ==-1)\n            return t.length();\n              while( i<t.length()){\n                   int x= s.indexOf(t.charAt(i),prev);\n                    if( x ==-1)\n                     return t.length()-i;\n                      prev =x;\n                  i++;\n              } \n               return 0;"
                    },
                    {
                        "username": "upretim",
                        "content": "prev =x+1; will fix this one, actually we need to search for next+1 index and not next,  for details, please have a look at my JavaScript solution at line no 12"
                    },
                    {
                        "username": "GhostInDanger",
                        "content": "same problem I  am facing "
                    }
                ]
            },
            {
                "id": 1795766,
                "content": [
                    {
                        "username": "Imperial_Lord",
                        "content": "Seriously, this is toooo easy to be ranked medium"
                    },
                    {
                        "username": "jain_gaurav",
                        "content": "i encountered this question in OA of Amazon."
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "u\\'ve aced it!"
                    },
                    {
                        "username": "sabonett",
                        "content": "Return the minimum number of characters that need to be `appended to the end of s` so that t becomes a subsequence of s. How t become substring of s by appending only two characters?\n\nInput:\n`s = \"ajkhe\"`\n`t = \"juh\"`\n`Output 3`\n`Expected 2`\n"
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "Its not substring.. its needs to be a Subsequence"
                    },
                    {
                        "username": "vaibh_1406",
                        "content": "because \\'j\\' already exists and you need to insert only two characters i.e \\'u\\' and \\'h\\'..!!"
                    },
                    {
                        "username": "GhostInDanger",
                        "content": " test case :https://drive.google.com/file/d/1fI0OiWFtJyRtAaPUgm-4eVn86XEq3Q09/view?usp=sharing\noutput= 96017\nExpected  output =96063 how to debug and check existing code  78 test case are passed"
                    },
                    {
                        "username": "JustinMei",
                        "content": "Thanks for your test case! It helped me a lot."
                    },
                    {
                        "username": "upretim",
                        "content": "prev =x+1; will fix this one, actually we need to search for next+1 index and not next, for details, please have a look at my JavaScript solution at line no 12\\n\\n"
                    },
                    {
                        "username": "gattemvenkatalakshmi",
                        "content": "same what is ur code "
                    },
                    {
                        "username": "nhienlh94",
                        "content": "It\\'s so simple to be a medium question, crazy"
                    },
                    {
                        "username": "yuangaonyc",
                        "content": "Why is this medium? "
                    },
                    {
                        "username": "MichaelChan2417",
                        "content": "should be labeled EZ\\n"
                    },
                    {
                        "username": "vaibh_1406",
                        "content": "where is my code wrong, can anyone please suggest me ?? (PYTHON 3)\\n\\nclass Solution:\\n    def appendCharacters(self, s: str, t: str) -> int:\\n        res = \\'\\'\\n\\n        for i in range(len(t)):\\n            if t[i] in s:\\n                res+=t[i]\\n            else:\\n                break\\n        return (len(t) -len(res))"
                    },
                    {
                        "username": "magnusbarata",
                        "content": "A subsequence must keep the original order of appearance, while the `t[i] in s` part in your code will evaluate to `True` regardless of order in s.\\nFor the simplest case, your code will fail given the input `s=\"ab\", t=\"ba\"`. For this input, your code will return 0 (i.e every element on t exist on s, without thinking the order of appearance in s), while the expected result will be 1 (i.e. s should be \"aba\", so that t is a subsequence of s)."
                    },
                    {
                        "username": "Krishrx",
                        "content": "[@Vaibhav Verma](/vaibh_1406) I am not a python guy but according to my understanding from ur code ,ur code fails for the testcase where s=\"abcde\" t=\"abab\"  ur o/p=0 expected o/p = 2\\nthe code doesnt check for duplicates where we need to make s as abcdeab,I think u need to rewrite ur logic.\\nkindly check my java solution if u are comfortable with java\\nhttps://leetcode.com/problems/append-characters-to-string-to-make-subsequence/solutions/3749270/simple-java-solution/"
                    },
                    {
                        "username": "kmp1084",
                        "content": "gave me a chance to realize why 1143. Longest Common Subsequence cannot be used to solve this problem."
                    },
                    {
                        "username": "gattemvenkatalakshmi",
                        "content": "can anyone tell why this is wrong 78 test cases were passed\n  \n\nint i =0;\n          int prev =  s.indexOf(t.charAt(i));\n           i++;\n           if( prev ==-1)\n            return t.length();\n              while( i<t.length()){\n                   int x= s.indexOf(t.charAt(i),prev);\n                    if( x ==-1)\n                     return t.length()-i;\n                      prev =x;\n                  i++;\n              } \n               return 0;"
                    },
                    {
                        "username": "upretim",
                        "content": "prev =x+1; will fix this one, actually we need to search for next+1 index and not next,  for details, please have a look at my JavaScript solution at line no 12"
                    },
                    {
                        "username": "GhostInDanger",
                        "content": "same problem I  am facing "
                    }
                ]
            },
            {
                "id": 1763418,
                "content": [
                    {
                        "username": "Imperial_Lord",
                        "content": "Seriously, this is toooo easy to be ranked medium"
                    },
                    {
                        "username": "jain_gaurav",
                        "content": "i encountered this question in OA of Amazon."
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "u\\'ve aced it!"
                    },
                    {
                        "username": "sabonett",
                        "content": "Return the minimum number of characters that need to be `appended to the end of s` so that t becomes a subsequence of s. How t become substring of s by appending only two characters?\n\nInput:\n`s = \"ajkhe\"`\n`t = \"juh\"`\n`Output 3`\n`Expected 2`\n"
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "Its not substring.. its needs to be a Subsequence"
                    },
                    {
                        "username": "vaibh_1406",
                        "content": "because \\'j\\' already exists and you need to insert only two characters i.e \\'u\\' and \\'h\\'..!!"
                    },
                    {
                        "username": "GhostInDanger",
                        "content": " test case :https://drive.google.com/file/d/1fI0OiWFtJyRtAaPUgm-4eVn86XEq3Q09/view?usp=sharing\noutput= 96017\nExpected  output =96063 how to debug and check existing code  78 test case are passed"
                    },
                    {
                        "username": "JustinMei",
                        "content": "Thanks for your test case! It helped me a lot."
                    },
                    {
                        "username": "upretim",
                        "content": "prev =x+1; will fix this one, actually we need to search for next+1 index and not next, for details, please have a look at my JavaScript solution at line no 12\\n\\n"
                    },
                    {
                        "username": "gattemvenkatalakshmi",
                        "content": "same what is ur code "
                    },
                    {
                        "username": "nhienlh94",
                        "content": "It\\'s so simple to be a medium question, crazy"
                    },
                    {
                        "username": "yuangaonyc",
                        "content": "Why is this medium? "
                    },
                    {
                        "username": "MichaelChan2417",
                        "content": "should be labeled EZ\\n"
                    },
                    {
                        "username": "vaibh_1406",
                        "content": "where is my code wrong, can anyone please suggest me ?? (PYTHON 3)\\n\\nclass Solution:\\n    def appendCharacters(self, s: str, t: str) -> int:\\n        res = \\'\\'\\n\\n        for i in range(len(t)):\\n            if t[i] in s:\\n                res+=t[i]\\n            else:\\n                break\\n        return (len(t) -len(res))"
                    },
                    {
                        "username": "magnusbarata",
                        "content": "A subsequence must keep the original order of appearance, while the `t[i] in s` part in your code will evaluate to `True` regardless of order in s.\\nFor the simplest case, your code will fail given the input `s=\"ab\", t=\"ba\"`. For this input, your code will return 0 (i.e every element on t exist on s, without thinking the order of appearance in s), while the expected result will be 1 (i.e. s should be \"aba\", so that t is a subsequence of s)."
                    },
                    {
                        "username": "Krishrx",
                        "content": "[@Vaibhav Verma](/vaibh_1406) I am not a python guy but according to my understanding from ur code ,ur code fails for the testcase where s=\"abcde\" t=\"abab\"  ur o/p=0 expected o/p = 2\\nthe code doesnt check for duplicates where we need to make s as abcdeab,I think u need to rewrite ur logic.\\nkindly check my java solution if u are comfortable with java\\nhttps://leetcode.com/problems/append-characters-to-string-to-make-subsequence/solutions/3749270/simple-java-solution/"
                    },
                    {
                        "username": "kmp1084",
                        "content": "gave me a chance to realize why 1143. Longest Common Subsequence cannot be used to solve this problem."
                    },
                    {
                        "username": "gattemvenkatalakshmi",
                        "content": "can anyone tell why this is wrong 78 test cases were passed\n  \n\nint i =0;\n          int prev =  s.indexOf(t.charAt(i));\n           i++;\n           if( prev ==-1)\n            return t.length();\n              while( i<t.length()){\n                   int x= s.indexOf(t.charAt(i),prev);\n                    if( x ==-1)\n                     return t.length()-i;\n                      prev =x;\n                  i++;\n              } \n               return 0;"
                    },
                    {
                        "username": "upretim",
                        "content": "prev =x+1; will fix this one, actually we need to search for next+1 index and not next,  for details, please have a look at my JavaScript solution at line no 12"
                    },
                    {
                        "username": "GhostInDanger",
                        "content": "same problem I  am facing "
                    }
                ]
            },
            {
                "id": 1702930,
                "content": [
                    {
                        "username": "Imperial_Lord",
                        "content": "Seriously, this is toooo easy to be ranked medium"
                    },
                    {
                        "username": "jain_gaurav",
                        "content": "i encountered this question in OA of Amazon."
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "u\\'ve aced it!"
                    },
                    {
                        "username": "sabonett",
                        "content": "Return the minimum number of characters that need to be `appended to the end of s` so that t becomes a subsequence of s. How t become substring of s by appending only two characters?\n\nInput:\n`s = \"ajkhe\"`\n`t = \"juh\"`\n`Output 3`\n`Expected 2`\n"
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "Its not substring.. its needs to be a Subsequence"
                    },
                    {
                        "username": "vaibh_1406",
                        "content": "because \\'j\\' already exists and you need to insert only two characters i.e \\'u\\' and \\'h\\'..!!"
                    },
                    {
                        "username": "GhostInDanger",
                        "content": " test case :https://drive.google.com/file/d/1fI0OiWFtJyRtAaPUgm-4eVn86XEq3Q09/view?usp=sharing\noutput= 96017\nExpected  output =96063 how to debug and check existing code  78 test case are passed"
                    },
                    {
                        "username": "JustinMei",
                        "content": "Thanks for your test case! It helped me a lot."
                    },
                    {
                        "username": "upretim",
                        "content": "prev =x+1; will fix this one, actually we need to search for next+1 index and not next, for details, please have a look at my JavaScript solution at line no 12\\n\\n"
                    },
                    {
                        "username": "gattemvenkatalakshmi",
                        "content": "same what is ur code "
                    },
                    {
                        "username": "nhienlh94",
                        "content": "It\\'s so simple to be a medium question, crazy"
                    },
                    {
                        "username": "yuangaonyc",
                        "content": "Why is this medium? "
                    },
                    {
                        "username": "MichaelChan2417",
                        "content": "should be labeled EZ\\n"
                    },
                    {
                        "username": "vaibh_1406",
                        "content": "where is my code wrong, can anyone please suggest me ?? (PYTHON 3)\\n\\nclass Solution:\\n    def appendCharacters(self, s: str, t: str) -> int:\\n        res = \\'\\'\\n\\n        for i in range(len(t)):\\n            if t[i] in s:\\n                res+=t[i]\\n            else:\\n                break\\n        return (len(t) -len(res))"
                    },
                    {
                        "username": "magnusbarata",
                        "content": "A subsequence must keep the original order of appearance, while the `t[i] in s` part in your code will evaluate to `True` regardless of order in s.\\nFor the simplest case, your code will fail given the input `s=\"ab\", t=\"ba\"`. For this input, your code will return 0 (i.e every element on t exist on s, without thinking the order of appearance in s), while the expected result will be 1 (i.e. s should be \"aba\", so that t is a subsequence of s)."
                    },
                    {
                        "username": "Krishrx",
                        "content": "[@Vaibhav Verma](/vaibh_1406) I am not a python guy but according to my understanding from ur code ,ur code fails for the testcase where s=\"abcde\" t=\"abab\"  ur o/p=0 expected o/p = 2\\nthe code doesnt check for duplicates where we need to make s as abcdeab,I think u need to rewrite ur logic.\\nkindly check my java solution if u are comfortable with java\\nhttps://leetcode.com/problems/append-characters-to-string-to-make-subsequence/solutions/3749270/simple-java-solution/"
                    },
                    {
                        "username": "kmp1084",
                        "content": "gave me a chance to realize why 1143. Longest Common Subsequence cannot be used to solve this problem."
                    },
                    {
                        "username": "gattemvenkatalakshmi",
                        "content": "can anyone tell why this is wrong 78 test cases were passed\n  \n\nint i =0;\n          int prev =  s.indexOf(t.charAt(i));\n           i++;\n           if( prev ==-1)\n            return t.length();\n              while( i<t.length()){\n                   int x= s.indexOf(t.charAt(i),prev);\n                    if( x ==-1)\n                     return t.length()-i;\n                      prev =x;\n                  i++;\n              } \n               return 0;"
                    },
                    {
                        "username": "upretim",
                        "content": "prev =x+1; will fix this one, actually we need to search for next+1 index and not next,  for details, please have a look at my JavaScript solution at line no 12"
                    },
                    {
                        "username": "GhostInDanger",
                        "content": "same problem I  am facing "
                    }
                ]
            },
            {
                "id": 2056064,
                "content": [
                    {
                        "username": "Imperial_Lord",
                        "content": "Seriously, this is toooo easy to be ranked medium"
                    },
                    {
                        "username": "jain_gaurav",
                        "content": "i encountered this question in OA of Amazon."
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "u\\'ve aced it!"
                    },
                    {
                        "username": "sabonett",
                        "content": "Return the minimum number of characters that need to be `appended to the end of s` so that t becomes a subsequence of s. How t become substring of s by appending only two characters?\n\nInput:\n`s = \"ajkhe\"`\n`t = \"juh\"`\n`Output 3`\n`Expected 2`\n"
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "Its not substring.. its needs to be a Subsequence"
                    },
                    {
                        "username": "vaibh_1406",
                        "content": "because \\'j\\' already exists and you need to insert only two characters i.e \\'u\\' and \\'h\\'..!!"
                    },
                    {
                        "username": "GhostInDanger",
                        "content": " test case :https://drive.google.com/file/d/1fI0OiWFtJyRtAaPUgm-4eVn86XEq3Q09/view?usp=sharing\noutput= 96017\nExpected  output =96063 how to debug and check existing code  78 test case are passed"
                    },
                    {
                        "username": "JustinMei",
                        "content": "Thanks for your test case! It helped me a lot."
                    },
                    {
                        "username": "upretim",
                        "content": "prev =x+1; will fix this one, actually we need to search for next+1 index and not next, for details, please have a look at my JavaScript solution at line no 12\\n\\n"
                    },
                    {
                        "username": "gattemvenkatalakshmi",
                        "content": "same what is ur code "
                    },
                    {
                        "username": "nhienlh94",
                        "content": "It\\'s so simple to be a medium question, crazy"
                    },
                    {
                        "username": "yuangaonyc",
                        "content": "Why is this medium? "
                    },
                    {
                        "username": "MichaelChan2417",
                        "content": "should be labeled EZ\\n"
                    },
                    {
                        "username": "vaibh_1406",
                        "content": "where is my code wrong, can anyone please suggest me ?? (PYTHON 3)\\n\\nclass Solution:\\n    def appendCharacters(self, s: str, t: str) -> int:\\n        res = \\'\\'\\n\\n        for i in range(len(t)):\\n            if t[i] in s:\\n                res+=t[i]\\n            else:\\n                break\\n        return (len(t) -len(res))"
                    },
                    {
                        "username": "magnusbarata",
                        "content": "A subsequence must keep the original order of appearance, while the `t[i] in s` part in your code will evaluate to `True` regardless of order in s.\\nFor the simplest case, your code will fail given the input `s=\"ab\", t=\"ba\"`. For this input, your code will return 0 (i.e every element on t exist on s, without thinking the order of appearance in s), while the expected result will be 1 (i.e. s should be \"aba\", so that t is a subsequence of s)."
                    },
                    {
                        "username": "Krishrx",
                        "content": "[@Vaibhav Verma](/vaibh_1406) I am not a python guy but according to my understanding from ur code ,ur code fails for the testcase where s=\"abcde\" t=\"abab\"  ur o/p=0 expected o/p = 2\\nthe code doesnt check for duplicates where we need to make s as abcdeab,I think u need to rewrite ur logic.\\nkindly check my java solution if u are comfortable with java\\nhttps://leetcode.com/problems/append-characters-to-string-to-make-subsequence/solutions/3749270/simple-java-solution/"
                    },
                    {
                        "username": "kmp1084",
                        "content": "gave me a chance to realize why 1143. Longest Common Subsequence cannot be used to solve this problem."
                    },
                    {
                        "username": "gattemvenkatalakshmi",
                        "content": "can anyone tell why this is wrong 78 test cases were passed\n  \n\nint i =0;\n          int prev =  s.indexOf(t.charAt(i));\n           i++;\n           if( prev ==-1)\n            return t.length();\n              while( i<t.length()){\n                   int x= s.indexOf(t.charAt(i),prev);\n                    if( x ==-1)\n                     return t.length()-i;\n                      prev =x;\n                  i++;\n              } \n               return 0;"
                    },
                    {
                        "username": "upretim",
                        "content": "prev =x+1; will fix this one, actually we need to search for next+1 index and not next,  for details, please have a look at my JavaScript solution at line no 12"
                    },
                    {
                        "username": "GhostInDanger",
                        "content": "same problem I  am facing "
                    }
                ]
            },
            {
                "id": 2042362,
                "content": [
                    {
                        "username": "Imperial_Lord",
                        "content": "Seriously, this is toooo easy to be ranked medium"
                    },
                    {
                        "username": "jain_gaurav",
                        "content": "i encountered this question in OA of Amazon."
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "u\\'ve aced it!"
                    },
                    {
                        "username": "sabonett",
                        "content": "Return the minimum number of characters that need to be `appended to the end of s` so that t becomes a subsequence of s. How t become substring of s by appending only two characters?\n\nInput:\n`s = \"ajkhe\"`\n`t = \"juh\"`\n`Output 3`\n`Expected 2`\n"
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "Its not substring.. its needs to be a Subsequence"
                    },
                    {
                        "username": "vaibh_1406",
                        "content": "because \\'j\\' already exists and you need to insert only two characters i.e \\'u\\' and \\'h\\'..!!"
                    },
                    {
                        "username": "GhostInDanger",
                        "content": " test case :https://drive.google.com/file/d/1fI0OiWFtJyRtAaPUgm-4eVn86XEq3Q09/view?usp=sharing\noutput= 96017\nExpected  output =96063 how to debug and check existing code  78 test case are passed"
                    },
                    {
                        "username": "JustinMei",
                        "content": "Thanks for your test case! It helped me a lot."
                    },
                    {
                        "username": "upretim",
                        "content": "prev =x+1; will fix this one, actually we need to search for next+1 index and not next, for details, please have a look at my JavaScript solution at line no 12\\n\\n"
                    },
                    {
                        "username": "gattemvenkatalakshmi",
                        "content": "same what is ur code "
                    },
                    {
                        "username": "nhienlh94",
                        "content": "It\\'s so simple to be a medium question, crazy"
                    },
                    {
                        "username": "yuangaonyc",
                        "content": "Why is this medium? "
                    },
                    {
                        "username": "MichaelChan2417",
                        "content": "should be labeled EZ\\n"
                    },
                    {
                        "username": "vaibh_1406",
                        "content": "where is my code wrong, can anyone please suggest me ?? (PYTHON 3)\\n\\nclass Solution:\\n    def appendCharacters(self, s: str, t: str) -> int:\\n        res = \\'\\'\\n\\n        for i in range(len(t)):\\n            if t[i] in s:\\n                res+=t[i]\\n            else:\\n                break\\n        return (len(t) -len(res))"
                    },
                    {
                        "username": "magnusbarata",
                        "content": "A subsequence must keep the original order of appearance, while the `t[i] in s` part in your code will evaluate to `True` regardless of order in s.\\nFor the simplest case, your code will fail given the input `s=\"ab\", t=\"ba\"`. For this input, your code will return 0 (i.e every element on t exist on s, without thinking the order of appearance in s), while the expected result will be 1 (i.e. s should be \"aba\", so that t is a subsequence of s)."
                    },
                    {
                        "username": "Krishrx",
                        "content": "[@Vaibhav Verma](/vaibh_1406) I am not a python guy but according to my understanding from ur code ,ur code fails for the testcase where s=\"abcde\" t=\"abab\"  ur o/p=0 expected o/p = 2\\nthe code doesnt check for duplicates where we need to make s as abcdeab,I think u need to rewrite ur logic.\\nkindly check my java solution if u are comfortable with java\\nhttps://leetcode.com/problems/append-characters-to-string-to-make-subsequence/solutions/3749270/simple-java-solution/"
                    },
                    {
                        "username": "kmp1084",
                        "content": "gave me a chance to realize why 1143. Longest Common Subsequence cannot be used to solve this problem."
                    },
                    {
                        "username": "gattemvenkatalakshmi",
                        "content": "can anyone tell why this is wrong 78 test cases were passed\n  \n\nint i =0;\n          int prev =  s.indexOf(t.charAt(i));\n           i++;\n           if( prev ==-1)\n            return t.length();\n              while( i<t.length()){\n                   int x= s.indexOf(t.charAt(i),prev);\n                    if( x ==-1)\n                     return t.length()-i;\n                      prev =x;\n                  i++;\n              } \n               return 0;"
                    },
                    {
                        "username": "upretim",
                        "content": "prev =x+1; will fix this one, actually we need to search for next+1 index and not next,  for details, please have a look at my JavaScript solution at line no 12"
                    },
                    {
                        "username": "GhostInDanger",
                        "content": "same problem I  am facing "
                    }
                ]
            },
            {
                "id": 2023664,
                "content": [
                    {
                        "username": "Imperial_Lord",
                        "content": "Seriously, this is toooo easy to be ranked medium"
                    },
                    {
                        "username": "jain_gaurav",
                        "content": "i encountered this question in OA of Amazon."
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "u\\'ve aced it!"
                    },
                    {
                        "username": "sabonett",
                        "content": "Return the minimum number of characters that need to be `appended to the end of s` so that t becomes a subsequence of s. How t become substring of s by appending only two characters?\n\nInput:\n`s = \"ajkhe\"`\n`t = \"juh\"`\n`Output 3`\n`Expected 2`\n"
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "Its not substring.. its needs to be a Subsequence"
                    },
                    {
                        "username": "vaibh_1406",
                        "content": "because \\'j\\' already exists and you need to insert only two characters i.e \\'u\\' and \\'h\\'..!!"
                    },
                    {
                        "username": "GhostInDanger",
                        "content": " test case :https://drive.google.com/file/d/1fI0OiWFtJyRtAaPUgm-4eVn86XEq3Q09/view?usp=sharing\noutput= 96017\nExpected  output =96063 how to debug and check existing code  78 test case are passed"
                    },
                    {
                        "username": "JustinMei",
                        "content": "Thanks for your test case! It helped me a lot."
                    },
                    {
                        "username": "upretim",
                        "content": "prev =x+1; will fix this one, actually we need to search for next+1 index and not next, for details, please have a look at my JavaScript solution at line no 12\\n\\n"
                    },
                    {
                        "username": "gattemvenkatalakshmi",
                        "content": "same what is ur code "
                    },
                    {
                        "username": "nhienlh94",
                        "content": "It\\'s so simple to be a medium question, crazy"
                    },
                    {
                        "username": "yuangaonyc",
                        "content": "Why is this medium? "
                    },
                    {
                        "username": "MichaelChan2417",
                        "content": "should be labeled EZ\\n"
                    },
                    {
                        "username": "vaibh_1406",
                        "content": "where is my code wrong, can anyone please suggest me ?? (PYTHON 3)\\n\\nclass Solution:\\n    def appendCharacters(self, s: str, t: str) -> int:\\n        res = \\'\\'\\n\\n        for i in range(len(t)):\\n            if t[i] in s:\\n                res+=t[i]\\n            else:\\n                break\\n        return (len(t) -len(res))"
                    },
                    {
                        "username": "magnusbarata",
                        "content": "A subsequence must keep the original order of appearance, while the `t[i] in s` part in your code will evaluate to `True` regardless of order in s.\\nFor the simplest case, your code will fail given the input `s=\"ab\", t=\"ba\"`. For this input, your code will return 0 (i.e every element on t exist on s, without thinking the order of appearance in s), while the expected result will be 1 (i.e. s should be \"aba\", so that t is a subsequence of s)."
                    },
                    {
                        "username": "Krishrx",
                        "content": "[@Vaibhav Verma](/vaibh_1406) I am not a python guy but according to my understanding from ur code ,ur code fails for the testcase where s=\"abcde\" t=\"abab\"  ur o/p=0 expected o/p = 2\\nthe code doesnt check for duplicates where we need to make s as abcdeab,I think u need to rewrite ur logic.\\nkindly check my java solution if u are comfortable with java\\nhttps://leetcode.com/problems/append-characters-to-string-to-make-subsequence/solutions/3749270/simple-java-solution/"
                    },
                    {
                        "username": "kmp1084",
                        "content": "gave me a chance to realize why 1143. Longest Common Subsequence cannot be used to solve this problem."
                    },
                    {
                        "username": "gattemvenkatalakshmi",
                        "content": "can anyone tell why this is wrong 78 test cases were passed\n  \n\nint i =0;\n          int prev =  s.indexOf(t.charAt(i));\n           i++;\n           if( prev ==-1)\n            return t.length();\n              while( i<t.length()){\n                   int x= s.indexOf(t.charAt(i),prev);\n                    if( x ==-1)\n                     return t.length()-i;\n                      prev =x;\n                  i++;\n              } \n               return 0;"
                    },
                    {
                        "username": "upretim",
                        "content": "prev =x+1; will fix this one, actually we need to search for next+1 index and not next,  for details, please have a look at my JavaScript solution at line no 12"
                    },
                    {
                        "username": "GhostInDanger",
                        "content": "same problem I  am facing "
                    }
                ]
            },
            {
                "id": 1926840,
                "content": [
                    {
                        "username": "Imperial_Lord",
                        "content": "Seriously, this is toooo easy to be ranked medium"
                    },
                    {
                        "username": "jain_gaurav",
                        "content": "i encountered this question in OA of Amazon."
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "u\\'ve aced it!"
                    },
                    {
                        "username": "sabonett",
                        "content": "Return the minimum number of characters that need to be `appended to the end of s` so that t becomes a subsequence of s. How t become substring of s by appending only two characters?\n\nInput:\n`s = \"ajkhe\"`\n`t = \"juh\"`\n`Output 3`\n`Expected 2`\n"
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "Its not substring.. its needs to be a Subsequence"
                    },
                    {
                        "username": "vaibh_1406",
                        "content": "because \\'j\\' already exists and you need to insert only two characters i.e \\'u\\' and \\'h\\'..!!"
                    },
                    {
                        "username": "GhostInDanger",
                        "content": " test case :https://drive.google.com/file/d/1fI0OiWFtJyRtAaPUgm-4eVn86XEq3Q09/view?usp=sharing\noutput= 96017\nExpected  output =96063 how to debug and check existing code  78 test case are passed"
                    },
                    {
                        "username": "JustinMei",
                        "content": "Thanks for your test case! It helped me a lot."
                    },
                    {
                        "username": "upretim",
                        "content": "prev =x+1; will fix this one, actually we need to search for next+1 index and not next, for details, please have a look at my JavaScript solution at line no 12\\n\\n"
                    },
                    {
                        "username": "gattemvenkatalakshmi",
                        "content": "same what is ur code "
                    },
                    {
                        "username": "nhienlh94",
                        "content": "It\\'s so simple to be a medium question, crazy"
                    },
                    {
                        "username": "yuangaonyc",
                        "content": "Why is this medium? "
                    },
                    {
                        "username": "MichaelChan2417",
                        "content": "should be labeled EZ\\n"
                    },
                    {
                        "username": "vaibh_1406",
                        "content": "where is my code wrong, can anyone please suggest me ?? (PYTHON 3)\\n\\nclass Solution:\\n    def appendCharacters(self, s: str, t: str) -> int:\\n        res = \\'\\'\\n\\n        for i in range(len(t)):\\n            if t[i] in s:\\n                res+=t[i]\\n            else:\\n                break\\n        return (len(t) -len(res))"
                    },
                    {
                        "username": "magnusbarata",
                        "content": "A subsequence must keep the original order of appearance, while the `t[i] in s` part in your code will evaluate to `True` regardless of order in s.\\nFor the simplest case, your code will fail given the input `s=\"ab\", t=\"ba\"`. For this input, your code will return 0 (i.e every element on t exist on s, without thinking the order of appearance in s), while the expected result will be 1 (i.e. s should be \"aba\", so that t is a subsequence of s)."
                    },
                    {
                        "username": "Krishrx",
                        "content": "[@Vaibhav Verma](/vaibh_1406) I am not a python guy but according to my understanding from ur code ,ur code fails for the testcase where s=\"abcde\" t=\"abab\"  ur o/p=0 expected o/p = 2\\nthe code doesnt check for duplicates where we need to make s as abcdeab,I think u need to rewrite ur logic.\\nkindly check my java solution if u are comfortable with java\\nhttps://leetcode.com/problems/append-characters-to-string-to-make-subsequence/solutions/3749270/simple-java-solution/"
                    },
                    {
                        "username": "kmp1084",
                        "content": "gave me a chance to realize why 1143. Longest Common Subsequence cannot be used to solve this problem."
                    },
                    {
                        "username": "gattemvenkatalakshmi",
                        "content": "can anyone tell why this is wrong 78 test cases were passed\n  \n\nint i =0;\n          int prev =  s.indexOf(t.charAt(i));\n           i++;\n           if( prev ==-1)\n            return t.length();\n              while( i<t.length()){\n                   int x= s.indexOf(t.charAt(i),prev);\n                    if( x ==-1)\n                     return t.length()-i;\n                      prev =x;\n                  i++;\n              } \n               return 0;"
                    },
                    {
                        "username": "upretim",
                        "content": "prev =x+1; will fix this one, actually we need to search for next+1 index and not next,  for details, please have a look at my JavaScript solution at line no 12"
                    },
                    {
                        "username": "GhostInDanger",
                        "content": "same problem I  am facing "
                    }
                ]
            },
            {
                "id": 1797184,
                "content": [
                    {
                        "username": "Imperial_Lord",
                        "content": "Seriously, this is toooo easy to be ranked medium"
                    },
                    {
                        "username": "jain_gaurav",
                        "content": "i encountered this question in OA of Amazon."
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "u\\'ve aced it!"
                    },
                    {
                        "username": "sabonett",
                        "content": "Return the minimum number of characters that need to be `appended to the end of s` so that t becomes a subsequence of s. How t become substring of s by appending only two characters?\n\nInput:\n`s = \"ajkhe\"`\n`t = \"juh\"`\n`Output 3`\n`Expected 2`\n"
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "Its not substring.. its needs to be a Subsequence"
                    },
                    {
                        "username": "vaibh_1406",
                        "content": "because \\'j\\' already exists and you need to insert only two characters i.e \\'u\\' and \\'h\\'..!!"
                    },
                    {
                        "username": "GhostInDanger",
                        "content": " test case :https://drive.google.com/file/d/1fI0OiWFtJyRtAaPUgm-4eVn86XEq3Q09/view?usp=sharing\noutput= 96017\nExpected  output =96063 how to debug and check existing code  78 test case are passed"
                    },
                    {
                        "username": "JustinMei",
                        "content": "Thanks for your test case! It helped me a lot."
                    },
                    {
                        "username": "upretim",
                        "content": "prev =x+1; will fix this one, actually we need to search for next+1 index and not next, for details, please have a look at my JavaScript solution at line no 12\\n\\n"
                    },
                    {
                        "username": "gattemvenkatalakshmi",
                        "content": "same what is ur code "
                    },
                    {
                        "username": "nhienlh94",
                        "content": "It\\'s so simple to be a medium question, crazy"
                    },
                    {
                        "username": "yuangaonyc",
                        "content": "Why is this medium? "
                    },
                    {
                        "username": "MichaelChan2417",
                        "content": "should be labeled EZ\\n"
                    },
                    {
                        "username": "vaibh_1406",
                        "content": "where is my code wrong, can anyone please suggest me ?? (PYTHON 3)\\n\\nclass Solution:\\n    def appendCharacters(self, s: str, t: str) -> int:\\n        res = \\'\\'\\n\\n        for i in range(len(t)):\\n            if t[i] in s:\\n                res+=t[i]\\n            else:\\n                break\\n        return (len(t) -len(res))"
                    },
                    {
                        "username": "magnusbarata",
                        "content": "A subsequence must keep the original order of appearance, while the `t[i] in s` part in your code will evaluate to `True` regardless of order in s.\\nFor the simplest case, your code will fail given the input `s=\"ab\", t=\"ba\"`. For this input, your code will return 0 (i.e every element on t exist on s, without thinking the order of appearance in s), while the expected result will be 1 (i.e. s should be \"aba\", so that t is a subsequence of s)."
                    },
                    {
                        "username": "Krishrx",
                        "content": "[@Vaibhav Verma](/vaibh_1406) I am not a python guy but according to my understanding from ur code ,ur code fails for the testcase where s=\"abcde\" t=\"abab\"  ur o/p=0 expected o/p = 2\\nthe code doesnt check for duplicates where we need to make s as abcdeab,I think u need to rewrite ur logic.\\nkindly check my java solution if u are comfortable with java\\nhttps://leetcode.com/problems/append-characters-to-string-to-make-subsequence/solutions/3749270/simple-java-solution/"
                    },
                    {
                        "username": "kmp1084",
                        "content": "gave me a chance to realize why 1143. Longest Common Subsequence cannot be used to solve this problem."
                    },
                    {
                        "username": "gattemvenkatalakshmi",
                        "content": "can anyone tell why this is wrong 78 test cases were passed\n  \n\nint i =0;\n          int prev =  s.indexOf(t.charAt(i));\n           i++;\n           if( prev ==-1)\n            return t.length();\n              while( i<t.length()){\n                   int x= s.indexOf(t.charAt(i),prev);\n                    if( x ==-1)\n                     return t.length()-i;\n                      prev =x;\n                  i++;\n              } \n               return 0;"
                    },
                    {
                        "username": "upretim",
                        "content": "prev =x+1; will fix this one, actually we need to search for next+1 index and not next,  for details, please have a look at my JavaScript solution at line no 12"
                    },
                    {
                        "username": "GhostInDanger",
                        "content": "same problem I  am facing "
                    }
                ]
            },
            {
                "id": 1704257,
                "content": [
                    {
                        "username": "Imperial_Lord",
                        "content": "Seriously, this is toooo easy to be ranked medium"
                    },
                    {
                        "username": "jain_gaurav",
                        "content": "i encountered this question in OA of Amazon."
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "u\\'ve aced it!"
                    },
                    {
                        "username": "sabonett",
                        "content": "Return the minimum number of characters that need to be `appended to the end of s` so that t becomes a subsequence of s. How t become substring of s by appending only two characters?\n\nInput:\n`s = \"ajkhe\"`\n`t = \"juh\"`\n`Output 3`\n`Expected 2`\n"
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "Its not substring.. its needs to be a Subsequence"
                    },
                    {
                        "username": "vaibh_1406",
                        "content": "because \\'j\\' already exists and you need to insert only two characters i.e \\'u\\' and \\'h\\'..!!"
                    },
                    {
                        "username": "GhostInDanger",
                        "content": " test case :https://drive.google.com/file/d/1fI0OiWFtJyRtAaPUgm-4eVn86XEq3Q09/view?usp=sharing\noutput= 96017\nExpected  output =96063 how to debug and check existing code  78 test case are passed"
                    },
                    {
                        "username": "JustinMei",
                        "content": "Thanks for your test case! It helped me a lot."
                    },
                    {
                        "username": "upretim",
                        "content": "prev =x+1; will fix this one, actually we need to search for next+1 index and not next, for details, please have a look at my JavaScript solution at line no 12\\n\\n"
                    },
                    {
                        "username": "gattemvenkatalakshmi",
                        "content": "same what is ur code "
                    },
                    {
                        "username": "nhienlh94",
                        "content": "It\\'s so simple to be a medium question, crazy"
                    },
                    {
                        "username": "yuangaonyc",
                        "content": "Why is this medium? "
                    },
                    {
                        "username": "MichaelChan2417",
                        "content": "should be labeled EZ\\n"
                    },
                    {
                        "username": "vaibh_1406",
                        "content": "where is my code wrong, can anyone please suggest me ?? (PYTHON 3)\\n\\nclass Solution:\\n    def appendCharacters(self, s: str, t: str) -> int:\\n        res = \\'\\'\\n\\n        for i in range(len(t)):\\n            if t[i] in s:\\n                res+=t[i]\\n            else:\\n                break\\n        return (len(t) -len(res))"
                    },
                    {
                        "username": "magnusbarata",
                        "content": "A subsequence must keep the original order of appearance, while the `t[i] in s` part in your code will evaluate to `True` regardless of order in s.\\nFor the simplest case, your code will fail given the input `s=\"ab\", t=\"ba\"`. For this input, your code will return 0 (i.e every element on t exist on s, without thinking the order of appearance in s), while the expected result will be 1 (i.e. s should be \"aba\", so that t is a subsequence of s)."
                    },
                    {
                        "username": "Krishrx",
                        "content": "[@Vaibhav Verma](/vaibh_1406) I am not a python guy but according to my understanding from ur code ,ur code fails for the testcase where s=\"abcde\" t=\"abab\"  ur o/p=0 expected o/p = 2\\nthe code doesnt check for duplicates where we need to make s as abcdeab,I think u need to rewrite ur logic.\\nkindly check my java solution if u are comfortable with java\\nhttps://leetcode.com/problems/append-characters-to-string-to-make-subsequence/solutions/3749270/simple-java-solution/"
                    },
                    {
                        "username": "kmp1084",
                        "content": "gave me a chance to realize why 1143. Longest Common Subsequence cannot be used to solve this problem."
                    },
                    {
                        "username": "gattemvenkatalakshmi",
                        "content": "can anyone tell why this is wrong 78 test cases were passed\n  \n\nint i =0;\n          int prev =  s.indexOf(t.charAt(i));\n           i++;\n           if( prev ==-1)\n            return t.length();\n              while( i<t.length()){\n                   int x= s.indexOf(t.charAt(i),prev);\n                    if( x ==-1)\n                     return t.length()-i;\n                      prev =x;\n                  i++;\n              } \n               return 0;"
                    },
                    {
                        "username": "upretim",
                        "content": "prev =x+1; will fix this one, actually we need to search for next+1 index and not next,  for details, please have a look at my JavaScript solution at line no 12"
                    },
                    {
                        "username": "GhostInDanger",
                        "content": "same problem I  am facing "
                    }
                ]
            },
            {
                "id": 1699934,
                "content": [
                    {
                        "username": "Imperial_Lord",
                        "content": "Seriously, this is toooo easy to be ranked medium"
                    },
                    {
                        "username": "jain_gaurav",
                        "content": "i encountered this question in OA of Amazon."
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "u\\'ve aced it!"
                    },
                    {
                        "username": "sabonett",
                        "content": "Return the minimum number of characters that need to be `appended to the end of s` so that t becomes a subsequence of s. How t become substring of s by appending only two characters?\n\nInput:\n`s = \"ajkhe\"`\n`t = \"juh\"`\n`Output 3`\n`Expected 2`\n"
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "Its not substring.. its needs to be a Subsequence"
                    },
                    {
                        "username": "vaibh_1406",
                        "content": "because \\'j\\' already exists and you need to insert only two characters i.e \\'u\\' and \\'h\\'..!!"
                    },
                    {
                        "username": "GhostInDanger",
                        "content": " test case :https://drive.google.com/file/d/1fI0OiWFtJyRtAaPUgm-4eVn86XEq3Q09/view?usp=sharing\noutput= 96017\nExpected  output =96063 how to debug and check existing code  78 test case are passed"
                    },
                    {
                        "username": "JustinMei",
                        "content": "Thanks for your test case! It helped me a lot."
                    },
                    {
                        "username": "upretim",
                        "content": "prev =x+1; will fix this one, actually we need to search for next+1 index and not next, for details, please have a look at my JavaScript solution at line no 12\\n\\n"
                    },
                    {
                        "username": "gattemvenkatalakshmi",
                        "content": "same what is ur code "
                    },
                    {
                        "username": "nhienlh94",
                        "content": "It\\'s so simple to be a medium question, crazy"
                    },
                    {
                        "username": "yuangaonyc",
                        "content": "Why is this medium? "
                    },
                    {
                        "username": "MichaelChan2417",
                        "content": "should be labeled EZ\\n"
                    },
                    {
                        "username": "vaibh_1406",
                        "content": "where is my code wrong, can anyone please suggest me ?? (PYTHON 3)\\n\\nclass Solution:\\n    def appendCharacters(self, s: str, t: str) -> int:\\n        res = \\'\\'\\n\\n        for i in range(len(t)):\\n            if t[i] in s:\\n                res+=t[i]\\n            else:\\n                break\\n        return (len(t) -len(res))"
                    },
                    {
                        "username": "magnusbarata",
                        "content": "A subsequence must keep the original order of appearance, while the `t[i] in s` part in your code will evaluate to `True` regardless of order in s.\\nFor the simplest case, your code will fail given the input `s=\"ab\", t=\"ba\"`. For this input, your code will return 0 (i.e every element on t exist on s, without thinking the order of appearance in s), while the expected result will be 1 (i.e. s should be \"aba\", so that t is a subsequence of s)."
                    },
                    {
                        "username": "Krishrx",
                        "content": "[@Vaibhav Verma](/vaibh_1406) I am not a python guy but according to my understanding from ur code ,ur code fails for the testcase where s=\"abcde\" t=\"abab\"  ur o/p=0 expected o/p = 2\\nthe code doesnt check for duplicates where we need to make s as abcdeab,I think u need to rewrite ur logic.\\nkindly check my java solution if u are comfortable with java\\nhttps://leetcode.com/problems/append-characters-to-string-to-make-subsequence/solutions/3749270/simple-java-solution/"
                    },
                    {
                        "username": "kmp1084",
                        "content": "gave me a chance to realize why 1143. Longest Common Subsequence cannot be used to solve this problem."
                    },
                    {
                        "username": "gattemvenkatalakshmi",
                        "content": "can anyone tell why this is wrong 78 test cases were passed\n  \n\nint i =0;\n          int prev =  s.indexOf(t.charAt(i));\n           i++;\n           if( prev ==-1)\n            return t.length();\n              while( i<t.length()){\n                   int x= s.indexOf(t.charAt(i),prev);\n                    if( x ==-1)\n                     return t.length()-i;\n                      prev =x;\n                  i++;\n              } \n               return 0;"
                    },
                    {
                        "username": "upretim",
                        "content": "prev =x+1; will fix this one, actually we need to search for next+1 index and not next,  for details, please have a look at my JavaScript solution at line no 12"
                    },
                    {
                        "username": "GhostInDanger",
                        "content": "same problem I  am facing "
                    }
                ]
            },
            {
                "id": 1795766,
                "content": [
                    {
                        "username": "Imperial_Lord",
                        "content": "Seriously, this is toooo easy to be ranked medium"
                    },
                    {
                        "username": "jain_gaurav",
                        "content": "i encountered this question in OA of Amazon."
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "u\\'ve aced it!"
                    },
                    {
                        "username": "sabonett",
                        "content": "Return the minimum number of characters that need to be `appended to the end of s` so that t becomes a subsequence of s. How t become substring of s by appending only two characters?\n\nInput:\n`s = \"ajkhe\"`\n`t = \"juh\"`\n`Output 3`\n`Expected 2`\n"
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "Its not substring.. its needs to be a Subsequence"
                    },
                    {
                        "username": "vaibh_1406",
                        "content": "because \\'j\\' already exists and you need to insert only two characters i.e \\'u\\' and \\'h\\'..!!"
                    },
                    {
                        "username": "GhostInDanger",
                        "content": " test case :https://drive.google.com/file/d/1fI0OiWFtJyRtAaPUgm-4eVn86XEq3Q09/view?usp=sharing\noutput= 96017\nExpected  output =96063 how to debug and check existing code  78 test case are passed"
                    },
                    {
                        "username": "JustinMei",
                        "content": "Thanks for your test case! It helped me a lot."
                    },
                    {
                        "username": "upretim",
                        "content": "prev =x+1; will fix this one, actually we need to search for next+1 index and not next, for details, please have a look at my JavaScript solution at line no 12\\n\\n"
                    },
                    {
                        "username": "gattemvenkatalakshmi",
                        "content": "same what is ur code "
                    },
                    {
                        "username": "nhienlh94",
                        "content": "It\\'s so simple to be a medium question, crazy"
                    },
                    {
                        "username": "yuangaonyc",
                        "content": "Why is this medium? "
                    },
                    {
                        "username": "MichaelChan2417",
                        "content": "should be labeled EZ\\n"
                    },
                    {
                        "username": "vaibh_1406",
                        "content": "where is my code wrong, can anyone please suggest me ?? (PYTHON 3)\\n\\nclass Solution:\\n    def appendCharacters(self, s: str, t: str) -> int:\\n        res = \\'\\'\\n\\n        for i in range(len(t)):\\n            if t[i] in s:\\n                res+=t[i]\\n            else:\\n                break\\n        return (len(t) -len(res))"
                    },
                    {
                        "username": "magnusbarata",
                        "content": "A subsequence must keep the original order of appearance, while the `t[i] in s` part in your code will evaluate to `True` regardless of order in s.\\nFor the simplest case, your code will fail given the input `s=\"ab\", t=\"ba\"`. For this input, your code will return 0 (i.e every element on t exist on s, without thinking the order of appearance in s), while the expected result will be 1 (i.e. s should be \"aba\", so that t is a subsequence of s)."
                    },
                    {
                        "username": "Krishrx",
                        "content": "[@Vaibhav Verma](/vaibh_1406) I am not a python guy but according to my understanding from ur code ,ur code fails for the testcase where s=\"abcde\" t=\"abab\"  ur o/p=0 expected o/p = 2\\nthe code doesnt check for duplicates where we need to make s as abcdeab,I think u need to rewrite ur logic.\\nkindly check my java solution if u are comfortable with java\\nhttps://leetcode.com/problems/append-characters-to-string-to-make-subsequence/solutions/3749270/simple-java-solution/"
                    },
                    {
                        "username": "kmp1084",
                        "content": "gave me a chance to realize why 1143. Longest Common Subsequence cannot be used to solve this problem."
                    },
                    {
                        "username": "gattemvenkatalakshmi",
                        "content": "can anyone tell why this is wrong 78 test cases were passed\n  \n\nint i =0;\n          int prev =  s.indexOf(t.charAt(i));\n           i++;\n           if( prev ==-1)\n            return t.length();\n              while( i<t.length()){\n                   int x= s.indexOf(t.charAt(i),prev);\n                    if( x ==-1)\n                     return t.length()-i;\n                      prev =x;\n                  i++;\n              } \n               return 0;"
                    },
                    {
                        "username": "upretim",
                        "content": "prev =x+1; will fix this one, actually we need to search for next+1 index and not next,  for details, please have a look at my JavaScript solution at line no 12"
                    },
                    {
                        "username": "GhostInDanger",
                        "content": "same problem I  am facing "
                    }
                ]
            },
            {
                "id": 1763418,
                "content": [
                    {
                        "username": "Imperial_Lord",
                        "content": "Seriously, this is toooo easy to be ranked medium"
                    },
                    {
                        "username": "jain_gaurav",
                        "content": "i encountered this question in OA of Amazon."
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "u\\'ve aced it!"
                    },
                    {
                        "username": "sabonett",
                        "content": "Return the minimum number of characters that need to be `appended to the end of s` so that t becomes a subsequence of s. How t become substring of s by appending only two characters?\n\nInput:\n`s = \"ajkhe\"`\n`t = \"juh\"`\n`Output 3`\n`Expected 2`\n"
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "Its not substring.. its needs to be a Subsequence"
                    },
                    {
                        "username": "vaibh_1406",
                        "content": "because \\'j\\' already exists and you need to insert only two characters i.e \\'u\\' and \\'h\\'..!!"
                    },
                    {
                        "username": "GhostInDanger",
                        "content": " test case :https://drive.google.com/file/d/1fI0OiWFtJyRtAaPUgm-4eVn86XEq3Q09/view?usp=sharing\noutput= 96017\nExpected  output =96063 how to debug and check existing code  78 test case are passed"
                    },
                    {
                        "username": "JustinMei",
                        "content": "Thanks for your test case! It helped me a lot."
                    },
                    {
                        "username": "upretim",
                        "content": "prev =x+1; will fix this one, actually we need to search for next+1 index and not next, for details, please have a look at my JavaScript solution at line no 12\\n\\n"
                    },
                    {
                        "username": "gattemvenkatalakshmi",
                        "content": "same what is ur code "
                    },
                    {
                        "username": "nhienlh94",
                        "content": "It\\'s so simple to be a medium question, crazy"
                    },
                    {
                        "username": "yuangaonyc",
                        "content": "Why is this medium? "
                    },
                    {
                        "username": "MichaelChan2417",
                        "content": "should be labeled EZ\\n"
                    },
                    {
                        "username": "vaibh_1406",
                        "content": "where is my code wrong, can anyone please suggest me ?? (PYTHON 3)\\n\\nclass Solution:\\n    def appendCharacters(self, s: str, t: str) -> int:\\n        res = \\'\\'\\n\\n        for i in range(len(t)):\\n            if t[i] in s:\\n                res+=t[i]\\n            else:\\n                break\\n        return (len(t) -len(res))"
                    },
                    {
                        "username": "magnusbarata",
                        "content": "A subsequence must keep the original order of appearance, while the `t[i] in s` part in your code will evaluate to `True` regardless of order in s.\\nFor the simplest case, your code will fail given the input `s=\"ab\", t=\"ba\"`. For this input, your code will return 0 (i.e every element on t exist on s, without thinking the order of appearance in s), while the expected result will be 1 (i.e. s should be \"aba\", so that t is a subsequence of s)."
                    },
                    {
                        "username": "Krishrx",
                        "content": "[@Vaibhav Verma](/vaibh_1406) I am not a python guy but according to my understanding from ur code ,ur code fails for the testcase where s=\"abcde\" t=\"abab\"  ur o/p=0 expected o/p = 2\\nthe code doesnt check for duplicates where we need to make s as abcdeab,I think u need to rewrite ur logic.\\nkindly check my java solution if u are comfortable with java\\nhttps://leetcode.com/problems/append-characters-to-string-to-make-subsequence/solutions/3749270/simple-java-solution/"
                    },
                    {
                        "username": "kmp1084",
                        "content": "gave me a chance to realize why 1143. Longest Common Subsequence cannot be used to solve this problem."
                    },
                    {
                        "username": "gattemvenkatalakshmi",
                        "content": "can anyone tell why this is wrong 78 test cases were passed\n  \n\nint i =0;\n          int prev =  s.indexOf(t.charAt(i));\n           i++;\n           if( prev ==-1)\n            return t.length();\n              while( i<t.length()){\n                   int x= s.indexOf(t.charAt(i),prev);\n                    if( x ==-1)\n                     return t.length()-i;\n                      prev =x;\n                  i++;\n              } \n               return 0;"
                    },
                    {
                        "username": "upretim",
                        "content": "prev =x+1; will fix this one, actually we need to search for next+1 index and not next,  for details, please have a look at my JavaScript solution at line no 12"
                    },
                    {
                        "username": "GhostInDanger",
                        "content": "same problem I  am facing "
                    }
                ]
            },
            {
                "id": 1702930,
                "content": [
                    {
                        "username": "Imperial_Lord",
                        "content": "Seriously, this is toooo easy to be ranked medium"
                    },
                    {
                        "username": "jain_gaurav",
                        "content": "i encountered this question in OA of Amazon."
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "u\\'ve aced it!"
                    },
                    {
                        "username": "sabonett",
                        "content": "Return the minimum number of characters that need to be `appended to the end of s` so that t becomes a subsequence of s. How t become substring of s by appending only two characters?\n\nInput:\n`s = \"ajkhe\"`\n`t = \"juh\"`\n`Output 3`\n`Expected 2`\n"
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "Its not substring.. its needs to be a Subsequence"
                    },
                    {
                        "username": "vaibh_1406",
                        "content": "because \\'j\\' already exists and you need to insert only two characters i.e \\'u\\' and \\'h\\'..!!"
                    },
                    {
                        "username": "GhostInDanger",
                        "content": " test case :https://drive.google.com/file/d/1fI0OiWFtJyRtAaPUgm-4eVn86XEq3Q09/view?usp=sharing\noutput= 96017\nExpected  output =96063 how to debug and check existing code  78 test case are passed"
                    },
                    {
                        "username": "JustinMei",
                        "content": "Thanks for your test case! It helped me a lot."
                    },
                    {
                        "username": "upretim",
                        "content": "prev =x+1; will fix this one, actually we need to search for next+1 index and not next, for details, please have a look at my JavaScript solution at line no 12\\n\\n"
                    },
                    {
                        "username": "gattemvenkatalakshmi",
                        "content": "same what is ur code "
                    },
                    {
                        "username": "nhienlh94",
                        "content": "It\\'s so simple to be a medium question, crazy"
                    },
                    {
                        "username": "yuangaonyc",
                        "content": "Why is this medium? "
                    },
                    {
                        "username": "MichaelChan2417",
                        "content": "should be labeled EZ\\n"
                    },
                    {
                        "username": "vaibh_1406",
                        "content": "where is my code wrong, can anyone please suggest me ?? (PYTHON 3)\\n\\nclass Solution:\\n    def appendCharacters(self, s: str, t: str) -> int:\\n        res = \\'\\'\\n\\n        for i in range(len(t)):\\n            if t[i] in s:\\n                res+=t[i]\\n            else:\\n                break\\n        return (len(t) -len(res))"
                    },
                    {
                        "username": "magnusbarata",
                        "content": "A subsequence must keep the original order of appearance, while the `t[i] in s` part in your code will evaluate to `True` regardless of order in s.\\nFor the simplest case, your code will fail given the input `s=\"ab\", t=\"ba\"`. For this input, your code will return 0 (i.e every element on t exist on s, without thinking the order of appearance in s), while the expected result will be 1 (i.e. s should be \"aba\", so that t is a subsequence of s)."
                    },
                    {
                        "username": "Krishrx",
                        "content": "[@Vaibhav Verma](/vaibh_1406) I am not a python guy but according to my understanding from ur code ,ur code fails for the testcase where s=\"abcde\" t=\"abab\"  ur o/p=0 expected o/p = 2\\nthe code doesnt check for duplicates where we need to make s as abcdeab,I think u need to rewrite ur logic.\\nkindly check my java solution if u are comfortable with java\\nhttps://leetcode.com/problems/append-characters-to-string-to-make-subsequence/solutions/3749270/simple-java-solution/"
                    },
                    {
                        "username": "kmp1084",
                        "content": "gave me a chance to realize why 1143. Longest Common Subsequence cannot be used to solve this problem."
                    },
                    {
                        "username": "gattemvenkatalakshmi",
                        "content": "can anyone tell why this is wrong 78 test cases were passed\n  \n\nint i =0;\n          int prev =  s.indexOf(t.charAt(i));\n           i++;\n           if( prev ==-1)\n            return t.length();\n              while( i<t.length()){\n                   int x= s.indexOf(t.charAt(i),prev);\n                    if( x ==-1)\n                     return t.length()-i;\n                      prev =x;\n                  i++;\n              } \n               return 0;"
                    },
                    {
                        "username": "upretim",
                        "content": "prev =x+1; will fix this one, actually we need to search for next+1 index and not next,  for details, please have a look at my JavaScript solution at line no 12"
                    },
                    {
                        "username": "GhostInDanger",
                        "content": "same problem I  am facing "
                    }
                ]
            },
            {
                "id": 2056064,
                "content": [
                    {
                        "username": "Imperial_Lord",
                        "content": "Seriously, this is toooo easy to be ranked medium"
                    },
                    {
                        "username": "jain_gaurav",
                        "content": "i encountered this question in OA of Amazon."
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "u\\'ve aced it!"
                    },
                    {
                        "username": "sabonett",
                        "content": "Return the minimum number of characters that need to be `appended to the end of s` so that t becomes a subsequence of s. How t become substring of s by appending only two characters?\n\nInput:\n`s = \"ajkhe\"`\n`t = \"juh\"`\n`Output 3`\n`Expected 2`\n"
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "Its not substring.. its needs to be a Subsequence"
                    },
                    {
                        "username": "vaibh_1406",
                        "content": "because \\'j\\' already exists and you need to insert only two characters i.e \\'u\\' and \\'h\\'..!!"
                    },
                    {
                        "username": "GhostInDanger",
                        "content": " test case :https://drive.google.com/file/d/1fI0OiWFtJyRtAaPUgm-4eVn86XEq3Q09/view?usp=sharing\noutput= 96017\nExpected  output =96063 how to debug and check existing code  78 test case are passed"
                    },
                    {
                        "username": "JustinMei",
                        "content": "Thanks for your test case! It helped me a lot."
                    },
                    {
                        "username": "upretim",
                        "content": "prev =x+1; will fix this one, actually we need to search for next+1 index and not next, for details, please have a look at my JavaScript solution at line no 12\\n\\n"
                    },
                    {
                        "username": "gattemvenkatalakshmi",
                        "content": "same what is ur code "
                    },
                    {
                        "username": "nhienlh94",
                        "content": "It\\'s so simple to be a medium question, crazy"
                    },
                    {
                        "username": "yuangaonyc",
                        "content": "Why is this medium? "
                    },
                    {
                        "username": "MichaelChan2417",
                        "content": "should be labeled EZ\\n"
                    },
                    {
                        "username": "vaibh_1406",
                        "content": "where is my code wrong, can anyone please suggest me ?? (PYTHON 3)\\n\\nclass Solution:\\n    def appendCharacters(self, s: str, t: str) -> int:\\n        res = \\'\\'\\n\\n        for i in range(len(t)):\\n            if t[i] in s:\\n                res+=t[i]\\n            else:\\n                break\\n        return (len(t) -len(res))"
                    },
                    {
                        "username": "magnusbarata",
                        "content": "A subsequence must keep the original order of appearance, while the `t[i] in s` part in your code will evaluate to `True` regardless of order in s.\\nFor the simplest case, your code will fail given the input `s=\"ab\", t=\"ba\"`. For this input, your code will return 0 (i.e every element on t exist on s, without thinking the order of appearance in s), while the expected result will be 1 (i.e. s should be \"aba\", so that t is a subsequence of s)."
                    },
                    {
                        "username": "Krishrx",
                        "content": "[@Vaibhav Verma](/vaibh_1406) I am not a python guy but according to my understanding from ur code ,ur code fails for the testcase where s=\"abcde\" t=\"abab\"  ur o/p=0 expected o/p = 2\\nthe code doesnt check for duplicates where we need to make s as abcdeab,I think u need to rewrite ur logic.\\nkindly check my java solution if u are comfortable with java\\nhttps://leetcode.com/problems/append-characters-to-string-to-make-subsequence/solutions/3749270/simple-java-solution/"
                    },
                    {
                        "username": "kmp1084",
                        "content": "gave me a chance to realize why 1143. Longest Common Subsequence cannot be used to solve this problem."
                    },
                    {
                        "username": "gattemvenkatalakshmi",
                        "content": "can anyone tell why this is wrong 78 test cases were passed\n  \n\nint i =0;\n          int prev =  s.indexOf(t.charAt(i));\n           i++;\n           if( prev ==-1)\n            return t.length();\n              while( i<t.length()){\n                   int x= s.indexOf(t.charAt(i),prev);\n                    if( x ==-1)\n                     return t.length()-i;\n                      prev =x;\n                  i++;\n              } \n               return 0;"
                    },
                    {
                        "username": "upretim",
                        "content": "prev =x+1; will fix this one, actually we need to search for next+1 index and not next,  for details, please have a look at my JavaScript solution at line no 12"
                    },
                    {
                        "username": "GhostInDanger",
                        "content": "same problem I  am facing "
                    }
                ]
            },
            {
                "id": 2042362,
                "content": [
                    {
                        "username": "Imperial_Lord",
                        "content": "Seriously, this is toooo easy to be ranked medium"
                    },
                    {
                        "username": "jain_gaurav",
                        "content": "i encountered this question in OA of Amazon."
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "u\\'ve aced it!"
                    },
                    {
                        "username": "sabonett",
                        "content": "Return the minimum number of characters that need to be `appended to the end of s` so that t becomes a subsequence of s. How t become substring of s by appending only two characters?\n\nInput:\n`s = \"ajkhe\"`\n`t = \"juh\"`\n`Output 3`\n`Expected 2`\n"
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "Its not substring.. its needs to be a Subsequence"
                    },
                    {
                        "username": "vaibh_1406",
                        "content": "because \\'j\\' already exists and you need to insert only two characters i.e \\'u\\' and \\'h\\'..!!"
                    },
                    {
                        "username": "GhostInDanger",
                        "content": " test case :https://drive.google.com/file/d/1fI0OiWFtJyRtAaPUgm-4eVn86XEq3Q09/view?usp=sharing\noutput= 96017\nExpected  output =96063 how to debug and check existing code  78 test case are passed"
                    },
                    {
                        "username": "JustinMei",
                        "content": "Thanks for your test case! It helped me a lot."
                    },
                    {
                        "username": "upretim",
                        "content": "prev =x+1; will fix this one, actually we need to search for next+1 index and not next, for details, please have a look at my JavaScript solution at line no 12\\n\\n"
                    },
                    {
                        "username": "gattemvenkatalakshmi",
                        "content": "same what is ur code "
                    },
                    {
                        "username": "nhienlh94",
                        "content": "It\\'s so simple to be a medium question, crazy"
                    },
                    {
                        "username": "yuangaonyc",
                        "content": "Why is this medium? "
                    },
                    {
                        "username": "MichaelChan2417",
                        "content": "should be labeled EZ\\n"
                    },
                    {
                        "username": "vaibh_1406",
                        "content": "where is my code wrong, can anyone please suggest me ?? (PYTHON 3)\\n\\nclass Solution:\\n    def appendCharacters(self, s: str, t: str) -> int:\\n        res = \\'\\'\\n\\n        for i in range(len(t)):\\n            if t[i] in s:\\n                res+=t[i]\\n            else:\\n                break\\n        return (len(t) -len(res))"
                    },
                    {
                        "username": "magnusbarata",
                        "content": "A subsequence must keep the original order of appearance, while the `t[i] in s` part in your code will evaluate to `True` regardless of order in s.\\nFor the simplest case, your code will fail given the input `s=\"ab\", t=\"ba\"`. For this input, your code will return 0 (i.e every element on t exist on s, without thinking the order of appearance in s), while the expected result will be 1 (i.e. s should be \"aba\", so that t is a subsequence of s)."
                    },
                    {
                        "username": "Krishrx",
                        "content": "[@Vaibhav Verma](/vaibh_1406) I am not a python guy but according to my understanding from ur code ,ur code fails for the testcase where s=\"abcde\" t=\"abab\"  ur o/p=0 expected o/p = 2\\nthe code doesnt check for duplicates where we need to make s as abcdeab,I think u need to rewrite ur logic.\\nkindly check my java solution if u are comfortable with java\\nhttps://leetcode.com/problems/append-characters-to-string-to-make-subsequence/solutions/3749270/simple-java-solution/"
                    },
                    {
                        "username": "kmp1084",
                        "content": "gave me a chance to realize why 1143. Longest Common Subsequence cannot be used to solve this problem."
                    },
                    {
                        "username": "gattemvenkatalakshmi",
                        "content": "can anyone tell why this is wrong 78 test cases were passed\n  \n\nint i =0;\n          int prev =  s.indexOf(t.charAt(i));\n           i++;\n           if( prev ==-1)\n            return t.length();\n              while( i<t.length()){\n                   int x= s.indexOf(t.charAt(i),prev);\n                    if( x ==-1)\n                     return t.length()-i;\n                      prev =x;\n                  i++;\n              } \n               return 0;"
                    },
                    {
                        "username": "upretim",
                        "content": "prev =x+1; will fix this one, actually we need to search for next+1 index and not next,  for details, please have a look at my JavaScript solution at line no 12"
                    },
                    {
                        "username": "GhostInDanger",
                        "content": "same problem I  am facing "
                    }
                ]
            },
            {
                "id": 2023664,
                "content": [
                    {
                        "username": "Imperial_Lord",
                        "content": "Seriously, this is toooo easy to be ranked medium"
                    },
                    {
                        "username": "jain_gaurav",
                        "content": "i encountered this question in OA of Amazon."
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "u\\'ve aced it!"
                    },
                    {
                        "username": "sabonett",
                        "content": "Return the minimum number of characters that need to be `appended to the end of s` so that t becomes a subsequence of s. How t become substring of s by appending only two characters?\n\nInput:\n`s = \"ajkhe\"`\n`t = \"juh\"`\n`Output 3`\n`Expected 2`\n"
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "Its not substring.. its needs to be a Subsequence"
                    },
                    {
                        "username": "vaibh_1406",
                        "content": "because \\'j\\' already exists and you need to insert only two characters i.e \\'u\\' and \\'h\\'..!!"
                    },
                    {
                        "username": "GhostInDanger",
                        "content": " test case :https://drive.google.com/file/d/1fI0OiWFtJyRtAaPUgm-4eVn86XEq3Q09/view?usp=sharing\noutput= 96017\nExpected  output =96063 how to debug and check existing code  78 test case are passed"
                    },
                    {
                        "username": "JustinMei",
                        "content": "Thanks for your test case! It helped me a lot."
                    },
                    {
                        "username": "upretim",
                        "content": "prev =x+1; will fix this one, actually we need to search for next+1 index and not next, for details, please have a look at my JavaScript solution at line no 12\\n\\n"
                    },
                    {
                        "username": "gattemvenkatalakshmi",
                        "content": "same what is ur code "
                    },
                    {
                        "username": "nhienlh94",
                        "content": "It\\'s so simple to be a medium question, crazy"
                    },
                    {
                        "username": "yuangaonyc",
                        "content": "Why is this medium? "
                    },
                    {
                        "username": "MichaelChan2417",
                        "content": "should be labeled EZ\\n"
                    },
                    {
                        "username": "vaibh_1406",
                        "content": "where is my code wrong, can anyone please suggest me ?? (PYTHON 3)\\n\\nclass Solution:\\n    def appendCharacters(self, s: str, t: str) -> int:\\n        res = \\'\\'\\n\\n        for i in range(len(t)):\\n            if t[i] in s:\\n                res+=t[i]\\n            else:\\n                break\\n        return (len(t) -len(res))"
                    },
                    {
                        "username": "magnusbarata",
                        "content": "A subsequence must keep the original order of appearance, while the `t[i] in s` part in your code will evaluate to `True` regardless of order in s.\\nFor the simplest case, your code will fail given the input `s=\"ab\", t=\"ba\"`. For this input, your code will return 0 (i.e every element on t exist on s, without thinking the order of appearance in s), while the expected result will be 1 (i.e. s should be \"aba\", so that t is a subsequence of s)."
                    },
                    {
                        "username": "Krishrx",
                        "content": "[@Vaibhav Verma](/vaibh_1406) I am not a python guy but according to my understanding from ur code ,ur code fails for the testcase where s=\"abcde\" t=\"abab\"  ur o/p=0 expected o/p = 2\\nthe code doesnt check for duplicates where we need to make s as abcdeab,I think u need to rewrite ur logic.\\nkindly check my java solution if u are comfortable with java\\nhttps://leetcode.com/problems/append-characters-to-string-to-make-subsequence/solutions/3749270/simple-java-solution/"
                    },
                    {
                        "username": "kmp1084",
                        "content": "gave me a chance to realize why 1143. Longest Common Subsequence cannot be used to solve this problem."
                    },
                    {
                        "username": "gattemvenkatalakshmi",
                        "content": "can anyone tell why this is wrong 78 test cases were passed\n  \n\nint i =0;\n          int prev =  s.indexOf(t.charAt(i));\n           i++;\n           if( prev ==-1)\n            return t.length();\n              while( i<t.length()){\n                   int x= s.indexOf(t.charAt(i),prev);\n                    if( x ==-1)\n                     return t.length()-i;\n                      prev =x;\n                  i++;\n              } \n               return 0;"
                    },
                    {
                        "username": "upretim",
                        "content": "prev =x+1; will fix this one, actually we need to search for next+1 index and not next,  for details, please have a look at my JavaScript solution at line no 12"
                    },
                    {
                        "username": "GhostInDanger",
                        "content": "same problem I  am facing "
                    }
                ]
            },
            {
                "id": 1926840,
                "content": [
                    {
                        "username": "Imperial_Lord",
                        "content": "Seriously, this is toooo easy to be ranked medium"
                    },
                    {
                        "username": "jain_gaurav",
                        "content": "i encountered this question in OA of Amazon."
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "u\\'ve aced it!"
                    },
                    {
                        "username": "sabonett",
                        "content": "Return the minimum number of characters that need to be `appended to the end of s` so that t becomes a subsequence of s. How t become substring of s by appending only two characters?\n\nInput:\n`s = \"ajkhe\"`\n`t = \"juh\"`\n`Output 3`\n`Expected 2`\n"
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "Its not substring.. its needs to be a Subsequence"
                    },
                    {
                        "username": "vaibh_1406",
                        "content": "because \\'j\\' already exists and you need to insert only two characters i.e \\'u\\' and \\'h\\'..!!"
                    },
                    {
                        "username": "GhostInDanger",
                        "content": " test case :https://drive.google.com/file/d/1fI0OiWFtJyRtAaPUgm-4eVn86XEq3Q09/view?usp=sharing\noutput= 96017\nExpected  output =96063 how to debug and check existing code  78 test case are passed"
                    },
                    {
                        "username": "JustinMei",
                        "content": "Thanks for your test case! It helped me a lot."
                    },
                    {
                        "username": "upretim",
                        "content": "prev =x+1; will fix this one, actually we need to search for next+1 index and not next, for details, please have a look at my JavaScript solution at line no 12\\n\\n"
                    },
                    {
                        "username": "gattemvenkatalakshmi",
                        "content": "same what is ur code "
                    },
                    {
                        "username": "nhienlh94",
                        "content": "It\\'s so simple to be a medium question, crazy"
                    },
                    {
                        "username": "yuangaonyc",
                        "content": "Why is this medium? "
                    },
                    {
                        "username": "MichaelChan2417",
                        "content": "should be labeled EZ\\n"
                    },
                    {
                        "username": "vaibh_1406",
                        "content": "where is my code wrong, can anyone please suggest me ?? (PYTHON 3)\\n\\nclass Solution:\\n    def appendCharacters(self, s: str, t: str) -> int:\\n        res = \\'\\'\\n\\n        for i in range(len(t)):\\n            if t[i] in s:\\n                res+=t[i]\\n            else:\\n                break\\n        return (len(t) -len(res))"
                    },
                    {
                        "username": "magnusbarata",
                        "content": "A subsequence must keep the original order of appearance, while the `t[i] in s` part in your code will evaluate to `True` regardless of order in s.\\nFor the simplest case, your code will fail given the input `s=\"ab\", t=\"ba\"`. For this input, your code will return 0 (i.e every element on t exist on s, without thinking the order of appearance in s), while the expected result will be 1 (i.e. s should be \"aba\", so that t is a subsequence of s)."
                    },
                    {
                        "username": "Krishrx",
                        "content": "[@Vaibhav Verma](/vaibh_1406) I am not a python guy but according to my understanding from ur code ,ur code fails for the testcase where s=\"abcde\" t=\"abab\"  ur o/p=0 expected o/p = 2\\nthe code doesnt check for duplicates where we need to make s as abcdeab,I think u need to rewrite ur logic.\\nkindly check my java solution if u are comfortable with java\\nhttps://leetcode.com/problems/append-characters-to-string-to-make-subsequence/solutions/3749270/simple-java-solution/"
                    },
                    {
                        "username": "kmp1084",
                        "content": "gave me a chance to realize why 1143. Longest Common Subsequence cannot be used to solve this problem."
                    },
                    {
                        "username": "gattemvenkatalakshmi",
                        "content": "can anyone tell why this is wrong 78 test cases were passed\n  \n\nint i =0;\n          int prev =  s.indexOf(t.charAt(i));\n           i++;\n           if( prev ==-1)\n            return t.length();\n              while( i<t.length()){\n                   int x= s.indexOf(t.charAt(i),prev);\n                    if( x ==-1)\n                     return t.length()-i;\n                      prev =x;\n                  i++;\n              } \n               return 0;"
                    },
                    {
                        "username": "upretim",
                        "content": "prev =x+1; will fix this one, actually we need to search for next+1 index and not next,  for details, please have a look at my JavaScript solution at line no 12"
                    },
                    {
                        "username": "GhostInDanger",
                        "content": "same problem I  am facing "
                    }
                ]
            },
            {
                "id": 1797184,
                "content": [
                    {
                        "username": "Imperial_Lord",
                        "content": "Seriously, this is toooo easy to be ranked medium"
                    },
                    {
                        "username": "jain_gaurav",
                        "content": "i encountered this question in OA of Amazon."
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "u\\'ve aced it!"
                    },
                    {
                        "username": "sabonett",
                        "content": "Return the minimum number of characters that need to be `appended to the end of s` so that t becomes a subsequence of s. How t become substring of s by appending only two characters?\n\nInput:\n`s = \"ajkhe\"`\n`t = \"juh\"`\n`Output 3`\n`Expected 2`\n"
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "Its not substring.. its needs to be a Subsequence"
                    },
                    {
                        "username": "vaibh_1406",
                        "content": "because \\'j\\' already exists and you need to insert only two characters i.e \\'u\\' and \\'h\\'..!!"
                    },
                    {
                        "username": "GhostInDanger",
                        "content": " test case :https://drive.google.com/file/d/1fI0OiWFtJyRtAaPUgm-4eVn86XEq3Q09/view?usp=sharing\noutput= 96017\nExpected  output =96063 how to debug and check existing code  78 test case are passed"
                    },
                    {
                        "username": "JustinMei",
                        "content": "Thanks for your test case! It helped me a lot."
                    },
                    {
                        "username": "upretim",
                        "content": "prev =x+1; will fix this one, actually we need to search for next+1 index and not next, for details, please have a look at my JavaScript solution at line no 12\\n\\n"
                    },
                    {
                        "username": "gattemvenkatalakshmi",
                        "content": "same what is ur code "
                    },
                    {
                        "username": "nhienlh94",
                        "content": "It\\'s so simple to be a medium question, crazy"
                    },
                    {
                        "username": "yuangaonyc",
                        "content": "Why is this medium? "
                    },
                    {
                        "username": "MichaelChan2417",
                        "content": "should be labeled EZ\\n"
                    },
                    {
                        "username": "vaibh_1406",
                        "content": "where is my code wrong, can anyone please suggest me ?? (PYTHON 3)\\n\\nclass Solution:\\n    def appendCharacters(self, s: str, t: str) -> int:\\n        res = \\'\\'\\n\\n        for i in range(len(t)):\\n            if t[i] in s:\\n                res+=t[i]\\n            else:\\n                break\\n        return (len(t) -len(res))"
                    },
                    {
                        "username": "magnusbarata",
                        "content": "A subsequence must keep the original order of appearance, while the `t[i] in s` part in your code will evaluate to `True` regardless of order in s.\\nFor the simplest case, your code will fail given the input `s=\"ab\", t=\"ba\"`. For this input, your code will return 0 (i.e every element on t exist on s, without thinking the order of appearance in s), while the expected result will be 1 (i.e. s should be \"aba\", so that t is a subsequence of s)."
                    },
                    {
                        "username": "Krishrx",
                        "content": "[@Vaibhav Verma](/vaibh_1406) I am not a python guy but according to my understanding from ur code ,ur code fails for the testcase where s=\"abcde\" t=\"abab\"  ur o/p=0 expected o/p = 2\\nthe code doesnt check for duplicates where we need to make s as abcdeab,I think u need to rewrite ur logic.\\nkindly check my java solution if u are comfortable with java\\nhttps://leetcode.com/problems/append-characters-to-string-to-make-subsequence/solutions/3749270/simple-java-solution/"
                    },
                    {
                        "username": "kmp1084",
                        "content": "gave me a chance to realize why 1143. Longest Common Subsequence cannot be used to solve this problem."
                    },
                    {
                        "username": "gattemvenkatalakshmi",
                        "content": "can anyone tell why this is wrong 78 test cases were passed\n  \n\nint i =0;\n          int prev =  s.indexOf(t.charAt(i));\n           i++;\n           if( prev ==-1)\n            return t.length();\n              while( i<t.length()){\n                   int x= s.indexOf(t.charAt(i),prev);\n                    if( x ==-1)\n                     return t.length()-i;\n                      prev =x;\n                  i++;\n              } \n               return 0;"
                    },
                    {
                        "username": "upretim",
                        "content": "prev =x+1; will fix this one, actually we need to search for next+1 index and not next,  for details, please have a look at my JavaScript solution at line no 12"
                    },
                    {
                        "username": "GhostInDanger",
                        "content": "same problem I  am facing "
                    }
                ]
            },
            {
                "id": 1704257,
                "content": [
                    {
                        "username": "Imperial_Lord",
                        "content": "Seriously, this is toooo easy to be ranked medium"
                    },
                    {
                        "username": "jain_gaurav",
                        "content": "i encountered this question in OA of Amazon."
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "u\\'ve aced it!"
                    },
                    {
                        "username": "sabonett",
                        "content": "Return the minimum number of characters that need to be `appended to the end of s` so that t becomes a subsequence of s. How t become substring of s by appending only two characters?\n\nInput:\n`s = \"ajkhe\"`\n`t = \"juh\"`\n`Output 3`\n`Expected 2`\n"
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "Its not substring.. its needs to be a Subsequence"
                    },
                    {
                        "username": "vaibh_1406",
                        "content": "because \\'j\\' already exists and you need to insert only two characters i.e \\'u\\' and \\'h\\'..!!"
                    },
                    {
                        "username": "GhostInDanger",
                        "content": " test case :https://drive.google.com/file/d/1fI0OiWFtJyRtAaPUgm-4eVn86XEq3Q09/view?usp=sharing\noutput= 96017\nExpected  output =96063 how to debug and check existing code  78 test case are passed"
                    },
                    {
                        "username": "JustinMei",
                        "content": "Thanks for your test case! It helped me a lot."
                    },
                    {
                        "username": "upretim",
                        "content": "prev =x+1; will fix this one, actually we need to search for next+1 index and not next, for details, please have a look at my JavaScript solution at line no 12\\n\\n"
                    },
                    {
                        "username": "gattemvenkatalakshmi",
                        "content": "same what is ur code "
                    },
                    {
                        "username": "nhienlh94",
                        "content": "It\\'s so simple to be a medium question, crazy"
                    },
                    {
                        "username": "yuangaonyc",
                        "content": "Why is this medium? "
                    },
                    {
                        "username": "MichaelChan2417",
                        "content": "should be labeled EZ\\n"
                    },
                    {
                        "username": "vaibh_1406",
                        "content": "where is my code wrong, can anyone please suggest me ?? (PYTHON 3)\\n\\nclass Solution:\\n    def appendCharacters(self, s: str, t: str) -> int:\\n        res = \\'\\'\\n\\n        for i in range(len(t)):\\n            if t[i] in s:\\n                res+=t[i]\\n            else:\\n                break\\n        return (len(t) -len(res))"
                    },
                    {
                        "username": "magnusbarata",
                        "content": "A subsequence must keep the original order of appearance, while the `t[i] in s` part in your code will evaluate to `True` regardless of order in s.\\nFor the simplest case, your code will fail given the input `s=\"ab\", t=\"ba\"`. For this input, your code will return 0 (i.e every element on t exist on s, without thinking the order of appearance in s), while the expected result will be 1 (i.e. s should be \"aba\", so that t is a subsequence of s)."
                    },
                    {
                        "username": "Krishrx",
                        "content": "[@Vaibhav Verma](/vaibh_1406) I am not a python guy but according to my understanding from ur code ,ur code fails for the testcase where s=\"abcde\" t=\"abab\"  ur o/p=0 expected o/p = 2\\nthe code doesnt check for duplicates where we need to make s as abcdeab,I think u need to rewrite ur logic.\\nkindly check my java solution if u are comfortable with java\\nhttps://leetcode.com/problems/append-characters-to-string-to-make-subsequence/solutions/3749270/simple-java-solution/"
                    },
                    {
                        "username": "kmp1084",
                        "content": "gave me a chance to realize why 1143. Longest Common Subsequence cannot be used to solve this problem."
                    },
                    {
                        "username": "gattemvenkatalakshmi",
                        "content": "can anyone tell why this is wrong 78 test cases were passed\n  \n\nint i =0;\n          int prev =  s.indexOf(t.charAt(i));\n           i++;\n           if( prev ==-1)\n            return t.length();\n              while( i<t.length()){\n                   int x= s.indexOf(t.charAt(i),prev);\n                    if( x ==-1)\n                     return t.length()-i;\n                      prev =x;\n                  i++;\n              } \n               return 0;"
                    },
                    {
                        "username": "upretim",
                        "content": "prev =x+1; will fix this one, actually we need to search for next+1 index and not next,  for details, please have a look at my JavaScript solution at line no 12"
                    },
                    {
                        "username": "GhostInDanger",
                        "content": "same problem I  am facing "
                    }
                ]
            }
        ]
    }
]