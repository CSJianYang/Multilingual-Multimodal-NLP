[
    {
        "title": "Step-By-Step Directions From a Binary Tree Node to Another",
        "question_content": "You are given the root of a binary tree with n nodes. Each node is uniquely assigned a value from 1 to n. You are also given an integer startValue representing the value of the start node s, and a different integer destValue representing the value of the destination node t.\nFind the shortest path starting from node s and ending at node t. Generate step-by-step directions of such path as a string consisting of only the uppercase letters 'L', 'R', and 'U'. Each letter indicates a specific direction:\n\n\t'L' means to go from a node to its left child node.\n\t'R' means to go from a node to its right child node.\n\t'U' means to go from a node to its parent node.\n\nReturn the step-by-step directions of the shortest path from node s to node t.\n&nbsp;\nExample 1:\n\nInput: root = [5,1,2,3,null,6,4], startValue = 3, destValue = 6\nOutput: \"UURL\"\nExplanation: The shortest path is: 3 &rarr; 1 &rarr; 5 &rarr; 2 &rarr; 6.\n\nExample 2:\n\nInput: root = [2,1], startValue = 2, destValue = 1\nOutput: \"L\"\nExplanation: The shortest path is: 2 &rarr; 1.\n\n&nbsp;\nConstraints:\n\n\tThe number of nodes in the tree is n.\n\t2 <= n <= 105\n\t1 <= Node.val <= n\n\tAll the values in the tree are unique.\n\t1 <= startValue, destValue <= n\n\tstartValue != destValue",
        "solutions": [
            {
                "id": 1612105,
                "title": "3-steps",
                "content": "1. Build directions for both start and destination from the root.\\n\\t- Say we get \"LLRRL\" and \"LRR\".\\n2. Remove common prefix path.\\n\\t- We remove \"L\", and now start direction is \"LRRL\", and destination - \"RR\"\\n3. Replace all steps in the start direction to \"U\" and add destination direction.\\n\\t- The result is \"UUUU\" + \"RR\".\\n\\n**C++**\\nHere, we build path in the reverse order to avoid creating new strings.\\n\\n```cpp\\nbool find(TreeNode* n, int val, string &path) {\\n    if (n->val == val)\\n        return true;\\n    if (n->left && find(n->left, val, path))\\n        path.push_back(\\'L\\');\\n    else if (n->right && find(n->right, val, path))\\n        path.push_back(\\'R\\');\\n    return !path.empty();\\n}\\nstring getDirections(TreeNode* root, int startValue, int destValue) {\\n    string s_p, d_p;\\n    find(root, startValue, s_p);\\n    find(root, destValue, d_p);\\n    while (!s_p.empty() && !d_p.empty() && s_p.back() == d_p.back()) {\\n        s_p.pop_back();\\n        d_p.pop_back();\\n    }\\n    return string(s_p.size(), \\'U\\') + string(rbegin(d_p), rend(d_p));\\n}\\n```\\n**Java**\\n```java\\nprivate boolean find(TreeNode n, int val, StringBuilder sb) {\\n    if (n.val == val) \\n        return true;\\n    if (n.left != null && find(n.left, val, sb))\\n        sb.append(\"L\");\\n    else if (n.right != null && find(n.right, val, sb))\\n        sb.append(\"R\");\\n    return sb.length() > 0;\\n}\\npublic String getDirections(TreeNode root, int startValue, int destValue) {\\n    StringBuilder s = new StringBuilder(), d = new StringBuilder();\\n    find(root, startValue, s);\\n    find(root, destValue, d);\\n    int i = 0, max_i = Math.min(d.length(), s.length());\\n    while (i < max_i && s.charAt(s.length() - i - 1) == d.charAt(d.length() - i - 1))\\n        ++i;\\n    return \"U\".repeat(s.length() - i) + d.reverse().toString().substring(i);\\n}\\n```\\n**Python 3**\\nLists in Python are mutable and passed by a reference.\\n\\n```python\\nclass Solution:\\n    def getDirections(self, root: Optional[TreeNode], startValue: int, destValue: int) -> str:\\n        def find(n: TreeNode, val: int, path: List[str]) -> bool:\\n            if n.val == val:\\n                return True\\n            if n.left and find(n.left, val, path):\\n                path += \"L\"\\n            elif n.right and find(n.right, val, path):\\n                path += \"R\"\\n            return path\\n        s, d = [], []\\n        find(root, startValue, s)\\n        find(root, destValue, d)\\n        while len(s) and len(d) and s[-1] == d[-1]:\\n            s.pop()\\n            d.pop()\\n        return \"\".join(\"U\" * len(s)) + \"\".join(reversed(d))\\n```",
                "solutionTags": [
                    "Java",
                    "Python3",
                    "C"
                ],
                "code": "```cpp\\nbool find(TreeNode* n, int val, string &path) {\\n    if (n->val == val)\\n        return true;\\n    if (n->left && find(n->left, val, path))\\n        path.push_back(\\'L\\');\\n    else if (n->right && find(n->right, val, path))\\n        path.push_back(\\'R\\');\\n    return !path.empty();\\n}\\nstring getDirections(TreeNode* root, int startValue, int destValue) {\\n    string s_p, d_p;\\n    find(root, startValue, s_p);\\n    find(root, destValue, d_p);\\n    while (!s_p.empty() && !d_p.empty() && s_p.back() == d_p.back()) {\\n        s_p.pop_back();\\n        d_p.pop_back();\\n    }\\n    return string(s_p.size(), \\'U\\') + string(rbegin(d_p), rend(d_p));\\n}\\n```\n```java\\nprivate boolean find(TreeNode n, int val, StringBuilder sb) {\\n    if (n.val == val) \\n        return true;\\n    if (n.left != null && find(n.left, val, sb))\\n        sb.append(\"L\");\\n    else if (n.right != null && find(n.right, val, sb))\\n        sb.append(\"R\");\\n    return sb.length() > 0;\\n}\\npublic String getDirections(TreeNode root, int startValue, int destValue) {\\n    StringBuilder s = new StringBuilder(), d = new StringBuilder();\\n    find(root, startValue, s);\\n    find(root, destValue, d);\\n    int i = 0, max_i = Math.min(d.length(), s.length());\\n    while (i < max_i && s.charAt(s.length() - i - 1) == d.charAt(d.length() - i - 1))\\n        ++i;\\n    return \"U\".repeat(s.length() - i) + d.reverse().toString().substring(i);\\n}\\n```\n```python\\nclass Solution:\\n    def getDirections(self, root: Optional[TreeNode], startValue: int, destValue: int) -> str:\\n        def find(n: TreeNode, val: int, path: List[str]) -> bool:\\n            if n.val == val:\\n                return True\\n            if n.left and find(n.left, val, path):\\n                path += \"L\"\\n            elif n.right and find(n.right, val, path):\\n                path += \"R\"\\n            return path\\n        s, d = [], []\\n        find(root, startValue, s)\\n        find(root, destValue, d)\\n        while len(s) and len(d) and s[-1] == d[-1]:\\n            s.pop()\\n            d.pop()\\n        return \"\".join(\"U\" * len(s)) + \"\".join(reversed(d))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1613071,
                "title": "idea-explained-lca-tree-traversal-backtracking-c-clean-code",
                "content": "**Idea :**\\n------------------------\\n* This is a very nice problem as one require multiple concepts. Like \\n\\t* **Lowest Common Ancestor** \\n\\t* **DFS** : *Tree Traversal and Backtracking* (to get Path b/w nodes)\\n\\n* First let us make couple of observations and note it down : \\n\\n\\t* How to get shortest distance/path b/w two node in Binary Tree?\\n\\n\\t\\t* We need to find closest point(from nodes), where path from root to nodes intersect\\n\\t\\n\\t\\t* This is nothing but the **LCA**(Lowest Common Ancestor) of two nodes.\\n\\t* Now, if we move from **start node to LCA node**, which direction we will follow : `U(up)` , `L(left)` or `R(right)` ? \\n\\t\\n\\t\\t* Here we can surely say since LCA always lie above the node, so we will move in upward direction.\\n\\t\\t\\n\\t\\t* And there can also be a case when **start node itself is LCA**, so no need to worry in this case.\\n\\n* Now coming back to our problem, we need to get shortest path from `start -> destination` ,  or\\n\\t* in other words path from \\n\\t\\t\\n\\t\\t\\t\"start -> LCA\" + \"LCA -> destination\"\\n\\t\\t\\t\\n\\t\\t\\t-> But we cannot find \"start -> LCA\" directly. i.e from bottom to up\\n\\t\\t\\t-> What we can do instead is first find top to down path \\n\\t\\t\\t\\t\\ti.e \"LCA -> start\" , using normal tree traversal algo\\n\\t\\t\\t-> and then convert it such that we move in upward direction. (Observation: 2)\\n\\t\\t\\t\\n\\n* Thus, putting all these together. Lets write a **step-by-step** algorithm to get directions : \\n\\t1. First of all find the LCA node of `start` and `destination`.\\n\\n\\t2. Then we need to get path from `lca_to_start` and from `lca_to_destination`.\\n\\t3. To get path from `root -> node` as a string, we will use `traverse()` function.\\n\\t\\t* In this we simply do a simple **DFS** ( kind of pre-order traversal)\\n\\t\\t* First explore left path, if node is found. Then return true. \\n\\t\\t* Otherwise backtrack and explore right path. \\n\\n\\t4. Now that we have both paths, we will convert all chars in `lca_to_start` to `U`, since we will move upward.\\n\\t5. At last, concatenate both strings and return combined path.\\n\\n* Lets see this through an example : \\n\\t\\t\\t\\t\\t  \\n\\t\\tGiven : start = 3, destination = 6\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t\\t\\t  5   ---> LCA(3,6)\\n\\t\\t\\t\\t\\t\\t\\t/   \\\\\\n\\t\\t\\t\\t\\t\\t   1     2\\n\\t\\t\\t\\t\\t\\t  /     /  \\\\\\n\\t\\t\\tstart <---\\t\\'3\\'   \\'6\\'    4\\n\\t\\t\\t\\t\\t\\t\\t   ^\\n\\t\\t\\t\\t\\t\\t\\t   |\\n\\t\\t\\t\\t\\t\\t   destination\\n\\t\\t\\t\\t\\t\\t   \\n\\t\\t-> So here node \\'5\\' is LCA of start(3) and dest(3)\\n\\t\\t-> path from lca_to_start = \\'5 -> 1 -> 3\\' = \"L L\"\\n\\t\\t-> path from lca_to_dest = \\'5 -> 2 -> 6\\' = \"R L\"\\n\\t\\t\\n\\t\\tAlso, since we know that shortest path from \\n\\t\\t\\t# start-> destination = \\'start -> LCA\\' + \\'LCA -> destination\\'\\n\\t\\t\\t\\n\\t\\tSo, we need to convert (reverse) `lca_to_start` = \"U U\" , as we move in upward direction\\n\\t\\t\\n\\t\\tTherefore, final path = \"U U\" + \"R L\" = \"U U R L\"\\n\\n------------------------\\n# **Code**:\\n------------------------\\n<iframe src=\"https://leetcode.com/playground/EvtBGr4m/shared\" frameBorder=\"0\" width=\"1000\" height=\"500\"></iframe>\\n\\n------------------------\\n**Complexity :**\\n\\n* Time : `O(N + N + N)` , N is number of nodes in binary tree\\n\\t* Since first get LCA, so `O(N)` for that\\n\\t* Then to get path from LCA to start and destination, so `O(N)`\\n\\t* At last we convert `lca_to_start` string to \\'U\\' and concatenate, so ~`O(N)`\\n\\n* Space : `O(N)`\\n------------------------\\n***If you find this helpful, do give it a LIKE :)***",
                "solutionTags": [
                    "Backtracking",
                    "Tree",
                    "Depth-First Search",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "**Idea :**\\n------------------------\\n* This is a very nice problem as one require multiple concepts. Like \\n\\t* **Lowest Common Ancestor** \\n\\t* **DFS** : *Tree Traversal and Backtracking* (to get Path b/w nodes)\\n\\n* First let us make couple of observations and note it down : \\n\\n\\t* How to get shortest distance/path b/w two node in Binary Tree?\\n\\n\\t\\t* We need to find closest point(from nodes), where path from root to nodes intersect\\n\\t\\n\\t\\t* This is nothing but the **LCA**(Lowest Common Ancestor) of two nodes.\\n\\t* Now, if we move from **start node to LCA node**, which direction we will follow : `U(up)` , `L(left)` or `R(right)` ? \\n\\t\\n\\t\\t* Here we can surely say since LCA always lie above the node, so we will move in upward direction.\\n\\t\\t\\n\\t\\t* And there can also be a case when **start node itself is LCA**, so no need to worry in this case.\\n\\n* Now coming back to our problem, we need to get shortest path from `start -> destination` ,  or\\n\\t* in other words path from \\n\\t\\t\\n\\t\\t\\t\"start -> LCA\" + \"LCA -> destination\"\\n\\t\\t\\t\\n\\t\\t\\t-> But we cannot find \"start -> LCA\" directly. i.e from bottom to up\\n\\t\\t\\t-> What we can do instead is first find top to down path \\n\\t\\t\\t\\t\\ti.e \"LCA -> start\" , using normal tree traversal algo\\n\\t\\t\\t-> and then convert it such that we move in upward direction. (Observation: 2)\\n\\t\\t\\t\\n\\n* Thus, putting all these together. Lets write a **step-by-step** algorithm to get directions : \\n\\t1. First of all find the LCA node of `start` and `destination`.\\n\\n\\t2. Then we need to get path from `lca_to_start` and from `lca_to_destination`.\\n\\t3. To get path from `root -> node` as a string, we will use `traverse()` function.\\n\\t\\t* In this we simply do a simple **DFS** ( kind of pre-order traversal)\\n\\t\\t* First explore left path, if node is found. Then return true. \\n\\t\\t* Otherwise backtrack and explore right path. \\n\\n\\t4. Now that we have both paths, we will convert all chars in `lca_to_start` to `U`, since we will move upward.\\n\\t5. At last, concatenate both strings and return combined path.\\n\\n* Lets see this through an example : \\n\\t\\t\\t\\t\\t  \\n\\t\\tGiven : start = 3, destination = 6\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t\\t\\t  5   ---> LCA(3,6)\\n\\t\\t\\t\\t\\t\\t\\t/   \\\\\\n\\t\\t\\t\\t\\t\\t   1     2\\n\\t\\t\\t\\t\\t\\t  /     /  \\\\\\n\\t\\t\\tstart <---\\t\\'3\\'   \\'6\\'    4\\n\\t\\t\\t\\t\\t\\t\\t   ^\\n\\t\\t\\t\\t\\t\\t\\t   |\\n\\t\\t\\t\\t\\t\\t   destination\\n\\t\\t\\t\\t\\t\\t   \\n\\t\\t-> So here node \\'5\\' is LCA of start(3) and dest(3)\\n\\t\\t-> path from lca_to_start = \\'5 -> 1 -> 3\\' = \"L L\"\\n\\t\\t-> path from lca_to_dest = \\'5 -> 2 -> 6\\' = \"R L\"\\n\\t\\t\\n\\t\\tAlso, since we know that shortest path from \\n\\t\\t\\t# start-> destination = \\'start -> LCA\\' + \\'LCA -> destination\\'\\n\\t\\t\\t\\n\\t\\tSo, we need to convert (reverse) `lca_to_start` = \"U U\" , as we move in upward direction\\n\\t\\t\\n\\t\\tTherefore, final path = \"U U\" + \"R L\" = \"U U R L\"\\n\\n------------------------\\n# **Code**:\\n------------------------\\n<iframe src=\"https://leetcode.com/playground/EvtBGr4m/shared\" frameBorder=\"0\" width=\"1000\" height=\"500\"></iframe>\\n\\n------------------------\\n**Complexity :**\\n\\n* Time : `O(N + N + N)` , N is number of nodes in binary tree\\n\\t* Since first get LCA, so `O(N)` for that\\n\\t* Then to get path from LCA to start and destination, so `O(N)`\\n\\t* At last we convert `lca_to_start` string to \\'U\\' and concatenate, so ~`O(N)`\\n\\n* Space : `O(N)`\\n------------------------\\n***If you find this helpful, do give it a LIKE :)***",
                "codeTag": "Unknown"
            },
            {
                "id": 1612179,
                "title": "python3-lca",
                "content": "Please check out this [commit](https://github.com/gaosanyong/leetcode/commit/b1948f8814bebeca475cbb354cd44d19092dff59) for solutions of weekly 270.\\n\\n```\\nclass Solution:\\n    def getDirections(self, root: Optional[TreeNode], startValue: int, destValue: int) -> str:\\n        \\n        def lca(node): \\n            \"\"\"Return lowest common ancestor of start and dest nodes.\"\"\"\\n            if not node or node.val in (startValue , destValue): return node \\n            left, right = lca(node.left), lca(node.right)\\n            return node if left and right else left or right\\n        \\n        root = lca(root) # only this sub-tree matters\\n        \\n        ps = pd = \"\"\\n        stack = [(root, \"\")]\\n        while stack: \\n            node, path = stack.pop()\\n            if node.val == startValue: ps = path \\n            if node.val == destValue: pd = path\\n            if node.left: stack.append((node.left, path + \"L\"))\\n            if node.right: stack.append((node.right, path + \"R\"))\\n        return \"U\"*len(ps) + pd\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def getDirections(self, root: Optional[TreeNode], startValue: int, destValue: int) -> str:\\n        \\n        def lca(node): \\n            \"\"\"Return lowest common ancestor of start and dest nodes.\"\"\"\\n            if not node or node.val in (startValue , destValue): return node \\n            left, right = lca(node.left), lca(node.right)\\n            return node if left and right else left or right\\n        \\n        root = lca(root) # only this sub-tree matters\\n        \\n        ps = pd = \"\"\\n        stack = [(root, \"\")]\\n        while stack: \\n            node, path = stack.pop()\\n            if node.val == startValue: ps = path \\n            if node.val == destValue: pd = path\\n            if node.left: stack.append((node.left, path + \"L\"))\\n            if node.right: stack.append((node.right, path + \"R\"))\\n        return \"U\"*len(ps) + pd\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1611977,
                "title": "c-solution-find-lca",
                "content": "\\n1. apply LCA to get a new root.\\n2. get the Path from the new root to start and dest.\\n3. concate startPath and destPath, note that we need to replace startPath\\'s char to \\'U\\'\\n```\\nclass Solution {\\npublic:\\n    TreeNode* lca(TreeNode *root, int startValue, int destValue) {\\n        if(!root) return NULL;\\n        if(root->val == startValue) return root;\\n        if(root->val == destValue) return root;\\n        auto l = lca(root->left, startValue, destValue);\\n        auto r = lca(root->right, startValue, destValue);\\n        if(l && r) return root;\\n        return l ? l : r;\\n    }\\n    bool getPath(TreeNode *root, int value, string &path) {\\n        if(!root) return false;\\n        if(root->val == value) return true;\\n        path += \\'L\\';\\n        auto res = getPath(root->left, value, path);\\n        if(res) return true;\\n        path.pop_back();\\n        path += \\'R\\';\\n        res = getPath(root->right, value, path);\\n        if(res) return true;\\n        path.pop_back();\\n        return false;\\n    }\\n    string getDirections(TreeNode* root, int startValue, int destValue) {\\n        root = lca(root, startValue, destValue);\\n        string p1, p2;\\n        getPath(root, startValue, p1);\\n        getPath(root, destValue, p2);\\n        for(auto &c : p1) c = \\'U\\';\\n        return p1 + p2;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    TreeNode* lca(TreeNode *root, int startValue, int destValue) {\\n        if(!root) return NULL;\\n        if(root->val == startValue) return root;\\n        if(root->val == destValue) return root;\\n        auto l = lca(root->left, startValue, destValue);\\n        auto r = lca(root->right, startValue, destValue);\\n        if(l && r) return root;\\n        return l ? l : r;\\n    }\\n    bool getPath(TreeNode *root, int value, string &path) {\\n        if(!root) return false;\\n        if(root->val == value) return true;\\n        path += \\'L\\';\\n        auto res = getPath(root->left, value, path);\\n        if(res) return true;\\n        path.pop_back();\\n        path += \\'R\\';\\n        res = getPath(root->right, value, path);\\n        if(res) return true;\\n        path.pop_back();\\n        return false;\\n    }\\n    string getDirections(TreeNode* root, int startValue, int destValue) {\\n        root = lca(root, startValue, destValue);\\n        string p1, p2;\\n        getPath(root, startValue, p1);\\n        getPath(root, destValue, p2);\\n        for(auto &c : p1) c = \\'U\\';\\n        return p1 + p2;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1612123,
                "title": "this-actually-contains-several-tree-questions-nice-one",
                "content": "1. get lowest common ancestor \\n2. find the path from ancestor to start / dest\\n(Actually we dont need ancestor to start, we just need the depth to fill several \"U\"s, so it\\'s a calculate depth sub-question. I didnt implement that because I could just re-use the get dir method)\\n\\nSo this is a very good tree question\\nlowestCommonAncestor  + find path + calculate depth\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public String getDirections(TreeNode root, int startValue, int destValue) {\\n        TreeNode ancestor = lowestCommonAncestor(root, startValue, destValue);\\n        List<String> toStart = new ArrayList<>();\\n        getDirection(ancestor, startValue, toStart);\\n        List<String> toDest = new ArrayList<>();\\n        getDirection(ancestor, destValue, toDest);\\n        StringBuilder sb = new StringBuilder();\\n        for (int i = 0; i < toStart.size(); i++) sb.append(\"U\");\\n        for (String s : toDest) sb.append(s);\\n        return sb.toString();\\n    }\\n    \\n    private TreeNode lowestCommonAncestor(TreeNode root, int p, int q) {\\n        if (root == null || p == root.val || q == root.val) return root; \\n        TreeNode left = lowestCommonAncestor(root.left, p, q);\\n        TreeNode right = lowestCommonAncestor(root.right, p, q);\\n        if (left != null && right != null) return root; \\n        else return left == null ? right : left;\\n    }\\n    \\n    private boolean getDirection(TreeNode ancestor, int value, List<String> steps) {\\n        if (ancestor == null) return false;\\n        if (ancestor.val == value) return true;\\n        steps.add(\"L\");\\n        if (getDirection(ancestor.left, value, steps)) return true;\\n        steps.remove(steps.size() - 1);\\n        steps.add(\"R\");\\n        if (getDirection(ancestor.right, value, steps)) return true;\\n        steps.remove(steps.size() - 1);\\n        return false;\\n    }\\n}",
                "solutionTags": [
                    "Tree",
                    "Recursion"
                ],
                "code": "class Solution {\\n    public String getDirections(TreeNode root, int startValue, int destValue) {\\n        TreeNode ancestor = lowestCommonAncestor(root, startValue, destValue);\\n        List<String> toStart = new ArrayList<>();\\n        getDirection(ancestor, startValue, toStart);\\n        List<String> toDest = new ArrayList<>();\\n        getDirection(ancestor, destValue, toDest);\\n        StringBuilder sb = new StringBuilder();\\n        for (int i = 0; i < toStart.size(); i++) sb.append(\"U\");\\n        for (String s : toDest) sb.append(s);\\n        return sb.toString();\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1612293,
                "title": "c-lca-simple-solution-with-explanation",
                "content": "Basically, we want to got to destValue from startValue. But,since a tree is a **directed graph**. So, we can only move from parent to child. So, **how to move from any node to any other node?**\\n\\nWhat if,  we  find LCA(lowest common Ancestor) of both nodes. Then we can move from LCA to startValue and then again LCA to destValue. \\nSay, \\n```\\n\\t   Path1 = LCA to startValue\\n\\t   Path2=  LCA to destValue\\n```\\nIn this way, we can cover the whole path(path1 + path2).  But, there is  a problem. And the problem is - **the first path(path1) will be from LCA to startValue(Top to bottom). But, we want the path from startValue to LCA.**\\nSo, we after getting the path from LCA to startValue, **we will update L and R with U** (since we are going up).\\n\\nFinally, we will be adding both path1 and path2 to get the complete path.\\n\\nConsider below C++ solution :\\n```\\nclass Solution {\\npublic:\\n    bool search(TreeNode* root, int target, string &s){\\n        if(root==NULL) {\\n            return false;\\n        }\\n        if(root->val==target) {\\n            return true;\\n        }\\n        \\n        bool find1=search(root->left,target, s+=\\'L\\');  // search on left side\\n        if(find1) return true;\\n        s.pop_back(); // backtracking step\\n        \\n        bool find2= search(root->right,target, s+=\\'R\\'); // search on right side\\n        if(find2) return true;\\n        s.pop_back(); // backtracking step\\n        return false;\\n    }\\n  \\n     TreeNode* lca(TreeNode* root ,int n1 ,int n2)\\n    {\\n       if(root==NULL)\\n       return NULL;\\n       if(root->val==n1 or root->val==n2)\\n       return root;\\n       \\n       TreeNode* left=lca(root->left,n1,n2);\\n       TreeNode* right=lca(root->right,n1,n2);\\n       \\n       if(left!=NULL && right!=NULL)\\n       return root;\\n       if(left)\\n       return left;\\n       if(right)\\n       return right;\\n       \\n       return NULL; // not present in tree\\n       \\n    }\\n    string getDirections(TreeNode* root, int startValue, int destValue) {\\n        TreeNode* temp=lca(root,startValue,destValue);\\n        \\n        string s1,s2;\\n        search(temp,startValue,s1);\\n        search(temp,destValue,s2);\\n        for(auto &it:s1){\\n            it=\\'U\\';\\n        }\\n        return s1+s2;\\n    }\\n};\\n```\\n***If this post helped you in anyway, please upvote it so that it can help others too***!",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n\\t   Path1 = LCA to startValue\\n\\t   Path2=  LCA to destValue\\n```\n```\\nclass Solution {\\npublic:\\n    bool search(TreeNode* root, int target, string &s){\\n        if(root==NULL) {\\n            return false;\\n        }\\n        if(root->val==target) {\\n            return true;\\n        }\\n        \\n        bool find1=search(root->left,target, s+=\\'L\\');  // search on left side\\n        if(find1) return true;\\n        s.pop_back(); // backtracking step\\n        \\n        bool find2= search(root->right,target, s+=\\'R\\'); // search on right side\\n        if(find2) return true;\\n        s.pop_back(); // backtracking step\\n        return false;\\n    }\\n  \\n     TreeNode* lca(TreeNode* root ,int n1 ,int n2)\\n    {\\n       if(root==NULL)\\n       return NULL;\\n       if(root->val==n1 or root->val==n2)\\n       return root;\\n       \\n       TreeNode* left=lca(root->left,n1,n2);\\n       TreeNode* right=lca(root->right,n1,n2);\\n       \\n       if(left!=NULL && right!=NULL)\\n       return root;\\n       if(left)\\n       return left;\\n       if(right)\\n       return right;\\n       \\n       return NULL; // not present in tree\\n       \\n    }\\n    string getDirections(TreeNode* root, int startValue, int destValue) {\\n        TreeNode* temp=lca(root,startValue,destValue);\\n        \\n        string s1,s2;\\n        search(temp,startValue,s1);\\n        search(temp,destValue,s2);\\n        for(auto &it:s1){\\n            it=\\'U\\';\\n        }\\n        return s1+s2;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2005805,
                "title": "python3-dfs-easy-solution-using-deque",
                "content": "```\\nclass Solution:\\n    def getDirections(self, root: Optional[TreeNode], startValue: int, destValue: int) -> str:\\n        # The idea is that we find paths for both start and target nodes.\\n        # Once we have found them we reduce paths to a lowest common parent node.\\n        # We change the all items in path of start to \\'U\\' and keep the path of target same.\\n        def dfs(node, target, path):\\n            if not node:\\n                return False\\n\\n            if node.val == target:\\n                return True\\n\\n            if node.left:\\n                if dfs(node.left, target, path):\\n                    path.appendleft(\\'L\\')\\n                    return True\\n\\n            if node.right:\\n                if dfs(node.right, target, path):\\n                    path.appendleft(\\'R\\')\\n                    return True                \\n            \\n        s_path, t_path = deque(), deque()\\n        dfs(root, startValue, s_path)\\n        dfs(root, destValue, t_path)\\n        \\n        while s_path and t_path and s_path[0] == t_path[0]:\\n            s_path.popleft()\\n            t_path.popleft()\\n        \\n        return \\'U\\' * len(s_path) + \\'\\'.join(t_path)\\n",
                "solutionTags": [
                    "Python",
                    "Depth-First Search",
                    "Queue"
                ],
                "code": "```\\nclass Solution:\\n    def getDirections(self, root: Optional[TreeNode], startValue: int, destValue: int) -> str:\\n        # The idea is that we find paths for both start and target nodes.\\n        # Once we have found them we reduce paths to a lowest common parent node.\\n        # We change the all items in path of start to \\'U\\' and keep the path of target same.\\n        def dfs(node, target, path):\\n            if not node:\\n                return False\\n\\n            if node.val == target:\\n                return True\\n\\n            if node.left:\\n                if dfs(node.left, target, path):\\n                    path.appendleft(\\'L\\')\\n                    return True\\n\\n            if node.right:\\n                if dfs(node.right, target, path):\\n                    path.appendleft(\\'R\\')\\n                    return True                \\n            \\n        s_path, t_path = deque(), deque()\\n        dfs(root, startValue, s_path)\\n        dfs(root, destValue, t_path)\\n        \\n        while s_path and t_path and s_path[0] == t_path[0]:\\n            s_path.popleft()\\n            t_path.popleft()\\n        \\n        return \\'U\\' * len(s_path) + \\'\\'.join(t_path)\\n",
                "codeTag": "Java"
            },
            {
                "id": 1612071,
                "title": "accepted-python-super-simple-dfs-bfs",
                "content": "3 Step Process:\\n1. Do a recursive DFS and mark each node\\'s parent in the ListNode class.\\n2. Save the value of `startNode` and `endNode`.\\n3. Start a BFS from the `startNode` till you reach `endNode` recording the path on the way. You\\'re guarenteed to reach `endNode` by the shortest path.\\n\\nTime Complexity: `O(n)`\\nSpace Complexity: `O(n)`\\n\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\n#         self.parent = parent\\n\\nclass Solution:\\n    def getDirections(self, root: Optional[TreeNode], startValue: int, destValue: int) -> str:\\n        self.startNode = None\\n        self.endNode = None      \\n        \\n        def createParent(root, parent):\\n            if not root:\\n                return\\n            \\n            root.parent = parent\\n            createParent(root.left, root)\\n            createParent(root.right, root)\\n            \\n            if root.val == startValue:\\n                self.startNode = root\\n            if root.val == destValue:\\n                self.endNode = root\\n            \\n            return\\n        \\n        createParent(root, None)\\n        \\n        queue = [(self.startNode, \"\")]\\n        visited = set()\\n        visited.add(self.startNode.val)\\n        \\n        while queue:\\n            node, value = queue.pop(0)\\n            \\n            if node == self.endNode:\\n                return value\\n            \\n            if node.parent and node.parent.val not in visited:\\n                queue.append((node.parent, value+\"U\"))\\n                visited.add(node.parent.val)\\n            \\n            if node.right and node.right.val not in visited:\\n                queue.append((node.right, value+\"R\"))\\n                visited.add(node.right.val)\\n            \\n            if node.left and node.left.val not in visited:\\n                queue.append((node.left, value+\"L\"))\\n                visited.add(node.left.val)\\n        \\n        return \"\"\\n```",
                "solutionTags": [
                    "Python",
                    "Tree",
                    "Depth-First Search",
                    "Breadth-First Search"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\n#         self.parent = parent\\n\\nclass Solution:\\n    def getDirections(self, root: Optional[TreeNode], startValue: int, destValue: int) -> str:\\n        self.startNode = None\\n        self.endNode = None      \\n        \\n        def createParent(root, parent):\\n            if not root:\\n                return\\n            \\n            root.parent = parent\\n            createParent(root.left, root)\\n            createParent(root.right, root)\\n            \\n            if root.val == startValue:\\n                self.startNode = root\\n            if root.val == destValue:\\n                self.endNode = root\\n            \\n            return\\n        \\n        createParent(root, None)\\n        \\n        queue = [(self.startNode, \"\")]\\n        visited = set()\\n        visited.add(self.startNode.val)\\n        \\n        while queue:\\n            node, value = queue.pop(0)\\n            \\n            if node == self.endNode:\\n                return value\\n            \\n            if node.parent and node.parent.val not in visited:\\n                queue.append((node.parent, value+\"U\"))\\n                visited.add(node.parent.val)\\n            \\n            if node.right and node.right.val not in visited:\\n                queue.append((node.right, value+\"R\"))\\n                visited.add(node.right.val)\\n            \\n            if node.left and node.left.val not in visited:\\n                queue.append((node.left, value+\"L\"))\\n                visited.add(node.left.val)\\n        \\n        return \"\"\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1781093,
                "title": "java-dfs-solution-o-n-solution-easy-to-understand",
                "content": "* Let **p1 =  start > root** path.\\n* Let **p2 = end > root** path.\\n* Remove common prefix path between **p1** and **p2**\\n* Replace all the remaining part of **p1** to **\"U\"**\\n* Reverse the remaining the part of **p2**\\n* Add **p1** and **p2**\\n\\n**Solution:**\\n```\\nclass Solution {\\n    \\n    private boolean DFS(TreeNode currNode, StringBuilder path, int destVal) {\\n        if(currNode == null) return false;\\n        if(currNode.val == destVal) return true;\\n        if(DFS(currNode.left, path, destVal)) path.append(\"L\");\\n        else if(DFS(currNode.right, path, destVal)) path.append(\"R\");\\n        return path.length() > 0;\\n    }\\n    \\n    public String getDirections(TreeNode root, int startValue, int destValue) {\\n        StringBuilder startToRoot = new StringBuilder();\\n        StringBuilder endToRoot = new StringBuilder();\\n        \\n        DFS(root, startToRoot, startValue);\\n        DFS(root, endToRoot, destValue);\\n        \\n        int i = startToRoot.length(), j = endToRoot.length();\\n        int cnt = 0;\\n        while(i > 0 && j > 0 && startToRoot.charAt(i-1) == endToRoot.charAt(j-1)) {\\n            cnt++; i--; j--;\\n        }\\n        \\n        String sPath = \"U\".repeat(startToRoot.length() - cnt);\\n        String ePath = endToRoot.reverse().toString().substring(cnt, endToRoot.length());\\n        \\n        return sPath + ePath;\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "Java",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    \\n    private boolean DFS(TreeNode currNode, StringBuilder path, int destVal) {\\n        if(currNode == null) return false;\\n        if(currNode.val == destVal) return true;\\n        if(DFS(currNode.left, path, destVal)) path.append(\"L\");\\n        else if(DFS(currNode.right, path, destVal)) path.append(\"R\");\\n        return path.length() > 0;\\n    }\\n    \\n    public String getDirections(TreeNode root, int startValue, int destValue) {\\n        StringBuilder startToRoot = new StringBuilder();\\n        StringBuilder endToRoot = new StringBuilder();\\n        \\n        DFS(root, startToRoot, startValue);\\n        DFS(root, endToRoot, destValue);\\n        \\n        int i = startToRoot.length(), j = endToRoot.length();\\n        int cnt = 0;\\n        while(i > 0 && j > 0 && startToRoot.charAt(i-1) == endToRoot.charAt(j-1)) {\\n            cnt++; i--; j--;\\n        }\\n        \\n        String sPath = \"U\".repeat(startToRoot.length() - cnt);\\n        String ePath = endToRoot.reverse().toString().substring(cnt, endToRoot.length());\\n        \\n        return sPath + ePath;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1612110,
                "title": "javascript-lca-as-common-prefix-in-paths",
                "content": "Idea:\\n- Get the paths to both the start node and the end node\\n- Find the node that is the lowest common ancestor to both nodes\\n\\t- This is equivalent to the last character in which the prefix of `startPath` and `endPath` are the same\\n- The final path consists of walking \"up\" (\\'U\\') from the start node to the ancestor, then walking \"down\" (\\'L/R\\') to the end node\\n\\nO(n) time for the tree traversal.\\nO(h) space for recursion, stack depth is at most `h` where `h` is the height of the tree.\\n```\\nvar getDirections = function(root, startValue, destValue) {\\n    const getPath = (node, value, acc=\\'\\') => {\\n        if (node === null) {\\n            return \\'\\';\\n        } else if (node.val === value) {\\n            return acc;\\n        } else {\\n            return getPath(node.left, value, acc + \\'L\\') + getPath(node.right, value, acc + \\'R\\')\\n        }\\n    }\\n    \\n\\t// generate the paths\\n    let startPath = getPath(root, startValue);\\n    let destPath = getPath(root, destValue);\\n    \\n    // find the lowest common ancestor\\n    let i = 0;\\n    for (; i < startPath.length && i < destPath.length && startPath[i] === destPath[i]; i++);\\n    \\n\\t// output the final path\\n    let output = \\'\\';\\n    for (let j = i; j < startPath.length; j++) {\\n        output += \\'U\\';\\n    }\\n    \\n    return output + destPath.substring(i);\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Tree"
                ],
                "code": "```\\nvar getDirections = function(root, startValue, destValue) {\\n    const getPath = (node, value, acc=\\'\\') => {\\n        if (node === null) {\\n            return \\'\\';\\n        } else if (node.val === value) {\\n            return acc;\\n        } else {\\n            return getPath(node.left, value, acc + \\'L\\') + getPath(node.right, value, acc + \\'R\\')\\n        }\\n    }\\n    \\n\\t// generate the paths\\n    let startPath = getPath(root, startValue);\\n    let destPath = getPath(root, destValue);\\n    \\n    // find the lowest common ancestor\\n    let i = 0;\\n    for (; i < startPath.length && i < destPath.length && startPath[i] === destPath[i]; i++);\\n    \\n\\t// output the final path\\n    let output = \\'\\';\\n    for (let j = i; j < startPath.length; j++) {\\n        output += \\'U\\';\\n    }\\n    \\n    return output + destPath.substring(i);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1728875,
                "title": "2-python-solutions-graph-based-lca",
                "content": "#### **Solution 1: Graph Based, passed**\\n#### Space=O(N) for building graph and queue. Time= O(N) for traversing the tree and for the BFS\\nThe idea is build an undirected graph, the directions from Node1--> Node2 is either L or R, and the opposite Node2-->1 is always U\\n```\\nclass Solution:\\n    def getDirections(self, root: Optional[TreeNode], startValue: int, destValue: int) -> str:\\n\\t\\n        graph=defaultdict(list)    \\n        stack=[(root)]\\n\\t\\t\\n\\t\\t#Step1: Build Graph\\n        while stack:\\n            node=stack.pop()\\n            \\n            if node.left:\\n                graph[node.val].append((node.left.val,\"L\"))\\n                graph[node.left.val].append((node.val,\"U\"))\\n                stack.append(node.left)\\n            if node.right:\\n                graph[node.val].append((node.right.val,\"R\"))\\n                graph[node.right.val].append((node.val,\"U\"))\\n                stack.append(node.right)\\n        #Step 2: Normal BFS\\n        q=deque([(startValue,\"\")])\\n        seen=set()\\n        seen.add(startValue)\\n        \\n        while q:\\n            node,path=q.popleft()\\n            if node==destValue:\\n                return path\\n            \\n            for neigh in graph[node]:\\n                v,d=neigh\\n                if v not in seen:\\n                    q.append((v,path+d))\\n                    seen.add(v)\\n        return -1\\n```\\n\\n#### **Solution 2: LCA with getPath recursion: Memory Limit Exceded**\\n#### When I tried the LCA solution, I got the path from LCA to start and LCA to end recursively which is correct, but didn\\'t pass memory constraint\\nThe idea is that the 2 nodes must have a LCA, if you get the LCA, then the answer is startNode to LCA + LCA to dest node, but if you notice the first part start to LCA is always \\'U\\', but I do care about the length, how many U\\'\\'s? so I still get the path from start to LCA then I relace the path with U\\'s\\n```\\nclass Solution:\\n    def getDirections(self, root: Optional[TreeNode], startValue: int, destValue: int) -> str:\\n        \\n        def getLCA(root,p,q):\\n            if not root: return None\\n            if root.val==p or root.val==q:\\n                return root\\n            L=getLCA(root.left,p,q)\\n            R=getLCA(root.right,p,q)\\n            if L and R:\\n                return root\\n            return L or R\\n        \\n        \\n        def getPath(node1,node2,path): #---> Problem here\\n            if not node1: return\\n            if node1.val==node2: return path\\n            return getPath(node1.left,node2,path+[\"L\"]) or getPath(node1.right,node2,path+[\"R\"])\\n            \\n        \\n        LCA=getLCA(root,startValue,destValue)\\n        path1=getPath(LCA,startValue,[]) \\n        path2=getPath(LCA,destValue,[])\\n        path=[\"U\"]*len(path1) + path2 if path1 else path2 \\n        return \"\".join(path)\\n      \\n```\\n\\n#### **Solution 2 Revisited: LCA then get path iterative*\\nExact same idea as above, the only change is getPath,\\n```\\nclass Solution:\\n    def getDirections(self, root: Optional[TreeNode], startValue: int, destValue: int) -> str:\\n        \\n        #soltion 2 LCA\\n        def getLCA(root,p,q):\\n            if not root: return None\\n            if root.val==p or root.val==q:\\n                return root\\n            L=getLCA(root.left,p,q)\\n            R=getLCA(root.right,p,q)\\n            if L and R:\\n                return root\\n            return L or R\\n    \\n            \\n        \\n        LCA=getLCA(root,startValue,destValue)\\n        ps,pd=\"\",\"\"\\n        stack = [(LCA, \"\")]\\n        while stack: \\n            node, path = stack.pop()\\n            if node.val == startValue: ps = path \\n            if node.val == destValue: pd = path\\n            if node.left: stack.append((node.left, path + \"L\"))\\n            if node.right: stack.append((node.right, path + \"R\"))\\n                \\n        return \"U\"*len(ps) + pd\\n```\\n\\n**A 3rd solution is getting the depth of each node from the root, then removing the common prefix.\\n**",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Graph"
                ],
                "code": "```\\nclass Solution:\\n    def getDirections(self, root: Optional[TreeNode], startValue: int, destValue: int) -> str:\\n\\t\\n        graph=defaultdict(list)    \\n        stack=[(root)]\\n\\t\\t\\n\\t\\t#Step1: Build Graph\\n        while stack:\\n            node=stack.pop()\\n            \\n            if node.left:\\n                graph[node.val].append((node.left.val,\"L\"))\\n                graph[node.left.val].append((node.val,\"U\"))\\n                stack.append(node.left)\\n            if node.right:\\n                graph[node.val].append((node.right.val,\"R\"))\\n                graph[node.right.val].append((node.val,\"U\"))\\n                stack.append(node.right)\\n        #Step 2: Normal BFS\\n        q=deque([(startValue,\"\")])\\n        seen=set()\\n        seen.add(startValue)\\n        \\n        while q:\\n            node,path=q.popleft()\\n            if node==destValue:\\n                return path\\n            \\n            for neigh in graph[node]:\\n                v,d=neigh\\n                if v not in seen:\\n                    q.append((v,path+d))\\n                    seen.add(v)\\n        return -1\\n```\n```\\nclass Solution:\\n    def getDirections(self, root: Optional[TreeNode], startValue: int, destValue: int) -> str:\\n        \\n        def getLCA(root,p,q):\\n            if not root: return None\\n            if root.val==p or root.val==q:\\n                return root\\n            L=getLCA(root.left,p,q)\\n            R=getLCA(root.right,p,q)\\n            if L and R:\\n                return root\\n            return L or R\\n        \\n        \\n        def getPath(node1,node2,path): #---> Problem here\\n            if not node1: return\\n            if node1.val==node2: return path\\n            return getPath(node1.left,node2,path+[\"L\"]) or getPath(node1.right,node2,path+[\"R\"])\\n            \\n        \\n        LCA=getLCA(root,startValue,destValue)\\n        path1=getPath(LCA,startValue,[]) \\n        path2=getPath(LCA,destValue,[])\\n        path=[\"U\"]*len(path1) + path2 if path1 else path2 \\n        return \"\".join(path)\\n      \\n```\n```\\nclass Solution:\\n    def getDirections(self, root: Optional[TreeNode], startValue: int, destValue: int) -> str:\\n        \\n        #soltion 2 LCA\\n        def getLCA(root,p,q):\\n            if not root: return None\\n            if root.val==p or root.val==q:\\n                return root\\n            L=getLCA(root.left,p,q)\\n            R=getLCA(root.right,p,q)\\n            if L and R:\\n                return root\\n            return L or R\\n    \\n            \\n        \\n        LCA=getLCA(root,startValue,destValue)\\n        ps,pd=\"\",\"\"\\n        stack = [(LCA, \"\")]\\n        while stack: \\n            node, path = stack.pop()\\n            if node.val == startValue: ps = path \\n            if node.val == destValue: pd = path\\n            if node.left: stack.append((node.left, path + \"L\"))\\n            if node.right: stack.append((node.right, path + \"R\"))\\n                \\n        return \"U\"*len(ps) + pd\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1618402,
                "title": "c-lca-dfs-easy-code-with-explanation",
                "content": "### LCA + DFS | Backtracking\\n*  As we konw that the **Shortest path** between source and destination is from their **LCA node** , we need to find the LCA node for the two given nodes.\\n\\n* Then we need to travel to the Source and Destination from the LCA node and store their path. This can be done using a slight variation of  **DFS** with **Backtracking**.\\n\\n* Another catcch is that the path from Source node to the LCA Node must be changed to **\"U\"** as we always move upwards from the Source to LCA node.\\n\\n* And then we return the **concatenated** path from LCA to source and LCA to Destination.\\nThus the problem can be solved using the basic concpets of\\n\\n**1. LCA \\n2. DFS** \\n\\n***CODE :***\\n\\n```\\nclass Solution {\\npublic:\\n    TreeNode* findlca(TreeNode* root, int source , int destination)\\n    {\\n        if(!root)\\n            return NULL;\\n        \\n        if(root->val == source || root->val == destination)\\n            return root;\\n        \\n        auto left =  findlca(root->left,source,destination);\\n        auto right = findlca(root->right,source,destination);\\n        \\n        if(left && right) //if both nodes are found return LCA\\n            return root;\\n        \\n        if(!left && !right )\\n            return NULL;\\n        \\n        return left ? left : right;\\n    }\\n    bool dfs(TreeNode*root , int target , string &path)\\n    {\\n        if(!root )\\n            return false;\\n        //if target is reached return \\n        if(root->val == target)\\n            return true;\\n        \\n        path += \"L\"; // move to left\\n        if(dfs(root->left, target , path))\\n            return true; // if path is found no need to traverse anymore\\n        path.pop_back(); // else backtrack\\n        \\n\\t\\t//similarly for right nodes\\n        path+=\"R\"; \\n        if(dfs(root->right ,target , path))\\n            return true;\\n        path.pop_back();\\n        \\n        return false;\\n    }\\n    string getDirections(TreeNode* root, int source, int destination) {\\n        \\n        auto lca = findlca( root , source ,destination); //find the LCA\\n        //variable to store path\\n        string path1 = \"\", path2 = \"\"; \\n        // search for source node\\n        dfs( lca, source , path1); \\n        for(auto &i: path1)\\n            i = \\'U\\';\\n        // search for destination node\\n        dfs(lca, destination, path2); \\n        return path1+path2;\\n    }\\n};\\n```\\nUpvote if you like it :)",
                "solutionTags": [
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    TreeNode* findlca(TreeNode* root, int source , int destination)\\n    {\\n        if(!root)\\n            return NULL;\\n        \\n        if(root->val == source || root->val == destination)\\n            return root;\\n        \\n        auto left =  findlca(root->left,source,destination);\\n        auto right = findlca(root->right,source,destination);\\n        \\n        if(left && right) //if both nodes are found return LCA\\n            return root;\\n        \\n        if(!left && !right )\\n            return NULL;\\n        \\n        return left ? left : right;\\n    }\\n    bool dfs(TreeNode*root , int target , string &path)\\n    {\\n        if(!root )\\n            return false;\\n        //if target is reached return \\n        if(root->val == target)\\n            return true;\\n        \\n        path += \"L\"; // move to left\\n        if(dfs(root->left, target , path))\\n            return true; // if path is found no need to traverse anymore\\n        path.pop_back(); // else backtrack\\n        \\n\\t\\t//similarly for right nodes\\n        path+=\"R\"; \\n        if(dfs(root->right ,target , path))\\n            return true;\\n        path.pop_back();\\n        \\n        return false;\\n    }\\n    string getDirections(TreeNode* root, int source, int destination) {\\n        \\n        auto lca = findlca( root , source ,destination); //find the LCA\\n        //variable to store path\\n        string path1 = \"\", path2 = \"\"; \\n        // search for source node\\n        dfs( lca, source , path1); \\n        for(auto &i: path1)\\n            i = \\'U\\';\\n        // search for destination node\\n        dfs(lca, destination, path2); \\n        return path1+path2;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1612613,
                "title": "java-solution-find-lca",
                "content": "```\\nclass Solution {\\n    public String getDirections(TreeNode root, int s, int d) {\\n        TreeNode CA = findLCA(root, s, d);\\n        \\n        StringBuilder ans = new StringBuilder();\\n        ArrayDeque<String> q1 = new ArrayDeque<>();\\n        helper(CA, s, q1);\\n        ArrayDeque<String> q2 = new ArrayDeque<>();\\n        helper(CA, d, q2);\\n        \\n        for(int i = 0; i < q1.size(); i++) ans.append(\"U\");\\n        while(!q2.isEmpty()) ans.append(q2.poll());\\n        \\n        return ans.toString();\\n    }\\n    \\n    public boolean helper(TreeNode n, int v, ArrayDeque<String> q) {\\n        if(n == null) return false;\\n        if(n.val == v) return true;\\n        \\n        q.offer(\"L\");\\n        boolean left = helper(n.left, v, q);\\n        if(left) return true;\\n        q.removeLast();\\n        \\n        q.offer(\"R\");\\n        boolean right = helper(n.right, v, q);\\n        if(right) return true;\\n        q.removeLast();\\n        \\n        return false;\\n    }\\n    \\n    public TreeNode findLCA(TreeNode node, int s, int d) {\\n        if(node == null) return null;\\n        \\n        if(node.val == s || node.val == d) return node;\\n        \\n        TreeNode left = findLCA(node.left, s, d);\\n        TreeNode right = findLCA(node.right, s, d);\\n        if(left != null && right != null) return node;\\n        if(left == null && right != null) return right;\\n        else return left;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public String getDirections(TreeNode root, int s, int d) {\\n        TreeNode CA = findLCA(root, s, d);\\n        \\n        StringBuilder ans = new StringBuilder();\\n        ArrayDeque<String> q1 = new ArrayDeque<>();\\n        helper(CA, s, q1);\\n        ArrayDeque<String> q2 = new ArrayDeque<>();\\n        helper(CA, d, q2);\\n        \\n        for(int i = 0; i < q1.size(); i++) ans.append(\"U\");\\n        while(!q2.isEmpty()) ans.append(q2.poll());\\n        \\n        return ans.toString();\\n    }\\n    \\n    public boolean helper(TreeNode n, int v, ArrayDeque<String> q) {\\n        if(n == null) return false;\\n        if(n.val == v) return true;\\n        \\n        q.offer(\"L\");\\n        boolean left = helper(n.left, v, q);\\n        if(left) return true;\\n        q.removeLast();\\n        \\n        q.offer(\"R\");\\n        boolean right = helper(n.right, v, q);\\n        if(right) return true;\\n        q.removeLast();\\n        \\n        return false;\\n    }\\n    \\n    public TreeNode findLCA(TreeNode node, int s, int d) {\\n        if(node == null) return null;\\n        \\n        if(node.val == s || node.val == d) return node;\\n        \\n        TreeNode left = findLCA(node.left, s, d);\\n        TreeNode right = findLCA(node.right, s, d);\\n        if(left != null && right != null) return node;\\n        if(left == null && right != null) return right;\\n        else return left;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1612108,
                "title": "python-solution-easy-to-understand",
                "content": "we record the path from root to start (path1) and dest node(path2). Drawing some examples, we can find that when two paths have same parent path which part we can just ignore, then we turn the left path1 to \\'U\\' and concate the left path2 path.\\n\\n```python\\nclass Solution:\\n    def getDirections(self, root: Optional[TreeNode], startValue: int, destValue: int) -> str:\\n        \"\"\"\\n        The number of nodes in the tree is n.\\n        2 <= n <= 10^5\\n        1 <= Node.val <= n\\n        All the values in the tree are unique.\\n        1 <= startValue, destValue <= n\\n        startValue != destValue\\n        :param root:\\n        :param startValue:\\n        :param destValue:\\n        :return:\\n        \"\"\"\\n        if root is None:\\n            return \"\"\\n\\n        dq = collections.deque()\\n        dq.append((root, \"\"))\\n        start_found = False\\n        dest_found = False\\n        start_path = \"\"\\n        dest_path = \"\"\\n        while len(dq) > 0 and not (start_found and dest_found):\\n            node, path = dq.popleft()\\n            if node.val == startValue:\\n                start_found = True\\n                start_path = path\\n            elif node.val == destValue:\\n                dest_found = True\\n                dest_path = path\\n            if node.left is not None:\\n                dq.append((node.left, path + \"L\"))\\n            if node.right is not None:\\n                dq.append((node.right, path + \"R\"))\\n        i = 0\\n        while len(start_path) > i and len(dest_path) > i and start_path[i] == dest_path[i]:\\n            i += 1\\n        return (len(start_path) - i) * \\'U\\' + dest_path[i:]\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```python\\nclass Solution:\\n    def getDirections(self, root: Optional[TreeNode], startValue: int, destValue: int) -> str:\\n        \"\"\"\\n        The number of nodes in the tree is n.\\n        2 <= n <= 10^5\\n        1 <= Node.val <= n\\n        All the values in the tree are unique.\\n        1 <= startValue, destValue <= n\\n        startValue != destValue\\n        :param root:\\n        :param startValue:\\n        :param destValue:\\n        :return:\\n        \"\"\"\\n        if root is None:\\n            return \"\"\\n\\n        dq = collections.deque()\\n        dq.append((root, \"\"))\\n        start_found = False\\n        dest_found = False\\n        start_path = \"\"\\n        dest_path = \"\"\\n        while len(dq) > 0 and not (start_found and dest_found):\\n            node, path = dq.popleft()\\n            if node.val == startValue:\\n                start_found = True\\n                start_path = path\\n            elif node.val == destValue:\\n                dest_found = True\\n                dest_path = path\\n            if node.left is not None:\\n                dq.append((node.left, path + \"L\"))\\n            if node.right is not None:\\n                dq.append((node.right, path + \"R\"))\\n        i = 0\\n        while len(start_path) > i and len(dest_path) > i and start_path[i] == dest_path[i]:\\n            i += 1\\n        return (len(start_path) - i) * \\'U\\' + dest_path[i:]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2024215,
                "title": "javascript-easy-to-read-dfs-find-lca-find-depth-find-path",
                "content": "Great question, once you understand that you have to find the LCA of target and destination, everything else makes more sense. I left plenty of comments, I think this solution is more readable than most here. I find it very straight forward, enjoy!\\n\\n```\\nvar getDirections = function(root, startValue, destValue) {\\n  const lca = findLCA(root, startValue, destValue) \\n  const depth = findDepth(lca, startValue) \\n  const path = findPath(lca, destValue)\\n  return \\'U\\'.repeat(depth).concat(path) // we reapeat the depth, and concat the path\\n};\\n\\n// Find Least Common Ancestor\\nfunction findLCA(root, s, d){\\n  if(!root) return null\\n  if(root.val === s || root.val === d) return root\\n  const left = findLCA(root.left, s, d)\\n  const right = findLCA(root.right, s, d)\\n  if(left && right)\\n    return root\\n  return left || right\\n} \\n\\n// Find depth to target, i.e UU...\\nfunction findDepth(root, val, count=0){\\n  if(!root) return 0  \\n  if(root.val === val) return count\\n  return findDepth(root.left, val, count+1) ||\\n         findDepth(root.right, val, count+1)\\n}\\n\\n// Find path to target, i.e LR...\\nfunction findPath(root, val, str=\\'\\'){\\n  if(!root) return \\'\\'\\n  if(root.val === val) return str\\n  return findPath(root.left, val, str+\\'L\\') ||\\n         findPath(root.right, val, str+\\'R\\')\\n}\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Depth-First Search"
                ],
                "code": "```\\nvar getDirections = function(root, startValue, destValue) {\\n  const lca = findLCA(root, startValue, destValue) \\n  const depth = findDepth(lca, startValue) \\n  const path = findPath(lca, destValue)\\n  return \\'U\\'.repeat(depth).concat(path) // we reapeat the depth, and concat the path\\n};\\n\\n// Find Least Common Ancestor\\nfunction findLCA(root, s, d){\\n  if(!root) return null\\n  if(root.val === s || root.val === d) return root\\n  const left = findLCA(root.left, s, d)\\n  const right = findLCA(root.right, s, d)\\n  if(left && right)\\n    return root\\n  return left || right\\n} \\n\\n// Find depth to target, i.e UU...\\nfunction findDepth(root, val, count=0){\\n  if(!root) return 0  \\n  if(root.val === val) return count\\n  return findDepth(root.left, val, count+1) ||\\n         findDepth(root.right, val, count+1)\\n}\\n\\n// Find path to target, i.e LR...\\nfunction findPath(root, val, str=\\'\\'){\\n  if(!root) return \\'\\'\\n  if(root.val === val) return str\\n  return findPath(root.left, val, str+\\'L\\') ||\\n         findPath(root.right, val, str+\\'R\\')\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2175069,
                "title": "easy-iterative-solution-memory-97-79-runtime-30",
                "content": "# Intuitive approach\\nFind start and dest using bfs and store their paths\\nnow using **largest common prefix** in the paths, we can find our LCA,\\nso the path from **LCA to Source** would be replaced with U and the rest from **LCA to destination** would be appended with the path and returned.\\n\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def getDirections(self, root: Optional[TreeNode], startValue: int, destValue: int) -> str:\\n    \\n        self.path1=\"\"\\n        self.path2=\"\"\\n         \\n        def traverse(node):\\n            q = deque([[node,\"\"]])\\n            while q:\\n                for i in range (len(q)):\\n                    n,path = q.popleft()\\n                    if n.val == startValue:\\n                        self.path1 = path\\n                    if n.val == destValue:\\n                        self.path2 = path\\n                    if self.path1 and self.path2:\\n                        return\\n                    if n.left:\\n                        q.append([n.left,path+\"L\"])\\n                    if n.right:\\n                        q.append([n.right,path+\"R\"])\\n        \\n        traverse(root)\\n        \\n        def LCP(s1,s2):\\n            for i in range(min(len(s1),len(s2))):\\n                \\n                if s1[i]!=s2[i]:\\n                    return i\\n            return min(len(s1),len(s2))\\n        if len(self.path1)==0:\\n            return self.path2\\n        \\n        \\n        ind = LCP(self.path1,self.path2)\\n        \\n        return \"U\"*(len(self.path1)-ind)+self.path2[ind:]\\n\\n        \\n```",
                "solutionTags": [
                    "Breadth-First Search",
                    "Queue"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def getDirections(self, root: Optional[TreeNode], startValue: int, destValue: int) -> str:\\n    \\n        self.path1=\"\"\\n        self.path2=\"\"\\n         \\n        def traverse(node):\\n            q = deque([[node,\"\"]])\\n            while q:\\n                for i in range (len(q)):\\n                    n,path = q.popleft()\\n                    if n.val == startValue:\\n                        self.path1 = path\\n                    if n.val == destValue:\\n                        self.path2 = path\\n                    if self.path1 and self.path2:\\n                        return\\n                    if n.left:\\n                        q.append([n.left,path+\"L\"])\\n                    if n.right:\\n                        q.append([n.right,path+\"R\"])\\n        \\n        traverse(root)\\n        \\n        def LCP(s1,s2):\\n            for i in range(min(len(s1),len(s2))):\\n                \\n                if s1[i]!=s2[i]:\\n                    return i\\n            return min(len(s1),len(s2))\\n        if len(self.path1)==0:\\n            return self.path2\\n        \\n        \\n        ind = LCP(self.path1,self.path2)\\n        \\n        return \"U\"*(len(self.path1)-ind)+self.path2[ind:]\\n\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1922867,
                "title": "simple-java-lca-and-dfs-pathfinding",
                "content": "```\\nclass Solution { \\n\\n    List<String> paths;    \\n    public String getDirections(TreeNode root, int startValue, int destValue) {\\n        if(root == null)\\n            return \"\";\\n        paths = new ArrayList();\\n        TreeNode lca = lca(root, startValue, destValue);\\n        find(lca, startValue, new StringBuilder());\\n        find(lca, destValue, new StringBuilder());\\n        StringBuilder result = new StringBuilder();\\n        \\n        for(int i = 0 ; i < paths.get(0).length(); i++)\\n            result.append(\"U\");\\n        result.append(paths.get(1));\\n        return result.toString();\\n    }\\n    \\n    public TreeNode lca(TreeNode node, int startValue, int destValue){\\n        \\n        if(node == null)\\n            return null;\\n        \\n        if(node.val == startValue || node.val == destValue)\\n            return node;\\n        \\n        TreeNode left = lca(node.left, startValue, destValue);\\n        TreeNode right = lca(node.right, startValue, destValue);\\n        \\n        if(left != null && right != null)\\n            return node;\\n        \\n        return left != null ? left : right;\\n    }\\n    \\n    public void find(TreeNode node, int val, StringBuilder path){\\n        if(node == null)\\n            return;\\n        \\n        if(node.val == val){\\n            paths.add(path.toString());\\n            return;\\n        }\\n        \\n        if(node.left != null)\\n            find(node.left, val, path.append(\"L\"));\\n        if(node.right != null)\\n            find(node.right, val, path.append(\"R\"));\\n        \\n        path.deleteCharAt(path.length()-1);\\n        return;\\n    }\\n    \\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution { \\n\\n    List<String> paths;    \\n    public String getDirections(TreeNode root, int startValue, int destValue) {\\n        if(root == null)\\n            return \"\";\\n        paths = new ArrayList();\\n        TreeNode lca = lca(root, startValue, destValue);\\n        find(lca, startValue, new StringBuilder());\\n        find(lca, destValue, new StringBuilder());\\n        StringBuilder result = new StringBuilder();\\n        \\n        for(int i = 0 ; i < paths.get(0).length(); i++)\\n            result.append(\"U\");\\n        result.append(paths.get(1));\\n        return result.toString();\\n    }\\n    \\n    public TreeNode lca(TreeNode node, int startValue, int destValue){\\n        \\n        if(node == null)\\n            return null;\\n        \\n        if(node.val == startValue || node.val == destValue)\\n            return node;\\n        \\n        TreeNode left = lca(node.left, startValue, destValue);\\n        TreeNode right = lca(node.right, startValue, destValue);\\n        \\n        if(left != null && right != null)\\n            return node;\\n        \\n        return left != null ? left : right;\\n    }\\n    \\n    public void find(TreeNode node, int val, StringBuilder path){\\n        if(node == null)\\n            return;\\n        \\n        if(node.val == val){\\n            paths.add(path.toString());\\n            return;\\n        }\\n        \\n        if(node.left != null)\\n            find(node.left, val, path.append(\"L\"));\\n        if(node.right != null)\\n            find(node.right, val, path.append(\"R\"));\\n        \\n        path.deleteCharAt(path.length()-1);\\n        return;\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2523385,
                "title": "c-lca-fully-commented",
                "content": "```\\n    \\n    //step 1 : find lca\\n    TreeNode*lca(TreeNode*root,int s,int d)\\n    {\\n        if(!root)\\n            return NULL;\\n        if(root->val==s||root->val==d)\\n            return root;\\n        TreeNode*l=lca(root->left,s,d);\\n        TreeNode*r=lca(root->right,s,d);\\n        if(l&&r)\\n            return root;\\n        return l?l:r;\\n    }\\n    \\n    //step 2 : path from lca to s and lca to d\\n    bool path(TreeNode*root,int s,string &p)\\n    {\\n        if(!root)\\n            return false;\\n        //if we find the node then return true\\n        if(root->val==s)\\n            return true;\\n        // check id the node exist in left subtree\\n        p.push_back(\\'L\\');\\n        if(path(root->left,s,p))\\n            return true;\\n        //if not then remove l\\n        p.pop_back();\\n        \\n        //check in right subtree\\n        p.push_back(\\'R\\');\\n        if(path(root->right,s,p))\\n            return true;\\n        //if not found then remove r\\n        p.pop_back();\\n        //if not found in root,left subtree and right subtree then return false\\n        return false;\\n    }\\n    \\n    \\n    string getDirections(TreeNode* root, int s, int d) {\\n        TreeNode*l=lca(root,s,d); //get lca\\n        string ls=\"\",ld=\"\";\\n        path(l,s,ls);   //find path from lca to s\\n        path(l,d,ld);   //path from lca to d\\n        \\n        //lca to s has to be always an upward move as per the ques .. hence replace l and r with u (bcoz we want path from s to lca)\\n        for(auto &x:ls)\\n            x=\\'U\\';\\n        //return the paths sum\\n        return ls+ld;\\n    }",
                "solutionTags": [
                    "C++",
                    "C",
                    "Backtracking",
                    "Depth-First Search"
                ],
                "code": "```\\n    \\n    //step 1 : find lca\\n    TreeNode*lca(TreeNode*root,int s,int d)\\n    {\\n        if(!root)\\n            return NULL;\\n        if(root->val==s||root->val==d)\\n            return root;\\n        TreeNode*l=lca(root->left,s,d);\\n        TreeNode*r=lca(root->right,s,d);\\n        if(l&&r)\\n            return root;\\n        return l?l:r;\\n    }\\n    \\n    //step 2 : path from lca to s and lca to d\\n    bool path(TreeNode*root,int s,string &p)\\n    {\\n        if(!root)\\n            return false;\\n        //if we find the node then return true\\n        if(root->val==s)\\n            return true;\\n        // check id the node exist in left subtree\\n        p.push_back(\\'L\\');\\n        if(path(root->left,s,p))\\n            return true;\\n        //if not then remove l\\n        p.pop_back();\\n        \\n        //check in right subtree\\n        p.push_back(\\'R\\');\\n        if(path(root->right,s,p))\\n            return true;\\n        //if not found then remove r\\n        p.pop_back();\\n        //if not found in root,left subtree and right subtree then return false\\n        return false;\\n    }\\n    \\n    \\n    string getDirections(TreeNode* root, int s, int d) {\\n        TreeNode*l=lca(root,s,d); //get lca\\n        string ls=\"\",ld=\"\";\\n        path(l,s,ls);   //find path from lca to s\\n        path(l,d,ld);   //path from lca to d\\n        \\n        //lca to s has to be always an upward move as per the ques .. hence replace l and r with u (bcoz we want path from s to lca)\\n        for(auto &x:ls)\\n            x=\\'U\\';\\n        //return the paths sum\\n        return ls+ld;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2395329,
                "title": "python-solution-with-explanation",
                "content": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def getDirections(self, root: Optional[TreeNode], startValue: int, destValue: int) -> str:\\n        \\n        def dfs(node, path, val) :\\n            if node.val == val :\\n                return True\\n            if node.left and dfs(node.left, path, val) :\\n                path.append(\\'L\\')\\n            elif node.right and dfs(node.right, path, val) :\\n                path.append(\\'R\\')\\n            return len(path) > 0 # failed to find a path\\n        \\n        start, dest = [], []\\n        dfs(root, start, startValue) # create a start node path\\n        dfs(root, dest, destValue) # create a dest node path\\n        \\n        while start and dest and start[-1] == dest[-1] :\\n            start.pop()\\n            dest.pop()\\n        \\n        return \\'U\\'*len(start) + \\'\\'.join(reversed(dest))\\n        \\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def getDirections(self, root: Optional[TreeNode], startValue: int, destValue: int) -> str:\\n        \\n        def dfs(node, path, val) :\\n            if node.val == val :\\n                return True\\n            if node.left and dfs(node.left, path, val) :\\n                path.append(\\'L\\')\\n            elif node.right and dfs(node.right, path, val) :\\n                path.append(\\'R\\')\\n            return len(path) > 0 # failed to find a path\\n        \\n        start, dest = [], []\\n        dfs(root, start, startValue) # create a start node path\\n        dfs(root, dest, destValue) # create a dest node path\\n        \\n        while start and dest and start[-1] == dest[-1] :\\n            start.pop()\\n            dest.pop()\\n        \\n        return \\'U\\'*len(start) + \\'\\'.join(reversed(dest))\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1794188,
                "title": "one-pass-with-picture-explanation-no-need-to-find-lca",
                "content": "Use bits to denote the findings of dfs\\n```\\n1. Found none  -> 00\\n2. Found start -> 01\\n3. Found dest  -> 10\\n4. Found both  -> 11\\n```\\nReturn value from dfs is the finding from its left/right subtree and its current node.\\n\\n<img src=\"https://assets.leetcode.com/users/images/eed71e04-6ff8-4bc9-80e7-91410368f290_1645626665.9065495.png\" width=\"512\" />\\n\\nAt each node, check the findings of ` lf = dfs(root->left)` and `rt = dfs(root->right)`:\\n\\n```\\n1. One of lf/rt found both                          -> root is a common ancestor (not lowest)\\n2. lf found start and rt found dest (or vice versa) -> root is the lowest common ancestor\\n3. lf/rt found start/dest and the other found none  -> root is on the path from lca to start/dest\\n```\\n\\nThen we can push the corresponding instruction:\\n```\\n1. root is an common ancestor (not lowest) -> do nothing\\n2. root is lowest common ancestor          -> start path += \\'U\\' and dest path += \\'L\\'/\\'R\\' (depends on which side found dest)\\n3. root is on path from lca to start/dest  -> start path += \\'U\\' or  dest path += \\'L\\'/\\'R\\' (depends on which side found dest)\\n```\\n\\nIn solution I used an enum to be more clear.\\n```\\nclass Solution {\\npublic:\\n    enum Found : int {None = 0, Start = 1, Dest = 2, Both = 3};\\n    \\n    string getDirections(TreeNode* root, int startValue, int destValue) {\\n        std::string startPath;\\n        std::string destPath;\\n        \\n        dfs(root, startValue, destValue, startPath, destPath);\\n        \\n        // dest path obtain by dfs is from dest node -> lca\\n        reverse(std::begin(destPath), std::end(destPath));\\n        \\n        return startPath + destPath;\\n    }\\n    \\n    Found dfs(TreeNode* root, int startValue, int destValue, string& startPath, string& destPath) {\\n        if (!root) {\\n            return Found::None;\\n        }\\n        \\n        Found curr = Found::None;\\n        \\n        if (root->val == startValue) {\\n            curr = Found::Start;\\n        } else if (root->val == destValue) {\\n            curr = Found::Dest;\\n        }\\n        \\n        Found lf = dfs(root->left, startValue, destValue, startPath, destPath);\\n        Found rt = dfs(root->right, startValue, destValue, startPath, destPath);\\n        \\n        if (lf == Found::Start || rt == Found::Start) {\\n            startPath.push_back(\\'U\\');\\n        }\\n        \\n        if (lf == Found::Dest) {\\n            destPath.push_back(\\'L\\');\\n        } else if (rt == Found::Dest) {\\n            destPath.push_back(\\'R\\');\\n        }\\n        \\n        Found finding = Found(curr | lf | rt);\\n        \\n        return finding;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Bitmask"
                ],
                "code": "```\\n1. Found none  -> 00\\n2. Found start -> 01\\n3. Found dest  -> 10\\n4. Found both  -> 11\\n```\n```\\n1. One of lf/rt found both                          -> root is a common ancestor (not lowest)\\n2. lf found start and rt found dest (or vice versa) -> root is the lowest common ancestor\\n3. lf/rt found start/dest and the other found none  -> root is on the path from lca to start/dest\\n```\n```\\n1. root is an common ancestor (not lowest) -> do nothing\\n2. root is lowest common ancestor          -> start path += \\'U\\' and dest path += \\'L\\'/\\'R\\' (depends on which side found dest)\\n3. root is on path from lca to start/dest  -> start path += \\'U\\' or  dest path += \\'L\\'/\\'R\\' (depends on which side found dest)\\n```\n```\\nclass Solution {\\npublic:\\n    enum Found : int {None = 0, Start = 1, Dest = 2, Both = 3};\\n    \\n    string getDirections(TreeNode* root, int startValue, int destValue) {\\n        std::string startPath;\\n        std::string destPath;\\n        \\n        dfs(root, startValue, destValue, startPath, destPath);\\n        \\n        // dest path obtain by dfs is from dest node -> lca\\n        reverse(std::begin(destPath), std::end(destPath));\\n        \\n        return startPath + destPath;\\n    }\\n    \\n    Found dfs(TreeNode* root, int startValue, int destValue, string& startPath, string& destPath) {\\n        if (!root) {\\n            return Found::None;\\n        }\\n        \\n        Found curr = Found::None;\\n        \\n        if (root->val == startValue) {\\n            curr = Found::Start;\\n        } else if (root->val == destValue) {\\n            curr = Found::Dest;\\n        }\\n        \\n        Found lf = dfs(root->left, startValue, destValue, startPath, destPath);\\n        Found rt = dfs(root->right, startValue, destValue, startPath, destPath);\\n        \\n        if (lf == Found::Start || rt == Found::Start) {\\n            startPath.push_back(\\'U\\');\\n        }\\n        \\n        if (lf == Found::Dest) {\\n            destPath.push_back(\\'L\\');\\n        } else if (rt == Found::Dest) {\\n            destPath.push_back(\\'R\\');\\n        }\\n        \\n        Found finding = Found(curr | lf | rt);\\n        \\n        return finding;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1612109,
                "title": "sort-of-finding-lca",
                "content": "1. Find the paths from root to start node and dest nodes respectively,  the paths should be represented using \\'L\\' and \\'R\\'.\\n2. Remove common prefix of both paths, this is identical to that we only need to go up to LCA node before going down to the dest node.\\n3. Replace each letter in the path to start node with \\'U\\', then concat that with the path to dest node.\\n```\\nclass Solution {\\n    \\n    private String start, dest;\\n    private StringBuilder path = new StringBuilder();\\n\\n    public String getDirections(TreeNode root, int startValue, int destValue) {\\n        int i = 0;\\n        StringBuilder output = new StringBuilder();\\n        getDirections(startValue, destValue, root);\\n        while (i < start.length() && i < dest.length() && start.charAt(i) == dest.charAt(i)) i++;\\n        for (int j = i; j < start.length(); j++) output.append(\\'U\\');\\n        for (int j = i; j < dest.length(); j++) output.append(dest.charAt(j));\\n        return output.toString();\\n    }\\n\\n    private void getDirections(int startValue, int destValue, TreeNode root) {\\n        if (root == null) return;\\n        if (startValue == root.val) start = path.toString();\\n        else if (destValue == root.val) dest = path.toString();\\n        path.append(\\'L\\');\\n        getDirections(startValue, destValue, root.left);\\n        path.setCharAt(path.length() - 1, \\'R\\');\\n        getDirections(startValue, destValue, root.right);\\n        path.setLength(path.length() - 1);\\n    }\\n\\n}\\n```\\nPlease ignore the naming, I know they are in bad practice.",
                "solutionTags": [
                    "Java",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    \\n    private String start, dest;\\n    private StringBuilder path = new StringBuilder();\\n\\n    public String getDirections(TreeNode root, int startValue, int destValue) {\\n        int i = 0;\\n        StringBuilder output = new StringBuilder();\\n        getDirections(startValue, destValue, root);\\n        while (i < start.length() && i < dest.length() && start.charAt(i) == dest.charAt(i)) i++;\\n        for (int j = i; j < start.length(); j++) output.append(\\'U\\');\\n        for (int j = i; j < dest.length(); j++) output.append(dest.charAt(j));\\n        return output.toString();\\n    }\\n\\n    private void getDirections(int startValue, int destValue, TreeNode root) {\\n        if (root == null) return;\\n        if (startValue == root.val) start = path.toString();\\n        else if (destValue == root.val) dest = path.toString();\\n        path.append(\\'L\\');\\n        getDirections(startValue, destValue, root.left);\\n        path.setCharAt(path.length() - 1, \\'R\\');\\n        getDirections(startValue, destValue, root.right);\\n        path.setLength(path.length() - 1);\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1612371,
                "title": "c-o-n-find-lca-and-then-find-path-to-node",
                "content": "```csharp\\n\\npublic string GetDirections(TreeNode root, int startValue, int destValue)\\n{\\n\\tStringBuilder sb = new();\\n\\tvar lca = LowestCommonAncestor(root, startValue, destValue);\\n\\n\\tStringBuilder toStart = new();\\n\\ttraverse(lca, startValue, toStart);\\n\\tsb.Append(\\'U\\', toStart.Length);\\n\\n\\ttraverse(lca, destValue, sb);\\n\\treturn sb.ToString();\\n}\\n\\npublic bool traverse(TreeNode node, int val, StringBuilder sb)\\n{\\n\\tif (node == null)\\n\\t{\\n\\t\\treturn false;\\n\\t}\\n\\n\\tif (node.val == val)\\n\\t{\\n\\t\\treturn true;\\n\\t}\\n\\n\\tsb.Append(\\'L\\');\\n\\tif (traverse(node.left, val, sb))\\n\\t{\\n\\t\\treturn true;\\n\\t}\\n\\tsb.Remove(sb.Length - 1, 1);\\n\\n\\tsb.Append(\\'R\\');\\n\\tif (traverse(node.right, val, sb))\\n\\t{\\n\\t\\treturn true;\\n\\t}\\n\\tsb.Remove(sb.Length - 1, 1);\\n\\n\\treturn false;\\n}\\n\\npublic TreeNode LowestCommonAncestor(TreeNode root, int p, int q)\\n{\\n\\tif (root == null || root.val == p || root.val == q)\\n\\t{\\n\\t\\treturn root;\\n\\t}\\n\\n\\tTreeNode left = LowestCommonAncestor(root.left, p, q);\\n\\tTreeNode right = LowestCommonAncestor(root.right, p, q);\\n\\n\\tif (left != null && right != null)\\n\\t{\\n\\t\\treturn root;\\n\\t}\\n\\n\\tif (right == null)\\n\\t{\\n\\t\\treturn left;\\n\\t}\\n\\n\\treturn right;\\n}\\n```",
                "solutionTags": [],
                "code": "```csharp\\n\\npublic string GetDirections(TreeNode root, int startValue, int destValue)\\n{\\n\\tStringBuilder sb = new();\\n\\tvar lca = LowestCommonAncestor(root, startValue, destValue);\\n\\n\\tStringBuilder toStart = new();\\n\\ttraverse(lca, startValue, toStart);\\n\\tsb.Append(\\'U\\', toStart.Length);\\n\\n\\ttraverse(lca, destValue, sb);\\n\\treturn sb.ToString();\\n}\\n\\npublic bool traverse(TreeNode node, int val, StringBuilder sb)\\n{\\n\\tif (node == null)\\n\\t{\\n\\t\\treturn false;\\n\\t}\\n\\n\\tif (node.val == val)\\n\\t{\\n\\t\\treturn true;\\n\\t}\\n\\n\\tsb.Append(\\'L\\');\\n\\tif (traverse(node.left, val, sb))\\n\\t{\\n\\t\\treturn true;\\n\\t}\\n\\tsb.Remove(sb.Length - 1, 1);\\n\\n\\tsb.Append(\\'R\\');\\n\\tif (traverse(node.right, val, sb))\\n\\t{\\n\\t\\treturn true;\\n\\t}\\n\\tsb.Remove(sb.Length - 1, 1);\\n\\n\\treturn false;\\n}\\n\\npublic TreeNode LowestCommonAncestor(TreeNode root, int p, int q)\\n{\\n\\tif (root == null || root.val == p || root.val == q)\\n\\t{\\n\\t\\treturn root;\\n\\t}\\n\\n\\tTreeNode left = LowestCommonAncestor(root.left, p, q);\\n\\tTreeNode right = LowestCommonAncestor(root.right, p, q);\\n\\n\\tif (left != null && right != null)\\n\\t{\\n\\t\\treturn root;\\n\\t}\\n\\n\\tif (right == null)\\n\\t{\\n\\t\\treturn left;\\n\\t}\\n\\n\\treturn right;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2186785,
                "title": "java-o-n-runtime-70-memory-90",
                "content": "```\\nclass Solution {\\n    private boolean dfs(TreeNode root, int val, Deque<Character> dq) {\\n        if (root == null)\\n            return false;\\n        \\n        if (root.val == val)\\n            return true;\\n        \\n\\t\\t// Going left, append \\'L\\' to your deque. Remember to remove this if val was not present in left subtree\\n        dq.addLast(\\'L\\');\\n        if (dfs(root.left, val, dq))\\n            return true;\\n        else // not found, remove \\'L\\'\\n            dq.removeLast();\\n        \\n\\t\\t// Going right, append \\'R\\' to your deque. Remember to remove this if val was not present in left subtree\\n        dq.addLast(\\'R\\');\\n        if (dfs(root.right, val, dq))\\n            return true;\\n        else // not found, remove \\'R\\'\\n            dq.removeLast();\\n        \\n        return false;\\n    }\\n    \\n    public String getDirections(TreeNode root, int startValue, int destValue) {\\n        Deque<Character> startDq = new LinkedList();\\n\\t\\t// store path for startValue\\n        dfs(root, startValue, startDq);\\n        \\n        Deque<Character> destDq = new LinkedList();\\n\\t\\t// store path for destValue\\n        dfs(root, destValue, destDq);\\n        \\n\\t\\t// Since the path is from the root, we should remove the common path steps.\\n\\t\\t// Note: Common path will be until the Lowest Common Ancestor\\n        while (!startDq.isEmpty() && !destDq.isEmpty() && startDq.peekFirst() == destDq.peekFirst()) {\\n            startDq.removeFirst();\\n            destDq.removeFirst();\\n        }\\n        \\n        StringBuilder sb = new StringBuilder();\\n\\t\\t\\n\\t\\t// Only way is Up from the start node.\\n\\t\\t// Note: StartDq will be empty if it\\'s the lca itself, DestDq will have all the path information\\n        while (!startDq.isEmpty()) {\\n            sb.append(\\'U\\');\\n            startDq.removeFirst();\\n        }\\n        \\n\\t\\t// Append whatever is left in DestDq\\n        while (!destDq.isEmpty())\\n            sb.append(destDq.removeFirst());\\n        \\n        return sb.toString();\\n    }\\n}\\n```\\n\\nPlease upvote if you liked it :)",
                "solutionTags": [
                    "Depth-First Search",
                    "Queue"
                ],
                "code": "```\\nclass Solution {\\n    private boolean dfs(TreeNode root, int val, Deque<Character> dq) {\\n        if (root == null)\\n            return false;\\n        \\n        if (root.val == val)\\n            return true;\\n        \\n\\t\\t// Going left, append \\'L\\' to your deque. Remember to remove this if val was not present in left subtree\\n        dq.addLast(\\'L\\');\\n        if (dfs(root.left, val, dq))\\n            return true;\\n        else // not found, remove \\'L\\'\\n            dq.removeLast();\\n        \\n\\t\\t// Going right, append \\'R\\' to your deque. Remember to remove this if val was not present in left subtree\\n        dq.addLast(\\'R\\');\\n        if (dfs(root.right, val, dq))\\n            return true;\\n        else // not found, remove \\'R\\'\\n            dq.removeLast();\\n        \\n        return false;\\n    }\\n    \\n    public String getDirections(TreeNode root, int startValue, int destValue) {\\n        Deque<Character> startDq = new LinkedList();\\n\\t\\t// store path for startValue\\n        dfs(root, startValue, startDq);\\n        \\n        Deque<Character> destDq = new LinkedList();\\n\\t\\t// store path for destValue\\n        dfs(root, destValue, destDq);\\n        \\n\\t\\t// Since the path is from the root, we should remove the common path steps.\\n\\t\\t// Note: Common path will be until the Lowest Common Ancestor\\n        while (!startDq.isEmpty() && !destDq.isEmpty() && startDq.peekFirst() == destDq.peekFirst()) {\\n            startDq.removeFirst();\\n            destDq.removeFirst();\\n        }\\n        \\n        StringBuilder sb = new StringBuilder();\\n\\t\\t\\n\\t\\t// Only way is Up from the start node.\\n\\t\\t// Note: StartDq will be empty if it\\'s the lca itself, DestDq will have all the path information\\n        while (!startDq.isEmpty()) {\\n            sb.append(\\'U\\');\\n            startDq.removeFirst();\\n        }\\n        \\n\\t\\t// Append whatever is left in DestDq\\n        while (!destDq.isEmpty())\\n            sb.append(destDq.removeFirst());\\n        \\n        return sb.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2133459,
                "title": "python-lca-solution",
                "content": "1. find the LCA (lowest common ancestor)\\n2. get the path from the lca to start/dest\\n3. replace startPath\\'s char to \\'U\\', concat startPath and and destPath\\n\\n```\\nclass Solution:\\n    def lowestCommonAncestor(self, root, p, q):\\n        def dfs(node, p, q):\\n            if node == None or node.val == p or node.val == q:\\n                return node\\n            l = dfs(node.left, p, q)\\n            r = dfs(node.right, p, q)\\n            if l == None:\\n                return r\\n            if r == None:\\n                return l\\n            return node\\n        return dfs(root, p, q)\\n        \\n    def getDirections(self, root: Optional[TreeNode], startValue: int, destValue: int) -> str:\\n        def backtrack(node, path, val):\\n            if node.val == val:\\n                return \\'\\'.join(path)\\n            if node.left:\\n                path.append(\\'L\\')\\n                l = backtrack(node.left, path, val)\\n                path.pop()\\n                if l: return l\\n            if node.right:\\n                path.append(\\'R\\')\\n                r = backtrack(node.right, path, val)\\n                path.pop()\\n                return r\\n        \\n        lca = self.lowestCommonAncestor(root, startValue, destValue)\\n        path1 = backtrack(lca, [], startValue)\\n        path2 = backtrack(lca, [], destValue)\\n        return len(path1) * \\'U\\' + path2\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def lowestCommonAncestor(self, root, p, q):\\n        def dfs(node, p, q):\\n            if node == None or node.val == p or node.val == q:\\n                return node\\n            l = dfs(node.left, p, q)\\n            r = dfs(node.right, p, q)\\n            if l == None:\\n                return r\\n            if r == None:\\n                return l\\n            return node\\n        return dfs(root, p, q)\\n        \\n    def getDirections(self, root: Optional[TreeNode], startValue: int, destValue: int) -> str:\\n        def backtrack(node, path, val):\\n            if node.val == val:\\n                return \\'\\'.join(path)\\n            if node.left:\\n                path.append(\\'L\\')\\n                l = backtrack(node.left, path, val)\\n                path.pop()\\n                if l: return l\\n            if node.right:\\n                path.append(\\'R\\')\\n                r = backtrack(node.right, path, val)\\n                path.pop()\\n                return r\\n        \\n        lca = self.lowestCommonAncestor(root, startValue, destValue)\\n        path1 = backtrack(lca, [], startValue)\\n        path2 = backtrack(lca, [], destValue)\\n        return len(path1) * \\'U\\' + path2\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1894970,
                "title": "python-solution-for-o-n-only-one-pass-in-tree",
                "content": "#Solution: First, use DFS to get both path of startValue and destValue. For this two path, erase same path value. For startPath, cacalute length and transfer to \"U\" and keep the remain destPath\\nTime: O(N)\\nSpace: O(N)\\nN is the number of node in tree.\\n\\nclass Solution:\\n\\n\\tdef getDirections(self, root: Optional[TreeNode], startValue: int, destValue: int) -> str:\\n        pathStart, pathDest = self.getPath(startValue, destValue, root)\\n        while pathStart and pathDest and pathStart[0] == pathDest[0]:\\n            pathStart.popleft()\\n            pathDest.popleft()\\n        return len(pathStart)*\"U\" + \"\".join(pathDest)\\n        \\n    def getPath(self, startVal, destVal, root):\\n        pathStart = deque()\\n        pathDest = deque()\\n        path = deque()\\n        def dfs(node, path):\\n            nonlocal pathStart\\n            nonlocal pathDest\\n            if node.val == startVal:\\n                pathStart = path.copy()\\n            elif node.val == destVal:\\n                pathDest = path.copy()\\n            if node.left:\\n                path.append(\"L\")\\n                dfs(node.left, path)\\n                path.pop()\\n            if node.right:\\n                path.append(\"R\")\\n                dfs(node.right, path)\\n                path.pop()\\n        dfs(root, path)\\n        return pathStart, pathDest",
                "solutionTags": [
                    "Python",
                    "Depth-First Search"
                ],
                "code": "#Solution: First, use DFS to get both path of startValue and destValue. For this two path, erase same path value. For startPath, cacalute length and transfer to \"U\" and keep the remain destPath\\nTime: O(N)\\nSpace: O(N)\\nN is the number of node in tree.\\n\\nclass Solution:\\n\\n\\tdef getDirections(self, root: Optional[TreeNode], startValue: int, destValue: int) -> str:\\n        pathStart, pathDest = self.getPath(startValue, destValue, root)\\n        while pathStart and pathDest and pathStart[0] == pathDest[0]:\\n            pathStart.popleft()\\n            pathDest.popleft()\\n        return len(pathStart)*\"U\" + \"\".join(pathDest)\\n        \\n    def getPath(self, startVal, destVal, root):\\n        pathStart = deque()\\n        pathDest = deque()\\n        path = deque()\\n        def dfs(node, path):\\n            nonlocal pathStart\\n            nonlocal pathDest\\n            if node.val == startVal:\\n                pathStart = path.copy()\\n            elif node.val == destVal:\\n                pathDest = path.copy()\\n            if node.left:\\n                path.append(\"L\")\\n                dfs(node.left, path)\\n                path.pop()\\n            if node.right:\\n                path.append(\"R\")\\n                dfs(node.right, path)\\n                path.pop()\\n        dfs(root, path)\\n        return pathStart, pathDest",
                "codeTag": "Java"
            },
            {
                "id": 1719881,
                "title": "java-lca-like-solution",
                "content": "Idea is to find the path from root to desired nodes (source and target) using postOrder dfs like in LCA problem.\\n    Further, concatenate these paths accordingly.\\n    It is likely that root is not LCA, so remove the common occuring directions before concatenation\\n\\n```\\nclass Solution {\\n    public String getDirections(TreeNode root, int startValue, int destValue) {\\n        StringBuilder sourceSb = new StringBuilder();\\n        StringBuilder destSb = new StringBuilder();\\n        if(startValue == destValue)return sourceSb.toString();\\n        \\n        dfs(root, startValue, sourceSb);\\n        dfs(root, destValue, destSb);\\n        //reverse bc these SBs are in bottom to root order\\n        destSb = destSb.reverse();\\n        sourceSb= sourceSb.reverse();\\n        \\n        //these SBs have paths from target node to ROOT (which may not be LCA)\\n        //so remove common parts from start\\n        //like if its RRLR and RRRL, initial 2 Rs are extra \\n        int lcaIdx=0;\\n\\n        while(lcaIdx<sourceSb.length() && lcaIdx<destSb.length()){\\n            if(sourceSb.charAt(lcaIdx) == destSb.charAt(lcaIdx)){\\n                lcaIdx++;\\n            }else {\\n                break;\\n            }\\n        }\\n        return \"U\".repeat(sourceSb.length()-lcaIdx) + destSb.toString().substring(lcaIdx);\\n    }\\n    \\n    private boolean dfs(TreeNode node, int value, StringBuilder sb){\\n        if(node==null)return false;\\n        if(node.val == value) return true;\\n        boolean left = dfs(node.left, value, sb);\\n        boolean right = dfs(node.right, value, sb);\\n        if(left)sb.append(\"L\");\\n        else if(right)sb.append(\"R\");\\n        return left||right;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    public String getDirections(TreeNode root, int startValue, int destValue) {\\n        StringBuilder sourceSb = new StringBuilder();\\n        StringBuilder destSb = new StringBuilder();\\n        if(startValue == destValue)return sourceSb.toString();\\n        \\n        dfs(root, startValue, sourceSb);\\n        dfs(root, destValue, destSb);\\n        //reverse bc these SBs are in bottom to root order\\n        destSb = destSb.reverse();\\n        sourceSb= sourceSb.reverse();\\n        \\n        //these SBs have paths from target node to ROOT (which may not be LCA)\\n        //so remove common parts from start\\n        //like if its RRLR and RRRL, initial 2 Rs are extra \\n        int lcaIdx=0;\\n\\n        while(lcaIdx<sourceSb.length() && lcaIdx<destSb.length()){\\n            if(sourceSb.charAt(lcaIdx) == destSb.charAt(lcaIdx)){\\n                lcaIdx++;\\n            }else {\\n                break;\\n            }\\n        }\\n        return \"U\".repeat(sourceSb.length()-lcaIdx) + destSb.toString().substring(lcaIdx);\\n    }\\n    \\n    private boolean dfs(TreeNode node, int value, StringBuilder sb){\\n        if(node==null)return false;\\n        if(node.val == value) return true;\\n        boolean left = dfs(node.left, value, sb);\\n        boolean right = dfs(node.right, value, sb);\\n        if(left)sb.append(\"L\");\\n        else if(right)sb.append(\"R\");\\n        return left||right;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2604410,
                "title": "java-lca-path-discovery-code-comments",
                "content": "There are many great answers in the discussion forum, thank you folks for the incredible work. I have structured the solution in the easy to read code blocks, hopefully, it will be useful for you. \\n\\n```\\n // Time complexity: O(N), as each step require loosely O(N) time  - LCA and path discovery for both start and dest values. \\npublic String getDirections(TreeNode root, int startValue, int destValue) {\\n    // step 1: find the LCA\\n    final TreeNode node = findLCAInBinaryTree(root, startValue, destValue);\\n\\n    // step 2: find path for start value\\n    final StringBuilder startPath = new StringBuilder();\\n    findNode(node, startValue, startPath);\\n    \\n    // step 2.1: convert start path from top down to bottom up\\n    for (int i = 0; i < startPath.length(); i++) {\\n      startPath.setCharAt(i, \\'U\\');\\n    }\\n    \\n    // step 3. find path for destination value\\n    final StringBuilder destPath = new StringBuilder();\\n    findNode(node, destValue, destPath);\\n\\n    // step 4. combine paths\\n    return startPath.append(destPath).toString();\\n  }\\n\\n // General solution to find a node in a binary tree for a given key\\n // Time complexity: O(N), in the worst case, need to browse all the nodes\\n  private TreeNode findNode(TreeNode node, int targetValue, StringBuilder path) {\\n    if (node == null) return null;\\n    if (node.data == targetValue) return node;\\n\\n    // explore left subtree\\n    TreeNode foundNode = findNode(node.left, targetValue, path.append(\"L\"));\\n    if (foundNode != null) return foundNode;\\n\\n    // otherwise, revert previous path append \\n    path.setLength(path.length() - 1);\\n   \\n    // explore right subtree\\n    foundNode = findNode(node.right, targetValue, path.append(\"R\"));\\n    if (foundNode != null) return foundNode;\\n\\n    // otherwise, revert previous path append\\n    path.setLength(path.length() - 1);\\n    \\n    return null;\\n  }\\n\\n // Would recommend to explore https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/ \\n // Time complexity: O(N), in the worst case, need to browse all the nodes\\n  private TreeNode findLCAInBinaryTree(TreeNode node, int startValue, int destValue) {\\n    if (node == null || node.data == startValue || node.data == destValue) {\\n      return node;\\n    }\\n\\n    // explore left subtree for LCA\\n    TreeNode leftNode = findLCAInBinaryTree(node.left, startValue, destValue);\\n    // explore right subtree for LCA\\n    TreeNode rightNode = findLCAInBinaryTree(node.right, startValue, destValue);\\n\\n    if (leftNode == null) return rightNode;\\n    if (rightNode == null) return leftNode;\\n    \\n    // if both are not null, we found the LCA node\\n    return node;\\n  }\\n```",
                "solutionTags": [],
                "code": "```\\n // Time complexity: O(N), as each step require loosely O(N) time  - LCA and path discovery for both start and dest values. \\npublic String getDirections(TreeNode root, int startValue, int destValue) {\\n    // step 1: find the LCA\\n    final TreeNode node = findLCAInBinaryTree(root, startValue, destValue);\\n\\n    // step 2: find path for start value\\n    final StringBuilder startPath = new StringBuilder();\\n    findNode(node, startValue, startPath);\\n    \\n    // step 2.1: convert start path from top down to bottom up\\n    for (int i = 0; i < startPath.length(); i++) {\\n      startPath.setCharAt(i, \\'U\\');\\n    }\\n    \\n    // step 3. find path for destination value\\n    final StringBuilder destPath = new StringBuilder();\\n    findNode(node, destValue, destPath);\\n\\n    // step 4. combine paths\\n    return startPath.append(destPath).toString();\\n  }\\n\\n // General solution to find a node in a binary tree for a given key\\n // Time complexity: O(N), in the worst case, need to browse all the nodes\\n  private TreeNode findNode(TreeNode node, int targetValue, StringBuilder path) {\\n    if (node == null) return null;\\n    if (node.data == targetValue) return node;\\n\\n    // explore left subtree\\n    TreeNode foundNode = findNode(node.left, targetValue, path.append(\"L\"));\\n    if (foundNode != null) return foundNode;\\n\\n    // otherwise, revert previous path append \\n    path.setLength(path.length() - 1);\\n   \\n    // explore right subtree\\n    foundNode = findNode(node.right, targetValue, path.append(\"R\"));\\n    if (foundNode != null) return foundNode;\\n\\n    // otherwise, revert previous path append\\n    path.setLength(path.length() - 1);\\n    \\n    return null;\\n  }\\n\\n // Would recommend to explore https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/ \\n // Time complexity: O(N), in the worst case, need to browse all the nodes\\n  private TreeNode findLCAInBinaryTree(TreeNode node, int startValue, int destValue) {\\n    if (node == null || node.data == startValue || node.data == destValue) {\\n      return node;\\n    }\\n\\n    // explore left subtree for LCA\\n    TreeNode leftNode = findLCAInBinaryTree(node.left, startValue, destValue);\\n    // explore right subtree for LCA\\n    TreeNode rightNode = findLCAInBinaryTree(node.right, startValue, destValue);\\n\\n    if (leftNode == null) return rightNode;\\n    if (rightNode == null) return leftNode;\\n    \\n    // if both are not null, we found the LCA node\\n    return node;\\n  }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2119370,
                "title": "using-dfs-lca-technique-with-comments-c",
                "content": "Implementation\\n\\n**Using LCA Technique, DFS\\nTime Complexity : O(N)\\nSpace Complexity : O(N)**\\n\\n```\\nclass Solution {\\nprivate:\\n    TreeNode* findLCA(TreeNode* root, int startValue, int destValue){\\n        if(!root) return NULL;\\n        \\n        if(root->val == startValue || root->val == destValue){\\n            return root;\\n        }\\n        \\n        TreeNode* leftLCA = findLCA(root->left, startValue, destValue);\\n        TreeNode* rightLCA = findLCA(root->right, startValue, destValue);\\n        \\n        if(leftLCA && rightLCA){\\n            return root;\\n        }\\n        \\n        return leftLCA ? leftLCA : rightLCA;\\n    }\\n    \\n    bool findNode(TreeNode* root, int startValue, string &url){\\n        if(!root) return false;\\n        \\n        if(root->val == startValue) return true;\\n        \\n        // trying to finding the node on left side\\n        url += \\'L\\';\\n        \\n        // if found\\n        if(findNode(root->left, startValue, url)){\\n            return true;\\n        }        \\n        // if not found, so Backtrack\\n        url.pop_back();\\n        \\n        // trying to finding the node on right side\\n        url += \\'R\\';\\n        \\n        // if found\\n        if(findNode(root->right, startValue, url)){\\n            return true;\\n        }        \\n        // if not found, so Backtrack\\n        url.pop_back();\\n        \\n        // if node not found anywhere\\n        return false;\\n    }\\n    \\npublic:\\n    string getDirections(TreeNode* root, int startValue, int destValue) {\\n        \\n        // finding LCA\\n        TreeNode* lca = findLCA(root, startValue, destValue);\\n        \\n        // finding the startURL from LCA for startValue and destinationURL from LCA for destValue\\n        string startURL = \"\", destinationURL = \"\";\\n        findNode(lca, startValue, startURL);\\n        findNode(lca, destValue, destinationURL);\\n        \\n        // In the starting we are going left side, so the time when we will find the startvalue on left side, so if we will start from their then it will be look like up side, so thats why assigning U to the startURL.\\n        for(auto &ch : startURL){\\n            ch = \\'U\\';\\n        }\\n        \\n        return startURL + destinationURL;\\n    }\\n};\\n```\\nIf you find any issue in understanding the solution then comment below, will try to help you.\\nIf you found my solution useful.\\nSo **please do upvote and encourage me** to document all leetcode problems\\uD83D\\uDE03\\nHappy Coding :)",
                "solutionTags": [
                    "C",
                    "Tree",
                    "Depth-First Search",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    TreeNode* findLCA(TreeNode* root, int startValue, int destValue){\\n        if(!root) return NULL;\\n        \\n        if(root->val == startValue || root->val == destValue){\\n            return root;\\n        }\\n        \\n        TreeNode* leftLCA = findLCA(root->left, startValue, destValue);\\n        TreeNode* rightLCA = findLCA(root->right, startValue, destValue);\\n        \\n        if(leftLCA && rightLCA){\\n            return root;\\n        }\\n        \\n        return leftLCA ? leftLCA : rightLCA;\\n    }\\n    \\n    bool findNode(TreeNode* root, int startValue, string &url){\\n        if(!root) return false;\\n        \\n        if(root->val == startValue) return true;\\n        \\n        // trying to finding the node on left side\\n        url += \\'L\\';\\n        \\n        // if found\\n        if(findNode(root->left, startValue, url)){\\n            return true;\\n        }        \\n        // if not found, so Backtrack\\n        url.pop_back();\\n        \\n        // trying to finding the node on right side\\n        url += \\'R\\';\\n        \\n        // if found\\n        if(findNode(root->right, startValue, url)){\\n            return true;\\n        }        \\n        // if not found, so Backtrack\\n        url.pop_back();\\n        \\n        // if node not found anywhere\\n        return false;\\n    }\\n    \\npublic:\\n    string getDirections(TreeNode* root, int startValue, int destValue) {\\n        \\n        // finding LCA\\n        TreeNode* lca = findLCA(root, startValue, destValue);\\n        \\n        // finding the startURL from LCA for startValue and destinationURL from LCA for destValue\\n        string startURL = \"\", destinationURL = \"\";\\n        findNode(lca, startValue, startURL);\\n        findNode(lca, destValue, destinationURL);\\n        \\n        // In the starting we are going left side, so the time when we will find the startvalue on left side, so if we will start from their then it will be look like up side, so thats why assigning U to the startURL.\\n        for(auto &ch : startURL){\\n            ch = \\'U\\';\\n        }\\n        \\n        return startURL + destinationURL;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1730550,
                "title": "java-explained-easy-to-understand",
                "content": "// TC : O(N)\\n// SC : O(N) recursion\\n```\\nclass Solution {\\n    public String getDirections(TreeNode root, int startValue, int destValue) {\\n        StringBuilder s = new StringBuilder();\\n        StringBuilder d = new StringBuilder();\\n        \\n        findPath(root, startValue, s); // find reversed path of startValue\\n        findPath(root, destValue, d); // find reversed path of destValue\\n        \\n        int i = 0;\\n        int min_i = Math.min(s.length(), d.length());\\n        \\n        // to find the Least Common Ancestor(LCA) we need to cpmpare the strings from backwards\\n        while (i < min_i && s.charAt(s.length() - i - 1) == d.charAt(d.length() - i - 1)) {\\n            i++;\\n        }\\n        \\n        // for remaining of the \\'s\\' (excluding LCA) replace by \\'U\\' because of upward movement\\n        // the \\'d\\' has to be reversed in order to go donwards from LCA to destValue\\n        return \"U\".repeat(s.length() - i) + d.reverse().toString().substring(i);\\n    }\\n    \\n    // find path of startValue and destValue from the root\\n    // These paths are from down towards root, so actua;l path from root can be gettable by reversing the sb\\n    private boolean findPath(TreeNode root, int val, StringBuilder sb) {\\n        if(root.val == val) {\\n            return true;\\n        }\\n        \\n        if(root.left != null && findPath(root.left, val, sb)) {\\n            sb.append(\"L\");\\n        }\\n        \\n        else if(root.right != null && findPath(root.right, val, sb)) {\\n            sb.append(\"R\");\\n        }\\n           \\n        return sb.length() > 0;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public String getDirections(TreeNode root, int startValue, int destValue) {\\n        StringBuilder s = new StringBuilder();\\n        StringBuilder d = new StringBuilder();\\n        \\n        findPath(root, startValue, s); // find reversed path of startValue\\n        findPath(root, destValue, d); // find reversed path of destValue\\n        \\n        int i = 0;\\n        int min_i = Math.min(s.length(), d.length());\\n        \\n        // to find the Least Common Ancestor(LCA) we need to cpmpare the strings from backwards\\n        while (i < min_i && s.charAt(s.length() - i - 1) == d.charAt(d.length() - i - 1)) {\\n            i++;\\n        }\\n        \\n        // for remaining of the \\'s\\' (excluding LCA) replace by \\'U\\' because of upward movement\\n        // the \\'d\\' has to be reversed in order to go donwards from LCA to destValue\\n        return \"U\".repeat(s.length() - i) + d.reverse().toString().substring(i);\\n    }\\n    \\n    // find path of startValue and destValue from the root\\n    // These paths are from down towards root, so actua;l path from root can be gettable by reversing the sb\\n    private boolean findPath(TreeNode root, int val, StringBuilder sb) {\\n        if(root.val == val) {\\n            return true;\\n        }\\n        \\n        if(root.left != null && findPath(root.left, val, sb)) {\\n            sb.append(\"L\");\\n        }\\n        \\n        else if(root.right != null && findPath(root.right, val, sb)) {\\n            sb.append(\"R\");\\n        }\\n           \\n        return sb.length() > 0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1634819,
                "title": "javascript-10-lines-easy-to-understand-solution-93-81",
                "content": "Runtime: 308 ms, faster than 92.73% of JavaScript online submissions for Step-By-Step Directions From a Binary Tree Node to Another.\\nMemory Usage: 85.7 MB, less than 81.82% of JavaScript online submissions for Step-By-Step Directions From a Binary Tree Node to Another.\\n```\\nvar getDirections = function(root, startValue, destValue) {\\n    let a, let b, let i = 0;\\n    const go = (node, route) => {\\n        if(node.val===startValue) a = [...route];\\n        if(node.val===destValue) b = [...route];\\n        if(node.left!==null) route.push(\"L\"), go(node.left, route), route.pop();\\n        if(node.right!==null) route.push(\"R\"), go(node.right, route), route.pop();\\n    }\\n    go(root, []);\\n    while(a[i]&&b[i]&&a[i]===b[i]) i++;\\n    return \"U\".repeat(a.length-i) + b.join(\"\").slice(i);\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar getDirections = function(root, startValue, destValue) {\\n    let a, let b, let i = 0;\\n    const go = (node, route) => {\\n        if(node.val===startValue) a = [...route];\\n        if(node.val===destValue) b = [...route];\\n        if(node.left!==null) route.push(\"L\"), go(node.left, route), route.pop();\\n        if(node.right!==null) route.push(\"R\"), go(node.right, route), route.pop();\\n    }\\n    go(root, []);\\n    while(a[i]&&b[i]&&a[i]===b[i]) i++;\\n    return \"U\".repeat(a.length-i) + b.join(\"\").slice(i);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1613124,
                "title": "dfs-in-and-out-timers-c-clear-explanation",
                "content": "This Solution uses concept of **in** and **out** timers.\\uD83D\\uDE80\\uD83D\\uDE80\\n\\n**3 Steps:**\\n1) Filling the parents of node using map\\n2) DFS for filling in and out times of a node\\n3) Treversing from start to end by considering the time\\n\\n**So What we need to check to find the correct next move:**\\n* if e*ndValue* is present is left side then definately the *endValue* should be the child of it. Step: \"L\"\\n* if e*ndValue* is present is left side then definately the *endValue* should be the child of it. Step : \"R\"\\n* otherwise there is no option, obviously go to current node\\'s parent. Step : \"U\"\\n\\n**Note :** Child here means immediate child or grandchild (couldn\\'t find correct word right now\\uD83D\\uDE05) of a node.\\n\\n### How to check if any *Node2* is Child of *Node2* ?? \\n**Visualization of Parent - Child based on DFS in and out timers:**\\n![image](https://assets.leetcode.com/users/images/a864b11c-db58-4fe2-b309-a002d9d5f13c_1638715617.125205.png)\\n\\n\\n\\n**Time** : O(N)\\n**Space** : O(N)\\n\\nComment if you have any queries.\\n\\nUpvote \\u2B06\\uFE0F if you got something from this.\\n\\n**Solution:**\\n```\\nclass Solution {\\npublic:\\n    int in[100005];\\n    int out[100005];\\n    int timer;\\n    unordered_map<TreeNode*,TreeNode*> p;\\n\\n\\n    void dfs(TreeNode* root)\\n    {\\n        if(root == nullptr) return;\\n        int node = root -> val;\\n\\t\\t// Increment timer everytime to get unique time values\\n        in[node] = timer++;\\n\\n        dfs(root -> left);\\n\\n        dfs(root-> right);\\n\\n        out[node] = timer++;\\n    }\\n\\t\\n\\t//  getting the Node Where the startValue is present\\n    TreeNode* getNode(TreeNode * root,int val)\\n    {\\n        if(root == nullptr) return nullptr;\\n\\n        if(root -> val == val) return root;\\n\\n        TreeNode* l =  getNode(root -> left,val);\\n        if(l) return l;\\n        TreeNode* r = getNode(root->right,val);\\n        \\n        if(r) return r;\\n\\n        return nullptr; \\n    }\\n\\t\\n\\t// Filling parents for traversal in path function\\n    void fillparents(TreeNode * root,TreeNode* parent)\\n    {\\n        if(root == nullptr) return;\\n\\n        p[root] = parent;\\n        \\n        fillparents(root -> left,root);\\n        fillparents(root -> right,root);\\n    }\\n\\n    string ans;\\n\\n    void path(TreeNode* root,int end)\\n    {\\n        int node = root -> val;\\n\\t\\t// Reached Destination - STOP\\n        if(root -> val == end) return;\\n\\n        // left\\n\\n        if(root-> left && in[end] >= in[root-> left -> val] && out[end] <= out[root-> left -> val])\\n        {\\n            ans += \"L\";\\n            path(root->left,end);\\n        }\\n        // right\\n        else if(root-> right && in[end] >= in[root-> right -> val] && out[end] <= out[root-> right -> val])\\n        {\\n            ans += \"R\";\\n            path(root-> right,end);\\n        }\\n\\t\\t// No option go to parent\\n        else\\n        {\\n            ans += \"U\";\\n            path(p[root],end);\\n        }\\n\\n    }\\n\\n    string getDirections(TreeNode* root, int startValue, int destValue) {\\n        TreeNode* parent = nullptr;\\n\\t\\t// clear previous parents\\n        p.clear();\\n        fillparents(root,parent);\\n       \\n        ans = \"\";\\n\\t\\t\\n\\t\\t// intialize timer to 0\\n        timer = 0;\\n        \\n        dfs(root);\\n        \\n        TreeNode* dest = getNode(root,startValue);\\n\\n        if(!dest) return \"\";\\n\\n        path(dest,destValue);\\n\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "Tree",
                    "Depth-First Search",
                    "Binary Tree"
                ],
                "code": "class Solution {\\npublic:\\n    int in[100005];\\n    int out[100005];\\n    int timer;\\n    unordered_map<TreeNode*,TreeNode*> p;\\n\\n\\n    void dfs(TreeNode* root)\\n    {\\n        if(root == nullptr) return;\\n        int node = root -> val;\\n\\t\\t// Increment timer everytime to get unique time values\\n        in[node] = timer++;\\n\\n        dfs(root -> left);\\n\\n        dfs(root-> right);\\n\\n        out[node] = timer++;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 3847672,
                "title": "beat-98-with-full-line-by-line-code-explanation",
                "content": "\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n   bool path(TreeNode* root,int v,string &p){\\n       //we use boolen to push only that path we is giving answer otherwise we have to use pick and not pick\\n       if(root->val == v)  return true;\\n\\n       if(root->left && path(root->left,v,p)) p.push_back(\\'L\\');\\n\\n       else if(root->right && path(root->right,v,p)) p.push_back(\\'R\\');\\n       //if path is empty after going to left and right taht means that path has not to be included\\n       return !p.empty();\\n   }\\n    string getDirections(TreeNode* root, int startValue, int destValue) {\\n        string s,d;\\n        //we just have to find the path from root to the starting point and to the destination \\n        //we get the string path \\n        path(root,startValue,s);\\n        path(root,destValue,d);\\n        // Now if s and d string have common prefix mean that path is one which have to travel for both thus that \\n        // part is not in the answer \\n        while(!s.empty() && !d.empty() && s.back()==d.back()){\\n            s.pop_back();\\n            d.pop_back();\\n        }\\n        //now we know that if we have go left or right for the starting point then we have to go up from starting so \\n        //we make a string of same size as s with u\\n        // all the path was in reverse order thus we reverse d\\n        return string(s.size(),\\'U\\')+string(rbegin(d),rend(d));\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n   bool path(TreeNode* root,int v,string &p){\\n       //we use boolen to push only that path we is giving answer otherwise we have to use pick and not pick\\n       if(root->val == v)  return true;\\n\\n       if(root->left && path(root->left,v,p)) p.push_back(\\'L\\');\\n\\n       else if(root->right && path(root->right,v,p)) p.push_back(\\'R\\');\\n       //if path is empty after going to left and right taht means that path has not to be included\\n       return !p.empty();\\n   }\\n    string getDirections(TreeNode* root, int startValue, int destValue) {\\n        string s,d;\\n        //we just have to find the path from root to the starting point and to the destination \\n        //we get the string path \\n        path(root,startValue,s);\\n        path(root,destValue,d);\\n        // Now if s and d string have common prefix mean that path is one which have to travel for both thus that \\n        // part is not in the answer \\n        while(!s.empty() && !d.empty() && s.back()==d.back()){\\n            s.pop_back();\\n            d.pop_back();\\n        }\\n        //now we know that if we have go left or right for the starting point then we have to go up from starting so \\n        //we make a string of same size as s with u\\n        // all the path was in reverse order thus we reverse d\\n        return string(s.size(),\\'U\\')+string(rbegin(d),rend(d));\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3773177,
                "title": "backtracking-lcs-c-images-explanation",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\napproach is Simple, Just find out the path from **root--->source** and **root--->target** now, ignore the path from **root-->LCS(source, target)** now change the **root-->Source** path into **\\'U\\'** and no change in **root--->target** path.\\n\\nEX:-\\n![Screenshot 2023-07-16 160832.jpg](https://assets.leetcode.com/users/images/59d4f0c9-2d72-435a-a1ea-bd320c036221_1689503971.6242192.jpeg)\\n![image.png](https://assets.leetcode.com/users/images/90401061-1306-41dc-a9b1-66a71c5ad656_1689504525.8587072.png)\\n\\n\\n# Complexity\\n- Time complexity:(N+N+n+m)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool findpath(TreeNode* root,vector<TreeNode*> &v,int t)\\n    {\\n        if(!root) return false;\\n        v.push_back(root);\\n        if(root->val==t) return true;\\n        if(findpath(root->left,v,t) || findpath(root->right,v,t)) return true;\\n        v.pop_back();\\n        return false;\\n    }\\n    string getDirections(TreeNode* root, int s, int d) {\\n        if(!root) return \"\";\\n        vector<TreeNode*> v1,v2;\\n        string ans = \"\";\\n        findpath(root,v1,s);\\n        findpath(root,v2,d);\\n        int k =  0,n = v1.size(),m = v2.size();\\n        while(k<min(n,m) && v1[k]==v2[k]) k++;\\n        for(int i = k;i<n;i++) ans+=\"U\";\\n        for(int i = k;i<m;i++) \\n        {\\n            if(v2[i-1]->left == v2[i]) ans+=\"L\";\\n            else ans+=\"R\";\\n        }\\n        return ans;\\n    }\\n};\\n```\\n![upvote.jpg](https://assets.leetcode.com/users/images/17383c9d-b163-4a74-8003-450f1984713f_1689504647.544543.jpeg)\\n",
                "solutionTags": [
                    "C++",
                    "String",
                    "Backtracking",
                    "Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool findpath(TreeNode* root,vector<TreeNode*> &v,int t)\\n    {\\n        if(!root) return false;\\n        v.push_back(root);\\n        if(root->val==t) return true;\\n        if(findpath(root->left,v,t) || findpath(root->right,v,t)) return true;\\n        v.pop_back();\\n        return false;\\n    }\\n    string getDirections(TreeNode* root, int s, int d) {\\n        if(!root) return \"\";\\n        vector<TreeNode*> v1,v2;\\n        string ans = \"\";\\n        findpath(root,v1,s);\\n        findpath(root,v2,d);\\n        int k =  0,n = v1.size(),m = v2.size();\\n        while(k<min(n,m) && v1[k]==v2[k]) k++;\\n        for(int i = k;i<n;i++) ans+=\"U\";\\n        for(int i = k;i<m;i++) \\n        {\\n            if(v2[i-1]->left == v2[i]) ans+=\"L\";\\n            else ans+=\"R\";\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2781727,
                "title": "c-dfs-mle-accepted-approach",
                "content": "**MLE on 287th Test**\\n\\n```cpp\\nclass Solution {\\npublic:\\n    bool isStartInLeftSubTree;\\n    string str;\\n    TreeNode* getCA(TreeNode *root, int x1, int x2) {\\n        if (root == nullptr) return nullptr;\\n        if (root->val == x1 || root->val == x2) {\\n            return root;\\n        }\\n        auto l = getCA(root->left, x1, x2);\\n        auto r = getCA(root->right, x1, x2);\\n        if (l && r) return root;\\n        return l? l: r;\\n    }\\n    bool findPath(TreeNode *root, int valueToBeFound) {\\n        if (root == nullptr) return false;\\n        if (root->val == valueToBeFound) {\\n            return true;\\n        }\\n        bool l = findPath(root->left, valueToBeFound);\\n        bool r = findPath(root->right, valueToBeFound);\\n        if (l) {\\n            str = \"L\" + str;\\n        } else if (r) {\\n            str = \"R\" + str;\\n        }\\n        return (l || r);\\n    }\\n    \\n    int findStartNodeDepth(TreeNode *root, int x) {\\n        if (root == nullptr) return -1;\\n        if (root->val == x) return 0;\\n        int l = findStartNodeDepth(root->left, x);\\n        int r = findStartNodeDepth(root->right, x);\\n        if (l == -1 && r == -1) return -1;\\n        isStartInLeftSubTree = (l >= 0? true: false);\\n        return max(l, r) + 1;\\n    }\\n    \\n    string getDirections(TreeNode* root, int startValue, int destValue) {\\n        str = \"\";\\n        string x = \"\";\\n        auto getStringByLen = [&] (int A) {\\n            string p = \"\";\\n            while(A--) {\\n                p += \\'U\\';\\n            }\\n            return p;\\n        };\\n            \\n        TreeNode *ca = getCA(root, startValue, destValue);\\n        if (ca->val == destValue) {\\n            return getStringByLen(findStartNodeDepth(ca, startValue));\\n        } else if (ca->val == startValue) {\\n            findPath(ca, destValue);\\n            return str;\\n        } else {\\n            findPath(ca, destValue);\\n            return getStringByLen(findStartNodeDepth(ca, startValue)) + str;\\n        }\\n    }\\n};\\n```\\n\\n**Accepted**\\n```cpp\\nclass Solution {\\npublic:\\n    bool getPath(TreeNode *root, int x, string &str) {\\n        if (root->val == x) return true;\\n        //If node exists in left subtree, then we would get the true from left\\n        //hence we need to go to left subtree from the current root node\\n        if (root->left && getPath(root->left, x, str))  str += \\'L\\';\\n        else if (root->right && getPath(root->right, x, str))   str += \\'R\\';\\n        return str.size() > 0;\\n    }\\n    string getDirections(TreeNode* root, int startValue, int destValue) {\\n        string s, d;\\n        getPath(root, startValue, s);\\n        getPath(root, destValue, d);\\n        //since the paths are stored in reverse order\\n        //we know that for a common ancestor to exist\\n        //there will be some common path between the two string\\n        while(min(s.size(), d.size()) > 0 && s.back() == d.back()) {\\n            s.pop_back();\\n            d.pop_back();\\n        }\\n        return string(s.size(), \\'U\\') + string(rbegin(d), rend(d));\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    bool isStartInLeftSubTree;\\n    string str;\\n    TreeNode* getCA(TreeNode *root, int x1, int x2) {\\n        if (root == nullptr) return nullptr;\\n        if (root->val == x1 || root->val == x2) {\\n            return root;\\n        }\\n        auto l = getCA(root->left, x1, x2);\\n        auto r = getCA(root->right, x1, x2);\\n        if (l && r) return root;\\n        return l? l: r;\\n    }\\n    bool findPath(TreeNode *root, int valueToBeFound) {\\n        if (root == nullptr) return false;\\n        if (root->val == valueToBeFound) {\\n            return true;\\n        }\\n        bool l = findPath(root->left, valueToBeFound);\\n        bool r = findPath(root->right, valueToBeFound);\\n        if (l) {\\n            str = \"L\" + str;\\n        } else if (r) {\\n            str = \"R\" + str;\\n        }\\n        return (l || r);\\n    }\\n    \\n    int findStartNodeDepth(TreeNode *root, int x) {\\n        if (root == nullptr) return -1;\\n        if (root->val == x) return 0;\\n        int l = findStartNodeDepth(root->left, x);\\n        int r = findStartNodeDepth(root->right, x);\\n        if (l == -1 && r == -1) return -1;\\n        isStartInLeftSubTree = (l >= 0? true: false);\\n        return max(l, r) + 1;\\n    }\\n    \\n    string getDirections(TreeNode* root, int startValue, int destValue) {\\n        str = \"\";\\n        string x = \"\";\\n        auto getStringByLen = [&] (int A) {\\n            string p = \"\";\\n            while(A--) {\\n                p += \\'U\\';\\n            }\\n            return p;\\n        };\\n            \\n        TreeNode *ca = getCA(root, startValue, destValue);\\n        if (ca->val == destValue) {\\n            return getStringByLen(findStartNodeDepth(ca, startValue));\\n        } else if (ca->val == startValue) {\\n            findPath(ca, destValue);\\n            return str;\\n        } else {\\n            findPath(ca, destValue);\\n            return getStringByLen(findStartNodeDepth(ca, startValue)) + str;\\n        }\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    bool getPath(TreeNode *root, int x, string &str) {\\n        if (root->val == x) return true;\\n        //If node exists in left subtree, then we would get the true from left\\n        //hence we need to go to left subtree from the current root node\\n        if (root->left && getPath(root->left, x, str))  str += \\'L\\';\\n        else if (root->right && getPath(root->right, x, str))   str += \\'R\\';\\n        return str.size() > 0;\\n    }\\n    string getDirections(TreeNode* root, int startValue, int destValue) {\\n        string s, d;\\n        getPath(root, startValue, s);\\n        getPath(root, destValue, d);\\n        //since the paths are stored in reverse order\\n        //we know that for a common ancestor to exist\\n        //there will be some common path between the two string\\n        while(min(s.size(), d.size()) > 0 && s.back() == d.back()) {\\n            s.pop_back();\\n            d.pop_back();\\n        }\\n        return string(s.size(), \\'U\\') + string(rbegin(d), rend(d));\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2687919,
                "title": "java-solution",
                "content": "```\\n  public boolean findPath(TreeNode node, int val, Stack<String> stack) {\\n    if (node == null) {\\n      return false;\\n    }\\n\\n    if (node.val == val) {\\n      return true;\\n    }\\n\\n    stack.push(\"L\");\\n    if (findPath(node.left, val, stack)) {\\n      return true;\\n    }\\n    stack.pop();\\n\\n    stack.push(\"R\");\\n    if (findPath(node.right, val, stack)) {\\n      return true;\\n    }\\n    stack.pop();\\n\\n    return false;\\n  }\\n\\n  public String getDirections(TreeNode root, int startValue, int destValue) {\\n    Stack<String> stack = new Stack<>();\\n\\n    findPath(root, startValue, stack);\\n    String rootToStart = String.join(\"\", stack);\\n    stack.clear();\\n\\n    findPath(root, destValue, stack);\\n    String rootToDest = String.join(\"\", stack);\\n    stack.clear();\\n\\n    if (rootToStart.isBlank()) {\\n      return rootToDest;\\n    }\\n\\n    int i = 0;\\n    while (i < Math.min(rootToStart.length(), rootToDest.length())\\n            && rootToStart.charAt(i) == rootToDest.charAt(i)) {\\n      i++;\\n    }\\n\\n    return reverePath(rootToStart.substring(i)) + rootToDest.substring(i);\\n  }\\n\\n  private String reverePath(String path) {\\n    return \"U\".repeat(path.length());\\n  }\\n```",
                "solutionTags": [],
                "code": "```\\n  public boolean findPath(TreeNode node, int val, Stack<String> stack) {\\n    if (node == null) {\\n      return false;\\n    }\\n\\n    if (node.val == val) {\\n      return true;\\n    }\\n\\n    stack.push(\"L\");\\n    if (findPath(node.left, val, stack)) {\\n      return true;\\n    }\\n    stack.pop();\\n\\n    stack.push(\"R\");\\n    if (findPath(node.right, val, stack)) {\\n      return true;\\n    }\\n    stack.pop();\\n\\n    return false;\\n  }\\n\\n  public String getDirections(TreeNode root, int startValue, int destValue) {\\n    Stack<String> stack = new Stack<>();\\n\\n    findPath(root, startValue, stack);\\n    String rootToStart = String.join(\"\", stack);\\n    stack.clear();\\n\\n    findPath(root, destValue, stack);\\n    String rootToDest = String.join(\"\", stack);\\n    stack.clear();\\n\\n    if (rootToStart.isBlank()) {\\n      return rootToDest;\\n    }\\n\\n    int i = 0;\\n    while (i < Math.min(rootToStart.length(), rootToDest.length())\\n            && rootToStart.charAt(i) == rootToDest.charAt(i)) {\\n      i++;\\n    }\\n\\n    return reverePath(rootToStart.substring(i)) + rootToDest.substring(i);\\n  }\\n\\n  private String reverePath(String path) {\\n    return \"U\".repeat(path.length());\\n  }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2644669,
                "title": "java-lca-dfs-easy-to-understand",
                "content": "```\\npublic String getDirections(TreeNode root, int startValue, int destValue) {\\n        StringBuilder sb1 = new StringBuilder(), sb2 = new StringBuilder();\\n        dfs(root, startValue, sb1);\\n        dfs(root, destValue, sb2);\\n        int k = 0;\\n        while (k < sb1.length() && k < sb2.length() && sb1.charAt(k) == sb2.charAt(k)) {\\n            k++;\\n        }\\n        for (int i = k; i < sb1.length(); i++) {\\n            sb1.setCharAt(i, \\'U\\');\\n        }\\n        return sb1.substring(k) + sb2.substring(k);\\n    }\\n    \\n    private boolean dfs(TreeNode root, int target, StringBuilder dir) {\\n        if (root == null) return false;\\n        if (root.val == target) return true;\\n        if (root.left != null) {\\n            dir.append(\"L\");\\n            if (dfs(root.left, target, dir)) return true;\\n            dir.deleteCharAt(dir.length() - 1);\\n        }\\n        if (root.right != null) {\\n            dir.append(\"R\");\\n            if (dfs(root.right, target, dir)) return true;\\n            dir.deleteCharAt(dir.length() - 1);\\n        }\\n        return false;\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic String getDirections(TreeNode root, int startValue, int destValue) {\\n        StringBuilder sb1 = new StringBuilder(), sb2 = new StringBuilder();\\n        dfs(root, startValue, sb1);\\n        dfs(root, destValue, sb2);\\n        int k = 0;\\n        while (k < sb1.length() && k < sb2.length() && sb1.charAt(k) == sb2.charAt(k)) {\\n            k++;\\n        }\\n        for (int i = k; i < sb1.length(); i++) {\\n            sb1.setCharAt(i, \\'U\\');\\n        }\\n        return sb1.substring(k) + sb2.substring(k);\\n    }\\n    \\n    private boolean dfs(TreeNode root, int target, StringBuilder dir) {\\n        if (root == null) return false;\\n        if (root.val == target) return true;\\n        if (root.left != null) {\\n            dir.append(\"L\");\\n            if (dfs(root.left, target, dir)) return true;\\n            dir.deleteCharAt(dir.length() - 1);\\n        }\\n        if (root.right != null) {\\n            dir.append(\"R\");\\n            if (dfs(root.right, target, dir)) return true;\\n            dir.deleteCharAt(dir.length() - 1);\\n        }\\n        return false;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2240051,
                "title": "java-simple-solution-using-lca-beginner-friendly-tc-o-n",
                "content": "```\\n// idea :-\\n    // 1- shortest path is LCA.\\n    // 2- startValue to LCA path will always be \"U\".\\n    // 3- destValue to LCA path we will find with find().\\n\\t\\nclass Solution {\\n    public boolean ntrp(TreeNode root, int node, ArrayList<TreeNode> list){\\n        if(root == null)\\n            return false;\\n        if(root.val == node){\\n            list.add(root);\\n            return true;\\n        }\\n        \\n        boolean res = ntrp(root.left, node, list) || ntrp(root.right, node, list);\\n        \\n        if(res)\\n            list.add(root);\\n        \\n        return res;\\n    }\\n    public TreeNode lca(ArrayList<TreeNode> a1, ArrayList<TreeNode> a2){\\n        TreeNode lca = null;\\n        int i = a1.size() - 1, j = a2.size()-1;\\n        while(i >= 0 && j >= 0){\\n            if(a1.get(i).val == a2.get(j).val){\\n                lca = a1.get(i);\\n                i--;\\n                j--;\\n            }else{\\n                break;\\n            }\\n        }\\n        return lca;\\n    }\\n    public boolean find(int dest,TreeNode root, StringBuilder s){\\n        if(root == null)\\n            return false;\\n        \\n        if(root.val == dest)\\n            return true;\\n        \\n        boolean left = find(dest,root.left,s);\\n        if(left){\\n            s.append(\"L\");\\n            return left;\\n        }\\n        boolean right = find(dest, root.right, s);\\n        if(right){\\n            s.append(\"R\");\\n            return right;\\n        }\\n        return false;\\n    }    \\n    public String getDirections(TreeNode root, int startValue, int destValue) {\\n        if(root == null)\\n            return \"\";\\n        ArrayList<TreeNode> a1 = new ArrayList<>();\\n        ArrayList<TreeNode> a2 = new ArrayList<>();\\n        ntrp(root, startValue, a1);\\n        ntrp(root, destValue, a2);\\n        \\n        TreeNode lca = lca(a1, a2);\\n        StringBuilder s1 = new StringBuilder();\\n        StringBuilder s2 = new StringBuilder();\\n        \\n        for(int i = 0; i < a1.size(); i++){\\n            if(a1.get(i).val != lca.val){\\n                s1.append(\"U\");\\n            }else\\n                break;\\n        }\\n        find(destValue, lca, s2);\\n        \\n        return s1.toString() + s2.reverse().toString();\\n    }\\n}\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public boolean ntrp(TreeNode root, int node, ArrayList<TreeNode> list){\\n        if(root == null)\\n            return false;\\n        if(root.val == node){\\n            list.add(root);\\n            return true;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2000577,
                "title": "java-o-n",
                "content": "* Find LCA\\n* Find two paths\\n\\t* from LCA to source node\\n\\t* from LCA to dest node\\n* Construct direction using two paths\\n```\\nclass Solution {\\n    private TreeNode LCA(TreeNode node, int startValue, int destValue) {\\n        if (node == null) {\\n            return null;\\n        }\\n        \\n        if (node.val == startValue || node.val == destValue) {\\n            return node;\\n        }\\n        \\n        TreeNode left = LCA(node.left, startValue, destValue);\\n        TreeNode right = LCA(node.right, startValue, destValue);\\n        \\n        if (left != null && right != null) {\\n            return node;\\n        }\\n        \\n        if (left != null) {\\n            return left;\\n        }\\n        return right;\\n    }\\n    \\n    private boolean constructPath(TreeNode node, int targetVal, List<String> currPath) {\\n        if (node == null) {\\n            return false;\\n        }\\n        \\n        if (node.val == targetVal) {\\n            return true;\\n        }\\n        \\n        currPath.add(\"L\");\\n        boolean targetInLeftTree = constructPath(node.left, targetVal, currPath);\\n        if (targetInLeftTree) {\\n            return true;\\n        }\\n        currPath.remove(currPath.size() - 1);\\n        \\n        currPath.add(\"R\");\\n        boolean targetInRightTree = constructPath(node.right, targetVal, currPath);\\n        if (targetInRightTree) {\\n            return true;\\n        }\\n        currPath.remove(currPath.size() - 1);\\n        \\n        return false;\\n    }\\n    \\n    private String constructDirection(List<String> rootToStartVal, List<String> rootToDestVal) {\\n        StringBuilder direction = new StringBuilder();\\n        // go up from source node to root\\n        for (int i = 0; i < rootToStartVal.size(); i++) {\\n            direction.append(\\'U\\');\\n        }\\n        // go down from root to dest node\\n        for (int i = 0; i < rootToDestVal.size(); i++) {\\n            direction.append(rootToDestVal.get(i));\\n        }\\n        \\n        return direction.toString();\\n    }\\n    \\n    public String getDirections(TreeNode root, int startValue, int destValue) {\\n        TreeNode lca = LCA(root, startValue, destValue);\\n        List<String> rootToStartVal = new ArrayList<>();\\n        List<String> rootToDestVal = new ArrayList<>();\\n        constructPath(lca, startValue, rootToStartVal);\\n        constructPath(lca, destValue, rootToDestVal);\\n        return constructDirection(rootToStartVal, rootToDestVal);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    private TreeNode LCA(TreeNode node, int startValue, int destValue) {\\n        if (node == null) {\\n            return null;\\n        }\\n        \\n        if (node.val == startValue || node.val == destValue) {\\n            return node;\\n        }\\n        \\n        TreeNode left = LCA(node.left, startValue, destValue);\\n        TreeNode right = LCA(node.right, startValue, destValue);\\n        \\n        if (left != null && right != null) {\\n            return node;\\n        }\\n        \\n        if (left != null) {\\n            return left;\\n        }\\n        return right;\\n    }\\n    \\n    private boolean constructPath(TreeNode node, int targetVal, List<String> currPath) {\\n        if (node == null) {\\n            return false;\\n        }\\n        \\n        if (node.val == targetVal) {\\n            return true;\\n        }\\n        \\n        currPath.add(\"L\");\\n        boolean targetInLeftTree = constructPath(node.left, targetVal, currPath);\\n        if (targetInLeftTree) {\\n            return true;\\n        }\\n        currPath.remove(currPath.size() - 1);\\n        \\n        currPath.add(\"R\");\\n        boolean targetInRightTree = constructPath(node.right, targetVal, currPath);\\n        if (targetInRightTree) {\\n            return true;\\n        }\\n        currPath.remove(currPath.size() - 1);\\n        \\n        return false;\\n    }\\n    \\n    private String constructDirection(List<String> rootToStartVal, List<String> rootToDestVal) {\\n        StringBuilder direction = new StringBuilder();\\n        // go up from source node to root\\n        for (int i = 0; i < rootToStartVal.size(); i++) {\\n            direction.append(\\'U\\');\\n        }\\n        // go down from root to dest node\\n        for (int i = 0; i < rootToDestVal.size(); i++) {\\n            direction.append(rootToDestVal.get(i));\\n        }\\n        \\n        return direction.toString();\\n    }\\n    \\n    public String getDirections(TreeNode root, int startValue, int destValue) {\\n        TreeNode lca = LCA(root, startValue, destValue);\\n        List<String> rootToStartVal = new ArrayList<>();\\n        List<String> rootToDestVal = new ArrayList<>();\\n        constructPath(lca, startValue, rootToStartVal);\\n        constructPath(lca, destValue, rootToDestVal);\\n        return constructDirection(rootToStartVal, rootToDestVal);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1965601,
                "title": "java-dfs-o-n",
                "content": "**Explanation:**\\n\\n1) Find the LCA of startValue and destValue. Why LCA? Because we don\\'t need to go above LCA to travel from start to end. The route will always pass through the LCA.\\n\\n2) Generate the step by step direction from the LCA to startValue (Left) and LCA to destValue (Right). The direction from Left to LCA will only consist of \\'U\\'s as per the output format.\\n\\n3) Combine both the directions (Left+Right).\\n\\n**Time Complexity:** O(n)\\n\\n```\\nclass Solution {\\n    \\n    public String getDirections(TreeNode root, int start, int dest) {\\n        \\n        TreeNode ancestor = LCA(root,start,dest);\\n        \\n        StringBuilder left = getDirection(ancestor,start,false);\\n        StringBuilder right = getDirection(ancestor,dest,true);\\n\\t\\t\\n\\t\\treturn left.toString() + right.reverse().toString();\\n    }\\n    \\n    public TreeNode LCA(TreeNode root, int p, int q) {\\n        \\n        if(root == null || root.val == p || root.val == q) return root;\\n        \\n        TreeNode left = LCA(root.left,p,q);\\n        TreeNode right = LCA(root.right,p,q);\\n        \\n        if(left == null) return right;\\n        if(right == null) return left;\\n        \\n        return root;\\n    }\\n    \\n    public StringBuilder getDirection(TreeNode root, int dest, boolean flag) {\\n        \\n        if(root == null) return null;\\n        if(root.val == dest) return new StringBuilder();\\n        \\n        StringBuilder left = getDirection(root.left,dest,flag);\\n        \\n        if(left != null) {\\n            \\n            left.append(!flag ? \"U\" : \"L\");\\n            return left;\\n        }\\n        \\n        StringBuilder right = getDirection(root.right,dest,flag);\\n        \\n        if(right != null) {\\n            \\n            right.append(!flag ? \"U\" : \"R\");\\n            return right;\\n        }\\n        \\n        return null;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Tree",
                    "Depth-First Search",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    \\n    public String getDirections(TreeNode root, int start, int dest) {\\n        \\n        TreeNode ancestor = LCA(root,start,dest);\\n        \\n        StringBuilder left = getDirection(ancestor,start,false);\\n        StringBuilder right = getDirection(ancestor,dest,true);\\n\\t\\t\\n\\t\\treturn left.toString() + right.reverse().toString();\\n    }\\n    \\n    public TreeNode LCA(TreeNode root, int p, int q) {\\n        \\n        if(root == null || root.val == p || root.val == q) return root;\\n        \\n        TreeNode left = LCA(root.left,p,q);\\n        TreeNode right = LCA(root.right,p,q);\\n        \\n        if(left == null) return right;\\n        if(right == null) return left;\\n        \\n        return root;\\n    }\\n    \\n    public StringBuilder getDirection(TreeNode root, int dest, boolean flag) {\\n        \\n        if(root == null) return null;\\n        if(root.val == dest) return new StringBuilder();\\n        \\n        StringBuilder left = getDirection(root.left,dest,flag);\\n        \\n        if(left != null) {\\n            \\n            left.append(!flag ? \"U\" : \"L\");\\n            return left;\\n        }\\n        \\n        StringBuilder right = getDirection(root.right,dest,flag);\\n        \\n        if(right != null) {\\n            \\n            right.append(!flag ? \"U\" : \"R\");\\n            return right;\\n        }\\n        \\n        return null;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1964602,
                "title": "bfs-python-straightforward-solution",
                "content": "My idea is a bit simple and straightforward. So there is only one path possible to any node from root of a binary tree. By taking advantage of this property we can simply find path from root to source and destination. Once I have both the paths I will simply iterate over both the paths and ignore all the common part. Then I just convert path of source to U because source needs to reach root of subtree containing destination before it can reach it. Finally I am adding the remaining path to my destination node\\n```\\nclass Solution:\\n    def getDirections(self, root: Optional[TreeNode], startValue: int, destValue: int) -> str:\\n        dq = deque([[root, \"\"]])\\n        sourceDirections = \"\"\\n        destDirections = \"\"\\n        while len(dq) > 0:\\n            curr = dq.popleft()\\n            if curr[0] is None:\\n                continue\\n            if curr[0].val == startValue:\\n                sourceDirections = curr[1]\\n            if curr[0].val == destValue:\\n                destDirections = curr[1]\\n            dq.append([curr[0].left, curr[1]+\"L\"])\\n            dq.append([curr[0].right, curr[1]+\"R\"])\\n\\n        index = 0\\n        for i in range(min(len(sourceDirections), len(destDirections))):\\n            if sourceDirections[i] == destDirections[i]:\\n                index += 1\\n            else:\\n                break\\n        \\n        return (len(sourceDirections) - index) * \"U\" + destDirections[index:]\\n```",
                "solutionTags": [
                    "Python3",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def getDirections(self, root: Optional[TreeNode], startValue: int, destValue: int) -> str:\\n        dq = deque([[root, \"\"]])\\n        sourceDirections = \"\"\\n        destDirections = \"\"\\n        while len(dq) > 0:\\n            curr = dq.popleft()\\n            if curr[0] is None:\\n                continue\\n            if curr[0].val == startValue:\\n                sourceDirections = curr[1]\\n            if curr[0].val == destValue:\\n                destDirections = curr[1]\\n            dq.append([curr[0].left, curr[1]+\"L\"])\\n            dq.append([curr[0].right, curr[1]+\"R\"])\\n\\n        index = 0\\n        for i in range(min(len(sourceDirections), len(destDirections))):\\n            if sourceDirections[i] == destDirections[i]:\\n                index += 1\\n            else:\\n                break\\n        \\n        return (len(sourceDirections) - index) * \"U\" + destDirections[index:]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1935966,
                "title": "c-dfs-o-n",
                "content": "```\\nclass Solution {\\n    void dfs(TreeNode* n, int s, int d, string& str)\\n    {\\n        if (n == nullptr)\\n            return;\\n        if (n->val == s)\\n            anss = str;\\n        else if (n->val == d) \\n            ansd = str;\\n        str.push_back(\\'L\\');\\n        dfs(n->left,s,d,str);\\n        str.pop_back();\\n        str.push_back(\\'R\\');\\n        dfs(n->right,s,d,str);\\n        str.pop_back();\\n    }\\n    string anss, ansd;\\npublic:\\n    string getDirections(TreeNode* root, int startValue, int destValue) {\\n        string str;\\n        dfs(root, startValue, destValue, str);\\n        int i=0;\\n        while(anss[i] == ansd[i])\\n            i++;\\n        return string(anss.size()-i,\\'U\\').append(ansd.substr(i,ansd.size()-i));\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    void dfs(TreeNode* n, int s, int d, string& str)\\n    {\\n        if (n == nullptr)\\n            return;\\n        if (n->val == s)\\n            anss = str;\\n        else if (n->val == d) \\n            ansd = str;\\n        str.push_back(\\'L\\');\\n        dfs(n->left,s,d,str);\\n        str.pop_back();\\n        str.push_back(\\'R\\');\\n        dfs(n->right,s,d,str);\\n        str.pop_back();\\n    }\\n    string anss, ansd;\\npublic:\\n    string getDirections(TreeNode* root, int startValue, int destValue) {\\n        string str;\\n        dfs(root, startValue, destValue, str);\\n        int i=0;\\n        while(anss[i] == ansd[i])\\n            i++;\\n        return string(anss.size()-i,\\'U\\').append(ansd.substr(i,ansd.size()-i));\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1847993,
                "title": "c-2-methods-1-dfs-bfs-backtrack-the-path-2-lca-dfs",
                "content": "**[Approach 1] DFS + BFS + Backtrack the path**\\n\\n**Idea**\\n* Traverse each node by using DFS to find\\n\\t1. each node\\'s parent\\n\\t2. the starting node\\n* From the starting node, use BFS to reach the end node\\n\\nWith the following implementation, I\\'ve got MLE. (Spent too much memory)\\n\\n```\\nclass Solution {\\npublic:\\n    void FindStart(TreeNode* root, int startValue, unordered_map<TreeNode*,TreeNode*> &parent, TreeNode* &startNode) {\\n        if (root == nullptr) return ;\\n        if (root->val == startValue) {\\n            startNode = root;\\n        }\\n        \\n        if (root->left) {\\n            parent[root->left] = root;\\n            FindStart(root->left, startValue, parent, startNode);\\n        }\\n        if (root->right) {\\n            parent[root->right] = root;\\n            FindStart(root->right, startValue, parent, startNode);\\n        }\\n        return;\\n    }\\n    string getDirections(TreeNode* root, int startValue, int destValue) {\\n        unordered_map<TreeNode*,TreeNode*> parent;\\n        TreeNode* startNode;\\n        FindStart(root, startValue, parent, startNode);\\n        \\n        unordered_map<TreeNode*,bool> visited;\\n        queue<pair<TreeNode*,string>> q;\\n        q.push({startNode,\"\"});\\n        visited[startNode] = true;\\n        \\n        while (!q.empty()) {\\n            int n = q.size();\\n            \\n            for (int i = 0; i < n; i++) {\\n                auto [node, state] = q.front();\\n                q.pop();\\n                if (node->val == destValue) return state;\\n                \\n                if (node->left && !visited.count(node->left)) {\\n                    q.push({node->left,state+\"L\"});\\n                    visited[node->left] = true;\\n                }\\n                if (node->right && !visited.count(node->right)) {\\n                    q.push({node->right,state+\"R\"});\\n                    visited[node->right] = true;\\n                }\\n                if (parent.count(node) && !visited.count(parent[node])) {\\n                    q.push({parent[node],state+\"U\"});\\n                    visited[parent[node]] = true;\\n                }\\n            }\\n        }\\n        return \"\";\\n    }\\n};\\n```\\n\\nInspired by @dylan9, it might due to the path we stored is overflowing.\\nReference1 (see the comment in this post) : https://leetcode.com/problems/step-by-step-directions-from-a-binary-tree-node-to-another/discuss/1612071/Accepted-Python-Super-Simple-or-DFS-%2B-BFS\\nReference2 : https://leetcode.com/problems/step-by-step-directions-from-a-binary-tree-node-to-another/discuss/1613475/C-DFS-%2B-BFS\\n\\n```\\nI suspect the string you are using to hold the path is overflowing (I had that issue in C#) so I maintained just a parent reference to reconstruct the path via backtracing which fixed my TLE/MLE.\\n```\\n\\nHence, I\\'ve tried another approach mentioned above to just maintained the parent and the operation(\\'U\\', \\'L\\', \\'R\\'), and backtrack the entire path once we reached the end node.\\nWith the following implementation, it is accepted by OJ.\\n\\n![image](https://assets.leetcode.com/users/images/e575f1ab-58db-480a-8877-0436ed771262_1647238991.9218836.png)\\n\\n\\n```\\nclass Solution {\\npublic:\\n    void FindStart(TreeNode* root, int startValue, unordered_map<TreeNode*,TreeNode*> &parent, TreeNode* &startNode) {\\n        if (root == nullptr) return;\\n        if (root->val == startValue) {\\n            startNode = root;\\n        }\\n        \\n        bool ans = false;\\n        if (root->left) {\\n            parent[root->left] = root;\\n            FindStart(root->left, startValue, parent, startNode);\\n        }\\n        if (root->right) {\\n            parent[root->right] = root;\\n            FindStart(root->right, startValue, parent, startNode);\\n        }\\n        return;\\n    }\\n    string BackTrackPath(TreeNode* node, unordered_map<TreeNode*,pair<TreeNode*,string>> &GoThrough) {\\n        string s;\\n        while (GoThrough.count(node)) {\\n            s += GoThrough[node].second;\\n            node = GoThrough[node].first;\\n        }\\n        reverse(s.begin(), s.end());\\n        return s;\\n    }\\n    string getDirections(TreeNode* root, int startValue, int destValue) {\\n        unordered_map<TreeNode*,TreeNode*> parent;\\n        TreeNode* startNode;\\n        int num = 0;\\n        FindStart(root, startValue, parent, startNode);\\n        \\n        unordered_map<TreeNode*,bool> visited;\\n        unordered_map<TreeNode*,pair<TreeNode*,string>> GoThrough;  // <next_node, <cur_node,operation>>\\n        queue<TreeNode*> q;\\n        q.push(startNode);\\n        visited[startNode] = true;\\n        \\n        while (!q.empty()) {\\n            int n = q.size();\\n            \\n            for (int i = 0; i < n; i++) {\\n                auto node = q.front();\\n                q.pop();\\n                if (node->val == destValue) {\\n                    return BackTrackPath(node, GoThrough);\\n                }\\n                \\n                if (node->left && !visited.count(node->left)) {\\n                    q.push(node->left);\\n                    GoThrough[node->left] = {node,\"L\"};\\n                    visited[node->left] = true;\\n                }\\n                if (node->right && !visited.count(node->right)) {\\n                    q.push(node->right);\\n                    GoThrough[node->right] = {node,\"R\"};\\n                    visited[node->right] = true;\\n                }\\n                if (parent.count(node) && !visited.count(parent[node])) {\\n                    q.push(parent[node]);\\n                    GoThrough[parent[node]] = {node,\"U\"};\\n                    visited[parent[node]] = true;\\n                }\\n            }\\n        }\\n        return \"\";\\n    }\\n};\\n```\\n\\n**Note:** I\\'ve got the idea to (1) find the starting node first, (2) BFS to reach the target first from the following leetcode problem.\\nhttps://leetcode.com/problems/all-nodes-distance-k-in-binary-tree/\\n\\n====================================================================\\n\\n**[Approach 2] LCA + DFS**\\n\\n**Idea**\\n* As many posts mentioned, the length from ***starting node*** to ***ending node*** = S -> LCA + LCA -> E\\n\\t* S : Starting node\\n\\t* E : Ending node\\n\\t* LCA : lowest common ancestor of S and E\\n* Concept of the approach\\n\\t1. Find LCA of S and E\\n\\t2. Find the way from LCA -> S and LCA -> E\\n\\t3. Replace the way of LCA->S to all \\'U\\'\\n\\t4. Return the concatenated result of modified LCA->S and LCA->E\\n\\n```\\nclass Solution {\\npublic:\\n    bool Traverse(TreeNode* root, int value, string &s) {\\n        if (root->val == value) return true;\\n        \\n        if (root->left) {\\n            s.push_back(\\'L\\');\\n            if (Traverse(root->left, value, s)) return true;\\n            s.pop_back();\\n        }\\n        if (root->right) {\\n            s.push_back(\\'R\\');\\n            if (Traverse(root->right, value, s)) return true;\\n            s.pop_back();\\n        }\\n        return false;\\n    }\\n    TreeNode* getLCA(TreeNode* root, int startValue, int destValue) {\\n        if (root == nullptr) return root;\\n        if (root->val == startValue || root->val == destValue) return root;\\n        \\n        TreeNode* left = getLCA(root->left, startValue, destValue);\\n        TreeNode* right = getLCA(root->right, startValue, destValue);\\n        \\n        if (left && right) return root;\\n        return left ? left : right;\\n    }\\n    string getDirections(TreeNode* root, int startValue, int destValue) {\\n\\t\\t// (1) Find LCA of S and E\\n        TreeNode* LCA = getLCA(root, startValue, destValue);\\n        \\n        string left, right;\\n\\t\\t// (2) Find the way from LCA -> S and LCA -> E\\n        Traverse(LCA, startValue, left);\\n        Traverse(LCA, destValue, right);\\n\\t\\t// (3) Replace the way of LCA->S to all \\'U\\'\\n        for (int i = 0; i < left.size(); i++) left[i] = \\'U\\';\\n\\t\\t// (4) Return the concatenated result of modified LCA->S and LCA->E\\n        return left + right;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Backtracking",
                    "Depth-First Search",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void FindStart(TreeNode* root, int startValue, unordered_map<TreeNode*,TreeNode*> &parent, TreeNode* &startNode) {\\n        if (root == nullptr) return ;\\n        if (root->val == startValue) {\\n            startNode = root;\\n        }\\n        \\n        if (root->left) {\\n            parent[root->left] = root;\\n            FindStart(root->left, startValue, parent, startNode);\\n        }\\n        if (root->right) {\\n            parent[root->right] = root;\\n            FindStart(root->right, startValue, parent, startNode);\\n        }\\n        return;\\n    }\\n    string getDirections(TreeNode* root, int startValue, int destValue) {\\n        unordered_map<TreeNode*,TreeNode*> parent;\\n        TreeNode* startNode;\\n        FindStart(root, startValue, parent, startNode);\\n        \\n        unordered_map<TreeNode*,bool> visited;\\n        queue<pair<TreeNode*,string>> q;\\n        q.push({startNode,\"\"});\\n        visited[startNode] = true;\\n        \\n        while (!q.empty()) {\\n            int n = q.size();\\n            \\n            for (int i = 0; i < n; i++) {\\n                auto [node, state] = q.front();\\n                q.pop();\\n                if (node->val == destValue) return state;\\n                \\n                if (node->left && !visited.count(node->left)) {\\n                    q.push({node->left,state+\"L\"});\\n                    visited[node->left] = true;\\n                }\\n                if (node->right && !visited.count(node->right)) {\\n                    q.push({node->right,state+\"R\"});\\n                    visited[node->right] = true;\\n                }\\n                if (parent.count(node) && !visited.count(parent[node])) {\\n                    q.push({parent[node],state+\"U\"});\\n                    visited[parent[node]] = true;\\n                }\\n            }\\n        }\\n        return \"\";\\n    }\\n};\\n```\n```\\nI suspect the string you are using to hold the path is overflowing (I had that issue in C#) so I maintained just a parent reference to reconstruct the path via backtracing which fixed my TLE/MLE.\\n```\n```\\nclass Solution {\\npublic:\\n    void FindStart(TreeNode* root, int startValue, unordered_map<TreeNode*,TreeNode*> &parent, TreeNode* &startNode) {\\n        if (root == nullptr) return;\\n        if (root->val == startValue) {\\n            startNode = root;\\n        }\\n        \\n        bool ans = false;\\n        if (root->left) {\\n            parent[root->left] = root;\\n            FindStart(root->left, startValue, parent, startNode);\\n        }\\n        if (root->right) {\\n            parent[root->right] = root;\\n            FindStart(root->right, startValue, parent, startNode);\\n        }\\n        return;\\n    }\\n    string BackTrackPath(TreeNode* node, unordered_map<TreeNode*,pair<TreeNode*,string>> &GoThrough) {\\n        string s;\\n        while (GoThrough.count(node)) {\\n            s += GoThrough[node].second;\\n            node = GoThrough[node].first;\\n        }\\n        reverse(s.begin(), s.end());\\n        return s;\\n    }\\n    string getDirections(TreeNode* root, int startValue, int destValue) {\\n        unordered_map<TreeNode*,TreeNode*> parent;\\n        TreeNode* startNode;\\n        int num = 0;\\n        FindStart(root, startValue, parent, startNode);\\n        \\n        unordered_map<TreeNode*,bool> visited;\\n        unordered_map<TreeNode*,pair<TreeNode*,string>> GoThrough;  // <next_node, <cur_node,operation>>\\n        queue<TreeNode*> q;\\n        q.push(startNode);\\n        visited[startNode] = true;\\n        \\n        while (!q.empty()) {\\n            int n = q.size();\\n            \\n            for (int i = 0; i < n; i++) {\\n                auto node = q.front();\\n                q.pop();\\n                if (node->val == destValue) {\\n                    return BackTrackPath(node, GoThrough);\\n                }\\n                \\n                if (node->left && !visited.count(node->left)) {\\n                    q.push(node->left);\\n                    GoThrough[node->left] = {node,\"L\"};\\n                    visited[node->left] = true;\\n                }\\n                if (node->right && !visited.count(node->right)) {\\n                    q.push(node->right);\\n                    GoThrough[node->right] = {node,\"R\"};\\n                    visited[node->right] = true;\\n                }\\n                if (parent.count(node) && !visited.count(parent[node])) {\\n                    q.push(parent[node]);\\n                    GoThrough[parent[node]] = {node,\"U\"};\\n                    visited[parent[node]] = true;\\n                }\\n            }\\n        }\\n        return \"\";\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    bool Traverse(TreeNode* root, int value, string &s) {\\n        if (root->val == value) return true;\\n        \\n        if (root->left) {\\n            s.push_back(\\'L\\');\\n            if (Traverse(root->left, value, s)) return true;\\n            s.pop_back();\\n        }\\n        if (root->right) {\\n            s.push_back(\\'R\\');\\n            if (Traverse(root->right, value, s)) return true;\\n            s.pop_back();\\n        }\\n        return false;\\n    }\\n    TreeNode* getLCA(TreeNode* root, int startValue, int destValue) {\\n        if (root == nullptr) return root;\\n        if (root->val == startValue || root->val == destValue) return root;\\n        \\n        TreeNode* left = getLCA(root->left, startValue, destValue);\\n        TreeNode* right = getLCA(root->right, startValue, destValue);\\n        \\n        if (left && right) return root;\\n        return left ? left : right;\\n    }\\n    string getDirections(TreeNode* root, int startValue, int destValue) {\\n\\t\\t// (1) Find LCA of S and E\\n        TreeNode* LCA = getLCA(root, startValue, destValue);\\n        \\n        string left, right;\\n\\t\\t// (2) Find the way from LCA -> S and LCA -> E\\n        Traverse(LCA, startValue, left);\\n        Traverse(LCA, destValue, right);\\n\\t\\t// (3) Replace the way of LCA->S to all \\'U\\'\\n        for (int i = 0; i < left.size(); i++) left[i] = \\'U\\';\\n\\t\\t// (4) Return the concatenated result of modified LCA->S and LCA->E\\n        return left + right;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1764826,
                "title": "clean-single-pass-collect-start-end-path-no-lca-needed",
                "content": "**Idea:**\\n\\nPath will always pass through LCA of start & end\\nRoot -> LCA path with be common in paths Root -> start & Root -> end\\nTraverse tree fully once and generate path from root along with traversal\\nWhen start or end is seen collect the paths from root -> start & root -> end\\n**for example:** LLRL & LLLRRL\\nTrim common prefix from both the paths\\n**after trim**: RL && LRRL\\nReplace all the characters in first Path as \"U\"\\n\\n**Java Code**\\n\\n```\\nclass Solution {\\n    String a = \"\";\\n    String b = \"\";\\n    private void buildPath(TreeNode root, int start, int end, StringBuilder sb) {\\n        if(root == null)\\n            return;\\n        if(root.val == start) {\\n            a = sb.toString();\\n        }\\n        if(root.val == end) {\\n            b = sb.toString();\\n        }\\n        if(root.left != null) {\\n            sb.append(\"L\");\\n            buildPath(root.left, start, end, sb);\\n            sb.deleteCharAt(sb.length()-1);\\n        }\\n        if(root.right != null) {\\n            sb.append(\"R\");\\n            buildPath(root.right, start, end, sb);\\n            sb.deleteCharAt(sb.length()-1);\\n        }\\n        return;\\n            \\n    }\\n    public String getDirections(TreeNode root, int startValue, int destValue) {\\n        buildPath(root, startValue, destValue, new StringBuilder());\\n        if(a == \"\")\\n            return b;\\n        if(b == \"\")\\n            return \"U\".repeat(a.length());\\n        int i=0;\\n        while(i<a.length() && i<b.length() && a.charAt(i) == b.charAt(i))\\n            i++;\\n        return \"U\".repeat(a.length()-i) + b.substring(i, b.length());\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    String a = \"\";\\n    String b = \"\";\\n    private void buildPath(TreeNode root, int start, int end, StringBuilder sb) {\\n        if(root == null)\\n            return;\\n        if(root.val == start) {\\n            a = sb.toString();\\n        }\\n        if(root.val == end) {\\n            b = sb.toString();\\n        }\\n        if(root.left != null) {\\n            sb.append(\"L\");\\n            buildPath(root.left, start, end, sb);\\n            sb.deleteCharAt(sb.length()-1);\\n        }\\n        if(root.right != null) {\\n            sb.append(\"R\");\\n            buildPath(root.right, start, end, sb);\\n            sb.deleteCharAt(sb.length()-1);\\n        }\\n        return;\\n            \\n    }\\n    public String getDirections(TreeNode root, int startValue, int destValue) {\\n        buildPath(root, startValue, destValue, new StringBuilder());\\n        if(a == \"\")\\n            return b;\\n        if(b == \"\")\\n            return \"U\".repeat(a.length());\\n        int i=0;\\n        while(i<a.length() && i<b.length() && a.charAt(i) == b.charAt(i))\\n            i++;\\n        return \"U\".repeat(a.length()-i) + b.substring(i, b.length());\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1613013,
                "title": "rust-with-comments",
                "content": "```\\nuse std::cell::RefCell;\\nuse std::rc::Rc;\\n\\nuse crate::tree_node::TreeNode;\\n\\nstruct Solution;\\n\\nimpl Solution {\\n    pub fn get_directions(\\n        root: Option<Rc<RefCell<TreeNode>>>,\\n        start_value: i32,\\n        dest_value: i32,\\n    ) -> String {\\n        // 1. find path from root to start\\n        // 2. find path from root to dest\\n        // 3. remove dup parent nodes\\n        // 4. revert path to start, and join path with dest\\n        let mut path_to_start: Vec<char> = Vec::new();\\n        let mut path_to_dest: Vec<char> = Vec::new();\\n\\n        Self::find_path(&root, start_value, &mut path_to_start);\\n        Self::find_path(&root, dest_value, &mut path_to_dest);\\n\\n        let mut start_idx = 0;\\n        for i in 0..(path_to_start.len()).min(path_to_dest.len()) {\\n            if path_to_start[i] == path_to_dest[i] {\\n                start_idx = i + 1;\\n            } else {\\n                break;\\n            }\\n        }\\n\\n        path_to_start = path_to_start[start_idx..].to_vec();\\n        path_to_dest = path_to_dest[start_idx..].to_vec();\\n\\n        // revert path_to_start\\n        let mut path_to_start_rev = vec![\\'U\\'; path_to_start.len()];\\n\\t\\t// join with dest\\n        path_to_start_rev.append(&mut path_to_dest);\\n        path_to_start_rev.iter().collect()\\n    }\\n\\n    fn find_path(root: &Option<Rc<RefCell<TreeNode>>>, value: i32, path: &mut Vec<char>) -> bool {\\n        match root {\\n            None => return false,\\n            Some(r) => {\\n                if r.borrow().val == value {\\n                    return true;\\n                } else {\\n                    path.push(\\'L\\');\\n                    if Self::find_path(&r.borrow().left, value, path) {\\n                        return true;\\n                    }\\n                    path.pop();\\n\\n                    path.push(\\'R\\');\\n                    if Self::find_path(&r.borrow().right, value, path) {\\n                        return true;\\n                    }\\n                    path.pop();\\n\\n                    return false;\\n                }\\n            }\\n        }\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nuse std::cell::RefCell;\\nuse std::rc::Rc;\\n\\nuse crate::tree_node::TreeNode;\\n\\nstruct Solution;\\n\\nimpl Solution {\\n    pub fn get_directions(\\n        root: Option<Rc<RefCell<TreeNode>>>,\\n        start_value: i32,\\n        dest_value: i32,\\n    ) -> String {\\n        // 1. find path from root to start\\n        // 2. find path from root to dest\\n        // 3. remove dup parent nodes\\n        // 4. revert path to start, and join path with dest\\n        let mut path_to_start: Vec<char> = Vec::new();\\n        let mut path_to_dest: Vec<char> = Vec::new();\\n\\n        Self::find_path(&root, start_value, &mut path_to_start);\\n        Self::find_path(&root, dest_value, &mut path_to_dest);\\n\\n        let mut start_idx = 0;\\n        for i in 0..(path_to_start.len()).min(path_to_dest.len()) {\\n            if path_to_start[i] == path_to_dest[i] {\\n                start_idx = i + 1;\\n            } else {\\n                break;\\n            }\\n        }\\n\\n        path_to_start = path_to_start[start_idx..].to_vec();\\n        path_to_dest = path_to_dest[start_idx..].to_vec();\\n\\n        // revert path_to_start\\n        let mut path_to_start_rev = vec![\\'U\\'; path_to_start.len()];\\n\\t\\t// join with dest\\n        path_to_start_rev.append(&mut path_to_dest);\\n        path_to_start_rev.iter().collect()\\n    }\\n\\n    fn find_path(root: &Option<Rc<RefCell<TreeNode>>>, value: i32, path: &mut Vec<char>) -> bool {\\n        match root {\\n            None => return false,\\n            Some(r) => {\\n                if r.borrow().val == value {\\n                    return true;\\n                } else {\\n                    path.push(\\'L\\');\\n                    if Self::find_path(&r.borrow().left, value, path) {\\n                        return true;\\n                    }\\n                    path.pop();\\n\\n                    path.push(\\'R\\');\\n                    if Self::find_path(&r.borrow().right, value, path) {\\n                        return true;\\n                    }\\n                    path.pop();\\n\\n                    return false;\\n                }\\n            }\\n        }\\n    }\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1612229,
                "title": "map-nodes-with-their-parents-perform-bfs-could-anyone-please-tell-why-i-m-getting-tle",
                "content": "```\\n  class Pair{\\n        TreeNode  node; \\n        String psf; \\n\\t\\t\\n        public Pair(TreeNode node, String psf){\\n            this.node = node; \\n            this.psf = psf; \\n        }\\n    }\\n    \\n    public TreeNode findPar(TreeNode root,HashMap<TreeNode, TreeNode> map, int startVal){\\n        Queue<TreeNode> q = new ArrayDeque<>(); //BFS to map nodes with their parent nodes\\n        q.add(root); \\n        \\n        TreeNode start = null; \\n        \\n        while(q.size()>0){\\n            int size = q.size();\\n            \\n            while(size-- >0){\\n                TreeNode rem = q.remove(); \\n                if(rem.val == startVal) start =  rem; // found node corresponding to startval\\n\\t\\t\\t\\t\\n                if(rem.left!=null){ \\n                    q.add(rem.left);\\n                    map.put(rem.left, rem); // map cur node with its parent\\n                }\\n                \\n                if(rem.right!=null){\\n                    q.add(rem.right); \\n                    map.put(rem.right, rem); \\n                }\\n            }\\n        }\\n        \\n        return start; \\n    }\\n    \\n   \\n    \\n    public String getDirections(TreeNode root, int startValue, int destValue) {\\n        if(root == null) return \"\"; \\n        \\n        HashMap<TreeNode, TreeNode> map = new HashMap<>();     \\n        TreeNode start = findPar(root, map, startValue); //map child to parent ptrs; get node corresponding to startValue\\n        \\n        \\n        Queue<Pair> q = new ArrayDeque<>(); \\n        q.add(new Pair(start,\"\")); \\n        \\n        while(q.size()>0){ //BFS to find shortest distance\\n            int size = q.size();\\n\\t\\t\\t\\n            while(size-- >0){\\n                Pair pair = q.remove(); \\n                TreeNode rem = pair.node; \\n                String psf  = pair.psf; \\n                \\n                if(rem.val == destValue) return psf; //reached target\\n                \\n                if(rem.left!=null){\\n                    q.add(new Pair(rem.left, psf + \"L\")); // add left child if exists\\n                }\\n                \\n                if(rem.right!=null){\\n                    q.add(new Pair(rem.right, psf + \"R\")); // add rt child if exists\\n                }\\n                \\n                if(map.containsKey(rem)){\\n\\t\\t\\t\\t   q.add(new Pair(map.get(rem), psf + \"U\")); //add parent node if exists\\n\\t\\t\\t\\t}\\n            }\\n        }\\n        \\n        return \"0\"; \\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n  class Pair{\\n        TreeNode  node; \\n        String psf; \\n\\t\\t\\n        public Pair(TreeNode node, String psf){\\n            this.node = node; \\n            this.psf = psf; \\n        }\\n    }\\n    \\n    public TreeNode findPar(TreeNode root,HashMap<TreeNode, TreeNode> map, int startVal){\\n        Queue<TreeNode> q = new ArrayDeque<>(); //BFS to map nodes with their parent nodes\\n        q.add(root); \\n        \\n        TreeNode start = null; \\n        \\n        while(q.size()>0){\\n            int size = q.size();\\n            \\n            while(size-- >0){\\n                TreeNode rem = q.remove(); \\n                if(rem.val == startVal) start =  rem; // found node corresponding to startval\\n\\t\\t\\t\\t\\n                if(rem.left!=null){ \\n                    q.add(rem.left);\\n                    map.put(rem.left, rem); // map cur node with its parent\\n                }\\n                \\n                if(rem.right!=null){\\n                    q.add(rem.right); \\n                    map.put(rem.right, rem); \\n                }\\n            }\\n        }\\n        \\n        return start; \\n    }\\n    \\n   \\n    \\n    public String getDirections(TreeNode root, int startValue, int destValue) {\\n        if(root == null) return \"\"; \\n        \\n        HashMap<TreeNode, TreeNode> map = new HashMap<>();     \\n        TreeNode start = findPar(root, map, startValue); //map child to parent ptrs; get node corresponding to startValue\\n        \\n        \\n        Queue<Pair> q = new ArrayDeque<>(); \\n        q.add(new Pair(start,\"\")); \\n        \\n        while(q.size()>0){ //BFS to find shortest distance\\n            int size = q.size();\\n\\t\\t\\t\\n            while(size-- >0){\\n                Pair pair = q.remove(); \\n                TreeNode rem = pair.node; \\n                String psf  = pair.psf; \\n                \\n                if(rem.val == destValue) return psf; //reached target\\n                \\n                if(rem.left!=null){\\n                    q.add(new Pair(rem.left, psf + \"L\")); // add left child if exists\\n                }\\n                \\n                if(rem.right!=null){\\n                    q.add(new Pair(rem.right, psf + \"R\")); // add rt child if exists\\n                }\\n                \\n                if(map.containsKey(rem)){\\n\\t\\t\\t\\t   q.add(new Pair(map.get(rem), psf + \"U\")); //add parent node if exists\\n\\t\\t\\t\\t}\\n            }\\n        }\\n        \\n        return \"0\"; \\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1612204,
                "title": "c-easy-to-understand-with-short-code-lca-and-path-finding",
                "content": "Algorithm: \\n1. Find LCA(lowest common ancestor) who is nearnest common root of both nodes. \\n2. Find path between startNode to LCA Node. And replace them with \\'U\\'.  For more understanding, please notice the figure in the problem. \\n3. Find path between endNode to LCA node.\\n4. Merge both path. \\n\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\nprivate:\\n    TreeNode* LCA(TreeNode* root, int &start, int &end) {\\n        \\n        if (!root || root->val == start || root->val == end) return root;\\n        TreeNode* left = LCA(root->left, start, end); // search in left\\n        TreeNode* right = LCA(root->right, start, end); // search in right\\n\\t\\t\\n\\t\\tif(left && right) return root;  // if left & right both have targeted nodes then return root, else return not empty side; \\n        return left ? left:right;\\n    }\\n    \\n    bool findPath(TreeNode* root,int &target, string &localPath){\\n        if(root == NULL) return false;\\n        if(root->val == target) return true;\\n\\n        localPath.push_back(\\'L\\'); // adding path\\n        bool isSeen = findPath(root->left, target, localPath);\\n        if(isSeen) return true; // already result is found, so stop the process. \\n        localPath.pop_back(); // removing last path as result is not found. \\n        \\n        localPath.push_back(\\'R\\');\\n        isSeen = findPath(root->right, target, localPath);\\n        if(isSeen) return true;\\n        localPath.pop_back();\\n        return false;\\n    }\\n\\npublic:\\n    string getDirections(TreeNode* root, int startValue, int destValue) {\\n        \\n        TreeNode *lca = LCA(root, startValue, destValue);       \\n        string result;\\n \\n        findPath(lca, startValue, result);\\n        for(auto &p:result) p = \\'U\\'; // changing the direction\\n        findPath(lca, destValue, result); // appending destination path with previous path. \\n\\n        return result;    \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\nprivate:\\n    TreeNode* LCA(TreeNode* root, int &start, int &end) {\\n        \\n        if (!root || root->val == start || root->val == end) return root;\\n        TreeNode* left = LCA(root->left, start, end); // search in left\\n        TreeNode* right = LCA(root->right, start, end); // search in right\\n\\t\\t\\n\\t\\tif(left && right) return root;  // if left & right both have targeted nodes then return root, else return not empty side; \\n        return left ? left:right;\\n    }\\n    \\n    bool findPath(TreeNode* root,int &target, string &localPath){\\n        if(root == NULL) return false;\\n        if(root->val == target) return true;\\n\\n        localPath.push_back(\\'L\\'); // adding path\\n        bool isSeen = findPath(root->left, target, localPath);\\n        if(isSeen) return true; // already result is found, so stop the process. \\n        localPath.pop_back(); // removing last path as result is not found. \\n        \\n        localPath.push_back(\\'R\\');\\n        isSeen = findPath(root->right, target, localPath);\\n        if(isSeen) return true;\\n        localPath.pop_back();\\n        return false;\\n    }\\n\\npublic:\\n    string getDirections(TreeNode* root, int startValue, int destValue) {\\n        \\n        TreeNode *lca = LCA(root, startValue, destValue);       \\n        string result;\\n \\n        findPath(lca, startValue, result);\\n        for(auto &p:result) p = \\'U\\'; // changing the direction\\n        findPath(lca, destValue, result); // appending destination path with previous path. \\n\\n        return result;    \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4013581,
                "title": "check-out-this-simple-c-approach-without-finding-lca",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- We have essentially created the paths followed from the root to the start and end values, and stored them in separate strings (start and end) through our preorder DFS recursion.\\n- Then we ignore the common path in the two strings, and merge the uncommon paths as desired into our answer string.\\n\\n# Complexity\\n\\n**Time Complexity:** $$O(N)$$, where N is the number of nodes in the binary tree.\\n\\n**Space Complexity:** $$O(N)$$ in the worst case (due to recursion stack) but can be smaller in more balanced trees. Strings will also have at max O(N) size.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void dfs (TreeNode* root, int &startValue, int &destValue, string &begin, string &end, string &temp) {\\n        if (!root) return;\\n        if (!begin.empty() && !end.empty()) return;\\n        if (root->val == startValue) begin = temp;\\n        if (root->val == destValue) end = temp;\\n        temp += \\'L\\';\\n        dfs (root->left, startValue, destValue, begin, end, temp);\\n        temp.pop_back();\\n        temp += \\'R\\';\\n        dfs (root->right, startValue, destValue, begin, end, temp);\\n        temp.pop_back();\\n    }\\n    string getDirections(TreeNode* root, int startValue, int destValue) {\\n        string begin = \"\", end = \"\", temp = \"\";\\n        dfs(root, startValue, destValue, begin, end, temp);\\n        int i;\\n        for (i=0; i<begin.size() && i<end.size(); i++) {\\n            if (begin[i] != end[i]) break;\\n        }\\n        string ans = \"\";\\n        ans.append(begin.size()-i, \\'U\\');\\n        ans += end.substr(i);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String",
                    "Tree",
                    "Depth-First Search",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void dfs (TreeNode* root, int &startValue, int &destValue, string &begin, string &end, string &temp) {\\n        if (!root) return;\\n        if (!begin.empty() && !end.empty()) return;\\n        if (root->val == startValue) begin = temp;\\n        if (root->val == destValue) end = temp;\\n        temp += \\'L\\';\\n        dfs (root->left, startValue, destValue, begin, end, temp);\\n        temp.pop_back();\\n        temp += \\'R\\';\\n        dfs (root->right, startValue, destValue, begin, end, temp);\\n        temp.pop_back();\\n    }\\n    string getDirections(TreeNode* root, int startValue, int destValue) {\\n        string begin = \"\", end = \"\", temp = \"\";\\n        dfs(root, startValue, destValue, begin, end, temp);\\n        int i;\\n        for (i=0; i<begin.size() && i<end.size(); i++) {\\n            if (begin[i] != end[i]) break;\\n        }\\n        string ans = \"\";\\n        ans.append(begin.size()-i, \\'U\\');\\n        ans += end.substr(i);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3910533,
                "title": "c-super-easy-clean-code-100-optimised-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\nprivate:\\n    bool findPath(TreeNode* root, int tar, string& path){\\n\\n        if(root == nullptr) return false;\\n        if(root->val == tar) return true;\\n\\n        bool left = findPath(root->left,tar,path);\\n        if(left){\\n            path += \\'L\\';\\n            return true;\\n        }\\n\\n        bool right = findPath(root->right,tar,path);\\n        if(right){\\n            path += \\'R\\';\\n            return true;\\n        }\\n\\n        return false;\\n\\n    }\\npublic:\\n    string getDirections(TreeNode* root, int startValue, int destValue) {\\n        \\n        string pathRootToSt = \"\";\\n        findPath(root,startValue,pathRootToSt);\\n\\n        string pathRootToDt = \"\";\\n        findPath(root,destValue,pathRootToDt);\\n\\n        int i = pathRootToSt.size() - 1;\\n        int j = pathRootToDt.size() - 1;\\n\\n        while(i>=0 && j>=0 && pathRootToSt[i] == pathRootToDt[j]){\\n            pathRootToSt.pop_back();\\n            pathRootToDt.pop_back();\\n            i--;\\n            j--;\\n        }\\n\\n        i = pathRootToSt.size();\\n\\n        for(int j=0; j<i; j++){\\n            pathRootToSt[j] = \\'U\\';\\n        }\\n\\n        reverse(pathRootToDt.begin(),pathRootToDt.end());\\n\\n        return pathRootToSt + pathRootToDt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\nprivate:\\n    bool findPath(TreeNode* root, int tar, string& path){\\n\\n        if(root == nullptr) return false;\\n        if(root->val == tar) return true;\\n\\n        bool left = findPath(root->left,tar,path);\\n        if(left){\\n            path += \\'L\\';\\n            return true;\\n        }\\n\\n        bool right = findPath(root->right,tar,path);\\n        if(right){\\n            path += \\'R\\';\\n            return true;\\n        }\\n\\n        return false;\\n\\n    }\\npublic:\\n    string getDirections(TreeNode* root, int startValue, int destValue) {\\n        \\n        string pathRootToSt = \"\";\\n        findPath(root,startValue,pathRootToSt);\\n\\n        string pathRootToDt = \"\";\\n        findPath(root,destValue,pathRootToDt);\\n\\n        int i = pathRootToSt.size() - 1;\\n        int j = pathRootToDt.size() - 1;\\n\\n        while(i>=0 && j>=0 && pathRootToSt[i] == pathRootToDt[j]){\\n            pathRootToSt.pop_back();\\n            pathRootToDt.pop_back();\\n            i--;\\n            j--;\\n        }\\n\\n        i = pathRootToSt.size();\\n\\n        for(int j=0; j<i; j++){\\n            pathRootToSt[j] = \\'U\\';\\n        }\\n\\n        reverse(pathRootToDt.begin(),pathRootToDt.end());\\n\\n        return pathRootToSt + pathRootToDt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3782021,
                "title": "easiest-implementation-using-lca-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n\\nclass Solution {\\npublic:\\n\\n    TreeNode* lowestCA(TreeNode* root, int x, int y){\\n        if(!root) return NULL;\\n        if(root->val == x || root->val == y) return root;\\n\\n        TreeNode* left = lowestCA(root->left,x,y);\\n        TreeNode* right = lowestCA(root->right,x,y);\\n\\n        if(left && right) return root;\\n        return left ? left : right;\\n    }\\n\\n    string s1 = \"\", s2 = \"\";\\n\\n    bool toLCA(TreeNode* root, string &curr, int x){\\n        if(!root) return false;\\n        if(root->val == x){\\n            s1 = curr;\\n            return true;\\n        }\\n        curr += \"U\";\\n        if(toLCA(root->left,curr,x)) return true;\\n        if(toLCA(root->right,curr,x)) return true;\\n        curr.pop_back();\\n        return false;\\n    }\\n\\n    bool fromLCA(TreeNode* root, string &curr, int x){\\n        if(!root) return false;\\n        if(root->val == x){\\n            s2 = curr;\\n            return true;\\n        }\\n        curr += \"L\";\\n        if(fromLCA(root->left,curr,x)) return true;\\n        curr.pop_back();\\n\\n        curr+=\"R\";\\n        if(fromLCA(root->right,curr,x)) return true;\\n        curr.pop_back();\\n\\n        return false;\\n    }\\n    string getDirections(TreeNode* root, int startValue, int destValue) {\\n        TreeNode* lca = lowestCA(root,startValue,destValue);\\n        string curr1 = \"\", curr2 = \"\";\\n        toLCA(lca,curr1,startValue);\\n        fromLCA(lca,curr2,destValue);\\n        return s1 + s2;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String",
                    "Tree",
                    "Depth-First Search",
                    "Binary Tree"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n\\n    TreeNode* lowestCA(TreeNode* root, int x, int y){\\n        if(!root) return NULL;\\n        if(root->val == x || root->val == y) return root;\\n\\n        TreeNode* left = lowestCA(root->left,x,y);\\n        TreeNode* right = lowestCA(root->right,x,y);\\n\\n        if(left && right) return root;\\n        return left ? left : right;\\n    }\\n\\n    string s1 = \"\", s2 = \"\";\\n\\n    bool toLCA(TreeNode* root, string &curr, int x){\\n        if(!root) return false;\\n        if(root->val == x){\\n            s1 = curr;\\n            return true;\\n        }\\n        curr += \"U\";\\n        if(toLCA(root->left,curr,x)) return true;\\n        if(toLCA(root->right,curr,x)) return true;\\n        curr.pop_back();\\n        return false;\\n    }\\n\\n    bool fromLCA(TreeNode* root, string &curr, int x){\\n        if(!root) return false;\\n        if(root->val == x){\\n            s2 = curr;\\n            return true;\\n        }\\n        curr += \"L\";\\n        if(fromLCA(root->left,curr,x)) return true;\\n        curr.pop_back();\\n\\n        curr+=\"R\";\\n        if(fromLCA(root->right,curr,x)) return true;\\n        curr.pop_back();\\n\\n        return false;\\n    }\\n    string getDirections(TreeNode* root, int startValue, int destValue) {\\n        TreeNode* lca = lowestCA(root,startValue,destValue);\\n        string curr1 = \"\", curr2 = \"\";\\n        toLCA(lca,curr1,startValue);\\n        fromLCA(lca,curr2,destValue);\\n        return s1 + s2;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3288964,
                "title": "python3-easiest-explanation-lca-method",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n**Find common parent and navigate.**\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- find least common parent of start and destination.\\n- now find height of start from lca.\\n- append hheight times \\'U\\' in answer string.\\n- now traverse from lca for destination node.\\n- check in both left and right sub-tree, if destination found in left append \\'L\\' and if found in right append \\'R\\'.\\n- return answer.\\n\\n# Complexity\\n- Time complexity: O(3*height of tree)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def getDirections(self, root: Optional[TreeNode], startValue: int, destValue: int) -> str:\\n        lca = None\\n        def get_lca(curr=None):\\n            nonlocal lca\\n            if curr:\\n                ans = 0\\n                if curr.val == startValue:ans += 1\\n                if curr.val == destValue:ans += 1\\n                ans += get_lca(curr.left)\\n                ans += get_lca(curr.right)\\n                if ans == 2 and not lca:\\n                    lca = curr\\n                    return 0\\n                else: return ans\\n            return 0\\n        get_lca(root)\\n        def get_height_from(curr=None):\\n            if curr:\\n                if curr.val == startValue: return 1\\n                ans = get_height_from(curr.left)+get_height_from(curr.right)\\n                if ans: return ans + 1\\n                return ans\\n            return 0\\n        height = get_height_from(lca) - 1\\n        asf = []\\n        for i in range(height):asf.append(\\'U\\') \\n        def find_dest(curr=None):\\n            nonlocal asf\\n            if curr:\\n                if curr.val == destValue:return True\\n                asf.append(\\'L\\')\\n                if not find_dest(curr.left):asf.pop()\\n                else:return True\\n                asf.append(\\'R\\')\\n                if not find_dest(curr.right):asf.pop()\\n                else:return True\\n                return False\\n            return False\\n        find_dest(lca)\\n        return \\'\\'.join(asf)\\n```\\n# Please like and comment.",
                "solutionTags": [
                    "Python3",
                    "String",
                    "Tree",
                    "Depth-First Search"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def getDirections(self, root: Optional[TreeNode], startValue: int, destValue: int) -> str:\\n        lca = None\\n        def get_lca(curr=None):\\n            nonlocal lca\\n            if curr:\\n                ans = 0\\n                if curr.val == startValue:ans += 1\\n                if curr.val == destValue:ans += 1\\n                ans += get_lca(curr.left)\\n                ans += get_lca(curr.right)\\n                if ans == 2 and not lca:\\n                    lca = curr\\n                    return 0\\n                else: return ans\\n            return 0\\n        get_lca(root)\\n        def get_height_from(curr=None):\\n            if curr:\\n                if curr.val == startValue: return 1\\n                ans = get_height_from(curr.left)+get_height_from(curr.right)\\n                if ans: return ans + 1\\n                return ans\\n            return 0\\n        height = get_height_from(lca) - 1\\n        asf = []\\n        for i in range(height):asf.append(\\'U\\') \\n        def find_dest(curr=None):\\n            nonlocal asf\\n            if curr:\\n                if curr.val == destValue:return True\\n                asf.append(\\'L\\')\\n                if not find_dest(curr.left):asf.pop()\\n                else:return True\\n                asf.append(\\'R\\')\\n                if not find_dest(curr.right):asf.pop()\\n                else:return True\\n                return False\\n            return False\\n        find_dest(lca)\\n        return \\'\\'.join(asf)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3076660,
                "title": "using-lca",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\nO(N)\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    vector<int>P;\\n    vector<pair<char,int>>Q;\\n    char state=\\'N\\';\\n    void Traverse(vector<int>&pass1,vector<pair<char,int>>&pass2,TreeNode* root,int p,int q)\\n    {\\n        pass1.push_back(root->val);\\n        pass2.push_back({state,root->val});\\n        if(root->val==p)\\n        {\\n            P=pass1;\\n        }\\n        else if(root->val==q)\\n        {\\n            Q=pass2;\\n        }\\n        if(root->left!=NULL)\\n        {\\n            state=\\'L\\';\\n            Traverse(pass1,pass2,root->left,p,q);\\n        }\\n        if(root->right!=NULL)\\n        {\\n            state=\\'R\\';\\n            Traverse(pass1,pass2,root->right,p,q);\\n        }\\n        pass1.pop_back();\\n        pass2.pop_back();\\n        return;\\n    }\\n    vector<int> lowestCommonAncestor(TreeNode* root,int p,int q) \\n    {\\n        vector<int>pass1;\\n        vector<pair<char,int>>pass2;\\n        Traverse(pass1,pass2,root,p,q);\\n        unordered_map<int,pair<int,int>>existsancestor;// exists index\\n        int spindex1,spindex2;\\n        for(int i=0;i<P.size();i++)\\n        {\\n            existsancestor[P[i]].first=true;\\n            existsancestor[P[i]].second=i;\\n        }\\n        for(int i=Q.size()-1;i>=0;i--)\\n        {\\n            if(existsancestor[Q[i].second].first==1)\\n            {\\n                spindex1=existsancestor[Q[i].second].second;\\n                spindex2=i;\\n                break;\\n            }\\n        }\\n        return {spindex1,spindex2};\\n    }\\n    string getDirections(TreeNode* root, int startValue, int destValue) \\n    {\\n        vector<int>index=lowestCommonAncestor(root,startValue,destValue);\\n        string ans;\\n        int i=P.size()-index[0];\\n        while(i--)\\n        {\\n            ans.push_back(\\'U\\');\\n        }\\n        ans.pop_back();\\n        for(i=index[1]+1;i<Q.size();i++)\\n        {\\n            ans.push_back(Q[i].first);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    vector<int>P;\\n    vector<pair<char,int>>Q;\\n    char state=\\'N\\';\\n    void Traverse(vector<int>&pass1,vector<pair<char,int>>&pass2,TreeNode* root,int p,int q)\\n    {\\n        pass1.push_back(root->val);\\n        pass2.push_back({state,root->val});\\n        if(root->val==p)\\n        {\\n            P=pass1;\\n        }\\n        else if(root->val==q)\\n        {\\n            Q=pass2;\\n        }\\n        if(root->left!=NULL)\\n        {\\n            state=\\'L\\';\\n            Traverse(pass1,pass2,root->left,p,q);\\n        }\\n        if(root->right!=NULL)\\n        {\\n            state=\\'R\\';\\n            Traverse(pass1,pass2,root->right,p,q);\\n        }\\n        pass1.pop_back();\\n        pass2.pop_back();\\n        return;\\n    }\\n    vector<int> lowestCommonAncestor(TreeNode* root,int p,int q) \\n    {\\n        vector<int>pass1;\\n        vector<pair<char,int>>pass2;\\n        Traverse(pass1,pass2,root,p,q);\\n        unordered_map<int,pair<int,int>>existsancestor;// exists index\\n        int spindex1,spindex2;\\n        for(int i=0;i<P.size();i++)\\n        {\\n            existsancestor[P[i]].first=true;\\n            existsancestor[P[i]].second=i;\\n        }\\n        for(int i=Q.size()-1;i>=0;i--)\\n        {\\n            if(existsancestor[Q[i].second].first==1)\\n            {\\n                spindex1=existsancestor[Q[i].second].second;\\n                spindex2=i;\\n                break;\\n            }\\n        }\\n        return {spindex1,spindex2};\\n    }\\n    string getDirections(TreeNode* root, int startValue, int destValue) \\n    {\\n        vector<int>index=lowestCommonAncestor(root,startValue,destValue);\\n        string ans;\\n        int i=P.size()-index[0];\\n        while(i--)\\n        {\\n            ans.push_back(\\'U\\');\\n        }\\n        ans.pop_back();\\n        for(i=index[1]+1;i<Q.size();i++)\\n        {\\n            ans.push_back(Q[i].first);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2912372,
                "title": "simple-fast-c-solution-get-two-paths-remove-their-common-prefix",
                "content": "# Approach\\nWe can use a simple recursive procedure with a `StringBuilder` to construct the path (string made of `\\'L\\'` and `\\'R\\'`) leading to each of the two values. They\\'re constructed backwards, so we need to reverse them afterwards. Then if they have any common prefix we remove them. Finally the first string is replaced by a string of all `\\'U\\'` of the same size, and they\\'re appended.\\n\\n# Complexity\\n- Time complexity:\\n$$O(\\\\text{tree depth})$$\\n\\n- Space complexity:\\n$$O(\\\\text{tree depth})$$\\n\\n# Code\\n```\\n/**\\n * public class TreeNode {\\n *     public int val;\\n *     public TreeNode left;\\n *     public TreeNode right;\\n * }\\n */\\npublic class Solution {\\n    public bool GetPath(TreeNode root, int val, StringBuilder result) {\\n        if (root == null) {\\n            return false;\\n        }\\n        if (root.val == val) {\\n            return true;\\n        }\\n        if (GetPath(root.left, val, result)) {\\n            result.Append(\"L\");\\n            return true;\\n        }\\n        if (GetPath(root.right, val, result)) {\\n            result.Append(\"R\");\\n            return true;\\n        }\\n        return false;\\n    }\\n\\n    public void Reverse(StringBuilder sb) {\\n        for (int i=0; i < sb.Length/2; i++) {\\n            char temp = sb[i];\\n            sb[i] = sb[sb.Length - 1 - i];\\n            sb[sb.Length - 1 - i] = temp;\\n        }\\n    }\\n\\n    public string GetDirections(TreeNode root, int startValue, int destValue) {\\n        StringBuilder startBuild = new StringBuilder(), destBuild = new StringBuilder();\\n        GetPath(root, startValue, startBuild);\\n        GetPath(root, destValue, destBuild);\\n        Reverse(startBuild);\\n        Reverse(destBuild);\\n\\n        int prefixLength;\\n        for (prefixLength=0;\\n             prefixLength < startBuild.Length && prefixLength < destBuild.Length;\\n             prefixLength++) {\\n            if (startBuild[prefixLength] != destBuild[prefixLength]) {\\n                break;\\n            }\\n        }\\n\\n        return new string(\\'U\\', startBuild.Length - prefixLength) +\\n            destBuild.ToString(prefixLength, destBuild.Length - prefixLength);\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\n/**\\n * public class TreeNode {\\n *     public int val;\\n *     public TreeNode left;\\n *     public TreeNode right;\\n * }\\n */\\npublic class Solution {\\n    public bool GetPath(TreeNode root, int val, StringBuilder result) {\\n        if (root == null) {\\n            return false;\\n        }\\n        if (root.val == val) {\\n            return true;\\n        }\\n        if (GetPath(root.left, val, result)) {\\n            result.Append(\"L\");\\n            return true;\\n        }\\n        if (GetPath(root.right, val, result)) {\\n            result.Append(\"R\");\\n            return true;\\n        }\\n        return false;\\n    }\\n\\n    public void Reverse(StringBuilder sb) {\\n        for (int i=0; i < sb.Length/2; i++) {\\n            char temp = sb[i];\\n            sb[i] = sb[sb.Length - 1 - i];\\n            sb[sb.Length - 1 - i] = temp;\\n        }\\n    }\\n\\n    public string GetDirections(TreeNode root, int startValue, int destValue) {\\n        StringBuilder startBuild = new StringBuilder(), destBuild = new StringBuilder();\\n        GetPath(root, startValue, startBuild);\\n        GetPath(root, destValue, destBuild);\\n        Reverse(startBuild);\\n        Reverse(destBuild);\\n\\n        int prefixLength;\\n        for (prefixLength=0;\\n             prefixLength < startBuild.Length && prefixLength < destBuild.Length;\\n             prefixLength++) {\\n            if (startBuild[prefixLength] != destBuild[prefixLength]) {\\n                break;\\n            }\\n        }\\n\\n        return new string(\\'U\\', startBuild.Length - prefixLength) +\\n            destBuild.ToString(prefixLength, destBuild.Length - prefixLength);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2755548,
                "title": "java-using-node-to-root-path",
                "content": "```\\n//TC : O(N) + O(N) + O(logN) + O(logN);\\n//SC : O(logN), at worst the path arraylist can have maximum size as height of tree.\\nclass Solution {\\n    public String getDirections(TreeNode root, int startValue, int destValue) {\\n        List<TreeNode> path1 = nodeToRootPath(root, startValue); //O(N), worst case\\n        List<TreeNode> path2 = nodeToRootPath(root, destValue); //O(N), worst case\\n        \\n        int i = path1.size() - 1;\\n        int j = path2.size() - 1;\\n        \\n        while(i >= 0 && j >= 0 && path1.get(i).val == path2.get(j).val){\\n            i--;\\n            j--;\\n        }\\n        \\n        StringBuilder res = new StringBuilder();\\n        while(i >= 0){  //As we have to move Up from startValue to LCA, so we will append \\'U\\'\\n            res.append(\"U\");\\n            i--;\\n        }\\n        \\n        TreeNode tempRoot = path2.get(j + 1); //LCA\\n        while(j >= 0){\\n            TreeNode currNode = path2.get(j); // current node\\n            if(tempRoot.left == currNode){ //checking whether this node is left or right child of current node \\n                res.append(\"L\");\\n            }else{\\n                res.append(\"R\");\\n            }\\n            \\n            tempRoot = currNode; //change the temp root node as current node, for next node\\n            j--;\\n        }\\n        \\n        return res.toString();\\n    }\\n    \\n    \\n    //Node to root path code, TC : O(N), worst case\\n    public List<TreeNode> nodeToRootPath(TreeNode root, int val){\\n        if(root == null){\\n            return new ArrayList<>();\\n        }\\n        \\n        if(root.val == val){\\n            List<TreeNode> base = new ArrayList<>();\\n            base.add(root);\\n            return base;\\n        }\\n        \\n        List<TreeNode> left = nodeToRootPath(root.left, val);\\n        if(left.size() > 0){\\n            left.add(root);\\n            return left;\\n        }\\n        \\n        List<TreeNode> right = nodeToRootPath(root.right, val);\\n        if(right.size() > 0){\\n            right.add(root);\\n            return right;\\n        }\\n        \\n        return new ArrayList<>();\\n    }\\n}\\n```\\n**Hope you like the solution. If you liked it, please don\\'t forget to UPVOTE it. Thank You**",
                "solutionTags": [
                    "Recursion"
                ],
                "code": "```\\n//TC : O(N) + O(N) + O(logN) + O(logN);\\n//SC : O(logN), at worst the path arraylist can have maximum size as height of tree.\\nclass Solution {\\n    public String getDirections(TreeNode root, int startValue, int destValue) {\\n        List<TreeNode> path1 = nodeToRootPath(root, startValue); //O(N), worst case\\n        List<TreeNode> path2 = nodeToRootPath(root, destValue); //O(N), worst case\\n        \\n        int i = path1.size() - 1;\\n        int j = path2.size() - 1;\\n        \\n        while(i >= 0 && j >= 0 && path1.get(i).val == path2.get(j).val){\\n            i--;\\n            j--;\\n        }\\n        \\n        StringBuilder res = new StringBuilder();\\n        while(i >= 0){  //As we have to move Up from startValue to LCA, so we will append \\'U\\'\\n            res.append(\"U\");\\n            i--;\\n        }\\n        \\n        TreeNode tempRoot = path2.get(j + 1); //LCA\\n        while(j >= 0){\\n            TreeNode currNode = path2.get(j); // current node\\n            if(tempRoot.left == currNode){ //checking whether this node is left or right child of current node \\n                res.append(\"L\");\\n            }else{\\n                res.append(\"R\");\\n            }\\n            \\n            tempRoot = currNode; //change the temp root node as current node, for next node\\n            j--;\\n        }\\n        \\n        return res.toString();\\n    }\\n    \\n    \\n    //Node to root path code, TC : O(N), worst case\\n    public List<TreeNode> nodeToRootPath(TreeNode root, int val){\\n        if(root == null){\\n            return new ArrayList<>();\\n        }\\n        \\n        if(root.val == val){\\n            List<TreeNode> base = new ArrayList<>();\\n            base.add(root);\\n            return base;\\n        }\\n        \\n        List<TreeNode> left = nodeToRootPath(root.left, val);\\n        if(left.size() > 0){\\n            left.add(root);\\n            return left;\\n        }\\n        \\n        List<TreeNode> right = nodeToRootPath(root.right, val);\\n        if(right.size() > 0){\\n            right.add(root);\\n            return right;\\n        }\\n        \\n        return new ArrayList<>();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2626831,
                "title": "java-3-step-solution-explained",
                "content": "Considering that the Shortest Path from Start Node to Destination Node will pass Through their Lowest Common Ancestor, we have to Find the LCA 1st.\\n\\nFollowing this, we perform a DFS from the LCA to both the Start & the Destination Nodes by Building a Path on each Step. \\nWhile Performing our DFS, we check if we have Found a Path, else Backtrack from that Root node & explore the Other Subtree. For the Start Node DFS traversal, just append the String \"U\" instead as we are reusing the same Function for both start & end Path finding & we have used \"L\" for visiting left child Node & \"R\" for visiting right child Node.\\n\\nAt the End convert the LCA to Start node path to \"U\" entirely & append the LCA to Destination path.\\n\\n```\\nclass Solution {\\n    public String getDirections(TreeNode root, int startValue, int destValue) {\\n        TreeNode ancestor = findLCA(root, startValue, destValue);\\n        \\n        StringBuilder sb = new StringBuilder();\\n        buildPath(ancestor, startValue, sb);\\n        int len = sb.length();\\n        String path1 = \"\";\\n        \\n        for(int i = 0; i < len; i++)\\n            path1 += \"U\";\\n        \\n        sb.setLength(0);\\n        buildPath(ancestor, destValue, sb);\\n        \\n        String path2 = sb.toString();\\n        \\n        return path1 + path2;\\n    }\\n    \\n    private boolean buildPath(TreeNode root, int val, StringBuilder sb)\\n    {\\n        if(root == null) return false;\\n        if(root.val == val) return true;\\n        \\n        sb.append(\"L\");\\n        if(buildPath(root.left, val, sb)) return true;\\n        \\n        sb.delete(sb.length() - 1,sb.length());\\n        \\n        sb.append(\"R\");\\n        if(buildPath(root.right, val, sb)) return true;\\n        sb.delete(sb.length() - 1,sb.length());\\n        \\n        return false;\\n    }\\n    \\n    private TreeNode findLCA(TreeNode root, int start, int end)\\n    {\\n        if(root == null) return root;\\n        if(root.val == start || root.val == end)\\n            return root;\\n        \\n        TreeNode left = findLCA(root.left, start , end);\\n        TreeNode right = findLCA(root.right, start, end);\\n        \\n        if(left != null && right != null)\\n            return root;\\n        \\n        return left == null ? right : left;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Backtracking",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    public String getDirections(TreeNode root, int startValue, int destValue) {\\n        TreeNode ancestor = findLCA(root, startValue, destValue);\\n        \\n        StringBuilder sb = new StringBuilder();\\n        buildPath(ancestor, startValue, sb);\\n        int len = sb.length();\\n        String path1 = \"\";\\n        \\n        for(int i = 0; i < len; i++)\\n            path1 += \"U\";\\n        \\n        sb.setLength(0);\\n        buildPath(ancestor, destValue, sb);\\n        \\n        String path2 = sb.toString();\\n        \\n        return path1 + path2;\\n    }\\n    \\n    private boolean buildPath(TreeNode root, int val, StringBuilder sb)\\n    {\\n        if(root == null) return false;\\n        if(root.val == val) return true;\\n        \\n        sb.append(\"L\");\\n        if(buildPath(root.left, val, sb)) return true;\\n        \\n        sb.delete(sb.length() - 1,sb.length());\\n        \\n        sb.append(\"R\");\\n        if(buildPath(root.right, val, sb)) return true;\\n        sb.delete(sb.length() - 1,sb.length());\\n        \\n        return false;\\n    }\\n    \\n    private TreeNode findLCA(TreeNode root, int start, int end)\\n    {\\n        if(root == null) return root;\\n        if(root.val == start || root.val == end)\\n            return root;\\n        \\n        TreeNode left = findLCA(root.left, start , end);\\n        TreeNode right = findLCA(root.right, start, end);\\n        \\n        if(left != null && right != null)\\n            return root;\\n        \\n        return left == null ? right : left;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2624794,
                "title": "java-solution-using-dfs-and-lca-25ms-beats-95-96",
                "content": "**Three steps**\\n1. Find LCA\\n2. Find a path from **start to LCA**\\n\\t- use the **getLcaToEndPath()** helper method to find the path from LCA to start\\n\\t- replace all **L/R** in the string with **U** because we are going upward, from start to LCA\\n3. Find a path from **LCA to end**\\n\\t- normal DFS\\n\\t- once we find the destination (end) then set **found = true** so that we don\\'t traverse any further direction and don\\'t remove any extra characters from the stringbuilder path\\n\\n```\\n    public String getDirections(TreeNode root, int startValue, int destValue) {\\n        TreeNode lca = getLCA(root, startValue, destValue);\\n        \\n        boolean[] found1 = new boolean[]{ false };\\n        boolean[] found2 = new boolean[]{ false };\\n        \\n        StringBuilder sb1 = new StringBuilder(), sb2 = new StringBuilder();\\n        getStartToLcaPath(lca, startValue, sb1, found1);\\n        getLcaToEndPath(lca, destValue, sb2, found2);\\n        \\n        return sb1.toString() + sb2.toString();\\n    }\\n    \\n    private void getStartToLcaPath(TreeNode lca, int start, StringBuilder sb, boolean[] found){\\n        getLcaToEndPath(lca, start, sb, found);\\n        int length = sb.length();\\n        sb.setLength(0);\\n        sb.append(\"U\".repeat(length));\\n    }\\n    \\n    private void getLcaToEndPath(TreeNode lca, int dest, StringBuilder sb,  boolean[] found){\\n        if (lca == null){\\n            return;\\n        }\\n        if (lca.val == dest){\\n            found[0] = true;\\n            return;\\n        }\\n        if ((lca.left != null) && (!found[0])){\\n            sb.append(\"L\");\\n            getLcaToEndPath(lca.left, dest, sb, found);\\n            if (!found[0]){\\n                sb.setLength(Math.max((sb.length() - 1), 0));            \\n            }\\n        }\\n        if ((lca.right != null) && (!found[0])){\\n            sb.append(\"R\");\\n            getLcaToEndPath(lca.right, dest, sb, found);\\n            if (!found[0]){\\n                sb.setLength(Math.max((sb.length() - 1), 0));\\n            }\\n        }\\n    }\\n    \\n    private TreeNode getLCA(TreeNode root, int start, int end){\\n        if (root == null){\\n            return root;\\n        }\\n        \\n        if ((root.val == start) || (root.val == end)){\\n            return root;\\n        }\\n        \\n        TreeNode left = getLCA(root.left, start, end);\\n        TreeNode right = getLCA(root.right, start, end);\\n        \\n        if ((left != null) && (right != null)){\\n            return root;\\n        } else {\\n            return left == null ? right : left;\\n        }\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search"
                ],
                "code": "```\\n    public String getDirections(TreeNode root, int startValue, int destValue) {\\n        TreeNode lca = getLCA(root, startValue, destValue);\\n        \\n        boolean[] found1 = new boolean[]{ false };\\n        boolean[] found2 = new boolean[]{ false };\\n        \\n        StringBuilder sb1 = new StringBuilder(), sb2 = new StringBuilder();\\n        getStartToLcaPath(lca, startValue, sb1, found1);\\n        getLcaToEndPath(lca, destValue, sb2, found2);\\n        \\n        return sb1.toString() + sb2.toString();\\n    }\\n    \\n    private void getStartToLcaPath(TreeNode lca, int start, StringBuilder sb, boolean[] found){\\n        getLcaToEndPath(lca, start, sb, found);\\n        int length = sb.length();\\n        sb.setLength(0);\\n        sb.append(\"U\".repeat(length));\\n    }\\n    \\n    private void getLcaToEndPath(TreeNode lca, int dest, StringBuilder sb,  boolean[] found){\\n        if (lca == null){\\n            return;\\n        }\\n        if (lca.val == dest){\\n            found[0] = true;\\n            return;\\n        }\\n        if ((lca.left != null) && (!found[0])){\\n            sb.append(\"L\");\\n            getLcaToEndPath(lca.left, dest, sb, found);\\n            if (!found[0]){\\n                sb.setLength(Math.max((sb.length() - 1), 0));            \\n            }\\n        }\\n        if ((lca.right != null) && (!found[0])){\\n            sb.append(\"R\");\\n            getLcaToEndPath(lca.right, dest, sb, found);\\n            if (!found[0]){\\n                sb.setLength(Math.max((sb.length() - 1), 0));\\n            }\\n        }\\n    }\\n    \\n    private TreeNode getLCA(TreeNode root, int start, int end){\\n        if (root == null){\\n            return root;\\n        }\\n        \\n        if ((root.val == start) || (root.val == end)){\\n            return root;\\n        }\\n        \\n        TreeNode left = getLCA(root.left, start, end);\\n        TreeNode right = getLCA(root.right, start, end);\\n        \\n        if ((left != null) && (right != null)){\\n            return root;\\n        } else {\\n            return left == null ? right : left;\\n        }\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2600568,
                "title": "python-dfs-with-explanation",
                "content": "Approach - \\n* The path can follow the route from parent node, we need to construct a dict to store parent nodes\\n* Since the startNode is not provided, we need to find the startNode using the startValue\\n* Start from the startNode and go in all 3 directions i.e left, right, parent\\n* Once you find the destNode, iterate back to the startNode and construct the result path along the way.\\n\\nSolution - \\n1.  DFS to construct parent pointers. At every iteration, you need to keep track of the parent node. Add it to the ```parents``` dict. Every node will have only 1 parent, except root\\n2.  DFS to reach the startNode\\n3.  There are 2 stages in constructing the path\\n\\t* \\tReach the destNode from the startNode\\n\\t* \\tFrom the destNode, backtrack to the startNode and construct path along the way\\n\\nConstructing path - \\n* To make it easier to visualize, imagine you are at random node during backtracking (return calls of your recursive function). There can only be 3 cases - \\n\\t* You got an answer (i.e True) from the left node OR right node OR parent node\\n\\t* In the first case, you will add \"L\" to the result, since you got a True result from the node.left call\\n\\t* Similarly, if you got a True result from the node.right or node.parent calls, you will add \"R\" or \"U\" respectively\\n\\n```res``` is constructed in a reverse order, since you are constructing a path while backtracking from the destNode to sourceNode\\n\\n\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def getDirections(self, root: Optional[TreeNode], startValue: int, destValue: int) -> str:\\n        def generate_parent(node, parent):\\n            nonlocal parents\\n            if not node:\\n                return\\n            parents[node] = parent\\n            generate_parent(node.left, node)\\n            generate_parent(node.right, node)\\n        \\n        def reach_start(node):\\n            if not node:\\n                return None\\n            if node.val == startValue:\\n                return node\\n            left = reach_start(node.left)\\n            if left:\\n                return left\\n            \\n            right= reach_start(node.right)\\n            if right:\\n                return right\\n            \\n            return None\\n         \\n        def gen_path(node, visited, parents):\\n            nonlocal res\\n            if not node or node in visited:\\n                return False\\n            if node.val == destValue:\\n                return True\\n            visited.add(node)\\n            \\n            left = gen_path(node.left, visited, parents)\\n            if left:\\n                res += \"L\"\\n                return True\\n            right = gen_path(node.right, visited, parents)\\n            if right:\\n                res += \"R\"\\n                return True\\n            parent = gen_path(parents[node], visited, parents)\\n            if parent:\\n                res += \"U\"\\n                return True\\n            \\n        parents = {}\\n        generate_parent(root, None)\\n\\n        res = \"\"\\n        startNode = reach_start(root)\\n        if not startNode:\\n            return \"\"\\n        gen_path(startNode, set(), parents)\\n        return res[::-1]\\n```\\n\\nPlease upvote if you found this explanation helpful. It will encourage me to write more such solutions. Thanks!",
                "solutionTags": [
                    "Python",
                    "Depth-First Search"
                ],
                "code": "```parents```\n```res```\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def getDirections(self, root: Optional[TreeNode], startValue: int, destValue: int) -> str:\\n        def generate_parent(node, parent):\\n            nonlocal parents\\n            if not node:\\n                return\\n            parents[node] = parent\\n            generate_parent(node.left, node)\\n            generate_parent(node.right, node)\\n        \\n        def reach_start(node):\\n            if not node:\\n                return None\\n            if node.val == startValue:\\n                return node\\n            left = reach_start(node.left)\\n            if left:\\n                return left\\n            \\n            right= reach_start(node.right)\\n            if right:\\n                return right\\n            \\n            return None\\n         \\n        def gen_path(node, visited, parents):\\n            nonlocal res\\n            if not node or node in visited:\\n                return False\\n            if node.val == destValue:\\n                return True\\n            visited.add(node)\\n            \\n            left = gen_path(node.left, visited, parents)\\n            if left:\\n                res += \"L\"\\n                return True\\n            right = gen_path(node.right, visited, parents)\\n            if right:\\n                res += \"R\"\\n                return True\\n            parent = gen_path(parents[node], visited, parents)\\n            if parent:\\n                res += \"U\"\\n                return True\\n            \\n        parents = {}\\n        generate_parent(root, None)\\n\\n        res = \"\"\\n        startNode = reach_start(root)\\n        if not startNode:\\n            return \"\"\\n        gen_path(startNode, set(), parents)\\n        return res[::-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2592745,
                "title": "c-easy-solution",
                "content": "```\\n//TC=O(N)\\n    //SC=O(N) N=STRING SPACE\\n    TreeNode* lca(TreeNode* root,int p,int q){\\n        if(!root||root->val==p||root->val==q){\\n            return root;\\n        }\\n        TreeNode* left=lca(root->left,p,q);\\n        TreeNode* right=lca(root->right,p,q);\\n        if(!left){\\n            return right;\\n        }\\n        if(!right){\\n            return left;\\n        }\\n        return root;\\n    }\\n    void distance(TreeNode* root,int p,int k,int &dis){\\n        if(!root){\\n            return ;\\n        }\\n        if(root->val==p){\\n            dis=k;\\n        }\\n        distance(root->left,p,k+1,dis);\\n        distance(root->right,p,k+1,dis);\\n    }\\n    void find(TreeNode* root,int q,string &temp,string& pass){\\n        if(!root){\\n            return ;\\n        }\\n        if(root->val==q){\\n            temp=pass;\\n        }\\n        pass+=\"L\";\\n        find(root->left,q,temp,pass);\\n        pass.pop_back();\\n        pass+=\"R\";\\n        find(root->right,q,temp,pass);\\n        pass.pop_back();\\n    }\\n    string getDirections(TreeNode* root, int startValue, int destValue) {\\n        TreeNode* LCA=lca(root,startValue,destValue);\\n        string temp=\"\";\\n        int dis=0,k=0;\\n        distance(LCA,startValue,k,dis);\\n        string temp1=\"\",pass=\"\";\\n        find(LCA,destValue,temp1,pass);\\n        string ans=\"\";\\n        for(int i=0;i<dis;i++){\\n            ans+=\\'U\\';\\n        }\\n        \\n        return ans+temp1;\\n    }\\n```",
                "solutionTags": [
                    "C",
                    "String",
                    "Backtracking",
                    "Depth-First Search"
                ],
                "code": "```\\n//TC=O(N)\\n    //SC=O(N) N=STRING SPACE\\n    TreeNode* lca(TreeNode* root,int p,int q){\\n        if(!root||root->val==p||root->val==q){\\n            return root;\\n        }\\n        TreeNode* left=lca(root->left,p,q);\\n        TreeNode* right=lca(root->right,p,q);\\n        if(!left){\\n            return right;\\n        }\\n        if(!right){\\n            return left;\\n        }\\n        return root;\\n    }\\n    void distance(TreeNode* root,int p,int k,int &dis){\\n        if(!root){\\n            return ;\\n        }\\n        if(root->val==p){\\n            dis=k;\\n        }\\n        distance(root->left,p,k+1,dis);\\n        distance(root->right,p,k+1,dis);\\n    }\\n    void find(TreeNode* root,int q,string &temp,string& pass){\\n        if(!root){\\n            return ;\\n        }\\n        if(root->val==q){\\n            temp=pass;\\n        }\\n        pass+=\"L\";\\n        find(root->left,q,temp,pass);\\n        pass.pop_back();\\n        pass+=\"R\";\\n        find(root->right,q,temp,pass);\\n        pass.pop_back();\\n    }\\n    string getDirections(TreeNode* root, int startValue, int destValue) {\\n        TreeNode* LCA=lca(root,startValue,destValue);\\n        string temp=\"\";\\n        int dis=0,k=0;\\n        distance(LCA,startValue,k,dis);\\n        string temp1=\"\",pass=\"\";\\n        find(LCA,destValue,temp1,pass);\\n        string ans=\"\";\\n        for(int i=0;i<dis;i++){\\n            ans+=\\'U\\';\\n        }\\n        \\n        return ans+temp1;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2536099,
                "title": "javascript",
                "content": "```\\nvar getDirections = function(root, startValue, destValue) {\\n    // there is only 1 path from Start to End\\n    \\n  \\n    let start = \"\", end = \"\";\\n    // path L - RR \\n    function getPath (node, path) {\\n        if(!node) return;\\n        \\n        if(node.val === startValue)\\n            start = path;\\n        if(node.val === destValue)\\n            end = path;\\n            \\n        getPath(node.left, path + \"L\");\\n        getPath(node.right, path + \"R\");\\n    }\\n    \\n    getPath(root, \"\");\\n    \\n    let index = 0;\\n    \\n    while(start[index] === end[index])\\n        index += 1;\\n    \\n    return start.slice(index).split(\\'\\').map(_ => \"U\").join(\"\") + end.slice(index);\\n};",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar getDirections = function(root, startValue, destValue) {\\n    // there is only 1 path from Start to End\\n    \\n  \\n    let start = \"\", end = \"\";\\n    // path L - RR \\n    function getPath (node, path) {\\n        if(!node) return;\\n        \\n        if(node.val === startValue)\\n            start = path;\\n        if(node.val === destValue)\\n            end = path;\\n            \\n        getPath(node.left, path + \"L\");\\n        getPath(node.right, path + \"R\");\\n    }\\n    \\n    getPath(root, \"\");\\n    \\n    let index = 0;\\n    \\n    while(start[index] === end[index])\\n        index += 1;\\n    \\n    return start.slice(index).split(\\'\\').map(_ => \"U\").join(\"\") + end.slice(index);\\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 2433044,
                "title": "c-short-and-optimised-code-easy-to-understand",
                "content": "```\\n bool solve(TreeNode * root,int x,string &s)\\n    {\\n        if(root==NULL) return false;\\n        if(root->val == x) return true;\\n        s.push_back(\\'L\\');\\n        if(solve(root->left,x,s)) return true;\\n        s.pop_back();\\n        s.push_back(\\'R\\');\\n        if(solve(root->right,x,s)) return true;\\n        s.pop_back();\\n        return false;\\n    }\\n    \\n    \\n    TreeNode* findLCA(TreeNode* root,int p,int q)\\n    {\\n        if(root==NULL) return NULL;\\n        if(root->val==p || root->val==q) return root;\\n        TreeNode *LCA1 = findLCA(root->left,p,q);\\n        TreeNode *LCA2 = findLCA(root->right,p,q);\\n        if(LCA1!=NULL && LCA2!=NULL) return root;\\n        else if(LCA1==NULL) return LCA2;\\n        else return LCA1;\\n    }\\n    string getDirections(TreeNode* root, int startValue, int destValue) {\\n        TreeNode *LCA= findLCA(root,startValue,destValue);\\n        string a = \"\",b = \"\";\\n        solve(LCA,destValue,b);\\n        solve(LCA,startValue,a);\\n        for(int i=0;i<a.length();i++) a[i] = \\'U\\';\\n        return a+b;\\n    }",
                "solutionTags": [
                    "Backtracking"
                ],
                "code": "```\\n bool solve(TreeNode * root,int x,string &s)\\n    {\\n        if(root==NULL) return false;\\n        if(root->val == x) return true;\\n        s.push_back(\\'L\\');\\n        if(solve(root->left,x,s)) return true;\\n        s.pop_back();\\n        s.push_back(\\'R\\');\\n        if(solve(root->right,x,s)) return true;\\n        s.pop_back();\\n        return false;\\n    }\\n    \\n    \\n    TreeNode* findLCA(TreeNode* root,int p,int q)\\n    {\\n        if(root==NULL) return NULL;\\n        if(root->val==p || root->val==q) return root;\\n        TreeNode *LCA1 = findLCA(root->left,p,q);\\n        TreeNode *LCA2 = findLCA(root->right,p,q);\\n        if(LCA1!=NULL && LCA2!=NULL) return root;\\n        else if(LCA1==NULL) return LCA2;\\n        else return LCA1;\\n    }\\n    string getDirections(TreeNode* root, int startValue, int destValue) {\\n        TreeNode *LCA= findLCA(root,startValue,destValue);\\n        string a = \"\",b = \"\";\\n        solve(LCA,destValue,b);\\n        solve(LCA,startValue,a);\\n        for(int i=0;i<a.length();i++) a[i] = \\'U\\';\\n        return a+b;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2335362,
                "title": "intuitive-solution-using-lca",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    TreeNode* helper(TreeNode* root,int p,int q){\\n        if(root==nullptr)\\n            return nullptr;\\n        \\n        if(root->val==p || root->val==q)\\n            return root;\\n        \\n        TreeNode* x=helper(root->left,p,q);\\n        TreeNode* y=helper(root->right,p,q);\\n        \\n        if(x!=nullptr && y!=nullptr)\\n            return root;\\n        if(x==nullptr)\\n            return y;\\n        if(y==nullptr)\\n            return x;\\n        return nullptr;\\n    }\\n    \\n    \\n    string paths(TreeNode* root,int s){\\n        if(root==nullptr)\\n            return \"\";\\n        if(root->val==s){\\n            string ans=\"U\";\\n            return ans;\\n        }\\n        string x=paths(root->left,s);\\n        if(x.size()){\\n            x +=\"U\";\\n            return x;\\n        }\\n        string y=paths(root->right,s);\\n        if(y.size()){\\n            y +=\"U\";\\n            return y;\\n        }\\n        return \"\";\\n    }\\n    \\n    string pathd(TreeNode* root,int d){\\n        if(root==nullptr)\\n            return \"\";\\n        if(root->val==d){\\n            string ans=\"@\";\\n            return ans;\\n        }\\n        string x=pathd(root->left,d);\\n        if(x.size()){\\n            x +=\"L\";\\n            return x;\\n        }\\n        string y=pathd(root->right,d);\\n        if(y.size()){\\n            y +=\"R\";\\n            return y;\\n        }\\n        return \"\";\\n    }\\n    \\n    string getDirections(TreeNode* root, int startValue, int destValue) {\\n        TreeNode* lca=helper(root,startValue,destValue);\\n        string s=\"\",d=\"\";\\n        s=paths(lca,startValue);\\n        if(s.size())\\n            s.pop_back();\\n        d=pathd(lca,destValue);\\n        if(d.size()){\\n            reverse(d.begin(),d.end());\\n            d.pop_back();\\n        }\\n        return s+d;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    \\n    TreeNode* helper(TreeNode* root,int p,int q){\\n        if(root==nullptr)\\n            return nullptr;\\n        \\n        if(root->val==p || root->val==q)\\n            return root;\\n        \\n        TreeNode* x=helper(root->left,p,q);\\n        TreeNode* y=helper(root->right,p,q);\\n        \\n        if(x!=nullptr && y!=nullptr)\\n            return root;\\n        if(x==nullptr)\\n            return y;\\n        if(y==nullptr)\\n            return x;\\n        return nullptr;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 2297391,
                "title": "python-modified-find-lca-single-pass-recursive",
                "content": "I wanted to see if I could do this one by building on top of the standard \"Find-LCA of two nodes\" recursive solution. \\n\\nIn case the interviewer first asks you to find the LCA of two nodes, then adds a followup to return the steps between them.\\n\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def getDirections(self, root: Optional[TreeNode], startValue: int, destValue: int) -> str:\\n        start_path = []\\n        dest_path = []\\n        res = []\\n        \\n        def dfs(root):\\n            if not root or len(res) > 0:\\n                return False, False\\n            \\n            left_has_start, left_has_dest = dfs(root.left)\\n            right_has_start, right_has_dest = dfs(root.right)\\n            \\n            #update paths if they contain start/dest\\n            if left_has_start or right_has_start:\\n                start_path.append(\\'U\\')\\n                \\n            if left_has_dest:\\n                dest_path.append(\\'L\\')\\n                \\n            if right_has_dest:\\n                dest_path.append(\\'R\\')\\n            \\n            #standard \"find LCA\" logic\\n            left = left_has_start or left_has_dest\\n            right = right_has_start or right_has_dest\\n            mid = True if root.val == startValue or root.val == destValue else False\\n            \\n            #if we\\'ve hit the LCA, update res\\n            if left + right + mid >= 2:\\n                res.extend(start_path)\\n                res.extend(reversed(dest_path)) #dest path will be in reverse order\\n            \\n            #return bools for whether or not we have the start or dest in this path\\n            has_start = left_has_start or right_has_start or root.val == startValue\\n            has_dest = left_has_dest or right_has_dest or root.val == destValue\\n                \\n            return has_start, has_dest\\n        \\n        dfs(root)\\n        return \"\".join(res)\\n```",
                "solutionTags": [
                    "Python",
                    "Recursion"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def getDirections(self, root: Optional[TreeNode], startValue: int, destValue: int) -> str:\\n        start_path = []\\n        dest_path = []\\n        res = []\\n        \\n        def dfs(root):\\n            if not root or len(res) > 0:\\n                return False, False\\n            \\n            left_has_start, left_has_dest = dfs(root.left)\\n            right_has_start, right_has_dest = dfs(root.right)\\n            \\n            #update paths if they contain start/dest\\n            if left_has_start or right_has_start:\\n                start_path.append(\\'U\\')\\n                \\n            if left_has_dest:\\n                dest_path.append(\\'L\\')\\n                \\n            if right_has_dest:\\n                dest_path.append(\\'R\\')\\n            \\n            #standard \"find LCA\" logic\\n            left = left_has_start or left_has_dest\\n            right = right_has_start or right_has_dest\\n            mid = True if root.val == startValue or root.val == destValue else False\\n            \\n            #if we\\'ve hit the LCA, update res\\n            if left + right + mid >= 2:\\n                res.extend(start_path)\\n                res.extend(reversed(dest_path)) #dest path will be in reverse order\\n            \\n            #return bools for whether or not we have the start or dest in this path\\n            has_start = left_has_start or right_has_start or root.val == startValue\\n            has_dest = left_has_dest or right_has_dest or root.val == destValue\\n                \\n            return has_start, has_dest\\n        \\n        dfs(root)\\n        return \"\".join(res)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2274340,
                "title": "save-memory-lca-find-path-don-t-need-to-add-parent",
                "content": "1. First find the lowest common ancester, applying a flag to stop recursion earlier to save time.\\n2. Second, start at lowest common ancester rather than root, this save the memory and time cost from common path.\\nTime O(n)\\nSpace O(n) --> extremly case: linklist like tree\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def __init__(self):\\n        self.lca = None\\n    \\n    def getDirections(self, root: Optional[TreeNode], startValue: int, destValue: int) -> str:            \\n        def findlca(root, p, q, flag):\\n            if flag == False:\\n                return False, False\\n            if not root:\\n                return False, flag\\n            left, flag1 = findlca(root.left, p, q, flag)\\n            right, flag2 = findlca(root.right, p, q, flag)\\n            flag = flag1 and flag2\\n            if flag == False:\\n                return False, False\\n            if ((left and right) or (root.val in (p, q) and (left or right))) and self.lca is None:\\n                flag = False\\n                self.lca = root\\n                return True, flag\\n            if left or right or root.val in (p, q):\\n                return True, flag\\n            return False, flag\\n        \\n        def findpath(root, val, path):\\n            if root.val == val:\\n                return True\\n            if root.left and findpath(root.left, val, path):\\n                path += \"L\"\\n            elif root.right and findpath(root.right, val, path):\\n                path += \"R\"\\n            return True if path else False\\n            \\n        findlca(root, startValue, destValue, True)\\n        \\n        path_to_s, path_to_d = [], []\\n        findpath(self.lca, startValue, path_to_s)\\n        findpath(self.lca, destValue, path_to_d)\\n        \\n        return \"U\"*len(path_to_s) + \"\".join(reversed(path_to_d))\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def __init__(self):\\n        self.lca = None\\n    \\n    def getDirections(self, root: Optional[TreeNode], startValue: int, destValue: int) -> str:            \\n        def findlca(root, p, q, flag):\\n            if flag == False:\\n                return False, False\\n            if not root:\\n                return False, flag\\n            left, flag1 = findlca(root.left, p, q, flag)\\n            right, flag2 = findlca(root.right, p, q, flag)\\n            flag = flag1 and flag2\\n            if flag == False:\\n                return False, False\\n            if ((left and right) or (root.val in (p, q) and (left or right))) and self.lca is None:\\n                flag = False\\n                self.lca = root\\n                return True, flag\\n            if left or right or root.val in (p, q):\\n                return True, flag\\n            return False, flag\\n        \\n        def findpath(root, val, path):\\n            if root.val == val:\\n                return True\\n            if root.left and findpath(root.left, val, path):\\n                path += \"L\"\\n            elif root.right and findpath(root.right, val, path):\\n                path += \"R\"\\n            return True if path else False\\n            \\n        findlca(root, startValue, destValue, True)\\n        \\n        path_to_s, path_to_d = [], []\\n        findpath(self.lca, startValue, path_to_s)\\n        findpath(self.lca, destValue, path_to_d)\\n        \\n        return \"U\"*len(path_to_s) + \"\".join(reversed(path_to_d))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2243086,
                "title": "javascript-faster-than-90",
                "content": "```\\nvar getDirections = function(root, startValue, destValue) {\\n    const startPath = [];\\n    const destPath = [];\\n    find(root, startValue, startPath);\\n    find(root, destValue, destPath);\\n\\n    while(startPath.length && destPath.length && startPath.at(-1) == destPath.at(-1)) {\\n        startPath.pop();\\n        destPath.pop();\\n    }\\n\\n    return startPath.map(() => \"U\").join(\"\") + destPath.reverse().join(\"\");\\n};\\n\\nvar find = function(root, d, path) {\\n    if(root == null) return false;\\n    \\n    if(root.val == d) return true;\\n    \\n    if(root.left != null && find(root.left, d, path)) {\\n        path.push(\"L\");\\n        return true;\\n    }\\n\\n    if(root.right != null && find(root.right, d, path)) {\\n        path.push(\"R\");\\n        return true;\\n    }\\n    \\n    return false;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nvar getDirections = function(root, startValue, destValue) {\\n    const startPath = [];\\n    const destPath = [];\\n    find(root, startValue, startPath);\\n    find(root, destValue, destPath);\\n\\n    while(startPath.length && destPath.length && startPath.at(-1) == destPath.at(-1)) {\\n        startPath.pop();\\n        destPath.pop();\\n    }\\n\\n    return startPath.map(() => \"U\").join(\"\") + destPath.reverse().join(\"\");\\n};\\n\\nvar find = function(root, d, path) {\\n    if(root == null) return false;\\n    \\n    if(root.val == d) return true;\\n    \\n    if(root.left != null && find(root.left, d, path)) {\\n        path.push(\"L\");\\n        return true;\\n    }\\n\\n    if(root.right != null && find(root.right, d, path)) {\\n        path.push(\"R\");\\n        return true;\\n    }\\n    \\n    return false;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2239775,
                "title": "java-o-n-dfs-lca",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public String getDirections(TreeNode root, int startValue, int destValue) {\\n        // do we have uniq values in the tree? yes\\n        // is it binary tree or bst? binary\\n        // side of startValue ? left or right\\n        \\n        // time: O(n)\\n        // spae: O(h)\\n        TreeNode lca = lca(root, startValue, destValue);\\n        \\n        StringBuilder sb = new StringBuilder();\\n        // lca is start, traverse to destValue\\n        if(lca.val == startValue) {\\n            // traverse down\\n            \\n            traverse(lca, destValue, sb);\\n            return sb.toString();\\n        } \\n        \\n        // lca is destValue, traverse up from src\\n        // we can not traverse up from child to parent\\n        // path length from lca to secValue  == Up move length from src to lca\\n        else if(lca.val == destValue) {\\n            // traverse up\\n            sb = new StringBuilder();\\n            traverse(lca, startValue, sb);\\n            return \"U\".repeat(sb.length());\\n        } \\n        // get path to destValue from lca => path2\\n        // get path to srcValue from lca => path1\\n        // final path => Up move from path1 + path2\\n        else {\\n            // get path to destValue from lca\\n            sb = new StringBuilder();\\n            traverse(lca, destValue, sb);\\n            String path2 = sb.toString();\\n            \\n            sb = new StringBuilder();\\n            traverse(lca, startValue, sb);\\n            String path1 = sb.toString();\\n            \\n            sb = new StringBuilder();\\n            sb.append(\"U\".repeat(path1.length()));\\n            sb.append(path2);\\n            \\n            return sb.toString();\\n        }\\n    }\\n    private boolean traverse(TreeNode root, int toNode, StringBuilder sb) {\\n        if(root == null)\\n            return false;\\n        \\n        if(root.val == toNode)\\n            return true;\\n        \\n        sb.append(\"R\");\\n        if(traverse(root.right, toNode, sb))\\n            return true;\\n        sb.deleteCharAt(sb.length()-1);\\n        \\n        sb.append(\"L\");\\n        if(traverse(root.left, toNode, sb))\\n            return true;\\n        sb.deleteCharAt(sb.length()-1);\\n        \\n        return false;\\n    }\\n    private TreeNode lca(TreeNode root, int p, int q) {\\n        if(root == null)\\n            return null;\\n        \\n        if(root.val == p || root.val == q) {\\n            return root;\\n        }\\n        \\n        TreeNode left = lca(root.left, p, q);\\n        TreeNode right = lca(root.right, p, q);\\n        \\n        if(left != null && right != null) {\\n            return root;\\n        }\\n        \\n        return left == null ? right : left;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Depth-First Search"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public String getDirections(TreeNode root, int startValue, int destValue) {\\n        // do we have uniq values in the tree? yes\\n        // is it binary tree or bst? binary\\n        // side of startValue ? left or right\\n        \\n        // time: O(n)\\n        // spae: O(h)\\n        TreeNode lca = lca(root, startValue, destValue);\\n        \\n        StringBuilder sb = new StringBuilder();\\n        // lca is start, traverse to destValue\\n        if(lca.val == startValue) {\\n            // traverse down\\n            \\n            traverse(lca, destValue, sb);\\n            return sb.toString();\\n        } \\n        \\n        // lca is destValue, traverse up from src\\n        // we can not traverse up from child to parent\\n        // path length from lca to secValue  == Up move length from src to lca\\n        else if(lca.val == destValue) {\\n            // traverse up\\n            sb = new StringBuilder();\\n            traverse(lca, startValue, sb);\\n            return \"U\".repeat(sb.length());\\n        } \\n        // get path to destValue from lca => path2\\n        // get path to srcValue from lca => path1\\n        // final path => Up move from path1 + path2\\n        else {\\n            // get path to destValue from lca\\n            sb = new StringBuilder();\\n            traverse(lca, destValue, sb);\\n            String path2 = sb.toString();\\n            \\n            sb = new StringBuilder();\\n            traverse(lca, startValue, sb);\\n            String path1 = sb.toString();\\n            \\n            sb = new StringBuilder();\\n            sb.append(\"U\".repeat(path1.length()));\\n            sb.append(path2);\\n            \\n            return sb.toString();\\n        }\\n    }\\n    private boolean traverse(TreeNode root, int toNode, StringBuilder sb) {\\n        if(root == null)\\n            return false;\\n        \\n        if(root.val == toNode)\\n            return true;\\n        \\n        sb.append(\"R\");\\n        if(traverse(root.right, toNode, sb))\\n            return true;\\n        sb.deleteCharAt(sb.length()-1);\\n        \\n        sb.append(\"L\");\\n        if(traverse(root.left, toNode, sb))\\n            return true;\\n        sb.deleteCharAt(sb.length()-1);\\n        \\n        return false;\\n    }\\n    private TreeNode lca(TreeNode root, int p, int q) {\\n        if(root == null)\\n            return null;\\n        \\n        if(root.val == p || root.val == q) {\\n            return root;\\n        }\\n        \\n        TreeNode left = lca(root.left, p, q);\\n        TreeNode right = lca(root.right, p, q);\\n        \\n        if(left != null && right != null) {\\n            return root;\\n        }\\n        \\n        return left == null ? right : left;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2229489,
                "title": "java-lowest-common-ancestor-dfs-approach-95-time-complexity",
                "content": "```\\nclass Solution {\\n    StringBuilder startSb;\\n    StringBuilder endSb;\\n    public String getDirections(TreeNode root, int startValue, int destValue) {\\n        startSb = new StringBuilder();\\n        endSb = new StringBuilder();\\n        TreeNode ancestor = getLowestCommonAncestor(root, startValue, destValue);\\n        findPath(ancestor, startValue, true);\\n        findPath(ancestor, destValue, false);\\n        return startSb.append(endSb.reverse().toString()).toString();\\n    }\\n    public TreeNode findPath(TreeNode ancestor, int value, boolean findStartNode){\\n        if(ancestor == null || ancestor.val == value){\\n            return ancestor;\\n        }\\n        TreeNode left = findPath(ancestor.left, value, findStartNode);\\n        TreeNode right = findPath(ancestor.right, value, findStartNode);\\n        \\n    \\n        if(left != null){\\n            if(findStartNode){\\n                startSb.append(\\'U\\');\\n            }else{\\n                endSb.append(\\'L\\');\\n            }\\n            return left;\\n        }\\n        if(right != null){\\n             if(findStartNode){\\n                startSb.append(\\'U\\');\\n            }else{\\n                endSb.append(\\'R\\');\\n            }\\n            return right;\\n        }\\n        return null;\\n        \\n    }\\n    public TreeNode getLowestCommonAncestor(TreeNode root, int startValue, int destValue){\\n        \\n        if(root == null || root.val == startValue || root.val == destValue){\\n            return root;\\n        }\\n        TreeNode left = getLowestCommonAncestor(root.left, startValue, destValue);\\n        TreeNode right = getLowestCommonAncestor(root.right, startValue, destValue);\\n        \\n        if(left != null && right != null){\\n            return root;\\n        }\\n        if(left != null){\\n            return left;\\n        }\\n        if(right != null){\\n            return right;\\n        }\\n        return null;\\n\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    StringBuilder startSb;\\n    StringBuilder endSb;\\n    public String getDirections(TreeNode root, int startValue, int destValue) {\\n        startSb = new StringBuilder();\\n        endSb = new StringBuilder();\\n        TreeNode ancestor = getLowestCommonAncestor(root, startValue, destValue);\\n        findPath(ancestor, startValue, true);\\n        findPath(ancestor, destValue, false);\\n        return startSb.append(endSb.reverse().toString()).toString();\\n    }\\n    public TreeNode findPath(TreeNode ancestor, int value, boolean findStartNode){\\n        if(ancestor == null || ancestor.val == value){\\n            return ancestor;\\n        }\\n        TreeNode left = findPath(ancestor.left, value, findStartNode);\\n        TreeNode right = findPath(ancestor.right, value, findStartNode);\\n        \\n    \\n        if(left != null){\\n            if(findStartNode){\\n                startSb.append(\\'U\\');\\n            }else{\\n                endSb.append(\\'L\\');\\n            }\\n            return left;\\n        }\\n        if(right != null){\\n             if(findStartNode){\\n                startSb.append(\\'U\\');\\n            }else{\\n                endSb.append(\\'R\\');\\n            }\\n            return right;\\n        }\\n        return null;\\n        \\n    }\\n    public TreeNode getLowestCommonAncestor(TreeNode root, int startValue, int destValue){\\n        \\n        if(root == null || root.val == startValue || root.val == destValue){\\n            return root;\\n        }\\n        TreeNode left = getLowestCommonAncestor(root.left, startValue, destValue);\\n        TreeNode right = getLowestCommonAncestor(root.right, startValue, destValue);\\n        \\n        if(left != null && right != null){\\n            return root;\\n        }\\n        if(left != null){\\n            return left;\\n        }\\n        if(right != null){\\n            return right;\\n        }\\n        return null;\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2224238,
                "title": "simple-iterative-solution-pre-order-with-explanation-and-comments",
                "content": "1. Pick both paths to start and destination\\n2. Remove the longest prefix from both paths\\n3. Replace the whole left branch with \\'U\\'s \\n\\n```\\nclass Solution:\\n    def find_path(self, node, src_val, dest_val):\\n        # To handle pre-order iterative\\n        stack = []\\n        stack.append((node, \"\"))\\n        # Tracking the path to both start and destination\\n        src_path = dest_path = \"\"\\n        \\n        while stack:\\n            node, path = stack.pop()\\n            \\n            if node.val == src_val:\\n                src_path = path\\n            if node.val == dest_val:\\n                dest_path = path\\n            \\n            # Tracking the both paths at the same time\\n            if node.right:\\n                stack.append((node.right, path+\"R\"))\\n            if node.left:\\n                stack.append((node.left, path+\"L\"))\\n            \\n        return src_path, dest_path\\n        \\n    def getDirections(self, root: Optional[TreeNode], startValue: int, destValue: int) -> str:\\n        path_s, path_d = self.find_path(root, startValue, destValue)\\n        \\n        i = j = 0\\n        while i < len(path_s) and j < len(path_d):\\n            if path_s[i] != path_d[j]:\\n                break\\n            i += 1\\n            j += 1\\n        \\n        return \\'U\\' * len(path_s[i:]) + path_d[j:]\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "String",
                    "Tree"
                ],
                "code": "```\\nclass Solution:\\n    def find_path(self, node, src_val, dest_val):\\n        # To handle pre-order iterative\\n        stack = []\\n        stack.append((node, \"\"))\\n        # Tracking the path to both start and destination\\n        src_path = dest_path = \"\"\\n        \\n        while stack:\\n            node, path = stack.pop()\\n            \\n            if node.val == src_val:\\n                src_path = path\\n            if node.val == dest_val:\\n                dest_path = path\\n            \\n            # Tracking the both paths at the same time\\n            if node.right:\\n                stack.append((node.right, path+\"R\"))\\n            if node.left:\\n                stack.append((node.left, path+\"L\"))\\n            \\n        return src_path, dest_path\\n        \\n    def getDirections(self, root: Optional[TreeNode], startValue: int, destValue: int) -> str:\\n        path_s, path_d = self.find_path(root, startValue, destValue)\\n        \\n        i = j = 0\\n        while i < len(path_s) and j < len(path_d):\\n            if path_s[i] != path_d[j]:\\n                break\\n            i += 1\\n            j += 1\\n        \\n        return \\'U\\' * len(path_s[i:]) + path_d[j:]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2211672,
                "title": "c-tree-dfs-prefix-matching",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    \\n    bool dfs(TreeNode *root, int val, string &s) {\\n        if(root == NULL) return false;\\n        if(root->val == val) {\\n            return true;\\n        }\\n        if(dfs(root->left, val, s)) {\\n            s.push_back(\\'L\\');\\n            return true;\\n        }\\n        if(dfs(root->right, val, s)) {\\n            s.push_back(\\'R\\');\\n            return true;\\n        }\\n        return false;\\n    }\\n    \\n    string getDirections(TreeNode* root, int startValue, int destValue) {\\n        string s1 = \"\", s2 = \"\";\\n        dfs(root, startValue, s1);\\n        dfs(root, destValue, s2);\\n        reverse(s1.begin(), s1.end());\\n        reverse(s2.begin(), s2.end());\\n        int i = 0;\\n        int n = s1.size(), m = s2.size();\\n        while(i < min(n, m) && s1[i] == s2[i]) {\\n            i++;\\n        }\\n        string ans = \"\";\\n        for(int j = i; j < n; j++) {\\n            ans += \\'U\\';\\n        }\\n        for(int j = i; j < m; j++) {\\n            ans += s2[j];\\n        }\\n\\n        return ans;\\n    }\\n};\\n\\n\\n----------------------------------------------------------------------\\n\\n// 2nd approach\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n\\n    string rootToNode(TreeNode *root, int &node) {\\n        if(root == NULL) {\\n            return \"\";\\n        }\\n        if(root->val == node) {\\n            return \"*\";\\n        }\\n        string left = rootToNode(root->left, node);\\n        if(left != \"\") {\\n            return \\'L\\' + left;\\n        }\\n        string right = rootToNode(root->right, node);\\n        if(right != \"\") {\\n            return \\'R\\' + right;\\n        }\\n        return \"\";\\n    }\\n\\n    string getDirections(TreeNode* root, int startValue, int destValue) {\\n        string startPath = rootToNode(root, startValue);\\n        string destPath = rootToNode(root, destValue);\\n        int idx = 0;\\n        int n = startPath.size(), m = destPath.size();\\n        while(idx < min(n, m) && startPath[idx] == destPath[idx]) {\\n            idx++;\\n        }\\n        // cout << startPath << \" - \" << destPath << endl;\\n        string ans = \"\";\\n        for(int i = idx; i < n; i++) {\\n            char c = startPath[i];\\n            if(c == \\'*\\') break; \\n            ans += \"U\";\\n        }\\n        for(int i = idx; i < m; i++) {\\n            char c = destPath[i];\\n            if(c == \\'*\\') break;\\n            ans += c;\\n        }\\n        return ans;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    \\n    bool dfs(TreeNode *root, int val, string &s) {\\n        if(root == NULL) return false;\\n        if(root->val == val) {\\n            return true;\\n        }\\n        if(dfs(root->left, val, s)) {\\n            s.push_back(\\'L\\');\\n            return true;\\n        }\\n        if(dfs(root->right, val, s)) {\\n            s.push_back(\\'R\\');\\n            return true;\\n        }\\n        return false;\\n    }\\n    \\n    string getDirections(TreeNode* root, int startValue, int destValue) {\\n        string s1 = \"\", s2 = \"\";\\n        dfs(root, startValue, s1);\\n        dfs(root, destValue, s2);\\n        reverse(s1.begin(), s1.end());\\n        reverse(s2.begin(), s2.end());\\n        int i = 0;\\n        int n = s1.size(), m = s2.size();\\n        while(i < min(n, m) && s1[i] == s2[i]) {\\n            i++;\\n        }\\n        string ans = \"\";\\n        for(int j = i; j < n; j++) {\\n            ans += \\'U\\';\\n        }\\n        for(int j = i; j < m; j++) {\\n            ans += s2[j];\\n        }\\n\\n        return ans;\\n    }\\n};\\n\\n\\n----------------------------------------------------------------------\\n\\n// 2nd approach\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n\\n    string rootToNode(TreeNode *root, int &node) {\\n        if(root == NULL) {\\n            return \"\";\\n        }\\n        if(root->val == node) {\\n            return \"*\";\\n        }\\n        string left = rootToNode(root->left, node);\\n        if(left != \"\") {\\n            return \\'L\\' + left;\\n        }\\n        string right = rootToNode(root->right, node);\\n        if(right != \"\") {\\n            return \\'R\\' + right;\\n        }\\n        return \"\";\\n    }\\n\\n    string getDirections(TreeNode* root, int startValue, int destValue) {\\n        string startPath = rootToNode(root, startValue);\\n        string destPath = rootToNode(root, destValue);\\n        int idx = 0;\\n        int n = startPath.size(), m = destPath.size();\\n        while(idx < min(n, m) && startPath[idx] == destPath[idx]) {\\n            idx++;\\n        }\\n        // cout << startPath << \" - \" << destPath << endl;\\n        string ans = \"\";\\n        for(int i = idx; i < n; i++) {\\n            char c = startPath[i];\\n            if(c == \\'*\\') break; \\n            ans += \"U\";\\n        }\\n        for(int i = idx; i < m; i++) {\\n            char c = destPath[i];\\n            if(c == \\'*\\') break;\\n            ans += c;\\n        }\\n        return ans;\\n    }\\n};\\n\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2184488,
                "title": "c-simple-step-by-step-explanation-lca",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    // Function to find a node\\n    bool find(TreeNode* root, int a){\\n        if(!root) return false;\\n        if(root->val==a) return true;\\n        \\n        return find(root->left, a) or find(root->right, a);\\n    }\\n    \\n    // Function to find Lowest Common Ancestor of two nodes\\n    TreeNode* lca(TreeNode* root, int a, int b){\\n        if(root->val==a or root->val==b) return root;\\n        if((find(root->left, a) and find(root->right, b)) or (find(root->right, a) and find(root->left, b))) return root;\\n        \\n        if(find(root->left, a) and find(root->left, b)) return lca(root->left, a, b);\\n        return lca(root->right, a, b);\\n    }\\n    \\n    // Function to find the path of a node\\n    bool dfs(TreeNode* root, int value, string &ans){\\n        if(!root) return false;\\n        if(root->val==value){\\n            return true;\\n        }\\n        bool l = dfs(root->left, value, ans);\\n        bool r = dfs(root->right, value, ans);\\n        \\n        if(l){\\n            ans+=\\'L\\';\\n            return true;\\n        }if(r){\\n            ans+=\\'R\\';\\n            return true;\\n        }\\n        return false;\\n    }\\n    \\n    // Function to find the height and store it as a sequence of ups (U)\\n    bool findHeight(TreeNode* root, int value, string &height){\\n        if(!root) return false;\\n        if(root->val==value){\\n            return true;\\n        }\\n        bool l = findHeight(root->left, value, height);\\n        bool r = findHeight(root->right, value, height);\\n        \\n        if(l){\\n            height+=\\'U\\';\\n            return true;\\n        }if(r){\\n            height+=\\'U\\';\\n            return true;\\n        }\\n        return false;\\n    }\\n    \\n    string getDirections(TreeNode* root, int startValue, int destValue) {\\n        TreeNode* node = lca(root, startValue, destValue);\\n        \\n        // Case 1: lca == startValue, Find the path destValue in left or right subtree\\n        // Case 2: lca == destValue, String will be all UPS (height of startValue)\\n        // Case 3: startValue in left subtree and destValue in right subtree of lca, UPS (Height of startValue) + path to destValue in right subtree\\n        // Case 4: startValue in right subtree and destValue in left subtree of lca, UPS (Height of startValue) + path to destValue in left subtree\\n        \\n        // Case 1\\n        if(node->val==startValue){\\n            string ans=\"\";\\n            bool p = dfs(node, destValue, ans);\\n            reverse(ans.begin(), ans.end());\\n            return ans;\\n        }\\n        \\n        // Case 2\\n        if(node->val==destValue){\\n            string height=\"\";\\n            bool p = findHeight(node, startValue, height);\\n            return height;\\n        }\\n        \\n        // Case 3\\n        if(find(node->left, startValue) and find(node->right, destValue)){\\n            //cout<<\"1\";\\n            string height=\"\", path=\"\";\\n            bool a = findHeight(node, startValue, height);\\n            bool b = dfs(node->right, destValue, path);\\n            reverse(path.begin(), path.end());\\n            return height+\\'R\\'+path;\\n        }\\n        \\n        // Case 4\\n        if(find(node->right, startValue) and find(node->left, destValue)){\\n            string height=\"\", path=\"\";\\n            bool a = findHeight(node, startValue, height);\\n            bool b = dfs(node->left, destValue, path);\\n            reverse(path.begin(), path.end());\\n            return height+\\'L\\'+path;\\n        }\\n        \\n        return \"\";\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    // Function to find a node\\n    bool find(TreeNode* root, int a){\\n        if(!root) return false;\\n        if(root->val==a) return true;\\n        \\n        return find(root->left, a) or find(root->right, a);\\n    }\\n    \\n    // Function to find Lowest Common Ancestor of two nodes\\n    TreeNode* lca(TreeNode* root, int a, int b){\\n        if(root->val==a or root->val==b) return root;\\n        if((find(root->left, a) and find(root->right, b)) or (find(root->right, a) and find(root->left, b))) return root;\\n        \\n        if(find(root->left, a) and find(root->left, b)) return lca(root->left, a, b);\\n        return lca(root->right, a, b);\\n    }\\n    \\n    // Function to find the path of a node\\n    bool dfs(TreeNode* root, int value, string &ans){\\n        if(!root) return false;\\n        if(root->val==value){\\n            return true;\\n        }\\n        bool l = dfs(root->left, value, ans);\\n        bool r = dfs(root->right, value, ans);\\n        \\n        if(l){\\n            ans+=\\'L\\';\\n            return true;\\n        }if(r){\\n            ans+=\\'R\\';\\n            return true;\\n        }\\n        return false;\\n    }\\n    \\n    // Function to find the height and store it as a sequence of ups (U)\\n    bool findHeight(TreeNode* root, int value, string &height){\\n        if(!root) return false;\\n        if(root->val==value){\\n            return true;\\n        }\\n        bool l = findHeight(root->left, value, height);\\n        bool r = findHeight(root->right, value, height);\\n        \\n        if(l){\\n            height+=\\'U\\';\\n            return true;\\n        }if(r){\\n            height+=\\'U\\';\\n            return true;\\n        }\\n        return false;\\n    }\\n    \\n    string getDirections(TreeNode* root, int startValue, int destValue) {\\n        TreeNode* node = lca(root, startValue, destValue);\\n        \\n        // Case 1: lca == startValue, Find the path destValue in left or right subtree\\n        // Case 2: lca == destValue, String will be all UPS (height of startValue)\\n        // Case 3: startValue in left subtree and destValue in right subtree of lca, UPS (Height of startValue) + path to destValue in right subtree\\n        // Case 4: startValue in right subtree and destValue in left subtree of lca, UPS (Height of startValue) + path to destValue in left subtree\\n        \\n        // Case 1\\n        if(node->val==startValue){\\n            string ans=\"\";\\n            bool p = dfs(node, destValue, ans);\\n            reverse(ans.begin(), ans.end());\\n            return ans;\\n        }\\n        \\n        // Case 2\\n        if(node->val==destValue){\\n            string height=\"\";\\n            bool p = findHeight(node, startValue, height);\\n            return height;\\n        }\\n        \\n        // Case 3\\n        if(find(node->left, startValue) and find(node->right, destValue)){\\n            //cout<<\"1\";\\n            string height=\"\", path=\"\";\\n            bool a = findHeight(node, startValue, height);\\n            bool b = dfs(node->right, destValue, path);\\n            reverse(path.begin(), path.end());\\n            return height+\\'R\\'+path;\\n        }\\n        \\n        // Case 4\\n        if(find(node->right, startValue) and find(node->left, destValue)){\\n            string height=\"\", path=\"\";\\n            bool a = findHeight(node, startValue, height);\\n            bool b = dfs(node->left, destValue, path);\\n            reverse(path.begin(), path.end());\\n            return height+\\'L\\'+path;\\n        }\\n        \\n        return \"\";\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2174969,
                "title": "easy-working-solution-memory-97-time-30",
                "content": "First find LCA using DFS...\\nThen find paths from LCA to startValue and LCA to DestValue using BFS..\\nSince this problem mainly focuses on memory constraint...therefore iterative approach is better than recursive approach...\\n\\n```\\nclass Solution:\\n    def getDirections(self, root: Optional[TreeNode], startValue: int, destValue: int) -> str:\\n        def dfs(root):\\n            if not root:\\n                return None\\n            if root.val == startValue:\\n                return root\\n            if root.val == destValue:\\n                return root\\n            l = dfs(root.left)\\n            r = dfs(root.right)\\n            if l and r:\\n                return root\\n            return l or r\\n        \\n        lca = dfs(root)\\n        self.pathToSrc = \"\"\\n        self.pathToDest = \"\"\\n        \\n        def LCAtoSrcAndDest(root):\\n            queue = deque()\\n            queue.append([root,\"\"])\\n            while queue:\\n                for i in range(len(queue)):\\n                    node,path = queue.popleft()\\n                    if node.val == destValue:\\n                        self.pathToDest = path\\n                    if node.val == startValue:\\n                        self.pathToSrc = path\\n                    if self.pathToSrc and self.pathToDest:\\n                        return\\n                    if node.left:\\n                        queue.append([node.left,path+\"L\"])\\n                    if node.right:\\n                        queue.append([node.right,path+\"R\"])\\n                    \\n                    \\n        LCAtoSrcAndDest(lca)\\n        if lca.val != startValue and lca.val != destValue:\\n            return \"U\"*(len(self.pathToSrc)) + self.pathToDest\\n        \\n        if lca.val == startValue:\\n            return self.pathToDest\\n        \\n        if lca.val == destValue:\\n            return \"U\"*(len(self.pathToSrc))\\n        \\n```",
                "solutionTags": [
                    "Depth-First Search",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def getDirections(self, root: Optional[TreeNode], startValue: int, destValue: int) -> str:\\n        def dfs(root):\\n            if not root:\\n                return None\\n            if root.val == startValue:\\n                return root\\n            if root.val == destValue:\\n                return root\\n            l = dfs(root.left)\\n            r = dfs(root.right)\\n            if l and r:\\n                return root\\n            return l or r\\n        \\n        lca = dfs(root)\\n        self.pathToSrc = \"\"\\n        self.pathToDest = \"\"\\n        \\n        def LCAtoSrcAndDest(root):\\n            queue = deque()\\n            queue.append([root,\"\"])\\n            while queue:\\n                for i in range(len(queue)):\\n                    node,path = queue.popleft()\\n                    if node.val == destValue:\\n                        self.pathToDest = path\\n                    if node.val == startValue:\\n                        self.pathToSrc = path\\n                    if self.pathToSrc and self.pathToDest:\\n                        return\\n                    if node.left:\\n                        queue.append([node.left,path+\"L\"])\\n                    if node.right:\\n                        queue.append([node.right,path+\"R\"])\\n                    \\n                    \\n        LCAtoSrcAndDest(lca)\\n        if lca.val != startValue and lca.val != destValue:\\n            return \"U\"*(len(self.pathToSrc)) + self.pathToDest\\n        \\n        if lca.val == startValue:\\n            return self.pathToDest\\n        \\n        if lca.val == destValue:\\n            return \"U\"*(len(self.pathToSrc))\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2098864,
                "title": "swift-solution-3-steps-by-votrubac",
                "content": "LeetCoder named Votrubac introduced the following solution to this problem. I re-write it in Swift language and it\\'s 95% fast.\\n\\nThank you.\\n\\nStep 1: \\nBuild directions for both start and destination from the root.\\nSay we get \"LLRRL\" and \"LRR\".\\n\\nStep 2:\\nRemove common prefix path.\\nWe remove \"L\", and now start direction is \"LRRL\", and destination - \"RR\"\\n\\nStep 3:\\nReplace all steps in the start direction to \"U\" and add destination direction.\\nThe result is \"UUUU\" + \"RR\".\\n\\n```\\nclass Solution {\\n    func getDirections(_ root: TreeNode?, _ startValue: Int, _ destValue: Int) -> String {\\n        var s = [Character](), d = [Character]()\\n        find(root!, startValue, &s)\\n        find(root!, destValue, &d)\\n        var i = 0, maxLength = min(s.count, d.count)\\n        while i < maxLength && s[s.count - i - 1] == d[d.count - i - 1] {\\n            i += 1\\n        }\\n        //print(\"\\\\(s),\\\\(d),\\\\(i)\")\\n        let left = Array(repeating: Character(\"U\"), count: s.count - i)\\n        let right = Array(d[0..<d.count-i]).reversed()\\n        return String(left) + String(right)\\n    }\\n    \\n    func find(_ node: TreeNode, _ val: Int, _ stringBuilder: inout [Character]) -> Bool {\\n        if node.val == val {\\n            return true\\n        }\\n        if node.left != nil && find(node.left!, val, &stringBuilder) {\\n            stringBuilder.append(Character(\"L\"))\\n        } else if node.right != nil && find(node.right!, val, &stringBuilder) {\\n            stringBuilder.append(Character(\"R\"))\\n        }\\n        return stringBuilder.isEmpty == false\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func getDirections(_ root: TreeNode?, _ startValue: Int, _ destValue: Int) -> String {\\n        var s = [Character](), d = [Character]()\\n        find(root!, startValue, &s)\\n        find(root!, destValue, &d)\\n        var i = 0, maxLength = min(s.count, d.count)\\n        while i < maxLength && s[s.count - i - 1] == d[d.count - i - 1] {\\n            i += 1\\n        }\\n        //print(\"\\\\(s),\\\\(d),\\\\(i)\")\\n        let left = Array(repeating: Character(\"U\"), count: s.count - i)\\n        let right = Array(d[0..<d.count-i]).reversed()\\n        return String(left) + String(right)\\n    }\\n    \\n    func find(_ node: TreeNode, _ val: Int, _ stringBuilder: inout [Character]) -> Bool {\\n        if node.val == val {\\n            return true\\n        }\\n        if node.left != nil && find(node.left!, val, &stringBuilder) {\\n            stringBuilder.append(Character(\"L\"))\\n        } else if node.right != nil && find(node.right!, val, &stringBuilder) {\\n            stringBuilder.append(Character(\"R\"))\\n        }\\n        return stringBuilder.isEmpty == false\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2091268,
                "title": "faster-easy-to-understand-c-code",
                "content": "* ***Using LCA***\\n\\n* ***Time Complexity : O(N)***\\n\\n* ***Space Complexity : O(height of tree)***\\n\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    \\n    // find LCA (lowest common ancestor)\\n    \\n    TreeNode* LCA(TreeNode* root, int p, int q)\\n    {\\n        if(root == NULL)\\n            return NULL;\\n        \\n        if(root -> val == p || root -> val == q)\\n            return root;\\n        \\n        TreeNode* left_subtree = LCA(root -> left, p, q);\\n        \\n        TreeNode* right_subtree = LCA(root -> right, p, q);\\n        \\n        if(left_subtree != NULL && right_subtree != NULL)\\n            return root;\\n        \\n        if(left_subtree == NULL)\\n            return right_subtree;\\n        \\n        else\\n            return left_subtree;\\n    }\\n    \\n    // find the path from the root to target node\\n    \\n    bool find_path(TreeNode* root, int target, string &path)\\n    {\\n        if(root == NULL)\\n            return NULL;\\n        \\n        if(root -> val == target)\\n            return true;\\n        \\n        bool left_subtree = find_path(root -> left, target, path);\\n        \\n        if(left_subtree)\\n        {\\n            path += \\'L\\';\\n            \\n            return true;\\n        }\\n        \\n        bool right_subtree = find_path(root -> right, target, path);\\n        \\n        if(right_subtree)\\n        {\\n            path += \\'R\\';\\n            \\n            return true;\\n        }\\n        \\n        return false;\\n    }\\n    \\n    string getDirections(TreeNode* root, int startValue, int destValue) {\\n        \\n        TreeNode* lca = LCA(root, startValue, destValue);\\n        \\n        cout << lca -> val << endl;\\n        \\n        string path1 = \"\";\\n        \\n        find_path(lca, startValue, path1);\\n        \\n        string path2 = \"\";\\n        \\n        find_path(lca, destValue, path2);\\n        \\n        reverse(path2.begin(), path2.end());\\n        \\n        // replace the character of path1 with \\'U\\'\\n        \\n        for(int i = 0; i < path1.size(); i++)\\n        {\\n            path1[i] = \\'U\\';\\n        }\\n        \\n        return path1 + path2;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    \\n    // find LCA (lowest common ancestor)\\n    \\n    TreeNode* LCA(TreeNode* root, int p, int q)\\n    {\\n        if(root == NULL)\\n            return NULL;\\n        \\n        if(root -> val == p || root -> val == q)\\n            return root;\\n        \\n        TreeNode* left_subtree = LCA(root -> left, p, q);\\n        \\n        TreeNode* right_subtree = LCA(root -> right, p, q);\\n        \\n        if(left_subtree != NULL && right_subtree != NULL)\\n            return root;\\n        \\n        if(left_subtree == NULL)\\n            return right_subtree;\\n        \\n        else\\n            return left_subtree;\\n    }\\n    \\n    // find the path from the root to target node\\n    \\n    bool find_path(TreeNode* root, int target, string &path)\\n    {\\n        if(root == NULL)\\n            return NULL;\\n        \\n        if(root -> val == target)\\n            return true;\\n        \\n        bool left_subtree = find_path(root -> left, target, path);\\n        \\n        if(left_subtree)\\n        {\\n            path += \\'L\\';\\n            \\n            return true;\\n        }\\n        \\n        bool right_subtree = find_path(root -> right, target, path);\\n        \\n        if(right_subtree)\\n        {\\n            path += \\'R\\';\\n            \\n            return true;\\n        }\\n        \\n        return false;\\n    }\\n    \\n    string getDirections(TreeNode* root, int startValue, int destValue) {\\n        \\n        TreeNode* lca = LCA(root, startValue, destValue);\\n        \\n        cout << lca -> val << endl;\\n        \\n        string path1 = \"\";\\n        \\n        find_path(lca, startValue, path1);\\n        \\n        string path2 = \"\";\\n        \\n        find_path(lca, destValue, path2);\\n        \\n        reverse(path2.begin(), path2.end());\\n        \\n        // replace the character of path1 with \\'U\\'\\n        \\n        for(int i = 0; i < path1.size(); i++)\\n        {\\n            path1[i] = \\'U\\';\\n        }\\n        \\n        return path1 + path2;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2065266,
                "title": "python-two-dfs-traversals",
                "content": "```\\nclass Solution:\\n    def getDirections(self, root: Optional[TreeNode], startValue: int, destValue: int) -> str:\\n        def buildAdjacencyList(node):\\n            if not node:\\n                return\\n            \\n            if node.left:\\n                adj[node.val].append((node.left.val, \\'L\\'))\\n                adj[node.left.val].append((node.val, \\'U\\'))\\n                buildAdjacencyList(node.left)\\n                \\n            if node.right:\\n                adj[node.val].append((node.right.val, \\'R\\'))            \\n                adj[node.right.val].append((node.val, \\'U\\'))\\n                buildAdjacencyList(node.right)\\n\\n                \\n        def findNode(value, prior, path):\\n            if value == destValue:\\n                return True\\n                \\n            for next_value, char in adj[value]:\\n                if next_value != prior:               \\n                    if findNode(next_value, value, path):\\n                        path.append(char)                        \\n                        return True\\n                \\n            return False\\n                    \\n        adj = defaultdict(list)            \\n        buildAdjacencyList(root)\\n\\n        path = []\\n        findNode(startValue, -1, path)\\n        \\n        return \"\".join(reversed(path))\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def getDirections(self, root: Optional[TreeNode], startValue: int, destValue: int) -> str:\\n        def buildAdjacencyList(node):\\n            if not node:\\n                return\\n            \\n            if node.left:\\n                adj[node.val].append((node.left.val, \\'L\\'))\\n                adj[node.left.val].append((node.val, \\'U\\'))\\n                buildAdjacencyList(node.left)\\n                \\n            if node.right:\\n                adj[node.val].append((node.right.val, \\'R\\'))            \\n                adj[node.right.val].append((node.val, \\'U\\'))\\n                buildAdjacencyList(node.right)\\n\\n                \\n        def findNode(value, prior, path):\\n            if value == destValue:\\n                return True\\n                \\n            for next_value, char in adj[value]:\\n                if next_value != prior:               \\n                    if findNode(next_value, value, path):\\n                        path.append(char)                        \\n                        return True\\n                \\n            return False\\n                    \\n        adj = defaultdict(list)            \\n        buildAdjacencyList(root)\\n\\n        path = []\\n        findNode(startValue, -1, path)\\n        \\n        return \"\".join(reversed(path))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2052309,
                "title": "python3-dfs-simple-solution-52-fast-30-memory",
                "content": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\n\\n\\nclass Solution:\\n    def getDirections(self, root: Optional[TreeNode], startValue: int, destValue: int) -> str:\\n        pD = [] \\n        pS = [] \\n        path = []\\n        \\n        def dfs(n: Optional[TreeNode]) -> str:\\n            nonlocal pD, pS, path\\n            if n is None:\\n                return None\\n            if n.val == startValue:\\n                pS[:] = path\\n            if n.val == destValue:\\n                pD[:] = path\\n            path.append(\\'L\\')    \\n            dfs(n.left)\\n            path.pop()\\n            path.append(\\'R\\')    \\n            dfs(n.right)\\n            path.pop()\\n        dfs(root)\\n        \\n        for i in range(max(len(pS), len(pD))):\\n            if i >= len(pS):\\n                return \\'\\'.join(pD[i:])\\n            if i >= len(pD):\\n                return \\'\\'.join([\\'U\\'] * (len(pS) - i)) \\n            if pS[i] != pD[i]:\\n                return \\'\\'.join([\\'U\\'] * (len(pS) - i) + list(pD[i:]))\\n\\t\\t\\t\\t```",
                "solutionTags": [],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\n\\n\\nclass Solution:\\n    def getDirections(self, root: Optional[TreeNode], startValue: int, destValue: int) -> str:\\n        pD = [] \\n        pS = [] \\n        path = []\\n        \\n        def dfs(n: Optional[TreeNode]) -> str:\\n            nonlocal pD, pS, path\\n            if n is None:\\n                return None\\n            if n.val == startValue:\\n                pS[:] = path\\n            if n.val == destValue:\\n                pD[:] = path\\n            path.append(\\'L\\')    \\n            dfs(n.left)\\n            path.pop()\\n            path.append(\\'R\\')    \\n            dfs(n.right)\\n            path.pop()\\n        dfs(root)\\n        \\n        for i in range(max(len(pS), len(pD))):\\n            if i >= len(pS):\\n                return \\'\\'.join(pD[i:])\\n            if i >= len(pD):\\n                return \\'\\'.join([\\'U\\'] * (len(pS) - i)) \\n            if pS[i] != pD[i]:\\n                return \\'\\'.join([\\'U\\'] * (len(pS) - i) + list(pD[i:]))\\n\\t\\t\\t\\t```",
                "codeTag": "Java"
            },
            {
                "id": 2020014,
                "title": "c-easysolution-with-commtents-using-lca-dfs-backtracking",
                "content": "```\\n/**\\n * @brief \\n * Give a direction string starting at Start Point to Dest Point in a tree.\\n * (We can see that going upper level do not have a to figure left or right.)\\n * \\n * @algo1 Finding LCA + DFS backtracking\\n *  Bottom down from root and find the start and end from LCA (least common ancestor)\\n *  (Using method as #236)\\n * \\n *  From LCA, DFS find both nodes and figure the direction by backtracking\\n *  1. To start point, count the steps by string length, replace it with \\'U\\'\\n *  2. To end point, filling the direction\\n * \\n *  Assume the tree is with N nodes\\n *  Time O(N)\\n *  Space O(N) recursion stack or stack space\\n */\\nclass Solution {\\n    string pathToStart;\\n    string pathToEnd;\\n    string tempPath;\\npublic:\\n    TreeNode* findLCA(TreeNode* currentNode, int p, int q) {\\n        if(currentNode == NULL || currentNode->val == p || currentNode->val == q) return currentNode;\\n\\n        TreeNode *leftSubTree = findLCA(currentNode->left, p, q);\\n        TreeNode *rightSubTree = findLCA(currentNode->right, p, q);\\n\\n        if(leftSubTree && rightSubTree) {\\n            // separate below currentNode\\n            return currentNode;\\n        }\\n        // same side, one node will be the LCA\\n        return leftSubTree != NULL ? leftSubTree : rightSubTree; \\n    }\\n\\n    void dfsBuildPath(TreeNode* current, int startValue, int destValue) {\\n        if(current == NULL) return;\\n        else if(current -> val == startValue) {\\n            // this recursion has reach start point -> lets reverse back with \\'U\\'\\n            for(int i=0; i<tempPath.length(); i++) {\\n                pathToStart += \\'U\\';\\n            }\\n            // continue to the bottom, do not return, not sure if we reach the another point\\n        }\\n        else if (current -> val == destValue) {\\n            // record the path from LCA to end\\n            pathToEnd = tempPath;\\n            // continue to the bottom, do not return, not sure if we reach the another point\\n        }\\n\\n        // unstop back track finding the nodes\\n        tempPath.push_back(\\'L\\');\\n        dfsBuildPath(current->left, startValue, destValue);\\n        tempPath.pop_back();\\n\\n        tempPath.push_back(\\'R\\');\\n        dfsBuildPath(current->right, startValue, destValue);\\n        tempPath.pop_back();\\n    }\\n\\n    string getDirections(TreeNode* root, int startValue, int destValue) {\\n        TreeNode* lcaNode = findLCA(root, startValue, destValue);\\n        // find both path independently from LCA, use string as a stack to build the path\\n        dfsBuildPath(lcaNode, startValue, destValue);\\n        return pathToStart + pathToEnd;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Backtracking",
                    "Depth-First Search"
                ],
                "code": "```\\n/**\\n * @brief \\n * Give a direction string starting at Start Point to Dest Point in a tree.\\n * (We can see that going upper level do not have a to figure left or right.)\\n * \\n * @algo1 Finding LCA + DFS backtracking\\n *  Bottom down from root and find the start and end from LCA (least common ancestor)\\n *  (Using method as #236)\\n * \\n *  From LCA, DFS find both nodes and figure the direction by backtracking\\n *  1. To start point, count the steps by string length, replace it with \\'U\\'\\n *  2. To end point, filling the direction\\n * \\n *  Assume the tree is with N nodes\\n *  Time O(N)\\n *  Space O(N) recursion stack or stack space\\n */\\nclass Solution {\\n    string pathToStart;\\n    string pathToEnd;\\n    string tempPath;\\npublic:\\n    TreeNode* findLCA(TreeNode* currentNode, int p, int q) {\\n        if(currentNode == NULL || currentNode->val == p || currentNode->val == q) return currentNode;\\n\\n        TreeNode *leftSubTree = findLCA(currentNode->left, p, q);\\n        TreeNode *rightSubTree = findLCA(currentNode->right, p, q);\\n\\n        if(leftSubTree && rightSubTree) {\\n            // separate below currentNode\\n            return currentNode;\\n        }\\n        // same side, one node will be the LCA\\n        return leftSubTree != NULL ? leftSubTree : rightSubTree; \\n    }\\n\\n    void dfsBuildPath(TreeNode* current, int startValue, int destValue) {\\n        if(current == NULL) return;\\n        else if(current -> val == startValue) {\\n            // this recursion has reach start point -> lets reverse back with \\'U\\'\\n            for(int i=0; i<tempPath.length(); i++) {\\n                pathToStart += \\'U\\';\\n            }\\n            // continue to the bottom, do not return, not sure if we reach the another point\\n        }\\n        else if (current -> val == destValue) {\\n            // record the path from LCA to end\\n            pathToEnd = tempPath;\\n            // continue to the bottom, do not return, not sure if we reach the another point\\n        }\\n\\n        // unstop back track finding the nodes\\n        tempPath.push_back(\\'L\\');\\n        dfsBuildPath(current->left, startValue, destValue);\\n        tempPath.pop_back();\\n\\n        tempPath.push_back(\\'R\\');\\n        dfsBuildPath(current->right, startValue, destValue);\\n        tempPath.pop_back();\\n    }\\n\\n    string getDirections(TreeNode* root, int startValue, int destValue) {\\n        TreeNode* lcaNode = findLCA(root, startValue, destValue);\\n        // find both path independently from LCA, use string as a stack to build the path\\n        dfsBuildPath(lcaNode, startValue, destValue);\\n        return pathToStart + pathToEnd;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1993700,
                "title": "python-only-find-two-paths-and-done-o-n",
                "content": "# Give a vote. It motivates me ..\\n```\\nclass Solution:\\n    def getDirections(self, root: Optional[TreeNode], l: int, r: int) -> str:\\n        \\n        # 1st find paths from root to both the nodes \\n        \\n        fp , sp = [] , []\\n        self.call(root , fp , l)  # gives the path from root to 1st node\\n        self.call(root , sp , r)  # gives the path from root to 2nd node\\n        \\n        while fp and sp and  fp[-1] == sp[-1]:   # ** Remove the nodeswhich are common in both paths .**\\n            fp.pop()\\n            sp.pop()\\n        return \\'U\\'*(len(fp)) + \\'\\'.join(reversed(sp))\\n        \\n        \\n        \\n    def call(self , root , path , val):\\n        #if not root:\\n        #    return False\\n        if root.val == val:\\n            return True \\n        \\n        if root.left:\\n            #arr.append(\\'L\\')\\n            if self.call(root.left , path , val):\\n                path.append(\\'L\\')\\n                return True \\n            #path.pop()\\n        \\n        if root.right:\\n            #arr.append(\\'L\\')\\n            if self.call(root.right , path , val) : \\n                path.append(\\'R\\')\\n                return True \\n            #path.pop()\\n        \\n            \\n        \\n```\\n# Upvote if understood And feel free to ask if have any doubt .",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def getDirections(self, root: Optional[TreeNode], l: int, r: int) -> str:\\n        \\n        # 1st find paths from root to both the nodes \\n        \\n        fp , sp = [] , []\\n        self.call(root , fp , l)  # gives the path from root to 1st node\\n        self.call(root , sp , r)  # gives the path from root to 2nd node\\n        \\n        while fp and sp and  fp[-1] == sp[-1]:   # ** Remove the nodeswhich are common in both paths .**\\n            fp.pop()\\n            sp.pop()\\n        return \\'U\\'*(len(fp)) + \\'\\'.join(reversed(sp))\\n        \\n        \\n        \\n    def call(self , root , path , val):\\n        #if not root:\\n        #    return False\\n        if root.val == val:\\n            return True \\n        \\n        if root.left:\\n            #arr.append(\\'L\\')\\n            if self.call(root.left , path , val):\\n                path.append(\\'L\\')\\n                return True \\n            #path.pop()\\n        \\n        if root.right:\\n            #arr.append(\\'L\\')\\n            if self.call(root.right , path , val) : \\n                path.append(\\'R\\')\\n                return True \\n            #path.pop()\\n        \\n            \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1982342,
                "title": "c-lca-easy-to-understand-solution",
                "content": "```\\n/* \\n    Time: O(n)\\n    Space: O(h)\\n    Tag: Tree Traversal, LCA\\n    Difficulty: M\\n*/\\n\\nclass Solution {\\n    int start;\\n    int end;\\n\\n    string startPath;\\n    string destPath;\\n    TreeNode *findLCA(TreeNode *root) {\\n        if (!root) return NULL;\\n        if (root->val == start || root->val == end) return root;\\n        TreeNode *left = findLCA(root->left);\\n        TreeNode *right = findLCA(root->right);\\n        if (left != NULL && right != NULL)\\n            return root;\\n        else if (left)\\n            return left;\\n        return right;\\n    }\\n\\n    void findPath(TreeNode *root, string &path) {\\n        if (!root) return;\\n        if (root->val == start) {\\n            for (int i = 0; i < path.length(); i++) {\\n                startPath += \"U\";\\n            }\\n        } else if (root->val == end) {\\n            destPath = path;\\n        }\\n        path.push_back(\\'L\\');\\n        findPath(root->left, path);\\n        path.pop_back();\\n        path.push_back(\\'R\\');\\n        findPath(root->right, path);\\n        path.pop_back();\\n    }\\n\\npublic:\\n    string getDirections(TreeNode *root, int startValue, int destValue) {\\n        start = startValue;\\n        end = destValue;\\n        TreeNode *lca = findLCA(root);\\n        string path = \"\";\\n        findPath(lca, path);\\n        return startPath + destPath;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search",
                    "Binary Tree"
                ],
                "code": "```\\n/* \\n    Time: O(n)\\n    Space: O(h)\\n    Tag: Tree Traversal, LCA\\n    Difficulty: M\\n*/\\n\\nclass Solution {\\n    int start;\\n    int end;\\n\\n    string startPath;\\n    string destPath;\\n    TreeNode *findLCA(TreeNode *root) {\\n        if (!root) return NULL;\\n        if (root->val == start || root->val == end) return root;\\n        TreeNode *left = findLCA(root->left);\\n        TreeNode *right = findLCA(root->right);\\n        if (left != NULL && right != NULL)\\n            return root;\\n        else if (left)\\n            return left;\\n        return right;\\n    }\\n\\n    void findPath(TreeNode *root, string &path) {\\n        if (!root) return;\\n        if (root->val == start) {\\n            for (int i = 0; i < path.length(); i++) {\\n                startPath += \"U\";\\n            }\\n        } else if (root->val == end) {\\n            destPath = path;\\n        }\\n        path.push_back(\\'L\\');\\n        findPath(root->left, path);\\n        path.pop_back();\\n        path.push_back(\\'R\\');\\n        findPath(root->right, path);\\n        path.pop_back();\\n    }\\n\\npublic:\\n    string getDirections(TreeNode *root, int startValue, int destValue) {\\n        start = startValue;\\n        end = destValue;\\n        TreeNode *lca = findLCA(root);\\n        string path = \"\";\\n        findPath(lca, path);\\n        return startPath + destPath;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1899479,
                "title": "super-simple-java-o-n-with-tree-encoding",
                "content": "Super simple solution with tree encoding. For example 1, sCode = \"LL\" and dCode = \"RL\" and the result is \"UURL\" (just convert sCode to Us and concat to dCode but just from the first common ancestor)\\n\\t\\n\\t\\n\\t\\n\\tenum Direction{RIGHT, LEFT, NONE};\\n    \\n    public String getDirections(TreeNode root, int startValue, int destValue) {\\n\\t    int s=startValue, d=destValue;\\n        StringBuilder sCode = new StringBuilder();\\n        StringBuilder dCode = new StringBuilder();\\n        StringBuilder res = new StringBuilder();\\n        int i=0, j=0; \\n        \\n        hasPath(root, s, sCode, Direction.NONE);\\n        hasPath(root, d, dCode, Direction.NONE);\\n        \\n        //search the first common ancestor\\n        while(i<sCode.length() && i<dCode.length() && sCode.charAt(i) == dCode.charAt(i)){\\n            i++;\\n            j++;\\n        }\\n        \\n        while(i<sCode.length()){\\n            res.append(\"U\");\\n            i++;\\n        }\\n        \\n        while(j<dCode.length()){\\n            res.append(dCode.charAt(j));\\n            j++;\\n        }\\n        \\n        return res.toString();\\n    }\\n    \\n    private Boolean hasPath(TreeNode root, int val, StringBuilder code, Direction dir){\\n        if(root == null) return false;\\n        \\n        if(dir == Direction.RIGHT)\\n            code.append(\"R\");\\n        else if(dir == Direction.LEFT)\\n            code.append(\"L\");\\n        \\n        if(root.val == val) \\n\\t\\t\\treturn true;\\n        \\n        if(hasPath(root.left, val, code, Direction.LEFT) || hasPath(root.right, val, code, Direction.RIGHT)) \\n\\t\\t\\treturn true;\\n        \\n        code.deleteCharAt(code.length() - 1);\\n        return false;\\n    }",
                "solutionTags": [
                    "Java",
                    "Tree",
                    "Recursion"
                ],
                "code": "Super simple solution with tree encoding. For example 1, sCode = \"LL\" and dCode = \"RL\" and the result is \"UURL\" (just convert sCode to Us and concat to dCode but just from the first common ancestor)\\n\\t\\n\\t\\n\\t\\n\\tenum Direction{RIGHT, LEFT, NONE};\\n    \\n    public String getDirections(TreeNode root, int startValue, int destValue) {\\n\\t    int s=startValue, d=destValue;\\n        StringBuilder sCode = new StringBuilder();\\n        StringBuilder dCode = new StringBuilder();\\n        StringBuilder res = new StringBuilder();\\n        int i=0, j=0; \\n        \\n        hasPath(root, s, sCode, Direction.NONE);\\n        hasPath(root, d, dCode, Direction.NONE);\\n        \\n        //search the first common ancestor\\n        while(i<sCode.length() && i<dCode.length() && sCode.charAt(i) == dCode.charAt(i)){\\n            i++;\\n            j++;\\n        }\\n        \\n        while(i<sCode.length()){\\n            res.append(\"U\");\\n            i++;\\n        }\\n        \\n        while(j<dCode.length()){\\n            res.append(dCode.charAt(j));\\n            j++;\\n        }\\n        \\n        return res.toString();\\n    }\\n    \\n    private Boolean hasPath(TreeNode root, int val, StringBuilder code, Direction dir){\\n        if(root == null) return false;\\n        \\n        if(dir == Direction.RIGHT)\\n            code.append(\"R\");\\n        else if(dir == Direction.LEFT)\\n            code.append(\"L\");\\n        \\n        if(root.val == val) \\n\\t\\t\\treturn true;\\n        \\n        if(hasPath(root.left, val, code, Direction.LEFT) || hasPath(root.right, val, code, Direction.RIGHT)) \\n\\t\\t\\treturn true;\\n        \\n        code.deleteCharAt(code.length() - 1);\\n        return false;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1898197,
                "title": "c-3-dfs-lca-path-recover",
                "content": "Use 3dfs:\\n1. find lca\\n2. recover start -> lca path\\n3. recover lca -> end path\\n\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    inline bool dfs(TreeNode *root, int startValue, int endValue, TreeNode* &lca) {\\n        if (!root) {\\n            return false;\\n        }\\n        int res = (root->val == startValue || root->val == endValue) + dfs(root->left, startValue, endValue, lca) + dfs(root->right, startValue, endValue, lca);\\n        if (res >= 2 && !lca) {\\n            lca = root;\\n            return true;\\n        }\\n        return res > 0;\\n    }\\n    \\n    inline bool dfs1(TreeNode *root, int s, string &left) {\\n        if (!root) {\\n            return false;\\n        }\\n        if (root->val == s) {\\n            return true;\\n        }\\n        if (dfs1(root->left, s, left) || dfs1(root->right, s, left)) {\\n            left += \"U\";\\n            return true;\\n        }\\n        return false;\\n    }\\n    \\n    inline bool dfs2(TreeNode *root, int e, string &right) {\\n        if (!root) {\\n            return false;\\n        }\\n        if (root->val == e) {\\n            return true;\\n        }\\n        if (dfs2(root->left, e, right)) {\\n            right += \"L\";\\n            return true;\\n        } else if (dfs2(root->right, e, right)) {\\n            right += \"R\";\\n            return true;\\n        }\\n        return false;\\n    }\\n    \\n    \\n    string getDirections(TreeNode* root, int startValue, int destValue) {\\n        TreeNode* lca = nullptr;\\n        dfs(root, startValue, destValue, lca);\\n        // cout << lca -> val << endl;\\n        string left = \"\";\\n        dfs1(lca, startValue, left);\\n        string right = \"\";\\n        dfs2(lca, destValue, right);\\n        reverse(right.begin(), right.end());\\n        return left + right;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    inline bool dfs(TreeNode *root, int startValue, int endValue, TreeNode* &lca) {\\n        if (!root) {\\n            return false;\\n        }\\n        int res = (root->val == startValue || root->val == endValue) + dfs(root->left, startValue, endValue, lca) + dfs(root->right, startValue, endValue, lca);\\n        if (res >= 2 && !lca) {\\n            lca = root;\\n            return true;\\n        }\\n        return res > 0;\\n    }\\n    \\n    inline bool dfs1(TreeNode *root, int s, string &left) {\\n        if (!root) {\\n            return false;\\n        }\\n        if (root->val == s) {\\n            return true;\\n        }\\n        if (dfs1(root->left, s, left) || dfs1(root->right, s, left)) {\\n            left += \"U\";\\n            return true;\\n        }\\n        return false;\\n    }\\n    \\n    inline bool dfs2(TreeNode *root, int e, string &right) {\\n        if (!root) {\\n            return false;\\n        }\\n        if (root->val == e) {\\n            return true;\\n        }\\n        if (dfs2(root->left, e, right)) {\\n            right += \"L\";\\n            return true;\\n        } else if (dfs2(root->right, e, right)) {\\n            right += \"R\";\\n            return true;\\n        }\\n        return false;\\n    }\\n    \\n    \\n    string getDirections(TreeNode* root, int startValue, int destValue) {\\n        TreeNode* lca = nullptr;\\n        dfs(root, startValue, destValue, lca);\\n        // cout << lca -> val << endl;\\n        string left = \"\";\\n        dfs1(lca, startValue, left);\\n        string right = \"\";\\n        dfs2(lca, destValue, right);\\n        reverse(right.begin(), right.end());\\n        return left + right;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1897376,
                "title": "go-lca",
                "content": "```\\n/*\\nfind the common root between the 2 values and then dfs to the node\\n\\nrebuild the tree with the ability to go to parent and do a bfs search\\n\\ndfs path search for both start and des values, then remove any common\\ndirections they have. then all start path is always U\\n*/\\n\\nfunc getDirections(root *TreeNode, startValue int, destValue int) string {\\n\\tlca := lowestCommonAncestor(root, startValue, destValue)\\n\\tstartPath, destPath := []string{}, []string{}\\n\\tdfs(lca, startValue, &startPath)\\n\\tdfs(lca, destValue, &destPath)\\n\\treturn invert(startPath) + strings.Join(destPath, \"\")\\n}\\n\\nfunc invert(path []string) string {\\n\\tsLen := len(path)\\n\\tvar upPath strings.Builder\\n\\tfor i := 0; i < sLen; i++ {\\n\\t\\tupPath.WriteString(\"U\")\\n\\t}\\n\\treturn upPath.String()\\n}\\n\\nfunc dfs(cur *TreeNode, v int, path *[]string) bool {\\n\\tif cur == nil {\\n\\t\\treturn false\\n\\t}\\n\\tif cur.Val == v {\\n\\t\\treturn true\\n\\t}\\n\\t*path = append(*path, \"L\")\\n\\thasVal := dfs(cur.Left, v, path)\\n\\tif hasVal {\\n\\t\\treturn true\\n\\t}\\n\\t*path = (*path)[:len(*path)-1]\\n\\n\\t*path = append(*path, \"R\")\\n\\thasVal = dfs(cur.Right, v, path)\\n\\tif hasVal {\\n\\t\\treturn true\\n\\t}\\n\\t*path = (*path)[:len(*path)-1]\\n\\n\\treturn false\\n}\\n\\nfunc lowestCommonAncestor(cur *TreeNode, s, d int) *TreeNode {\\n\\tif cur == nil {\\n\\t\\treturn nil\\n\\t}\\n\\t// Case cur is LCA: cur is one of the target nodes and the other target node is in a subtree.\\n\\tif cur.Val == s || cur.Val == d {\\n\\t\\treturn cur\\n\\t}\\n\\tleft := lowestCommonAncestor(cur.Left, s, d)\\n\\tright := lowestCommonAncestor(cur.Right, s, d)\\n\\t// Case cur is LCA: one target node is in the left subtree and the other target node is in the right subtree.\\n\\tif left != nil && right != nil {\\n\\t\\treturn cur\\n\\t}\\n\\t// Case cur is not LCA: cur is in the path between LCA and target node or LCA is in the subtree of cur node.\\n\\tif left != nil {\\n\\t\\treturn left\\n\\t}\\n\\tif right != nil {\\n\\t\\treturn right\\n\\t}\\n\\t// Case cur is not LCA: cur is neither a target node and its subtree has no target nodes.\\n\\treturn nil\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n/*\\nfind the common root between the 2 values and then dfs to the node\\n\\nrebuild the tree with the ability to go to parent and do a bfs search\\n\\ndfs path search for both start and des values, then remove any common\\ndirections they have. then all start path is always U\\n*/\\n\\nfunc getDirections(root *TreeNode, startValue int, destValue int) string {\\n\\tlca := lowestCommonAncestor(root, startValue, destValue)\\n\\tstartPath, destPath := []string{}, []string{}\\n\\tdfs(lca, startValue, &startPath)\\n\\tdfs(lca, destValue, &destPath)\\n\\treturn invert(startPath) + strings.Join(destPath, \"\")\\n}\\n\\nfunc invert(path []string) string {\\n\\tsLen := len(path)\\n\\tvar upPath strings.Builder\\n\\tfor i := 0; i < sLen; i++ {\\n\\t\\tupPath.WriteString(\"U\")\\n\\t}\\n\\treturn upPath.String()\\n}\\n\\nfunc dfs(cur *TreeNode, v int, path *[]string) bool {\\n\\tif cur == nil {\\n\\t\\treturn false\\n\\t}\\n\\tif cur.Val == v {\\n\\t\\treturn true\\n\\t}\\n\\t*path = append(*path, \"L\")\\n\\thasVal := dfs(cur.Left, v, path)\\n\\tif hasVal {\\n\\t\\treturn true\\n\\t}\\n\\t*path = (*path)[:len(*path)-1]\\n\\n\\t*path = append(*path, \"R\")\\n\\thasVal = dfs(cur.Right, v, path)\\n\\tif hasVal {\\n\\t\\treturn true\\n\\t}\\n\\t*path = (*path)[:len(*path)-1]\\n\\n\\treturn false\\n}\\n\\nfunc lowestCommonAncestor(cur *TreeNode, s, d int) *TreeNode {\\n\\tif cur == nil {\\n\\t\\treturn nil\\n\\t}\\n\\t// Case cur is LCA: cur is one of the target nodes and the other target node is in a subtree.\\n\\tif cur.Val == s || cur.Val == d {\\n\\t\\treturn cur\\n\\t}\\n\\tleft := lowestCommonAncestor(cur.Left, s, d)\\n\\tright := lowestCommonAncestor(cur.Right, s, d)\\n\\t// Case cur is LCA: one target node is in the left subtree and the other target node is in the right subtree.\\n\\tif left != nil && right != nil {\\n\\t\\treturn cur\\n\\t}\\n\\t// Case cur is not LCA: cur is in the path between LCA and target node or LCA is in the subtree of cur node.\\n\\tif left != nil {\\n\\t\\treturn left\\n\\t}\\n\\tif right != nil {\\n\\t\\treturn right\\n\\t}\\n\\t// Case cur is not LCA: cur is neither a target node and its subtree has no target nodes.\\n\\treturn nil\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1883864,
                "title": "short-solution-that-only-traverse-the-tree-once",
                "content": "```\\nclass Solution {\\n    public final static char U = \\'U\\';\\n    public final static char R = \\'R\\';\\n    public final static char L = \\'L\\';\\n    \\n    public String getDirections(TreeNode root, int startValue, int destValue) {\\n        StringBuilder p1 = new StringBuilder();\\n        StringBuilder p2 = new StringBuilder();\\n        findPath(root, p1, p2, startValue, destValue);\\n        p1.append(p2.reverse());\\n        \\n        return p1.toString();\\n    }\\n    \\n    public int findPath(TreeNode node, StringBuilder p1, StringBuilder p2, int v1, int v2) {\\n        if (node == null) {\\n            return 0;\\n        }\\n        \\n        int searchL = findPath(node.left, p1, p2, v1, v2);\\n        int searchR = findPath(node.right, p1, p2, v1, v2);\\n        int any = searchL | searchR;\\n        \\n        if (any == 3) {\\n            p1.append(U);\\n            p2.append(searchL == 2 ? L : R);\\n            return 0;\\n        } else if (any == 1) {\\n            p1.append(U);\\n        } else if (any == 2) {\\n            p2.append(searchL == 2 ? L : R);\\n        }\\n     \\n        if ((node.val == v1 || node.val == v2) && any != 0) {\\n            return 0;\\n        } else if (node.val == v1) {\\n            return 1;\\n        }else if (node.val == v2) {\\n            return 2;\\n        }\\n        \\n        return any;        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public final static char U = \\'U\\';\\n    public final static char R = \\'R\\';\\n    public final static char L = \\'L\\';\\n    \\n    public String getDirections(TreeNode root, int startValue, int destValue) {\\n        StringBuilder p1 = new StringBuilder();\\n        StringBuilder p2 = new StringBuilder();\\n        findPath(root, p1, p2, startValue, destValue);\\n        p1.append(p2.reverse());\\n        \\n        return p1.toString();\\n    }\\n    \\n    public int findPath(TreeNode node, StringBuilder p1, StringBuilder p2, int v1, int v2) {\\n        if (node == null) {\\n            return 0;\\n        }\\n        \\n        int searchL = findPath(node.left, p1, p2, v1, v2);\\n        int searchR = findPath(node.right, p1, p2, v1, v2);\\n        int any = searchL | searchR;\\n        \\n        if (any == 3) {\\n            p1.append(U);\\n            p2.append(searchL == 2 ? L : R);\\n            return 0;\\n        } else if (any == 1) {\\n            p1.append(U);\\n        } else if (any == 2) {\\n            p2.append(searchL == 2 ? L : R);\\n        }\\n     \\n        if ((node.val == v1 || node.val == v2) && any != 0) {\\n            return 0;\\n        } else if (node.val == v1) {\\n            return 1;\\n        }else if (node.val == v2) {\\n            return 2;\\n        }\\n        \\n        return any;        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1854336,
                "title": "python-20-line",
                "content": "```\\nclass Solution:\\n    def getDirections(self, root: Optional[TreeNode], startValue: int, destValue: int) -> str:\\n        def recurse(node, val):\\n            if node is None:\\n                return None\\n            if node.val == val:\\n                return \\'\\'\\n            p0 = recurse(node.left, val)\\n            p1 = recurse(node.right, val)\\n            if p0 is not None:\\n                return \\'L\\' + p0\\n            elif p1 is not None:\\n                return \\'R\\' + p1\\n            else:\\n                return None\\n        p0 = recurse(root, startValue)\\n        p1 = recurse(root, destValue)\\n        \\n        prefix = 0\\n        while prefix < len(p0) and prefix < len(p1) and p0[prefix] == p1[prefix]:\\n            prefix += 1\\n        \\n        return (len(p0) - prefix) * \\'U\\'+ p1[prefix:]\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def getDirections(self, root: Optional[TreeNode], startValue: int, destValue: int) -> str:\\n        def recurse(node, val):\\n            if node is None:\\n                return None\\n            if node.val == val:\\n                return \\'\\'\\n            p0 = recurse(node.left, val)\\n            p1 = recurse(node.right, val)\\n            if p0 is not None:\\n                return \\'L\\' + p0\\n            elif p1 is not None:\\n                return \\'R\\' + p1\\n            else:\\n                return None\\n        p0 = recurse(root, startValue)\\n        p1 = recurse(root, destValue)\\n        \\n        prefix = 0\\n        while prefix < len(p0) and prefix < len(p1) and p0[prefix] == p1[prefix]:\\n            prefix += 1\\n        \\n        return (len(p0) - prefix) * \\'U\\'+ p1[prefix:]\\n",
                "codeTag": "Java"
            },
            {
                "id": 1782203,
                "title": "python-dfs-lca-backtracking-o-n",
                "content": "It\\'s a little long but I hope it makes sense.\\n\\nConsider 3 cases for LCA\\n    1) start is LCA\\n    2) dest is LCA\\n    3) another node is LCA\\n \\nApproach: DFS. Find the LCA, while keeping track of the path traversed so far (backtracking). Since we need to know the positions of both start and dest, we cannot return upon finding the first node (start or dest) because that could be LCA (case 1/2), meaning we would never find the second node. So we continue searching until we have found both nodes, and update their paths accordingly. At first node found, we can update the LCA to that path (case 1,2), because as we return up the tree, if we find a node where both left and right paths have start/dest nodes, that will be the LCA (case 3).\\n\\nObservation: Once LCA is determined, we already know the paths from root to LCA, start, and dest. We can find the path by converting path from LCA to start to \"U\" at each step, and append the path from LCA to dest.\\n\\n```\\ndef getDirections(self, root: Optional[TreeNode], startValue: int, destValue: int) -> str:\\n        sPath, dPath, lcaPath = \"\", \"\", \"\"\\n        \\n        def getPaths(curr, start, dest, path):\\n            nonlocal sPath, dPath, lcaPath\\n            if not curr: return False\\n            \\n            # check curr node\\n            if curr.val == start:\\n                sPath = \"\".join(path)\\n            elif curr.val == dest:\\n                dPath = \"\".join(path)\\n            \\n            if sPath and dPath:     # Both nodes found, early terminate\\n                if curr.val in (start,dest): \\n                    return True\\n                else: \\n                    return False\\n            else:                   # Explore left,right child\\n                path.append(\"L\")\\n                leftFound = getPaths(curr.left, start, dest, path)\\n                path.pop()\\n                path.append(\"R\")\\n                rightFound = getPaths(curr.right, start, dest, path)\\n                path.pop()\\n                \\n                # Check if currNode is LCA. \\n\\t\\t\\t\\t# Note that case 1,2 does not update LCA for second node found. (returned earlier at \"if sPath and dPath\")\\n                if leftFound and rightFound or curr.val == start or curr.val == dest:\\n                    lcaPath = \"\".join(path)\\n                    return True\\n                return leftFound or rightFound # Check if this path contains a start/dest node\\n                    \\n        getPaths(root, startValue, destValue, [])\\n        lcaTosPath, lcaTodPath = sPath[len(lcaPath):], dPath[len(lcaPath):]\\n        return \"U\"*len(lcaTosPath) + lcaTodPath\\n```",
                "solutionTags": [
                    "Python",
                    "Backtracking",
                    "Depth-First Search"
                ],
                "code": "```\\ndef getDirections(self, root: Optional[TreeNode], startValue: int, destValue: int) -> str:\\n        sPath, dPath, lcaPath = \"\", \"\", \"\"\\n        \\n        def getPaths(curr, start, dest, path):\\n            nonlocal sPath, dPath, lcaPath\\n            if not curr: return False\\n            \\n            # check curr node\\n            if curr.val == start:\\n                sPath = \"\".join(path)\\n            elif curr.val == dest:\\n                dPath = \"\".join(path)\\n            \\n            if sPath and dPath:     # Both nodes found, early terminate\\n                if curr.val in (start,dest): \\n                    return True\\n                else: \\n                    return False\\n            else:                   # Explore left,right child\\n                path.append(\"L\")\\n                leftFound = getPaths(curr.left, start, dest, path)\\n                path.pop()\\n                path.append(\"R\")\\n                rightFound = getPaths(curr.right, start, dest, path)\\n                path.pop()\\n                \\n                # Check if currNode is LCA. \\n\\t\\t\\t\\t# Note that case 1,2 does not update LCA for second node found. (returned earlier at \"if sPath and dPath\")\\n                if leftFound and rightFound or curr.val == start or curr.val == dest:\\n                    lcaPath = \"\".join(path)\\n                    return True\\n                return leftFound or rightFound # Check if this path contains a start/dest node\\n                    \\n        getPaths(root, startValue, destValue, [])\\n        lcaTosPath, lcaTodPath = sPath[len(lcaPath):], dPath[len(lcaPath):]\\n        return \"U\"*len(lcaTosPath) + lcaTodPath\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1779975,
                "title": "least-common-ancestor-o-n",
                "content": "Similar to strategy used in Least Common Ancestor, find the path form root to each start and destination. Then remove common parents untill you reach the first different point. From there, change all the elements from start to U, and append it to end path.\\n\\n\\n``` python\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def getDirections(self, root: Optional[TreeNode], startValue: int, destValue: int) -> str:\\n        def root_to_leaf(node, target):\\n            if not node:\\n                return [False,\"\"]\\n            if node.val == target:\\n                return [True,\"\"]\\n            \\n            left_seen, left_path = root_to_leaf(node.left,target)\\n            if left_seen:\\n                return [left_seen, left_path + \\'L\\']\\n            \\n            right_seen, right_path = root_to_leaf(node.right,target)\\n            if right_seen:\\n                return [right_seen, right_path + \\'R\\']\\n            \\n            return [False, []]\\n        \\n        _, start_path= root_to_leaf(root, startValue)\\n        _, end_path = root_to_leaf(root, destValue)\\n        start_path = list(start_path)\\n        end_path = list(end_path)\\n        while start_path and end_path and start_path[-1] == end_path[-1]:\\n            start_path.pop()\\n            end_path.pop()\\n        \\n        return \"\".join([\"U\" for _ in start_path] + [part for part in end_path[::-1]])\\n",
                "solutionTags": [],
                "code": "Similar to strategy used in Least Common Ancestor, find the path form root to each start and destination. Then remove common parents untill you reach the first different point. From there, change all the elements from start to U, and append it to end path.\\n\\n\\n``` python\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def getDirections(self, root: Optional[TreeNode], startValue: int, destValue: int) -> str:\\n        def root_to_leaf(node, target):\\n            if not node:\\n                return [False,\"\"]\\n            if node.val == target:\\n                return [True,\"\"]\\n            \\n            left_seen, left_path = root_to_leaf(node.left,target)\\n            if left_seen:\\n                return [left_seen, left_path + \\'L\\']\\n            \\n            right_seen, right_path = root_to_leaf(node.right,target)\\n            if right_seen:\\n                return [right_seen, right_path + \\'R\\']\\n            \\n            return [False, []]\\n        \\n        _, start_path= root_to_leaf(root, startValue)\\n        _, end_path = root_to_leaf(root, destValue)\\n        start_path = list(start_path)\\n        end_path = list(end_path)\\n        while start_path and end_path and start_path[-1] == end_path[-1]:\\n            start_path.pop()\\n            end_path.pop()\\n        \\n        return \"\".join([\"U\" for _ in start_path] + [part for part in end_path[::-1]])\\n",
                "codeTag": "Java"
            },
            {
                "id": 1748174,
                "title": "c-dfs-lca-build-path-easy-to-understand",
                "content": "```\\npublic class Solution {\\n    private String pathToStart = \"\";\\n    private String pathToDest = \"\"; \\n    private StringBuilder finalResult = new StringBuilder();\\n    public string GetDirections(TreeNode root, int startValue, int destValue) {\\n\\t\\t//Find LCA of two nodes\\n        TreeNode lca = lowestCommonAncestor(root, startValue, destValue);\\n\\t\\t//Traverse through binary tree starting LCA and return path when reached to startValue or destValue\\n        dfs(lca, startValue, destValue, new StringBuilder());\\n        for(int i = 0; i < pathToStart.Length; i++){\\n            finalResult.Append(\\'U\\');\\n        }\\n        return finalResult.Append(pathToDest).ToString();\\n    }\\n    \\n    //Find lowest comman ancestor for start and destination values\\n    private TreeNode lowestCommonAncestor(TreeNode root, int p, int q){\\n        if(root == null || root.val == p || root.val == q)\\n            return root;\\n        TreeNode left = lowestCommonAncestor(root.left, p, q);\\n        TreeNode right = lowestCommonAncestor(root.right, p, q);\\n        \\n        if(left != null && right != null){\\n            return root;\\n        }\\n        \\n        return left == null ? right : left;\\n    }\\n    \\n\\t//Start DFS from LCA and build paths using backtracking\\n    private void dfs(TreeNode root, int p, int q, StringBuilder path){\\n        if(root == null)\\n            return;\\n        if(root.val == p)\\n            pathToStart = path.ToString();\\n        if(root.val == q)\\n            pathToDest = path.ToString();\\n        \\n        dfs(root.left, p, q, path.Append(\\'L\\'));\\n\\t\\t//Remove last character where root.left == null\\n        path.Remove(path.Length - 1, 1);\\n\\t\\t\\n        dfs(root.right, p, q, path.Append(\\'R\\'));\\n        //Remove last character where root.right == null\\n\\t\\tpath.Remove(path.Length - 1, 1);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Depth-First Search",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\npublic class Solution {\\n    private String pathToStart = \"\";\\n    private String pathToDest = \"\"; \\n    private StringBuilder finalResult = new StringBuilder();\\n    public string GetDirections(TreeNode root, int startValue, int destValue) {\\n\\t\\t//Find LCA of two nodes\\n        TreeNode lca = lowestCommonAncestor(root, startValue, destValue);\\n\\t\\t//Traverse through binary tree starting LCA and return path when reached to startValue or destValue\\n        dfs(lca, startValue, destValue, new StringBuilder());\\n        for(int i = 0; i < pathToStart.Length; i++){\\n            finalResult.Append(\\'U\\');\\n        }\\n        return finalResult.Append(pathToDest).ToString();\\n    }\\n    \\n    //Find lowest comman ancestor for start and destination values\\n    private TreeNode lowestCommonAncestor(TreeNode root, int p, int q){\\n        if(root == null || root.val == p || root.val == q)\\n            return root;\\n        TreeNode left = lowestCommonAncestor(root.left, p, q);\\n        TreeNode right = lowestCommonAncestor(root.right, p, q);\\n        \\n        if(left != null && right != null){\\n            return root;\\n        }\\n        \\n        return left == null ? right : left;\\n    }\\n    \\n\\t//Start DFS from LCA and build paths using backtracking\\n    private void dfs(TreeNode root, int p, int q, StringBuilder path){\\n        if(root == null)\\n            return;\\n        if(root.val == p)\\n            pathToStart = path.ToString();\\n        if(root.val == q)\\n            pathToDest = path.ToString();\\n        \\n        dfs(root.left, p, q, path.Append(\\'L\\'));\\n\\t\\t//Remove last character where root.left == null\\n        path.Remove(path.Length - 1, 1);\\n\\t\\t\\n        dfs(root.right, p, q, path.Append(\\'R\\'));\\n        //Remove last character where root.right == null\\n\\t\\tpath.Remove(path.Length - 1, 1);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1740392,
                "title": "python-two-approaches-check-it-out",
                "content": "Approach 1: Find LCA b/w two nodes and start to traverse from those nodes to start and dest and return the concated paths - TLE\\n\\n```\\nclass Solution:\\n    def getDirections(self, root: Optional[TreeNode], startValue: int, destValue: int) -> str:\\n        \\n\\t\\t#Th below method was taken from @InjySarhan post in the discuss\\n        def getLCA(root,p,q):\\n            if not root: return None\\n            if root.val==p or root.val==q:\\n                return root\\n            L=getLCA(root.left,p,q)\\n            R=getLCA(root.right,p,q)\\n            if L and R:\\n                return root\\n            return L or R\\n    \\n    #get route from root to start and root to end, result will be adding them both\\n        \\n        lca = getLCA(root, startValue, destValue)\\n        q = deque()\\n        start_path, dest_path = \\'\\',\\'\\'\\n        curr_tree = [lca.val]\\n        q.append([lca, \\'\\', 0 , curr_tree])\\n        while q :\\n            curr = q.popleft()\\n            curr_node, curr_path, curr_lvl , curr_tree = curr\\n            if curr_node.val == startValue:\\n                start_path = \\'U\\'*curr_lvl\\n                start_tree = curr_tree\\n            if curr_node.val == destValue:\\n                dest_path = curr_path\\n                dest_tree = curr_tree\\n            #if we found both the paths, stop searching\\n            if start_path and dest_path:\\n                break\\n            else:\\n                new_lvl = curr_lvl + 1\\n                if curr_node.left:\\n                    new_path = curr_path + \\'L\\'\\n                    new_tree = curr_tree + [curr_node.left.val]\\n                    q.append([curr_node.left, new_path, new_lvl, new_tree])\\n                if curr_node.right:\\n                    new_path = curr_path + \\'R\\'\\n                    new_tree = curr_tree + [curr_node.right.val]\\n                    q.append([curr_node.right, new_path, new_lvl, new_tree])\\n                \\n        #pop start and dest nodes\\n        start_tree.pop()\\n        dest_tree.pop()\\n                \\n        print(start_path, dest_path)\\n        print(start_tree, dest_tree)\\n\\n        #Check for LCA b/w two lists of trees and remove the common\\n        \\n        if root.val == startValue:\\n            return dest_path\\n        if root.val == destValue:\\n            return start_path\\n        \\n#         #if start and dest are both  \\n#         min_tree_len = min(len(start_tree), len(dest_tree))\\n        \\n#         #num of common nodes\\n#         common_ancestors = set(start_tree).intersection(set(dest_tree))\\n#         len_common_ancestors = len(common_ancestors)\\n#         print(len_common_ancestors)\\n#         #skip the idxs for both left and right as they are common\\n#         left_path = start_path[len_common_ancestors-1:]\\n#         right_path = dest_path[len_common_ancestors-1:]\\n        \\n#         print(left_path+right_path)\\n        \\n        # return left_path + right_path\\n        return start_path + dest_path\\n                \\n```\\n\\n#Approach2 :: build a graph from tree and use DFS - Worked (Passed Successfully all cases)\\n```\\nclass Solution:\\n    def getDirections(self, root: Optional[TreeNode], startValue: int, destValue: int) -> str:\\n    \\n        def build_graph(root,graph):\\n\\n            q = deque()\\n            q.append(root)\\n            while q:\\n                curr = q.pop()\\n                curr_val = curr.val\\n                # left = curr.left\\n                # right = curr.right\\n\\n                if curr.val not in graph:\\n                    graph[curr_val] = {}\\n \\n                if curr.left:\\n                    left_val = curr.left.val\\n                    if left_val not in graph:\\n                        graph[left_val] = {}\\n                    graph[curr_val][left_val] = \\'L\\'\\n                    graph[left_val][curr_val] = \\'U\\'\\n                    q.append(curr.left)\\n                if curr.right:\\n                    right_val = curr.right.val\\n                    if right_val not in graph:\\n                        graph[right_val] = {}\\n                    graph[curr_val][right_val] = \\'R\\'\\n                    graph[right_val][curr_val] = \\'U\\'\\n                    q.append(curr.right)\\n\\n            return\\n\\t\\t\\t\\n\\t\\t#Build the graph here\\t\\n\\t\\tgraph = {}\\n        build_graph(root, graph)\\n        # print(graph)\\n        \\n        #BFS from start to dest\\n        visited = set()\\n        path = \\'\\'\\n        q = deque()\\n        q.append([startValue, path])\\n        while q :\\n            curr_node, curr_path = q.popleft()\\n            if curr_node == destValue:\\n                return curr_path\\n            neighbs = graph[curr_node]\\n            for neigh in neighbs:\\n                if neigh not in visited:\\n                    new_path = curr_path + neighbs[neigh]\\n                    q.append([neigh, new_path])\\n                    visited.add(neigh)\\n        \\n```",
                "solutionTags": [
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def getDirections(self, root: Optional[TreeNode], startValue: int, destValue: int) -> str:\\n        \\n\\t\\t#Th below method was taken from @InjySarhan post in the discuss\\n        def getLCA(root,p,q):\\n            if not root: return None\\n            if root.val==p or root.val==q:\\n                return root\\n            L=getLCA(root.left,p,q)\\n            R=getLCA(root.right,p,q)\\n            if L and R:\\n                return root\\n            return L or R\\n    \\n    #get route from root to start and root to end, result will be adding them both\\n        \\n        lca = getLCA(root, startValue, destValue)\\n        q = deque()\\n        start_path, dest_path = \\'\\',\\'\\'\\n        curr_tree = [lca.val]\\n        q.append([lca, \\'\\', 0 , curr_tree])\\n        while q :\\n            curr = q.popleft()\\n            curr_node, curr_path, curr_lvl , curr_tree = curr\\n            if curr_node.val == startValue:\\n                start_path = \\'U\\'*curr_lvl\\n                start_tree = curr_tree\\n            if curr_node.val == destValue:\\n                dest_path = curr_path\\n                dest_tree = curr_tree\\n            #if we found both the paths, stop searching\\n            if start_path and dest_path:\\n                break\\n            else:\\n                new_lvl = curr_lvl + 1\\n                if curr_node.left:\\n                    new_path = curr_path + \\'L\\'\\n                    new_tree = curr_tree + [curr_node.left.val]\\n                    q.append([curr_node.left, new_path, new_lvl, new_tree])\\n                if curr_node.right:\\n                    new_path = curr_path + \\'R\\'\\n                    new_tree = curr_tree + [curr_node.right.val]\\n                    q.append([curr_node.right, new_path, new_lvl, new_tree])\\n                \\n        #pop start and dest nodes\\n        start_tree.pop()\\n        dest_tree.pop()\\n                \\n        print(start_path, dest_path)\\n        print(start_tree, dest_tree)\\n\\n        #Check for LCA b/w two lists of trees and remove the common\\n        \\n        if root.val == startValue:\\n            return dest_path\\n        if root.val == destValue:\\n            return start_path\\n        \\n#         #if start and dest are both  \\n#         min_tree_len = min(len(start_tree), len(dest_tree))\\n        \\n#         #num of common nodes\\n#         common_ancestors = set(start_tree).intersection(set(dest_tree))\\n#         len_common_ancestors = len(common_ancestors)\\n#         print(len_common_ancestors)\\n#         #skip the idxs for both left and right as they are common\\n#         left_path = start_path[len_common_ancestors-1:]\\n#         right_path = dest_path[len_common_ancestors-1:]\\n        \\n#         print(left_path+right_path)\\n        \\n        # return left_path + right_path\\n        return start_path + dest_path\\n                \\n```\n```\\nclass Solution:\\n    def getDirections(self, root: Optional[TreeNode], startValue: int, destValue: int) -> str:\\n    \\n        def build_graph(root,graph):\\n\\n            q = deque()\\n            q.append(root)\\n            while q:\\n                curr = q.pop()\\n                curr_val = curr.val\\n                # left = curr.left\\n                # right = curr.right\\n\\n                if curr.val not in graph:\\n                    graph[curr_val] = {}\\n \\n                if curr.left:\\n                    left_val = curr.left.val\\n                    if left_val not in graph:\\n                        graph[left_val] = {}\\n                    graph[curr_val][left_val] = \\'L\\'\\n                    graph[left_val][curr_val] = \\'U\\'\\n                    q.append(curr.left)\\n                if curr.right:\\n                    right_val = curr.right.val\\n                    if right_val not in graph:\\n                        graph[right_val] = {}\\n                    graph[curr_val][right_val] = \\'R\\'\\n                    graph[right_val][curr_val] = \\'U\\'\\n                    q.append(curr.right)\\n\\n            return\\n\\t\\t\\t\\n\\t\\t#Build the graph here\\t\\n\\t\\tgraph = {}\\n        build_graph(root, graph)\\n        # print(graph)\\n        \\n        #BFS from start to dest\\n        visited = set()\\n        path = \\'\\'\\n        q = deque()\\n        q.append([startValue, path])\\n        while q :\\n            curr_node, curr_path = q.popleft()\\n            if curr_node == destValue:\\n                return curr_path\\n            neighbs = graph[curr_node]\\n            for neigh in neighbs:\\n                if neigh not in visited:\\n                    new_path = curr_path + neighbs[neigh]\\n                    q.append([neigh, new_path])\\n                    visited.add(neigh)\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1737505,
                "title": "java-simple-implementation-without-any-weird-tricks-beats-82",
                "content": "```\\nprivate final char LEFT = \\'L\\';\\n    private final char UP = \\'U\\';\\n    private final char RIGHT = \\'R\\';\\n    \\n    public String getDirections(TreeNode root, int startValue, int destValue) {\\n        StringBuilder startPath = new StringBuilder();\\n        StringBuilder destPath = new StringBuilder();\\n        StringBuilder combinedPaths = new StringBuilder();\\n        \\n        // get LCA, then use LCA to find shortest path to each node. PATHS WILL NEVER OVERLAP\\n        TreeNode lca = findLCA(root, startValue, destValue);\\n        findPath(lca, startValue, startPath);\\n        findPath(lca, destValue, destPath);\\n        \\n        // Add x U\\'s to combinedPath (x is length of startPath), We would only go up from start to lca\\n        for (int i = 0; i < startPath.length(); i++) combinedPaths.append(UP);\\n        \\n        // dest never overlaps with source, simply append entire string\\n        combinedPaths.append(destPath);\\n\\n        return combinedPaths.toString();\\n    }\\n    \\n    // basic lca implementation.  \\n    private TreeNode findLCA(TreeNode root, int startVal, int destVal) {\\n        if (root == null || root.val == startVal || root.val == destVal) return root;\\n        \\n        TreeNode left = findLCA(root.left, startVal, destVal);\\n        TreeNode right = findLCA(root.right, startVal, destVal);\\n        if (left != null && right != null) return root;\\n        \\n        return left != null? left : right;\\n    }\\n    \\n    // return false if we ever hit a null value, true if we hit target\\n    private boolean findPath(TreeNode source, int targetVal, StringBuilder pathString) {\\n        if (source == null) return false;\\n        if (source.val == targetVal) return true;\\n        \\n        // add char to pathString, remove if we didn\\'t actually find target\\n        pathString.append(LEFT);\\n        boolean destInLeft = findPath(source.left, targetVal, pathString);\\n        if (!destInLeft) pathString.setLength(pathString.length() - 1);\\n\\t\\t\\n        // add char to pathString, remove if we didn\\'t actually find target\\n        pathString.append(RIGHT);\\n        boolean destInRight = findPath(source.right, targetVal, pathString);\\n        if (!destInRight) pathString.setLength(pathString.length() - 1);\\n        \\n        // if either returned true, then we have to be on the correct path. All incorrect char\\'s would have been removed by now.\\n        return destInLeft || destInRight;\\n    }\\n\\t```",
                "solutionTags": [],
                "code": "```\\nprivate final char LEFT = \\'L\\';\\n    private final char UP = \\'U\\';\\n    private final char RIGHT = \\'R\\';\\n    \\n    public String getDirections(TreeNode root, int startValue, int destValue) {\\n        StringBuilder startPath = new StringBuilder();\\n        StringBuilder destPath = new StringBuilder();\\n        StringBuilder combinedPaths = new StringBuilder();\\n        \\n        // get LCA, then use LCA to find shortest path to each node. PATHS WILL NEVER OVERLAP\\n        TreeNode lca = findLCA(root, startValue, destValue);\\n        findPath(lca, startValue, startPath);\\n        findPath(lca, destValue, destPath);\\n        \\n        // Add x U\\'s to combinedPath (x is length of startPath), We would only go up from start to lca\\n        for (int i = 0; i < startPath.length(); i++) combinedPaths.append(UP);\\n        \\n        // dest never overlaps with source, simply append entire string\\n        combinedPaths.append(destPath);\\n\\n        return combinedPaths.toString();\\n    }\\n    \\n    // basic lca implementation.  \\n    private TreeNode findLCA(TreeNode root, int startVal, int destVal) {\\n        if (root == null || root.val == startVal || root.val == destVal) return root;\\n        \\n        TreeNode left = findLCA(root.left, startVal, destVal);\\n        TreeNode right = findLCA(root.right, startVal, destVal);\\n        if (left != null && right != null) return root;\\n        \\n        return left != null? left : right;\\n    }\\n    \\n    // return false if we ever hit a null value, true if we hit target\\n    private boolean findPath(TreeNode source, int targetVal, StringBuilder pathString) {\\n        if (source == null) return false;\\n        if (source.val == targetVal) return true;\\n        \\n        // add char to pathString, remove if we didn\\'t actually find target\\n        pathString.append(LEFT);\\n        boolean destInLeft = findPath(source.left, targetVal, pathString);\\n        if (!destInLeft) pathString.setLength(pathString.length() - 1);\\n\\t\\t\\n        // add char to pathString, remove if we didn\\'t actually find target\\n        pathString.append(RIGHT);\\n        boolean destInRight = findPath(source.right, targetVal, pathString);\\n        if (!destInRight) pathString.setLength(pathString.length() - 1);\\n        \\n        // if either returned true, then we have to be on the correct path. All incorrect char\\'s would have been removed by now.\\n        return destInLeft || destInRight;\\n    }\\n\\t```",
                "codeTag": "Unknown"
            },
            {
                "id": 1672865,
                "title": "lca-code-with-explanation-in-c",
                "content": "```\\nclass Solution {\\npublic:\\n    TreeNode* lca(TreeNode* root, int &a, int &b) {\\n        if(!root) return root;\\n        if(root->val == a or root->val == b) return root;\\n        TreeNode* l = lca(root->left, a, b);\\n        TreeNode* r = lca(root->right, a, b);\\n        if(l and r) return root;\\n        if(l) return l;\\n        return r;\\n    }\\n    bool findStart(TreeNode* root, int &s, string &str)\\n    {\\n        if(!root) return false;\\n        if(root->val == s) return true;\\n        str.push_back(\\'U\\');\\n        if(findStart(root->left, s, str)) return true;\\n        if(findStart(root->right, s, str)) return true;\\n        str.pop_back();\\n        return false;\\n    }\\n    bool findEnd(TreeNode* root, int &e, string &str)\\n    {\\n        if(!root){str.pop_back();return false;}\\n        if(root->val == e) return true;\\n        str.push_back(\\'L\\');\\n        if(findEnd(root->left, e, str)) return true;\\n        str.push_back(\\'R\\');\\n        if(findEnd(root->right, e, str)) return true;\\n        str.pop_back();\\n        return false;\\n    }\\n    string getDirections(TreeNode* root, int s, int e) {\\n        TreeNode* X = lca(root, s, e);\\n        string str;\\n        findStart(X, s, str);\\n        findEnd(X, e, str);\\n        return str;\\n    }\\n};\\n```\\n\\n1. The LCA code is pretty straightforward that we are finding the LCA of two nodes, please solve the LCA question, LCA II, LCA III, LCA IV in order to understand this question as that would be the prereq for this one.\\n2. In order to get directions from the start node to the end node of the two nodes, we need to know the lca of the start node and end node and we will store it in a node named as X\\n3. now we will recursively find the start node from this LCA node X and end node from this LCA node X and we will keep on appending the string and the string that we pass in the two functions will be passed by reference. and the end node and start node data will be passed as integer reference.\\n4. In the findstart function, we are checking that if the root is null then we are returning false. if the root value is s then we return true. we push U as on the left subtree of the LCA, we need to go to the leftmost node, so we will print U first then we will recursively call the findStart function on both the root->left and root->right. and if anyone of those return true then well and good otherwise U will not be printed na. At the end we return false, if both of the if blocks fail to return true.\\n5. Likewise in the findEnd, we will go down so we need to go from parent to child so we have two moves left or right.\\n6. We will first check if the root node itself doesnt exist then in that case, we will pop of the string and return false. now we will check if the root->value is e then in that case we return true. Push L then check for existence of findEnd on root->left. Push R and check for the existence of Root->right. and if both the if blocks fail to output true, in that case, we clear this string and return false.\\n\\nIn the end we return the string.",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    TreeNode* lca(TreeNode* root, int &a, int &b) {\\n        if(!root) return root;\\n        if(root->val == a or root->val == b) return root;\\n        TreeNode* l = lca(root->left, a, b);\\n        TreeNode* r = lca(root->right, a, b);\\n        if(l and r) return root;\\n        if(l) return l;\\n        return r;\\n    }\\n    bool findStart(TreeNode* root, int &s, string &str)\\n    {\\n        if(!root) return false;\\n        if(root->val == s) return true;\\n        str.push_back(\\'U\\');\\n        if(findStart(root->left, s, str)) return true;\\n        if(findStart(root->right, s, str)) return true;\\n        str.pop_back();\\n        return false;\\n    }\\n    bool findEnd(TreeNode* root, int &e, string &str)\\n    {\\n        if(!root){str.pop_back();return false;}\\n        if(root->val == e) return true;\\n        str.push_back(\\'L\\');\\n        if(findEnd(root->left, e, str)) return true;\\n        str.push_back(\\'R\\');\\n        if(findEnd(root->right, e, str)) return true;\\n        str.pop_back();\\n        return false;\\n    }\\n    string getDirections(TreeNode* root, int s, int e) {\\n        TreeNode* X = lca(root, s, e);\\n        string str;\\n        findStart(X, s, str);\\n        findEnd(X, e, str);\\n        return str;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1670554,
                "title": "java-easy-solution",
                "content": "```\\nclass Solution {\\n    \\n    StringBuilder source=new StringBuilder(),destination= new StringBuilder();\\n    public String getDirections(TreeNode root, int startValue, int destValue) {\\n        dfs(root,startValue,source);\\n        dfs(root,destValue,destination);\\n        StringBuilder res= new StringBuilder();\\n        int i=0,j=0;\\n        for(;i<source.length()&&j<destination.length()  && source.charAt(i) == destination.charAt(j);i++,j++);\\n        for(int k=i;k<source.length();k++)\\n            res.append(\\'U\\');\\n        for(int k=j;k<destination.length();k++)\\n            res.append(destination.charAt(k));\\n        \\n        return res.toString();\\n    }\\n    \\n    \\n    boolean  dfs(TreeNode node,int val,StringBuilder temp){\\n        if(node==null) return false;\\n        if(node.val==val) return true;\\n        temp.append(\\'L\\');\\n        if(dfs(node.left,val,temp)) return true;\\n        temp.setCharAt(temp.length()-1,\\'R\\');\\n        if(dfs(node.right,val,temp)) return true;\\n        temp.deleteCharAt(temp.length()-1);\\n        return false;\\n        \\n    }\\n\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    \\n    StringBuilder source=new StringBuilder(),destination= new StringBuilder();\\n    public String getDirections(TreeNode root, int startValue, int destValue) {\\n        dfs(root,startValue,source);\\n        dfs(root,destValue,destination);\\n        StringBuilder res= new StringBuilder();\\n        int i=0,j=0;\\n        for(;i<source.length()&&j<destination.length()  && source.charAt(i) == destination.charAt(j);i++,j++);\\n        for(int k=i;k<source.length();k++)\\n            res.append(\\'U\\');\\n        for(int k=j;k<destination.length();k++)\\n            res.append(destination.charAt(k));\\n        \\n        return res.toString();\\n    }\\n    \\n    \\n    boolean  dfs(TreeNode node,int val,StringBuilder temp){\\n        if(node==null) return false;\\n        if(node.val==val) return true;\\n        temp.append(\\'L\\');\\n        if(dfs(node.left,val,temp)) return true;\\n        temp.setCharAt(temp.length()-1,\\'R\\');\\n        if(dfs(node.right,val,temp)) return true;\\n        temp.deleteCharAt(temp.length()-1);\\n        return false;\\n        \\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1616665,
                "title": "c-simple-code",
                "content": "```\\nclass Solution {\\npublic:\\n\\n    \\n    bool findPath(TreeNode* root,int val,vector<char>& path){\\n        \\n        \\n        if(!root)return false;\\n        if(root->val==val)return true;\\n        \\n        if(findPath(root->left,val,path)){\\n            path.push_back(\\'L\\');\\n            return true;\\n        }\\n        else if(findPath(root->right,val,path)){\\n            path.push_back(\\'R\\');\\n            return true;\\n        }\\n        return false;\\n    }\\n    \\n    TreeNode* findCommon(TreeNode* root,int s,int e){\\n        \\n        if(!root)return NULL;\\n        if(root->val == s || root->val==e)return root;\\n        \\n        TreeNode* left = findCommon(root->left,s,e);\\n        TreeNode* right = findCommon(root->right,s,e);\\n        if(left && right )return root;\\n        \\n        return (left!=NULL?left:right);\\n        \\n    }\\n    \\n    string getDirections(TreeNode* root, int s, int e) {\\n        \\n        TreeNode* common = findCommon(root,s,e);\\n        vector<char> path1,path2;\\n        findPath(common,s,path1);\\n        findPath(common,e,path2);\\n        \\n \\n        string ans=\"\";\\n        int l=path1.size(),r=path2.size();\\n        for(int i=0;i<l;i++){\\n            ans+=\\'U\\';\\n        }\\n        for(int i=r-1;i>=0;i--){\\n            ans+=path2[i];\\n        }\\n        \\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    \\n    bool findPath(TreeNode* root,int val,vector<char>& path){\\n        \\n        \\n        if(!root)return false;\\n        if(root->val==val)return true;\\n        \\n        if(findPath(root->left,val,path)){\\n            path.push_back(\\'L\\');\\n            return true;\\n        }\\n        else if(findPath(root->right,val,path)){\\n            path.push_back(\\'R\\');\\n            return true;\\n        }\\n        return false;\\n    }\\n    \\n    TreeNode* findCommon(TreeNode* root,int s,int e){\\n        \\n        if(!root)return NULL;\\n        if(root->val == s || root->val==e)return root;\\n        \\n        TreeNode* left = findCommon(root->left,s,e);\\n        TreeNode* right = findCommon(root->right,s,e);\\n        if(left && right )return root;\\n        \\n        return (left!=NULL?left:right);\\n        \\n    }\\n    \\n    string getDirections(TreeNode* root, int s, int e) {\\n        \\n        TreeNode* common = findCommon(root,s,e);\\n        vector<char> path1,path2;\\n        findPath(common,s,path1);\\n        findPath(common,e,path2);\\n        \\n \\n        string ans=\"\";\\n        int l=path1.size(),r=path2.size();\\n        for(int i=0;i<l;i++){\\n            ans+=\\'U\\';\\n        }\\n        for(int i=r-1;i>=0;i--){\\n            ans+=path2[i];\\n        }\\n        \\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1614261,
                "title": "c-o-n-solution-with-clear-code",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\n    \\nprivate:\\n    bool findPath(TreeNode* root,string& ans,int& target)\\n    {\\n        if(root->val == target) return true;\\n        if(root->left && findPath(root->left,ans,target))\\n        {\\n            ans+=\"L\";\\n            return true;\\n        }\\n        if(root->right && findPath(root->right,ans,target))\\n        {\\n            ans+=\"R\";\\n            return true;\\n        }\\n        \\n        return false;\\n    }\\n    \\npublic:\\n    string getDirections(TreeNode* root, int startValue, int destValue) \\n    {\\n        string rToStart = \"\";\\n        string rToDest = \"\";\\n        \\n        findPath(root,rToStart,startValue);\\n        findPath(root,rToDest,destValue);\\n\\t\\t\\n\\t\\t\\n\\t\\t// removing the common part\\n        while(rToStart.size() > 0 && rToDest.size() > 0 && (rToStart.back() == rToDest.back()))\\n        {\\n            rToStart.pop_back();\\n            rToDest.pop_back();\\n        }\\n        \\n\\t\\t//replacing rToStart with U\\n        for(int i=0;i<rToStart.size();i++) \\n        {\\n            rToStart[i] = \\'U\\';\\n        }\\n        \\n\\t\\t//reversing the rToDest\\n        reverse(rToDest.begin(),rToDest.end());\\n\\t\\t\\n        return rToStart+rToDest;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "String",
                    "Backtracking",
                    "Tree",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\n    \\nprivate:\\n    bool findPath(TreeNode* root,string& ans,int& target)\\n    {\\n        if(root->val == target) return true;\\n        if(root->left && findPath(root->left,ans,target))\\n        {\\n            ans+=\"L\";\\n            return true;\\n        }\\n        if(root->right && findPath(root->right,ans,target))\\n        {\\n            ans+=\"R\";\\n            return true;\\n        }\\n        \\n        return false;\\n    }\\n    \\npublic:\\n    string getDirections(TreeNode* root, int startValue, int destValue) \\n    {\\n        string rToStart = \"\";\\n        string rToDest = \"\";\\n        \\n        findPath(root,rToStart,startValue);\\n        findPath(root,rToDest,destValue);\\n\\t\\t\\n\\t\\t\\n\\t\\t// removing the common part\\n        while(rToStart.size() > 0 && rToDest.size() > 0 && (rToStart.back() == rToDest.back()))\\n        {\\n            rToStart.pop_back();\\n            rToDest.pop_back();\\n        }\\n        \\n\\t\\t//replacing rToStart with U\\n        for(int i=0;i<rToStart.size();i++) \\n        {\\n            rToStart[i] = \\'U\\';\\n        }\\n        \\n\\t\\t//reversing the rToDest\\n        reverse(rToDest.begin(),rToDest.end());\\n\\t\\t\\n        return rToStart+rToDest;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1613604,
                "title": "clean-c-intuitive-single-dfs",
                "content": "\\n```\\nclass Solution {\\npublic:\\n\\nstring a=\"\";\\nstring b=\"\";\\n\\n \\xA0 pair<int, int> helper(TreeNode* root, int start, int dest)\\n    {\\n        if(root==NULL)\\n        {\\n            return {0, 0};\\n        }\\n        pair<int, int> p1 = helper(root->left, start, dest);\\n         if(p1.first == 1 && p1.second == 1)\\n        {\\n            return p1;\\n        }\\n        pair<int, int> p2 = helper(root->right, start, dest);\\n         if(p2.first == 1 && p2.second == 1)\\n        {\\n            return p2;\\n        }\\n        pair<int, int> p;\\n        p.first = (p1.first|p2.first);\\n        p.second = (p1.second|p2.second);\\n         if(p.first == 1)\\n        {\\n            a+=\\'U\\';\\n        }\\n        if(p.second == 1)\\n        {\\n            if(p1.second == 1)\\n            {\\n                b+=\\'L\\';\\n            }\\n            if(p2.second == 1)\\n            {\\n                b+=\\'R\\';\\n            }\\n        }\\n        if(root->val == start)\\n        {\\n            p.first = 1;\\n        }\\n        if(root->val == dest)\\n        {\\n            p.second = 1;\\n        }\\n       \\n        return p;\\n    }\\n    \\n    string getDirections(TreeNode* root, int startValue, int destValue) {\\n        helper(root, startValue, destValue);\\n        reverse(b.begin(), b.end());\\n        return a+b;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n\\nstring a=\"\";\\nstring b=\"\";\\n\\n \\xA0 pair<int, int> helper(TreeNode* root, int start, int dest)\\n    {\\n        if(root==NULL)\\n        {\\n            return {0, 0};\\n        }\\n        pair<int, int> p1 = helper(root->left, start, dest);\\n         if(p1.first == 1 && p1.second == 1)\\n        {\\n            return p1;\\n        }\\n        pair<int, int> p2 = helper(root->right, start, dest);\\n         if(p2.first == 1 && p2.second == 1)\\n        {\\n            return p2;\\n        }\\n        pair<int, int> p;\\n        p.first = (p1.first|p2.first);\\n        p.second = (p1.second|p2.second);\\n         if(p.first == 1)\\n        {\\n            a+=\\'U\\';\\n        }\\n        if(p.second == 1)\\n        {\\n            if(p1.second == 1)\\n            {\\n                b+=\\'L\\';\\n            }\\n            if(p2.second == 1)\\n            {\\n                b+=\\'R\\';\\n            }\\n        }\\n        if(root->val == start)\\n        {\\n            p.first = 1;\\n        }\\n        if(root->val == dest)\\n        {\\n            p.second = 1;\\n        }\\n       \\n        return p;\\n    }\\n    \\n    string getDirections(TreeNode* root, int startValue, int destValue) {\\n        helper(root, startValue, destValue);\\n        reverse(b.begin(), b.end());\\n        return a+b;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1613475,
                "title": "c-dfs-bfs",
                "content": "1. Use DFS to construct a Graph based on the Tree represented by Dictionary<int, Edge> (values mapped to Edge class that wraps the TreeNode class)\\n2. Perform BFS on the Graph from start to end value\\n3. Use BackTrace during BFS to store the directions chosen along the way. Note: There are two ways to do backtracing but Method 1 will give TLE/MLE due to the memory overhead of storing the paths so I went with Method 2 (https://stackoverflow.com/questions/8922060/how-to-trace-the-path-in-a-breadth-first-search)\\n***\\n\\t/**\\n\\t * Definition for a binary tree node.\\n\\t * public class TreeNode {\\n\\t *     public int val;\\n\\t *     public TreeNode left;\\n\\t *     public TreeNode right;\\n\\t *     public TreeNode(int val=0, TreeNode left=null, TreeNode right=null) {\\n\\t *         this.val = val;\\n\\t *         this.left = left;\\n\\t *         this.right = right;\\n\\t *     }\\n\\t * }\\n\\t */\\n\\n\\tpublic class Edge {\\n\\t\\tpublic TreeNode currentNode;\\n\\t\\tpublic TreeNode leftNode;\\n\\t\\tpublic TreeNode rightNode;\\n\\t\\tpublic TreeNode parentNode;\\n\\n\\t\\tpublic Edge(TreeNode currentNode, TreeNode leftNode, TreeNode rightNode, TreeNode parentNode) {\\n\\t\\t\\tthis.currentNode = currentNode;\\n\\t\\t\\tthis.leftNode = leftNode;\\n\\t\\t\\tthis.rightNode = rightNode;\\n\\t\\t\\tthis.parentNode = parentNode;\\n\\t\\t}\\n\\t}\\n\\tpublic class Solution {\\n\\n\\t\\tpublic string GetDirections(TreeNode root, int startValue, int destValue) {\\n\\t\\t\\tif (startValue == destValue) {\\n\\t\\t\\t\\treturn string.Empty;\\n\\t\\t\\t}\\n\\t\\t\\tDictionary<int, Edge> graph = new Dictionary<int, Edge>();\\n\\t\\t\\t// dfs to build graph dictionary of val->Node\\n\\t\\t\\tdfs(root, null, graph);\\n\\t\\t\\t// bfs through the graph starting from startValue until destValue is reached\\n\\t\\t\\treturn bfs(graph, startValue, destValue);\\n\\t\\t}\\n\\n\\t\\tpublic string bfs(Dictionary<int, Edge> graph, int startValue, int destValue) {\\n\\t\\t\\tstring result = string.Empty;\\n\\t\\t\\tQueue<Edge> q = new Queue<Edge>();\\n\\t\\t\\tDictionary<Edge, (Edge, string)> paths = new Dictionary<Edge, (Edge, string)>();\\n\\t\\t\\tq.Enqueue(graph[startValue]);\\n\\t\\t\\tHashSet<Edge> visited = new HashSet<Edge>();\\n\\t\\t\\twhile (q.Count > 0) {\\n\\t\\t\\t\\tint cnt = q.Count;\\n\\t\\t\\t\\tfor (int i = 0; i < cnt; i++) {\\n\\t\\t\\t\\t\\tEdge current = q.Dequeue();\\n\\t\\t\\t\\t\\tif (current.currentNode.val == destValue) {\\n\\t\\t\\t\\t\\t\\tresult = backTrace(paths, graph[current.currentNode.val]);\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tvisited.Add(current);\\n\\t\\t\\t\\t\\tif (current.leftNode != null && !visited.Contains(graph[current.leftNode.val])) {\\n\\t\\t\\t\\t\\t\\tpaths.Add(graph[current.leftNode.val], (current, \"L\"));\\n\\t\\t\\t\\t\\t\\tq.Enqueue(graph[current.leftNode.val]);\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tif (current.rightNode != null && !visited.Contains(graph[current.rightNode.val])) {\\n\\t\\t\\t\\t\\t\\tpaths.Add(graph[current.rightNode.val], (current, \"R\"));\\n\\t\\t\\t\\t\\t\\tq.Enqueue(graph[current.rightNode.val]);\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tif (current.parentNode != null && !visited.Contains(graph[current.parentNode.val])) {\\n\\t\\t\\t\\t\\t\\tpaths.Add(graph[current.parentNode.val], (current, \"U\"));\\n\\t\\t\\t\\t\\t\\tq.Enqueue(graph[current.parentNode.val]);\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn result;\\n\\t\\t}\\n\\n\\t\\tpublic string backTrace(Dictionary<Edge, (Edge, string)> paths, Edge end) {\\n\\t\\t\\tEdge curr = end;\\n\\t\\t\\tList<string> tracedPath = new List<string>();\\n\\t\\t\\twhile (paths.ContainsKey(curr)) {\\n\\t\\t\\t\\ttracedPath.Add(paths[curr].Item2);\\n\\t\\t\\t\\tcurr = paths[curr].Item1;\\n\\t\\t\\t}\\n\\t\\t\\ttracedPath.Reverse();\\n\\t\\t\\treturn string.Join(\"\", tracedPath);\\n\\t\\t}\\n\\n\\t\\tpublic void dfs(TreeNode root, TreeNode parent, Dictionary<int, Edge> graph) {\\n\\t\\t\\tif (root != null) {\\n\\t\\t\\t\\tif (!graph.ContainsKey(root.val)) {\\n\\t\\t\\t\\t\\tgraph.Add(root.val, new Edge(root, root.left, root.right, parent));\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tdfs(root.left, root, graph);\\n\\t\\t\\t\\tdfs(root.right, root, graph);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n***",
                "solutionTags": [
                    "Depth-First Search",
                    "Breadth-First Search"
                ],
                "code": "class Solution {\\n\\n\\t\\tpublic string GetDirections(TreeNode root, int startValue, int destValue) {\\n\\t\\t\\tif (startValue == destValue) {\\n\\t\\t\\t\\treturn string.Empty;\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1612382,
                "title": "c-bfs-dfs-solution",
                "content": "**Approach :**\\n*Note : There are better approaches available like using LCA, but this is what I came up with while solving in contest.*\\n* Converted tree to undirected/unweighted graph.\\n* Then simple bfs from source to destination and kept track of shortest path in predi[]\\n* Used predc[] to store \\'L\\', \\'R\\', \\'U\\'\\n\\n```\\nclass Solution {\\npublic:\\n    string getDirections(TreeNode* root, int startValue, int destValue) {\\n        int n = 0;\\n        dfs(root, n);\\n        vector<pair<int, char>> adj[n+1];\\n        create(root, adj);\\n        vector<bool> vis(n+1, false);\\n        vector<char> predc(n+1);\\n        vector<int> predi(n+1);\\n        string res = \"\";\\n        queue<int> q;\\n        q.push(startValue);\\n        vis[startValue] = true;\\n        predi[startValue] = -1;\\n        while(!q.empty()) {\\n            int t = q.front();\\n            q.pop();\\n            if(t == destValue) break;\\n            for(auto &it : adj[t]){\\n                if(!vis[it.first]){\\n                    vis[it.first] = true;\\n                    predc[it.first] = it.second;\\n                    predi[it.first] = t;\\n                    q.push(it.first);\\n                }\\n            }\\n        }\\n        while(predi[destValue] != -1){\\n            res += predc[destValue];\\n            destValue = predi[destValue];\\n        }\\n        reverse(res.begin(), res.end());\\n        return res;\\n    }\\n    \\n    void create(TreeNode *root, vector<pair<int, char>> adj[]){\\n        if(root == nullptr) return;\\n        if(root->left){\\n            adj[root->val].push_back({root->left->val, \\'L\\'});\\n            adj[root->left->val].push_back({root->val, \\'U\\'});\\n            create(root->left, adj);\\n        }\\n        if(root->right){\\n            adj[root->val].push_back({root->right->val, \\'R\\'});\\n            adj[root->right->val].push_back({root->val, \\'U\\'});\\n            create(root->right, adj);\\n        }\\n    }\\n    \\n    void dfs(TreeNode* root, int &n){\\n        if(root == nullptr) return;\\n        dfs(root->left, n);\\n        n++;\\n        dfs(root->right, n);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Tree",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string getDirections(TreeNode* root, int startValue, int destValue) {\\n        int n = 0;\\n        dfs(root, n);\\n        vector<pair<int, char>> adj[n+1];\\n        create(root, adj);\\n        vector<bool> vis(n+1, false);\\n        vector<char> predc(n+1);\\n        vector<int> predi(n+1);\\n        string res = \"\";\\n        queue<int> q;\\n        q.push(startValue);\\n        vis[startValue] = true;\\n        predi[startValue] = -1;\\n        while(!q.empty()) {\\n            int t = q.front();\\n            q.pop();\\n            if(t == destValue) break;\\n            for(auto &it : adj[t]){\\n                if(!vis[it.first]){\\n                    vis[it.first] = true;\\n                    predc[it.first] = it.second;\\n                    predi[it.first] = t;\\n                    q.push(it.first);\\n                }\\n            }\\n        }\\n        while(predi[destValue] != -1){\\n            res += predc[destValue];\\n            destValue = predi[destValue];\\n        }\\n        reverse(res.begin(), res.end());\\n        return res;\\n    }\\n    \\n    void create(TreeNode *root, vector<pair<int, char>> adj[]){\\n        if(root == nullptr) return;\\n        if(root->left){\\n            adj[root->val].push_back({root->left->val, \\'L\\'});\\n            adj[root->left->val].push_back({root->val, \\'U\\'});\\n            create(root->left, adj);\\n        }\\n        if(root->right){\\n            adj[root->val].push_back({root->right->val, \\'R\\'});\\n            adj[root->right->val].push_back({root->val, \\'U\\'});\\n            create(root->right, adj);\\n        }\\n    }\\n    \\n    void dfs(TreeNode* root, int &n){\\n        if(root == nullptr) return;\\n        dfs(root->left, n);\\n        n++;\\n        dfs(root->right, n);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1612331,
                "title": "c-solution-using-lca-intuitive-196ms",
                "content": "**LCA** finds the Lowest common ancestor of both the Start and Dest values.\\nOnce we find LCA , we find path to both nodes.\\n**Getpath** method stores the path in string s from root to any node present in the tree.\\n\\nPath to start is not important as we just need depth( *I have not implemented that method*). Just change all char in Path start to \\'U\\'.\\n\\nIn the end Path dest is reversed because of how the recursion method works.\\n```\\nclass Solution {\\n    \\n    private: \\n    \\n    TreeNode* LCA(TreeNode* root , int a , int b)\\n    {\\n        if(root==NULL)\\n            return NULL;\\n        \\n        if(root->val == a || root->val == b)\\n            return root;\\n        \\n        TreeNode* left = LCA(root->left , a ,b);\\n        TreeNode* right = LCA(root->right , a ,b);\\n        \\n        if(left && right)\\n            return root;\\n        \\n        if(!left)\\n            return right;\\n        \\n        return left;\\n        \\n    }\\n    string s1 = \"\";\\n    string s2 = \"\";\\n    \\n    bool getpath(TreeNode* root , int x , string& s)\\n    {\\n        if(root==NULL)\\n            return false;\\n        \\n        if(root->val == x)\\n            return true;\\n        \\n        bool left = getpath(root->left , x ,s);\\n        bool right = getpath(root->right , x ,s);\\n        \\n        if(left)\\n            s += \\'L\\';\\n        else if(right)\\n            s += \\'R\\';\\n        \\n        return left || right;\\n        \\n    }\\n    public:\\n    string getDirections(TreeNode* root, int startValue, int destValue) \\n    {\\n        TreeNode* lca = LCA(root , startValue , destValue);\\n     \\n        getpath(lca, startValue,s1);\\n        getpath(lca, destValue ,s2);\\n        \\n    \\n       for(int i = 0;i<s1.size();i++)\\n       {\\n           s1[i] = \\'U\\';\\n       }\\n        reverse(s2.begin() , s2.end());\\n        \\n        return s1+s2 ;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    \\n    private: \\n    \\n    TreeNode* LCA(TreeNode* root , int a , int b)\\n    {\\n        if(root==NULL)\\n            return NULL;\\n        \\n        if(root->val == a || root->val == b)\\n            return root;\\n        \\n        TreeNode* left = LCA(root->left , a ,b);\\n        TreeNode* right = LCA(root->right , a ,b);\\n        \\n        if(left && right)\\n            return root;\\n        \\n        if(!left)\\n            return right;\\n        \\n        return left;\\n        \\n    }\\n    string s1 = \"\";\\n    string s2 = \"\";\\n    \\n    bool getpath(TreeNode* root , int x , string& s)\\n    {\\n        if(root==NULL)\\n            return false;\\n        \\n        if(root->val == x)\\n            return true;\\n        \\n        bool left = getpath(root->left , x ,s);\\n        bool right = getpath(root->right , x ,s);\\n        \\n        if(left)\\n            s += \\'L\\';\\n        else if(right)\\n            s += \\'R\\';\\n        \\n        return left || right;\\n        \\n    }\\n    public:\\n    string getDirections(TreeNode* root, int startValue, int destValue) \\n    {\\n        TreeNode* lca = LCA(root , startValue , destValue);\\n     \\n        getpath(lca, startValue,s1);\\n        getpath(lca, destValue ,s2);\\n        \\n    \\n       for(int i = 0;i<s1.size();i++)\\n       {\\n           s1[i] = \\'U\\';\\n       }\\n        reverse(s2.begin() , s2.end());\\n        \\n        return s1+s2 ;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1612221,
                "title": "c-easy-approach-lca-pre-order-traversal-to-start-and-destination",
                "content": "\\n\\nclass Solution {\\npublic:\\n\\n    string st;\\n    vector<string> res;\\n\\t\\n    void solve(int val, TreeNode* root){             // from lca node to startNode ( it is sure it will be only \\'U\\', so find number of nodes/distance from lca node to startNode)\\n        if(root==NULL) return;\\n        if(root->val==val){\\n            res.push_back(st);\\n        }\\n        st+=\\'U\\';\\n        solve(val,  root->left);\\n        st.pop_back();\\n        st+=\\'U\\';\\n        solve(val,  root->right);\\n        st.pop_back();   \\n    }\\n\\t\\n    void solve_(int val, TreeNode* root){           //from lca node to destination node (PreOrder traversal to path taken recorded in a string)\\n        if(root==NULL) return;\\n        if(root->val==val){\\n            res.push_back(st);\\n        }\\n        st+=\\'L\\';\\n        solve_(val,  root->left);\\n        st.pop_back();\\n        st+=\\'R\\';\\n        solve_(val,  root->right);\\n        st.pop_back();\\n    }\\n    \\n    TreeNode* lowestCommonAncestor(TreeNode* root, int p, int q) {\\n        if(!root) return NULL;\\n        if(root->val==p || root->val==q) return root;\\n        TreeNode* l = lowestCommonAncestor(root->left,p,q);\\n        TreeNode* r = lowestCommonAncestor(root->right,p,q);\\n        if(l&&r) return root;\\n        else if(l) return l;\\n        else return r;\\n    }\\n    \\n    string getDirections(TreeNode* root, int startValue, int destValue) {\\n        TreeNode* ref = lowestCommonAncestor(root,startValue, destValue);\\n        string s,d;\\n        solve(startValue,ref);\\n        cout<<res[0];\\n\\n        solve_(destValue, ref);\\n        cout<<res[1]<<endl;\\n        return res[0]+res[1];\\n    }\\n};",
                "solutionTags": [
                    "Recursion"
                ],
                "code": "class Solution {\\npublic:\\n\\n    string st;\\n    vector<string> res;\\n\\t\\n    void solve(int val, TreeNode* root){             // from lca node to startNode ( it is sure it will be only \\'U\\', so find number of nodes/distance from lca node to startNode)\\n        if(root==NULL) return;\\n        if(root->val==val){\\n            res.push_back(st);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1612083,
                "title": "java-lca-and-build-path",
                "content": "```\\nclass Solution {\\n    //find the common ancerstor first \\n    public String getDirections(TreeNode root, int startValue, int destValue) {\\n        TreeNode ancestor = lowestCommonAncestor(root, startValue, destValue);\\n        \\n        String v = getPath(ancestor, startValue);\\n        StringBuilder sb = new StringBuilder();\\n        for (int i = 0; i < v.length(); i++)\\n            sb.append(\"U\");\\n        String u = getPath(ancestor, destValue);\\n        \\n        return sb.toString() + u;\\n    }\\n    \\n    private String getPath(TreeNode ancestor, int value) {\\n        if (value == ancestor.val)\\n            return \"\";\\n        \\n        //key:node, {node, 1L 2R}\\n        Map<Integer, int[]> from = new HashMap<>();\\n        Queue<TreeNode> queue = new LinkedList<>();\\n        queue.add(ancestor);\\n        while (!queue.isEmpty()) {\\n            TreeNode curr = queue.remove();\\n            if (curr.val == value)\\n                break;\\n            if (curr.left != null) {\\n                from.put(curr.left.val, new int[]{curr.val, 1});\\n                queue.add(curr.left);\\n            }\\n            if (curr.right != null) {\\n                from.put(curr.right.val, new int[]{curr.val, 2});\\n                queue.add(curr.right);\\n            } \\n        }\\n        \\n        StringBuilder sb = new StringBuilder();\\n        while (value != ancestor.val) {\\n            String direction = from.get(value)[1] == 1 ? \"L\" : \"R\";\\n            sb.append(direction);\\n            value = from.get(value)[0];\\n        }\\n        \\n        return sb.reverse().toString();\\n    }\\n    \\n    \\n    \\n    private TreeNode lowestCommonAncestor(TreeNode root, int s, int d) {\\n        if (root == null) {\\n            return root;\\n        }\\n        if (root.val == s || root.val == d) {\\n            return root;\\n        }\\n        TreeNode left = lowestCommonAncestor(root.left, s, d);\\n        TreeNode right = lowestCommonAncestor(root.right, s, d);\\n        \\n        //current root contains both p and q, is the lca node, and this is postorder\\n        if (left != null && right != null)\\n            return root;\\n        \\n        //left or right at least one of them contains lca\\n        return left == null ? right : left;\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    //find the common ancerstor first \\n    public String getDirections(TreeNode root, int startValue, int destValue) {\\n        TreeNode ancestor = lowestCommonAncestor(root, startValue, destValue);\\n        \\n        String v = getPath(ancestor, startValue);\\n        StringBuilder sb = new StringBuilder();\\n        for (int i = 0; i < v.length(); i++)\\n            sb.append(\"U\");\\n        String u = getPath(ancestor, destValue);\\n        \\n        return sb.toString() + u;\\n    }\\n    \\n    private String getPath(TreeNode ancestor, int value) {\\n        if (value == ancestor.val)\\n            return \"\";\\n        \\n        //key:node, {node, 1L 2R}\\n        Map<Integer, int[]> from = new HashMap<>();\\n        Queue<TreeNode> queue = new LinkedList<>();\\n        queue.add(ancestor);\\n        while (!queue.isEmpty()) {\\n            TreeNode curr = queue.remove();\\n            if (curr.val == value)\\n                break;\\n            if (curr.left != null) {\\n                from.put(curr.left.val, new int[]{curr.val, 1});\\n                queue.add(curr.left);\\n            }\\n            if (curr.right != null) {\\n                from.put(curr.right.val, new int[]{curr.val, 2});\\n                queue.add(curr.right);\\n            } \\n        }\\n        \\n        StringBuilder sb = new StringBuilder();\\n        while (value != ancestor.val) {\\n            String direction = from.get(value)[1] == 1 ? \"L\" : \"R\";\\n            sb.append(direction);\\n            value = from.get(value)[0];\\n        }\\n        \\n        return sb.reverse().toString();\\n    }\\n    \\n    \\n    \\n    private TreeNode lowestCommonAncestor(TreeNode root, int s, int d) {\\n        if (root == null) {\\n            return root;\\n        }\\n        if (root.val == s || root.val == d) {\\n            return root;\\n        }\\n        TreeNode left = lowestCommonAncestor(root.left, s, d);\\n        TreeNode right = lowestCommonAncestor(root.right, s, d);\\n        \\n        //current root contains both p and q, is the lca node, and this is postorder\\n        if (left != null && right != null)\\n            return root;\\n        \\n        //left or right at least one of them contains lca\\n        return left == null ? right : left;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1612045,
                "title": "c-bfs",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n     map<TreeNode*, vector<pair<TreeNode*, char>>> adj;\\n     map<TreeNode*, int> v;\\n     TreeNode* source;\\n     TreeNode* target;\\n    \\n    void traverse(TreeNode* node, int s, int t)\\n    {\\n        if(node==nullptr)\\n            return ;\\n        if(node->val==s)\\n            source = node;\\n         if(node->val==t)\\n            target = node;\\n        \\n        if(node->left)\\n        {\\n            adj[node->left].push_back({node, \\'U\\'});\\n            adj[node].push_back({node->left, \\'L\\'});\\n            \\n        }\\n         if(node->right)\\n        {\\n            adj[node->right].push_back({node, \\'U\\'});\\n            adj[node].push_back({node->right, \\'R\\'});\\n            \\n        }\\n        traverse(node->left, s, t);\\n        traverse(node->right, s, t);\\n    }\\n    \\n    string getDirections(TreeNode* root, int s, int d) {\\n        traverse(root, s, d);\\n      \\n        string ans;\\n        queue<pair<TreeNode*, string>> q;\\n        \\n        q.push({source, \"\"});\\n        v[source]=1;\\n        \\n        while(!q.empty())\\n        {\\n            auto node = q.front();\\n            int sz = q.size();\\n            q.pop();\\n            TreeNode* t = node.first;\\n            string pathTillNow = node.second;\\n            for(int i=0; i<sz; i++)\\n            {\\n                for(auto neigh : adj[t])\\n                {\\n                    if(v.find(neigh.first)==v.end())\\n                    {\\n                        string path = pathTillNow;\\n                        auto next = neigh.first;\\n                        char dir = neigh.second;\\n                        \\n                        path+=dir;\\n                        if(next==target)\\n                            return path;\\n                        else\\n                        {\\n                            q.push({next, path});\\n                            v[next]=1;\\n                        }\\n                            \\n                      \\n                    }\\n                   \\n                }\\n            }\\n            \\n       }\\n        return ans;\\n    }\\n    \\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    \\n     map<TreeNode*, vector<pair<TreeNode*, char>>> adj;\\n     map<TreeNode*, int> v;\\n     TreeNode* source;\\n     TreeNode* target;\\n    \\n    void traverse(TreeNode* node, int s, int t)\\n    {\\n        if(node==nullptr)\\n            return ;\\n        if(node->val==s)\\n            source = node;\\n         if(node->val==t)\\n            target = node;\\n        \\n        if(node->left)\\n        {\\n            adj[node->left].push_back({node, \\'U\\'}",
                "codeTag": "Java"
            },
            {
                "id": 4053378,
                "title": "c-lca-of-two-nodes-dfs-backtracking",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nFound out the LCA using recursion/dfs. Calculated the string of directions from the LCA to both the source and destination nodes using simple recursion/backtracking. If the destination is the LCA itself, we return a string of \\'U\\'s of length equal to length of path from source node to destination node. If the LCA is the source, we just return the directional string of path from the LCA to the destination. Otherwise, we concatenate the directional string of path from the LCA to the source by making it all \\'U\\'s to the directional string of the path from the LCA to the destination and return the ans.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n\\n    bool solve(TreeNode* &root, int startValue, int destValue, TreeNode* &lca) {\\n\\n        if(root == NULL) return false;\\n\\n        bool left = solve(root->left, startValue, destValue, lca);\\n\\n        bool right = solve(root->right, startValue, destValue, lca);\\n\\n        if(root->val == startValue) {\\n\\n            if(left || right) {\\n\\n                lca = root;\\n            }\\n\\n            return true;\\n\\n        }\\n\\n        if(root->val == destValue) {\\n            \\n            if(left || right) lca = root;\\n\\n            return true;\\n        }\\n\\n\\n        if(left && right) {\\n\\n            lca = root;\\n\\n            return true;\\n        }\\n\\n        if(left || right) return true;\\n\\n        return false;\\n\\n    }\\n\\n    void solve2(TreeNode* &root, string &str1, string &path, int dest) {\\n\\n        if(root->val == dest) {\\n\\n            str1 = path;\\n\\n            return;\\n        }\\n\\n        path += \\'L\\';\\n\\n        if(root->left) solve2(root->left, str1, path, dest);\\n\\n        path.pop_back();\\n\\n        path += \\'R\\';\\n\\n        if(root->right) solve2(root->right, str1, path, dest);\\n\\n        path.pop_back();\\n    }\\n    \\n    string getDirections(TreeNode* root, int startValue, int destValue) {\\n\\n        TreeNode* lca = NULL;\\n        \\n        solve(root, startValue, destValue, lca);\\n\\n        string str1= \"\";\\n\\n        string str2 = \"\";\\n\\n        string path = \"\";\\n\\n        solve2(lca, str1, path, destValue);\\n\\n        if(lca->val == startValue) return str1;\\n\\n        path = \"\";\\n\\n        solve2(lca, str2, path, startValue);\\n\\n        for(int i = 0; i < str2.length(); i++) {\\n\\n            str2[i] = \\'U\\';\\n        }\\n\\n        if(lca->val == destValue) {\\n\\n            return str2;\\n        }\\n\\n        string ans = str2 + str1;\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String",
                    "Backtracking",
                    "Tree",
                    "Depth-First Search",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n\\n    bool solve(TreeNode* &root, int startValue, int destValue, TreeNode* &lca) {\\n\\n        if(root == NULL) return false;\\n\\n        bool left = solve(root->left, startValue, destValue, lca);\\n\\n        bool right = solve(root->right, startValue, destValue, lca);\\n\\n        if(root->val == startValue) {\\n\\n            if(left || right) {\\n\\n                lca = root;\\n            }\\n\\n            return true;\\n\\n        }\\n\\n        if(root->val == destValue) {\\n            \\n            if(left || right) lca = root;\\n\\n            return true;\\n        }\\n\\n\\n        if(left && right) {\\n\\n            lca = root;\\n\\n            return true;\\n        }\\n\\n        if(left || right) return true;\\n\\n        return false;\\n\\n    }\\n\\n    void solve2(TreeNode* &root, string &str1, string &path, int dest) {\\n\\n        if(root->val == dest) {\\n\\n            str1 = path;\\n\\n            return;\\n        }\\n\\n        path += \\'L\\';\\n\\n        if(root->left) solve2(root->left, str1, path, dest);\\n\\n        path.pop_back();\\n\\n        path += \\'R\\';\\n\\n        if(root->right) solve2(root->right, str1, path, dest);\\n\\n        path.pop_back();\\n    }\\n    \\n    string getDirections(TreeNode* root, int startValue, int destValue) {\\n\\n        TreeNode* lca = NULL;\\n        \\n        solve(root, startValue, destValue, lca);\\n\\n        string str1= \"\";\\n\\n        string str2 = \"\";\\n\\n        string path = \"\";\\n\\n        solve2(lca, str1, path, destValue);\\n\\n        if(lca->val == startValue) return str1;\\n\\n        path = \"\";\\n\\n        solve2(lca, str2, path, startValue);\\n\\n        for(int i = 0; i < str2.length(); i++) {\\n\\n            str2[i] = \\'U\\';\\n        }\\n\\n        if(lca->val == destValue) {\\n\\n            return str2;\\n        }\\n\\n        string ans = str2 + str1;\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4002636,
                "title": "simple-c-code-using-lca",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n- O(n)\\n\\n- Space complexity:\\n- O(n)\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n       TreeNode* lca(TreeNode* root, int p, int q){\\n        if(!root or p==root->val or q==root->val) return root;\\n\\n        TreeNode* l=lca(root->left,p,q);\\n        TreeNode* r=lca(root->right,p,q);\\n\\n        if(!l) return r;\\n\\n        if(!r) return l;\\n\\n        return root;\\n\\n    }\\n    string t=\"\";\\n    bool flag=false;\\n    void dfs(TreeNode* root,int node,char ch,string &s){\\n        if(!root) return;\\n\\n        if(root->val==node){\\n            if(ch!=\\'#\\') s+=ch;\\n            t=s;\\n            flag=true;\\n            return;\\n        }\\n        if(ch!=\\'#\\') s+=ch;\\n\\n        dfs(root->left,node,\\'L\\',s);\\n        dfs(root->right,node,\\'R\\',s);\\n\\n        s.pop_back();\\n    }\\n    string getDirections(TreeNode* root, int st, int des) {\\n        TreeNode* start=lca(root,st,des);\\n\\n        // cout<<start->val<<\" \";\\n        string s=\"\";\\n\\n        dfs(start,des,\\'#\\',s);\\n\\n        string temp=t;\\n        s.clear();\\n\\n        dfs(start,st,\\'#\\',s);\\n\\n        string ans=\"\";\\n\\n        for(int i=0;i<t.size();i++) ans+=\\'U\\';\\n\\n        ans+=temp;\\n\\n        cout<<temp<<\" \"<<t<<endl;\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String",
                    "Tree",
                    "Depth-First Search",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n       TreeNode* lca(TreeNode* root, int p, int q){\\n        if(!root or p==root->val or q==root->val) return root;\\n\\n        TreeNode* l=lca(root->left,p,q);\\n        TreeNode* r=lca(root->right,p,q);\\n\\n        if(!l) return r;\\n\\n        if(!r) return l;\\n\\n        return root;\\n\\n    }\\n    string t=\"\";\\n    bool flag=false;\\n    void dfs(TreeNode* root,int node,char ch,string &s){\\n        if(!root) return;\\n\\n        if(root->val==node){\\n            if(ch!=\\'#\\') s+=ch;\\n            t=s;\\n            flag=true;\\n            return;\\n        }\\n        if(ch!=\\'#\\') s+=ch;\\n\\n        dfs(root->left,node,\\'L\\',s);\\n        dfs(root->right,node,\\'R\\',s);\\n\\n        s.pop_back();\\n    }\\n    string getDirections(TreeNode* root, int st, int des) {\\n        TreeNode* start=lca(root,st,des);\\n\\n        // cout<<start->val<<\" \";\\n        string s=\"\";\\n\\n        dfs(start,des,\\'#\\',s);\\n\\n        string temp=t;\\n        s.clear();\\n\\n        dfs(start,st,\\'#\\',s);\\n\\n        string ans=\"\";\\n\\n        for(int i=0;i<t.size();i++) ans+=\\'U\\';\\n\\n        ans+=temp;\\n\\n        cout<<temp<<\" \"<<t<<endl;\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3937011,
                "title": "beats-84-solution-using-dfs-c",
                "content": "# Intuition\\nThe problem requires finding the step-by-step directions from one node to another in a binary tree. You can approach this by performing Depth-First Search (DFS) to find the paths from the root to both nodes and then compare the paths to generate the final directions.\\n\\n# Approach\\n1. Initialize two `StringBuilder` objects, `startChars` and `finalChars`, to store the directions for the start and destination nodes respectively.\\n\\n2. Perform DFS to find the path from the root to the `startValue` node using the `DFS` function. While traversing the tree, append \\'L\\' or \\'R\\' to the `startChars` string depending on whether you move left or right in the tree.\\n\\n3. Similarly, perform DFS to find the path from the root to the `destValue` node using the same `DFS` function. Again, append \\'L\\' or \\'R\\' to the `finalChars` string.\\n\\n4. Remove the common path from both `startChars` and `finalChars` using the `RemoveCommonPath` function. This step ensures that you only include the directions that lead from the common ancestor to the destination.\\n\\n5. Reverse the `finalChars` string using the `ReverseSB` function. This step is required because you\\'ve traversed from the root to the destination node, and you need to reverse the directions to get the correct path from the source to the destination.\\n\\n6. Replace any remaining \\'L\\' or \\'R\\' characters in the `startChars` string with \\'U\\' (up), as the directions need to be adjusted to reflect the upward movement.\\n\\n7. Finally, return the concatenation of `startChars` and `finalChars` as the result.\\n\\n# Complexity\\n- Time complexity:\\nThe DFS function traverses the tree in a depth-first manner, visiting each node exactly once. Hence, the time complexity is O(n), where n is the number of nodes in the binary tree.\\n\\n- Space complexity:\\nThe space complexity is determined by the space used by the `StringBuilder` objects and the recursive call stack during the DFS traversal. Since you\\'re using two `StringBuilder` objects for storing directions and the maximum depth of recursion in a binary tree is O(log n) (for a balanced tree), the overall space complexity is O(n) due to the `StringBuilder` objects.\\n\\n# Code\\n```\\npublic class Solution {\\n    public string GetDirections(TreeNode root, int startValue, int destValue) {\\n        StringBuilder startChars = new(), finalChars = new();\\n        DFS(root, startValue, startChars);\\n        DFS(root, destValue, finalChars);\\n        \\n        RemoveCommonPath(startChars, finalChars);\\n        \\n        ReverseSB(finalChars);\\n\\n        startChars.Replace(\\'R\\', \\'U\\');\\n        startChars.Replace(\\'L\\', \\'U\\');\\n        return startChars.Append(finalChars).ToString();\\n    }\\n    private bool DFS(TreeNode node, int find, StringBuilder target){\\n        if(node is null) return false;\\n        if(node.val == find) return true;\\n\\n        var left = DFS(node.left, find, target);\\n        if(left) target.Append(\\'L\\');\\n        var right = DFS(node.right, find, target);\\n        if(right) target.Append(\\'R\\');\\n\\n        return left || right;\\n    }\\n\\n    private void RemoveCommonPath(StringBuilder path1, StringBuilder path2){\\n        while(path1.Length > 0 && path2.Length > 0 && path1[path1.Length - 1] == path2[path2.Length - 1]){\\n            path1.Remove(path1.Length - 1, 1);\\n            path2.Remove(path2.Length - 1, 1);\\n        }\\n    }\\n\\n    private void ReverseSB(StringBuilder path){\\n        for(int i = 0; i < path.Length / 2; i++){\\n            var temp = path[path.Length - i - 1];\\n            path[path.Length - i - 1] = path[i];\\n            path[i] = temp;\\n        }\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "C#",
                    "String",
                    "Depth-First Search"
                ],
                "code": "```\\npublic class Solution {\\n    public string GetDirections(TreeNode root, int startValue, int destValue) {\\n        StringBuilder startChars = new(), finalChars = new();\\n        DFS(root, startValue, startChars);\\n        DFS(root, destValue, finalChars);\\n        \\n        RemoveCommonPath(startChars, finalChars);\\n        \\n        ReverseSB(finalChars);\\n\\n        startChars.Replace(\\'R\\', \\'U\\');\\n        startChars.Replace(\\'L\\', \\'U\\');\\n        return startChars.Append(finalChars).ToString();\\n    }\\n    private bool DFS(TreeNode node, int find, StringBuilder target){\\n        if(node is null) return false;\\n        if(node.val == find) return true;\\n\\n        var left = DFS(node.left, find, target);\\n        if(left) target.Append(\\'L\\');\\n        var right = DFS(node.right, find, target);\\n        if(right) target.Append(\\'R\\');\\n\\n        return left || right;\\n    }\\n\\n    private void RemoveCommonPath(StringBuilder path1, StringBuilder path2){\\n        while(path1.Length > 0 && path2.Length > 0 && path1[path1.Length - 1] == path2[path2.Length - 1]){\\n            path1.Remove(path1.Length - 1, 1);\\n            path2.Remove(path2.Length - 1, 1);\\n        }\\n    }\\n\\n    private void ReverseSB(StringBuilder path){\\n        for(int i = 0; i < path.Length / 2; i++){\\n            var temp = path[path.Length - i - 1];\\n            path[path.Length - i - 1] = path[i];\\n            path[i] = temp;\\n        }\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3865047,
                "title": "java-11ms-100-dfs-while-building-l-and-r-chars-speed-optimized",
                "content": "**General explanation of code concepts:**\\n\\nThis code does a recursive Depth-First-Search (DFS) of the tree searching for the start node, destination node, and the lowest-common-ancestor node of both the start and destination node.  After finding all three of these nodes, the DFS unwinds back to the root.\\n\\nThe resultant path through the tree will start at the startNode, and ascend upward in the tree (towards the root) until reaching the lowest-common-ancestor node.  Then the path will descend downward in the tree (toward the leaves), from the lowest-common-ancestor node to the destination node.  Special cases exist where the lowest-common-ancestor node may be either the start node or the destination node.  In these special cases, there will either be no \"U\"\\'s in the answer, or no \"L\" and \"R\"\\'s in the answer.  But because the leetcode problem does NOT allow the start and destination nodes to be the same, there will never be a case where the start, destination, and lowest-common-ancestor will all be the same node.\\n\\nThe code builds the \"L\" and \"R\" characters into an array of bytes, indexed by level in the tree, while the recursive DFS searches for the destination node in the tree.  After the destination node has been found, no more \"L\" and \"R\" changes will be made.  The \"L\" and \"R\" characters are written in the `path[]` byte array.  The worst case leetcode test case has 99_999 \"L\"\\'s and \"R\"\\'s.  To avoid moving all these \"L\"\\'s and \"R\"\\'s after they are built, the code keeps them in place in the `path[]` array, puts any \"U\"\\'s before the \"L\"\\'s and \"R\"\\'s, then returns a string based directly on a portion of the `path[]` array.\\n\\n**Algorithm:**\\n1. Start the DFS, searching for the start, destination, and lowest-common-ancestor nodes.  Build the \"L\" and \"R\\' path from the root to the destination node.\\n\\t* If current node is start or destination, then save their level in the tree.\\n\\t* If not all three nodes found, \\n\\t\\t* Put an \"L\" to the path for this level, if destination not yet found, then recurse down left sub-tree.\\n\\t\\t* Put an \"R\" into the path for this level, if destination not yet found, then recurse down right sub-tree.\\n\\t* If lowest-common-ancestor not yet found, and both start and destination found, then save current level as the lowest-common-ancestor\\'s level.\\n\\t* Return from a recursion level, indicating if a start or destination node is in the sub-tree.\\n2. Put the correct number of \"U\"\\'s, if any, before the \"L\" and \"R\" path.\\n3. Return the \"U\"\\'s, and \"L\"\\'s and \"R\"\\'s as a String.\\n\\n**Coding details and apology:**\\n\\nThe code below is speed optimized, which sacrifices some of the best programming practices.  But sometimes work projects have strict timing requirements, and best programming practices may need to be sacrificed when all other optimizations fail to meet the timing requirements.  This is usually needed for real-time and embedded programming, where hardware has fixed timing requirements.  So I apologize for making ugly code for the purpose of faster runtime.\\n\\nThe code below runs as fast as 11ms in August 2023.  But usually runs in 12ms to 15ms.\\n\\nIf useful, please upvote.\\n\\n**-------- Clean Code --------**\\n```\\nclass Solution {\\n    static byte[] path = new byte[200_001];\\n    int strtLevel = -1; \\n    int destLevel = -1;\\n    int comnLevel = -1;\\n    \\n    public String getDirections(TreeNode root, int startValue, int destValue) {\\n        findPaths(root, startValue, destValue, 100_000);\\n        int answerIdx = comnLevel;\\n        for (int i = strtLevel; i > comnLevel; i--)  \\n            path[--answerIdx] = \\'U\\';\\n        return new String(path, answerIdx, destLevel - answerIdx);\\n    }\\n    \\n    private int findPaths(TreeNode node, int strtVal, int destVal, int level) {\\n        if (node == null)  return 0;\\n        int result = 0;\\n        if (node.val == strtVal) {\\n            strtLevel = level;\\n            result = 1;\\n        } else if (node.val == destVal) {\\n            destLevel = level;\\n            result = 1;\\n        }\\n        int leftFound = 0;\\n        int rightFound = 0;\\n        if (comnLevel < 0) {\\n            if (destLevel < 0)  path[level] = \\'L\\';\\n            leftFound = findPaths(node.left, strtVal, destVal, level + 1);\\n            rightFound = 0;\\n            if (comnLevel < 0) {\\n                if (destLevel < 0)  path[level] = \\'R\\';\\n                rightFound = findPaths(node.right, strtVal, destVal, level + 1);\\n            }\\n        }\\n        if (comnLevel < 0 && leftFound + rightFound + result == 2) \\n            comnLevel = level;\\n        return result | leftFound | rightFound;\\n    }\\n}\\n```\\n**-------- Commented Code --------**\\n```\\nclass Solution {\\n    static byte[] path = new byte[200_001];\\n    int strtLevel = -1;     // Tree level of the start node.\\n    int destLevel = -1;     // Tree level of the destination node.\\n    int comnLevel = -1;     // Tree level of the lowest-common-ancestor \\n                            //    of the start and destination nodes.\\n    \\n    public String getDirections(TreeNode root, int startValue, int destValue) {\\n        findPaths(root, startValue, destValue, 100_000);\\n        int answerIdx = comnLevel;\\n        // Put the \"U\"\\'s before the lowest-common-ancestor\\'s index into the \\n        // path[] array.  The number of \"U\"\\'s is: strtLevel - comnLevel.  \\n        // Leave the \"L\" and \"R\" path info from the lowest-common-ancestor \\n        // index through the destination level in path[] array.  Do NOT waste \\n        // time copying the \"L\" and \"R\" path characters from index comnLevel \\n        // through index destLevel in the path[] array.  Leave the \"L\" and \"R\" \\n        // path in place, and put the correct number of \"U\"\\'s before the \"L\" \\n        // and \"R\" characters.\\n        for (int i = strtLevel; i > comnLevel; i--)  \\n            path[--answerIdx] = \\'U\\';\\n        return new String(path, answerIdx, destLevel - answerIdx);\\n    }\\n    \\n    // Do a recursive depth-first-search for the start and destination nodes.  \\n    // Build the \"L\" and \"R\" path from the root down to the destination node.  \\n    // Return 0 if didn\\'t find any start or destination node at or below the \\n    // passed node.  Return 1 if either the start, destination, or both start \\n    // and destination nodes were found at or below the passed node.  If found \\n    // both the start node and the destination node, and no lowest-common-ancestor \\n    // to the start and destination nodes has been found, then save the passed \\n    // node\\'s level as the level of the lowest-common-ancestor.\\n    private int findPaths(TreeNode node, int strtVal, int destVal, int level) {\\n        if (node == null)  return 0;\\n        int result = 0;\\n        if (node.val == strtVal) {\\n            strtLevel = level;\\n            result = 1;\\n        } else if (node.val == destVal) {\\n            destLevel = level;\\n            result = 1;\\n        }\\n        int leftFound = 0;\\n        int rightFound = 0;\\n        if (comnLevel < 0) {\\n            if (destLevel < 0)  path[level] = \\'L\\';\\n            leftFound = findPaths(node.left, strtVal, destVal, level + 1);\\n            rightFound = 0;\\n            if (comnLevel < 0) {\\n                if (destLevel < 0)  path[level] = \\'R\\';\\n                rightFound = findPaths(node.right, strtVal, destVal, level + 1);\\n            }\\n        }\\n        if (comnLevel < 0 && leftFound + rightFound + result == 2) \\n            comnLevel = level;\\n        return result | leftFound | rightFound;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    static byte[] path = new byte[200_001];\\n    int strtLevel = -1; \\n    int destLevel = -1;\\n    int comnLevel = -1;\\n    \\n    public String getDirections(TreeNode root, int startValue, int destValue) {\\n        findPaths(root, startValue, destValue, 100_000);\\n        int answerIdx = comnLevel;\\n        for (int i = strtLevel; i > comnLevel; i--)  \\n            path[--answerIdx] = \\'U\\';\\n        return new String(path, answerIdx, destLevel - answerIdx);\\n    }\\n    \\n    private int findPaths(TreeNode node, int strtVal, int destVal, int level) {\\n        if (node == null)  return 0;\\n        int result = 0;\\n        if (node.val == strtVal) {\\n            strtLevel = level;\\n            result = 1;\\n        } else if (node.val == destVal) {\\n            destLevel = level;\\n            result = 1;\\n        }\\n        int leftFound = 0;\\n        int rightFound = 0;\\n        if (comnLevel < 0) {\\n            if (destLevel < 0)  path[level] = \\'L\\';\\n            leftFound = findPaths(node.left, strtVal, destVal, level + 1);\\n            rightFound = 0;\\n            if (comnLevel < 0) {\\n                if (destLevel < 0)  path[level] = \\'R\\';\\n                rightFound = findPaths(node.right, strtVal, destVal, level + 1);\\n            }\\n        }\\n        if (comnLevel < 0 && leftFound + rightFound + result == 2) \\n            comnLevel = level;\\n        return result | leftFound | rightFound;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    static byte[] path = new byte[200_001];\\n    int strtLevel = -1;     // Tree level of the start node.\\n    int destLevel = -1;     // Tree level of the destination node.\\n    int comnLevel = -1;     // Tree level of the lowest-common-ancestor \\n                            //    of the start and destination nodes.\\n    \\n    public String getDirections(TreeNode root, int startValue, int destValue) {\\n        findPaths(root, startValue, destValue, 100_000);\\n        int answerIdx = comnLevel;\\n        // Put the \"U\"\\'s before the lowest-common-ancestor\\'s index into the \\n        // path[] array.  The number of \"U\"\\'s is: strtLevel - comnLevel.  \\n        // Leave the \"L\" and \"R\" path info from the lowest-common-ancestor \\n        // index through the destination level in path[] array.  Do NOT waste \\n        // time copying the \"L\" and \"R\" path characters from index comnLevel \\n        // through index destLevel in the path[] array.  Leave the \"L\" and \"R\" \\n        // path in place, and put the correct number of \"U\"\\'s before the \"L\" \\n        // and \"R\" characters.\\n        for (int i = strtLevel; i > comnLevel; i--)  \\n            path[--answerIdx] = \\'U\\';\\n        return new String(path, answerIdx, destLevel - answerIdx);\\n    }\\n    \\n    // Do a recursive depth-first-search for the start and destination nodes.  \\n    // Build the \"L\" and \"R\" path from the root down to the destination node.  \\n    // Return 0 if didn\\'t find any start or destination node at or below the \\n    // passed node.  Return 1 if either the start, destination, or both start \\n    // and destination nodes were found at or below the passed node.  If found \\n    // both the start node and the destination node, and no lowest-common-ancestor \\n    // to the start and destination nodes has been found, then save the passed \\n    // node\\'s level as the level of the lowest-common-ancestor.\\n    private int findPaths(TreeNode node, int strtVal, int destVal, int level) {\\n        if (node == null)  return 0;\\n        int result = 0;\\n        if (node.val == strtVal) {\\n            strtLevel = level;\\n            result = 1;\\n        } else if (node.val == destVal) {\\n            destLevel = level;\\n            result = 1;\\n        }\\n        int leftFound = 0;\\n        int rightFound = 0;\\n        if (comnLevel < 0) {\\n            if (destLevel < 0)  path[level] = \\'L\\';\\n            leftFound = findPaths(node.left, strtVal, destVal, level + 1);\\n            rightFound = 0;\\n            if (comnLevel < 0) {\\n                if (destLevel < 0)  path[level] = \\'R\\';\\n                rightFound = findPaths(node.right, strtVal, destVal, level + 1);\\n            }\\n        }\\n        if (comnLevel < 0 && leftFound + rightFound + result == 2) \\n            comnLevel = level;\\n        return result | leftFound | rightFound;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3492974,
                "title": "python3-bfs",
                "content": "\\n\\n# Code\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def getDirections(self, root: Optional[TreeNode], startValue: int, destValue: int) -> str:\\n        \\n        adj=defaultdict(list)\\n        \\n        def dfs(root):\\n            if not root:\\n                return\\n            if root.left:\\n                adj[root.val].append((root.left.val,\"L\"))\\n                adj[root.left.val].append((root.val,\"U\"))\\n                dfs(root.left)\\n            if root.right:\\n                adj[root.val].append((root.right.val,\"R\"))\\n                adj[root.right.val].append((root.val,\"U\"))\\n                dfs(root.right)\\n        \\n        dfs(root)\\n\\n        \\n        q=deque()\\n        q.append((startValue,\"\"))\\n        visited=set([startValue])\\n        \\n        \\n        \\n        while q:\\n            for i in range(len(q)):\\n                node,s=q.popleft()\\n                if node==destValue:\\n                    return s\\n\\n                for child,st in adj[node]:\\n                    if child not in visited:\\n                        visited.add(child)\\n                        q.append((child,s+st))\\n                    \\n                    \\n                    \\n                    \\n                    \\n                    \\n                    \\n                    \\n                    \\n                    \\n                    \\n                    \\n                    \\n                    \\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Breadth-First Search"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def getDirections(self, root: Optional[TreeNode], startValue: int, destValue: int) -> str:\\n        \\n        adj=defaultdict(list)\\n        \\n        def dfs(root):\\n            if not root:\\n                return\\n            if root.left:\\n                adj[root.val].append((root.left.val,\"L\"))\\n                adj[root.left.val].append((root.val,\"U\"))\\n                dfs(root.left)\\n            if root.right:\\n                adj[root.val].append((root.right.val,\"R\"))\\n                adj[root.right.val].append((root.val,\"U\"))\\n                dfs(root.right)\\n        \\n        dfs(root)\\n\\n        \\n        q=deque()\\n        q.append((startValue,\"\"))\\n        visited=set([startValue])\\n        \\n        \\n        \\n        while q:\\n            for i in range(len(q)):\\n                node,s=q.popleft()\\n                if node==destValue:\\n                    return s\\n\\n                for child,st in adj[node]:\\n                    if child not in visited:\\n                        visited.add(child)\\n                        q.append((child,s+st))\\n                    \\n                    \\n                    \\n                    \\n                    \\n                    \\n                    \\n                    \\n                    \\n                    \\n                    \\n                    \\n                    \\n                    \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2899152,
                "title": "bfs-lca",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nUsing Lowest common ancestor, DFS.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe shortest path between any two nodes in a tree must pass through LCA. Hence,\\n- Find LCA\\n- Path of element left to LCA\\n- Path of element right to LCS\\n\\nNow, replace \"L\"/\"R\" with \"U\" in the path of sourcePoint. Combine sourcePath to destinationPath.\\n\\n# Code\\n```\\nfrom queue import Queue\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def getDirections(self, root: Optional[TreeNode], sv: int, dv: int) -> str:\\n\\n        q = []\\n        q.append([root, \"\"])\\n        p1, p2, p1f, p2f = [], [], False, False\\n        while len(q) != 0:\\n            t = q.pop()\\n            if p1f and p2f:\\n                break\\n\\n            if not p1f and t[0].val == sv:\\n                p1f, p1 = True, t[1]\\n\\n            if not p2f and t[0].val == dv:\\n                p2f, p2 = True, t[1]\\n\\n            if t[0].left != None:\\n                q.append([t[0].left, t[1] + \"L\"])\\n            if t[0].right != None:\\n                q.append([t[0].right, t[1] + \"R\"])\\n\\n        i1, i2 = 0, 0\\n        while i1 < len(p1) and i2 < len(p2) and p1[i1] == p2[i2]:\\n            i1, i2 = i1+1, i2+1\\n        return \\'\\'.join(\"U\" for i in range(i1, len(p1))) + \\'\\'.join(i for i in p2[i2:])\\n\\n        \\n        \\n\\n\\n\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nfrom queue import Queue\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def getDirections(self, root: Optional[TreeNode], sv: int, dv: int) -> str:\\n\\n        q = []\\n        q.append([root, \"\"])\\n        p1, p2, p1f, p2f = [], [], False, False\\n        while len(q) != 0:\\n            t = q.pop()\\n            if p1f and p2f:\\n                break\\n\\n            if not p1f and t[0].val == sv:\\n                p1f, p1 = True, t[1]\\n\\n            if not p2f and t[0].val == dv:\\n                p2f, p2 = True, t[1]\\n\\n            if t[0].left != None:\\n                q.append([t[0].left, t[1] + \"L\"])\\n            if t[0].right != None:\\n                q.append([t[0].right, t[1] + \"R\"])\\n\\n        i1, i2 = 0, 0\\n        while i1 < len(p1) and i2 < len(p2) and p1[i1] == p2[i2]:\\n            i1, i2 = i1+1, i2+1\\n        return \\'\\'.join(\"U\" for i in range(i1, len(p1))) + \\'\\'.join(i for i in p2[i2:])\\n\\n        \\n        \\n\\n\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2755999,
                "title": "shortest-path-bfs-c-dijkstra",
                "content": "An Easy Simple approach of converting tree to graph and finding the shortest path using bfs or Dijskstra\\'s Algorithm.\\n\\n```\\nclass Solution {\\npublic:\\n    //Building the Graph\\n    void dfs(TreeNode *root , unordered_map<int , vector<pair<int , char>>> &g){\\n        if(!root)\\n            return;\\n        if(root->left){\\n            g[root->val].push_back({root->left->val , \\'L\\'});\\n            g[root->left->val].push_back({root->val , \\'U\\'});\\n        }\\n        if(root->right){\\n             g[root->val].push_back({root->right->val , \\'R\\'});\\n             g[root->right->val].push_back({root->val , \\'U\\'});\\n        }\\n        dfs(root->left , g);\\n        dfs(root->right , g);\\n        return;\\n    }\\n    //Finding Shortest Path\\n    string bfs(unordered_map<int , vector<pair<int , char>>> &g , int src , int end){\\n        vector<int> dis(g.size() + 1 , (int)1e9);\\n        unordered_map<int , pair<int , char>> path;\\n        dis[src] = 0;\\n        queue<int> q;\\n        q.push(src);\\n        while(!q.empty()){\\n            int node = q.front();\\n            q.pop();\\n            for(auto &[adj_node , dir] : g[node]){\\n                if(dis[adj_node] > dis[node] + 1){\\n                    dis[adj_node] = dis[node] + 1;\\n                    path[adj_node] = {node , dir};\\n                    q.push(adj_node);\\n                }\\n            }\\n        }\\n        string s{\"\"};\\n        while(1){\\n            if(end == src){\\n                break;\\n            }\\n            int x = path[end].first;\\n            s += path[end].second;\\n            end = x;\\n        }\\n        reverse(s.begin() , s.end());\\n        return s;\\n    }\\n    string getDirections(TreeNode* root, int startValue, int destValue) {\\n        unordered_map<int , vector<pair<int , char>>> g;\\n        dfs(root , g);        \\n        return bfs(g , startValue , destValue);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "String",
                    "Tree",
                    "Breadth-First Search",
                    "Graph",
                    "Shortest Path"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    //Building the Graph\\n    void dfs(TreeNode *root , unordered_map<int , vector<pair<int , char>>> &g){\\n        if(!root)\\n            return;\\n        if(root->left){\\n            g[root->val].push_back({root->left->val , \\'L\\'});\\n            g[root->left->val].push_back({root->val , \\'U\\'});\\n        }\\n        if(root->right){\\n             g[root->val].push_back({root->right->val , \\'R\\'});\\n             g[root->right->val].push_back({root->val , \\'U\\'});\\n        }\\n        dfs(root->left , g);\\n        dfs(root->right , g);\\n        return;\\n    }\\n    //Finding Shortest Path\\n    string bfs(unordered_map<int , vector<pair<int , char>>> &g , int src , int end){\\n        vector<int> dis(g.size() + 1 , (int)1e9);\\n        unordered_map<int , pair<int , char>> path;\\n        dis[src] = 0;\\n        queue<int> q;\\n        q.push(src);\\n        while(!q.empty()){\\n            int node = q.front();\\n            q.pop();\\n            for(auto &[adj_node , dir] : g[node]){\\n                if(dis[adj_node] > dis[node] + 1){\\n                    dis[adj_node] = dis[node] + 1;\\n                    path[adj_node] = {node , dir};\\n                    q.push(adj_node);\\n                }\\n            }\\n        }\\n        string s{\"\"};\\n        while(1){\\n            if(end == src){\\n                break;\\n            }\\n            int x = path[end].first;\\n            s += path[end].second;\\n            end = x;\\n        }\\n        reverse(s.begin() , s.end());\\n        return s;\\n    }\\n    string getDirections(TreeNode* root, int startValue, int destValue) {\\n        unordered_map<int , vector<pair<int , char>>> g;\\n        dfs(root , g);        \\n        return bfs(g , startValue , destValue);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2656962,
                "title": "python-graph-bfs-easy-to-understand",
                "content": "```\\nclass Solution:\\n    def __init__(self):\\n        self.graph = defaultdict(list)\\n    def getDirections(self, root: Optional[TreeNode], startValue: int, destValue: int) -> str:\\n\\t\\t# make a graph\\n        self.connect(None, root, \"\")\\n\\t\\t# BFS Traversal \\n        visited = {startValue}\\n        queue = collections.deque([(startValue, \"\")])\\n        while queue:\\n            node, curr = queue.popleft()\\n            if node == destValue:\\n                return curr\\n            for nxt, direction in self.graph[node]:\\n                if nxt not in visited:\\n                    visited.add(nxt)\\n                    queue.append((nxt, curr + direction))\\n                    \\n    def connect(self, parent, child, direction):\\n\\t\\t# shoud the moving direction inserting the node in the graph\\n        if parent and child:\\n            self.graph[parent.val].append((child.val, direction))\\n            self.graph[child.val].append((parent.val, \"U\"))\\n        if child.left:\\n            self.connect(child, child.left, \"L\")\\n        if child.right:\\n            self.connect(child, child.right, \"R\")\\n```",
                "solutionTags": [
                    "Python",
                    "Breadth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution:\\n    def __init__(self):\\n        self.graph = defaultdict(list)\\n    def getDirections(self, root: Optional[TreeNode], startValue: int, destValue: int) -> str:\\n\\t\\t# make a graph\\n        self.connect(None, root, \"\")\\n\\t\\t# BFS Traversal \\n        visited = {startValue}\\n        queue = collections.deque([(startValue, \"\")])\\n        while queue:\\n            node, curr = queue.popleft()\\n            if node == destValue:\\n                return curr\\n            for nxt, direction in self.graph[node]:\\n                if nxt not in visited:\\n                    visited.add(nxt)\\n                    queue.append((nxt, curr + direction))\\n                    \\n    def connect(self, parent, child, direction):\\n\\t\\t# shoud the moving direction inserting the node in the graph\\n        if parent and child:\\n            self.graph[parent.val].append((child.val, direction))\\n            self.graph[child.val].append((parent.val, \"U\"))\\n        if child.left:\\n            self.connect(child, child.left, \"L\")\\n        if child.right:\\n            self.connect(child, child.right, \"R\")\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2617893,
                "title": "python-two-dfs-functions",
                "content": "Logic:\\n\\t1. Find the list of all parents of the startValue (one the parents of the startValue is the Lowest common ancestor of startValue and destValue)\\n\\t2. Starting from startNode, for each parent, check if the destinaton node can be found using dfs:\\n\\t3. If the destination node cannot be found starting from the current parent, append \"U\" to the answer and check for the higher parents until the root node.\\n\\t4. If the destination node can be found starting from the current parent, break the loop and return your answer\\n\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def getDirections(self, root: Optional[TreeNode], startValue: int, destValue: int) -> str:\\n        parents = []\\n        def collectParents(node):\\n            parents.append(node)\\n            if node.val == startValue:\\n                return True\\n            \\n            if node.left and collectParents(node.left):\\n                return True\\n            \\n            if node.right and collectParents(node.right):\\n                return True\\n            \\n            parents.pop()\\n            return False\\n        \\n        ans = []\\n        visited = set()\\n        def findPath(node, side = None):\\n            if node.val not in visited:\\n                if side:\\n                    ans.append(side)\\n                if node.val == destValue:\\n                    return True\\n\\n                if node.left and findPath(node.left, \"L\"):\\n                    return True\\n\\n                if node.right and findPath(node.right, \"R\"):\\n                    return True\\n                if side:\\n                    ans.pop()\\n                return False\\n            \\n        collectParents(root)\\n        \\n        for parent in reversed(parents):\\n            found = findPath(parent)\\n            if found:\\n                break\\n            visited.add(parent.val)\\n            ans.append(\"U\")\\n            \\n        return \"\".join(ans)\\n\\n# time and space complexity\\n# time: O(nlogn)\\n# space O(n)\\n```",
                "solutionTags": [
                    "Python",
                    "Backtracking",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def getDirections(self, root: Optional[TreeNode], startValue: int, destValue: int) -> str:\\n        parents = []\\n        def collectParents(node):\\n            parents.append(node)\\n            if node.val == startValue:\\n                return True\\n            \\n            if node.left and collectParents(node.left):\\n                return True\\n            \\n            if node.right and collectParents(node.right):\\n                return True\\n            \\n            parents.pop()\\n            return False\\n        \\n        ans = []\\n        visited = set()\\n        def findPath(node, side = None):\\n            if node.val not in visited:\\n                if side:\\n                    ans.append(side)\\n                if node.val == destValue:\\n                    return True\\n\\n                if node.left and findPath(node.left, \"L\"):\\n                    return True\\n\\n                if node.right and findPath(node.right, \"R\"):\\n                    return True\\n                if side:\\n                    ans.pop()\\n                return False\\n            \\n        collectParents(root)\\n        \\n        for parent in reversed(parents):\\n            found = findPath(parent)\\n            if found:\\n                break\\n            visited.add(parent.val)\\n            ans.append(\"U\")\\n            \\n        return \"\".join(ans)\\n\\n# time and space complexity\\n# time: O(nlogn)\\n# space O(n)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2610450,
                "title": "c-short-easy-code",
                "content": "```\\nclass Solution {\\npublic:\\n    string left=\"\";\\n    string right=\"\";\\n\\t\\n\\t//use string push_back and pop_back for timecomplexity and also the root->left and root->right null check for better timecomplexity as you know it takes a\\n\\t//long time to check each null in the tree leaf node\\n\\t\\n        void fun(TreeNode* root,int s,int d,string &str){\\n            if(root==NULL){\\n                return;\\n            }\\n            if(s==-1 && d==-1){\\n                return;\\n            }\\n            if(root->val==s && s!=-1){\\n                s=-1;\\n                left=str;\\n            }\\n            if(root->val==d && d!=-1){\\n                d=-1;\\n                right=str;\\n            }\\n            if(root->left){\\n                str.push_back(\\'L\\');\\n            fun(root->left,s,d,str);\\n                        str.pop_back();}\\n            if(s==-1 && d==-1){\\n                return;\\n            }\\n            if(root->right){\\n            str.push_back(\\'R\\');\\n            fun(root->right,s,d,str);\\n            str.pop_back();\\n            }\\n            if(s==-1 && d==-1){\\n                return;\\n            }\\n        }\\n    string getDirections(TreeNode* root, int startValue, int destValue) {\\n        string str=\"\",ans=\"\";\\n        fun(root,startValue,destValue,str);// made a search for the direction of the value from root and \\n\\t\\t//stored it in the global variable left and right \\n        int ll=left.length();\\n        int rl=right.length();\\n        int count=0;\\n\\t\\t//now i count upto which index will the left and right string be equal and keep the count\\n        for(int i=0;i<min(ll,rl);i++){\\n            if(left[i]!=right[i]){\\n                break;\\n            }\\n            count++;\\n        }\\n\\t\\t//now i have got the lowest common ancestor place \\n\\t\\t//so start part all will be U and left dest side as it is combine both and voila\\n        for(int i=count;i<ll;i++){\\n            ans.push_back(\\'U\\');\\n        }\\n        for(int i=count;i<rl;i++){\\n            ans.push_back(right[i]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string left=\"\";\\n    string right=\"\";\\n\\t\\n\\t//use string push_back and pop_back for timecomplexity and also the root->left and root->right null check for better timecomplexity as you know it takes a\\n\\t//long time to check each null in the tree leaf node\\n\\t\\n        void fun(TreeNode* root,int s,int d,string &str){\\n            if(root==NULL){\\n                return;\\n            }\\n            if(s==-1 && d==-1){\\n                return;\\n            }\\n            if(root->val==s && s!=-1){\\n                s=-1;\\n                left=str;\\n            }\\n            if(root->val==d && d!=-1){\\n                d=-1;\\n                right=str;\\n            }\\n            if(root->left){\\n                str.push_back(\\'L\\');\\n            fun(root->left,s,d,str);\\n                        str.pop_back();}\\n            if(s==-1 && d==-1){\\n                return;\\n            }\\n            if(root->right){\\n            str.push_back(\\'R\\');\\n            fun(root->right,s,d,str);\\n            str.pop_back();\\n            }\\n            if(s==-1 && d==-1){\\n                return;\\n            }\\n        }\\n    string getDirections(TreeNode* root, int startValue, int destValue) {\\n        string str=\"\",ans=\"\";\\n        fun(root,startValue,destValue,str);// made a search for the direction of the value from root and \\n\\t\\t//stored it in the global variable left and right \\n        int ll=left.length();\\n        int rl=right.length();\\n        int count=0;\\n\\t\\t//now i count upto which index will the left and right string be equal and keep the count\\n        for(int i=0;i<min(ll,rl);i++){\\n            if(left[i]!=right[i]){\\n                break;\\n            }\\n            count++;\\n        }\\n\\t\\t//now i have got the lowest common ancestor place \\n\\t\\t//so start part all will be U and left dest side as it is combine both and voila\\n        for(int i=count;i<ll;i++){\\n            ans.push_back(\\'U\\');\\n        }\\n        for(int i=count;i<rl;i++){\\n            ans.push_back(right[i]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2608611,
                "title": "java-deque-dfs-solution-with-very-detailed-explanation",
                "content": "This solution is 58.7% faster than Java submissions, memory usage less than 87.95% of Java submissions\\n\\nThe idea is to use DFS to locate both start and dest nodes, create 2 Deque, one to store path from root to start node, another one to store path from root to dest node (element in Deque has direction as well). To improve performance, we look for both node at the same time and stop DFS if both nodes are located.\\n\\nOnce we have populated above 2 Deque, start from beginning of 2 Deque, remove elements with same value because these are common path for 2 nodes. We then get each element out of both Deque and construct shortest path.\\n\\nTherefore, for the Example 1, after we locate 2 nodes, we have\\nstartDeque = 5 -> 1 -> 3\\ndestDeque = (5, null) -> (2, \\'R\\') -> (6, \\'L\\')\\n\\nwe remove common path from begining of Deque, we have\\nstartDeque = 1 -> 3\\ndestDeque = (2, \\'R\\') -> (6, \\'L\\')\\n\\nThen we construct shortest path from elements of above 2 Deque, we have: U -> U -> R-> L\\n\\n```\\nclass Solution {\\n    Deque<Integer> startDeque = new LinkedList<>();\\n    Deque<Direction> destDeque = new LinkedList<>();\\n    boolean locatedStart = false;\\n    boolean locatedDest = false;\\n    StringBuilder path = new StringBuilder();\\n    public String getDirections(TreeNode root, int startValue, int destValue) {\\n        locateNodes(root, startValue, destValue, null);\\n        \\n\\t\\t// remove common path of two nodes, remaining are shortest path\\n        while (!startDeque.isEmpty() && !destDeque.isEmpty() && startDeque.peekFirst() == destDeque.peekFirst().val) {\\n            startDeque.pollFirst();\\n            destDeque.pollFirst();\\n        }\\n        \\n\\t\\t// start to construct path out of remaining elements of 2 Deque\\n        while (startDeque.pollFirst() != null) path.append(\"U\");\\n        while (destDeque.peekFirst() != null) {\\n            path.append(destDeque.pollFirst().dir);\\n        }\\n        \\n        return path.toString();\\n    }\\n    \\n    private void locateNodes(TreeNode node, int startValue, int destValue, Character dir) {\\n\\t    // visit a new node, add to both Deque if they haven\\'t been located\\n        if (!locatedStart) startDeque.offerLast(node.val);\\n        if (!locatedDest) destDeque.offerLast(new Direction(node.val, dir));\\n        \\n\\t\\t// if we locate nodes, mark it as found so we can skip manipulation of Deque\\n        if (node.val == startValue) locatedStart = true;\\n        if (node.val == destValue) locatedDest = true;\\n        \\n\\t\\t// if both nodes are found, stop iteration\\n        if (locatedStart && locatedDest) return;\\n        \\n\\t\\t// if left child is not null, continue DFS with left child\\n        if (node.left != null) {\\n            locateNodes(node.left, startValue, destValue, \\'L\\');\\n            if (!locatedStart) startDeque.pollLast();\\n            if (!locatedDest) destDeque.pollLast();\\n        }\\n        \\n\\t\\t// if right child is not null, continue DFS with right child\\n        if (node.right != null) {\\n            locateNodes(node.right, startValue, destValue, \\'R\\');\\n            if (!locatedStart) startDeque.pollLast();\\n            if (!locatedDest) destDeque.pollLast();\\n        }\\n    }\\n}\\n\\nclass Direction {\\n    int val;\\n    Character dir;\\n    \\n    public Direction(int val, Character dir) {\\n        this.val = val;\\n        this.dir = dir;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    Deque<Integer> startDeque = new LinkedList<>();\\n    Deque<Direction> destDeque = new LinkedList<>();\\n    boolean locatedStart = false;\\n    boolean locatedDest = false;\\n    StringBuilder path = new StringBuilder();\\n    public String getDirections(TreeNode root, int startValue, int destValue) {\\n        locateNodes(root, startValue, destValue, null);\\n        \\n\\t\\t// remove common path of two nodes, remaining are shortest path\\n        while (!startDeque.isEmpty() && !destDeque.isEmpty() && startDeque.peekFirst() == destDeque.peekFirst().val) {\\n            startDeque.pollFirst();\\n            destDeque.pollFirst();\\n        }\\n        \\n\\t\\t// start to construct path out of remaining elements of 2 Deque\\n        while (startDeque.pollFirst() != null) path.append(\"U\");\\n        while (destDeque.peekFirst() != null) {\\n            path.append(destDeque.pollFirst().dir);\\n        }\\n        \\n        return path.toString();\\n    }\\n    \\n    private void locateNodes(TreeNode node, int startValue, int destValue, Character dir) {\\n\\t    // visit a new node, add to both Deque if they haven\\'t been located\\n        if (!locatedStart) startDeque.offerLast(node.val);\\n        if (!locatedDest) destDeque.offerLast(new Direction(node.val, dir));\\n        \\n\\t\\t// if we locate nodes, mark it as found so we can skip manipulation of Deque\\n        if (node.val == startValue) locatedStart = true;\\n        if (node.val == destValue) locatedDest = true;\\n        \\n\\t\\t// if both nodes are found, stop iteration\\n        if (locatedStart && locatedDest) return;\\n        \\n\\t\\t// if left child is not null, continue DFS with left child\\n        if (node.left != null) {\\n            locateNodes(node.left, startValue, destValue, \\'L\\');\\n            if (!locatedStart) startDeque.pollLast();\\n            if (!locatedDest) destDeque.pollLast();\\n        }\\n        \\n\\t\\t// if right child is not null, continue DFS with right child\\n        if (node.right != null) {\\n            locateNodes(node.right, startValue, destValue, \\'R\\');\\n            if (!locatedStart) startDeque.pollLast();\\n            if (!locatedDest) destDeque.pollLast();\\n        }\\n    }\\n}\\n\\nclass Direction {\\n    int val;\\n    Character dir;\\n    \\n    public Direction(int val, Character dir) {\\n        this.val = val;\\n        this.dir = dir;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2601680,
                "title": "c-beats-95-dfs-method-largest-common-prefix-lca-easy-explanation-less-memory",
                "content": "The idea is to encode the root to target node paths as sequences of Left (L) or Right (R) decisions taken prepending the root prefix ($) to these sequences for both source and destination node, and then strip the largest common prefix in the two sequences , which eliminates the path from root to lowest common ancestor in the tree , then for remaining part of sequences we need to construct our result by taking steps towards UP (U) from source node so that we reach the LCA node and then append the remaining sequence of target node to it.\\n  \\n\\n```\\nclass Solution {\\n    string left, right;\\n    \\n    void getPathUtil(TreeNode *root, string &pre, int start, int end){\\n        if(!root){\\n            return ;\\n        }\\n        if(root->val == start){\\n            left = pre;\\n        }\\n        if(root -> val == end){\\n            right = pre;\\n        }\\n        pre.push_back(\\'L\\');\\n        getPathUtil(root->left, pre, start, end);\\n        pre.pop_back();\\n        pre.push_back(\\'R\\');\\n        getPathUtil(root->right, pre, start, end);\\n        pre.pop_back();\\n    }\\n    \\npublic:\\n    string getDirections(TreeNode* root, int startValue, int destValue) {\\n        string r = \"$\", ans = \"\";\\n        getPathUtil(root, r, startValue, destValue);\\n        \\n        int i, ls = left.size(), rs = right.size();\\n        for(i = 0; i < ls; i++){\\n            if(left[i] != right[i]){\\n                break;\\n            }\\n        }\\n        \\n        int x = i; \\n        for(; x < ls; x++){\\n            ans.push_back(\\'U\\');\\n        }\\n        x = i;\\n        for(; x < rs; x++){\\n            ans.push_back(right[x]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    string left, right;\\n    \\n    void getPathUtil(TreeNode *root, string &pre, int start, int end){\\n        if(!root){\\n            return ;\\n        }\\n        if(root->val == start){\\n            left = pre;\\n        }\\n        if(root -> val == end){\\n            right = pre;\\n        }\\n        pre.push_back(\\'L\\');\\n        getPathUtil(root->left, pre, start, end);\\n        pre.pop_back();\\n        pre.push_back(\\'R\\');\\n        getPathUtil(root->right, pre, start, end);\\n        pre.pop_back();\\n    }\\n    \\npublic:\\n    string getDirections(TreeNode* root, int startValue, int destValue) {\\n        string r = \"$\", ans = \"\";\\n        getPathUtil(root, r, startValue, destValue);\\n        \\n        int i, ls = left.size(), rs = right.size();\\n        for(i = 0; i < ls; i++){\\n            if(left[i] != right[i]){\\n                break;\\n            }\\n        }\\n        \\n        int x = i; \\n        for(; x < ls; x++){\\n            ans.push_back(\\'U\\');\\n        }\\n        x = i;\\n        for(; x < rs; x++){\\n            ans.push_back(right[x]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2558490,
                "title": "easy-dfs-solution",
                "content": "While other soutions might be more succinct, their implementation is not straight forward to understand.\\n\\nMy solutions comprises two steps:\\n\\n- Traverse the tree and convert it to a regular graph with directions (e.g. \"U\",\"L\",\"R\")\\n- Take note of the start node when you see it\\n- BFS or DFS again from the start node to the end node to build the path. Because this is a Tree, there is only one solution.\\n\\n\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def getDirections(self, root: Optional[TreeNode], startValue: int, destValue: int) -> str:\\n        graph = collections.defaultdict(list)\\n        # key: [(node,direction),()]\\n        \\n        startNode = None\\n        def traverse(root,parent):\\n            nonlocal startNode\\n            if not root:\\n                return\\n            \\n            if root.val == startValue:\\n                startNode = root\\n                \\n            graph[root].append((parent,\"U\"))\\n            if root.left:    \\n                graph[root].append((root.left,\"L\"))\\n                traverse(root.left,root)\\n            if root.right:\\n                graph[root].append((root.right,\"R\"))\\n                traverse(root.right,root)\\n            \\n        traverse(root,None)\\n        \\n        \\n        stack = [(startNode,\"\")]\\n        seen = set()\\n        seen.add(startNode)\\n        \\n        while stack:\\n            cur,path = stack.pop()\\n            if cur.val == destValue:\\n                return path\\n            for nxt,direction in graph[cur]:\\n                if nxt not in seen:\\n                    seen.add(nxt)\\n                    new_path = path + direction\\n                    stack.append((nxt,new_path))\\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Depth-First Search",
                    "Breadth-First Search"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def getDirections(self, root: Optional[TreeNode], startValue: int, destValue: int) -> str:\\n        graph = collections.defaultdict(list)\\n        # key: [(node,direction),()]\\n        \\n        startNode = None\\n        def traverse(root,parent):\\n            nonlocal startNode\\n            if not root:\\n                return\\n            \\n            if root.val == startValue:\\n                startNode = root\\n                \\n            graph[root].append((parent,\"U\"))\\n            if root.left:    \\n                graph[root].append((root.left,\"L\"))\\n                traverse(root.left,root)\\n            if root.right:\\n                graph[root].append((root.right,\"R\"))\\n                traverse(root.right,root)\\n            \\n        traverse(root,None)\\n        \\n        \\n        stack = [(startNode,\"\")]\\n        seen = set()\\n        seen.add(startNode)\\n        \\n        while stack:\\n            cur,path = stack.pop()\\n            if cur.val == destValue:\\n                return path\\n            for nxt,direction in graph[cur]:\\n                if nxt not in seen:\\n                    seen.add(nxt)\\n                    new_path = path + direction\\n                    stack.append((nxt,new_path))\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2536422,
                "title": "simple-java-code-base-on-hints",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public String getDirections(TreeNode root, int startValue, int destValue) {\\n       StringBuilder startPath = new StringBuilder();\\n       StringBuilder destPath = new StringBuilder();\\n       StringBuilder res = new StringBuilder();\\n        \\n       dfs(root,startPath,startValue);\\n       dfs(root,destPath,destValue);\\n       startPath.reverse(); destPath.reverse(); \\n       \\n        int minLen = Math.min(startPath.length(), destPath.length());\\n        \\n        int i = 0;\\n        while(i<minLen) {\\n            if(startPath.charAt(i)!=destPath.charAt(i))\\n                break;\\n            i++;\\n        }\\n        \\n        for(int j=i;j<startPath.length();j++)\\n            res.append(\"U\");\\n        \\n        res.append(destPath.substring(i,destPath.length()));\\n        \\n        return res.toString();\\n        \\n    }  \\n    \\n    \\n    public boolean dfs(TreeNode root, StringBuilder sb, int target) {\\n        \\n        if(root==null)\\n            return false;\\n        \\n        if(root.val==target)\\n            return true;\\n        \\n        if(dfs(root.left,sb,target)) {\\n            sb.append(\"L\");\\n            return true;\\n        }\\n        \\n        if(dfs(root.right,sb,target)) {\\n            sb.append(\"R\");\\n            return true;\\n        }\\n        \\n        return false;\\n    }\\n    \\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public String getDirections(TreeNode root, int startValue, int destValue) {\\n       StringBuilder startPath = new StringBuilder();\\n       StringBuilder destPath = new StringBuilder();\\n       StringBuilder res = new StringBuilder();\\n        \\n       dfs(root,startPath,startValue);\\n       dfs(root,destPath,destValue);\\n       startPath.reverse(); destPath.reverse(); \\n       \\n        int minLen = Math.min(startPath.length(), destPath.length());\\n        \\n        int i = 0;\\n        while(i<minLen) {\\n            if(startPath.charAt(i)!=destPath.charAt(i))\\n                break;\\n            i++;\\n        }\\n        \\n        for(int j=i;j<startPath.length();j++)\\n            res.append(\"U\");\\n        \\n        res.append(destPath.substring(i,destPath.length()));\\n        \\n        return res.toString();\\n        \\n    }  \\n    \\n    \\n    public boolean dfs(TreeNode root, StringBuilder sb, int target) {\\n        \\n        if(root==null)\\n            return false;\\n        \\n        if(root.val==target)\\n            return true;\\n        \\n        if(dfs(root.left,sb,target)) {\\n            sb.append(\"L\");\\n            return true;\\n        }\\n        \\n        if(dfs(root.right,sb,target)) {\\n            sb.append(\"R\");\\n            return true;\\n        }\\n        \\n        return false;\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2515860,
                "title": "faster-than-90-python",
                "content": "\\n![image](https://assets.leetcode.com/users/images/06dac10d-b16d-40b4-b2e0-dc95715d1761_1662061695.3839533.png)\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def getDirections(self, r: Optional[TreeNode], s: int, d: int) -> str:\\n        u=\"\"\\n        v=\"\"\\n        q={}\\n        def dfs(i,p,a):\\n            nonlocal u,v\\n            if not i:\\n                return\\n            q[i.val]=(p,a)\\n            dfs(i.left,\"L\",i.val)\\n            dfs(i.right,\"R\",i.val)\\n        dfs(r,\"\",r.val)\\n        u=[]\\n        while s!=r.val:\\n            u+=[q[s][0]]\\n            s=q[s][1]\\n        v=[]\\n        while d!=r.val:\\n            v+=[q[d][0]]\\n            d=q[d][1]\\n        u=u[::-1]\\n        v=v[::-1]\\n        for i in range(min(len(u),len(v))):\\n            if u[i]==v[i]:\\n                u[i]=\"\"\\n                v[i]=\"\"\\n            else:\\n                break\\n        return \"U\"*len(\"\".join(u))+\"\".join(v)",
                "solutionTags": [
                    "Python",
                    "Binary Tree"
                ],
                "code": "class Solution:\\n    def getDirections(self, r: Optional[TreeNode], s: int, d: int) -> str:\\n        u=\"\"\\n        v=\"\"\\n        q={}",
                "codeTag": "Java"
            },
            {
                "id": 2491773,
                "title": "map-c-approach-easy",
                "content": "```\\nclass Solution {\\npublic:\\n    map<TreeNode*,TreeNode*>parent;\\n    TreeNode* start = NULL;\\n    string global =\"\";\\n    \\n    void trav(TreeNode* root , int startValue )\\n    {\\n        \\n       if(root==NULL)\\n         {\\n               return ;\\n         }\\n        if(root->val==startValue )\\n        {\\n          start = root;  \\n        }\\n        if(root->left)\\n        {\\n            parent[root->left] = root ;\\n            trav( root->left, startValue);\\n        }\\n        if(root->right)\\n        {\\n            parent[root->right] = root ;\\n            trav( root->right, startValue);\\n        }        \\n    }\\n    \\n bool direct(TreeNode* root, int destValue, TreeNode *prev) // No path parameter, return boolean\\n    {\\n        if(root==NULL )\\n        {\\n            return false;\\n        }\\n        if(root->val == destValue)\\n        {\\n            global = \"\"; // Start building a path from the end\\n            return true; // Indicate that destination was found\\n        }\\n        if(root->left!=prev)\\n        {\\n            if (direct(root->left,destValue, root)) { // Use the returned boolean\\n                global += \"L\"; // Append in which direction we found the destination\\n                return true; // ... and indicate success\\n            }\\n        }\\n      \\n        if(root->right!=prev)\\n        {\\n            if (direct(root->right,destValue, root)) {\\n                global += \"R\";\\n                return true;\\n            }\\n        }\\n        \\n        if(parent[root]!=prev) // Don\\'t go back up when we just had come down\\n        {\\n            if (direct(parent[root],destValue, root)) {\\n                global += \"U\";\\n                return true;\\n            }\\n        }\\n        return false; // Didn\\'t find the destination in this subtree\\n   }\\n    \\n    \\n    string getDirections(TreeNode* root, int startValue, int destValue)\\n    { \\n        parent[root]= NULL;\\n        trav(root, startValue);\\n        direct(start,destValue, NULL);\\n        reverse(begin(global), end(global)); // Reverse the path\\n        parent.clear();\\n        return global;\\n    }\\n    \\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    map<TreeNode*,TreeNode*>parent;\\n    TreeNode* start = NULL;\\n    string global =\"\";\\n    \\n    void trav(TreeNode* root , int startValue )\\n    {\\n        \\n       if(root==NULL)\\n         {\\n               return ;\\n         }",
                "codeTag": "Java"
            },
            {
                "id": 2482337,
                "title": "python-lca-bfs-easy-solution",
                "content": "```\\ndef findlca(root,p,q):\\n            if not root:\\n                return\\n            if root.val == p or root.val == q:\\n                return root\\n            left = findlca(root.left, p, q)\\n            right = findlca(root.right, p, q)\\n            if left and right:\\n                return root\\n            else:\\n                return left or right\\n        lca=findlca(root,startValue,destValue)\\n        path_left=\"\"\\n        path_right=\"\"\\n        q=deque()\\n        q.append((lca,\"\"))\\n        while q:\\n            x=q.popleft()\\n            if x[0].val==startValue:\\n                path_left=x[1]\\n            if x[0].val==destValue:\\n                path_right=x[1]\\n            if path_left!=\"\" and path_right!=\"\":\\n                break\\n            if x[0].left:\\n                q.append((x[0].left,x[1]+\"L\"))\\n            if x[0].right:\\n                q.append((x[0].right,x[1]+\"R\"))\\n        z=len(path_left)*\"U\"\\n        return z+path_right\\n```",
                "solutionTags": [
                    "Python",
                    "Breadth-First Search"
                ],
                "code": "```\\ndef findlca(root,p,q):\\n            if not root:\\n                return\\n            if root.val == p or root.val == q:\\n                return root\\n            left = findlca(root.left, p, q)\\n            right = findlca(root.right, p, q)\\n            if left and right:\\n                return root\\n            else:\\n                return left or right\\n        lca=findlca(root,startValue,destValue)\\n        path_left=\"\"\\n        path_right=\"\"\\n        q=deque()\\n        q.append((lca,\"\"))\\n        while q:\\n            x=q.popleft()\\n            if x[0].val==startValue:\\n                path_left=x[1]\\n            if x[0].val==destValue:\\n                path_right=x[1]\\n            if path_left!=\"\" and path_right!=\"\":\\n                break\\n            if x[0].left:\\n                q.append((x[0].left,x[1]+\"L\"))\\n            if x[0].right:\\n                q.append((x[0].right,x[1]+\"R\"))\\n        z=len(path_left)*\"U\"\\n        return z+path_right\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2467371,
                "title": "detailed-step-wise-explanation-dfs-solution-lca-prefix",
                "content": "**Upvote if you liked the solution**\\n\\nStep 1 : Travel every node and in dfs tree traversal we are going to travel every node exactly once \\n\\nStep 2 : Keep adding the direction we went in our string \\n\\nStep 3 : Whenever we encounter our startValue node or destValue node we are going to store the path in other string\\n\\nStep 4 :  Whenever we reach last node or node with null we are going to backtrack from there\\nNow we have our path from root to startValue and root to destValue\\n\\nStep 5 :  From starting index till wherever we find the path equal means they are common path to both value so we have to erase that from our answer.\\n\\nStep 6 : Now we need to move towards root (Because in worst case it have to be LCA) from startValue that can be moved by U so add till we move to the LCA \\n\\nStep 7 : Now we need to move towards destValue from LCA so add remaining part from path of destination\\n\\nHurray , You got your answers\\n```\\nclass Solution {\\npublic:\\n    string s, t;\\n    void dfs(TreeNode* root, int start, int dest, string &a){\\n        if(!root){\\n            return;\\n        }\\n        if(root ->val == start){\\n            s = a;\\n        }\\n        if(root ->val == dest){\\n            t = a;\\n        }\\n        if(root ->left){\\n            a.push_back(\\'L\\');\\n            \\n            dfs(root ->left, start, dest, a);\\n            a.pop_back();\\n           \\n        }\\n        if(root ->right){\\n            a.push_back(\\'R\\')\\n            dfs(root ->right, start, dest, a);\\n            a.pop_back();\\n        }\\n        \\n\\n    }\\n    string getDirections(TreeNode* root, int startValue, int destValue) {\\n        string a= \"\", b = \"\";\\n        dfs(root, startValue, destValue,a);\\n        string ans=\"\";\\n        int i = 0, j = 0;\\n        while(i<s.size() && j<t.size()&& s[i] == t[j]){\\n            i++;\\n            j++;\\n        }\\n        while(i<s.size()){\\n            ans += \\'U\\';\\n            i++;\\n        }\\n        ans += t.substr(j);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Backtracking",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string s, t;\\n    void dfs(TreeNode* root, int start, int dest, string &a){\\n        if(!root){\\n            return;\\n        }\\n        if(root ->val == start){\\n            s = a;\\n        }\\n        if(root ->val == dest){\\n            t = a;\\n        }\\n        if(root ->left){\\n            a.push_back(\\'L\\');\\n            \\n            dfs(root ->left, start, dest, a);\\n            a.pop_back();\\n           \\n        }\\n        if(root ->right){\\n            a.push_back(\\'R\\')\\n            dfs(root ->right, start, dest, a);\\n            a.pop_back();\\n        }\\n        \\n\\n    }\\n    string getDirections(TreeNode* root, int startValue, int destValue) {\\n        string a= \"\", b = \"\";\\n        dfs(root, startValue, destValue,a);\\n        string ans=\"\";\\n        int i = 0, j = 0;\\n        while(i<s.size() && j<t.size()&& s[i] == t[j]){\\n            i++;\\n            j++;\\n        }\\n        while(i<s.size()){\\n            ans += \\'U\\';\\n            i++;\\n        }\\n        ans += t.substr(j);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2447809,
                "title": "c-modern-solution-without-lca-beats-93-detailed-comments-explanation",
                "content": "```cpp\\nclass Solution {\\n public:\\n  auto getDirections(TreeNode* root, int startValue, int destValue) -> string {\\n    string startPath;\\n    string destPath;\\n\\n    // Note that this DFS traversal will cause the path to be appended\\n    // bottom-first. Hence,\\n    //   - startPath =  path from startValue to root\\n    //   - destPath =  path from destValue to root\\n    findValue(root, startValue, startPath);\\n    findValue(root, destValue, destPath);\\n\\n    // Pop the common subpath for startValue & destValue (which is the\\n    // path from root to their lowest common ancestor, but in\\n    // reverse).\\n    while (!startPath.empty() && !destPath.empty() && startPath.back() == destPath.back()) {\\n      startPath.pop_back();\\n      destPath.pop_back();\\n    }\\n\\n    // startValue travels up to lowest common ancestor, then travels\\n    // downward to destValue.\\n    return string(startPath.size(), \\'U\\') + string(destPath.crbegin(), destPath.crend());\\n  }\\n\\n private:\\n  // Construct path from value to root\\n  auto findValue(TreeNode* root, int value, string& path) -> bool {\\n    if (root->val == value) return true;\\n\\n    if (root->left && findValue(root->left, value, path)) {\\n      path += \\'L\\';\\n      return true;\\n    } else if (root->right && findValue(root->right, value, path)) {\\n      path += \\'R\\';\\n      return true;\\n    }\\n\\n    return false;\\n  }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```cpp\\nclass Solution {\\n public:\\n  auto getDirections(TreeNode* root, int startValue, int destValue) -> string {\\n    string startPath;\\n    string destPath;\\n\\n    // Note that this DFS traversal will cause the path to be appended\\n    // bottom-first. Hence,\\n    //   - startPath =  path from startValue to root\\n    //   - destPath =  path from destValue to root\\n    findValue(root, startValue, startPath);\\n    findValue(root, destValue, destPath);\\n\\n    // Pop the common subpath for startValue & destValue (which is the\\n    // path from root to their lowest common ancestor, but in\\n    // reverse).\\n    while (!startPath.empty() && !destPath.empty() && startPath.back() == destPath.back()) {\\n      startPath.pop_back();\\n      destPath.pop_back();\\n    }\\n\\n    // startValue travels up to lowest common ancestor, then travels\\n    // downward to destValue.\\n    return string(startPath.size(), \\'U\\') + string(destPath.crbegin(), destPath.crend());\\n  }\\n\\n private:\\n  // Construct path from value to root\\n  auto findValue(TreeNode* root, int value, string& path) -> bool {\\n    if (root->val == value) return true;\\n\\n    if (root->left && findValue(root->left, value, path)) {\\n      path += \\'L\\';\\n      return true;\\n    } else if (root->right && findValue(root->right, value, path)) {\\n      path += \\'R\\';\\n      return true;\\n    }\\n\\n    return false;\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2436863,
                "title": "simple-dfs-python",
                "content": "```\\n\\t\\'\\'\\'\\n    O(N)\\n    O(N)\\n    \\'\\'\\'\\n    def getDirections(self, root: Optional[TreeNode], startValue: int, destValue: int) -> str:\\n        def dfs(node):  #get LCA\\n            if not node: return None\\n            if node.val in [startValue, destValue]:\\n                return node\\n            left = dfs(node.left)\\n            right = dfs(node.right)\\n            if left and right:\\n                return node\\n            return left or right\\n        \\n        root = dfs(root)\\n        temp, path = [], []\\n        \\n        def getPath(src,dst):\\n            if not src:\\n                return\\n            if src.val == dst:\\n                temp.append(path[:])\\n                return\\n            path.append(\"L\")\\n            getPath(src.left,dst)\\n            path.pop()\\n            path.append(\"R\")\\n            getPath(src.right,dst)\\n            path.pop()\\n        \\n        getPath(root,startValue)\\n        getPath(root,destValue)\\n        \\n        return len(temp[0]) * \"U\" + \"\".join(temp[1])\\n\\t\\t```",
                "solutionTags": [],
                "code": "```\\n\\t\\'\\'\\'\\n    O(N)\\n    O(N)\\n    \\'\\'\\'\\n    def getDirections(self, root: Optional[TreeNode], startValue: int, destValue: int) -> str:\\n        def dfs(node):  #get LCA\\n            if not node: return None\\n            if node.val in [startValue, destValue]:\\n                return node\\n            left = dfs(node.left)\\n            right = dfs(node.right)\\n            if left and right:\\n                return node\\n            return left or right\\n        \\n        root = dfs(root)\\n        temp, path = [], []\\n        \\n        def getPath(src,dst):\\n            if not src:\\n                return\\n            if src.val == dst:\\n                temp.append(path[:])\\n                return\\n            path.append(\"L\")\\n            getPath(src.left,dst)\\n            path.pop()\\n            path.append(\"R\")\\n            getPath(src.right,dst)\\n            path.pop()\\n        \\n        getPath(root,startValue)\\n        getPath(root,destValue)\\n        \\n        return len(temp[0]) * \"U\" + \"\".join(temp[1])\\n\\t\\t```",
                "codeTag": "Python3"
            },
            {
                "id": 2428549,
                "title": "common-sensical-solution-similar-to-burning-tree-building-parent-links",
                "content": "```\\n\\nvar getDirections = function(root, startValue, destValue) {\\n    let startNode = null;\\n    let visited = new Set();\\n    let queue = [root];\\n    \\n\\t// Build Parent Links for each node\\n    while(queue.length > 0){\\n        const node = queue.shift();\\n        if(node.left){\\n            node.left.parent = node;\\n            queue.push(node.left);\\n        }\\n        if(node.right){\\n            node.right.parent = node;\\n            queue.push(node.right)\\n        }\\n\\t\\t// Identify startNode so that we can start bfs from here\\n        if(node.val === startValue) startNode = node;\\n    }\\n    \\n    let directions = [\"\"];\\n    queue = [startNode];\\n    let found = false;\\n    \\n    while(queue.length > 0 && found === false){\\n        let queueLength = queue.length;\\n        for(let i=0;i<queueLength;i++){\\n            let node = queue.shift();\\n            if(node.val === destValue){\\n                found = true;\\n                break;\\n            }\\n\\t\\t\\t// Add current node to visited so that child nodes don\\'t get visited again once they go upto parent\\n            visited.add(node);\\n\\t\\t\\t\\n            let direction = directions.shift();\\n\\t\\t\\t\\n\\t\\t\\t// Add each node and their direction\\n            if(node.parent && !visited.has(node.parent)){\\n                queue.push(node.parent);\\n                directions.push(`${direction}U`);\\n            }\\n            if(node.left && !visited.has(node.left)){\\n                queue.push(node.left);\\n                directions.push(`${direction}L`);\\n            }\\n            if(node.right && !visited.has(node.right)){\\n                queue.push(node.right);\\n                directions.push(`${direction}R`);\\n            }\\n        }\\n    }\\n    \\n\\t// As this is BFS first element  in directions will be return value\\n    return directions.at(0);\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Tree",
                    "Breadth-First Search"
                ],
                "code": "```\\n\\nvar getDirections = function(root, startValue, destValue) {\\n    let startNode = null;\\n    let visited = new Set();\\n    let queue = [root];\\n    \\n\\t// Build Parent Links for each node\\n    while(queue.length > 0){\\n        const node = queue.shift();\\n        if(node.left){\\n            node.left.parent = node;\\n            queue.push(node.left);\\n        }\\n        if(node.right){\\n            node.right.parent = node;\\n            queue.push(node.right)\\n        }\\n\\t\\t// Identify startNode so that we can start bfs from here\\n        if(node.val === startValue) startNode = node;\\n    }\\n    \\n    let directions = [\"\"];\\n    queue = [startNode];\\n    let found = false;\\n    \\n    while(queue.length > 0 && found === false){\\n        let queueLength = queue.length;\\n        for(let i=0;i<queueLength;i++){\\n            let node = queue.shift();\\n            if(node.val === destValue){\\n                found = true;\\n                break;\\n            }\\n\\t\\t\\t// Add current node to visited so that child nodes don\\'t get visited again once they go upto parent\\n            visited.add(node);\\n\\t\\t\\t\\n            let direction = directions.shift();\\n\\t\\t\\t\\n\\t\\t\\t// Add each node and their direction\\n            if(node.parent && !visited.has(node.parent)){\\n                queue.push(node.parent);\\n                directions.push(`${direction}U`);\\n            }\\n            if(node.left && !visited.has(node.left)){\\n                queue.push(node.left);\\n                directions.push(`${direction}L`);\\n            }\\n            if(node.right && !visited.has(node.right)){\\n                queue.push(node.right);\\n                directions.push(`${direction}R`);\\n            }\\n        }\\n    }\\n    \\n\\t// As this is BFS first element  in directions will be return value\\n    return directions.at(0);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2413521,
                "title": "java-solution",
                "content": "```\\npublic String getDirections(TreeNode root, int startValue, int destValue) {\\n        List<TreeNode> start = new ArrayList<>();\\n        List<TreeNode> dest = new ArrayList<>();\\n        buildPathFromRoot(root, startValue, start);\\n        buildPathFromRoot(root, destValue, dest);\\n        int i = 0, j = 0;\\n        int idxOfLca = 0;\\n        while (i < start.size() && j < dest.size()) {\\n            if (i == j && start.get(i) == dest.get(j)) {\\n                i++;\\n                j++;\\n            } else {\\n                break;\\n            }\\n        }\\n        idxOfLca = i - 1;\\n        StringBuilder sb = new StringBuilder();\\n        int len = start.size() - 1;\\n        while (len != idxOfLca) {\\n            sb.append(\"U\");\\n            len--;\\n        }\\n        TreeNode node = start.get(idxOfLca);\\n        while (j < dest.size()) {\\n            if (node.left == dest.get(j)) {\\n                sb.append(\"L\");\\n            } else {\\n                sb.append(\"R\");\\n            }\\n            j++;\\n        }\\n        return sb.toString();\\n\\n    }\\n\\n    private boolean buildPathFromRoot(TreeNode node, int target, List<TreeNode> list) {\\n        if (node == null)\\n            return false;\\n        list.add(node);\\n        if (node.val == target)\\n            return true;\\n        if (buildPathFromRoot(node.left, target, list))\\n            return true;\\n        if (buildPathFromRoot(node.right, target, list))\\n            return true;\\n\\n        list.remove(list.size() - 1);\\n        return false;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic String getDirections(TreeNode root, int startValue, int destValue) {\\n        List<TreeNode> start = new ArrayList<>();\\n        List<TreeNode> dest = new ArrayList<>();\\n        buildPathFromRoot(root, startValue, start);\\n        buildPathFromRoot(root, destValue, dest);\\n        int i = 0, j = 0;\\n        int idxOfLca = 0;\\n        while (i < start.size() && j < dest.size()) {\\n            if (i == j && start.get(i) == dest.get(j)) {\\n                i++;\\n                j++;\\n            } else {\\n                break;\\n            }\\n        }\\n        idxOfLca = i - 1;\\n        StringBuilder sb = new StringBuilder();\\n        int len = start.size() - 1;\\n        while (len != idxOfLca) {\\n            sb.append(\"U\");\\n            len--;\\n        }\\n        TreeNode node = start.get(idxOfLca);\\n        while (j < dest.size()) {\\n            if (node.left == dest.get(j)) {\\n                sb.append(\"L\");\\n            } else {\\n                sb.append(\"R\");\\n            }\\n            j++;\\n        }\\n        return sb.toString();\\n\\n    }\\n\\n    private boolean buildPathFromRoot(TreeNode node, int target, List<TreeNode> list) {\\n        if (node == null)\\n            return false;\\n        list.add(node);\\n        if (node.val == target)\\n            return true;\\n        if (buildPathFromRoot(node.left, target, list))\\n            return true;\\n        if (buildPathFromRoot(node.right, target, list))\\n            return true;\\n\\n        list.remove(list.size() - 1);\\n        return false;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2410376,
                "title": "c-lca-using-two-strings",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* lowestCommonAncestor(TreeNode* root, int p, int q) {\\n        if(root==NULL)\\n            return NULL;\\n        if(root->val==p or root->val==q)\\n            return root;\\n        \\n        TreeNode*left=lowestCommonAncestor(root->left,p,q);\\n        TreeNode*right=lowestCommonAncestor(root->right,p,q);\\n\\n        if(left==NULL and right!=NULL)\\n            return right;\\n        else if(left!=NULL and right==NULL)\\n            return left;\\n        else if(left==NULL and right==NULL)\\n            return NULL;\\n        else \\n            return root;\\n    }\\n    TreeNode* solve(TreeNode*root,int node,string& ans)\\n    {\\n        if(root==NULL)\\n            return NULL;\\n        if(root->val==node)\\n        {\\n            return root;\\n        }\\n        TreeNode*left=solve(root->left,node,ans);\\n        TreeNode*right=solve(root->right,node,ans);\\n        if(left==NULL and right==NULL)\\n            return NULL;\\n        else if(!left and right)\\n        {\\n            ans+=\\'R\\';\\n            return right;\\n        }\\n        else if(left and !right)\\n        {\\n            ans+=\\'L\\';\\n            return left;\\n        }\\n        else \\n            return root;\\n    }\\n    string getDirections(TreeNode* root, int startValue, int destValue) {\\n        string a,b;\\n        TreeNode*lca=lowestCommonAncestor(root,startValue,destValue);\\n        solve(lca,startValue,a);\\n        solve(lca,destValue,b);\\n        for(char &ch:a)\\n            ch=\\'U\\';\\n        reverse(b.begin(),b.end());\\n        string ans=a+b;\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Depth-First Search",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* lowestCommonAncestor(TreeNode* root, int p, int q) {\\n        if(root==NULL)\\n            return NULL;\\n        if(root->val==p or root->val==q)\\n            return root;\\n        \\n        TreeNode*left=lowestCommonAncestor(root->left,p,q);\\n        TreeNode*right=lowestCommonAncestor(root->right,p,q);\\n\\n        if(left==NULL and right!=NULL)\\n            return right;\\n        else if(left!=NULL and right==NULL)\\n            return left;\\n        else if(left==NULL and right==NULL)\\n            return NULL;\\n        else \\n            return root;\\n    }\\n    TreeNode* solve(TreeNode*root,int node,string& ans)\\n    {\\n        if(root==NULL)\\n            return NULL;\\n        if(root->val==node)\\n        {\\n            return root;\\n        }\\n        TreeNode*left=solve(root->left,node,ans);\\n        TreeNode*right=solve(root->right,node,ans);\\n        if(left==NULL and right==NULL)\\n            return NULL;\\n        else if(!left and right)\\n        {\\n            ans+=\\'R\\';\\n            return right;\\n        }\\n        else if(left and !right)\\n        {\\n            ans+=\\'L\\';\\n            return left;\\n        }\\n        else \\n            return root;\\n    }\\n    string getDirections(TreeNode* root, int startValue, int destValue) {\\n        string a,b;\\n        TreeNode*lca=lowestCommonAncestor(root,startValue,destValue);\\n        solve(lca,startValue,a);\\n        solve(lca,destValue,b);\\n        for(char &ch:a)\\n            ch=\\'U\\';\\n        reverse(b.begin(),b.end());\\n        string ans=a+b;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2408646,
                "title": "lca-path-finding",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* lca(TreeNode* root,int a,int b){\\n        if(root==NULL) return NULL;\\n        if(root->val==a || root->val==b){\\n            return root;\\n        }\\n        TreeNode* l = lca(root->left,a,b);\\n        TreeNode* r = lca(root->right,a,b);\\n        if(l and r) return root;\\n        \\n        return l?l:r;\\n    }\\n    void traverse(TreeNode* root,int a,string &s,string &ans){\\n        if(root==NULL) return;\\n        if(root->val==a){\\n            ans = s;\\n        }\\n        s.push_back(\\'L\\');\\n        traverse(root->left,a,s,ans);\\n        s.pop_back();\\n        s.push_back(\\'R\\');\\n        traverse(root->right,a,s,ans);\\n        s.pop_back();\\n    }\\n    string getDirections(TreeNode* root, int a, int b) {\\n        TreeNode*  anc = lca(root,a,b);\\n        string rev = \"\";\\n        string temp = \"\";\\n        string ver = \"\";\\n        traverse(anc,a,temp,rev);\\n        traverse(anc,b,temp,ver);\\n        string str(rev.size(),\\'U\\');\\n        return str+ver;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* lca(TreeNode* root,int a,int b){\\n        if(root==NULL) return NULL;\\n        if(root->val==a || root->val==b){\\n            return root;\\n        }\\n        TreeNode* l = lca(root->left,a,b);\\n        TreeNode* r = lca(root->right,a,b);\\n        if(l and r) return root;\\n        \\n        return l?l:r;\\n    }\\n    void traverse(TreeNode* root,int a,string &s,string &ans){\\n        if(root==NULL) return;\\n        if(root->val==a){\\n            ans = s;\\n        }\\n        s.push_back(\\'L\\');\\n        traverse(root->left,a,s,ans);\\n        s.pop_back();\\n        s.push_back(\\'R\\');\\n        traverse(root->right,a,s,ans);\\n        s.pop_back();\\n    }\\n    string getDirections(TreeNode* root, int a, int b) {\\n        TreeNode*  anc = lca(root,a,b);\\n        string rev = \"\";\\n        string temp = \"\";\\n        string ver = \"\";\\n        traverse(anc,a,temp,rev);\\n        traverse(anc,b,temp,ver);\\n        string str(rev.size(),\\'U\\');\\n        return str+ver;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2361489,
                "title": "easy-java-solution",
                "content": "```\\nclass Solution {\\n    public String getDirections(TreeNode root, int startValue, int destValue) {\\n\\n\\t\\t// Get paths from root to start value and root to dest value\\n        StringBuilder startPath = getPath(root, startValue);\\n        StringBuilder destPath = getPath(root, destValue);\\n\\n\\t\\t// Remove the common prefix\\n        int len = Math.min(startPath.length(), destPath.length());\\n        int i = 0;\\n        while (i < len && startPath.charAt(startPath.length() - i - 1) == destPath.charAt(destPath.length() - i - 1))\\n            i += 1;\\n\\n\\t\\t// Replace remaining left path with \\'U\\' chars and concat startPath and destPath\\n        return \"U\".repeat(startPath.length() - i) + destPath.reverse().substring(i);\\n    }\\n\\n    private StringBuilder getPath(TreeNode root, int target) {\\n\\n        if (root == null) return null;\\n\\n        if (root.val == target) return new StringBuilder();\\n\\n        StringBuilder left = getPath(root.left, target);\\n        if (left != null) {\\n            left.append(\"L\");\\n            return left;\\n        }\\n\\n        StringBuilder right = getPath(root.right, target);\\n        if (right != null) {\\n            right.append(\"R\");\\n            return right;\\n        }\\n        return null;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    public String getDirections(TreeNode root, int startValue, int destValue) {\\n\\n\\t\\t// Get paths from root to start value and root to dest value\\n        StringBuilder startPath = getPath(root, startValue);\\n        StringBuilder destPath = getPath(root, destValue);\\n\\n\\t\\t// Remove the common prefix\\n        int len = Math.min(startPath.length(), destPath.length());\\n        int i = 0;\\n        while (i < len && startPath.charAt(startPath.length() - i - 1) == destPath.charAt(destPath.length() - i - 1))\\n            i += 1;\\n\\n\\t\\t// Replace remaining left path with \\'U\\' chars and concat startPath and destPath\\n        return \"U\".repeat(startPath.length() - i) + destPath.reverse().substring(i);\\n    }\\n\\n    private StringBuilder getPath(TreeNode root, int target) {\\n\\n        if (root == null) return null;\\n\\n        if (root.val == target) return new StringBuilder();\\n\\n        StringBuilder left = getPath(root.left, target);\\n        if (left != null) {\\n            left.append(\"L\");\\n            return left;\\n        }\\n\\n        StringBuilder right = getPath(root.right, target);\\n        if (right != null) {\\n            right.append(\"R\");\\n            return right;\\n        }\\n        return null;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2347565,
                "title": "python-easy-interview-practical-solution-with-bfs",
                "content": "This is one of the harder traversal questions out there, and I think it really should be hard. But with that said, I saw this and finished it with one go and spent time only on coding, no thoughts/inteligence required. \\n\\n1. Tree is a type of graph, without cycle. Now you don\\'t have a parent object member but you are allowed to go up. That immediately is a sign that converting this tree to graph will make it logically easier. You can do this with BFS like a normal person. \\n2. You are required to return the path. This is not commonly asked in leetcode BFS questions but totally valid. A very common way of doing this, as structured by [MIT opencourse here](https://ocw.mit.edu/courses/6-006-introduction-to-algorithms-fall-2011/resources/mit6_006f11_lec13/) is to use a `dict` instead of `set` to keep track of the node you visited, specifically `V[children] = parent`. This way later on you can return the path easily by going up this chain of parent-child relationship `while V[child]: child = V[child]`\\n3. All nodes are uniquly valued so just track `node.val`, otherwise you can track `node` but that becomes more complicated \\n4. The code here looks bulky but is actually very easy to read and super generalized. I have been using this structure for all my leetcode BFS questions and I don\\'t even need to change a single thing\\n\\n```Python\\nclass Solution:\\n    def getDirections(self, root: Optional[TreeNode], startValue: int, destValue: int) -> str:\\n\\t\\n        # Turn this tree into a graph \\n        left, right, parent = {}, {}, {root.val:None}\\n    \\n\\t\\tQ = [root]\\n        while Q: \\n            frontier = []\\n            for node in Q: \\n                if node.left: \\n                    left[node.val] = node.left.val\\n                    frontier.append(node.left)\\n                    parent[node.left.val] = node.val\\n                if node.right: \\n                    right[node.val] = node.right.val\\n                    frontier.append(node.right)\\n                    parent[node.right.val] = node.val\\n            Q = frontier \\n            \\n\\t\\t# BFS the tree \\n        V = {startValue:None}\\n        Q, found = [startValue], False\\n        while Q:\\n            if found: \\n                break\\n            frontier = []\\n            for nval in Q: \\n                if nval == destValue: \\n                    found = True # early stopping\\n                    break\\n                if nval in left and left[nval] not in V: \\n                    frontier.append(left[nval])\\n                    V[left[nval]] = (nval, \\'L\\')\\n                if nval in right and right[nval] not in V: \\n                    frontier.append(right[nval])\\n                    V[right[nval]] = (nval, \\'R\\')\\n                if nval in parent and parent[nval] not in V: \\n                    frontier.append(parent[nval])\\n                    V[parent[nval]] = (nval, \\'U\\')\\n            Q = frontier \\n        \\n\\t\\t# return the path \\n        out = []\\n        while V[destValue]: \\n            out.append(V[destValue][1]) # append L, R, U    \\n            destValue = V[destValue][0] # find path\\n        return \\'\\'.join(reversed(out))\\n```",
                "solutionTags": [
                    "Python",
                    "Breadth-First Search"
                ],
                "code": "```Python\\nclass Solution:\\n    def getDirections(self, root: Optional[TreeNode], startValue: int, destValue: int) -> str:\\n\\t\\n        # Turn this tree into a graph \\n        left, right, parent = {}, {}, {root.val:None}\\n    \\n\\t\\tQ = [root]\\n        while Q: \\n            frontier = []\\n            for node in Q: \\n                if node.left: \\n                    left[node.val] = node.left.val\\n                    frontier.append(node.left)\\n                    parent[node.left.val] = node.val\\n                if node.right: \\n                    right[node.val] = node.right.val\\n                    frontier.append(node.right)\\n                    parent[node.right.val] = node.val\\n            Q = frontier \\n            \\n\\t\\t# BFS the tree \\n        V = {startValue:None}\\n        Q, found = [startValue], False\\n        while Q:\\n            if found: \\n                break\\n            frontier = []\\n            for nval in Q: \\n                if nval == destValue: \\n                    found = True # early stopping\\n                    break\\n                if nval in left and left[nval] not in V: \\n                    frontier.append(left[nval])\\n                    V[left[nval]] = (nval, \\'L\\')\\n                if nval in right and right[nval] not in V: \\n                    frontier.append(right[nval])\\n                    V[right[nval]] = (nval, \\'R\\')\\n                if nval in parent and parent[nval] not in V: \\n                    frontier.append(parent[nval])\\n                    V[parent[nval]] = (nval, \\'U\\')\\n            Q = frontier \\n        \\n\\t\\t# return the path \\n        out = []\\n        while V[destValue]: \\n            out.append(V[destValue][1]) # append L, R, U    \\n            destValue = V[destValue][0] # find path\\n        return \\'\\'.join(reversed(out))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2340444,
                "title": "java-solution",
                "content": "```\\nclass Solution {\\n  public String getDirections(TreeNode root, int startValue, int destValue) {\\n    StringBuilder startSb = new StringBuilder();\\n    StringBuilder destSb = new StringBuilder();\\n    \\n    buildPath(root, startValue, startSb);\\n    buildPath(root, destValue, destSb);\\n    \\n    int start = 0;\\n    int end = Math.min(startSb.length(), destSb.length());\\n    while(start < end && startSb.charAt(startSb.length() - start - 1) == destSb.charAt(destSb.length() - start - 1)) {\\n      start++;\\n    }\\n    \\n    return \"U\".repeat(startSb.length() - start) + destSb.reverse().toString().substring(start);\\n  }\\n  \\n  public boolean buildPath(TreeNode root, int toFind, StringBuilder sb) {\\n    if(root.val == toFind) {\\n      return true;\\n    }\\n    \\n    if(root.left != null && buildPath(root.left, toFind, sb)) {\\n      sb.append(\"L\");\\n    } \\n    else if(root.right != null && buildPath(root.right, toFind, sb)) {\\n      sb.append(\"R\");\\n    }\\n    \\n    return sb.length() > 0;\\n  }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n  public String getDirections(TreeNode root, int startValue, int destValue) {\\n    StringBuilder startSb = new StringBuilder();\\n    StringBuilder destSb = new StringBuilder();\\n    \\n    buildPath(root, startValue, startSb);\\n    buildPath(root, destValue, destSb);\\n    \\n    int start = 0;\\n    int end = Math.min(startSb.length(), destSb.length());\\n    while(start < end && startSb.charAt(startSb.length() - start - 1) == destSb.charAt(destSb.length() - start - 1)) {\\n      start++;\\n    }\\n    \\n    return \"U\".repeat(startSb.length() - start) + destSb.reverse().toString().substring(start);\\n  }\\n  \\n  public boolean buildPath(TreeNode root, int toFind, StringBuilder sb) {\\n    if(root.val == toFind) {\\n      return true;\\n    }\\n    \\n    if(root.left != null && buildPath(root.left, toFind, sb)) {\\n      sb.append(\"L\");\\n    } \\n    else if(root.right != null && buildPath(root.right, toFind, sb)) {\\n      sb.append(\"R\");\\n    }\\n    \\n    return sb.length() > 0;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2319561,
                "title": "python-lca-dfs-and-you-can-always-know-the-target-to-find-by-passing-a-parameter",
                "content": "First glance, LCA to shorten the finding traversal.\\n\\nThen, to find the `start` and `dest`, we need to traverse **as well as pop out** the unnecessary letters during going up.\\n\\nAt last, if found `start`, we are always gonna going up from it, so `[\\'U\\']*len(w)`. And when found `dest`, keep it as it is.\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def getDirections(self, root: Optional[TreeNode], start: int, dest: int) -> str:\\n        \"\"\"\\n        find the LCA\\n        record the letters while finding \\n        s = 6, d = 3\\n        5 -> 1 -> 3 LL\\n        5 -> 2 -> 6 LLRL\\n        \\n        \"\"\"\\n        def lca(root, s, d):\\n            if not root: return None\\n            if s == root.val or d == root.val:\\n                return root\\n            left = lca(root.left, s, d)\\n            right = lca(root.right, s, d)\\n            if left and right:\\n                return root\\n            return left or right\\n        \\n        node = lca(root, start, dest)\\n        \\n        s, d = [], []\\n        def direction(node, w): # w: which to put result\\n            if not node: return \\n            if node.val == start:\\n                s.extend([\\'U\\'] * len(w))\\n            if node.val == dest:\\n                d.extend(w)\\n            if node.left:\\n                w.append(\\'L\\')\\n                direction(node.left, w)\\n                w.pop()\\n            if node.right:\\n                w.append(\\'R\\')\\n                direction(node.right, w)\\n                w.pop()\\n        \\n        direction(node, [])\\n        \\n        return \\'\\'.join(s + d)\\n            \\n```\\n**Time:** `O(N)`\\n\\nb/c we find LCA, which costs `O(N)`, and then during finding the `start` and `dest`, we also, in worst case, use `O(N)`\\n\\n**Space:** `O(H+N)`\\n\\nwhere `H` is the deepest height of the tree for recursion stack, and `N` is for `start` and `dest` arrays.\\n\\n",
                "solutionTags": [
                    "Python",
                    "Depth-First Search"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def getDirections(self, root: Optional[TreeNode], start: int, dest: int) -> str:\\n        \"\"\"\\n        find the LCA\\n        record the letters while finding \\n        s = 6, d = 3\\n        5 -> 1 -> 3 LL\\n        5 -> 2 -> 6 LLRL\\n        \\n        \"\"\"\\n        def lca(root, s, d):\\n            if not root: return None\\n            if s == root.val or d == root.val:\\n                return root\\n            left = lca(root.left, s, d)\\n            right = lca(root.right, s, d)\\n            if left and right:\\n                return root\\n            return left or right\\n        \\n        node = lca(root, start, dest)\\n        \\n        s, d = [], []\\n        def direction(node, w): # w: which to put result\\n            if not node: return \\n            if node.val == start:\\n                s.extend([\\'U\\'] * len(w))\\n            if node.val == dest:\\n                d.extend(w)\\n            if node.left:\\n                w.append(\\'L\\')\\n                direction(node.left, w)\\n                w.pop()\\n            if node.right:\\n                w.append(\\'R\\')\\n                direction(node.right, w)\\n                w.pop()\\n        \\n        direction(node, [])\\n        \\n        return \\'\\'.join(s + d)\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2317191,
                "title": "c-build-both-path-from-root-solution-fast-332ms-95-73",
                "content": "I was trying to solve it by kind LCA approach, but I found it is very comlicated to me track states and find pathes (kind hard task). Eventually, I decided to simplify logic by find pathes from the root and remove common prefix path. I implemented finding both pathes in one pass.\\n\\nI put there the description from the similar solved solution https://leetcode.com/problems/step-by-step-directions-from-a-binary-tree-node-to-another/discuss/1612105/3-Steps\\nSteps:\\n1. Build directions for both start and destination from the root. Say we get \"LLRRL\" and \"LRR\".\\n2. Remove common prefix path. We remove \"L\", and now start direction is \"LRRL\", and destination - \"RR\"\\n3. Replace all steps in the start direction to \"U\" and add destination direction. The result is \"UUUU\" + \"RR\".\\n```\\npublic class Solution {\\n    public string GetDirections(\\n        TreeNode root, int startValue, int destValue) \\n    {\\n        var sb = new StringBuilder(2048);\\n        \\n        string startPath = null, destPath = null;\\n        \\n        GetDirections(root, sb, \"\");   \\n        \\n        var i=0; // common prefix length\\n        \\n        for(; i<startPath.Length && i<destPath.Length && startPath[i]==destPath[i]; i++) ;\\n        \\n        return new string(\\'U\\', startPath.Length-i) + destPath.Substring(i);\\n        \\n        void GetDirections(TreeNode node, StringBuilder sb, string direction)\\n        {\\n            if(node == null || (startPath != null && destPath != null))\\n               return;\\n            \\n            sb.Append(direction);\\n            \\n            if(node.val == startValue) startPath = sb.ToString();\\n           \\n            if(node.val == destValue)  destPath = sb.ToString();\\n            \\n            GetDirections( node.left, sb, \"L\");\\n\\n            GetDirections(node.right, sb, \"R\");\\n            \\n            sb.Length -= direction.Length;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public string GetDirections(\\n        TreeNode root, int startValue, int destValue) \\n    {\\n        var sb = new StringBuilder(2048);\\n        \\n        string startPath = null, destPath = null;\\n        \\n        GetDirections(root, sb, \"\");   \\n        \\n        var i=0; // common prefix length\\n        \\n        for(; i<startPath.Length && i<destPath.Length && startPath[i]==destPath[i]; i++) ;\\n        \\n        return new string(\\'U\\', startPath.Length-i) + destPath.Substring(i);\\n        \\n        void GetDirections(TreeNode node, StringBuilder sb, string direction)\\n        {\\n            if(node == null || (startPath != null && destPath != null))\\n               return;\\n            \\n            sb.Append(direction);\\n            \\n            if(node.val == startValue) startPath = sb.ToString();\\n           \\n            if(node.val == destValue)  destPath = sb.ToString();\\n            \\n            GetDirections( node.left, sb, \"L\");\\n\\n            GetDirections(node.right, sb, \"R\");\\n            \\n            sb.Length -= direction.Length;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2310296,
                "title": "java-solution-by-using-lca-and-recursion",
                "content": "```java\\nclass Solution {\\n    private TreeNode LCA(TreeNode root, int startValue, int destValue) {\\n        if (root == null || root.val == startValue || root.val == destValue) {\\n            return root;\\n        }\\n\\n        TreeNode left = LCA(root.left, startValue, destValue);\\n        TreeNode right = LCA(root.right, startValue, destValue);\\n        if (left == null && right == null) {\\n            return null;\\n        }\\n        if (left != null && right != null) {\\n            return root;\\n        }\\n\\n        return left == null ? right : left;\\n    }\\n\\n    private boolean getStart(TreeNode root, int target, StringBuilder sb) {\\n        if (root == null) {\\n            return false;\\n        }\\n        if (root.val == target) {\\n            return true;\\n        }\\n        boolean left = getStart(root.left, target, sb);\\n        boolean right = getStart(root.right, target, sb);\\n        if (left || right) {\\n            sb.append(\\'U\\');\\n        }\\n\\n        return left || right;\\n    }\\n\\n    private boolean getEnd(TreeNode root, int target, StringBuilder sb) {\\n        if (root == null) {\\n            return false;\\n        }\\n        if (root.val == target) {\\n            return true;\\n        }\\n        boolean left = getEnd(root.left, target, sb);\\n        if (left) {\\n            sb.append(\\'L\\');\\n        }\\n        boolean right = getEnd(root.right, target, sb);\\n        if (right) {\\n            sb.append(\\'R\\');\\n        }\\n        return left || right;\\n    }\\n\\n    public String getDirections(TreeNode root, int startValue, int destValue) {\\n        TreeNode lca = LCA(root, startValue, destValue);\\n\\n        StringBuilder start = new StringBuilder();\\n        getStart(lca, startValue, start);\\n        StringBuilder end = new StringBuilder();\\n        getEnd(lca, destValue, end);\\n\\n        return start.toString() + end.reverse().toString();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```java\\nclass Solution {\\n    private TreeNode LCA(TreeNode root, int startValue, int destValue) {\\n        if (root == null || root.val == startValue || root.val == destValue) {\\n            return root;\\n        }\\n\\n        TreeNode left = LCA(root.left, startValue, destValue);\\n        TreeNode right = LCA(root.right, startValue, destValue);\\n        if (left == null && right == null) {\\n            return null;\\n        }\\n        if (left != null && right != null) {\\n            return root;\\n        }\\n\\n        return left == null ? right : left;\\n    }\\n\\n    private boolean getStart(TreeNode root, int target, StringBuilder sb) {\\n        if (root == null) {\\n            return false;\\n        }\\n        if (root.val == target) {\\n            return true;\\n        }\\n        boolean left = getStart(root.left, target, sb);\\n        boolean right = getStart(root.right, target, sb);\\n        if (left || right) {\\n            sb.append(\\'U\\');\\n        }\\n\\n        return left || right;\\n    }\\n\\n    private boolean getEnd(TreeNode root, int target, StringBuilder sb) {\\n        if (root == null) {\\n            return false;\\n        }\\n        if (root.val == target) {\\n            return true;\\n        }\\n        boolean left = getEnd(root.left, target, sb);\\n        if (left) {\\n            sb.append(\\'L\\');\\n        }\\n        boolean right = getEnd(root.right, target, sb);\\n        if (right) {\\n            sb.append(\\'R\\');\\n        }\\n        return left || right;\\n    }\\n\\n    public String getDirections(TreeNode root, int startValue, int destValue) {\\n        TreeNode lca = LCA(root, startValue, destValue);\\n\\n        StringBuilder start = new StringBuilder();\\n        getStart(lca, startValue, start);\\n        StringBuilder end = new StringBuilder();\\n        getEnd(lca, destValue, end);\\n\\n        return start.toString() + end.reverse().toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2309962,
                "title": "java-solution-95-faster-solution-using-backtracking",
                "content": "1. Build directions for both start and destination from the root.\\nSay we get \"LLRRL\" and \"LRR\".\\n2. Remove common prefix path.\\nWe remove \"L\", and now start direction is \"LRRL\", and destination - \"RR\"\\n3. Replace all steps in the start direction to \"U\" and add destination direction.\\nThe result is \"UUUU\" + \"RR\".\\n```\\nclass Solution {\\n    public String getDirections(TreeNode root, int startValue, int destValue) {\\n        StringBuilder start=new StringBuilder();\\n        StringBuilder dest=new StringBuilder();\\n        boolean check=recursion(root,startValue,start);\\n        \\n        boolean check1=recursion(root,destValue,dest);\\n        \\n        int idx=0;\\n        while(idx<start.length() && idx<dest.length() && start.charAt(idx)==dest.charAt(idx))\\n        idx++;\\n        \\n        StringBuilder ans=new StringBuilder();\\n        for(int i=idx;i<start.length();i++)\\n        ans.append(\\'U\\');\\n        \\n        ans.append(dest.substring(idx));\\n        return ans.toString();\\n    }\\n    private boolean recursion(TreeNode root,int value,StringBuilder sb)\\n    {\\n        if(root==null)\\n        return false;\\n        if(root.val==value)\\n        return true;\\n        sb.append(\\'L\\');\\n        if(recursion(root.left,value,sb))\\n        return true;\\n        sb.deleteCharAt(sb.length()-1);\\n        sb.append(\\'R\\');\\n        if(recursion(root.right,value,sb))\\n        return true;\\n        sb.deleteCharAt(sb.length()-1);\\n        \\n        return false;\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "String",
                    "Backtracking",
                    "Tree",
                    "Depth-First Search",
                    "Binary Tree"
                ],
                "code": "class Solution {\\n    public String getDirections(TreeNode root, int startValue, int destValue) {\\n        StringBuilder start=new StringBuilder();\\n        StringBuilder dest=new StringBuilder();\\n        boolean check=recursion(root,startValue,start);\\n        \\n        boolean check1=recursion(root,destValue,dest);\\n        \\n        int idx=0;\\n        while(idx<start.length() && idx<dest.length() && start.charAt(idx)==dest.charAt(idx))\\n        idx++;\\n        \\n        StringBuilder ans=new StringBuilder();\\n        for(int i=idx;i<start.length();i++)\\n        ans.append(\\'U\\');\\n        \\n        ans.append(dest.substring(idx));\\n        return ans.toString();\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 2303907,
                "title": "c",
                "content": "```\\nclass Solution {\\nprivate:\\n    bool findPath(vector<TreeNode*>& path, int value, TreeNode* node) {\\n        if(node->val == value) {\\n            path.push_back(node);\\n            return true;\\n        } else if(node->left && findPath(path,value,node->left)){\\n            path.push_back(node);\\n            return true;\\n        } else if(node->right && findPath(path,value,node->right)) {\\n            path.push_back(node);\\n            return true;\\n        } else return false;\\n    }\\npublic:\\n    string getDirections(TreeNode* root, int startValue, int destValue) {\\n        vector<TreeNode*> startPath;\\n        vector<TreeNode*> destPath;\\n        findPath(startPath, startValue, root);\\n        findPath(destPath, destValue, root);\\n        TreeNode* leastCommon = root;\\n        while(startPath.size() && destPath.size() && startPath.back()==destPath.back()){\\n            leastCommon = startPath.back();\\n            startPath.pop_back();\\n            destPath.pop_back();\\n        }\\n        string res;\\n        for(auto node:startPath){\\n            res+=\\'U\\';\\n        }\\n        TreeNode *node = leastCommon;\\n        while(destPath.size()) {\\n            if(destPath.back() == node->left) {\\n                res+= \\'L\\';\\n            } else {\\n                res += \\'R\\';\\n            }\\n            node = destPath.back();\\n            destPath.pop_back();\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    bool findPath(vector<TreeNode*>& path, int value, TreeNode* node) {\\n        if(node->val == value) {\\n            path.push_back(node);\\n            return true;\\n        } else if(node->left && findPath(path,value,node->left)){\\n            path.push_back(node);\\n            return true;\\n        } else if(node->right && findPath(path,value,node->right)) {\\n            path.push_back(node);\\n            return true;\\n        } else return false;\\n    }\\npublic:\\n    string getDirections(TreeNode* root, int startValue, int destValue) {\\n        vector<TreeNode*> startPath;\\n        vector<TreeNode*> destPath;\\n        findPath(startPath, startValue, root);\\n        findPath(destPath, destValue, root);\\n        TreeNode* leastCommon = root;\\n        while(startPath.size() && destPath.size() && startPath.back()==destPath.back()){\\n            leastCommon = startPath.back();\\n            startPath.pop_back();\\n            destPath.pop_back();\\n        }\\n        string res;\\n        for(auto node:startPath){\\n            res+=\\'U\\';\\n        }\\n        TreeNode *node = leastCommon;\\n        while(destPath.size()) {\\n            if(destPath.back() == node->left) {\\n                res+= \\'L\\';\\n            } else {\\n                res += \\'R\\';\\n            }\\n            node = destPath.back();\\n            destPath.pop_back();\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2295702,
                "title": "intuitive-do-as-hints-say",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\n    \\n    string head_;\\n    string tail_;\\n    \\n    bool dfs(TreeNode *node, int val, string& path) {\\n        if (!node) return false;\\n        if (node->val == val) return true;\\n        \\n        if (dfs(node->left, val, path)) {\\n            path += \\'L\\';\\n            return true;\\n        } else if (dfs(node->right, val, path)) {\\n            path += \\'R\\';\\n            return true;\\n        }\\n        return false;\\n    }\\n    \\n    string path() {\\n        int len = min(head_.size(), tail_.size());\\n        int cnt = 0;\\n        reverse(head_.begin(), head_.end());\\n        reverse(tail_.begin(), tail_.end());\\n        while (cnt < len and head_[cnt] == tail_[cnt])\\n            ++cnt;\\n\\n        head_ = head_.substr(cnt);\\n        fill(head_.begin(), head_.end(), \\'U\\');\\n        tail_ = tail_.substr(cnt);\\n        return head_ + tail_;\\n    }\\n    \\npublic:\\n    string getDirections(TreeNode* root, int startValue, int destValue) {\\n        dfs(root, startValue, head_);\\n        dfs(root, destValue, tail_);\\n        return path();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\n    \\n    string head_;\\n    string tail_;\\n    \\n    bool dfs(TreeNode *node, int val, string& path) {\\n        if (!node) return false;\\n        if (node->val == val) return true;\\n        \\n        if (dfs(node->left, val, path)) {\\n            path += \\'L\\';\\n            return true;\\n        } else if (dfs(node->right, val, path)) {\\n            path += \\'R\\';\\n            return true;\\n        }\\n        return false;\\n    }\\n    \\n    string path() {\\n        int len = min(head_.size(), tail_.size());\\n        int cnt = 0;\\n        reverse(head_.begin(), head_.end());\\n        reverse(tail_.begin(), tail_.end());\\n        while (cnt < len and head_[cnt] == tail_[cnt])\\n            ++cnt;\\n\\n        head_ = head_.substr(cnt);\\n        fill(head_.begin(), head_.end(), \\'U\\');\\n        tail_ = tail_.substr(cnt);\\n        return head_ + tail_;\\n    }\\n    \\npublic:\\n    string getDirections(TreeNode* root, int startValue, int destValue) {\\n        dfs(root, startValue, head_);\\n        dfs(root, destValue, tail_);\\n        return path();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2284232,
                "title": "go-dfs-3-steps",
                "content": "```\\nfunc getDirections(root *TreeNode, startValue int, destValue int) string {\\n    var sPath, ePath []string\\n\\n    search(root, &sPath, &startValue)\\n    search(root, &ePath, &destValue)\\n\\n    reverse(sPath)\\n    reverse(ePath)\\n\\n    i := 0\\n    \\n    for i < len(sPath) && i < len(ePath) {\\n        if sPath[i] == ePath[i] {\\n            i++\\n        } else {\\n            break\\n        }\\n    }\\n\\n    sPath = sPath[i:]\\n    ePath = ePath[i:]\\n    \\n    for j := 0; j < len(sPath); j++ {\\n        sPath[j] = \"U\"\\n    }\\n    \\n    return strings.Join(sPath, \"\") + strings.Join(ePath, \"\")\\n}\\n\\nfunc reverse(arr []string) {\\n    if len(arr) == 0 {\\n        return\\n    }\\n    \\n    l, r := 0, len(arr)-1\\n    \\n    for l < r {\\n        arr[l], arr[r] = arr[r], arr[l]\\n        l++\\n        r--\\n    }\\n}\\n\\nfunc search(root *TreeNode, path *[]string, target *int) bool {\\n    if root == nil { \\n        return false\\n    }\\n    \\n    if root.Val == *target {\\n        return true\\n    }\\n    \\n    if root.Left == nil && root.Right == nil {\\n        return false\\n    }\\n    \\n    if root.Left != nil {\\n        if search(root.Left, path, target) {\\n            *path = append(*path, \"L\")\\n            return true\\n        }\\n    }\\n    \\n    if root.Right != nil {\\n        if search(root.Right, path, target) {\\n            *path = append(*path, \"R\")\\n            return true\\n        }\\n    }\\n    \\n    return false\\n}\\n\\n```",
                "solutionTags": [
                    "Go",
                    "Depth-First Search",
                    "Breadth-First Search"
                ],
                "code": "```\\nfunc getDirections(root *TreeNode, startValue int, destValue int) string {\\n    var sPath, ePath []string\\n\\n    search(root, &sPath, &startValue)\\n    search(root, &ePath, &destValue)\\n\\n    reverse(sPath)\\n    reverse(ePath)\\n\\n    i := 0\\n    \\n    for i < len(sPath) && i < len(ePath) {\\n        if sPath[i] == ePath[i] {\\n            i++\\n        } else {\\n            break\\n        }\\n    }\\n\\n    sPath = sPath[i:]\\n    ePath = ePath[i:]\\n    \\n    for j := 0; j < len(sPath); j++ {\\n        sPath[j] = \"U\"\\n    }\\n    \\n    return strings.Join(sPath, \"\") + strings.Join(ePath, \"\")\\n}\\n\\nfunc reverse(arr []string) {\\n    if len(arr) == 0 {\\n        return\\n    }\\n    \\n    l, r := 0, len(arr)-1\\n    \\n    for l < r {\\n        arr[l], arr[r] = arr[r], arr[l]\\n        l++\\n        r--\\n    }\\n}\\n\\nfunc search(root *TreeNode, path *[]string, target *int) bool {\\n    if root == nil { \\n        return false\\n    }\\n    \\n    if root.Val == *target {\\n        return true\\n    }\\n    \\n    if root.Left == nil && root.Right == nil {\\n        return false\\n    }\\n    \\n    if root.Left != nil {\\n        if search(root.Left, path, target) {\\n            *path = append(*path, \"L\")\\n            return true\\n        }\\n    }\\n    \\n    if root.Right != nil {\\n        if search(root.Right, path, target) {\\n            *path = append(*path, \"R\")\\n            return true\\n        }\\n    }\\n    \\n    return false\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2279740,
                "title": "python-intuitive-find-lca-and-compute-steps",
                "content": "Step 1 uses the same iterative approach as findLowestCommonAncestor of two nodes\\n\\n```\\ndef getDirections(self, root: Optional[TreeNode], startValue: int, destValue: int) -> str:\\n\\t# 1. find lowestCommonAncestor of the two values\\n\\tdef findLCA_iterative(root):\\n\\t\\tstack = [root]\\n\\t\\twhile startValue not in parent or destValue not in parent:\\n\\t\\t\\tnode = stack.pop()\\n\\t\\t\\tif node.left:\\n\\t\\t\\t\\tparent[node.left.val] = node\\n\\t\\t\\t\\tstack.append(node.left)\\n\\t\\t\\tif node.right:\\n\\t\\t\\t\\tparent[node.right.val] = node\\n\\t\\t\\t\\tstack.append(node.right)\\n\\n\\t\\tancestors = set()\\n\\t\\tk = startValue\\n\\t\\twhile k in parent:\\n\\t\\t\\tancestors.add(k)\\n\\t\\t\\tk = parent[k].val if parent[k] else None\\n\\n\\t\\tlca_value = destValue\\n\\t\\twhile lca_value not in ancestors:\\n\\t\\t\\tlca_value = parent[lca_value].val\\n\\n\\t\\treturn lca_value\\n\\n\\tparent = {root.val: None} # value to node\\n\\tlca_value = findLCA_iterative(root)\\n\\n\\t# 2. recursively traverse up parent to see how many ups we need to reach lca from start\\n\\tsb = []\\n\\twhile startValue != lca_value:\\n\\t\\tstartValue = parent[startValue].val\\n\\t\\tsb.append(\\'U\\')\\n\\n\\t# 3. starting from destination node, traverse up parent and reverse the order of the steps performed\\n\\ttemp = []\\n\\tprev_val = destValue\\n\\twhile prev_val != lca_value:\\n\\t\\tparent_node = parent[prev_val]\\n\\t\\tif parent_node.left and parent_node.left.val == prev_val:\\n\\t\\t\\ttemp.append(\\'L\\')\\n\\t\\telse:\\n\\t\\t\\ttemp.append(\\'R\\')\\n\\t\\tprev_val = parent_node.val\\n\\n\\t# 4. return output from 2 + reversed(3)\\n\\tsb.extend(temp[::-1])\\n\\treturn \\'\\'.join(sb)\\n```",
                "solutionTags": [
                    "Python",
                    "Tree"
                ],
                "code": "```\\ndef getDirections(self, root: Optional[TreeNode], startValue: int, destValue: int) -> str:\\n\\t# 1. find lowestCommonAncestor of the two values\\n\\tdef findLCA_iterative(root):\\n\\t\\tstack = [root]\\n\\t\\twhile startValue not in parent or destValue not in parent:\\n\\t\\t\\tnode = stack.pop()\\n\\t\\t\\tif node.left:\\n\\t\\t\\t\\tparent[node.left.val] = node\\n\\t\\t\\t\\tstack.append(node.left)\\n\\t\\t\\tif node.right:\\n\\t\\t\\t\\tparent[node.right.val] = node\\n\\t\\t\\t\\tstack.append(node.right)\\n\\n\\t\\tancestors = set()\\n\\t\\tk = startValue\\n\\t\\twhile k in parent:\\n\\t\\t\\tancestors.add(k)\\n\\t\\t\\tk = parent[k].val if parent[k] else None\\n\\n\\t\\tlca_value = destValue\\n\\t\\twhile lca_value not in ancestors:\\n\\t\\t\\tlca_value = parent[lca_value].val\\n\\n\\t\\treturn lca_value\\n\\n\\tparent = {root.val: None} # value to node\\n\\tlca_value = findLCA_iterative(root)\\n\\n\\t# 2. recursively traverse up parent to see how many ups we need to reach lca from start\\n\\tsb = []\\n\\twhile startValue != lca_value:\\n\\t\\tstartValue = parent[startValue].val\\n\\t\\tsb.append(\\'U\\')\\n\\n\\t# 3. starting from destination node, traverse up parent and reverse the order of the steps performed\\n\\ttemp = []\\n\\tprev_val = destValue\\n\\twhile prev_val != lca_value:\\n\\t\\tparent_node = parent[prev_val]\\n\\t\\tif parent_node.left and parent_node.left.val == prev_val:\\n\\t\\t\\ttemp.append(\\'L\\')\\n\\t\\telse:\\n\\t\\t\\ttemp.append(\\'R\\')\\n\\t\\tprev_val = parent_node.val\\n\\n\\t# 4. return output from 2 + reversed(3)\\n\\tsb.extend(temp[::-1])\\n\\treturn \\'\\'.join(sb)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2274243,
                "title": "simple-bfs-dfs-solution",
                "content": "class Solution {\\n    Map<TreeNode, TreeNode> parent = new HashMap<>();\\n    \\n    public void parent_dfs(TreeNode root, TreeNode p) {\\n        if(root == null) return;\\n        parent.put(root, p);\\n        parent_dfs(root.left, root);\\n        parent_dfs(root.right, root);\\n    }\\n    \\n    public TreeNode nodeFinder(TreeNode cur, int val) {\\n            TreeNode result = null;\\n        if(cur.left != null)\\n            result = nodeFinder(cur.left,val);\\n\\n\\n        if(cur.val == val)\\n            return cur;\\n        if(result ==null && cur.right != null)\\n            result = nodeFinder(cur.right,val);\\n\\n        return result;\\n        }\\n        \\n    \\n    public String shortestPathBFS(TreeNode root, TreeNode src, int destValue) {\\n        String resultant = \"\";\\n        Queue<Pair<TreeNode, String>> Q = new ArrayDeque();\\n        Q.offer(new Pair<>(src, resultant));\\n        \\n        Set<TreeNode> visited = new HashSet<>();\\n        \\n        while (!Q.isEmpty()) {\\n            \\n            \\n            Pair<TreeNode, String> p = Q.poll();\\n            String currPath = p.getValue();\\n            TreeNode currNode = p.getKey();\\n            \\n            if (currNode.val == destValue) {\\n                return currPath;\\n            }\\n            \\n                visited.add(currNode);\\n            \\n            if (currNode.left != null && !visited.contains(currNode.left)) {\\n                Q.offer(new Pair(currNode.left, currPath+ \"L\"));\\n            }\\n            \\n            if (currNode.right != null && !visited.contains(currNode.right)) {\\n                Q.offer(new Pair(currNode.right, currPath+ \"R\"));\\n            }\\n            \\n            if (parent.get(currNode) != null && !visited.contains(parent.get(currNode)) ) {\\n                Q.offer(new Pair(parent.get(currNode), currPath+\"U\") );\\n            }\\n        \\n       }\\n        \\n        return resultant;\\n        \\n        \\n    }\\n    \\n    public String getDirections(TreeNode root, int startValue, int destValue) {\\n        parent_dfs(root, null);\\n        TreeNode src = nodeFinder(root, startValue);\\n        return shortestPathBFS(root, src, destValue);\\n        \\n        \\n    }\\n}",
                "solutionTags": [
                    "Depth-First Search",
                    "Breadth-First Search"
                ],
                "code": "class Solution {\\n    Map<TreeNode, TreeNode> parent = new HashMap<>();\\n    \\n    public void parent_dfs(TreeNode root, TreeNode p) {\\n        if(root == null) return;\\n        parent.put(root, p);\\n        parent_dfs(root.left, root);\\n        parent_dfs(root.right, root);\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 2250584,
                "title": "python-solution",
                "content": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def getDirections(self, root: Optional[TreeNode], startValue: int, destValue: int) -> str:\\n        res=\"\"\\n        stack = [root]\\n        parent = {root: None}\\n        while(stack):\\n            top = stack.pop()\\n            if top.val == startValue:\\n                p = top\\n            if top.val == destValue:\\n                q = top\\n            if top.left:\\n                stack.append(top.left)\\n                parent[top.left] = top\\n            if top.right:\\n                stack.append(top.right)\\n                parent[top.right] = top\\n\\n        ancestors = set()\\n        pp = p\\n        destPath = \"\"\\n        startPath = \"\"\\n        while(p):\\n            ancestors.add(p)\\n            p = parent[p]\\n\\n        while q not in ancestors:\\n            if parent[q].left == q:\\n                destPath+=\"L\"\\n            if parent[q].right == q:\\n                destPath+=\"R\"\\n            q = parent[q]\\n\\n        while pp != q:\\n            startPath+=\"U\"\\n            pp = parent[pp]\\n            \\n        return startPath+destPath[::-1]\\n        \\n\\t\\t```",
                "solutionTags": [],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def getDirections(self, root: Optional[TreeNode], startValue: int, destValue: int) -> str:\\n        res=\"\"\\n        stack = [root]\\n        parent = {root: None}\\n        while(stack):\\n            top = stack.pop()\\n            if top.val == startValue:\\n                p = top\\n            if top.val == destValue:\\n                q = top\\n            if top.left:\\n                stack.append(top.left)\\n                parent[top.left] = top\\n            if top.right:\\n                stack.append(top.right)\\n                parent[top.right] = top\\n\\n        ancestors = set()\\n        pp = p\\n        destPath = \"\"\\n        startPath = \"\"\\n        while(p):\\n            ancestors.add(p)\\n            p = parent[p]\\n\\n        while q not in ancestors:\\n            if parent[q].left == q:\\n                destPath+=\"L\"\\n            if parent[q].right == q:\\n                destPath+=\"R\"\\n            q = parent[q]\\n\\n        while pp != q:\\n            startPath+=\"U\"\\n            pp = parent[pp]\\n            \\n        return startPath+destPath[::-1]\\n        \\n\\t\\t```",
                "codeTag": "Java"
            },
            {
                "id": 2225063,
                "title": "java-o-n-straight-forward-lca-dfs",
                "content": "- Get LCA node\\n- Traverse from LCA to startValue. fill the direction to array\\n- Traverse from LCA to endValue. fill the direction to array\\n- Merge the result to StringBuilder\\n\\n\\n```\\nclass Solution {\\n    public String getDirections(TreeNode root, int startValue, int destValue) {\\n        if (root == null) return \"\";\\n        \\n        StringBuilder sb = new StringBuilder();\\n        List<Character> moveStart = new ArrayList();\\n        List<Character> moveDest = new ArrayList();\\n        \\n        TreeNode lca = getLCA(root, startValue, destValue);\\n        fillMove(lca, startValue, moveStart);\\n        fillMove(lca, destValue, moveDest);\\n        \\n        for (Character c : moveStart) {\\n            sb.append(\\'U\\');\\n        }\\n        \\n        for (int i = moveDest.size()-1; i >= 0; i--) {\\n            sb.append(moveDest.get(i));\\n        }\\n        \\n        return sb.toString();\\n    }\\n    \\n    private TreeNode getLCA(\\n        TreeNode node, \\n        int startValue, \\n        int destValue\\n    ) {\\n        if (node == null || node.val == startValue || node.val == destValue) return node;\\n        \\n        TreeNode left = getLCA(node.left, startValue, destValue);\\n        TreeNode right = getLCA(node.right, startValue, destValue);\\n        \\n        if (left != null && right != null) return node;\\n        if (left != null) return left;\\n        if (right != null) return right;\\n        \\n        return null;\\n    }\\n    \\n    private TreeNode fillMove(\\n        TreeNode node,\\n        int value,\\n        List<Character> move\\n    ) {\\n        if (node == null) return null;\\n        if (node.val == value)  return node;\\n        \\n        TreeNode left = fillMove(node.left, value, move);\\n        if (left != null) move.add(\\'L\\');\\n        TreeNode right = fillMove(node.right, value, move);\\n        if (right != null) move.add(\\'R\\');\\n        \\n        return left != null ? left : right;\\n    }    \\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public String getDirections(TreeNode root, int startValue, int destValue) {\\n        if (root == null) return \"\";\\n        \\n        StringBuilder sb = new StringBuilder();\\n        List<Character> moveStart = new ArrayList();\\n        List<Character> moveDest = new ArrayList();\\n        \\n        TreeNode lca = getLCA(root, startValue, destValue);\\n        fillMove(lca, startValue, moveStart);\\n        fillMove(lca, destValue, moveDest);\\n        \\n        for (Character c : moveStart) {\\n            sb.append(\\'U\\');\\n        }\\n        \\n        for (int i = moveDest.size()-1; i >= 0; i--) {\\n            sb.append(moveDest.get(i));\\n        }\\n        \\n        return sb.toString();\\n    }\\n    \\n    private TreeNode getLCA(\\n        TreeNode node, \\n        int startValue, \\n        int destValue\\n    ) {\\n        if (node == null || node.val == startValue || node.val == destValue) return node;\\n        \\n        TreeNode left = getLCA(node.left, startValue, destValue);\\n        TreeNode right = getLCA(node.right, startValue, destValue);\\n        \\n        if (left != null && right != null) return node;\\n        if (left != null) return left;\\n        if (right != null) return right;\\n        \\n        return null;\\n    }\\n    \\n    private TreeNode fillMove(\\n        TreeNode node,\\n        int value,\\n        List<Character> move\\n    ) {\\n        if (node == null) return null;\\n        if (node.val == value)  return node;\\n        \\n        TreeNode left = fillMove(node.left, value, move);\\n        if (left != null) move.add(\\'L\\');\\n        TreeNode right = fillMove(node.right, value, move);\\n        if (right != null) move.add(\\'R\\');\\n        \\n        return left != null ? left : right;\\n    }    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2200298,
                "title": "python-find-lca-using-preorder-traversals",
                "content": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def getDirections(self, root: Optional[TreeNode], startValue: int, destValue: int) -> str:\\n        def preorderFind(root, x, pre, path):\\n            if not root:\\n                return None, None\\n            \\n            if root.val == x:\\n                pre.append(x)\\n                return pre, path\\n              \\n            pre.append(root.val)\\n            path.append(\\'L\\')\\n            preL, pathL = preorderFind(root.left, x, pre, path)\\n            if preL:\\n                return preL, pathL\\n            path.pop()\\n            \\n            path.append(\\'R\\')\\n            preR, pathR = preorderFind(root.right, x, pre, path)\\n            if preR:\\n                return preR, pathR\\n            path.pop()\\n            \\n            pre.pop()\\n            \\n            return None, None\\n        \\n        # Do preorder traversals and find paths of start and dest nodes.\\n        # These give us paths from \"root -> ... LCA ... -> start\" and \"root -> ... LCA ... -> dest\".\\n        preS, pathS = preorderFind(root, startValue, [], [])\\n        preD, pathD = preorderFind(root, destValue, [], [])\\n        \\n        # Find LCA of start and dest (i-1 will be the LCA)\\n        i = 0\\n        while i < len(preS) and i < len(preD) and preS[i] == preD[i]:\\n            i += 1\\n            \\n        # Shortest path between start and dest is start -> LCA -> dest.\\n        # Reverse of LCA -> start will be UUUU... of the same length.\\n        for j in range(i-1, len(pathS)):\\n            pathS[j] = \\'U\\'\\n        \\n        # We\\'re not concerned about root but only the LCA.\\n        # Shortest path is start -> LCA + LCA -> dest.\\n        return \"\".join(pathS[i-1:] + pathD[i-1:])\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def getDirections(self, root: Optional[TreeNode], startValue: int, destValue: int) -> str:\\n        def preorderFind(root, x, pre, path):\\n            if not root:\\n                return None, None\\n            \\n            if root.val == x:\\n                pre.append(x)\\n                return pre, path\\n              \\n            pre.append(root.val)\\n            path.append(\\'L\\')\\n            preL, pathL = preorderFind(root.left, x, pre, path)\\n            if preL:\\n                return preL, pathL\\n            path.pop()\\n            \\n            path.append(\\'R\\')\\n            preR, pathR = preorderFind(root.right, x, pre, path)\\n            if preR:\\n                return preR, pathR\\n            path.pop()\\n            \\n            pre.pop()\\n            \\n            return None, None\\n        \\n        # Do preorder traversals and find paths of start and dest nodes.\\n        # These give us paths from \"root -> ... LCA ... -> start\" and \"root -> ... LCA ... -> dest\".\\n        preS, pathS = preorderFind(root, startValue, [], [])\\n        preD, pathD = preorderFind(root, destValue, [], [])\\n        \\n        # Find LCA of start and dest (i-1 will be the LCA)\\n        i = 0\\n        while i < len(preS) and i < len(preD) and preS[i] == preD[i]:\\n            i += 1\\n            \\n        # Shortest path between start and dest is start -> LCA -> dest.\\n        # Reverse of LCA -> start will be UUUU... of the same length.\\n        for j in range(i-1, len(pathS)):\\n            pathS[j] = \\'U\\'\\n        \\n        # We\\'re not concerned about root but only the LCA.\\n        # Shortest path is start -> LCA + LCA -> dest.\\n        return \"\".join(pathS[i-1:] + pathD[i-1:])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2199034,
                "title": "c-recursive-approch-esay-to-understand-using-lca",
                "content": "class Solution {\\npublic:\\n    \\n    TreeNode* LCA(TreeNode* root, int val1, int val2){\\n        \\n        if(root == NULL) return NULL;\\n        \\n        TreeNode* left = LCA(root->left, val1, val2);\\n        TreeNode* right = LCA(root->right, val1, val2);\\n        \\n        \\n        if(left != NULL and right != NULL){\\n            return root;\\n        }\\n        else if(root->val == val1 or root->val == val2){\\n            return root;\\n        }\\n        else if(left) return left;\\n        else if(right) return right;\\n        \\n        \\n        return NULL;\\n        \\n        \\n    }\\n    \\n\\n    \\n    bool ltos(TreeNode* root, int val, string &s){\\n        \\n        if(root == NULL) return false;\\n        \\n        if(root->val == val) return true;\\n        \\n        bool left = ltos(root->left, val, s);\\n        bool right = ltos(root->right, val, s);\\n        \\n        if(left or right){\\n            s += \\'U\\';\\n            return true;\\n        }\\n        \\n        return false;\\n    }\\n    \\n    bool ltod(TreeNode* root, int val, string &s){\\n        \\n        if(root == NULL) return false;\\n        \\n        if(root->val == val) return true;\\n        \\n        s += \\'L\\';\\n        \\n        bool left = ltod(root->left, val, s);\\n        \\n        if(left) return true;\\n        \\n        s.pop_back();\\n        \\n        s += \\'R\\';\\n        \\n        bool right = ltod(root->right, val, s);\\n        \\n        if(right) return true;\\n        \\n        s.pop_back();\\n        \\n        return false;\\n    }\\n    \\n    string getDirections(TreeNode* root, int startValue, int destValue) {\\n        \\n        TreeNode* lca = LCA(root, startValue, destValue);\\n        \\n        \\n        \\n        string s1 = \"\";\\n        ltos(lca, startValue, s1);\\n        \\n        string s2 = \"\";\\n        \\n        ltod(lca, destValue, s2);\\n        \\n        string res = s1 + s2;\\n        \\n        return res;\\n        \\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "class Solution {\\npublic:\\n    \\n    TreeNode* LCA(TreeNode* root, int val1, int val2){\\n        \\n        if(root == NULL) return NULL;\\n        \\n        TreeNode* left = LCA(root->left, val1, val2);\\n        TreeNode* right = LCA(root->right, val1, val2);\\n        \\n        \\n        if(left != NULL and right != NULL){\\n            return root;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2189250,
                "title": "python-bfs-solution",
                "content": "Step 1 : Get the source and desitination path using BFS\\nStep 2 : Remove the common path between the source and destination\\nStep 3 : Convert the remaining path for source to \\'U\\' and append the remaining destination path.\\n\\n\\n```\\nclass Solution:\\n    def getDirections(self, root: Optional[TreeNode], startValue: int, destValue: int) -> str:\\n\\n        \\n        stack = [(root,\"\")]\\n        while stack :\\n            x, p = stack.pop(0)\\n            if not(x):\\n                continue\\n            elif x.val == startValue:\\n                source = p\\n            elif x.val == destValue:\\n                dest = p\\n                \\n            stack.append((x.left, p+\\'L\\'))\\n            stack.append((x.right, p+\\'R\\'))\\n            \\n\\n        for i in range(max(len(source), len(dest))):\\n            if i == len(source):\\n                return dest[i:]\\n            if i == len(dest):\\n                return \\'U\\'*(len(source)-i)\\n            if source[i]!=dest[i]:\\n                return \\'U\\'*(len(source)-i) + dest[i:]\\n            \\n        return \"\"\\n",
                "solutionTags": [
                    "Python",
                    "Breadth-First Search"
                ],
                "code": "Step 1 : Get the source and desitination path using BFS\\nStep 2 : Remove the common path between the source and destination\\nStep 3 : Convert the remaining path for source to \\'U\\' and append the remaining destination path.\\n\\n\\n```\\nclass Solution:\\n    def getDirections(self, root: Optional[TreeNode], startValue: int, destValue: int) -> str:\\n\\n        \\n        stack = [(root,\"\")]\\n        while stack :\\n            x, p = stack.pop(0)\\n            if not(x):\\n                continue\\n            elif x.val == startValue:\\n                source = p\\n            elif x.val == destValue:\\n                dest = p\\n                \\n            stack.append((x.left, p+\\'L\\'))\\n            stack.append((x.right, p+\\'R\\'))\\n            \\n\\n        for i in range(max(len(source), len(dest))):\\n            if i == len(source):\\n                return dest[i:]\\n            if i == len(dest):\\n                return \\'U\\'*(len(source)-i)\\n            if source[i]!=dest[i]:\\n                return \\'U\\'*(len(source)-i) + dest[i:]\\n            \\n        return \"\"\\n",
                "codeTag": "Java"
            },
            {
                "id": 2186107,
                "title": "python-lca-dfs-with-explanation",
                "content": "Please upvote if you like the sol\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def getDirections(self, root: Optional[TreeNode], startValue: int, destValue: int) -> str:\\n        # dfs recursion\\n        def dfs(node, path, target):\\n            if node:\\n                # if the target in left\\n                if dfs(node.left, path, target):\\n                    # this will return when node.val == target\\n                    # if we come from node to left appendleft L\\n                    # appendleft is because we want RLR kind of direction from top to bottom\\n                    # there is no need for value add here\\n                    # i did it to understand the path\\n                    path.appendleft((\\'L\\', node.left.val))\\n                    return True                    \\n                if node.val == target:\\n                    return True                \\n                if dfs(node.right, path, target):\\n                    path.appendleft((\\'R\\', node.right.val))\\n                    return True\\n            return False\\n                \\n        l_path = deque()\\n        r_path = deque()\\n        dfs(root, l_path, startValue)\\n        dfs(root, r_path, destValue)\\n        l_path.appendleft((\\'\\', root.val))\\n        r_path.appendleft((\\'\\', root.val))\\n        \\n        # while left of both l_path == r_patj\\n        # we need to pop\\n        # this is because root might not be the LCA of both\\n        # basically we are trying to find LCA \\n        while l_path and r_path and l_path[0] == r_path[0]:\\n            l_n = l_path.popleft()\\n            r_n = r_path.popleft()\\n        # this assertion is because we will stop at LCA always\\n        # we can solve LCA the same way as well\\n        assert l_n == r_n\\n        return \\'U\\'*len(l_path) + \\'\\'.join([d for d, v in r_path])\\n```",
                "solutionTags": [
                    "Python",
                    "Depth-First Search"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def getDirections(self, root: Optional[TreeNode], startValue: int, destValue: int) -> str:\\n        # dfs recursion\\n        def dfs(node, path, target):\\n            if node:\\n                # if the target in left\\n                if dfs(node.left, path, target):\\n                    # this will return when node.val == target\\n                    # if we come from node to left appendleft L\\n                    # appendleft is because we want RLR kind of direction from top to bottom\\n                    # there is no need for value add here\\n                    # i did it to understand the path\\n                    path.appendleft((\\'L\\', node.left.val))\\n                    return True                    \\n                if node.val == target:\\n                    return True                \\n                if dfs(node.right, path, target):\\n                    path.appendleft((\\'R\\', node.right.val))\\n                    return True\\n            return False\\n                \\n        l_path = deque()\\n        r_path = deque()\\n        dfs(root, l_path, startValue)\\n        dfs(root, r_path, destValue)\\n        l_path.appendleft((\\'\\', root.val))\\n        r_path.appendleft((\\'\\', root.val))\\n        \\n        # while left of both l_path == r_patj\\n        # we need to pop\\n        # this is because root might not be the LCA of both\\n        # basically we are trying to find LCA \\n        while l_path and r_path and l_path[0] == r_path[0]:\\n            l_n = l_path.popleft()\\n            r_n = r_path.popleft()\\n        # this assertion is because we will stop at LCA always\\n        # we can solve LCA the same way as well\\n        assert l_n == r_n\\n        return \\'U\\'*len(l_path) + \\'\\'.join([d for d, v in r_path])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2150128,
                "title": "simple-java-soultion",
                "content": "```\\nclass Solution {\\n    private StringBuilder toStart, toDest;\\n    public String getDirections(TreeNode root, int startValue, int destValue) {\\n        dfs(root, startValue, destValue, new StringBuilder(), 0);\\n        while(0 < toStart.length() && 0 < toDest.length() && toStart.charAt(0) == toDest.charAt(0)) {\\n            toStart.deleteCharAt(0);\\n            toDest.deleteCharAt(0);\\n        }\\n        for(int i = 0; i < toStart.length(); i++) toStart.setCharAt(i, \\'U\\');\\n        toStart.append(toDest);\\n        return toStart.toString();\\n    }\\n    private void dfs(TreeNode node, int startValue, int destValue, StringBuilder builder, int index) {\\n        if(node == null) return;\\n        if(node.val == startValue) toStart = new StringBuilder(builder);\\n        else if(node.val == destValue) toDest = new StringBuilder(builder);\\n        dfs(node.left, startValue, destValue, builder.append(\\'L\\'), index + 1);\\n        builder.deleteCharAt(index);\\n        dfs(node.right, startValue, destValue, builder.append(\\'R\\'), index + 1);\\n        builder.deleteCharAt(index);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "String",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    private StringBuilder toStart, toDest;\\n    public String getDirections(TreeNode root, int startValue, int destValue) {\\n        dfs(root, startValue, destValue, new StringBuilder(), 0);\\n        while(0 < toStart.length() && 0 < toDest.length() && toStart.charAt(0) == toDest.charAt(0)) {\\n            toStart.deleteCharAt(0);\\n            toDest.deleteCharAt(0);\\n        }\\n        for(int i = 0; i < toStart.length(); i++) toStart.setCharAt(i, \\'U\\');\\n        toStart.append(toDest);\\n        return toStart.toString();\\n    }\\n    private void dfs(TreeNode node, int startValue, int destValue, StringBuilder builder, int index) {\\n        if(node == null) return;\\n        if(node.val == startValue) toStart = new StringBuilder(builder);\\n        else if(node.val == destValue) toDest = new StringBuilder(builder);\\n        dfs(node.left, startValue, destValue, builder.append(\\'L\\'), index + 1);\\n        builder.deleteCharAt(index);\\n        dfs(node.right, startValue, destValue, builder.append(\\'R\\'), index + 1);\\n        builder.deleteCharAt(index);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2136388,
                "title": "2-ideas-explained-lca-bfs-from-start-node-to-end-node-python-solution-with-comments",
                "content": "2 IDEAS:\\n\\nIdea1:\\n1. Find LCA of start and end nodes.\\n2. find start and end nodes from lca and store paths\\n3. Replace start path from LCA with \\'U\\' and reverse the end path and join with the start path.\\n4. \\n\\n\\n\\n\\n    def getDirections(self, root: Optional[TreeNode], startValue: int, destValue: int) -> str:\\n\\t\\tdef find_lca(root):\\n            if not root:\\n                return None\\n            if root.val == startValue or root.val == destValue:\\n                return root\\n            left = find_lca(root.left)\\n            right = find_lca(root.right)      \\t\\t\\t\\t\\n            if left and right:\\n                return root\\n            \\n            return left if left else right\\n        \\n\\n\\t\\t\\t\\n        def find(root,search,path):\\n            if root.val == search:\\n                return True\\n            \\n            if root.left and find(root.left,search,path):\\n                path.append(\\'L\\')\\n                return path\\n            elif root.right and find(root.right,search,path):\\n                path.append( \\'R\\')\\n                return path\\n            \\n            return False\\n            \\n      \\n        lca = find_lca(root)\\n        start_path,dest_path = list(),list()\\n        find(lca,startValue,start_path)\\n        find(lca,destValue,dest_path)\\n        return \"U\"*len(start_path) + \\'\\'.join(dest_path[::-1])\\n\\n\\nIdea 2:\\n1. DFS from root and add parents of each nodes to a map.\\n2. While traversing, store start node and end node.\\n3. Do a BFS from start node - include left child, right child and parent from the dictionary created on DFS. Maitain a \\'visited\\' set to track the nodes that are already visited. Store path with each iteration. \\'L\\' in case of left child , \\'R\\' in case of right child, \\'U\\' in case of parent.\\n4. Continue BFS until the end node is found. The path on that particular iteration would be the return value.\\n5. \\n\\n    def getDirections(self, root: Optional[TreeNode], startValue: int, destValue: int) -> str:\\n        self.parents = dict()\\n        self.src,self.dest = None,None\\n        \\n        def create_parents(root,parent):\\n            self.parents[root] = parent\\n            if root.val == startValue:\\n                self.src = root\\n            if root.val == destValue:\\n                self.dest = root\\n                \\n            if root.left:\\n                create_parents(root.left,root)\\n            if root.right:\\n                create_parents(root.right,root)\\n        \\n        create_parents(root,None)\\n        que = deque([(self.src,\\'\\')])\\n        visited = set()\\n        while que:\\n            node,path = que.popleft()\\n            if node.val == destValue:\\n                return path\\n            \\n            if node.left and node.left.val not in visited:\\n                visited.add(node.left.val)\\n                que.append((node.left,path+\\'L\\'))\\n\\n            if node.right and node.right.val not in visited:\\n                visited.add(node.right.val)\\n                que.append((node.right,path+\\'R\\'))\\n\\n            if self.parents[node] and self.parents[node].val not in visited:\\n                visited.add(self.parents[node].val)\\n                que.append((self.parents[node],path+\\'U\\'))\\n        \\n        return -1\\n\\t\\t\\n\\t\\t",
                "solutionTags": [
                    "Python",
                    "Depth-First Search",
                    "Breadth-First Search"
                ],
                "code": "2 IDEAS:\\n\\nIdea1:\\n1. Find LCA of start and end nodes.\\n2. find start and end nodes from lca and store paths\\n3. Replace start path from LCA with \\'U\\' and reverse the end path and join with the start path.\\n4. \\n\\n\\n\\n\\n    def getDirections(self, root: Optional[TreeNode], startValue: int, destValue: int) -> str:\\n\\t\\tdef find_lca(root):\\n            if not root:\\n                return None\\n            if root.val == startValue or root.val == destValue:\\n                return root\\n            left = find_lca(root.left)\\n            right = find_lca(root.right)      \\t\\t\\t\\t\\n            if left and right:\\n                return root\\n            \\n            return left if left else right\\n        \\n\\n\\t\\t\\t\\n        def find(root,search,path):\\n            if root.val == search:\\n                return True\\n            \\n            if root.left and find(root.left,search,path):\\n                path.append(\\'L\\')\\n                return path\\n            elif root.right and find(root.right,search,path):\\n                path.append( \\'R\\')\\n                return path\\n            \\n            return False\\n            \\n      \\n        lca = find_lca(root)\\n        start_path,dest_path = list(),list()\\n        find(lca,startValue,start_path)\\n        find(lca,destValue,dest_path)\\n        return \"U\"*len(start_path) + \\'\\'.join(dest_path[::-1])\\n\\n\\nIdea 2:\\n1. DFS from root and add parents of each nodes to a map.\\n2. While traversing, store start node and end node.\\n3. Do a BFS from start node - include left child, right child and parent from the dictionary created on DFS. Maitain a \\'visited\\' set to track the nodes that are already visited. Store path with each iteration. \\'L\\' in case of left child , \\'R\\' in case of right child, \\'U\\' in case of parent.\\n4. Continue BFS until the end node is found. The path on that particular iteration would be the return value.\\n5. \\n\\n    def getDirections(self, root: Optional[TreeNode], startValue: int, destValue: int) -> str:\\n        self.parents = dict()\\n        self.src,self.dest = None,None\\n        \\n        def create_parents(root,parent):\\n            self.parents[root] = parent\\n            if root.val == startValue:\\n                self.src = root\\n            if root.val == destValue:\\n                self.dest = root\\n                \\n            if root.left:\\n                create_parents(root.left,root)\\n            if root.right:\\n                create_parents(root.right,root)\\n        \\n        create_parents(root,None)\\n        que = deque([(self.src,\\'\\')])\\n        visited = set()\\n        while que:\\n            node,path = que.popleft()\\n            if node.val == destValue:\\n                return path\\n            \\n            if node.left and node.left.val not in visited:\\n                visited.add(node.left.val)\\n                que.append((node.left,path+\\'L\\'))\\n\\n            if node.right and node.right.val not in visited:\\n                visited.add(node.right.val)\\n                que.append((node.right,path+\\'R\\'))\\n\\n            if self.parents[node] and self.parents[node].val not in visited:\\n                visited.add(self.parents[node].val)\\n                que.append((self.parents[node],path+\\'U\\'))\\n        \\n        return -1\\n\\t\\t\\n\\t\\t",
                "codeTag": "Python3"
            },
            {
                "id": 2134518,
                "title": "java-solution-using-node-to-root-path-beginner-friendly-approach-clean-code",
                "content": "class Solution {\\n\\n    public String getDirections(TreeNode root, int startValue, int destValue) {\\n        List<TreeNode> list1 = getPath(root,startValue);\\n        List<TreeNode> list2 = getPath(root,destValue);\\n        \\n        int i = list1.size()-1;\\n        int j = list2.size()-1;\\n        \\n        while(i>=0 && j>=0){\\n            if(list1.get(i)!=list2.get(j)){\\n                break;\\n            }\\n            i--;\\n            j--;\\n        }\\n        \\n        i++;\\n        j++;\\n        \\n        StringBuilder ans = new StringBuilder();\\n        \\n        for(int ii = 0; ii<i; ii++){\\n            ans.append(\"U\");\\n        }\\n        \\n        for(int jj = j; jj>0; jj--){\\n            if(list2.get(jj-1) == list2.get(jj).left){\\n                ans.append(\"L\");\\n            }else{\\n                ans.append(\"R\");\\n            }\\n        }\\n        \\n        return ans.toString();\\n    }\\n    \\n    public List<TreeNode> getPath(TreeNode root, int node){\\n        if(root == null){\\n            return new ArrayList<>();\\n        }\\n        \\n        if(root.val == node){\\n            List<TreeNode> list = new ArrayList<>();\\n            list.add(root);\\n            return list;\\n        }\\n        \\n        List<TreeNode> left = getPath(root.left,node);\\n        if(left.size()>0){\\n            left.add(root);\\n            return left;\\n        }\\n        \\n        List<TreeNode> right = getPath(root.right,node);\\n        if(right.size()>0){\\n            right.add(root);\\n            return right;\\n        }\\n        \\n        return new ArrayList<>();\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "class Solution {\\n\\n    public String getDirections(TreeNode root, int startValue, int destValue) {\\n        List<TreeNode> list1 = getPath(root,startValue);\\n        List<TreeNode> list2 = getPath(root,destValue);\\n        \\n        int i = list1.size()-1;\\n        int j = list2.size()-1;\\n        \\n        while(i>=0 && j>=0){\\n            if(list1.get(i)!=list2.get(j)){\\n                break;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2132939,
                "title": "veryy-easyy-approach-to-this-difficult-question",
                "content": "bool search(TreeNode* root,int dest,string &ans)\\n   {\\n       if(!root)\\n           return false ;\\n       \\n       if(root->val==dest)\\n           return true;\\n       \\n       if(search(root->left,dest,ans))\\n           ans+=\\'L\\';   //ye hume backtrack krta hua ulta path dega (dest--> root)\\n       \\n       else if(search(root->right,dest,ans))\\n           ans+=\\'R\\';\\n       \\n    return ans.size()>0; //string if filled then true return krdo .False kyu return krna\\n   }\\n    string getDirections(TreeNode* root, int start, int dest) {\\n       \\n        string s1,s2;\\n        \\n        //step 1 find direction string from root to start and dest node\\n        \\n        search(root,start,s1); //direction string from root to start\\n        search(root,dest,s2);\\n        \\n        \\n        //step 2 --> 2 directions would be same till LCA of them so delete that part \\n        while(s1.size() and s2.size() and s1.back()==s2.back())\\n        {\\n            s1.pop_back();  //LCA last me hai coz path ulta hai (dest--> root)\\n            s2.pop_back();   //so last se front ki trf ayege to (root->dest);\\n        }\\n        \\n        //step 3 make the complete direction string\\n        \\n        cout<<s1<<\" \"<<s2;\\n        string ans=\"\";\\n        ans.append(s1.size(),\\'U\\');  //path from start to root = \\'U\\' only s1.size times\\n        reverse(s2.begin(),s2.end());  //reverse of s2 = path from root to dest\\n        \\n        \\n        return ans+s2;  //source to root + root to dest\\n    }",
                "solutionTags": [],
                "code": "bool search(TreeNode* root,int dest,string &ans)\\n   {\\n       if(!root)\\n           return false ;\\n       \\n       if(root->val==dest)\\n           return true;\\n       \\n       if(search(root->left,dest,ans))\\n           ans+=\\'L\\';   //ye hume backtrack krta hua ulta path dega (dest--> root)\\n       \\n       else if(search(root->right,dest,ans))\\n           ans+=\\'R\\';\\n       \\n    return ans.size()>0; //string if filled then true return krdo .False kyu return krna\\n   }\\n    string getDirections(TreeNode* root, int start, int dest) {\\n       \\n        string s1,s2;\\n        \\n        //step 1 find direction string from root to start and dest node\\n        \\n        search(root,start,s1); //direction string from root to start\\n        search(root,dest,s2);\\n        \\n        \\n        //step 2 --> 2 directions would be same till LCA of them so delete that part \\n        while(s1.size() and s2.size() and s1.back()==s2.back())\\n        {\\n            s1.pop_back();  //LCA last me hai coz path ulta hai (dest--> root)\\n            s2.pop_back();   //so last se front ki trf ayege to (root->dest);\\n        }\\n        \\n        //step 3 make the complete direction string\\n        \\n        cout<<s1<<\" \"<<s2;\\n        string ans=\"\";\\n        ans.append(s1.size(),\\'U\\');  //path from start to root = \\'U\\' only s1.size times\\n        reverse(s2.begin(),s2.end());  //reverse of s2 = path from root to dest\\n        \\n        \\n        return ans+s2;  //source to root + root to dest\\n    }",
                "codeTag": "C++"
            },
            {
                "id": 2103945,
                "title": "python3-solution-90-faster-solution",
                "content": "Instead of writing one function to find the lowest common ancestor first then writing another function to find paths from LCA to start and destination values, we can do the following\\n\\n1. find paths from root to start and destination values\\n2. Remove the longest common prefix in both of the paths\\n3. Convert elements in start path to \\'U\\' and combine it with the destination path\\n\\n```\\nclass Solution:\\n    \\n    def getDirections(self, root: Optional[TreeNode], startValue: int, destValue: int) -> str:\\n        \\n        final_paths = [[], []]\\n\\n        def path_to_node(root, cur_path, direction):\\n            nonlocal final_paths, startValue, destValue\\n            \\n            if not root:\\n                return\\n        \\n            cur_path.append(direction)\\n            \\n            if root.val == startValue:\\n                final_paths[0] = cur_path.copy()\\n            \\n            if root.val == destValue:\\n                final_paths[1] = cur_path.copy()\\n            \\n            path_to_node(root.left, cur_path, \\'L\\')\\n            path_to_node(root.right, cur_path, \\'R\\')\\n            \\n            cur_path.pop(-1)\\n        \\n        path_to_node(root, [], \\'S\\')\\n\\n        start_path = final_paths[0]\\n        dest_path = final_paths[1]\\n\\n        while len(start_path) > 0 and len(dest_path) > 0:\\n                \\n            if start_path[0] != dest_path[0]:\\n                break\\n            \\n            start_path.pop(0)\\n            dest_path.pop(0)\\n        \\n        return \\'U\\'*len(start_path) + \\'\\'.join(dest_path)\\n```\\n\\n\\n\\n\\n\\n",
                "solutionTags": [
                    "Python3",
                    "Tree",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution:\\n    \\n    def getDirections(self, root: Optional[TreeNode], startValue: int, destValue: int) -> str:\\n        \\n        final_paths = [[], []]\\n\\n        def path_to_node(root, cur_path, direction):\\n            nonlocal final_paths, startValue, destValue\\n            \\n            if not root:\\n                return\\n        \\n            cur_path.append(direction)\\n            \\n            if root.val == startValue:\\n                final_paths[0] = cur_path.copy()\\n            \\n            if root.val == destValue:\\n                final_paths[1] = cur_path.copy()\\n            \\n            path_to_node(root.left, cur_path, \\'L\\')\\n            path_to_node(root.right, cur_path, \\'R\\')\\n            \\n            cur_path.pop(-1)\\n        \\n        path_to_node(root, [], \\'S\\')\\n\\n        start_path = final_paths[0]\\n        dest_path = final_paths[1]\\n\\n        while len(start_path) > 0 and len(dest_path) > 0:\\n                \\n            if start_path[0] != dest_path[0]:\\n                break\\n            \\n            start_path.pop(0)\\n            dest_path.pop(0)\\n        \\n        return \\'U\\'*len(start_path) + \\'\\'.join(dest_path)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2094017,
                "title": "backtracking-and-lowestcommonancestor-full-explained",
                "content": "We need to find the lowest common ancestors of both the nodes first.\\nNow we will find a path from the LCA. First we find a path from LCA to start value and then we find path from LCA to destination.\\n\\nThe path from the start value will simply give Up directions as we will go upwards from the start to the LCA.\\nsimply add the path of destination we found above to these U\\'s we got from the start value.\\n\\n```\\nclass Solution {\\npublic:\\n    bool path(TreeNode* root, int n, string& p){\\n        if(!root)return false;\\n        if(root->val == n)return true;\\n        p.push_back(\\'L\\');\\n        auto pt = path(root->left,n,p);\\n        if(pt)return true;\\n        p.pop_back();\\n        p.push_back(\\'R\\');\\n       \\n        pt = path(root->right,n,p);\\n        if(pt)return true;\\n        p.pop_back();\\n        \\n        return false;\\n    }\\n    TreeNode* lca(TreeNode* root,int sv, int dv){\\n        if(!root)return NULL;\\n        if(root->val == sv or root-> val == dv)return root;\\n        auto l = lca(root->left,sv,dv);\\n        auto r = lca(root->right,sv,dv);\\n        if(l and r)return root;\\n        return r == NULL?l:r;\\n    }\\n    string getDirections(TreeNode* root, int startValue, int destValue) {\\n        string sv,dv;\\n        root =  lca(root,startValue,destValue);\\n        path(root,startValue,sv);\\n        path(root,destValue,dv);\\n        \\n        string ans;\\n        for(auto s : sv)ans.push_back(\\'U\\');\\n        ans = ans + dv;\\n    return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Backtracking",
                    "Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool path(TreeNode* root, int n, string& p){\\n        if(!root)return false;\\n        if(root->val == n)return true;\\n        p.push_back(\\'L\\');\\n        auto pt = path(root->left,n,p);\\n        if(pt)return true;\\n        p.pop_back();\\n        p.push_back(\\'R\\');\\n       \\n        pt = path(root->right,n,p);\\n        if(pt)return true;\\n        p.pop_back();\\n        \\n        return false;\\n    }\\n    TreeNode* lca(TreeNode* root,int sv, int dv){\\n        if(!root)return NULL;\\n        if(root->val == sv or root-> val == dv)return root;\\n        auto l = lca(root->left,sv,dv);\\n        auto r = lca(root->right,sv,dv);\\n        if(l and r)return root;\\n        return r == NULL?l:r;\\n    }\\n    string getDirections(TreeNode* root, int startValue, int destValue) {\\n        string sv,dv;\\n        root =  lca(root,startValue,destValue);\\n        path(root,startValue,sv);\\n        path(root,destValue,dv);\\n        \\n        string ans;\\n        for(auto s : sv)ans.push_back(\\'U\\');\\n        ans = ans + dv;\\n    return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2082631,
                "title": "c-sln-from-tree-to-graph-o-n-sln",
                "content": "```\\nstring getDirections(TreeNode* root, int startValue, int destValue) {\\n        unordered_map<int, vector<pair<int, char>>> g;\\n        function<void(TreeNode*)> treeDfs;\\n        treeDfs = [&](TreeNode* n) {\\n            if (!n) {\\n                return;\\n            }\\n            if (n->left) {\\n                g[n->val].emplace_back(n->left->val, \\'L\\');\\n                g[n->left->val].emplace_back(n->val, \\'U\\');\\n                treeDfs(n->left);\\n            }\\n            if (n->right) {\\n                g[n->val].emplace_back(n->right->val, \\'R\\');\\n                g[n->right->val].emplace_back(n->val, \\'U\\');\\n                treeDfs(n->right);\\n            }\\n        };\\n        treeDfs(root);\\n        \\n        function<bool(int, int)> graphDfs;\\n        string ans;\\n        graphDfs = [&](int v, int from) {\\n            if (v == destValue) {\\n                return true;\\n            }\\n            for (const auto[to, ch]: g[v]) {\\n                if (to != from) {\\n                    ans += ch;\\n                    if (graphDfs(to, v)) {\\n                        return true;\\n                    }\\n                    ans.pop_back();\\n                }\\n            }\\n            return false;\\n        };\\n        graphDfs(startValue, -1);\\n        return ans;\\n    }",
                "solutionTags": [],
                "code": "```\\nstring getDirections(TreeNode* root, int startValue, int destValue) {\\n        unordered_map<int, vector<pair<int, char>>> g;\\n        function<void(TreeNode*)> treeDfs;\\n        treeDfs = [&](TreeNode* n) {\\n            if (!n) {\\n                return;\\n            }\\n            if (n->left) {\\n                g[n->val].emplace_back(n->left->val, \\'L\\');\\n                g[n->left->val].emplace_back(n->val, \\'U\\');\\n                treeDfs(n->left);\\n            }\\n            if (n->right) {\\n                g[n->val].emplace_back(n->right->val, \\'R\\');\\n                g[n->right->val].emplace_back(n->val, \\'U\\');\\n                treeDfs(n->right);\\n            }\\n        };\\n        treeDfs(root);\\n        \\n        function<bool(int, int)> graphDfs;\\n        string ans;\\n        graphDfs = [&](int v, int from) {\\n            if (v == destValue) {\\n                return true;\\n            }\\n            for (const auto[to, ch]: g[v]) {\\n                if (to != from) {\\n                    ans += ch;\\n                    if (graphDfs(to, v)) {\\n                        return true;\\n                    }\\n                    ans.pop_back();\\n                }\\n            }\\n            return false;\\n        };\\n        graphDfs(startValue, -1);\\n        return ans;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2071659,
                "title": "java-lca-findpath-solution",
                "content": "```\\nclass Solution {\\n    public String getDirections(TreeNode root, int startValue, int destValue) {\\n        \\n        //Step-1: Find LCA\\n        TreeNode lca = LCA(root, startValue, destValue);\\n    \\n        //Step-2: Find Path from LCA to start\\n        List<String> pathToStart = new ArrayList<>();\\n        findPath(lca, startValue, pathToStart);\\n        \\n        //Step-3: Find Path from LCA to dest\\n        List<String> pathToDest = new ArrayList<>();\\n        findPath(lca, destValue, pathToDest);\\n\\n        //Step-4: Convert LCA to start node path to all \\'U\\'s\\n        StringBuilder result = new StringBuilder();\\n        for (int i = 0; i < pathToStart.size(); i++) {\\n            result.append(\"U\");\\n        }\\n\\t\\t\\n        //Step-5: concatenate 4 & 3 paths.\\n        for (String s : pathToDest) {\\n            result.append(s);\\n        }\\n        \\n        return result.toString();\\n    }\\n    \\n    public boolean findPath(TreeNode lca, int value, List<String> path) {\\n        if(lca == null) {\\n            return false;\\n        }\\n        \\n        if (lca.val == value) {\\n            return true;\\n        }\\n\\t\\t\\n        path.add(\"L\");\\n        boolean left = findPath(lca.left, value, path);\\n        if (left) {\\n            return true;\\n        }\\n        path.remove(path.size() - 1);\\n        \\n        path.add(\"R\");\\n        boolean right = findPath(lca.right, value, path);\\n        if (right) {\\n            return true;\\n        }\\n        path.remove(path.size() - 1);\\n        \\n        return false;\\n    }\\n    \\n    public TreeNode LCA(TreeNode root, int start, int dest) {\\n        if (root == null || root.val == start || root.val == dest) {\\n            return root;\\n        }\\n        \\n        TreeNode left = LCA(root.left, start, dest);\\n        TreeNode right = LCA(root.right, start, dest);\\n        \\n        if (left != null && right != null) {\\n            return root;\\n        }\\n        \\n        return left != null ? left : right;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public String getDirections(TreeNode root, int startValue, int destValue) {\\n        \\n        //Step-1: Find LCA\\n        TreeNode lca = LCA(root, startValue, destValue);\\n    \\n        //Step-2: Find Path from LCA to start\\n        List<String> pathToStart = new ArrayList<>();\\n        findPath(lca, startValue, pathToStart);\\n        \\n        //Step-3: Find Path from LCA to dest\\n        List<String> pathToDest = new ArrayList<>();\\n        findPath(lca, destValue, pathToDest);\\n\\n        //Step-4: Convert LCA to start node path to all \\'U\\'s\\n        StringBuilder result = new StringBuilder();\\n        for (int i = 0; i < pathToStart.size(); i++) {\\n            result.append(\"U\");\\n        }\\n\\t\\t\\n        //Step-5: concatenate 4 & 3 paths.\\n        for (String s : pathToDest) {\\n            result.append(s);\\n        }\\n        \\n        return result.toString();\\n    }\\n    \\n    public boolean findPath(TreeNode lca, int value, List<String> path) {\\n        if(lca == null) {\\n            return false;\\n        }\\n        \\n        if (lca.val == value) {\\n            return true;\\n        }\\n\\t\\t\\n        path.add(\"L\");\\n        boolean left = findPath(lca.left, value, path);\\n        if (left) {\\n            return true;\\n        }\\n        path.remove(path.size() - 1);\\n        \\n        path.add(\"R\");\\n        boolean right = findPath(lca.right, value, path);\\n        if (right) {\\n            return true;\\n        }\\n        path.remove(path.size() - 1);\\n        \\n        return false;\\n    }\\n    \\n    public TreeNode LCA(TreeNode root, int start, int dest) {\\n        if (root == null || root.val == start || root.val == dest) {\\n            return root;\\n        }\\n        \\n        TreeNode left = LCA(root.left, start, dest);\\n        TreeNode right = LCA(root.right, start, dest);\\n        \\n        if (left != null && right != null) {\\n            return root;\\n        }\\n        \\n        return left != null ? left : right;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2070637,
                "title": "one-pass-bottom-up-binary-tree-traversal-to-find-lca-java-solution-my-genuine-answer",
                "content": "Main idea: \\n-- Construct the paths from the two target nodes to their lowest common ancestor (LCA)\\n-- One pass bottom-up tree traversal to find the LCA [A Google Onsite interviewer may doubt it. How about you?]\\n-- Use a multi-value return result class to report the two target nodes\\' presences and paths from every tree node to its parent node [The biggest trick of this algorithm that can really go beyond a Google Onsite interviewer\\'s mind.]\\n-- Complete a left / right direction path from the perspective of a parent node [The 2nd biggest trick goes beyond a Google Interviewer.]\\n-- Finalize the whole result path at the only point of LCA [The 3nd biggesgt trick goes beyond.]\\n\\nClaim:\\n-- This is an original solution. I did not find anyone else using it. Forgive my blindness if I missed someone who has submitted similar answers before to leetcode. \\n-- You interviewer may not expect you deliver such an advanced solution during an interview of only 45 - 60 mins. Honestly, s/he may only pick up this problem from the interview question pool. S/He may just read through the sample answers from the problem submitter or solutions proposed by the previous candidates (I will really appreciate Her/im if S/He visits leetcode.com to collect more possible solutions and tries to deep dive this problem and cover all incoming candidates.)\\n\\n\\n\\n    class Result {\\n      boolean hasFrom;\\n      boolean hasTo;\\n      StringBuilder pathFrom = new StringBuilder();\\n      StringBuilder pathTo = new StringBuilder();\\n    }\\n  \\n    public String getDirections(TreeNode root, int valueFrom, int valueTo) {\\n      Result result = findHelper(root, valueFrom, valueTo);\\n      return result.pathFrom.toString();\\n    }\\n    \\n    private Result findHelper(TreeNode root, int valueFrom, int valueTo) {\\n      if (root == null) {\\n        return new Result();\\n      }\\n      \\n      Result leftRes = findHelper(root.left, valueFrom, valueTo);\\n      Result rightRes = findHelper(root.right, valueFrom, valueTo);\\n      if (leftRes.hasFrom && leftRes.hasTo) {\\n        return leftRes;\\n      }\\n      if (rightRes.hasFrom && rightRes.hasTo) {\\n        return rightRes;\\n      }\\n      \\n      if (leftRes.hasFrom) {\\n        leftRes.pathFrom.append(\"U\");\\n      }\\n      if (rightRes.hasFrom) {\\n        rightRes.pathFrom.append(\"U\");\\n      }\\n      if (leftRes.hasTo) {\\n        leftRes.pathTo.append(\"L\");\\n      }\\n      if (rightRes.hasTo) {\\n        rightRes.pathTo.append(\"R\");\\n      }\\n      \\n      Result result = new Result();\\n      result.hasFrom = leftRes.hasFrom || rightRes.hasFrom || (root.val == valueFrom);\\n      result.pathFrom = leftRes.hasFrom ? leftRes.pathFrom : rightRes.pathFrom;\\n      result.hasTo = leftRes.hasTo || rightRes.hasTo || (root.val == valueTo);\\n      result.pathTo = leftRes.hasTo ? leftRes.pathTo : rightRes.pathTo;\\n      \\n      if (result.hasFrom && result.hasTo) {\\n        result.pathTo.reverse();\\n        result.pathFrom.append(result.pathTo);\\n      }\\n      return result;\\n    }",
                "solutionTags": [],
                "code": "Main idea: \\n-- Construct the paths from the two target nodes to their lowest common ancestor (LCA)\\n-- One pass bottom-up tree traversal to find the LCA [A Google Onsite interviewer may doubt it. How about you?]\\n-- Use a multi-value return result class to report the two target nodes\\' presences and paths from every tree node to its parent node [The biggest trick of this algorithm that can really go beyond a Google Onsite interviewer\\'s mind.]\\n-- Complete a left / right direction path from the perspective of a parent node [The 2nd biggest trick goes beyond a Google Interviewer.]\\n-- Finalize the whole result path at the only point of LCA [The 3nd biggesgt trick goes beyond.]\\n\\nClaim:\\n-- This is an original solution. I did not find anyone else using it. Forgive my blindness if I missed someone who has submitted similar answers before to leetcode. \\n-- You interviewer may not expect you deliver such an advanced solution during an interview of only 45 - 60 mins. Honestly, s/he may only pick up this problem from the interview question pool. S/He may just read through the sample answers from the problem submitter or solutions proposed by the previous candidates (I will really appreciate Her/im if S/He visits leetcode.com to collect more possible solutions and tries to deep dive this problem and cover all incoming candidates.)\\n\\n\\n\\n    class Result {\\n      boolean hasFrom;\\n      boolean hasTo;\\n      StringBuilder pathFrom = new StringBuilder();\\n      StringBuilder pathTo = new StringBuilder();\\n    }\\n  \\n    public String getDirections(TreeNode root, int valueFrom, int valueTo) {\\n      Result result = findHelper(root, valueFrom, valueTo);\\n      return result.pathFrom.toString();\\n    }\\n    \\n    private Result findHelper(TreeNode root, int valueFrom, int valueTo) {\\n      if (root == null) {\\n        return new Result();\\n      }\\n      \\n      Result leftRes = findHelper(root.left, valueFrom, valueTo);\\n      Result rightRes = findHelper(root.right, valueFrom, valueTo);\\n      if (leftRes.hasFrom && leftRes.hasTo) {\\n        return leftRes;\\n      }\\n      if (rightRes.hasFrom && rightRes.hasTo) {\\n        return rightRes;\\n      }\\n      \\n      if (leftRes.hasFrom) {\\n        leftRes.pathFrom.append(\"U\");\\n      }\\n      if (rightRes.hasFrom) {\\n        rightRes.pathFrom.append(\"U\");\\n      }\\n      if (leftRes.hasTo) {\\n        leftRes.pathTo.append(\"L\");\\n      }\\n      if (rightRes.hasTo) {\\n        rightRes.pathTo.append(\"R\");\\n      }\\n      \\n      Result result = new Result();\\n      result.hasFrom = leftRes.hasFrom || rightRes.hasFrom || (root.val == valueFrom);\\n      result.pathFrom = leftRes.hasFrom ? leftRes.pathFrom : rightRes.pathFrom;\\n      result.hasTo = leftRes.hasTo || rightRes.hasTo || (root.val == valueTo);\\n      result.pathTo = leftRes.hasTo ? leftRes.pathTo : rightRes.pathTo;\\n      \\n      if (result.hasFrom && result.hasTo) {\\n        result.pathTo.reverse();\\n        result.pathFrom.append(result.pathTo);\\n      }\\n      return result;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 2061400,
                "title": "java-dfs-solution",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    String path;\\n    public String getDirections(TreeNode root, int startValue, int destValue) {\\n        String res = \"\";\\n        dfs(root, startValue, new StringBuilder());\\n        String sDir = path;\\n        dfs(root, destValue, new StringBuilder());\\n        String dDir = path;\\n        return combine(sDir, dDir);\\n    }\\n    \\n    boolean dfs(TreeNode cur, int value, StringBuilder direct) {\\n        if (cur == null) return false;\\n        if (cur.val == value) {\\n            path = direct.toString();\\n            return true;\\n        }\\n        if (cur.left != null) {\\n            direct.append(\"L\");\\n            if(dfs(cur.left, value, direct)) return true;\\n            direct.deleteCharAt(direct.length() - 1);\\n        }\\n        if (cur.right != null) {\\n            direct.append(\"R\");\\n            if(dfs(cur.right, value, direct)) return true;\\n            direct.deleteCharAt(direct.length() - 1);\\n        }\\n        return false;\\n    }\\n    \\n    String combine(String findingStart, String findingDest) {\\n        int j = 0;\\n        while(findingStart.length() > j && findingDest.length() > j) {\\n            if (findingStart.charAt(j) == findingDest.charAt(j)) {\\n                j++;\\n            } else {\\n                break;\\n            }\\n        }\\n        findingStart = findingStart.substring(j, findingStart.length());\\n        findingDest = findingDest.substring(j, findingDest.length());\\n        String res = \"\";\\n        int l = findingStart.length();\\n        for (int i = 0; i < l; i++) {\\n            res += \"U\";\\n        }\\n        return res + findingDest;\\n    }\\n}\\n```\\nImplement StringBuilder to save memory space.",
                "solutionTags": [],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    String path;\\n    public String getDirections(TreeNode root, int startValue, int destValue) {\\n        String res = \"\";\\n        dfs(root, startValue, new StringBuilder());\\n        String sDir = path;\\n        dfs(root, destValue, new StringBuilder());\\n        String dDir = path;\\n        return combine(sDir, dDir);\\n    }\\n    \\n    boolean dfs(TreeNode cur, int value, StringBuilder direct) {\\n        if (cur == null) return false;\\n        if (cur.val == value) {\\n            path = direct.toString();\\n            return true;\\n        }\\n        if (cur.left != null) {\\n            direct.append(\"L\");\\n            if(dfs(cur.left, value, direct)) return true;\\n            direct.deleteCharAt(direct.length() - 1);\\n        }\\n        if (cur.right != null) {\\n            direct.append(\"R\");\\n            if(dfs(cur.right, value, direct)) return true;\\n            direct.deleteCharAt(direct.length() - 1);\\n        }\\n        return false;\\n    }\\n    \\n    String combine(String findingStart, String findingDest) {\\n        int j = 0;\\n        while(findingStart.length() > j && findingDest.length() > j) {\\n            if (findingStart.charAt(j) == findingDest.charAt(j)) {\\n                j++;\\n            } else {\\n                break;\\n            }\\n        }\\n        findingStart = findingStart.substring(j, findingStart.length());\\n        findingDest = findingDest.substring(j, findingDest.length());\\n        String res = \"\";\\n        int l = findingStart.length();\\n        for (int i = 0; i < l; i++) {\\n            res += \"U\";\\n        }\\n        return res + findingDest;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2019929,
                "title": "java-best-solution-less-space-complexity-simple-way",
                "content": "```\\nclass Solution {\\n    Map<TreeNode, TreeNode> parentMap = new HashMap<>();\\n    TreeNode startNode;\\n    TreeNode destNode;\\n    public String getDirections(TreeNode root, int startValue, int destValue) {\\n        buildGraph(root, startValue, destValue);\\n        String path1 = buildPath(startNode);\\n        String path2 = buildPath(destNode);\\n        char[] c1 = path1.toCharArray();\\n        char[] c2 = path2.toCharArray();\\n        int index = 0;\\n\\n        // find the common path\\n        while(index < c1.length && index < c2.length && c1[index] == c2[index]){\\n            index++;\\n        }\\n        \\n        StringBuilder sb = new StringBuilder();\\n        for(int i = 0; i < c1.length-index; ++i){\\n            sb.append(\"U\");\\n        }\\n\\n        sb.append(path2.substring(index));\\n        \\n        return sb.toString();       \\n    }\\n         \\n    // build a parent graph from targetNode to root\\n    private void buildGraph(TreeNode root, int startValue, int destValue){  \\n       if ( root == null )\\n            return;\\n        if(root.val == startValue){\\n            startNode = root;\\n        }\\n        if(root.val == destValue){\\n            destNode = root;\\n        }\\n        if(startNode == null || destNode == null){\\n            if (root.left != null){\\n                parentMap.put(root.left,root) ;\\n                buildGraph(root.left, startValue, destValue) ;\\n            }\\n\\n            if (root.right != null){\\n                parentMap.put(root.right,root) ;\\n                buildGraph(root.right, startValue, destValue) ;\\n            }\\n        }\\n    }\\n    private String buildPath(TreeNode currNode){\\n        StringBuilder sb = new StringBuilder();\\n        while(parentMap.get(currNode) != null){            //check if the parent node is null to avoid nullpointer\\n            TreeNode parent = parentMap.get(currNode);\\n            if (currNode == parent.left) {\\n                    sb.insert(0, \\'L\\');\\n                }\\n                else {\\n                    sb.insert(0, \\'R\\');\\n                }\\n            currNode = parent;\\n        }\\n        return sb.toString();\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\n    Map<TreeNode, TreeNode> parentMap = new HashMap<>();\\n    TreeNode startNode;\\n    TreeNode destNode;\\n    public String getDirections(TreeNode root, int startValue, int destValue) {\\n        buildGraph(root, startValue, destValue);\\n        String path1 = buildPath(startNode);\\n        String path2 = buildPath(destNode);\\n        char[] c1 = path1.toCharArray();\\n        char[] c2 = path2.toCharArray();\\n        int index = 0;\\n\\n        // find the common path\\n        while(index < c1.length && index < c2.length && c1[index] == c2[index]){\\n            index++;\\n        }\\n        \\n        StringBuilder sb = new StringBuilder();\\n        for(int i = 0; i < c1.length-index; ++i){\\n            sb.append(\"U\");\\n        }\\n\\n        sb.append(path2.substring(index));\\n        \\n        return sb.toString();       \\n    }\\n         \\n    // build a parent graph from targetNode to root\\n    private void buildGraph(TreeNode root, int startValue, int destValue){  \\n       if ( root == null )\\n            return;\\n        if(root.val == startValue){\\n            startNode = root;\\n        }\\n        if(root.val == destValue){\\n            destNode = root;\\n        }\\n        if(startNode == null || destNode == null){\\n            if (root.left != null){\\n                parentMap.put(root.left,root) ;\\n                buildGraph(root.left, startValue, destValue) ;\\n            }\\n\\n            if (root.right != null){\\n                parentMap.put(root.right,root) ;\\n                buildGraph(root.right, startValue, destValue) ;\\n            }\\n        }\\n    }\\n    private String buildPath(TreeNode currNode){\\n        StringBuilder sb = new StringBuilder();\\n        while(parentMap.get(currNode) != null){            //check if the parent node is null to avoid nullpointer\\n            TreeNode parent = parentMap.get(currNode);\\n            if (currNode == parent.left) {\\n                    sb.insert(0, \\'L\\');\\n                }\\n                else {\\n                    sb.insert(0, \\'R\\');\\n                }\\n            currNode = parent;\\n        }\\n        return sb.toString();\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1565180,
                "content": [
                    {
                        "username": "nadabao",
                        "content": "This is one of the most frequently asked question in Google interviews recently."
                    },
                    {
                        "username": "Falguni6556",
                        "content": "how to reduce memory complexity?\\n"
                    },
                    {
                        "username": "strangeranda",
                        "content": "I came across this. I had DFS done recursively, recursive has a memory overhead, so I changed it to iterative and that went well.  "
                    },
                    {
                        "username": "ganapati_biswas",
                        "content": "**If you are getting MLE or TLE for larger input then pass the path string as a reference not by value.**\\n**Pass by value will create a new string  every time recursion  is called and will lead to MLE**\\n\\n**For Example-**\\n`void helper(TreeNode* root, string startTemp, string destTemp){\\n    ......\\n\\t.....\\n  }` \\nThis code will give TLE. But \\n`void helper(TreeNode* root, string &startTemp, string &destTemp){\\n    ......\\n\\t.....\\n  }` \\nthis is perfect."
                    },
                    {
                        "username": "vyshnavkr",
                        "content": "* Above meidum level problem\\n* I thought of finding startNode first from root. And then searching for destNode from startNode tracking the path alongwise. But this fails when startNode is on the right subtree of root and destNode is on the left subtree of root. It could be fixed by searching for either of the nodes first and then the other next. Now when destNode is found first, all the Us shold be kinda converted to Ls or Rs which is still complicated.\\n* The above complexities makes this problem to be thought of 2 parts: track root to startNode path as well as track root to destNode path. See Votubac\\'s brilliant solution."
                    },
                    {
                        "username": "strangeranda",
                        "content": "For anyone that came across memory limit exceeded while doing DFS in recursive fashion, change it to iterative DFS."
                    },
                    {
                        "username": "nishidy",
                        "content": "[1,3,8,7,null,4,5,6,null,null,null,null,null,null,2]\\n2\\n1\\n\\nExpected output is \"UUUU\", but it should not be more than 3 beause the depth of the binary tree is 3 in 15 nodes. If the number of nodes is 16 or more, the depth is 4 and the maximum numbrer of \"U\" should be 4. How can it be more than the depth of the binary tree in this problem?"
                    },
                    {
                        "username": "pkuphyzzb",
                        "content": "In python3 when you use recursion for dfs you would get MLE so you have to rely on a manual DFS ...."
                    },
                    {
                        "username": "shiva_rudra123",
                        "content": "class Solution {\\npublic:\\n    \\n    string getDirections(TreeNode* root, int startValue, int destValue) {\\n        unordered_map<TreeNode*,TreeNode*>m;\\n        unordered_map<TreeNode*,int>s;\\n        TreeNode* curr=root;\\n        TreeNode* burr,*lurr;\\n        queue<TreeNode*>q;\\n        q.push(curr);\\n        if(curr->val==startValue)\\n            burr=curr;\\n        if(curr->val==destValue)\\n            lurr=curr;\\n        while(!q.empty())\\n        {\\n            curr=q.front();\\n            q.pop();\\n            s[curr]=0;\\n            if(curr->val==startValue)\\n             burr=curr;\\n            if(curr->val==destValue)\\n             lurr=curr;\\n            if(curr->left!=NULL){\\n               m[curr->left]=curr;\\n               q.push(curr->left);\\n            }\\n        if(curr->right!=NULL){\\n               m[curr->right]=curr;\\n               q.push(curr->right);\\n            }\\n    }\\n    \\n    string ans=\"\";\\n    queue<pair<TreeNode*,string>>p;\\n    p.push({burr,\"\"});\\n    while(!p.empty()){\\n        curr=p.front().first;string s1=p.front().second;\\n        p.pop();\\n        if(s[curr]!=0)\\n          continue;\\n         if(curr==lurr)\\n         {\\n            ans=s1;\\n            break;\\n         }\\n         s[curr]=1;\\n         if(curr->left!=NULL)\\n           p.push({curr->left,s1+\"L\"});\\n         if(curr->right!=NULL)\\n           p.push({curr->right,s1+\"R\"});\\n         if(m.find(curr)!=m.end()){\\n            p.push({m[curr],s1+\"U\"});\\n         }\\n         \\n    }\\n    return ans;}\\n};\\n\\nwhy this sol is giving mle??anyone please help"
                    },
                    {
                        "username": "julia2022",
                        "content": "How can I connect with Leetcode team? Having problems with output values not being accepted (though strings are equal)"
                    },
                    {
                        "username": "julia2022",
                        "content": "There\\'s either a bug in the solutions, or something I\\'m not seeing:\\n\\nOutput vs Expected with case as incorrect\\n\"UURL\"\\n\"UURL\"\\n"
                    }
                ]
            },
            {
                "id": 1743614,
                "content": [
                    {
                        "username": "nadabao",
                        "content": "This is one of the most frequently asked question in Google interviews recently."
                    },
                    {
                        "username": "Falguni6556",
                        "content": "how to reduce memory complexity?\\n"
                    },
                    {
                        "username": "strangeranda",
                        "content": "I came across this. I had DFS done recursively, recursive has a memory overhead, so I changed it to iterative and that went well.  "
                    },
                    {
                        "username": "ganapati_biswas",
                        "content": "**If you are getting MLE or TLE for larger input then pass the path string as a reference not by value.**\\n**Pass by value will create a new string  every time recursion  is called and will lead to MLE**\\n\\n**For Example-**\\n`void helper(TreeNode* root, string startTemp, string destTemp){\\n    ......\\n\\t.....\\n  }` \\nThis code will give TLE. But \\n`void helper(TreeNode* root, string &startTemp, string &destTemp){\\n    ......\\n\\t.....\\n  }` \\nthis is perfect."
                    },
                    {
                        "username": "vyshnavkr",
                        "content": "* Above meidum level problem\\n* I thought of finding startNode first from root. And then searching for destNode from startNode tracking the path alongwise. But this fails when startNode is on the right subtree of root and destNode is on the left subtree of root. It could be fixed by searching for either of the nodes first and then the other next. Now when destNode is found first, all the Us shold be kinda converted to Ls or Rs which is still complicated.\\n* The above complexities makes this problem to be thought of 2 parts: track root to startNode path as well as track root to destNode path. See Votubac\\'s brilliant solution."
                    },
                    {
                        "username": "strangeranda",
                        "content": "For anyone that came across memory limit exceeded while doing DFS in recursive fashion, change it to iterative DFS."
                    },
                    {
                        "username": "nishidy",
                        "content": "[1,3,8,7,null,4,5,6,null,null,null,null,null,null,2]\\n2\\n1\\n\\nExpected output is \"UUUU\", but it should not be more than 3 beause the depth of the binary tree is 3 in 15 nodes. If the number of nodes is 16 or more, the depth is 4 and the maximum numbrer of \"U\" should be 4. How can it be more than the depth of the binary tree in this problem?"
                    },
                    {
                        "username": "pkuphyzzb",
                        "content": "In python3 when you use recursion for dfs you would get MLE so you have to rely on a manual DFS ...."
                    },
                    {
                        "username": "shiva_rudra123",
                        "content": "class Solution {\\npublic:\\n    \\n    string getDirections(TreeNode* root, int startValue, int destValue) {\\n        unordered_map<TreeNode*,TreeNode*>m;\\n        unordered_map<TreeNode*,int>s;\\n        TreeNode* curr=root;\\n        TreeNode* burr,*lurr;\\n        queue<TreeNode*>q;\\n        q.push(curr);\\n        if(curr->val==startValue)\\n            burr=curr;\\n        if(curr->val==destValue)\\n            lurr=curr;\\n        while(!q.empty())\\n        {\\n            curr=q.front();\\n            q.pop();\\n            s[curr]=0;\\n            if(curr->val==startValue)\\n             burr=curr;\\n            if(curr->val==destValue)\\n             lurr=curr;\\n            if(curr->left!=NULL){\\n               m[curr->left]=curr;\\n               q.push(curr->left);\\n            }\\n        if(curr->right!=NULL){\\n               m[curr->right]=curr;\\n               q.push(curr->right);\\n            }\\n    }\\n    \\n    string ans=\"\";\\n    queue<pair<TreeNode*,string>>p;\\n    p.push({burr,\"\"});\\n    while(!p.empty()){\\n        curr=p.front().first;string s1=p.front().second;\\n        p.pop();\\n        if(s[curr]!=0)\\n          continue;\\n         if(curr==lurr)\\n         {\\n            ans=s1;\\n            break;\\n         }\\n         s[curr]=1;\\n         if(curr->left!=NULL)\\n           p.push({curr->left,s1+\"L\"});\\n         if(curr->right!=NULL)\\n           p.push({curr->right,s1+\"R\"});\\n         if(m.find(curr)!=m.end()){\\n            p.push({m[curr],s1+\"U\"});\\n         }\\n         \\n    }\\n    return ans;}\\n};\\n\\nwhy this sol is giving mle??anyone please help"
                    },
                    {
                        "username": "julia2022",
                        "content": "How can I connect with Leetcode team? Having problems with output values not being accepted (though strings are equal)"
                    },
                    {
                        "username": "julia2022",
                        "content": "There\\'s either a bug in the solutions, or something I\\'m not seeing:\\n\\nOutput vs Expected with case as incorrect\\n\"UURL\"\\n\"UURL\"\\n"
                    }
                ]
            },
            {
                "id": 1576055,
                "content": [
                    {
                        "username": "nadabao",
                        "content": "This is one of the most frequently asked question in Google interviews recently."
                    },
                    {
                        "username": "Falguni6556",
                        "content": "how to reduce memory complexity?\\n"
                    },
                    {
                        "username": "strangeranda",
                        "content": "I came across this. I had DFS done recursively, recursive has a memory overhead, so I changed it to iterative and that went well.  "
                    },
                    {
                        "username": "ganapati_biswas",
                        "content": "**If you are getting MLE or TLE for larger input then pass the path string as a reference not by value.**\\n**Pass by value will create a new string  every time recursion  is called and will lead to MLE**\\n\\n**For Example-**\\n`void helper(TreeNode* root, string startTemp, string destTemp){\\n    ......\\n\\t.....\\n  }` \\nThis code will give TLE. But \\n`void helper(TreeNode* root, string &startTemp, string &destTemp){\\n    ......\\n\\t.....\\n  }` \\nthis is perfect."
                    },
                    {
                        "username": "vyshnavkr",
                        "content": "* Above meidum level problem\\n* I thought of finding startNode first from root. And then searching for destNode from startNode tracking the path alongwise. But this fails when startNode is on the right subtree of root and destNode is on the left subtree of root. It could be fixed by searching for either of the nodes first and then the other next. Now when destNode is found first, all the Us shold be kinda converted to Ls or Rs which is still complicated.\\n* The above complexities makes this problem to be thought of 2 parts: track root to startNode path as well as track root to destNode path. See Votubac\\'s brilliant solution."
                    },
                    {
                        "username": "strangeranda",
                        "content": "For anyone that came across memory limit exceeded while doing DFS in recursive fashion, change it to iterative DFS."
                    },
                    {
                        "username": "nishidy",
                        "content": "[1,3,8,7,null,4,5,6,null,null,null,null,null,null,2]\\n2\\n1\\n\\nExpected output is \"UUUU\", but it should not be more than 3 beause the depth of the binary tree is 3 in 15 nodes. If the number of nodes is 16 or more, the depth is 4 and the maximum numbrer of \"U\" should be 4. How can it be more than the depth of the binary tree in this problem?"
                    },
                    {
                        "username": "pkuphyzzb",
                        "content": "In python3 when you use recursion for dfs you would get MLE so you have to rely on a manual DFS ...."
                    },
                    {
                        "username": "shiva_rudra123",
                        "content": "class Solution {\\npublic:\\n    \\n    string getDirections(TreeNode* root, int startValue, int destValue) {\\n        unordered_map<TreeNode*,TreeNode*>m;\\n        unordered_map<TreeNode*,int>s;\\n        TreeNode* curr=root;\\n        TreeNode* burr,*lurr;\\n        queue<TreeNode*>q;\\n        q.push(curr);\\n        if(curr->val==startValue)\\n            burr=curr;\\n        if(curr->val==destValue)\\n            lurr=curr;\\n        while(!q.empty())\\n        {\\n            curr=q.front();\\n            q.pop();\\n            s[curr]=0;\\n            if(curr->val==startValue)\\n             burr=curr;\\n            if(curr->val==destValue)\\n             lurr=curr;\\n            if(curr->left!=NULL){\\n               m[curr->left]=curr;\\n               q.push(curr->left);\\n            }\\n        if(curr->right!=NULL){\\n               m[curr->right]=curr;\\n               q.push(curr->right);\\n            }\\n    }\\n    \\n    string ans=\"\";\\n    queue<pair<TreeNode*,string>>p;\\n    p.push({burr,\"\"});\\n    while(!p.empty()){\\n        curr=p.front().first;string s1=p.front().second;\\n        p.pop();\\n        if(s[curr]!=0)\\n          continue;\\n         if(curr==lurr)\\n         {\\n            ans=s1;\\n            break;\\n         }\\n         s[curr]=1;\\n         if(curr->left!=NULL)\\n           p.push({curr->left,s1+\"L\"});\\n         if(curr->right!=NULL)\\n           p.push({curr->right,s1+\"R\"});\\n         if(m.find(curr)!=m.end()){\\n            p.push({m[curr],s1+\"U\"});\\n         }\\n         \\n    }\\n    return ans;}\\n};\\n\\nwhy this sol is giving mle??anyone please help"
                    },
                    {
                        "username": "julia2022",
                        "content": "How can I connect with Leetcode team? Having problems with output values not being accepted (though strings are equal)"
                    },
                    {
                        "username": "julia2022",
                        "content": "There\\'s either a bug in the solutions, or something I\\'m not seeing:\\n\\nOutput vs Expected with case as incorrect\\n\"UURL\"\\n\"UURL\"\\n"
                    }
                ]
            },
            {
                "id": 1576478,
                "content": [
                    {
                        "username": "nadabao",
                        "content": "This is one of the most frequently asked question in Google interviews recently."
                    },
                    {
                        "username": "Falguni6556",
                        "content": "how to reduce memory complexity?\\n"
                    },
                    {
                        "username": "strangeranda",
                        "content": "I came across this. I had DFS done recursively, recursive has a memory overhead, so I changed it to iterative and that went well.  "
                    },
                    {
                        "username": "ganapati_biswas",
                        "content": "**If you are getting MLE or TLE for larger input then pass the path string as a reference not by value.**\\n**Pass by value will create a new string  every time recursion  is called and will lead to MLE**\\n\\n**For Example-**\\n`void helper(TreeNode* root, string startTemp, string destTemp){\\n    ......\\n\\t.....\\n  }` \\nThis code will give TLE. But \\n`void helper(TreeNode* root, string &startTemp, string &destTemp){\\n    ......\\n\\t.....\\n  }` \\nthis is perfect."
                    },
                    {
                        "username": "vyshnavkr",
                        "content": "* Above meidum level problem\\n* I thought of finding startNode first from root. And then searching for destNode from startNode tracking the path alongwise. But this fails when startNode is on the right subtree of root and destNode is on the left subtree of root. It could be fixed by searching for either of the nodes first and then the other next. Now when destNode is found first, all the Us shold be kinda converted to Ls or Rs which is still complicated.\\n* The above complexities makes this problem to be thought of 2 parts: track root to startNode path as well as track root to destNode path. See Votubac\\'s brilliant solution."
                    },
                    {
                        "username": "strangeranda",
                        "content": "For anyone that came across memory limit exceeded while doing DFS in recursive fashion, change it to iterative DFS."
                    },
                    {
                        "username": "nishidy",
                        "content": "[1,3,8,7,null,4,5,6,null,null,null,null,null,null,2]\\n2\\n1\\n\\nExpected output is \"UUUU\", but it should not be more than 3 beause the depth of the binary tree is 3 in 15 nodes. If the number of nodes is 16 or more, the depth is 4 and the maximum numbrer of \"U\" should be 4. How can it be more than the depth of the binary tree in this problem?"
                    },
                    {
                        "username": "pkuphyzzb",
                        "content": "In python3 when you use recursion for dfs you would get MLE so you have to rely on a manual DFS ...."
                    },
                    {
                        "username": "shiva_rudra123",
                        "content": "class Solution {\\npublic:\\n    \\n    string getDirections(TreeNode* root, int startValue, int destValue) {\\n        unordered_map<TreeNode*,TreeNode*>m;\\n        unordered_map<TreeNode*,int>s;\\n        TreeNode* curr=root;\\n        TreeNode* burr,*lurr;\\n        queue<TreeNode*>q;\\n        q.push(curr);\\n        if(curr->val==startValue)\\n            burr=curr;\\n        if(curr->val==destValue)\\n            lurr=curr;\\n        while(!q.empty())\\n        {\\n            curr=q.front();\\n            q.pop();\\n            s[curr]=0;\\n            if(curr->val==startValue)\\n             burr=curr;\\n            if(curr->val==destValue)\\n             lurr=curr;\\n            if(curr->left!=NULL){\\n               m[curr->left]=curr;\\n               q.push(curr->left);\\n            }\\n        if(curr->right!=NULL){\\n               m[curr->right]=curr;\\n               q.push(curr->right);\\n            }\\n    }\\n    \\n    string ans=\"\";\\n    queue<pair<TreeNode*,string>>p;\\n    p.push({burr,\"\"});\\n    while(!p.empty()){\\n        curr=p.front().first;string s1=p.front().second;\\n        p.pop();\\n        if(s[curr]!=0)\\n          continue;\\n         if(curr==lurr)\\n         {\\n            ans=s1;\\n            break;\\n         }\\n         s[curr]=1;\\n         if(curr->left!=NULL)\\n           p.push({curr->left,s1+\"L\"});\\n         if(curr->right!=NULL)\\n           p.push({curr->right,s1+\"R\"});\\n         if(m.find(curr)!=m.end()){\\n            p.push({m[curr],s1+\"U\"});\\n         }\\n         \\n    }\\n    return ans;}\\n};\\n\\nwhy this sol is giving mle??anyone please help"
                    },
                    {
                        "username": "julia2022",
                        "content": "How can I connect with Leetcode team? Having problems with output values not being accepted (though strings are equal)"
                    },
                    {
                        "username": "julia2022",
                        "content": "There\\'s either a bug in the solutions, or something I\\'m not seeing:\\n\\nOutput vs Expected with case as incorrect\\n\"UURL\"\\n\"UURL\"\\n"
                    }
                ]
            },
            {
                "id": 2004761,
                "content": [
                    {
                        "username": "nadabao",
                        "content": "This is one of the most frequently asked question in Google interviews recently."
                    },
                    {
                        "username": "Falguni6556",
                        "content": "how to reduce memory complexity?\\n"
                    },
                    {
                        "username": "strangeranda",
                        "content": "I came across this. I had DFS done recursively, recursive has a memory overhead, so I changed it to iterative and that went well.  "
                    },
                    {
                        "username": "ganapati_biswas",
                        "content": "**If you are getting MLE or TLE for larger input then pass the path string as a reference not by value.**\\n**Pass by value will create a new string  every time recursion  is called and will lead to MLE**\\n\\n**For Example-**\\n`void helper(TreeNode* root, string startTemp, string destTemp){\\n    ......\\n\\t.....\\n  }` \\nThis code will give TLE. But \\n`void helper(TreeNode* root, string &startTemp, string &destTemp){\\n    ......\\n\\t.....\\n  }` \\nthis is perfect."
                    },
                    {
                        "username": "vyshnavkr",
                        "content": "* Above meidum level problem\\n* I thought of finding startNode first from root. And then searching for destNode from startNode tracking the path alongwise. But this fails when startNode is on the right subtree of root and destNode is on the left subtree of root. It could be fixed by searching for either of the nodes first and then the other next. Now when destNode is found first, all the Us shold be kinda converted to Ls or Rs which is still complicated.\\n* The above complexities makes this problem to be thought of 2 parts: track root to startNode path as well as track root to destNode path. See Votubac\\'s brilliant solution."
                    },
                    {
                        "username": "strangeranda",
                        "content": "For anyone that came across memory limit exceeded while doing DFS in recursive fashion, change it to iterative DFS."
                    },
                    {
                        "username": "nishidy",
                        "content": "[1,3,8,7,null,4,5,6,null,null,null,null,null,null,2]\\n2\\n1\\n\\nExpected output is \"UUUU\", but it should not be more than 3 beause the depth of the binary tree is 3 in 15 nodes. If the number of nodes is 16 or more, the depth is 4 and the maximum numbrer of \"U\" should be 4. How can it be more than the depth of the binary tree in this problem?"
                    },
                    {
                        "username": "pkuphyzzb",
                        "content": "In python3 when you use recursion for dfs you would get MLE so you have to rely on a manual DFS ...."
                    },
                    {
                        "username": "shiva_rudra123",
                        "content": "class Solution {\\npublic:\\n    \\n    string getDirections(TreeNode* root, int startValue, int destValue) {\\n        unordered_map<TreeNode*,TreeNode*>m;\\n        unordered_map<TreeNode*,int>s;\\n        TreeNode* curr=root;\\n        TreeNode* burr,*lurr;\\n        queue<TreeNode*>q;\\n        q.push(curr);\\n        if(curr->val==startValue)\\n            burr=curr;\\n        if(curr->val==destValue)\\n            lurr=curr;\\n        while(!q.empty())\\n        {\\n            curr=q.front();\\n            q.pop();\\n            s[curr]=0;\\n            if(curr->val==startValue)\\n             burr=curr;\\n            if(curr->val==destValue)\\n             lurr=curr;\\n            if(curr->left!=NULL){\\n               m[curr->left]=curr;\\n               q.push(curr->left);\\n            }\\n        if(curr->right!=NULL){\\n               m[curr->right]=curr;\\n               q.push(curr->right);\\n            }\\n    }\\n    \\n    string ans=\"\";\\n    queue<pair<TreeNode*,string>>p;\\n    p.push({burr,\"\"});\\n    while(!p.empty()){\\n        curr=p.front().first;string s1=p.front().second;\\n        p.pop();\\n        if(s[curr]!=0)\\n          continue;\\n         if(curr==lurr)\\n         {\\n            ans=s1;\\n            break;\\n         }\\n         s[curr]=1;\\n         if(curr->left!=NULL)\\n           p.push({curr->left,s1+\"L\"});\\n         if(curr->right!=NULL)\\n           p.push({curr->right,s1+\"R\"});\\n         if(m.find(curr)!=m.end()){\\n            p.push({m[curr],s1+\"U\"});\\n         }\\n         \\n    }\\n    return ans;}\\n};\\n\\nwhy this sol is giving mle??anyone please help"
                    },
                    {
                        "username": "julia2022",
                        "content": "How can I connect with Leetcode team? Having problems with output values not being accepted (though strings are equal)"
                    },
                    {
                        "username": "julia2022",
                        "content": "There\\'s either a bug in the solutions, or something I\\'m not seeing:\\n\\nOutput vs Expected with case as incorrect\\n\"UURL\"\\n\"UURL\"\\n"
                    }
                ]
            },
            {
                "id": 1576444,
                "content": [
                    {
                        "username": "nadabao",
                        "content": "This is one of the most frequently asked question in Google interviews recently."
                    },
                    {
                        "username": "Falguni6556",
                        "content": "how to reduce memory complexity?\\n"
                    },
                    {
                        "username": "strangeranda",
                        "content": "I came across this. I had DFS done recursively, recursive has a memory overhead, so I changed it to iterative and that went well.  "
                    },
                    {
                        "username": "ganapati_biswas",
                        "content": "**If you are getting MLE or TLE for larger input then pass the path string as a reference not by value.**\\n**Pass by value will create a new string  every time recursion  is called and will lead to MLE**\\n\\n**For Example-**\\n`void helper(TreeNode* root, string startTemp, string destTemp){\\n    ......\\n\\t.....\\n  }` \\nThis code will give TLE. But \\n`void helper(TreeNode* root, string &startTemp, string &destTemp){\\n    ......\\n\\t.....\\n  }` \\nthis is perfect."
                    },
                    {
                        "username": "vyshnavkr",
                        "content": "* Above meidum level problem\\n* I thought of finding startNode first from root. And then searching for destNode from startNode tracking the path alongwise. But this fails when startNode is on the right subtree of root and destNode is on the left subtree of root. It could be fixed by searching for either of the nodes first and then the other next. Now when destNode is found first, all the Us shold be kinda converted to Ls or Rs which is still complicated.\\n* The above complexities makes this problem to be thought of 2 parts: track root to startNode path as well as track root to destNode path. See Votubac\\'s brilliant solution."
                    },
                    {
                        "username": "strangeranda",
                        "content": "For anyone that came across memory limit exceeded while doing DFS in recursive fashion, change it to iterative DFS."
                    },
                    {
                        "username": "nishidy",
                        "content": "[1,3,8,7,null,4,5,6,null,null,null,null,null,null,2]\\n2\\n1\\n\\nExpected output is \"UUUU\", but it should not be more than 3 beause the depth of the binary tree is 3 in 15 nodes. If the number of nodes is 16 or more, the depth is 4 and the maximum numbrer of \"U\" should be 4. How can it be more than the depth of the binary tree in this problem?"
                    },
                    {
                        "username": "pkuphyzzb",
                        "content": "In python3 when you use recursion for dfs you would get MLE so you have to rely on a manual DFS ...."
                    },
                    {
                        "username": "shiva_rudra123",
                        "content": "class Solution {\\npublic:\\n    \\n    string getDirections(TreeNode* root, int startValue, int destValue) {\\n        unordered_map<TreeNode*,TreeNode*>m;\\n        unordered_map<TreeNode*,int>s;\\n        TreeNode* curr=root;\\n        TreeNode* burr,*lurr;\\n        queue<TreeNode*>q;\\n        q.push(curr);\\n        if(curr->val==startValue)\\n            burr=curr;\\n        if(curr->val==destValue)\\n            lurr=curr;\\n        while(!q.empty())\\n        {\\n            curr=q.front();\\n            q.pop();\\n            s[curr]=0;\\n            if(curr->val==startValue)\\n             burr=curr;\\n            if(curr->val==destValue)\\n             lurr=curr;\\n            if(curr->left!=NULL){\\n               m[curr->left]=curr;\\n               q.push(curr->left);\\n            }\\n        if(curr->right!=NULL){\\n               m[curr->right]=curr;\\n               q.push(curr->right);\\n            }\\n    }\\n    \\n    string ans=\"\";\\n    queue<pair<TreeNode*,string>>p;\\n    p.push({burr,\"\"});\\n    while(!p.empty()){\\n        curr=p.front().first;string s1=p.front().second;\\n        p.pop();\\n        if(s[curr]!=0)\\n          continue;\\n         if(curr==lurr)\\n         {\\n            ans=s1;\\n            break;\\n         }\\n         s[curr]=1;\\n         if(curr->left!=NULL)\\n           p.push({curr->left,s1+\"L\"});\\n         if(curr->right!=NULL)\\n           p.push({curr->right,s1+\"R\"});\\n         if(m.find(curr)!=m.end()){\\n            p.push({m[curr],s1+\"U\"});\\n         }\\n         \\n    }\\n    return ans;}\\n};\\n\\nwhy this sol is giving mle??anyone please help"
                    },
                    {
                        "username": "julia2022",
                        "content": "How can I connect with Leetcode team? Having problems with output values not being accepted (though strings are equal)"
                    },
                    {
                        "username": "julia2022",
                        "content": "There\\'s either a bug in the solutions, or something I\\'m not seeing:\\n\\nOutput vs Expected with case as incorrect\\n\"UURL\"\\n\"UURL\"\\n"
                    }
                ]
            },
            {
                "id": 2048085,
                "content": [
                    {
                        "username": "nadabao",
                        "content": "This is one of the most frequently asked question in Google interviews recently."
                    },
                    {
                        "username": "Falguni6556",
                        "content": "how to reduce memory complexity?\\n"
                    },
                    {
                        "username": "strangeranda",
                        "content": "I came across this. I had DFS done recursively, recursive has a memory overhead, so I changed it to iterative and that went well.  "
                    },
                    {
                        "username": "ganapati_biswas",
                        "content": "**If you are getting MLE or TLE for larger input then pass the path string as a reference not by value.**\\n**Pass by value will create a new string  every time recursion  is called and will lead to MLE**\\n\\n**For Example-**\\n`void helper(TreeNode* root, string startTemp, string destTemp){\\n    ......\\n\\t.....\\n  }` \\nThis code will give TLE. But \\n`void helper(TreeNode* root, string &startTemp, string &destTemp){\\n    ......\\n\\t.....\\n  }` \\nthis is perfect."
                    },
                    {
                        "username": "vyshnavkr",
                        "content": "* Above meidum level problem\\n* I thought of finding startNode first from root. And then searching for destNode from startNode tracking the path alongwise. But this fails when startNode is on the right subtree of root and destNode is on the left subtree of root. It could be fixed by searching for either of the nodes first and then the other next. Now when destNode is found first, all the Us shold be kinda converted to Ls or Rs which is still complicated.\\n* The above complexities makes this problem to be thought of 2 parts: track root to startNode path as well as track root to destNode path. See Votubac\\'s brilliant solution."
                    },
                    {
                        "username": "strangeranda",
                        "content": "For anyone that came across memory limit exceeded while doing DFS in recursive fashion, change it to iterative DFS."
                    },
                    {
                        "username": "nishidy",
                        "content": "[1,3,8,7,null,4,5,6,null,null,null,null,null,null,2]\\n2\\n1\\n\\nExpected output is \"UUUU\", but it should not be more than 3 beause the depth of the binary tree is 3 in 15 nodes. If the number of nodes is 16 or more, the depth is 4 and the maximum numbrer of \"U\" should be 4. How can it be more than the depth of the binary tree in this problem?"
                    },
                    {
                        "username": "pkuphyzzb",
                        "content": "In python3 when you use recursion for dfs you would get MLE so you have to rely on a manual DFS ...."
                    },
                    {
                        "username": "shiva_rudra123",
                        "content": "class Solution {\\npublic:\\n    \\n    string getDirections(TreeNode* root, int startValue, int destValue) {\\n        unordered_map<TreeNode*,TreeNode*>m;\\n        unordered_map<TreeNode*,int>s;\\n        TreeNode* curr=root;\\n        TreeNode* burr,*lurr;\\n        queue<TreeNode*>q;\\n        q.push(curr);\\n        if(curr->val==startValue)\\n            burr=curr;\\n        if(curr->val==destValue)\\n            lurr=curr;\\n        while(!q.empty())\\n        {\\n            curr=q.front();\\n            q.pop();\\n            s[curr]=0;\\n            if(curr->val==startValue)\\n             burr=curr;\\n            if(curr->val==destValue)\\n             lurr=curr;\\n            if(curr->left!=NULL){\\n               m[curr->left]=curr;\\n               q.push(curr->left);\\n            }\\n        if(curr->right!=NULL){\\n               m[curr->right]=curr;\\n               q.push(curr->right);\\n            }\\n    }\\n    \\n    string ans=\"\";\\n    queue<pair<TreeNode*,string>>p;\\n    p.push({burr,\"\"});\\n    while(!p.empty()){\\n        curr=p.front().first;string s1=p.front().second;\\n        p.pop();\\n        if(s[curr]!=0)\\n          continue;\\n         if(curr==lurr)\\n         {\\n            ans=s1;\\n            break;\\n         }\\n         s[curr]=1;\\n         if(curr->left!=NULL)\\n           p.push({curr->left,s1+\"L\"});\\n         if(curr->right!=NULL)\\n           p.push({curr->right,s1+\"R\"});\\n         if(m.find(curr)!=m.end()){\\n            p.push({m[curr],s1+\"U\"});\\n         }\\n         \\n    }\\n    return ans;}\\n};\\n\\nwhy this sol is giving mle??anyone please help"
                    },
                    {
                        "username": "julia2022",
                        "content": "How can I connect with Leetcode team? Having problems with output values not being accepted (though strings are equal)"
                    },
                    {
                        "username": "julia2022",
                        "content": "There\\'s either a bug in the solutions, or something I\\'m not seeing:\\n\\nOutput vs Expected with case as incorrect\\n\"UURL\"\\n\"UURL\"\\n"
                    }
                ]
            },
            {
                "id": 1903956,
                "content": [
                    {
                        "username": "nadabao",
                        "content": "This is one of the most frequently asked question in Google interviews recently."
                    },
                    {
                        "username": "Falguni6556",
                        "content": "how to reduce memory complexity?\\n"
                    },
                    {
                        "username": "strangeranda",
                        "content": "I came across this. I had DFS done recursively, recursive has a memory overhead, so I changed it to iterative and that went well.  "
                    },
                    {
                        "username": "ganapati_biswas",
                        "content": "**If you are getting MLE or TLE for larger input then pass the path string as a reference not by value.**\\n**Pass by value will create a new string  every time recursion  is called and will lead to MLE**\\n\\n**For Example-**\\n`void helper(TreeNode* root, string startTemp, string destTemp){\\n    ......\\n\\t.....\\n  }` \\nThis code will give TLE. But \\n`void helper(TreeNode* root, string &startTemp, string &destTemp){\\n    ......\\n\\t.....\\n  }` \\nthis is perfect."
                    },
                    {
                        "username": "vyshnavkr",
                        "content": "* Above meidum level problem\\n* I thought of finding startNode first from root. And then searching for destNode from startNode tracking the path alongwise. But this fails when startNode is on the right subtree of root and destNode is on the left subtree of root. It could be fixed by searching for either of the nodes first and then the other next. Now when destNode is found first, all the Us shold be kinda converted to Ls or Rs which is still complicated.\\n* The above complexities makes this problem to be thought of 2 parts: track root to startNode path as well as track root to destNode path. See Votubac\\'s brilliant solution."
                    },
                    {
                        "username": "strangeranda",
                        "content": "For anyone that came across memory limit exceeded while doing DFS in recursive fashion, change it to iterative DFS."
                    },
                    {
                        "username": "nishidy",
                        "content": "[1,3,8,7,null,4,5,6,null,null,null,null,null,null,2]\\n2\\n1\\n\\nExpected output is \"UUUU\", but it should not be more than 3 beause the depth of the binary tree is 3 in 15 nodes. If the number of nodes is 16 or more, the depth is 4 and the maximum numbrer of \"U\" should be 4. How can it be more than the depth of the binary tree in this problem?"
                    },
                    {
                        "username": "pkuphyzzb",
                        "content": "In python3 when you use recursion for dfs you would get MLE so you have to rely on a manual DFS ...."
                    },
                    {
                        "username": "shiva_rudra123",
                        "content": "class Solution {\\npublic:\\n    \\n    string getDirections(TreeNode* root, int startValue, int destValue) {\\n        unordered_map<TreeNode*,TreeNode*>m;\\n        unordered_map<TreeNode*,int>s;\\n        TreeNode* curr=root;\\n        TreeNode* burr,*lurr;\\n        queue<TreeNode*>q;\\n        q.push(curr);\\n        if(curr->val==startValue)\\n            burr=curr;\\n        if(curr->val==destValue)\\n            lurr=curr;\\n        while(!q.empty())\\n        {\\n            curr=q.front();\\n            q.pop();\\n            s[curr]=0;\\n            if(curr->val==startValue)\\n             burr=curr;\\n            if(curr->val==destValue)\\n             lurr=curr;\\n            if(curr->left!=NULL){\\n               m[curr->left]=curr;\\n               q.push(curr->left);\\n            }\\n        if(curr->right!=NULL){\\n               m[curr->right]=curr;\\n               q.push(curr->right);\\n            }\\n    }\\n    \\n    string ans=\"\";\\n    queue<pair<TreeNode*,string>>p;\\n    p.push({burr,\"\"});\\n    while(!p.empty()){\\n        curr=p.front().first;string s1=p.front().second;\\n        p.pop();\\n        if(s[curr]!=0)\\n          continue;\\n         if(curr==lurr)\\n         {\\n            ans=s1;\\n            break;\\n         }\\n         s[curr]=1;\\n         if(curr->left!=NULL)\\n           p.push({curr->left,s1+\"L\"});\\n         if(curr->right!=NULL)\\n           p.push({curr->right,s1+\"R\"});\\n         if(m.find(curr)!=m.end()){\\n            p.push({m[curr],s1+\"U\"});\\n         }\\n         \\n    }\\n    return ans;}\\n};\\n\\nwhy this sol is giving mle??anyone please help"
                    },
                    {
                        "username": "julia2022",
                        "content": "How can I connect with Leetcode team? Having problems with output values not being accepted (though strings are equal)"
                    },
                    {
                        "username": "julia2022",
                        "content": "There\\'s either a bug in the solutions, or something I\\'m not seeing:\\n\\nOutput vs Expected with case as incorrect\\n\"UURL\"\\n\"UURL\"\\n"
                    }
                ]
            },
            {
                "id": 1731751,
                "content": [
                    {
                        "username": "nadabao",
                        "content": "This is one of the most frequently asked question in Google interviews recently."
                    },
                    {
                        "username": "Falguni6556",
                        "content": "how to reduce memory complexity?\\n"
                    },
                    {
                        "username": "strangeranda",
                        "content": "I came across this. I had DFS done recursively, recursive has a memory overhead, so I changed it to iterative and that went well.  "
                    },
                    {
                        "username": "ganapati_biswas",
                        "content": "**If you are getting MLE or TLE for larger input then pass the path string as a reference not by value.**\\n**Pass by value will create a new string  every time recursion  is called and will lead to MLE**\\n\\n**For Example-**\\n`void helper(TreeNode* root, string startTemp, string destTemp){\\n    ......\\n\\t.....\\n  }` \\nThis code will give TLE. But \\n`void helper(TreeNode* root, string &startTemp, string &destTemp){\\n    ......\\n\\t.....\\n  }` \\nthis is perfect."
                    },
                    {
                        "username": "vyshnavkr",
                        "content": "* Above meidum level problem\\n* I thought of finding startNode first from root. And then searching for destNode from startNode tracking the path alongwise. But this fails when startNode is on the right subtree of root and destNode is on the left subtree of root. It could be fixed by searching for either of the nodes first and then the other next. Now when destNode is found first, all the Us shold be kinda converted to Ls or Rs which is still complicated.\\n* The above complexities makes this problem to be thought of 2 parts: track root to startNode path as well as track root to destNode path. See Votubac\\'s brilliant solution."
                    },
                    {
                        "username": "strangeranda",
                        "content": "For anyone that came across memory limit exceeded while doing DFS in recursive fashion, change it to iterative DFS."
                    },
                    {
                        "username": "nishidy",
                        "content": "[1,3,8,7,null,4,5,6,null,null,null,null,null,null,2]\\n2\\n1\\n\\nExpected output is \"UUUU\", but it should not be more than 3 beause the depth of the binary tree is 3 in 15 nodes. If the number of nodes is 16 or more, the depth is 4 and the maximum numbrer of \"U\" should be 4. How can it be more than the depth of the binary tree in this problem?"
                    },
                    {
                        "username": "pkuphyzzb",
                        "content": "In python3 when you use recursion for dfs you would get MLE so you have to rely on a manual DFS ...."
                    },
                    {
                        "username": "shiva_rudra123",
                        "content": "class Solution {\\npublic:\\n    \\n    string getDirections(TreeNode* root, int startValue, int destValue) {\\n        unordered_map<TreeNode*,TreeNode*>m;\\n        unordered_map<TreeNode*,int>s;\\n        TreeNode* curr=root;\\n        TreeNode* burr,*lurr;\\n        queue<TreeNode*>q;\\n        q.push(curr);\\n        if(curr->val==startValue)\\n            burr=curr;\\n        if(curr->val==destValue)\\n            lurr=curr;\\n        while(!q.empty())\\n        {\\n            curr=q.front();\\n            q.pop();\\n            s[curr]=0;\\n            if(curr->val==startValue)\\n             burr=curr;\\n            if(curr->val==destValue)\\n             lurr=curr;\\n            if(curr->left!=NULL){\\n               m[curr->left]=curr;\\n               q.push(curr->left);\\n            }\\n        if(curr->right!=NULL){\\n               m[curr->right]=curr;\\n               q.push(curr->right);\\n            }\\n    }\\n    \\n    string ans=\"\";\\n    queue<pair<TreeNode*,string>>p;\\n    p.push({burr,\"\"});\\n    while(!p.empty()){\\n        curr=p.front().first;string s1=p.front().second;\\n        p.pop();\\n        if(s[curr]!=0)\\n          continue;\\n         if(curr==lurr)\\n         {\\n            ans=s1;\\n            break;\\n         }\\n         s[curr]=1;\\n         if(curr->left!=NULL)\\n           p.push({curr->left,s1+\"L\"});\\n         if(curr->right!=NULL)\\n           p.push({curr->right,s1+\"R\"});\\n         if(m.find(curr)!=m.end()){\\n            p.push({m[curr],s1+\"U\"});\\n         }\\n         \\n    }\\n    return ans;}\\n};\\n\\nwhy this sol is giving mle??anyone please help"
                    },
                    {
                        "username": "julia2022",
                        "content": "How can I connect with Leetcode team? Having problems with output values not being accepted (though strings are equal)"
                    },
                    {
                        "username": "julia2022",
                        "content": "There\\'s either a bug in the solutions, or something I\\'m not seeing:\\n\\nOutput vs Expected with case as incorrect\\n\"UURL\"\\n\"UURL\"\\n"
                    }
                ]
            },
            {
                "id": 1731749,
                "content": [
                    {
                        "username": "nadabao",
                        "content": "This is one of the most frequently asked question in Google interviews recently."
                    },
                    {
                        "username": "Falguni6556",
                        "content": "how to reduce memory complexity?\\n"
                    },
                    {
                        "username": "strangeranda",
                        "content": "I came across this. I had DFS done recursively, recursive has a memory overhead, so I changed it to iterative and that went well.  "
                    },
                    {
                        "username": "ganapati_biswas",
                        "content": "**If you are getting MLE or TLE for larger input then pass the path string as a reference not by value.**\\n**Pass by value will create a new string  every time recursion  is called and will lead to MLE**\\n\\n**For Example-**\\n`void helper(TreeNode* root, string startTemp, string destTemp){\\n    ......\\n\\t.....\\n  }` \\nThis code will give TLE. But \\n`void helper(TreeNode* root, string &startTemp, string &destTemp){\\n    ......\\n\\t.....\\n  }` \\nthis is perfect."
                    },
                    {
                        "username": "vyshnavkr",
                        "content": "* Above meidum level problem\\n* I thought of finding startNode first from root. And then searching for destNode from startNode tracking the path alongwise. But this fails when startNode is on the right subtree of root and destNode is on the left subtree of root. It could be fixed by searching for either of the nodes first and then the other next. Now when destNode is found first, all the Us shold be kinda converted to Ls or Rs which is still complicated.\\n* The above complexities makes this problem to be thought of 2 parts: track root to startNode path as well as track root to destNode path. See Votubac\\'s brilliant solution."
                    },
                    {
                        "username": "strangeranda",
                        "content": "For anyone that came across memory limit exceeded while doing DFS in recursive fashion, change it to iterative DFS."
                    },
                    {
                        "username": "nishidy",
                        "content": "[1,3,8,7,null,4,5,6,null,null,null,null,null,null,2]\\n2\\n1\\n\\nExpected output is \"UUUU\", but it should not be more than 3 beause the depth of the binary tree is 3 in 15 nodes. If the number of nodes is 16 or more, the depth is 4 and the maximum numbrer of \"U\" should be 4. How can it be more than the depth of the binary tree in this problem?"
                    },
                    {
                        "username": "pkuphyzzb",
                        "content": "In python3 when you use recursion for dfs you would get MLE so you have to rely on a manual DFS ...."
                    },
                    {
                        "username": "shiva_rudra123",
                        "content": "class Solution {\\npublic:\\n    \\n    string getDirections(TreeNode* root, int startValue, int destValue) {\\n        unordered_map<TreeNode*,TreeNode*>m;\\n        unordered_map<TreeNode*,int>s;\\n        TreeNode* curr=root;\\n        TreeNode* burr,*lurr;\\n        queue<TreeNode*>q;\\n        q.push(curr);\\n        if(curr->val==startValue)\\n            burr=curr;\\n        if(curr->val==destValue)\\n            lurr=curr;\\n        while(!q.empty())\\n        {\\n            curr=q.front();\\n            q.pop();\\n            s[curr]=0;\\n            if(curr->val==startValue)\\n             burr=curr;\\n            if(curr->val==destValue)\\n             lurr=curr;\\n            if(curr->left!=NULL){\\n               m[curr->left]=curr;\\n               q.push(curr->left);\\n            }\\n        if(curr->right!=NULL){\\n               m[curr->right]=curr;\\n               q.push(curr->right);\\n            }\\n    }\\n    \\n    string ans=\"\";\\n    queue<pair<TreeNode*,string>>p;\\n    p.push({burr,\"\"});\\n    while(!p.empty()){\\n        curr=p.front().first;string s1=p.front().second;\\n        p.pop();\\n        if(s[curr]!=0)\\n          continue;\\n         if(curr==lurr)\\n         {\\n            ans=s1;\\n            break;\\n         }\\n         s[curr]=1;\\n         if(curr->left!=NULL)\\n           p.push({curr->left,s1+\"L\"});\\n         if(curr->right!=NULL)\\n           p.push({curr->right,s1+\"R\"});\\n         if(m.find(curr)!=m.end()){\\n            p.push({m[curr],s1+\"U\"});\\n         }\\n         \\n    }\\n    return ans;}\\n};\\n\\nwhy this sol is giving mle??anyone please help"
                    },
                    {
                        "username": "julia2022",
                        "content": "How can I connect with Leetcode team? Having problems with output values not being accepted (though strings are equal)"
                    },
                    {
                        "username": "julia2022",
                        "content": "There\\'s either a bug in the solutions, or something I\\'m not seeing:\\n\\nOutput vs Expected with case as incorrect\\n\"UURL\"\\n\"UURL\"\\n"
                    }
                ]
            },
            {
                "id": 1565180,
                "content": [
                    {
                        "username": "nadabao",
                        "content": "This is one of the most frequently asked question in Google interviews recently."
                    },
                    {
                        "username": "Falguni6556",
                        "content": "how to reduce memory complexity?\\n"
                    },
                    {
                        "username": "strangeranda",
                        "content": "I came across this. I had DFS done recursively, recursive has a memory overhead, so I changed it to iterative and that went well.  "
                    },
                    {
                        "username": "ganapati_biswas",
                        "content": "**If you are getting MLE or TLE for larger input then pass the path string as a reference not by value.**\\n**Pass by value will create a new string  every time recursion  is called and will lead to MLE**\\n\\n**For Example-**\\n`void helper(TreeNode* root, string startTemp, string destTemp){\\n    ......\\n\\t.....\\n  }` \\nThis code will give TLE. But \\n`void helper(TreeNode* root, string &startTemp, string &destTemp){\\n    ......\\n\\t.....\\n  }` \\nthis is perfect."
                    },
                    {
                        "username": "vyshnavkr",
                        "content": "* Above meidum level problem\\n* I thought of finding startNode first from root. And then searching for destNode from startNode tracking the path alongwise. But this fails when startNode is on the right subtree of root and destNode is on the left subtree of root. It could be fixed by searching for either of the nodes first and then the other next. Now when destNode is found first, all the Us shold be kinda converted to Ls or Rs which is still complicated.\\n* The above complexities makes this problem to be thought of 2 parts: track root to startNode path as well as track root to destNode path. See Votubac\\'s brilliant solution."
                    },
                    {
                        "username": "strangeranda",
                        "content": "For anyone that came across memory limit exceeded while doing DFS in recursive fashion, change it to iterative DFS."
                    },
                    {
                        "username": "nishidy",
                        "content": "[1,3,8,7,null,4,5,6,null,null,null,null,null,null,2]\\n2\\n1\\n\\nExpected output is \"UUUU\", but it should not be more than 3 beause the depth of the binary tree is 3 in 15 nodes. If the number of nodes is 16 or more, the depth is 4 and the maximum numbrer of \"U\" should be 4. How can it be more than the depth of the binary tree in this problem?"
                    },
                    {
                        "username": "pkuphyzzb",
                        "content": "In python3 when you use recursion for dfs you would get MLE so you have to rely on a manual DFS ...."
                    },
                    {
                        "username": "shiva_rudra123",
                        "content": "class Solution {\\npublic:\\n    \\n    string getDirections(TreeNode* root, int startValue, int destValue) {\\n        unordered_map<TreeNode*,TreeNode*>m;\\n        unordered_map<TreeNode*,int>s;\\n        TreeNode* curr=root;\\n        TreeNode* burr,*lurr;\\n        queue<TreeNode*>q;\\n        q.push(curr);\\n        if(curr->val==startValue)\\n            burr=curr;\\n        if(curr->val==destValue)\\n            lurr=curr;\\n        while(!q.empty())\\n        {\\n            curr=q.front();\\n            q.pop();\\n            s[curr]=0;\\n            if(curr->val==startValue)\\n             burr=curr;\\n            if(curr->val==destValue)\\n             lurr=curr;\\n            if(curr->left!=NULL){\\n               m[curr->left]=curr;\\n               q.push(curr->left);\\n            }\\n        if(curr->right!=NULL){\\n               m[curr->right]=curr;\\n               q.push(curr->right);\\n            }\\n    }\\n    \\n    string ans=\"\";\\n    queue<pair<TreeNode*,string>>p;\\n    p.push({burr,\"\"});\\n    while(!p.empty()){\\n        curr=p.front().first;string s1=p.front().second;\\n        p.pop();\\n        if(s[curr]!=0)\\n          continue;\\n         if(curr==lurr)\\n         {\\n            ans=s1;\\n            break;\\n         }\\n         s[curr]=1;\\n         if(curr->left!=NULL)\\n           p.push({curr->left,s1+\"L\"});\\n         if(curr->right!=NULL)\\n           p.push({curr->right,s1+\"R\"});\\n         if(m.find(curr)!=m.end()){\\n            p.push({m[curr],s1+\"U\"});\\n         }\\n         \\n    }\\n    return ans;}\\n};\\n\\nwhy this sol is giving mle??anyone please help"
                    },
                    {
                        "username": "julia2022",
                        "content": "How can I connect with Leetcode team? Having problems with output values not being accepted (though strings are equal)"
                    },
                    {
                        "username": "julia2022",
                        "content": "There\\'s either a bug in the solutions, or something I\\'m not seeing:\\n\\nOutput vs Expected with case as incorrect\\n\"UURL\"\\n\"UURL\"\\n"
                    }
                ]
            },
            {
                "id": 1743614,
                "content": [
                    {
                        "username": "nadabao",
                        "content": "This is one of the most frequently asked question in Google interviews recently."
                    },
                    {
                        "username": "Falguni6556",
                        "content": "how to reduce memory complexity?\\n"
                    },
                    {
                        "username": "strangeranda",
                        "content": "I came across this. I had DFS done recursively, recursive has a memory overhead, so I changed it to iterative and that went well.  "
                    },
                    {
                        "username": "ganapati_biswas",
                        "content": "**If you are getting MLE or TLE for larger input then pass the path string as a reference not by value.**\\n**Pass by value will create a new string  every time recursion  is called and will lead to MLE**\\n\\n**For Example-**\\n`void helper(TreeNode* root, string startTemp, string destTemp){\\n    ......\\n\\t.....\\n  }` \\nThis code will give TLE. But \\n`void helper(TreeNode* root, string &startTemp, string &destTemp){\\n    ......\\n\\t.....\\n  }` \\nthis is perfect."
                    },
                    {
                        "username": "vyshnavkr",
                        "content": "* Above meidum level problem\\n* I thought of finding startNode first from root. And then searching for destNode from startNode tracking the path alongwise. But this fails when startNode is on the right subtree of root and destNode is on the left subtree of root. It could be fixed by searching for either of the nodes first and then the other next. Now when destNode is found first, all the Us shold be kinda converted to Ls or Rs which is still complicated.\\n* The above complexities makes this problem to be thought of 2 parts: track root to startNode path as well as track root to destNode path. See Votubac\\'s brilliant solution."
                    },
                    {
                        "username": "strangeranda",
                        "content": "For anyone that came across memory limit exceeded while doing DFS in recursive fashion, change it to iterative DFS."
                    },
                    {
                        "username": "nishidy",
                        "content": "[1,3,8,7,null,4,5,6,null,null,null,null,null,null,2]\\n2\\n1\\n\\nExpected output is \"UUUU\", but it should not be more than 3 beause the depth of the binary tree is 3 in 15 nodes. If the number of nodes is 16 or more, the depth is 4 and the maximum numbrer of \"U\" should be 4. How can it be more than the depth of the binary tree in this problem?"
                    },
                    {
                        "username": "pkuphyzzb",
                        "content": "In python3 when you use recursion for dfs you would get MLE so you have to rely on a manual DFS ...."
                    },
                    {
                        "username": "shiva_rudra123",
                        "content": "class Solution {\\npublic:\\n    \\n    string getDirections(TreeNode* root, int startValue, int destValue) {\\n        unordered_map<TreeNode*,TreeNode*>m;\\n        unordered_map<TreeNode*,int>s;\\n        TreeNode* curr=root;\\n        TreeNode* burr,*lurr;\\n        queue<TreeNode*>q;\\n        q.push(curr);\\n        if(curr->val==startValue)\\n            burr=curr;\\n        if(curr->val==destValue)\\n            lurr=curr;\\n        while(!q.empty())\\n        {\\n            curr=q.front();\\n            q.pop();\\n            s[curr]=0;\\n            if(curr->val==startValue)\\n             burr=curr;\\n            if(curr->val==destValue)\\n             lurr=curr;\\n            if(curr->left!=NULL){\\n               m[curr->left]=curr;\\n               q.push(curr->left);\\n            }\\n        if(curr->right!=NULL){\\n               m[curr->right]=curr;\\n               q.push(curr->right);\\n            }\\n    }\\n    \\n    string ans=\"\";\\n    queue<pair<TreeNode*,string>>p;\\n    p.push({burr,\"\"});\\n    while(!p.empty()){\\n        curr=p.front().first;string s1=p.front().second;\\n        p.pop();\\n        if(s[curr]!=0)\\n          continue;\\n         if(curr==lurr)\\n         {\\n            ans=s1;\\n            break;\\n         }\\n         s[curr]=1;\\n         if(curr->left!=NULL)\\n           p.push({curr->left,s1+\"L\"});\\n         if(curr->right!=NULL)\\n           p.push({curr->right,s1+\"R\"});\\n         if(m.find(curr)!=m.end()){\\n            p.push({m[curr],s1+\"U\"});\\n         }\\n         \\n    }\\n    return ans;}\\n};\\n\\nwhy this sol is giving mle??anyone please help"
                    },
                    {
                        "username": "julia2022",
                        "content": "How can I connect with Leetcode team? Having problems with output values not being accepted (though strings are equal)"
                    },
                    {
                        "username": "julia2022",
                        "content": "There\\'s either a bug in the solutions, or something I\\'m not seeing:\\n\\nOutput vs Expected with case as incorrect\\n\"UURL\"\\n\"UURL\"\\n"
                    }
                ]
            },
            {
                "id": 1576055,
                "content": [
                    {
                        "username": "nadabao",
                        "content": "This is one of the most frequently asked question in Google interviews recently."
                    },
                    {
                        "username": "Falguni6556",
                        "content": "how to reduce memory complexity?\\n"
                    },
                    {
                        "username": "strangeranda",
                        "content": "I came across this. I had DFS done recursively, recursive has a memory overhead, so I changed it to iterative and that went well.  "
                    },
                    {
                        "username": "ganapati_biswas",
                        "content": "**If you are getting MLE or TLE for larger input then pass the path string as a reference not by value.**\\n**Pass by value will create a new string  every time recursion  is called and will lead to MLE**\\n\\n**For Example-**\\n`void helper(TreeNode* root, string startTemp, string destTemp){\\n    ......\\n\\t.....\\n  }` \\nThis code will give TLE. But \\n`void helper(TreeNode* root, string &startTemp, string &destTemp){\\n    ......\\n\\t.....\\n  }` \\nthis is perfect."
                    },
                    {
                        "username": "vyshnavkr",
                        "content": "* Above meidum level problem\\n* I thought of finding startNode first from root. And then searching for destNode from startNode tracking the path alongwise. But this fails when startNode is on the right subtree of root and destNode is on the left subtree of root. It could be fixed by searching for either of the nodes first and then the other next. Now when destNode is found first, all the Us shold be kinda converted to Ls or Rs which is still complicated.\\n* The above complexities makes this problem to be thought of 2 parts: track root to startNode path as well as track root to destNode path. See Votubac\\'s brilliant solution."
                    },
                    {
                        "username": "strangeranda",
                        "content": "For anyone that came across memory limit exceeded while doing DFS in recursive fashion, change it to iterative DFS."
                    },
                    {
                        "username": "nishidy",
                        "content": "[1,3,8,7,null,4,5,6,null,null,null,null,null,null,2]\\n2\\n1\\n\\nExpected output is \"UUUU\", but it should not be more than 3 beause the depth of the binary tree is 3 in 15 nodes. If the number of nodes is 16 or more, the depth is 4 and the maximum numbrer of \"U\" should be 4. How can it be more than the depth of the binary tree in this problem?"
                    },
                    {
                        "username": "pkuphyzzb",
                        "content": "In python3 when you use recursion for dfs you would get MLE so you have to rely on a manual DFS ...."
                    },
                    {
                        "username": "shiva_rudra123",
                        "content": "class Solution {\\npublic:\\n    \\n    string getDirections(TreeNode* root, int startValue, int destValue) {\\n        unordered_map<TreeNode*,TreeNode*>m;\\n        unordered_map<TreeNode*,int>s;\\n        TreeNode* curr=root;\\n        TreeNode* burr,*lurr;\\n        queue<TreeNode*>q;\\n        q.push(curr);\\n        if(curr->val==startValue)\\n            burr=curr;\\n        if(curr->val==destValue)\\n            lurr=curr;\\n        while(!q.empty())\\n        {\\n            curr=q.front();\\n            q.pop();\\n            s[curr]=0;\\n            if(curr->val==startValue)\\n             burr=curr;\\n            if(curr->val==destValue)\\n             lurr=curr;\\n            if(curr->left!=NULL){\\n               m[curr->left]=curr;\\n               q.push(curr->left);\\n            }\\n        if(curr->right!=NULL){\\n               m[curr->right]=curr;\\n               q.push(curr->right);\\n            }\\n    }\\n    \\n    string ans=\"\";\\n    queue<pair<TreeNode*,string>>p;\\n    p.push({burr,\"\"});\\n    while(!p.empty()){\\n        curr=p.front().first;string s1=p.front().second;\\n        p.pop();\\n        if(s[curr]!=0)\\n          continue;\\n         if(curr==lurr)\\n         {\\n            ans=s1;\\n            break;\\n         }\\n         s[curr]=1;\\n         if(curr->left!=NULL)\\n           p.push({curr->left,s1+\"L\"});\\n         if(curr->right!=NULL)\\n           p.push({curr->right,s1+\"R\"});\\n         if(m.find(curr)!=m.end()){\\n            p.push({m[curr],s1+\"U\"});\\n         }\\n         \\n    }\\n    return ans;}\\n};\\n\\nwhy this sol is giving mle??anyone please help"
                    },
                    {
                        "username": "julia2022",
                        "content": "How can I connect with Leetcode team? Having problems with output values not being accepted (though strings are equal)"
                    },
                    {
                        "username": "julia2022",
                        "content": "There\\'s either a bug in the solutions, or something I\\'m not seeing:\\n\\nOutput vs Expected with case as incorrect\\n\"UURL\"\\n\"UURL\"\\n"
                    }
                ]
            },
            {
                "id": 1576478,
                "content": [
                    {
                        "username": "nadabao",
                        "content": "This is one of the most frequently asked question in Google interviews recently."
                    },
                    {
                        "username": "Falguni6556",
                        "content": "how to reduce memory complexity?\\n"
                    },
                    {
                        "username": "strangeranda",
                        "content": "I came across this. I had DFS done recursively, recursive has a memory overhead, so I changed it to iterative and that went well.  "
                    },
                    {
                        "username": "ganapati_biswas",
                        "content": "**If you are getting MLE or TLE for larger input then pass the path string as a reference not by value.**\\n**Pass by value will create a new string  every time recursion  is called and will lead to MLE**\\n\\n**For Example-**\\n`void helper(TreeNode* root, string startTemp, string destTemp){\\n    ......\\n\\t.....\\n  }` \\nThis code will give TLE. But \\n`void helper(TreeNode* root, string &startTemp, string &destTemp){\\n    ......\\n\\t.....\\n  }` \\nthis is perfect."
                    },
                    {
                        "username": "vyshnavkr",
                        "content": "* Above meidum level problem\\n* I thought of finding startNode first from root. And then searching for destNode from startNode tracking the path alongwise. But this fails when startNode is on the right subtree of root and destNode is on the left subtree of root. It could be fixed by searching for either of the nodes first and then the other next. Now when destNode is found first, all the Us shold be kinda converted to Ls or Rs which is still complicated.\\n* The above complexities makes this problem to be thought of 2 parts: track root to startNode path as well as track root to destNode path. See Votubac\\'s brilliant solution."
                    },
                    {
                        "username": "strangeranda",
                        "content": "For anyone that came across memory limit exceeded while doing DFS in recursive fashion, change it to iterative DFS."
                    },
                    {
                        "username": "nishidy",
                        "content": "[1,3,8,7,null,4,5,6,null,null,null,null,null,null,2]\\n2\\n1\\n\\nExpected output is \"UUUU\", but it should not be more than 3 beause the depth of the binary tree is 3 in 15 nodes. If the number of nodes is 16 or more, the depth is 4 and the maximum numbrer of \"U\" should be 4. How can it be more than the depth of the binary tree in this problem?"
                    },
                    {
                        "username": "pkuphyzzb",
                        "content": "In python3 when you use recursion for dfs you would get MLE so you have to rely on a manual DFS ...."
                    },
                    {
                        "username": "shiva_rudra123",
                        "content": "class Solution {\\npublic:\\n    \\n    string getDirections(TreeNode* root, int startValue, int destValue) {\\n        unordered_map<TreeNode*,TreeNode*>m;\\n        unordered_map<TreeNode*,int>s;\\n        TreeNode* curr=root;\\n        TreeNode* burr,*lurr;\\n        queue<TreeNode*>q;\\n        q.push(curr);\\n        if(curr->val==startValue)\\n            burr=curr;\\n        if(curr->val==destValue)\\n            lurr=curr;\\n        while(!q.empty())\\n        {\\n            curr=q.front();\\n            q.pop();\\n            s[curr]=0;\\n            if(curr->val==startValue)\\n             burr=curr;\\n            if(curr->val==destValue)\\n             lurr=curr;\\n            if(curr->left!=NULL){\\n               m[curr->left]=curr;\\n               q.push(curr->left);\\n            }\\n        if(curr->right!=NULL){\\n               m[curr->right]=curr;\\n               q.push(curr->right);\\n            }\\n    }\\n    \\n    string ans=\"\";\\n    queue<pair<TreeNode*,string>>p;\\n    p.push({burr,\"\"});\\n    while(!p.empty()){\\n        curr=p.front().first;string s1=p.front().second;\\n        p.pop();\\n        if(s[curr]!=0)\\n          continue;\\n         if(curr==lurr)\\n         {\\n            ans=s1;\\n            break;\\n         }\\n         s[curr]=1;\\n         if(curr->left!=NULL)\\n           p.push({curr->left,s1+\"L\"});\\n         if(curr->right!=NULL)\\n           p.push({curr->right,s1+\"R\"});\\n         if(m.find(curr)!=m.end()){\\n            p.push({m[curr],s1+\"U\"});\\n         }\\n         \\n    }\\n    return ans;}\\n};\\n\\nwhy this sol is giving mle??anyone please help"
                    },
                    {
                        "username": "julia2022",
                        "content": "How can I connect with Leetcode team? Having problems with output values not being accepted (though strings are equal)"
                    },
                    {
                        "username": "julia2022",
                        "content": "There\\'s either a bug in the solutions, or something I\\'m not seeing:\\n\\nOutput vs Expected with case as incorrect\\n\"UURL\"\\n\"UURL\"\\n"
                    }
                ]
            },
            {
                "id": 2004761,
                "content": [
                    {
                        "username": "nadabao",
                        "content": "This is one of the most frequently asked question in Google interviews recently."
                    },
                    {
                        "username": "Falguni6556",
                        "content": "how to reduce memory complexity?\\n"
                    },
                    {
                        "username": "strangeranda",
                        "content": "I came across this. I had DFS done recursively, recursive has a memory overhead, so I changed it to iterative and that went well.  "
                    },
                    {
                        "username": "ganapati_biswas",
                        "content": "**If you are getting MLE or TLE for larger input then pass the path string as a reference not by value.**\\n**Pass by value will create a new string  every time recursion  is called and will lead to MLE**\\n\\n**For Example-**\\n`void helper(TreeNode* root, string startTemp, string destTemp){\\n    ......\\n\\t.....\\n  }` \\nThis code will give TLE. But \\n`void helper(TreeNode* root, string &startTemp, string &destTemp){\\n    ......\\n\\t.....\\n  }` \\nthis is perfect."
                    },
                    {
                        "username": "vyshnavkr",
                        "content": "* Above meidum level problem\\n* I thought of finding startNode first from root. And then searching for destNode from startNode tracking the path alongwise. But this fails when startNode is on the right subtree of root and destNode is on the left subtree of root. It could be fixed by searching for either of the nodes first and then the other next. Now when destNode is found first, all the Us shold be kinda converted to Ls or Rs which is still complicated.\\n* The above complexities makes this problem to be thought of 2 parts: track root to startNode path as well as track root to destNode path. See Votubac\\'s brilliant solution."
                    },
                    {
                        "username": "strangeranda",
                        "content": "For anyone that came across memory limit exceeded while doing DFS in recursive fashion, change it to iterative DFS."
                    },
                    {
                        "username": "nishidy",
                        "content": "[1,3,8,7,null,4,5,6,null,null,null,null,null,null,2]\\n2\\n1\\n\\nExpected output is \"UUUU\", but it should not be more than 3 beause the depth of the binary tree is 3 in 15 nodes. If the number of nodes is 16 or more, the depth is 4 and the maximum numbrer of \"U\" should be 4. How can it be more than the depth of the binary tree in this problem?"
                    },
                    {
                        "username": "pkuphyzzb",
                        "content": "In python3 when you use recursion for dfs you would get MLE so you have to rely on a manual DFS ...."
                    },
                    {
                        "username": "shiva_rudra123",
                        "content": "class Solution {\\npublic:\\n    \\n    string getDirections(TreeNode* root, int startValue, int destValue) {\\n        unordered_map<TreeNode*,TreeNode*>m;\\n        unordered_map<TreeNode*,int>s;\\n        TreeNode* curr=root;\\n        TreeNode* burr,*lurr;\\n        queue<TreeNode*>q;\\n        q.push(curr);\\n        if(curr->val==startValue)\\n            burr=curr;\\n        if(curr->val==destValue)\\n            lurr=curr;\\n        while(!q.empty())\\n        {\\n            curr=q.front();\\n            q.pop();\\n            s[curr]=0;\\n            if(curr->val==startValue)\\n             burr=curr;\\n            if(curr->val==destValue)\\n             lurr=curr;\\n            if(curr->left!=NULL){\\n               m[curr->left]=curr;\\n               q.push(curr->left);\\n            }\\n        if(curr->right!=NULL){\\n               m[curr->right]=curr;\\n               q.push(curr->right);\\n            }\\n    }\\n    \\n    string ans=\"\";\\n    queue<pair<TreeNode*,string>>p;\\n    p.push({burr,\"\"});\\n    while(!p.empty()){\\n        curr=p.front().first;string s1=p.front().second;\\n        p.pop();\\n        if(s[curr]!=0)\\n          continue;\\n         if(curr==lurr)\\n         {\\n            ans=s1;\\n            break;\\n         }\\n         s[curr]=1;\\n         if(curr->left!=NULL)\\n           p.push({curr->left,s1+\"L\"});\\n         if(curr->right!=NULL)\\n           p.push({curr->right,s1+\"R\"});\\n         if(m.find(curr)!=m.end()){\\n            p.push({m[curr],s1+\"U\"});\\n         }\\n         \\n    }\\n    return ans;}\\n};\\n\\nwhy this sol is giving mle??anyone please help"
                    },
                    {
                        "username": "julia2022",
                        "content": "How can I connect with Leetcode team? Having problems with output values not being accepted (though strings are equal)"
                    },
                    {
                        "username": "julia2022",
                        "content": "There\\'s either a bug in the solutions, or something I\\'m not seeing:\\n\\nOutput vs Expected with case as incorrect\\n\"UURL\"\\n\"UURL\"\\n"
                    }
                ]
            },
            {
                "id": 1576444,
                "content": [
                    {
                        "username": "nadabao",
                        "content": "This is one of the most frequently asked question in Google interviews recently."
                    },
                    {
                        "username": "Falguni6556",
                        "content": "how to reduce memory complexity?\\n"
                    },
                    {
                        "username": "strangeranda",
                        "content": "I came across this. I had DFS done recursively, recursive has a memory overhead, so I changed it to iterative and that went well.  "
                    },
                    {
                        "username": "ganapati_biswas",
                        "content": "**If you are getting MLE or TLE for larger input then pass the path string as a reference not by value.**\\n**Pass by value will create a new string  every time recursion  is called and will lead to MLE**\\n\\n**For Example-**\\n`void helper(TreeNode* root, string startTemp, string destTemp){\\n    ......\\n\\t.....\\n  }` \\nThis code will give TLE. But \\n`void helper(TreeNode* root, string &startTemp, string &destTemp){\\n    ......\\n\\t.....\\n  }` \\nthis is perfect."
                    },
                    {
                        "username": "vyshnavkr",
                        "content": "* Above meidum level problem\\n* I thought of finding startNode first from root. And then searching for destNode from startNode tracking the path alongwise. But this fails when startNode is on the right subtree of root and destNode is on the left subtree of root. It could be fixed by searching for either of the nodes first and then the other next. Now when destNode is found first, all the Us shold be kinda converted to Ls or Rs which is still complicated.\\n* The above complexities makes this problem to be thought of 2 parts: track root to startNode path as well as track root to destNode path. See Votubac\\'s brilliant solution."
                    },
                    {
                        "username": "strangeranda",
                        "content": "For anyone that came across memory limit exceeded while doing DFS in recursive fashion, change it to iterative DFS."
                    },
                    {
                        "username": "nishidy",
                        "content": "[1,3,8,7,null,4,5,6,null,null,null,null,null,null,2]\\n2\\n1\\n\\nExpected output is \"UUUU\", but it should not be more than 3 beause the depth of the binary tree is 3 in 15 nodes. If the number of nodes is 16 or more, the depth is 4 and the maximum numbrer of \"U\" should be 4. How can it be more than the depth of the binary tree in this problem?"
                    },
                    {
                        "username": "pkuphyzzb",
                        "content": "In python3 when you use recursion for dfs you would get MLE so you have to rely on a manual DFS ...."
                    },
                    {
                        "username": "shiva_rudra123",
                        "content": "class Solution {\\npublic:\\n    \\n    string getDirections(TreeNode* root, int startValue, int destValue) {\\n        unordered_map<TreeNode*,TreeNode*>m;\\n        unordered_map<TreeNode*,int>s;\\n        TreeNode* curr=root;\\n        TreeNode* burr,*lurr;\\n        queue<TreeNode*>q;\\n        q.push(curr);\\n        if(curr->val==startValue)\\n            burr=curr;\\n        if(curr->val==destValue)\\n            lurr=curr;\\n        while(!q.empty())\\n        {\\n            curr=q.front();\\n            q.pop();\\n            s[curr]=0;\\n            if(curr->val==startValue)\\n             burr=curr;\\n            if(curr->val==destValue)\\n             lurr=curr;\\n            if(curr->left!=NULL){\\n               m[curr->left]=curr;\\n               q.push(curr->left);\\n            }\\n        if(curr->right!=NULL){\\n               m[curr->right]=curr;\\n               q.push(curr->right);\\n            }\\n    }\\n    \\n    string ans=\"\";\\n    queue<pair<TreeNode*,string>>p;\\n    p.push({burr,\"\"});\\n    while(!p.empty()){\\n        curr=p.front().first;string s1=p.front().second;\\n        p.pop();\\n        if(s[curr]!=0)\\n          continue;\\n         if(curr==lurr)\\n         {\\n            ans=s1;\\n            break;\\n         }\\n         s[curr]=1;\\n         if(curr->left!=NULL)\\n           p.push({curr->left,s1+\"L\"});\\n         if(curr->right!=NULL)\\n           p.push({curr->right,s1+\"R\"});\\n         if(m.find(curr)!=m.end()){\\n            p.push({m[curr],s1+\"U\"});\\n         }\\n         \\n    }\\n    return ans;}\\n};\\n\\nwhy this sol is giving mle??anyone please help"
                    },
                    {
                        "username": "julia2022",
                        "content": "How can I connect with Leetcode team? Having problems with output values not being accepted (though strings are equal)"
                    },
                    {
                        "username": "julia2022",
                        "content": "There\\'s either a bug in the solutions, or something I\\'m not seeing:\\n\\nOutput vs Expected with case as incorrect\\n\"UURL\"\\n\"UURL\"\\n"
                    }
                ]
            },
            {
                "id": 2048085,
                "content": [
                    {
                        "username": "nadabao",
                        "content": "This is one of the most frequently asked question in Google interviews recently."
                    },
                    {
                        "username": "Falguni6556",
                        "content": "how to reduce memory complexity?\\n"
                    },
                    {
                        "username": "strangeranda",
                        "content": "I came across this. I had DFS done recursively, recursive has a memory overhead, so I changed it to iterative and that went well.  "
                    },
                    {
                        "username": "ganapati_biswas",
                        "content": "**If you are getting MLE or TLE for larger input then pass the path string as a reference not by value.**\\n**Pass by value will create a new string  every time recursion  is called and will lead to MLE**\\n\\n**For Example-**\\n`void helper(TreeNode* root, string startTemp, string destTemp){\\n    ......\\n\\t.....\\n  }` \\nThis code will give TLE. But \\n`void helper(TreeNode* root, string &startTemp, string &destTemp){\\n    ......\\n\\t.....\\n  }` \\nthis is perfect."
                    },
                    {
                        "username": "vyshnavkr",
                        "content": "* Above meidum level problem\\n* I thought of finding startNode first from root. And then searching for destNode from startNode tracking the path alongwise. But this fails when startNode is on the right subtree of root and destNode is on the left subtree of root. It could be fixed by searching for either of the nodes first and then the other next. Now when destNode is found first, all the Us shold be kinda converted to Ls or Rs which is still complicated.\\n* The above complexities makes this problem to be thought of 2 parts: track root to startNode path as well as track root to destNode path. See Votubac\\'s brilliant solution."
                    },
                    {
                        "username": "strangeranda",
                        "content": "For anyone that came across memory limit exceeded while doing DFS in recursive fashion, change it to iterative DFS."
                    },
                    {
                        "username": "nishidy",
                        "content": "[1,3,8,7,null,4,5,6,null,null,null,null,null,null,2]\\n2\\n1\\n\\nExpected output is \"UUUU\", but it should not be more than 3 beause the depth of the binary tree is 3 in 15 nodes. If the number of nodes is 16 or more, the depth is 4 and the maximum numbrer of \"U\" should be 4. How can it be more than the depth of the binary tree in this problem?"
                    },
                    {
                        "username": "pkuphyzzb",
                        "content": "In python3 when you use recursion for dfs you would get MLE so you have to rely on a manual DFS ...."
                    },
                    {
                        "username": "shiva_rudra123",
                        "content": "class Solution {\\npublic:\\n    \\n    string getDirections(TreeNode* root, int startValue, int destValue) {\\n        unordered_map<TreeNode*,TreeNode*>m;\\n        unordered_map<TreeNode*,int>s;\\n        TreeNode* curr=root;\\n        TreeNode* burr,*lurr;\\n        queue<TreeNode*>q;\\n        q.push(curr);\\n        if(curr->val==startValue)\\n            burr=curr;\\n        if(curr->val==destValue)\\n            lurr=curr;\\n        while(!q.empty())\\n        {\\n            curr=q.front();\\n            q.pop();\\n            s[curr]=0;\\n            if(curr->val==startValue)\\n             burr=curr;\\n            if(curr->val==destValue)\\n             lurr=curr;\\n            if(curr->left!=NULL){\\n               m[curr->left]=curr;\\n               q.push(curr->left);\\n            }\\n        if(curr->right!=NULL){\\n               m[curr->right]=curr;\\n               q.push(curr->right);\\n            }\\n    }\\n    \\n    string ans=\"\";\\n    queue<pair<TreeNode*,string>>p;\\n    p.push({burr,\"\"});\\n    while(!p.empty()){\\n        curr=p.front().first;string s1=p.front().second;\\n        p.pop();\\n        if(s[curr]!=0)\\n          continue;\\n         if(curr==lurr)\\n         {\\n            ans=s1;\\n            break;\\n         }\\n         s[curr]=1;\\n         if(curr->left!=NULL)\\n           p.push({curr->left,s1+\"L\"});\\n         if(curr->right!=NULL)\\n           p.push({curr->right,s1+\"R\"});\\n         if(m.find(curr)!=m.end()){\\n            p.push({m[curr],s1+\"U\"});\\n         }\\n         \\n    }\\n    return ans;}\\n};\\n\\nwhy this sol is giving mle??anyone please help"
                    },
                    {
                        "username": "julia2022",
                        "content": "How can I connect with Leetcode team? Having problems with output values not being accepted (though strings are equal)"
                    },
                    {
                        "username": "julia2022",
                        "content": "There\\'s either a bug in the solutions, or something I\\'m not seeing:\\n\\nOutput vs Expected with case as incorrect\\n\"UURL\"\\n\"UURL\"\\n"
                    }
                ]
            },
            {
                "id": 1903956,
                "content": [
                    {
                        "username": "nadabao",
                        "content": "This is one of the most frequently asked question in Google interviews recently."
                    },
                    {
                        "username": "Falguni6556",
                        "content": "how to reduce memory complexity?\\n"
                    },
                    {
                        "username": "strangeranda",
                        "content": "I came across this. I had DFS done recursively, recursive has a memory overhead, so I changed it to iterative and that went well.  "
                    },
                    {
                        "username": "ganapati_biswas",
                        "content": "**If you are getting MLE or TLE for larger input then pass the path string as a reference not by value.**\\n**Pass by value will create a new string  every time recursion  is called and will lead to MLE**\\n\\n**For Example-**\\n`void helper(TreeNode* root, string startTemp, string destTemp){\\n    ......\\n\\t.....\\n  }` \\nThis code will give TLE. But \\n`void helper(TreeNode* root, string &startTemp, string &destTemp){\\n    ......\\n\\t.....\\n  }` \\nthis is perfect."
                    },
                    {
                        "username": "vyshnavkr",
                        "content": "* Above meidum level problem\\n* I thought of finding startNode first from root. And then searching for destNode from startNode tracking the path alongwise. But this fails when startNode is on the right subtree of root and destNode is on the left subtree of root. It could be fixed by searching for either of the nodes first and then the other next. Now when destNode is found first, all the Us shold be kinda converted to Ls or Rs which is still complicated.\\n* The above complexities makes this problem to be thought of 2 parts: track root to startNode path as well as track root to destNode path. See Votubac\\'s brilliant solution."
                    },
                    {
                        "username": "strangeranda",
                        "content": "For anyone that came across memory limit exceeded while doing DFS in recursive fashion, change it to iterative DFS."
                    },
                    {
                        "username": "nishidy",
                        "content": "[1,3,8,7,null,4,5,6,null,null,null,null,null,null,2]\\n2\\n1\\n\\nExpected output is \"UUUU\", but it should not be more than 3 beause the depth of the binary tree is 3 in 15 nodes. If the number of nodes is 16 or more, the depth is 4 and the maximum numbrer of \"U\" should be 4. How can it be more than the depth of the binary tree in this problem?"
                    },
                    {
                        "username": "pkuphyzzb",
                        "content": "In python3 when you use recursion for dfs you would get MLE so you have to rely on a manual DFS ...."
                    },
                    {
                        "username": "shiva_rudra123",
                        "content": "class Solution {\\npublic:\\n    \\n    string getDirections(TreeNode* root, int startValue, int destValue) {\\n        unordered_map<TreeNode*,TreeNode*>m;\\n        unordered_map<TreeNode*,int>s;\\n        TreeNode* curr=root;\\n        TreeNode* burr,*lurr;\\n        queue<TreeNode*>q;\\n        q.push(curr);\\n        if(curr->val==startValue)\\n            burr=curr;\\n        if(curr->val==destValue)\\n            lurr=curr;\\n        while(!q.empty())\\n        {\\n            curr=q.front();\\n            q.pop();\\n            s[curr]=0;\\n            if(curr->val==startValue)\\n             burr=curr;\\n            if(curr->val==destValue)\\n             lurr=curr;\\n            if(curr->left!=NULL){\\n               m[curr->left]=curr;\\n               q.push(curr->left);\\n            }\\n        if(curr->right!=NULL){\\n               m[curr->right]=curr;\\n               q.push(curr->right);\\n            }\\n    }\\n    \\n    string ans=\"\";\\n    queue<pair<TreeNode*,string>>p;\\n    p.push({burr,\"\"});\\n    while(!p.empty()){\\n        curr=p.front().first;string s1=p.front().second;\\n        p.pop();\\n        if(s[curr]!=0)\\n          continue;\\n         if(curr==lurr)\\n         {\\n            ans=s1;\\n            break;\\n         }\\n         s[curr]=1;\\n         if(curr->left!=NULL)\\n           p.push({curr->left,s1+\"L\"});\\n         if(curr->right!=NULL)\\n           p.push({curr->right,s1+\"R\"});\\n         if(m.find(curr)!=m.end()){\\n            p.push({m[curr],s1+\"U\"});\\n         }\\n         \\n    }\\n    return ans;}\\n};\\n\\nwhy this sol is giving mle??anyone please help"
                    },
                    {
                        "username": "julia2022",
                        "content": "How can I connect with Leetcode team? Having problems with output values not being accepted (though strings are equal)"
                    },
                    {
                        "username": "julia2022",
                        "content": "There\\'s either a bug in the solutions, or something I\\'m not seeing:\\n\\nOutput vs Expected with case as incorrect\\n\"UURL\"\\n\"UURL\"\\n"
                    }
                ]
            },
            {
                "id": 1731751,
                "content": [
                    {
                        "username": "nadabao",
                        "content": "This is one of the most frequently asked question in Google interviews recently."
                    },
                    {
                        "username": "Falguni6556",
                        "content": "how to reduce memory complexity?\\n"
                    },
                    {
                        "username": "strangeranda",
                        "content": "I came across this. I had DFS done recursively, recursive has a memory overhead, so I changed it to iterative and that went well.  "
                    },
                    {
                        "username": "ganapati_biswas",
                        "content": "**If you are getting MLE or TLE for larger input then pass the path string as a reference not by value.**\\n**Pass by value will create a new string  every time recursion  is called and will lead to MLE**\\n\\n**For Example-**\\n`void helper(TreeNode* root, string startTemp, string destTemp){\\n    ......\\n\\t.....\\n  }` \\nThis code will give TLE. But \\n`void helper(TreeNode* root, string &startTemp, string &destTemp){\\n    ......\\n\\t.....\\n  }` \\nthis is perfect."
                    },
                    {
                        "username": "vyshnavkr",
                        "content": "* Above meidum level problem\\n* I thought of finding startNode first from root. And then searching for destNode from startNode tracking the path alongwise. But this fails when startNode is on the right subtree of root and destNode is on the left subtree of root. It could be fixed by searching for either of the nodes first and then the other next. Now when destNode is found first, all the Us shold be kinda converted to Ls or Rs which is still complicated.\\n* The above complexities makes this problem to be thought of 2 parts: track root to startNode path as well as track root to destNode path. See Votubac\\'s brilliant solution."
                    },
                    {
                        "username": "strangeranda",
                        "content": "For anyone that came across memory limit exceeded while doing DFS in recursive fashion, change it to iterative DFS."
                    },
                    {
                        "username": "nishidy",
                        "content": "[1,3,8,7,null,4,5,6,null,null,null,null,null,null,2]\\n2\\n1\\n\\nExpected output is \"UUUU\", but it should not be more than 3 beause the depth of the binary tree is 3 in 15 nodes. If the number of nodes is 16 or more, the depth is 4 and the maximum numbrer of \"U\" should be 4. How can it be more than the depth of the binary tree in this problem?"
                    },
                    {
                        "username": "pkuphyzzb",
                        "content": "In python3 when you use recursion for dfs you would get MLE so you have to rely on a manual DFS ...."
                    },
                    {
                        "username": "shiva_rudra123",
                        "content": "class Solution {\\npublic:\\n    \\n    string getDirections(TreeNode* root, int startValue, int destValue) {\\n        unordered_map<TreeNode*,TreeNode*>m;\\n        unordered_map<TreeNode*,int>s;\\n        TreeNode* curr=root;\\n        TreeNode* burr,*lurr;\\n        queue<TreeNode*>q;\\n        q.push(curr);\\n        if(curr->val==startValue)\\n            burr=curr;\\n        if(curr->val==destValue)\\n            lurr=curr;\\n        while(!q.empty())\\n        {\\n            curr=q.front();\\n            q.pop();\\n            s[curr]=0;\\n            if(curr->val==startValue)\\n             burr=curr;\\n            if(curr->val==destValue)\\n             lurr=curr;\\n            if(curr->left!=NULL){\\n               m[curr->left]=curr;\\n               q.push(curr->left);\\n            }\\n        if(curr->right!=NULL){\\n               m[curr->right]=curr;\\n               q.push(curr->right);\\n            }\\n    }\\n    \\n    string ans=\"\";\\n    queue<pair<TreeNode*,string>>p;\\n    p.push({burr,\"\"});\\n    while(!p.empty()){\\n        curr=p.front().first;string s1=p.front().second;\\n        p.pop();\\n        if(s[curr]!=0)\\n          continue;\\n         if(curr==lurr)\\n         {\\n            ans=s1;\\n            break;\\n         }\\n         s[curr]=1;\\n         if(curr->left!=NULL)\\n           p.push({curr->left,s1+\"L\"});\\n         if(curr->right!=NULL)\\n           p.push({curr->right,s1+\"R\"});\\n         if(m.find(curr)!=m.end()){\\n            p.push({m[curr],s1+\"U\"});\\n         }\\n         \\n    }\\n    return ans;}\\n};\\n\\nwhy this sol is giving mle??anyone please help"
                    },
                    {
                        "username": "julia2022",
                        "content": "How can I connect with Leetcode team? Having problems with output values not being accepted (though strings are equal)"
                    },
                    {
                        "username": "julia2022",
                        "content": "There\\'s either a bug in the solutions, or something I\\'m not seeing:\\n\\nOutput vs Expected with case as incorrect\\n\"UURL\"\\n\"UURL\"\\n"
                    }
                ]
            },
            {
                "id": 1731749,
                "content": [
                    {
                        "username": "nadabao",
                        "content": "This is one of the most frequently asked question in Google interviews recently."
                    },
                    {
                        "username": "Falguni6556",
                        "content": "how to reduce memory complexity?\\n"
                    },
                    {
                        "username": "strangeranda",
                        "content": "I came across this. I had DFS done recursively, recursive has a memory overhead, so I changed it to iterative and that went well.  "
                    },
                    {
                        "username": "ganapati_biswas",
                        "content": "**If you are getting MLE or TLE for larger input then pass the path string as a reference not by value.**\\n**Pass by value will create a new string  every time recursion  is called and will lead to MLE**\\n\\n**For Example-**\\n`void helper(TreeNode* root, string startTemp, string destTemp){\\n    ......\\n\\t.....\\n  }` \\nThis code will give TLE. But \\n`void helper(TreeNode* root, string &startTemp, string &destTemp){\\n    ......\\n\\t.....\\n  }` \\nthis is perfect."
                    },
                    {
                        "username": "vyshnavkr",
                        "content": "* Above meidum level problem\\n* I thought of finding startNode first from root. And then searching for destNode from startNode tracking the path alongwise. But this fails when startNode is on the right subtree of root and destNode is on the left subtree of root. It could be fixed by searching for either of the nodes first and then the other next. Now when destNode is found first, all the Us shold be kinda converted to Ls or Rs which is still complicated.\\n* The above complexities makes this problem to be thought of 2 parts: track root to startNode path as well as track root to destNode path. See Votubac\\'s brilliant solution."
                    },
                    {
                        "username": "strangeranda",
                        "content": "For anyone that came across memory limit exceeded while doing DFS in recursive fashion, change it to iterative DFS."
                    },
                    {
                        "username": "nishidy",
                        "content": "[1,3,8,7,null,4,5,6,null,null,null,null,null,null,2]\\n2\\n1\\n\\nExpected output is \"UUUU\", but it should not be more than 3 beause the depth of the binary tree is 3 in 15 nodes. If the number of nodes is 16 or more, the depth is 4 and the maximum numbrer of \"U\" should be 4. How can it be more than the depth of the binary tree in this problem?"
                    },
                    {
                        "username": "pkuphyzzb",
                        "content": "In python3 when you use recursion for dfs you would get MLE so you have to rely on a manual DFS ...."
                    },
                    {
                        "username": "shiva_rudra123",
                        "content": "class Solution {\\npublic:\\n    \\n    string getDirections(TreeNode* root, int startValue, int destValue) {\\n        unordered_map<TreeNode*,TreeNode*>m;\\n        unordered_map<TreeNode*,int>s;\\n        TreeNode* curr=root;\\n        TreeNode* burr,*lurr;\\n        queue<TreeNode*>q;\\n        q.push(curr);\\n        if(curr->val==startValue)\\n            burr=curr;\\n        if(curr->val==destValue)\\n            lurr=curr;\\n        while(!q.empty())\\n        {\\n            curr=q.front();\\n            q.pop();\\n            s[curr]=0;\\n            if(curr->val==startValue)\\n             burr=curr;\\n            if(curr->val==destValue)\\n             lurr=curr;\\n            if(curr->left!=NULL){\\n               m[curr->left]=curr;\\n               q.push(curr->left);\\n            }\\n        if(curr->right!=NULL){\\n               m[curr->right]=curr;\\n               q.push(curr->right);\\n            }\\n    }\\n    \\n    string ans=\"\";\\n    queue<pair<TreeNode*,string>>p;\\n    p.push({burr,\"\"});\\n    while(!p.empty()){\\n        curr=p.front().first;string s1=p.front().second;\\n        p.pop();\\n        if(s[curr]!=0)\\n          continue;\\n         if(curr==lurr)\\n         {\\n            ans=s1;\\n            break;\\n         }\\n         s[curr]=1;\\n         if(curr->left!=NULL)\\n           p.push({curr->left,s1+\"L\"});\\n         if(curr->right!=NULL)\\n           p.push({curr->right,s1+\"R\"});\\n         if(m.find(curr)!=m.end()){\\n            p.push({m[curr],s1+\"U\"});\\n         }\\n         \\n    }\\n    return ans;}\\n};\\n\\nwhy this sol is giving mle??anyone please help"
                    },
                    {
                        "username": "julia2022",
                        "content": "How can I connect with Leetcode team? Having problems with output values not being accepted (though strings are equal)"
                    },
                    {
                        "username": "julia2022",
                        "content": "There\\'s either a bug in the solutions, or something I\\'m not seeing:\\n\\nOutput vs Expected with case as incorrect\\n\"UURL\"\\n\"UURL\"\\n"
                    }
                ]
            }
        ]
    }
]