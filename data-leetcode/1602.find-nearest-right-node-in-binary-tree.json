[
    {
        "title": "The Most Frequently Ordered Products for Each Customer",
        "question_content": null,
        "solutions": [],
        "discussions": [
            {
                "id": 1570447,
                "content": [
                    {
                        "username": "aodish",
                        "content": "with order_counts as (\\nSELECT\\no.customer_id,\\np.product_name,\\np.product_id,\\ncount(o.order_id) as order_count\\nFROM\\norders o\\nINNER JOIN products p ON p.product_id = o.product_id\\nGROUP BY 1,2,3)\\n\\nselect \\noc.customer_id,\\noc.product_id,\\noc.product_name\\nfrom order_counts oc\\nWHERE\\noc.order_count = (select MAX(order_count) from order_counts x where x.customer_id = oc.customer_id)\\n"
                    },
                    {
                        "username": "divy3003",
                        "content": "with ct as (select customer_id, product_id, rank()over(partition by customer_id order by count(product_id) desc) as rnk from orders group by customer_id, product_id)\\nselect c.customer_id, c.product_id, p.product_name\\nfrom ct c left join products p on c.product_id = p.product_id\\nwhere c.rnk = 1;"
                    },
                    {
                        "username": "MelodieHe",
                        "content": "WITH t1 AS (SELECT customer_id, product_id, RANK() OVER (PARTITION BY customer_id ORDER BY COUNT(order_date) DESC) AS rk FROM Orders GROUP BY customer_id, product_id)\\n\\nSELECT t1.customer_id, t1.product_id, P.product_name\\nFROM t1, Products P\\nWHERE rk = 1\\nAND t1.product_id = P.product_id\\nORDER BY t1.customer_id, t1.product_id \\n"
                    },
                    {
                        "username": "vdhyasagr",
                        "content": "A good case where you need to read the question properly. I could swear I read \"most recently\" and not \"most frequently\". That changed the whole dynamic. Straightforward solution otherwise"
                    }
                ]
            },
            {
                "id": 1570376,
                "content": [
                    {
                        "username": "aodish",
                        "content": "with order_counts as (\\nSELECT\\no.customer_id,\\np.product_name,\\np.product_id,\\ncount(o.order_id) as order_count\\nFROM\\norders o\\nINNER JOIN products p ON p.product_id = o.product_id\\nGROUP BY 1,2,3)\\n\\nselect \\noc.customer_id,\\noc.product_id,\\noc.product_name\\nfrom order_counts oc\\nWHERE\\noc.order_count = (select MAX(order_count) from order_counts x where x.customer_id = oc.customer_id)\\n"
                    },
                    {
                        "username": "divy3003",
                        "content": "with ct as (select customer_id, product_id, rank()over(partition by customer_id order by count(product_id) desc) as rnk from orders group by customer_id, product_id)\\nselect c.customer_id, c.product_id, p.product_name\\nfrom ct c left join products p on c.product_id = p.product_id\\nwhere c.rnk = 1;"
                    },
                    {
                        "username": "MelodieHe",
                        "content": "WITH t1 AS (SELECT customer_id, product_id, RANK() OVER (PARTITION BY customer_id ORDER BY COUNT(order_date) DESC) AS rk FROM Orders GROUP BY customer_id, product_id)\\n\\nSELECT t1.customer_id, t1.product_id, P.product_name\\nFROM t1, Products P\\nWHERE rk = 1\\nAND t1.product_id = P.product_id\\nORDER BY t1.customer_id, t1.product_id \\n"
                    },
                    {
                        "username": "vdhyasagr",
                        "content": "A good case where you need to read the question properly. I could swear I read \"most recently\" and not \"most frequently\". That changed the whole dynamic. Straightforward solution otherwise"
                    }
                ]
            },
            {
                "id": 1574582,
                "content": [
                    {
                        "username": "aodish",
                        "content": "with order_counts as (\\nSELECT\\no.customer_id,\\np.product_name,\\np.product_id,\\ncount(o.order_id) as order_count\\nFROM\\norders o\\nINNER JOIN products p ON p.product_id = o.product_id\\nGROUP BY 1,2,3)\\n\\nselect \\noc.customer_id,\\noc.product_id,\\noc.product_name\\nfrom order_counts oc\\nWHERE\\noc.order_count = (select MAX(order_count) from order_counts x where x.customer_id = oc.customer_id)\\n"
                    },
                    {
                        "username": "divy3003",
                        "content": "with ct as (select customer_id, product_id, rank()over(partition by customer_id order by count(product_id) desc) as rnk from orders group by customer_id, product_id)\\nselect c.customer_id, c.product_id, p.product_name\\nfrom ct c left join products p on c.product_id = p.product_id\\nwhere c.rnk = 1;"
                    },
                    {
                        "username": "MelodieHe",
                        "content": "WITH t1 AS (SELECT customer_id, product_id, RANK() OVER (PARTITION BY customer_id ORDER BY COUNT(order_date) DESC) AS rk FROM Orders GROUP BY customer_id, product_id)\\n\\nSELECT t1.customer_id, t1.product_id, P.product_name\\nFROM t1, Products P\\nWHERE rk = 1\\nAND t1.product_id = P.product_id\\nORDER BY t1.customer_id, t1.product_id \\n"
                    },
                    {
                        "username": "vdhyasagr",
                        "content": "A good case where you need to read the question properly. I could swear I read \"most recently\" and not \"most frequently\". That changed the whole dynamic. Straightforward solution otherwise"
                    }
                ]
            },
            {
                "id": 1901712,
                "content": [
                    {
                        "username": "aodish",
                        "content": "with order_counts as (\\nSELECT\\no.customer_id,\\np.product_name,\\np.product_id,\\ncount(o.order_id) as order_count\\nFROM\\norders o\\nINNER JOIN products p ON p.product_id = o.product_id\\nGROUP BY 1,2,3)\\n\\nselect \\noc.customer_id,\\noc.product_id,\\noc.product_name\\nfrom order_counts oc\\nWHERE\\noc.order_count = (select MAX(order_count) from order_counts x where x.customer_id = oc.customer_id)\\n"
                    },
                    {
                        "username": "divy3003",
                        "content": "with ct as (select customer_id, product_id, rank()over(partition by customer_id order by count(product_id) desc) as rnk from orders group by customer_id, product_id)\\nselect c.customer_id, c.product_id, p.product_name\\nfrom ct c left join products p on c.product_id = p.product_id\\nwhere c.rnk = 1;"
                    },
                    {
                        "username": "MelodieHe",
                        "content": "WITH t1 AS (SELECT customer_id, product_id, RANK() OVER (PARTITION BY customer_id ORDER BY COUNT(order_date) DESC) AS rk FROM Orders GROUP BY customer_id, product_id)\\n\\nSELECT t1.customer_id, t1.product_id, P.product_name\\nFROM t1, Products P\\nWHERE rk = 1\\nAND t1.product_id = P.product_id\\nORDER BY t1.customer_id, t1.product_id \\n"
                    },
                    {
                        "username": "vdhyasagr",
                        "content": "A good case where you need to read the question properly. I could swear I read \"most recently\" and not \"most frequently\". That changed the whole dynamic. Straightforward solution otherwise"
                    }
                ]
            }
        ]
    },
    {
        "title": "Build Binary Expression Tree From Infix Expression",
        "question_content": null,
        "solutions": [],
        "discussions": [
            {
                "id": 1837823,
                "content": [
                    {
                        "username": "coderinterview",
                        "content": "For the test case : \"(1/2/3)\"\\nExpected output is : [/,/,3,1,2]\\nMy output is : [/,1,/,null,null,2,3]\\nWhen my output is traversed in-order, same string is generated with operands in same order.\\nSo, why is it considered wrong ans?\\nMy Code:\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct Node {\\n *     char val;\\n *     Node *left;\\n *     Node *right;\\n *     Node() : val(\\' \\'), left(nullptr), right(nullptr) {}\\n *     Node(char x) : val(x), left(nullptr), right(nullptr) {}\\n *     Node(char x, Node *left, Node *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int rank(char c){\\n        if(c == \\'+\\') return 1;\\n        else if(c == \\'-\\') return 2;\\n        else if(c == \\'/\\') return 3;\\n        else if (c == \\'*\\') return 4;\\n        return 5;\\n    }\\n    Node* solve(string &s,int l,int r){\\n        if(l>r) return nullptr;\\n        int mino=l;      \\n        int ob=0;\\n        for(int i=l;i<=r;i++){\\n            if(s[i] == \\'(\\') ob++;\\n            else if(s[i] == \\')\\') ob--;\\n            else if(rank(s[i]) < rank(s[mino]) && ob == 0) mino=i;\\n            \\n        }\\n        if(mino == l && r-l != 0){\\n            ob=-1;\\n            for(int i=l;i<=r;i++){\\n                if(s[i] == \\'(\\') ob++;\\n                else if(s[i] == \\')\\') ob--;\\n                else if(rank(s[i]) < rank(s[mino]) && ob == 0) mino=i;    \\n            }\\n            l++;\\n            r--;\\n        }\\n        Node *t = new Node(s[mino]);\\n        t->left = solve(s,l,mino-1);\\n        t->right = solve(s,mino+1,r);\\n        return t;\\n    }\\n    Node* expTree(string s) {\\n        Node *ans = solve(s,0,s.length()-1);\\n        return ans;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "ndrwknsh",
                        "content": "I had the same problem in my code.\\n\\nThe output [/,1,/,null,null,2,3] is actually equivalent to \"1/(2/3)\"."
                    }
                ]
            }
        ]
    },
    {
        "title": "Crawler Log Folder",
        "question_content": "<p>The Leetcode file system keeps a log each time some user performs a <em>change folder</em> operation.</p>\n\n<p>The operations are described below:</p>\n\n<ul>\n\t<li><code>&quot;../&quot;</code> : Move to the parent folder of the current folder. (If you are already in the main folder, <strong>remain in the same folder</strong>).</li>\n\t<li><code>&quot;./&quot;</code> : Remain in the same folder.</li>\n\t<li><code>&quot;x/&quot;</code> : Move to the child folder named <code>x</code> (This folder is <strong>guaranteed to always exist</strong>).</li>\n</ul>\n\n<p>You are given a list of strings <code>logs</code> where <code>logs[i]</code> is the operation performed by the user at the <code>i<sup>th</sup></code> step.</p>\n\n<p>The file system starts in the main folder, then the operations in <code>logs</code> are performed.</p>\n\n<p>Return <em>the minimum number of operations needed to go back to the main folder after the change folder operations.</em></p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/09/09/sample_11_1957.png\" style=\"width: 775px; height: 151px;\" /></p>\n\n<pre>\n<strong>Input:</strong> logs = [&quot;d1/&quot;,&quot;d2/&quot;,&quot;../&quot;,&quot;d21/&quot;,&quot;./&quot;]\n<strong>Output:</strong> 2\n<strong>Explanation: </strong>Use this change folder operation &quot;../&quot; 2 times and go back to the main folder.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/09/09/sample_22_1957.png\" style=\"width: 600px; height: 270px;\" /></p>\n\n<pre>\n<strong>Input:</strong> logs = [&quot;d1/&quot;,&quot;d2/&quot;,&quot;./&quot;,&quot;d3/&quot;,&quot;../&quot;,&quot;d31/&quot;]\n<strong>Output:</strong> 3\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> logs = [&quot;d1/&quot;,&quot;../&quot;,&quot;../&quot;,&quot;../&quot;]\n<strong>Output:</strong> 0\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= logs.length &lt;= 10<sup>3</sup></code></li>\n\t<li><code>2 &lt;= logs[i].length &lt;= 10</code></li>\n\t<li><code>logs[i]</code> contains lowercase English letters, digits, <code>&#39;.&#39;</code>, and <code>&#39;/&#39;</code>.</li>\n\t<li><code>logs[i]</code> follows the format described in the statement.</li>\n\t<li>Folder names consist of lowercase English letters and digits.</li>\n</ul>\n",
        "solutions": [
            {
                "id": 866374,
                "title": "java-simple-o-n-loop",
                "content": "```\\n    public int minOperations(String[] logs) {\\n        int res = 0;\\n        for (String s : logs) {\\n            if (s.equals(\"../\")) res = Math.max(0, --res);\\n            else if (s.equals(\"./\")) continue;\\n            else res++;\\n        }\\n        return res;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public int minOperations(String[] logs) {\\n        int res = 0;\\n        for (String s : logs) {\\n            if (s.equals(\"../\")) res = Math.max(0, --res);\\n            else if (s.equals(\"./\")) continue;\\n            else res++;\\n        }\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 868439,
                "title": "c-check-for-and",
                "content": "Check whether we go back (`\"../\"`), stay (`\"./\"`) or deeper (otherwise), and update the number of `steps`.\\n```cpp\\nint minOperations(vector<string>& logs, int steps = 0) {\\n    for (auto log : logs)\\n        if (log == \"../\")\\n            steps = max(0, steps - 1);\\n        else if (log != \"./\")\\n            ++steps;\\n    return steps;\\n}\\n```",
                "solutionTags": [],
                "code": "```cpp\\nint minOperations(vector<string>& logs, int steps = 0) {\\n    for (auto log : logs)\\n        if (log == \"../\")\\n            steps = max(0, steps - 1);\\n        else if (log != \"./\")\\n            ++steps;\\n    return steps;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 866622,
                "title": "java-python-3-count-the-depth-of-the-folders",
                "content": "```java\\n    public int minOperations(String[] logs) {\\n        int depth = 0;\\n        for (String log : logs) {\\n            if (log.equals(\"../\")) {\\n                depth = Math.max(0, --depth);\\n            }else if (!log.equals(\"./\")) {\\n                ++depth;\\n            }\\n        }\\n        return depth;\\n    }\\n```\\n```python\\n    def minOperations(self, logs: List[str]) -> int:\\n        depth = 0\\n        for log in logs:\\n            if log == \\'../\\':\\n                depth = max(0, depth - 1)\\n            elif log != \\'./\\':\\n                depth += 1\\n        return depth\\n```\\n1 liner - credit to **@blue_sky5**\\n```python\\n    def minOperations(self, logs: List[str]) -> int:\\n        return functools.reduce(lambda depth, folder: max(0, depth - 1) if folder == \\'../\\' else depth + (folder != \\'./\\'), logs, 0)\\n```\\nImproved by **@StefanPochmann**:\\nRefer to the [hint](https://leetcode.com/problems/crawler-log-folder/discuss/866374/Java-Simple-O(N)-loop/779657).\\n```java\\n    public int minOperations(String[] logs) {\\n        return Arrays.stream(logs)\\n                     .mapToInt(log -> log.lastIndexOf(\".\"))\\n                     .reduce(0, (depth, index) -> Math.max(0, depth - index));  \\n    }\\n```\\n```python\\n    def minOperations(self, logs: List[str]) -> int:\\n        return functools.reduce(lambda depth, folder: max(0, depth - folder.rfind(\\'.\\')), logs, 0)\\n```",
                "solutionTags": [],
                "code": "```java\\n    public int minOperations(String[] logs) {\\n        int depth = 0;\\n        for (String log : logs) {\\n            if (log.equals(\"../\")) {\\n                depth = Math.max(0, --depth);\\n            }else if (!log.equals(\"./\")) {\\n                ++depth;\\n            }\\n        }\\n        return depth;\\n    }\\n```\n```python\\n    def minOperations(self, logs: List[str]) -> int:\\n        depth = 0\\n        for log in logs:\\n            if log == \\'../\\':\\n                depth = max(0, depth - 1)\\n            elif log != \\'./\\':\\n                depth += 1\\n        return depth\\n```\n```python\\n    def minOperations(self, logs: List[str]) -> int:\\n        return functools.reduce(lambda depth, folder: max(0, depth - 1) if folder == \\'../\\' else depth + (folder != \\'./\\'), logs, 0)\\n```\n```java\\n    public int minOperations(String[] logs) {\\n        return Arrays.stream(logs)\\n                     .mapToInt(log -> log.lastIndexOf(\".\"))\\n                     .reduce(0, (depth, index) -> Math.max(0, depth - index));  \\n    }\\n```\n```python\\n    def minOperations(self, logs: List[str]) -> int:\\n        return functools.reduce(lambda depth, folder: max(0, depth - folder.rfind(\\'.\\')), logs, 0)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1239366,
                "title": "shortest-c-stack-solution-100-faster",
                "content": "```\\nclass Solution\\n{\\npublic:\\n    int minOperations(vector<string> &logs)\\n    {\\n        stack<string> st;\\n        for (string &s : logs)\\n        {\\n            if (s == \"../\")\\n            {\\n                if(!st.empty())\\n                    st.pop();\\n            }\\n            else if (s == \"./\")\\n                continue;\\n            else\\n                st.push(s);\\n        }\\n        return st.size();\\n    }\\n};\\n```\\n\\n\\nIf this solution helped you in any way, then please hit the upvote button.\\nAlso, let me know if you face trouble understanding it.",
                "solutionTags": [
                    "C",
                    "Stack"
                ],
                "code": "```\\nclass Solution\\n{\\npublic:\\n    int minOperations(vector<string> &logs)\\n    {\\n        stack<string> st;\\n        for (string &s : logs)\\n        {\\n            if (s == \"../\")\\n            {\\n                if(!st.empty())\\n                    st.pop();\\n            }\\n            else if (s == \"./\")\\n                continue;\\n            else\\n                st.push(s);\\n        }\\n        return st.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1046552,
                "title": "java-o-n-stack",
                "content": "```\\nclass Solution {\\n    public int minOperations(String[] logs) {\\n         var stack = new Stack<String>();\\n        for(var log : logs){\\n            if(log.equals(\"../\")){\\n                if(!stack.empty())\\n                    stack.pop();\\n            }else if(log.equals(\"./\")){\\n\\n            }else{\\n                stack.push(log);\\n            }\\n        }\\n        return stack.size();\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Stack"
                ],
                "code": "class Solution {\\n    public int minOperations(String[] logs) {\\n         var stack = new Stack<String>();\\n        for(var log : logs){\\n            if(log.equals(\"../\")){\\n                if(!stack.empty())\\n                    stack.pop();\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 866343,
                "title": "python3-straightforward",
                "content": "\\n```\\nclass Solution:\\n    def minOperations(self, logs: List[str]) -> int:\\n        ans = 0\\n        for log in logs: \\n            if log == \"./\": continue\\n            elif log == \"../\": ans = max(0, ans-1) # parent directory\\n            else: ans += 1 # child directory \\n        return ans \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minOperations(self, logs: List[str]) -> int:\\n        ans = 0\\n        for log in logs: \\n            if log == \"./\": continue\\n            elif log == \"../\": ans = max(0, ans-1) # parent directory\\n            else: ans += 1 # child directory \\n        return ans \\n```",
                "codeTag": "Java"
            },
            {
                "id": 866722,
                "title": "faster-than-100-00-using-stack-and-without-stack-2-ways",
                "content": "```\\n//1.using stack\\nclass Solution {\\npublic:\\n    int minOperations(vector<string>& logs) {\\n\\t\\n        if(logs.size()==0) return 0;\\n\\t\\t\\n        stack<string> st;\\n        for(auto x: logs){\\n            if (x[0] != \\'.\\')  //Move to the child folder so add children\\n                st.push(x);\\n            else if(x==\"../\"){ // Move to the parent folder of the current folder so pop\\n                 if(!st.empty())  st.pop(); \\n                 else continue; //don\\u2019t move the pointer beyond the main folder.\\n            }\\n        }\\n        return st.size();\\n    }\\n};\\n//2.\\nclass Solution {\\npublic:\\n    int minOperations(vector<string>& logs) {\\n         int ans = 0;\\n        for (string log : logs) {\\n            if (log == \"../\") { // go deeper\\n                ans--; \\n                ans = max(ans, 0);\\n            } else if (log != \"./\") // one level up\\n\\t\\t\\t   ans++; \\n        }\\n        return ans;\\n    }\\n};\\n//3.\\nclass Solution {\\npublic:\\n    int minOperations(vector<string>& logs) {\\n        int res = 0;\\n        for (string s : logs) {\\n            if (s==\"../\") res = max(0, --res);\\n            else if (s==\"./\") continue;\\n            else res++;\\n        }\\n        return res;\\n    }\\n};\\n```\\n**Feel free to ask any question in the comment section.**\\nI hope that you\\'ve found the solution useful.\\nIn that case, **please do upvote and encourage me** to on my quest to document all leetcode problems\\uD83D\\uDE03\\nHappy Coding :)\\n",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n//1.using stack\\nclass Solution {\\npublic:\\n    int minOperations(vector<string>& logs) {\\n\\t\\n        if(logs.size()==0) return 0;\\n\\t\\t\\n        stack<string> st;\\n        for(auto x: logs){\\n            if (x[0] != \\'.\\')  //Move to the child folder so add children\\n                st.push(x);\\n            else if(x==\"../\"){ // Move to the parent folder of the current folder so pop\\n                 if(!st.empty())  st.pop(); \\n                 else continue; //don\\u2019t move the pointer beyond the main folder.\\n            }\\n        }\\n        return st.size();\\n    }\\n};\\n//2.\\nclass Solution {\\npublic:\\n    int minOperations(vector<string>& logs) {\\n         int ans = 0;\\n        for (string log : logs) {\\n            if (log == \"../\") { // go deeper\\n                ans--; \\n                ans = max(ans, 0);\\n            } else if (log != \"./\") // one level up\\n\\t\\t\\t   ans++; \\n        }\\n        return ans;\\n    }\\n};\\n//3.\\nclass Solution {\\npublic:\\n    int minOperations(vector<string>& logs) {\\n        int res = 0;\\n        for (string s : logs) {\\n            if (s==\"../\") res = max(0, --res);\\n            else if (s==\"./\") continue;\\n            else res++;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 871751,
                "title": "java-100-0ms-no-string-compares-explanation",
                "content": "Start at ```level = 0``` in the folder structure.  Move up or down levels in the folder structure, using 3 cases:\\n\\n1. \\t```\"../\"```  Move down a level toward the root:  Level-1, but not below zero.\\n2. \\t```\"./\"```  Do nothing.\\n3. \\t```\"text/\"```  Move upward in the folder structure:  Level+1\\n\\nTo decide on which case, for case 1. if the second character is a ```\\'.\\'``` then move down a level.  Else to decide between case 2. and case 3., if the first character is not a ```\\'.\\'``` then move up a level.  This method uses character comparisons instead of string comparisons, because usually ```char``` operations are faster than ```String``` operations.\\n\\nWhen done with all the folder strings, the resultant ```level``` number is the *number of operations needed to go back to the main folder* which was requested in the problem description.\\n```\\nclass Solution {\\n    public int minOperations(String[] logs) {\\n        int level = 0;\\n        for (String s : logs) {\\n            if (s.charAt(1) == \\'.\\')\\n                level = Math.max(0, level - 1);\\n            else if (s.charAt(0) != \\'.\\')\\n                level++;\\n        }\\n        return level;\\n    }\\n}\\n```\\n\\n**Or using ternary comparisons:**\\n```\\nclass Solution {\\n    public int minOperations(String[] logs) {\\n        int level = 0;\\n        for (String s : logs)\\n            level = (s.charAt(1) == \\'.\\') ? Math.max(0, level-1) : (s.charAt(0) != \\'.\\') ? level+1 : level;\\n        return level;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```level = 0```\n```\"../\"```\n```\"./\"```\n```\"text/\"```\n```\\'.\\'```\n```\\'.\\'```\n```char```\n```String```\n```level```\n```\\nclass Solution {\\n    public int minOperations(String[] logs) {\\n        int level = 0;\\n        for (String s : logs) {\\n            if (s.charAt(1) == \\'.\\')\\n                level = Math.max(0, level - 1);\\n            else if (s.charAt(0) != \\'.\\')\\n                level++;\\n        }\\n        return level;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int minOperations(String[] logs) {\\n        int level = 0;\\n        for (String s : logs)\\n            level = (s.charAt(1) == \\'.\\') ? Math.max(0, level-1) : (s.charAt(0) != \\'.\\') ? level+1 : level;\\n        return level;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2102858,
                "title": "python-super-easy-python-solution",
                "content": "```\\nclass Solution:\\n    def minOperations(self, logs: List[str]) -> int:\\n        res = 0\\n        \\n        for i in logs:\\n            if i == \\'../\\' and res > 0:\\n                res -= 1\\n            elif i != \\'./\\' and i != \\'../\\':\\n                res += 1\\n                \\n        return res\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minOperations(self, logs: List[str]) -> int:\\n        res = 0\\n        \\n        for i in logs:\\n            if i == \\'../\\' and res > 0:\\n                res -= 1\\n            elif i != \\'./\\' and i != \\'../\\':\\n                res += 1\\n                \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 866491,
                "title": "without-using-stack-o-1-space-complexity",
                "content": "```\\n    public int MinOperations(string[] logs) {\\n        int count = 0;\\n        \\n        foreach(string log in logs){\\n            if(log == \"../\"){\\n                if(count != 0){\\n                    count--;\\n                }\\n            }\\n            else if(log != \"./\"){\\n                count++;\\n            }\\n        }\\n        \\n        return count;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public int MinOperations(string[] logs) {\\n        int count = 0;\\n        \\n        foreach(string log in logs){\\n            if(log == \"../\"){\\n                if(count != 0){\\n                    count--;\\n                }\\n            }\\n            else if(log != \"./\"){\\n                count++;\\n            }\\n        }\\n        \\n        return count;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 866446,
                "title": "python-easy-using-stack",
                "content": "```\\n        if not logs:\\n            return 0\\n        \\n        stk = []\\n        \\n        for log in logs:\\n            if log == \\'../\\':\\n                if stk:\\n                    stk.pop()\\n            elif log == \\'./\\':\\n                continue\\n            else:\\n                stk.append(log)\\n        \\n        return len(stk)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\n        if not logs:\\n            return 0\\n        \\n        stk = []\\n        \\n        for log in logs:\\n            if log == \\'../\\':\\n                if stk:\\n                    stk.pop()\\n            elif log == \\'./\\':\\n                continue\\n            else:\\n                stk.append(log)\\n        \\n        return len(stk)\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3403932,
                "title": "c-implementation",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minOperations(vector<string>& logs) {\\n        int cnt=0;\\n        for (int i=0; i<logs.size(); i++){\\n            if (logs[i]==\"../\"){\\n                if (cnt>0)cnt--;\\n            }\\n            else if (logs[i]==\"./\"){\\n                // do nothing\\n            }\\n            else{\\n                cnt++;\\n            }\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<string>& logs) {\\n        int cnt=0;\\n        for (int i=0; i<logs.size(); i++){\\n            if (logs[i]==\"../\"){\\n                if (cnt>0)cnt--;\\n            }\\n            else if (logs[i]==\"./\"){\\n                // do nothing\\n            }\\n            else{\\n                cnt++;\\n            }\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3193850,
                "title": "easy-python-solution-using-stacks",
                "content": "# Code\\n```\\nclass Solution:\\n    def minOperations(self, logs: List[str]) -> int:\\n        stack=[]\\n        for i in logs:\\n            if i==\"./\":\\n                continue\\n            elif stack and i==\"../\":\\n                stack.pop()\\n            elif i!=\\'../\\':\\n                stack.append(i)\\n        return len(stack)\\n```",
                "solutionTags": [
                    "Python3",
                    "Array",
                    "Stack"
                ],
                "code": "```\\nclass Solution:\\n    def minOperations(self, logs: List[str]) -> int:\\n        stack=[]\\n        for i in logs:\\n            if i==\"./\":\\n                continue\\n            elif stack and i==\"../\":\\n                stack.pop()\\n            elif i!=\\'../\\':\\n                stack.append(i)\\n        return len(stack)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2507874,
                "title": "intuitive-code-and-easily-understandable-in-python",
                "content": "```\\nclass Solution:\\n    def minOperations(self, logs: List[str]) -> int:\\n        res = 0\\n        for i in logs:\\n            if i == \\'./\\':\\n                continue\\n            elif i == \\'../\\':\\n                if res > 0:\\n                    res -= 1\\n            else:\\n                res += 1\\n        return res\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minOperations(self, logs: List[str]) -> int:\\n        res = 0\\n        for i in logs:\\n            if i == \\'./\\':\\n                continue\\n            elif i == \\'../\\':\\n                if res > 0:\\n                    res -= 1\\n            else:\\n                res += 1\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 866466,
                "title": "javascript-stack",
                "content": "```\\n/**\\n * @param {string[]} logs\\n * @return {number}\\n */\\nvar minOperations = function(logs) {\\n    let stack = []\\n    for (const log of logs){\\n        if (log === \"../\"){\\n            stack.pop();\\n        } else if (log !== \"./\"){\\n            stack.push(log);\\n        }\\n    }\\n    return stack.length;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * @param {string[]} logs\\n * @return {number}\\n */\\nvar minOperations = function(logs) {\\n    let stack = []\\n    for (const log of logs){\\n        if (log === \"../\"){\\n            stack.pop();\\n        } else if (log !== \"./\"){\\n            stack.push(log);\\n        }\\n    }\\n    return stack.length;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2453034,
                "title": "js-runtime-92-91-memory-100-00",
                "content": "```\\nvar minOperations = function(logs) {\\n\\tlet level = 0;\\n\\tfor (let i = 0; i < logs.length; i++) {\\n\\t\\tif (logs[i] === \\'./\\') continue;\\n\\t\\tif (logs[i] !== \\'../\\') level++;\\n\\t\\telse level = Math.max(0, level-1);\\n\\t}\\n\\treturn level\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar minOperations = function(logs) {\\n\\tlet level = 0;\\n\\tfor (let i = 0; i < logs.length; i++) {\\n\\t\\tif (logs[i] === \\'./\\') continue;\\n\\t\\tif (logs[i] !== \\'../\\') level++;\\n\\t\\telse level = Math.max(0, level-1);\\n\\t}\\n\\treturn level\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1903453,
                "title": "python3-solution-using-stacks",
                "content": "```\\nclass Solution:\\n    def minOperations(self, logs: List[str]) -> int:\\n        m=\\'../\\'\\n        r=\\'./\\'\\n\\t\\t#create an empty stack\\n        stk=[]\\n\\t\\t#iterate through the list\\n        for i in logs:\\n\\t\\t\\t#if Move to the parent folder (../) operator occurs and stack is not empty, pop element from stack\\n            if(i==m):\\n                if(len(stk)>0):\\n                    stk.pop()\\n\\t\\t\\t#else if Remain in the same folder (./) operator occurs, do nothing and move to next element in list\\n            elif(i==r):\\n                continue\\n\\t\\t\\t#else add element to the stack\\n            else:\\n                stk.append(i)\\n\\t\\t#now return the size of the stack which would be the minimum number of operations needed to go back to the main folder\\n        return(len(stk))\\n\\t\\t```",
                "solutionTags": [
                    "Python",
                    "Stack"
                ],
                "code": "```\\nclass Solution:\\n    def minOperations(self, logs: List[str]) -> int:\\n        m=\\'../\\'\\n        r=\\'./\\'\\n\\t\\t#create an empty stack\\n        stk=[]\\n\\t\\t#iterate through the list\\n        for i in logs:\\n\\t\\t\\t#if Move to the parent folder (../) operator occurs and stack is not empty, pop element from stack\\n            if(i==m):\\n                if(len(stk)>0):\\n                    stk.pop()\\n\\t\\t\\t#else if Remain in the same folder (./) operator occurs, do nothing and move to next element in list\\n            elif(i==r):\\n                continue\\n\\t\\t\\t#else add element to the stack\\n            else:\\n                stk.append(i)\\n\\t\\t#now return the size of the stack which would be the minimum number of operations needed to go back to the main folder\\n        return(len(stk))\\n\\t\\t```",
                "codeTag": "Java"
            },
            {
                "id": 1529675,
                "title": "c-2-approach-1-with-extra-space-2-without-extra-space",
                "content": "#### WITH EXTRA SPACE \\n```\\nclass Solution {\\npublic:\\n    int minOperations(vector<string>& logs) \\n    {\\n         stack<string> st;\\n        \\n        for(int i=0;i<logs.size();i++)\\n        {\\n            if(!st.empty() && logs[i] == \"../\")\\n            {\\n                st.pop();\\n            }\\n            else if(st.empty() && logs[i] == \"../\")\\n            {\\n                continue;\\n            }\\n            else if(logs[i] == \"./\")\\n            {\\n                continue;\\n            }\\n            else \\n            {\\n                st.push(logs[i]);\\n            }\\n        }\\n        return st.size();\\n       \\n    }\\n};\\n```\\n**WITHOUT USING EXTRA SPACE** \\n```\\nclass Solution {\\npublic:\\n    int minOperations(vector<string>& logs) \\n    {\\n        int count = 0;\\n        for(int i=0;i<logs.size();i++)\\n        {\\n            if(logs[i] != \"./\")\\n            {\\n                if(logs[i] == \"../\")\\n                {\\n                    if(count > 0)\\n                    {\\n                        count--;\\n                    }\\n                    \\n                }\\n                else\\n                {\\n                    count++;\\n                }\\n            }\\n            \\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<string>& logs) \\n    {\\n         stack<string> st;\\n        \\n        for(int i=0;i<logs.size();i++)\\n        {\\n            if(!st.empty() && logs[i] == \"../\")\\n            {\\n                st.pop();\\n            }\\n            else if(st.empty() && logs[i] == \"../\")\\n            {\\n                continue;\\n            }\\n            else if(logs[i] == \"./\")\\n            {\\n                continue;\\n            }\\n            else \\n            {\\n                st.push(logs[i]);\\n            }\\n        }\\n        return st.size();\\n       \\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int minOperations(vector<string>& logs) \\n    {\\n        int count = 0;\\n        for(int i=0;i<logs.size();i++)\\n        {\\n            if(logs[i] != \"./\")\\n            {\\n                if(logs[i] == \"../\")\\n                {\\n                    if(count > 0)\\n                    {\\n                        count--;\\n                    }\\n                    \\n                }\\n                else\\n                {\\n                    count++;\\n                }\\n            }\\n            \\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1359182,
                "title": "two-simple-java-solutions",
                "content": "Intuition:\\nThere can be three kind of strings possible in logs:\\n\"./\", \"../\", \"d/\"\\nFirst Type  \"./\" :  In this type we don\\'t need to move anywhere so don\\'t do anything.\\nSecond Type \"../\": In this type we need to go back to previous directory so remove last entry from stack(if stack contains any entry).\\nThird Type \"d/\":  In this type we need to move to next directory so push new entry into stack.\\nIn the end return the position of final directory from root directory which is the size of stack.\\n\\nSolution 1 using stack:\\n\\n```\\nclass Solution {\\n    public int minOperations(String[] logs) {\\n        Stack<String> s= new Stack<>();\\n        for(String log : logs) {\\n            if(log.charAt(1)==\\'.\\' && !s.isEmpty())  // pop only when \"../\" log is there and there should be some entry in stack.\\n                s.pop();\\n            else if(log.charAt(0)!=\\'/\\' && log.charAt(0)!=\\'.\\') //directory name can be anything so check for two conditions\\n                s.push(log);\\n        }\\n        return s.size();\\n    }\\n}\\n```\\n\\n\\n\\n\\nSolution 2: using single variable \\n\\nYou can replace stack with simple variable. When you need to push new directory then just increment variable and when you need to pop then just decrement that variable. finally return the final directory position from root directory.\\n\\n```\\nclass Solution {\\n    public int minOperations(String[] logs) {\\n        int res=0;\\n        for(String log : logs) {\\n            if(log.charAt(1)==\\'.\\' && res>0)\\n                res--;\\n            else if(log.charAt(0)!=\\'/\\' && log.charAt(0)!=\\'.\\')\\n                res++;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minOperations(String[] logs) {\\n        Stack<String> s= new Stack<>();\\n        for(String log : logs) {\\n            if(log.charAt(1)==\\'.\\' && !s.isEmpty())  // pop only when \"../\" log is there and there should be some entry in stack.\\n                s.pop();\\n            else if(log.charAt(0)!=\\'/\\' && log.charAt(0)!=\\'.\\') //directory name can be anything so check for two conditions\\n                s.push(log);\\n        }\\n        return s.size();\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int minOperations(String[] logs) {\\n        int res=0;\\n        for(String log : logs) {\\n            if(log.charAt(1)==\\'.\\' && res>0)\\n                res--;\\n            else if(log.charAt(0)!=\\'/\\' && log.charAt(0)!=\\'.\\')\\n                res++;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1346322,
                "title": "java-0ms-100-fast-and-easy-to-understand-solution",
                "content": "Basic idea is to maintain depth of the current folder w.r.t. main folder.\\nAs there are only 3 types of command then interpret and manipulate(+1, -1, 0) depth accordingly.\\n**Type 1** \"./\" : Depth will be same \\n**Type 2** \"../\" : Decrease depth value by 1\\n**Type 3** \"x/\" : Increase depth value by 1\\n\\n```\\npublic int minOperations(String[] logs) {\\n        int depth = 0;\\n        for (String cmd : logs) {\\n            depth += interpretCurrentCMD(cmd);\\n            depth = depth < 0 ? 0 : depth;\\n            //Above condition will keep pointer in \\n            //same folder if already in the main folder\\n        }\\n        return depth;\\n    }\\n\\n    private int interpretCurrentCMD(String cmd) {\\n        // CMD Type \"./\"\\n        if (cmd.equals(\"./\")) {\\n            return 0;\\n        }\\n\\n        // CMD Type \"../\"\\n        if (cmd.equals(\"../\")) {\\n            return -1;\\n        }\\n\\n        // CMD Type \"x/\"\\n        return 1;\\n    }\\n```\\nPlease do upvote if you liked the solution or comment incase any doubt :)",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic int minOperations(String[] logs) {\\n        int depth = 0;\\n        for (String cmd : logs) {\\n            depth += interpretCurrentCMD(cmd);\\n            depth = depth < 0 ? 0 : depth;\\n            //Above condition will keep pointer in \\n            //same folder if already in the main folder\\n        }\\n        return depth;\\n    }\\n\\n    private int interpretCurrentCMD(String cmd) {\\n        // CMD Type \"./\"\\n        if (cmd.equals(\"./\")) {\\n            return 0;\\n        }\\n\\n        // CMD Type \"../\"\\n        if (cmd.equals(\"../\")) {\\n            return -1;\\n        }\\n\\n        // CMD Type \"x/\"\\n        return 1;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1331526,
                "title": "easy-python-solution",
                "content": "```\\nclass Solution:\\n    def minOperations(self, logs: List[str]) -> int:\\n        s = []\\n        for i in range(len(logs)):\\n            if logs[i] == \"../\":\\n                if len(s) == 0:\\n                    continue\\n                else:\\n                    s.pop(-1)\\n            elif logs[i] == \"./\":\\n                continue\\n            else:\\n                s.append(1)\\n        return len(s)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minOperations(self, logs: List[str]) -> int:\\n        s = []\\n        for i in range(len(logs)):\\n            if logs[i] == \"../\":\\n                if len(s) == 0:\\n                    continue\\n                else:\\n                    s.pop(-1)\\n            elif logs[i] == \"./\":\\n                continue\\n            else:\\n                s.append(1)\\n        return len(s)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3536067,
                "title": "java-simple-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n**O(n)**\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minOperations(String[] logs) {\\n\\n      \\n\\t\\tList<String> folder = new ArrayList<>();\\n\\n        for(int i=0;i<logs.length;i++)\\n        {\\n            if(logs[i].equals(\"./\"))\\n            {\\n                continue;\\n            }\\n            else if(logs[i].equals(\"../\"))\\n            {\\n            \\tif(folder.size()>1)\\n                folder.remove(folder.size()-1);\\n            \\telse\\n            \\t\\tfolder.clear();\\n            }\\n            else\\n            folder.add(logs[i]);\\n        }\\n\\n        return folder.size();\\n\\t}\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minOperations(String[] logs) {\\n\\n      \\n\\t\\tList<String> folder = new ArrayList<>();\\n\\n        for(int i=0;i<logs.length;i++)\\n        {\\n            if(logs[i].equals(\"./\"))\\n            {\\n                continue;\\n            }\\n            else if(logs[i].equals(\"../\"))\\n            {\\n            \\tif(folder.size()>1)\\n                folder.remove(folder.size()-1);\\n            \\telse\\n            \\t\\tfolder.clear();\\n            }\\n            else\\n            folder.add(logs[i]);\\n        }\\n\\n        return folder.size();\\n\\t}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3361090,
                "title": "crawler-log-folder-solution-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minOperations(vector<string>& logs) {\\n        int i, count=0;\\n        for(i=0 ; i<logs.size() ; i++)\\n        {\\n            if(logs[i]==\"../\" && count>0)\\n                count--;\\n            else if(logs[i]!=\"./\" && logs[i]!=\"../\")\\n                count++;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<string>& logs) {\\n        int i, count=0;\\n        for(i=0 ; i<logs.size() ; i++)\\n        {\\n            if(logs[i]==\"../\" && count>0)\\n                count--;\\n            else if(logs[i]!=\"./\" && logs[i]!=\"../\")\\n                count++;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3194915,
                "title": "reduce-switch-case-solution",
                "content": "# Code\\n```\\n/**\\n * @param {string[]} logs\\n * @return {number}\\n */\\nvar minOperations = function(logs) {\\n    return logs.reduce((acc, log) => {\\n        switch (log) {\\n            case \\'../\\':\\n                return Math.max(acc - 1, 0);\\n            case \\'./\\':\\n                return acc;\\n            default:\\n                return acc + 1;\\n        }\\n    }, 0);\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string[]} logs\\n * @return {number}\\n */\\nvar minOperations = function(logs) {\\n    return logs.reduce((acc, log) => {\\n        switch (log) {\\n            case \\'../\\':\\n                return Math.max(acc - 1, 0);\\n            case \\'./\\':\\n                return acc;\\n            default:\\n                return acc + 1;\\n        }\\n    }, 0);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3037519,
                "title": "python-solution-with-one-pass",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIterate through the logs, \\n- if there are two dots and the steps is greater than zero, then step decreases by 1\\n- if there is only one dot, steps doesn\\' change\\n- if it\\'s a folder, steps increase by 1\\n\\n\\n\\n# Complexity\\n- Time complexity: `O(n)`\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: `O(1)`\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```python\\nclass Solution:\\n    def minOperations(self, logs: List[str]) -> int:\\n        steps = 0\\n        for log in logs:\\n            if \"..\" in log:\\n                steps -= steps > 0\\n            elif \".\" in log:\\n                continue\\n            else:\\n                steps += 1\\n        return steps if steps > 0 else 0\\n```\\n\\nOr using `match`\\n\\n```python\\nclass Solution:\\n    def minOperations(self, logs: List[str]) -> int:\\n        steps = 0\\n        for log in logs:\\n            match log.split(\"/\")[0]:\\n                case \"..\":\\n                    steps -= steps > 0\\n                case \".\":\\n                    continue\\n                case d:\\n                    steps += 1\\n        return steps if steps > 0 else 0\\n```\\n\\n**Please upvote if you found if helpful.**",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```python\\nclass Solution:\\n    def minOperations(self, logs: List[str]) -> int:\\n        steps = 0\\n        for log in logs:\\n            if \"..\" in log:\\n                steps -= steps > 0\\n            elif \".\" in log:\\n                continue\\n            else:\\n                steps += 1\\n        return steps if steps > 0 else 0\\n```\n```python\\nclass Solution:\\n    def minOperations(self, logs: List[str]) -> int:\\n        steps = 0\\n        for log in logs:\\n            match log.split(\"/\")[0]:\\n                case \"..\":\\n                    steps -= steps > 0\\n                case \".\":\\n                    continue\\n                case d:\\n                    steps += 1\\n        return steps if steps > 0 else 0\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2961942,
                "title": "100-faster-java-solution-easy-and-simple",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public int minOperations(String[] logs) {\\n        int count=0;\\n        for(int i=0;i<logs.length;i++){\\n            if(logs[i].startsWith(\"..\")) count--;\\n            else if(logs[i].startsWith(\"./\")) continue;\\n            else count++;\\n\\n            if(count < 0) count =0;\\n        }\\n\\n        return count<0? 0 : count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minOperations(String[] logs) {\\n        int count=0;\\n        for(int i=0;i<logs.length;i++){\\n            if(logs[i].startsWith(\"..\")) count--;\\n            else if(logs[i].startsWith(\"./\")) continue;\\n            else count++;\\n\\n            if(count < 0) count =0;\\n        }\\n\\n        return count<0? 0 : count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2838141,
                "title": "java-easy-peasy-lemon-squeezy-solution",
                "content": "# Code\\n```\\nclass Solution {\\n    public int minOperations(String[] logs) {\\n        int count = 0;\\n        for (String move : logs) {\\n            switch (move) {\\n                case \"../\": {\\n                    if (count > 0)\\n                        count--;\\n                    break;\\n                }\\n                case \"./\": {\\n                    break;\\n                }\\n                default: {\\n                    count++;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minOperations(String[] logs) {\\n        int count = 0;\\n        for (String move : logs) {\\n            switch (move) {\\n                case \"../\": {\\n                    if (count > 0)\\n                        count--;\\n                    break;\\n                }\\n                case \"./\": {\\n                    break;\\n                }\\n                default: {\\n                    count++;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2641602,
                "title": "c-code",
                "content": "![image](https://assets.leetcode.com/users/images/9270a1fb-5c9f-4344-8eea-6e862ae6e403_1664524709.758991.png)\\n// creating stack then simple checking for two conditions , at the last return the size of stack . \\n\\n        stack<string>stk;\\n        for(int i = 0 ; i <logs.size();i++)\\n        {\\n            string str = logs[i];\\n            if(str == \"../\")\\n            {\\n                if(!stk.empty())\\n                {\\n                    stk.pop();\\n                }\\n            }\\n            else if(str != \"./\")\\n            {\\n                stk.push(str);\\n            }\\n        }\\n        return stk.size();\\n\\n",
                "solutionTags": [
                    "Stack"
                ],
                "code": "![image](https://assets.leetcode.com/users/images/9270a1fb-5c9f-4344-8eea-6e862ae6e403_1664524709.758991.png)\\n// creating stack then simple checking for two conditions , at the last return the size of stack . \\n\\n        stack<string>stk;\\n        for(int i = 0 ; i <logs.size();i++)\\n        {\\n            string str = logs[i];\\n            if(str == \"../\")\\n            {\\n                if(!stk.empty())\\n                {\\n                    stk.pop();\\n                }\\n            }\\n            else if(str != \"./\")\\n            {\\n                stk.push(str);\\n            }\\n        }\\n        return stk.size();\\n\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 2387765,
                "title": "two-solutions-stack-solution-iterative-solution",
                "content": "**Stack solution**\\n```\\nclass Solution {\\npublic:\\n    int minOperations(vector<string>& logs) {\\n        stack<int> s;\\n        for(int i = 0; i < logs.size(); i++){\\n            if(isalpha(logs[i][0]) || isdigit(logs[i][0]))\\n                s.push(1);\\n            \\n            if(logs[i] ==\"../\" && !s.empty())\\n                s.pop();\\n            \\n            if(logs[i] == \"./\")\\n                continue;\\n            \\n        }\\n        return s.size();\\n    }\\n};\\n```\\n\\n**Iterative solution**\\n```\\nclass Solution {\\npublic:\\n    int minOperations(vector<string>& logs) {\\n        int count = 0;\\n        for(int i = 0; i < logs.size(); i++){\\n            if(isalpha(logs[i][0]) || isdigit(logs[i][0]))\\n                count++;\\n            \\n            if(logs[i] ==\"../\" && count != 0)\\n                count--;\\n            \\n            if(logs[i] == \"./\")\\n                continue;\\n        }\\n        \\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<string>& logs) {\\n        stack<int> s;\\n        for(int i = 0; i < logs.size(); i++){\\n            if(isalpha(logs[i][0]) || isdigit(logs[i][0]))\\n                s.push(1);\\n            \\n            if(logs[i] ==\"../\" && !s.empty())\\n                s.pop();\\n            \\n            if(logs[i] == \"./\")\\n                continue;\\n            \\n        }\\n        return s.size();\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int minOperations(vector<string>& logs) {\\n        int count = 0;\\n        for(int i = 0; i < logs.size(); i++){\\n            if(isalpha(logs[i][0]) || isdigit(logs[i][0]))\\n                count++;\\n            \\n            if(logs[i] ==\"../\" && count != 0)\\n                count--;\\n            \\n            if(logs[i] == \"./\")\\n                continue;\\n        }\\n        \\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2007281,
                "title": "java-modified-stack-approach-beats-96-submissions",
                "content": "```\\nclass Solution {\\n    public int minOperations(String[] logs) {\\n        int c=0;\\n        \\n        for(int i=0; i<logs.length; i++){\\n            if(!logs[i].equals(\"./\") && !logs[i].equals(\"../\")){\\n                c++;\\n            }\\n            else if(c>0 && logs[i].equals(\"../\")){\\n                c--;\\n            }\\n        }\\n        \\n        return c;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minOperations(String[] logs) {\\n        int c=0;\\n        \\n        for(int i=0; i<logs.length; i++){\\n            if(!logs[i].equals(\"./\") && !logs[i].equals(\"../\")){\\n                c++;\\n            }\\n            else if(c>0 && logs[i].equals(\"../\")){\\n                c--;\\n            }\\n        }\\n        \\n        return c;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1490100,
                "title": "java-using-stack-do-checkout",
                "content": "**//Do vote up if you like it :)**\\n```\\nclass Solution {\\n    public int minOperations(String[] logs) {\\n        int len = logs.length;\\n        Stack<String> stack = new Stack<>();\\n        stack.push(\"Main\");\\n        for(int i = 0; i < len; i++) {\\n            if(logs[i].equals(\"./\")) continue; //Remain in same folder\\n            else if(logs[i].equals(\"../\")) {\\n                if(stack.peek().equals(\"Main\")) continue; //Already at parent\\n                else stack.pop(); //Go to one level back of the heirarchy\\n            }\\n            else stack.push(logs[i]); //Go to one level up of the heirarchy\\n        }\\n        int count = 0;\\n        while(!stack.peek().equals(\"Main\")) { //Pop until you reach to Main\\n            stack.pop();\\n            count++;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minOperations(String[] logs) {\\n        int len = logs.length;\\n        Stack<String> stack = new Stack<>();\\n        stack.push(\"Main\");\\n        for(int i = 0; i < len; i++) {\\n            if(logs[i].equals(\"./\")) continue; //Remain in same folder\\n            else if(logs[i].equals(\"../\")) {\\n                if(stack.peek().equals(\"Main\")) continue; //Already at parent\\n                else stack.pop(); //Go to one level back of the heirarchy\\n            }\\n            else stack.push(logs[i]); //Go to one level up of the heirarchy\\n        }\\n        int count = 0;\\n        while(!stack.peek().equals(\"Main\")) { //Pop until you reach to Main\\n            stack.pop();\\n            count++;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1315038,
                "title": "easy-fast-python-solution-faster-than-95-00",
                "content": "# Easy, Fast Python Solution (faster than 95.00%)\\nRuntime: 40 ms, faster than 95.00% of Python3 online submissions for Crawler Log Folder.\\nMemory Usage: 14.5 MB\\n\\n```\\ndef minOperations(self, logs: List[str]) -> int:\\n        length = len(logs)\\n        i = 0\\n\\n        while i < length:\\n            if logs[i] == \\'./\\':\\n                del logs[i]\\n                length -= 1\\n            elif logs[i] == \\'../\\':\\n                if i < 1:\\n                    del logs[i]\\n                    length -= 1\\n                else:\\n                    del logs[i]\\n                    del logs[i-1]\\n                    i -= 1\\n                    length -= 2\\n            else:\\n                i += 1\\n\\n        return len(logs)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\ndef minOperations(self, logs: List[str]) -> int:\\n        length = len(logs)\\n        i = 0\\n\\n        while i < length:\\n            if logs[i] == \\'./\\':\\n                del logs[i]\\n                length -= 1\\n            elif logs[i] == \\'../\\':\\n                if i < 1:\\n                    del logs[i]\\n                    length -= 1\\n                else:\\n                    del logs[i]\\n                    del logs[i-1]\\n                    i -= 1\\n                    length -= 2\\n            else:\\n                i += 1\\n\\n        return len(logs)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1098198,
                "title": "4-ms-faster-than-95-55-of-c-using-simple-stack-implementation",
                "content": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<string>& logs) {\\n        stack<string>s;\\n        int count=0;\\n        for(int i=0;i<logs.size();i++){\\n            string str=logs[i];\\n            if(str==\"../\"){\\n                if(!s.empty()) s.pop();\\n            }\\n            else if(str!=\"./\"){\\n              s.push(str);   \\n            }\\n        }\\n        while(!s.empty()){\\n            s.pop();\\n            count++;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<string>& logs) {\\n        stack<string>s;\\n        int count=0;\\n        for(int i=0;i<logs.size();i++){\\n            string str=logs[i];\\n            if(str==\"../\"){\\n                if(!s.empty()) s.pop();\\n            }\\n            else if(str!=\"./\"){\\n              s.push(str);   \\n            }\\n        }\\n        while(!s.empty()){\\n            s.pop();\\n            count++;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1065177,
                "title": "java-regex-solution-unique-in-this-discussion",
                "content": "I don\\'t know why these dicuss solutions are so repetitive I felt that this question can also be done using regex, and I am not so good at this, so I though let\\'s look up in the dicuss, sadly all the solutions in Java discuss were a repetitive code. So I had to come up with this code\\n\\n```\\npublic int minOperations(String[] logs) {\\n        int ans=0;\\n        for(String s : logs){\\n            if(s.equals(\"../\")) ans = Math.max(--ans,0);\\n            else if(s.matches(\"[0-9a-z]+/\")) ans++;\\n        }\\n        return ans;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic int minOperations(String[] logs) {\\n        int ans=0;\\n        for(String s : logs){\\n            if(s.equals(\"../\")) ans = Math.max(--ans,0);\\n            else if(s.matches(\"[0-9a-z]+/\")) ans++;\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1045008,
                "title": "beats-97-using-stack-o-n",
                "content": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<string> &logs) {\\n            \\n        stack <int> st;    \\n            \\n        for(string &s : logs){\\n                if(s == \"../\" && !st.empty())\\n                    st.pop();\\n                else if(s != \"./\" && s != \"../\")\\n                    st.push(1);    \\n        }\\n        \\n       return st.size();\\n    }\\n};\\n```\\n**Pls upvote my solution if you like it**",
                "solutionTags": [
                    "C",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<string> &logs) {\\n            \\n        stack <int> st;    \\n            \\n        for(string &s : logs){\\n                if(s == \"../\" && !st.empty())\\n                    st.pop();\\n                else if(s != \"./\" && s != \"../\")\\n                    st.push(1);    \\n        }\\n        \\n       return st.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 944864,
                "title": "c-99-faster-code-easy-to-understand-code",
                "content": "\\tclass Solution {\\n\\tpublic:\\n\\t\\tint minOperations(vector<string>& logs) {\\n\\n\\t\\t\\tint ans = 0; //this will keep track of our position\\n\\t\\t\\t\\t\\t\\t // i.e, how far we are from main folder \\n\\n\\t\\t\\tfor(int i=0;i<logs.size();i++){\\n\\n\\t\\t\\t\\tstring curr = logs[i];\\n\\n\\t\\t\\t\\tif(curr == \"../\")\\n\\t\\t\\t\\t\\tans--; \\n\\t\\t\\t\\telse if(curr == \"./\")\\n\\t\\t\\t\\t\\tans = ans;\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\tans++;\\n\\n\\t\\t\\t\\tif(ans < 0) ans  = 0;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tif(ans < 0) ans = 0;\\n\\n\\t\\t\\treturn ans;\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tint minOperations(vector<string>& logs) {\\n\\n\\t\\t\\tint ans = 0; //this will keep track of our position\\n\\t\\t\\t\\t\\t\\t // i.e, how far we are from main folder \\n\\n\\t\\t\\tfor(int i=0;i<logs.size();i++){\\n\\n\\t\\t\\t\\tstring curr = logs[i];\\n\\n\\t\\t\\t\\tif(curr == \"../\")\\n\\t\\t\\t\\t\\tans--; \\n\\t\\t\\t\\telse if(curr == \"./\")\\n\\t\\t\\t\\t\\tans = ans;\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\tans++;\\n\\n\\t\\t\\t\\tif(ans < 0) ans  = 0;\\n\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 886987,
                "title": "faster-than-53-36-of-c-memory-usage-10-8-mb-less-than-99-86",
                "content": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<string>& logs) {\\n        \\n        int ops=0;\\n        \\n        for(auto c:logs){\\n            \\n            if(c==\"../\") {\\n                \\n                if(ops>0)\\n                ops--;\\n            }\\n            else {\\n                \\n                if(c==\"./\") continue;\\n                else {\\n                    ops++;\\n                }\\n                \\n            }\\n            \\n        }\\n        \\n        return ops;     \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<string>& logs) {\\n        \\n        int ops=0;\\n        \\n        for(auto c:logs){\\n            \\n            if(c==\"../\") {\\n                \\n                if(ops>0)\\n                ops--;\\n            }\\n            else {\\n                \\n                if(c==\"./\") continue;\\n                else {\\n                    ops++;\\n                }\\n                \\n            }\\n            \\n        }\\n        \\n        return ops;     \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 866489,
                "title": "python-and-c-simple-python-code-o-n",
                "content": "**PYTHON**\\n```\\ndef minOperations(self, logs: List[str]) -> int:\\n        res = 0\\n        for val in logs:\\n            if(val  ==  \"../\"):\\n                if res: res-=1\\n            elif(val != \"./\" ) :  # to count for operations such as d1/ , d21/ \\n                res+=1\\n        return res\\n```\\n\\n**C++**\\n```\\nclass Solution {\\npublic:\\n    int minOperations(vector<string>& logs) {\\n        int res = 0;\\n        for(string val :logs){\\n            if(val==\"../\"){\\n                if(res!=0) res--;\\n            }\\n            else  if(val != \"./\") res+=1;  \\n\\t\\t}\\n        return res;\\n};\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\ndef minOperations(self, logs: List[str]) -> int:\\n        res = 0\\n        for val in logs:\\n            if(val  ==  \"../\"):\\n                if res: res-=1\\n            elif(val != \"./\" ) :  # to count for operations such as d1/ , d21/ \\n                res+=1\\n        return res\\n```\n```\\nclass Solution {\\npublic:\\n    int minOperations(vector<string>& logs) {\\n        int res = 0;\\n        for(string val :logs){\\n            if(val==\"../\"){\\n                if(res!=0) res--;\\n            }\\n            else  if(val != \"./\") res+=1;  \\n\\t\\t}\\n        return res;\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 866437,
                "title": "python-o-n-solution",
                "content": "```\\nclass Solution:\\n    def minOperations(self, logs: List[str]) -> int:\\n        \\n        # ans will hold minimum number of operations required\\n        ans = 0\\n        for i in logs:\\n            # when we go up by one directory the operation will decrease by 1\\n            if i==\"../\":\\n                ans-=1\\n            # nothing to do we neither go one directory up or down\\n            elif i==\\'./\\':\\n                pass\\n            # we have gone down by one directory so required operations will increase\\n            else:\\n                ans+=1\\n            # ans<0 means we were in the main directory and we perform ../ which means nothing\\n            if ans<0:\\n                ans = 0\\n        if ans<0:\\n            return 0\\n        return ans\\n\\n\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minOperations(self, logs: List[str]) -> int:\\n        \\n        # ans will hold minimum number of operations required\\n        ans = 0\\n        for i in logs:\\n            # when we go up by one directory the operation will decrease by 1\\n            if i==\"../\":\\n                ans-=1\\n            # nothing to do we neither go one directory up or down\\n            elif i==\\'./\\':\\n                pass\\n            # we have gone down by one directory so required operations will increase\\n            else:\\n                ans+=1\\n            # ans<0 means we were in the main directory and we perform ../ which means nothing\\n            if ans<0:\\n                ans = 0\\n        if ans<0:\\n            return 0\\n        return ans\\n\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 866397,
                "title": "c-simple-few-lines-solution-clean-code",
                "content": "```\\n int minOperations(vector<string>& logs) {\\n        int ans = 0;\\n        for (string log : logs) {\\n            if (log == \"../\") {\\n                ans--;\\n                ans = max(ans, 0);\\n            } else if (log != \"./\") ans++;\\n        }\\n        return ans;\\n    }",
                "solutionTags": [],
                "code": "```\\n int minOperations(vector<string>& logs) {\\n        int ans = 0;\\n        for (string log : logs) {\\n            if (log == \"../\") {\\n                ans--;\\n                ans = max(ans, 0);\\n            } else if (log != \"./\") ans++;\\n        }\\n        return ans;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3972434,
                "title": "simple-implementing-with-using-stack-ds",
                "content": "# Intuition\\nThe descriptions is leading us to use the **stack**, that follows LIFO-schema.\\n\\n---\\n\\nIf you don\\'t familiar with **stack**, lets have a look at [wiki page about stack description](https://en.wikipedia.org/wiki/Stack_(abstract_data_type)).\\n\\n# Approach\\n1. create `stack` variable, that\\'ll be store all of the elelement, that aren\\'t in this list `folders = [\\'./\\', \\'../\\']`\\n2. iterate over all `logs` and check, if log contains `../`, it\\'s time to **back to the parent folder**, if it\\'s `./`, than do **NOTHING**, otherwise save this dir inside of a stack.\\n3. be sure NOT to **pop from an empty stack, that causes an IndexError**\\n4. **finally check HOW** many dirs are in the stack\\n\\n# Complexity\\n- Time complexity: **O(n)** because of iterating `logs`\\n\\n- Space complexity: **O(n)**, in the worst case, if the folders aren\\'t that list of `folders`\\n\\n# Code\\n```\\nclass Solution:\\n    def minOperations(self, logs: List[str]) -> int:\\n        stack = []\\n\\n        for log in logs:\\n            if log.startswith(\\'../\\'):\\n                if stack:\\n                    stack.pop()\\n            elif log.startswith(\\'./\\'):\\n                continue\\n            else:\\n                stack.append(log)\\n\\n        return len(stack)\\n```",
                "solutionTags": [
                    "Python3",
                    "Stack"
                ],
                "code": "```\\nclass Solution:\\n    def minOperations(self, logs: List[str]) -> int:\\n        stack = []\\n\\n        for log in logs:\\n            if log.startswith(\\'../\\'):\\n                if stack:\\n                    stack.pop()\\n            elif log.startswith(\\'./\\'):\\n                continue\\n            else:\\n                stack.append(log)\\n\\n        return len(stack)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3882917,
                "title": "no-stack-c-only-5-lines-o-n-beast-95",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nApproach is Very Simple Just **Count** the Number of **Folders** after all the **Operations**.\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minOperations(vector<string>& logs) {\\n        int ans = 0;\\n        for(int i = 0;i<logs.size();i++)\\n        {\\n            if(logs[i]==\"../\" && ans>0) ans-=1;\\n            else if(logs[i]!=\"../\" && logs[i]!=\"./\") ans+=1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<string>& logs) {\\n        int ans = 0;\\n        for(int i = 0;i<logs.size();i++)\\n        {\\n            if(logs[i]==\"../\" && ans>0) ans-=1;\\n            else if(logs[i]!=\"../\" && logs[i]!=\"./\") ans+=1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3585614,
                "title": "easy-shit-solution-with-comments-beats-92",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\npublic class Solution {\\n    public int MinOperations(string[] logs)\\n    {\\n        List<string> result = new List<string>();\\n        foreach (var item in logs)\\n        {\\n            if (item.Contains(\\'.\\'))\\n            {\\n                if(item.Length - item.Replace(\".\", \"\").Length == 2) \\n                    if(result.Count != 0)\\n                        result.RemoveAt(result.Count - 1);\\n            }\\n            else\\n            {\\n                result.Add(item);\\n            }\\n        }\\n        return result.Count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int MinOperations(string[] logs)\\n    {\\n        List<string> result = new List<string>();\\n        foreach (var item in logs)\\n        {\\n            if (item.Contains(\\'.\\'))\\n            {\\n                if(item.Length - item.Replace(\".\", \"\").Length == 2) \\n                    if(result.Count != 0)\\n                        result.RemoveAt(result.Count - 1);\\n            }\\n            else\\n            {\\n                result.Add(item);\\n            }\\n        }\\n        return result.Count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3447741,
                "title": "c-solution-stack",
                "content": "```\\nint minOperations(vector<string>& logs) {\\n\\tstack<string> st;\\n\\tfor (const string& s : logs) {\\n\\t\\tif (s == \"../\") {\\n\\t\\t\\tif (!st.empty())\\n\\t\\t\\t\\tst.pop();\\n\\t\\t}\\n\\t\\telse if (s != \"./\")\\n\\t\\t\\tst.push(s);\\n\\t}\\n\\treturn st.size();\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Stack"
                ],
                "code": "```\\nint minOperations(vector<string>& logs) {\\n\\tstack<string> st;\\n\\tfor (const string& s : logs) {\\n\\t\\tif (s == \"../\") {\\n\\t\\t\\tif (!st.empty())\\n\\t\\t\\t\\tst.pop();\\n\\t\\t}\\n\\t\\telse if (s != \"./\")\\n\\t\\t\\tst.push(s);\\n\\t}\\n\\treturn st.size();\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3364041,
                "title": "js-very-easy-solution",
                "content": "# Code\\n```\\n/**\\n * @param {string[]} logs\\n * @return {number}\\n */\\nvar minOperations = function(logs) {\\n    let step = 0;\\n\\n    for (let i = 0; i < logs.length; i++) {\\n        const log = logs[i];\\n        if (log === \\'../\\') {\\n            if (step > 0) step--;\\n        } else if (log !== \\'./\\') {\\n            step++;\\n        }\\n    }\\n\\n    return step;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string[]} logs\\n * @return {number}\\n */\\nvar minOperations = function(logs) {\\n    let step = 0;\\n\\n    for (let i = 0; i < logs.length; i++) {\\n        const log = logs[i];\\n        if (log === \\'../\\') {\\n            if (step > 0) step--;\\n        } else if (log !== \\'./\\') {\\n            step++;\\n        }\\n    }\\n\\n    return step;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3328986,
                "title": "php-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n\\n    /**\\n     * @param String[] $logs\\n     * @return Integer\\n     */\\n    function minOperations($logs) {\\n        $count = 0;\\n        foreach($logs as $log) {\\n            if ($log == \\'../\\'){\\n                if ($count == 0) {\\n                    $count;\\n                } else {\\n                    $count -= 1;\\n                }\\n            } else if($log == \\'./\\'){\\n                $count;\\n            } else {\\n                $count += 1;\\n            }\\n        }\\n\\n        return $count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "PHP"
                ],
                "code": "```\\nclass Solution {\\n\\n    /**\\n     * @param String[] $logs\\n     * @return Integer\\n     */\\n    function minOperations($logs) {\\n        $count = 0;\\n        foreach($logs as $log) {\\n            if ($log == \\'../\\'){\\n                if ($count == 0) {\\n                    $count;\\n                } else {\\n                    $count -= 1;\\n                }\\n            } else if($log == \\'./\\'){\\n                $count;\\n            } else {\\n                $count += 1;\\n            }\\n        }\\n\\n        return $count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3289154,
                "title": "very-simple-self-explanatory-stack-based-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n# Code\\n```\\nclass Solution:\\n    def minOperations(self, logs: List[str]) -> int:\\n        stack = [] \\n        for lg in logs:\\n            if lg != \\'./\\':\\n                if lg != \\'../\\':\\n                    stack.append(lg)\\n                else:\\n                    if stack:\\n                        stack.pop()\\n        return len(stack)\\n\\n\\n\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minOperations(self, logs: List[str]) -> int:\\n        stack = [] \\n        for lg in logs:\\n            if lg != \\'./\\':\\n                if lg != \\'../\\':\\n                    stack.append(lg)\\n                else:\\n                    if stack:\\n                        stack.pop()\\n        return len(stack)\\n\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3240762,
                "title": "simple-python-code",
                "content": "# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def minOperations(self, logs: List[str]) -> int:\\n        stack = []\\n        for log in logs:\\n            if log == \"./\":\\n                continue\\n            elif log == \"../\":\\n                if stack:\\n                    stack.pop()\\n            else:\\n                stack.append(log)\\n        return len(stack)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minOperations(self, logs: List[str]) -> int:\\n        stack = []\\n        for log in logs:\\n            if log == \"./\":\\n                continue\\n            elif log == \"../\":\\n                if stack:\\n                    stack.pop()\\n            else:\\n                stack.append(log)\\n        return len(stack)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3227317,
                "title": "solved-using-stacks-with-o-n",
                "content": "# Intuition\\nI see I need to store past elements.So stack can do it\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n If else condition is used rather than while Because I just need to pop only 1 thing after comparision. \\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {string[]} logs\\n * @return {number}\\n */\\nvar minOperations = function(logs) {\\n    let stack=[]\\n    for(let i=0;i<logs.length;i++){\\n        if(stack.length!==0 && logs[i]===\\'../\\'){\\n            stack.pop()\\n        }else if(logs[i]===\\'./\\'){\\n            continue;\\n        }else if(logs[i]!==\\'../\\'){\\n            stack.push(logs[i])\\n        }\\n    }\\n    return stack.length\\n       \\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string[]} logs\\n * @return {number}\\n */\\nvar minOperations = function(logs) {\\n    let stack=[]\\n    for(let i=0;i<logs.length;i++){\\n        if(stack.length!==0 && logs[i]===\\'../\\'){\\n            stack.pop()\\n        }else if(logs[i]===\\'./\\'){\\n            continue;\\n        }else if(logs[i]!==\\'../\\'){\\n            stack.push(logs[i])\\n        }\\n    }\\n    return stack.length\\n       \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3012115,
                "title": "easy-to-understand-beat-100-and-runtime-is-1ms-using-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minOperations(String[] log) {\\n      int count=0;\\n        for(int i=0; i<log.length; i++)\\n        {\\n            \\n            if(!log[i].equals(\"./\") && !log[i].equals(\"../\"))\\n            {\\n                count++;\\n            }\\n            else if(log[i].equals(\"./\"))\\n            {\\n                continue;\\n            }\\n            else\\n            {\\n                if(count!=0)\\n                {\\n                count--;\\n                }\\n            }\\n        }\\n        if(count<=0)\\n        {\\n            return 0;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public int minOperations(String[] log) {\\n      int count=0;\\n        for(int i=0; i<log.length; i++)\\n        {\\n            \\n            if(!log[i].equals(\"./\") && !log[i].equals(\"../\"))\\n            {\\n                count++;\\n            }\\n            else if(log[i].equals(\"./\"))\\n            {\\n                continue;\\n            }\\n            else\\n            {\\n                if(count!=0)\\n                {\\n                count--;\\n                }\\n            }\\n        }\\n        if(count<=0)\\n        {\\n            return 0;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2965693,
                "title": "easiest-c-approach-1ms-time",
                "content": "# Intuition\\nEasy c++ approach\\n\\n# Approach\\ncount the number of directoires else return back\\n\\n# Complexity\\n- Time complexity: O(n)\\n\\n- Space complexity: O(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minOperations(vector<string>& logs) {\\n        int n=logs.size();\\n        int c=0;\\n        for(int i=0;i<n;i++){\\n            if(logs[i] == \"./\")\\n                continue;\\n            if(logs[i] == \"../\")\\n                    c--;\\n            else\\n                c++;\\n            if(c<0)\\n                c=0;\\n        }\\n        return c;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<string>& logs) {\\n        int n=logs.size();\\n        int c=0;\\n        for(int i=0;i<n;i++){\\n            if(logs[i] == \"./\")\\n                continue;\\n            if(logs[i] == \"../\")\\n                    c--;\\n            else\\n                c++;\\n            if(c<0)\\n                c=0;\\n        }\\n        return c;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2925804,
                "title": "3-ms-no-stack-c",
                "content": "\\n\\n## Approach 1 : O(1) Space\\n<!-- Describe your approach to solving the problem. -->\\n\\n```\\nclass Solution \\n{\\npublic:\\n    int minOperations(vector<string>& logs) \\n    {\\n        int ans=0;\\n        for(string &it:logs)\\n        {\\n            if(it[it.size()-2]!=\\'.\\')\\n               ans++;\\n            else if(it==\"../\")\\n               ans=(ans==0)?0:ans-1;\\n        }\\n        return ans;\\n    }\\n};\\n```\\n## Approach 2 : Stack\\n``` \\nclass Solution \\n{\\npublic:\\n    int minOperations(vector<string>& logs) \\n    {\\n        stack<string>st;\\n        for(string &it:logs)\\n        {\\n            if(!st.empty() && it==\"../\")\\n                st.pop();\\n            else if(it[it.size()-2]!=\\'.\\')\\n                st.push(it);\\n        }\\n        return st.size();\\n    }\\n};\\n```       \\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution \\n{\\npublic:\\n    int minOperations(vector<string>& logs) \\n    {\\n        int ans=0;\\n        for(string &it:logs)\\n        {\\n            if(it[it.size()-2]!=\\'.\\')\\n               ans++;\\n            else if(it==\"../\")\\n               ans=(ans==0)?0:ans-1;\\n        }\\n        return ans;\\n    }\\n};\\n```\n``` \\nclass Solution \\n{\\npublic:\\n    int minOperations(vector<string>& logs) \\n    {\\n        stack<string>st;\\n        for(string &it:logs)\\n        {\\n            if(!st.empty() && it==\"../\")\\n                st.pop();\\n            else if(it[it.size()-2]!=\\'.\\')\\n                st.push(it);\\n        }\\n        return st.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2707580,
                "title": "rust-fold-0ms",
                "content": "```\\nimpl Solution {\\n    pub fn min_operations(logs: Vec<String>) -> i32 {\\n        logs.iter()\\n            .fold(0, |dep, op| {\\n                match op.as_str() {\\n                    // decrease depth (stop at zero)\\n                    \"../\" => {\\n                        match dep {\\n                            0 => dep,\\n                            _ => dep - 1,\\n                        }\\n                    }\\n                    \"./\" => dep, // no change\\n                    _ => dep + 1,  // increase depth\\n                }\\n             })\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn min_operations(logs: Vec<String>) -> i32 {\\n        logs.iter()\\n            .fold(0, |dep, op| {\\n                match op.as_str() {\\n                    // decrease depth (stop at zero)\\n                    \"../\" => {\\n                        match dep {\\n                            0 => dep,\\n                            _ => dep - 1,\\n                        }\\n                    }\\n                    \"./\" => dep, // no change\\n                    _ => dep + 1,  // increase depth\\n                }\\n             })\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2688322,
                "title": "python-super-easy-no-stack",
                "content": "```py\\nclass Solution:\\n    def minOperations(self, logs: List[str]) -> int:\\n        ans = 0\\n        \\n        for i in logs:\\n            if i[0] == \".\" and i[1] == \".\":\\n                ans -=1\\n                if ans < 0:\\n                    ans = 0\\n            elif i[0] == \".\" and i[1] == \"/\":\\n                continue\\n            else:\\n                ans +=1\\n        return ans```",
                "solutionTags": [],
                "code": "```py\\nclass Solution:\\n    def minOperations(self, logs: List[str]) -> int:\\n        ans = 0\\n        \\n        for i in logs:\\n            if i[0] == \".\" and i[1] == \".\":\\n                ans -=1\\n                if ans < 0:\\n                    ans = 0\\n            elif i[0] == \".\" and i[1] == \"/\":\\n                continue\\n            else:\\n                ans +=1\\n        return ans```",
                "codeTag": "Java"
            },
            {
                "id": 2545524,
                "title": "java-easy-solution-99-75-fast",
                "content": "```\\nclass Solution {\\n    public int minOperations(String[] logs) {\\n        int c=0;\\n        for(int i=0;i<logs.length;i++)\\n        {\\n            \\n            if(logs[i].equals(\"../\")==true)c-=1;\\n            else if(logs[i].equals(\"./\")==true)continue;\\n            else c+=1;\\n            if(c<=0)c=0;\\n        }\\n        if(c<=0)return 0;\\n        else return c;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minOperations(String[] logs) {\\n        int c=0;\\n        for(int i=0;i<logs.length;i++)\\n        {\\n            \\n            if(logs[i].equals(\"../\")==true)c-=1;\\n            else if(logs[i].equals(\"./\")==true)continue;\\n            else c+=1;\\n            if(c<=0)c=0;\\n        }\\n        if(c<=0)return 0;\\n        else return c;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2504472,
                "title": "java-easy-solution-by-count-variable",
                "content": "```\\nclass Solution {\\n    public int minOperations(String[] logs) {\\n        int count=0;\\n        for(int i=0;i<logs.length;i++){\\n            if(logs[i].equals(\"../\") && count>0)\\n                count--;\\n            else if(logs[i].equals(\"../\"))\\n                continue;\\n            else if(!logs[i].equals(\"./\"))\\n                count++;\\n        }\\n        return count;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public int minOperations(String[] logs) {\\n        int count=0;\\n        for(int i=0;i<logs.length;i++){\\n            if(logs[i].equals(\"../\") && count>0)\\n                count--;\\n            else if(logs[i].equals(\"../\"))\\n                continue;\\n            else if(!logs[i].equals(\"./\"))\\n                count++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2464513,
                "title": "stack-java-simple-solution-2ms",
                "content": "```\\nclass Solution {\\n    public int minOperations(String[] logs) {\\n      Stack<String> stack=new Stack<>();\\n      int max=Integer.MIN_VALUE;\\n      for(int i=0;i<logs.length;i++)\\n      {\\n        if(!stack.isEmpty() && logs[i].equals(\"../\"))\\n          stack.pop();\\n        else if(!logs[i].equals(\"./\") && !logs[i].equals(\"../\"))\\n          stack.push(logs[i]); \\n      } \\n      return stack.size();\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\n    public int minOperations(String[] logs) {\\n      Stack<String> stack=new Stack<>();\\n      int max=Integer.MIN_VALUE;\\n      for(int i=0;i<logs.length;i++)\\n      {\\n        if(!stack.isEmpty() && logs[i].equals(\"../\"))\\n          stack.pop();\\n        else if(!logs[i].equals(\"./\") && !logs[i].equals(\"../\"))\\n          stack.push(logs[i]); \\n      } \\n      return stack.size();\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2407966,
                "title": "c",
                "content": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<string>& logs) {\\n        int count=0;\\n        for(auto x:logs){\\n            if(x==\"../\") count==0?0:count--;\\n            else if(x==\"./\") continue;\\n            else count++;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<string>& logs) {\\n        int count=0;\\n        for(auto x:logs){\\n            if(x==\"../\") count==0?0:count--;\\n            else if(x==\"./\") continue;\\n            else count++;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2312308,
                "title": "very-easy-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<string>& logs) {\\n        stack<string> str;\\n        for(int i=0;i<logs.size();i++){\\n            if(logs[i] == \"./\"){\\n                continue;\\n            }\\n            else if(logs[i] == \"../\"){\\n                if(str.empty()){\\n                    continue;\\n                }\\n                str.pop();\\n            }\\n            else{\\n                str.push(logs[i]);\\n            }\\n        }\\n        return str.size();\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<string>& logs) {\\n        stack<string> str;\\n        for(int i=0;i<logs.size();i++){\\n            if(logs[i] == \"./\"){\\n                continue;\\n            }\\n            else if(logs[i] == \"../\"){\\n                if(str.empty()){\\n                    continue;\\n                }\\n                str.pop();\\n            }\\n            else{\\n                str.push(logs[i]);\\n            }\\n        }\\n        return str.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2284266,
                "title": "java-2-methods-explained",
                "content": "**Method 1:** Stack\\n* Let there be a stack indicating current state of directory. Moving inside a directory will be a push, and moving out will be push\\n* If log is alphanumeric, then push the log \\n* Else if log is `../` and stack is not empty, pop from stack, since you\\'re moving out from the current directory\\n* Else log is `./` and nothing needs to be done\\n* At the end, the size of stack will indicate how deep we are in the directory\\n>**T/S:** O(n)/O(n), where n = size(logs)\\n```\\npublic int minOperations(String[] logs) {\\n\\tvar stack = new ArrayDeque<String>();\\n\\t\\n\\tfor (var log : logs)\\n\\t\\tif (Character.isAlphabetic(log.charAt(0)) || Character.isDigit(log.charAt(0)))\\n\\t\\t\\tstack.push(log);\\n\\t\\telse if (!stack.isEmpty() && log.charAt(1) == \\'.\\')\\n\\t\\t\\tstack.pop();\\n\\treturn stack.size();\\n}\\n```\\n**Method 2:** Space optimized version of method 1\\n* Notice that stack\\'s elements aren\\'t being used themselves, only push/pop/size are being used. \\n* This means we can replace the stack with a count variable and return that at the end\\n>**T/S:** O(n)/O(1)\\n```\\npublic int minOperations(String[] logs) {\\n\\tvar ops = 0;\\n\\t\\n\\tfor (var log : logs) \\n\\t\\tif (Character.isAlphabetic(log.charAt(0)) || Character.isDigit(log.charAt(0)))\\n\\t\\t\\tops++;\\n\\t\\telse if (ops > 0 && log.charAt(1) == \\'.\\')\\n\\t\\t\\tops--;\\n\\treturn ops;\\n}\\n```\\n***Please upvote if this helps***",
                "solutionTags": [
                    "Java",
                    "Stack"
                ],
                "code": "```\\npublic int minOperations(String[] logs) {\\n\\tvar stack = new ArrayDeque<String>();\\n\\t\\n\\tfor (var log : logs)\\n\\t\\tif (Character.isAlphabetic(log.charAt(0)) || Character.isDigit(log.charAt(0)))\\n\\t\\t\\tstack.push(log);\\n\\t\\telse if (!stack.isEmpty() && log.charAt(1) == \\'.\\')\\n\\t\\t\\tstack.pop();\\n\\treturn stack.size();\\n}\\n```\n```\\npublic int minOperations(String[] logs) {\\n\\tvar ops = 0;\\n\\t\\n\\tfor (var log : logs) \\n\\t\\tif (Character.isAlphabetic(log.charAt(0)) || Character.isDigit(log.charAt(0)))\\n\\t\\t\\tops++;\\n\\t\\telse if (ops > 0 && log.charAt(1) == \\'.\\')\\n\\t\\t\\tops--;\\n\\treturn ops;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2273108,
                "title": "c-stack-easy-code",
                "content": "Please Upvote :)\\n\\n```\\nclass Solution {\\npublic:\\n    int minOperations(vector<string>& logs) {\\n        stack<string> s;\\n        \\n        for(auto x:logs)\\n        {\\n            if(x==\"../\")\\n            {\\n                if(!s.empty())\\n                    s.pop();// child removed if exist\\n            }\\n            else if(x!=\"./\")\\n                s.push(\"+\");// new child added.\\n        }\\n        return s.size();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<string>& logs) {\\n        stack<string> s;\\n        \\n        for(auto x:logs)\\n        {\\n            if(x==\"../\")\\n            {\\n                if(!s.empty())\\n                    s.pop();// child removed if exist\\n            }\\n            else if(x!=\"./\")\\n                s.push(\"+\");// new child added.\\n        }\\n        return s.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2189303,
                "title": "java",
                "content": "```\\nclass Solution {\\n    public int minOperations(String[] logs) {\\n        int count = 0;\\n        \\n        for(int i = 0; i < logs.length; i++){\\n            if(logs[i].equals(\"./\")){\\n                continue;\\n            }\\n            else if(logs[i].equals(\"../\") ){\\n                if(count > 0){\\n                    count--;\\n                }\\n                \\n            }\\n            else{\\n                count++;\\n            }\\n        }\\n        \\n        return count;\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minOperations(String[] logs) {\\n        int count = 0;\\n        \\n        for(int i = 0; i < logs.length; i++){\\n            if(logs[i].equals(\"./\")){\\n                continue;\\n            }\\n            else if(logs[i].equals(\"../\") ){\\n                if(count > 0){\\n                    count--;\\n                }\\n                \\n            }\\n            else{\\n                count++;\\n            }\\n        }\\n        \\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2186704,
                "title": "java-easy-solution-100",
                "content": "```\\nclass Solution {\\n    public int minOperations(String[] logs) {\\n        int count=0;\\n        for(int i=0;i<logs.length;i++){\\n            \\n            if(logs[i].equals(\"../\")){\\n                count--;\\n            }else if(logs[i].equals(\"./\")){\\n                count=count;\\n            }else{\\n                count++;\\n            }\\n            if(count<0) count=0;\\n        }\\n       \\n        return count;\\n    }\\n}\\n```\\n**Please UPVOTE  you understand my code and comment your best approach**",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minOperations(String[] logs) {\\n        int count=0;\\n        for(int i=0;i<logs.length;i++){\\n            \\n            if(logs[i].equals(\"../\")){\\n                count--;\\n            }else if(logs[i].equals(\"./\")){\\n                count=count;\\n            }else{\\n                count++;\\n            }\\n            if(count<0) count=0;\\n        }\\n       \\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2137723,
                "title": "python3",
                "content": "```\\nclass Solution:\\n    def minOperations(self, logs: List[str]) -> int:\\n        c=0\\n        for i in range(len(logs)):\\n            if  logs[i]==\\'../\\' and c>0:\\n                c-=1\\n            elif logs[i]!=\\'../\\' and logs[i]!=\\'./\\' :\\n                c+=1\\n        return c\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minOperations(self, logs: List[str]) -> int:\\n        c=0\\n        for i in range(len(logs)):\\n            if  logs[i]==\\'../\\' and c>0:\\n                c-=1\\n            elif logs[i]!=\\'../\\' and logs[i]!=\\'./\\' :\\n                c+=1\\n        return c\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2107090,
                "title": "java-easy-faster-than-97",
                "content": "```\\npublic int minOperations(String[] s) {\\n        int res=0;\\n        for(String c:s){\\n            if(c.equals(\"../\")){\\n                res=Math.max(0,--res);\\n                \\n            }\\n            else if(c.equals(\"./\")){\\n                continue;\\n            }\\n            else{\\n                res++;\\n            }\\n        }\\n        return res;\\n        \\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic int minOperations(String[] s) {\\n        int res=0;\\n        for(String c:s){\\n            if(c.equals(\"../\")){\\n                res=Math.max(0,--res);\\n                \\n            }\\n            else if(c.equals(\"./\")){\\n                continue;\\n            }\\n            else{\\n                res++;\\n            }\\n        }\\n        return res;\\n        \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2022176,
                "title": "crawler-log-folder-python3-solution",
                "content": "```\\ndef minOperations(self, logs: List[str]) -> int:\\n\\tstack =[]\\n\\tfor i in range(len(logs)):\\n\\t\\tif logs[i] ==\"../\":\\n\\t\\t\\tif stack !=[]:\\n\\t\\t\\t\\tstack.pop()\\n\\t\\telif logs[i] ==\"./\":\\n\\t\\t\\tcontinue\\n\\t\\telse:\\n\\t\\t\\tstack.append(logs[i])\\n\\treturn len(stack)",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Stack"
                ],
                "code": "```\\ndef minOperations(self, logs: List[str]) -> int:\\n\\tstack =[]\\n\\tfor i in range(len(logs)):\\n\\t\\tif logs[i] ==\"../\":\\n\\t\\t\\tif stack !=[]:\\n\\t\\t\\t\\tstack.pop()\\n\\t\\telif logs[i] ==\"./\":\\n\\t\\t\\tcontinue\\n\\t\\telse:\\n\\t\\t\\tstack.append(logs[i])\\n\\treturn len(stack)",
                "codeTag": "Python3"
            },
            {
                "id": 2003637,
                "title": "python-easy-and-smart-solution-o-1-space-72ms",
                "content": "```\\n# var for counting directories or depth \\ndirs = 0\\nfor i in logs:\\n\\tif i == \"../\":\\n\\t    # if there is any folder present then remove it and \\n\\t\\t# if no folder present i.e. dirs = 0 then no need to do anything, \\n\\t\\t# you are already in root directory\\n\\t\\tif dirs != 0:\\n\\t\\t\\tdirs -= 1\\n\\t# you have to remain in same directory hence no increment in dirs ..i.e. depth remains same\\n\\telif i == \"./\":\\n\\t\\tcontinue\\n\\telse:\\n\\t# increase the dirs count with 1. because a new directory is encountered and \\n\\t# depth of dirs is increased\\n\\t#   root / a / b / c / d     --- > depth = 4\\n\\t# so if you see everytime we encounter a new directory our depth increases.\\n\\t\\tdirs += 1\\n\\t\\t\\n# if directories left then return count of them \\nif dirs > 0:\\n\\treturn dirs\\n# else if there are 0 directories then return 0\\nelse:\\n\\treturn 0\\n```\\nPlease **UPVOTE** if you liked the solution and do consider a follow.",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\n# var for counting directories or depth \\ndirs = 0\\nfor i in logs:\\n\\tif i == \"../\":\\n\\t    # if there is any folder present then remove it and \\n\\t\\t# if no folder present i.e. dirs = 0 then no need to do anything, \\n\\t\\t# you are already in root directory\\n\\t\\tif dirs != 0:\\n\\t\\t\\tdirs -= 1\\n\\t# you have to remain in same directory hence no increment in dirs ..i.e. depth remains same\\n\\telif i == \"./\":\\n\\t\\tcontinue\\n\\telse:\\n\\t# increase the dirs count with 1. because a new directory is encountered and \\n\\t# depth of dirs is increased\\n\\t#   root / a / b / c / d     --- > depth = 4\\n\\t# so if you see everytime we encounter a new directory our depth increases.\\n\\t\\tdirs += 1\\n\\t\\t\\n# if directories left then return count of them \\nif dirs > 0:\\n\\treturn dirs\\n# else if there are 0 directories then return 0\\nelse:\\n\\treturn 0\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1997483,
                "title": "c-simple-o-n",
                "content": "Just check for ../ and ./ and rest will be in else block.\\n\\n```\\nclass Solution {\\npublic:\\n    int minOperations(vector<string>& logs) {\\n        int len = logs.size();\\n        int ans = 0;\\n        \\n        for(int i=0; i<len; i++) {\\n            if(logs[i]==\"../\")\\n            {\\n                ans--;\\n                ans<0?ans=0:ans=ans;\\n            }\\n            else if(logs[i]==\"./\") continue;\\n            else{\\n                ans++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<string>& logs) {\\n        int len = logs.size();\\n        int ans = 0;\\n        \\n        for(int i=0; i<len; i++) {\\n            if(logs[i]==\"../\")\\n            {\\n                ans--;\\n                ans<0?ans=0:ans=ans;\\n            }\\n            else if(logs[i]==\"./\") continue;\\n            else{\\n                ans++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1997356,
                "title": "python-and-c-o-1-space",
                "content": "We are guaranteed that every folder will exist when called, so we don\\'t need to worry at all about that.\\n* If `log` is `\"../\"` we\\'ll go back up once (if we can)\\n* If `log` is not `\"../\"` we\\'ll go down once only if we are seeing a folder name, i.e. `log` is not `\"./\"`\\n\\n<hr>\\n\\n# Python solution\\n```\\nclass Solution:\\n    def minOperations(self, logs: List[str]) -> int:\\n        depth = 0\\n        \\n        for log in logs:\\n            if log == \"../\":\\n                if depth > 0:\\n                    depth -= 1\\n            elif log != \"./\":\\n                depth += 1\\n                \\n        return depth\\n```\\n\\n# C++ solution\\n```\\nclass Solution {\\npublic:\\n    int minOperations(vector<string>& logs) {\\n        \\n        int depth = 0;\\n        \\n        for(auto log: logs){\\n            if(log == \"../\"){\\n                if(depth > 0){\\n                    depth--;\\n                }\\n            }\\n            else if(log != \"./\"){\\n                depth++;\\n            }\\n        }\\n        \\n        return depth;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Python",
                    "C"
                ],
                "code": "```\\nclass Solution:\\n    def minOperations(self, logs: List[str]) -> int:\\n        depth = 0\\n        \\n        for log in logs:\\n            if log == \"../\":\\n                if depth > 0:\\n                    depth -= 1\\n            elif log != \"./\":\\n                depth += 1\\n                \\n        return depth\\n```\n```\\nclass Solution {\\npublic:\\n    int minOperations(vector<string>& logs) {\\n        \\n        int depth = 0;\\n        \\n        for(auto log: logs){\\n            if(log == \"../\"){\\n                if(depth > 0){\\n                    depth--;\\n                }\\n            }\\n            else if(log != \"./\"){\\n                depth++;\\n            }\\n        }\\n        \\n        return depth;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1997227,
                "title": "easy-stack-solution-simple-stack",
                "content": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<string>& l) {\\n     stack<string> st;\\n     for(int i=0;i<l.size();i++){\\n         if(l[i]==\"./\"){\\n             continue;\\n         }else if(l[i]==\"../\"){\\n             if(st.size())\\n             st.pop();\\n         }else{\\n             st.push(l[i]);\\n         }\\n     }\\n            return st.size();\\n     \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<string>& l) {\\n     stack<string> st;\\n     for(int i=0;i<l.size();i++){\\n         if(l[i]==\"./\"){\\n             continue;\\n         }else if(l[i]==\"../\"){\\n             if(st.size())\\n             st.pop();\\n         }else{\\n             st.push(l[i]);\\n         }\\n     }\\n            return st.size();\\n     \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1965420,
                "title": "javascript",
                "content": "```\\nvar minOperations = function(logs) {\\n    let count = 0;\\n    for(i=0;i<logs.length;i++){\\n        if(logs[i] === \\'../\\') {\\n            if(count > 0)  count = count - 1;\\n            continue\\n        }\\n        if(logs[i] === \\'./\\') continue;\\n        else count = count + 1;\\n    }\\n    return count\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar minOperations = function(logs) {\\n    let count = 0;\\n    for(i=0;i<logs.length;i++){\\n        if(logs[i] === \\'../\\') {\\n            if(count > 0)  count = count - 1;\\n            continue\\n        }\\n        if(logs[i] === \\'./\\') continue;\\n        else count = count + 1;\\n    }\\n    return count\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1943551,
                "title": "easiest-solution-without-using-stack",
                "content": "```\\n/**\\n * @param {string[]} logs\\n * @return {number}\\n */\\nvar minOperations = function(logs) {\\n    let s = 0;\\n    \\n    logs.forEach(step => {\\n        if(step === \\'../\\') s = Math.max(0, --s);\\n        else if(step !== \\'./\\') s++;\\n    });\\n    \\n    return s;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string[]} logs\\n * @return {number}\\n */\\nvar minOperations = function(logs) {\\n    let s = 0;\\n    \\n    logs.forEach(step => {\\n        if(step === \\'../\\') s = Math.max(0, --s);\\n        else if(step !== \\'./\\') s++;\\n    });\\n    \\n    return s;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1933398,
                "title": "java-easy-1ms-solution",
                "content": "```\\nclass Solution {\\n    public int minOperations(String[] logs) {\\n        List<String> l = new ArrayList();\\n        \\n        for(int i=0;i<=logs.length-1;i++){\\n            if(logs[i].equals(\"../\")){\\n                if(l.size()-1>0)\\n                l.remove(l.size()-1);\\n                else l.clear();\\n            }else if (logs[i].equals(\"./\")){\\n                continue;\\n            }else{\\n                l.add(logs[i]);\\n            }\\n        }\\n        return l.size();\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int minOperations(String[] logs) {\\n        List<String> l = new ArrayList();\\n        \\n        for(int i=0;i<=logs.length-1;i++){\\n            if(logs[i].equals(\"../\")){\\n                if(l.size()-1>0)\\n                l.remove(l.size()-1);\\n                else l.clear();\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1933326,
                "title": "c-two-approach-with-stack-without-stack-simple-clean-code",
                "content": "**C++ Approach :**\\n\\n**Approach 1 : Space - O(N)**\\n```\\n        stack<int> s;\\n        \\n        for(auto p:logs)\\n        {\\n            if(p==\"../\")\\n            {\\n                if(!s.empty())\\n                {\\n                    s.pop();\\n                }\\n            }\\n            else if(p==\"./\")\\n            {\\n                continue;\\n            }\\n            else\\n            {\\n                s.push(1);\\n            }\\n        }\\n        \\n        return s.size();\\n```\\n**Approach 2 : Space - O(1)**\\n```\\n\\t\\tint count=0;\\n        for(auto p:logs)\\n        {\\n            if(p==\"../\")\\n            {\\n                if(count>0)\\n                {\\n                    count--;\\n                }\\n            }\\n            else if(p==\"./\")\\n            {\\n                continue;\\n            }\\n            else\\n            {\\n                count++;\\n            }\\n        }\\n        \\n        return count;\\n```",
                "solutionTags": [
                    "C",
                    "Stack"
                ],
                "code": "```\\n        stack<int> s;\\n        \\n        for(auto p:logs)\\n        {\\n            if(p==\"../\")\\n            {\\n                if(!s.empty())\\n                {\\n                    s.pop();\\n                }\\n            }\\n            else if(p==\"./\")\\n            {\\n                continue;\\n            }\\n            else\\n            {\\n                s.push(1);\\n            }\\n        }\\n        \\n        return s.size();\\n```\n```\\n\\t\\tint count=0;\\n        for(auto p:logs)\\n        {\\n            if(p==\"../\")\\n            {\\n                if(count>0)\\n                {\\n                    count--;\\n                }\\n            }\\n            else if(p==\"./\")\\n            {\\n                continue;\\n            }\\n            else\\n            {\\n                count++;\\n            }\\n        }\\n        \\n        return count;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1932810,
                "title": "java-very-simple-solution-with-100-tc-and-97-space-complexity-solution",
                "content": "If \"../\" encountered return to the parent folder of that child\\nif \"./\" encountered then simply ignore and continue\\nif any other string encountered then simply goes to that file or increment the count\\n\\nAs easy as you thinks buddies ;)\\n\\n```\\nclass Solution {\\n    public int minOperations(String[] logs) {\\n        int res=0;\\n        for(int i=0;i<logs.length;i++){\\n            if(logs[i].equals(\"./\"))continue;\\n            else if(logs[i].equals(\"../\")){\\n                if(res>0)res--;\\n                continue;\\n            }\\n            else{\\n                res++;\\n            }\\n        }\\n        return res;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public int minOperations(String[] logs) {\\n        int res=0;\\n        for(int i=0;i<logs.length;i++){\\n            if(logs[i].equals(\"./\"))continue;\\n            else if(logs[i].equals(\"../\")){\\n                if(res>0)res--;\\n                continue;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1930803,
                "title": "java-solution-using-stack-faster-than-96-26",
                "content": "class Solution {\\n    public int minOperations(String[] logs) {\\n\\t\\n        Stack<String> stack = new Stack();\\n        \\n        for (String log: logs){\\n            \\n            if (log.equals(\"./\")){\\n                continue;\\n            }\\n           else if (log.equals(\"../\")){\\n                if (!stack.empty()){\\n                    stack.pop();\\n                }\\n            }\\n            else {\\n                 stack.push(\"a\");\\n            }\\n            \\n        }\\n        return stack.size();\\n    }\\n}\\n",
                "solutionTags": [
                    "Java",
                    "Stack"
                ],
                "code": "class Solution {\\n    public int minOperations(String[] logs) {\\n\\t\\n        Stack<String> stack = new Stack();\\n        \\n        for (String log: logs){\\n            \\n            if (log.equals(\"./\")){\\n                continue;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1903464,
                "title": "java-solution-using-stack-simplest-you-can-find",
                "content": "```\\nclass Solution {\\n    public int minOperations(String[] logs) {\\n       Stack<String> stack = new Stack<>();\\n       for(int i=0;i<logs.length;i++){\\n           if(stack.empty()&&(logs[i].contains(\"../\")||logs[i].contains(\"./\")))\\n               continue;\\n         if(logs[i].contains(\"../\"))\\n         {\\n             stack.pop();\\n         }\\n          else if(logs[i].contains(\"./\"))\\n          { \\n              stack.peek();\\n          }\\n           else stack.add(\"d\");\\n      }  \\n        return stack.size();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\n    public int minOperations(String[] logs) {\\n       Stack<String> stack = new Stack<>();\\n       for(int i=0;i<logs.length;i++){\\n           if(stack.empty()&&(logs[i].contains(\"../\")||logs[i].contains(\"./\")))\\n               continue;\\n         if(logs[i].contains(\"../\"))\\n         {\\n             stack.pop();\\n         }\\n          else if(logs[i].contains(\"./\"))\\n          { \\n              stack.peek();\\n          }\\n           else stack.add(\"d\");\\n      }  \\n        return stack.size();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1556542,
                "title": "short-code-0-n-and-0-1-c-easy-to-understand-100-faster-solution",
                "content": "int minOperations(vector<string>& logs) {\\n        \\n        int count=0;\\n        \\n        for(int i=0;i<logs.size();i++){\\n            if(logs[i]!=\"../\" and logs[i]!=\"./\")\\n                count++;\\n            \\n            else if(logs[i]==\"../\"){\\n                if(count>=2) count--;\\n                else count=0;\\n            }\\n            else\\n                continue;\\n            \\n        }\\n        \\n        \\n        \\n        return count;\\n    }",
                "solutionTags": [],
                "code": "int minOperations(vector<string>& logs) {\\n        \\n        int count=0;\\n        \\n        for(int i=0;i<logs.size();i++){\\n            if(logs[i]!=\"../\" and logs[i]!=\"./\")\\n                count++;\\n            \\n            else if(logs[i]==\"../\"){\\n                if(count>=2) count--;\\n                else count=0;\\n            }\\n            else\\n                continue;\\n            \\n        }\\n        \\n        \\n        \\n        return count;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1540186,
                "title": "easy-c-solution",
                "content": "```\\nclass Solution \\n{\\npublic:\\n    int minOperations(vector<string>& logs) \\n    {\\n        stack<string>stk;\\n        for(int i=0;i<logs.size();i++)\\n        {\\n            if(logs[i]!=\"../\" && logs[i]!=\"./\")\\n            {\\n                stk.push(logs[i]);\\n            }\\n            else if(logs[i]==\"../\" && !stk.empty())\\n            {\\n                stk.pop();\\n            }\\n        }\\n        return stk.size();\\n    }\\n};\\n```\\n***Please upvote if you have got any help from my code. Thank you.***",
                "solutionTags": [
                    "C",
                    "Stack"
                ],
                "code": "```\\nclass Solution \\n{\\npublic:\\n    int minOperations(vector<string>& logs) \\n    {\\n        stack<string>stk;\\n        for(int i=0;i<logs.size();i++)\\n        {\\n            if(logs[i]!=\"../\" && logs[i]!=\"./\")\\n            {\\n                stk.push(logs[i]);\\n            }\\n            else if(logs[i]==\"../\" && !stk.empty())\\n            {\\n                stk.pop();\\n            }\\n        }\\n        return stk.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1534807,
                "title": "c-90-fast-without-extra-space",
                "content": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<string>& logs) {\\n        int ans=0;\\n        for(int i=0; i<logs.size(); i++){\\n            string s=logs[i];\\n            if(s==\"../\") ans--;\\n            else if(s==\"./\") continue;\\n            else ans++;\\n            if(ans<0) ans=0;\\n        }\\n           return ans;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int minOperations(vector<string>& logs) {\\n        int ans=0;\\n        for(int i=0; i<logs.size(); i++){\\n            string s=logs[i];\\n            if(s==\"../\") ans--;\\n            else if(s==\"./\") continue;\\n            else ans++;\\n            if(ans<0) ans=0;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1534633,
                "title": "java-easy-solution",
                "content": "```\\nclass Solution {\\n    public int minOperations(String[] logs) {\\n        int count=0;\\n        for(String temp:logs){\\n            if(temp.substring(0,2).equals(\"..\"))\\n                count=(count-1)<0?0:(count-1);\\n            else if(!temp.substring(0,2).equals(\"./\"))\\n                count++;\\n        }\\n        return count;\\n        \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minOperations(String[] logs) {\\n        int count=0;\\n        for(String temp:logs){\\n            if(temp.substring(0,2).equals(\"..\"))\\n                count=(count-1)<0?0:(count-1);\\n            else if(!temp.substring(0,2).equals(\"./\"))\\n                count++;\\n        }\\n        return count;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1373644,
                "title": "c-simpe-string",
                "content": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<string>& logs) {\\n        int count=0;\\n        for(int i=0;i<logs.size();i++){\\n            if(logs[i]==\"./\"){\\n                count=count;\\n            }else if(logs[i]==\"../\"){\\n                if(count>0){\\n                    count--;\\n                }\\n            }else{\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    int minOperations(vector<string>& logs) {\\n        int count=0;\\n        for(int i=0;i<logs.size();i++){\\n            if(logs[i]==\"./\"){\\n                count=count;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1366348,
                "title": "simple-java-100",
                "content": "```\\npublic int minOperations(String[] logs) {\\n        int depth = 0;\\n        for (String s : logs) {\\n            depth -= s.charAt(0) == \\'.\\' ? depth == 0 || s.charAt(1) == \\'/\\' ? 0 : 1 : -1;\\n        }\\n        return depth;\\n    }\\n```\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic int minOperations(String[] logs) {\\n        int depth = 0;\\n        for (String s : logs) {\\n            depth -= s.charAt(0) == \\'.\\' ? depth == 0 || s.charAt(1) == \\'/\\' ? 0 : 1 : -1;\\n        }\\n        return depth;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1291927,
                "title": "easy-python-solution-93-94",
                "content": "Runtime: 40 ms, faster than 93.94% of Python3 online submissions for Crawler Log Folder.\\nMemory Usage: 14.5 MB, less than 22.91% of Python3 online submissions for Crawler Log Folder.\\n```\\nclass Solution:\\n    def minOperations(self, logs: List[str]) -> int:\\n        stack=[]\\n        for i in logs:\\n            if(i==\\'../\\' and stack):\\n                stack.pop()\\n            elif(i==\\'./\\'):\\n                continue\\n            elif(i!=\\'../\\' ):\\n                stack.append(i)\\n        return len(stack)",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "Runtime: 40 ms, faster than 93.94% of Python3 online submissions for Crawler Log Folder.\\nMemory Usage: 14.5 MB, less than 22.91% of Python3 online submissions for Crawler Log Folder.\\n```\\nclass Solution:\\n    def minOperations(self, logs: List[str]) -> int:\\n        stack=[]\\n        for i in logs:\\n            if(i==\\'../\\' and stack):\\n                stack.pop()\\n            elif(i==\\'./\\'):\\n                continue\\n            elif(i!=\\'../\\' ):\\n                stack.append(i)\\n        return len(stack)",
                "codeTag": "Java"
            },
            {
                "id": 1247348,
                "title": "c-iterative-solution",
                "content": "If logs[i] == \"../\" dercrease the count variable but we can\\'t move beyond main folder so check if (count != 0) than only decrement the count, and we don\\'t have to do anything if we found \"./\" so check if (logs[i] != \"./\") it means logs[i] must be equal to \"x/\" so increment the count variable.\\n\\n```\\nclass Solution {\\npublic:\\n    int minOperations(vector<string>& logs) {\\n\\n        int count = 0;\\n        \\n        for (int i =0; i< logs.size(); i++){\\n            if (logs[i] == \"../\") {\\n                if (count != 0) count--;\\n            }\\n            else if (logs[i] != \"./\") count++;\\n        }\\n        return count;\\n    }\\n};",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\npublic:\\n    int minOperations(vector<string>& logs) {\\n\\n        int count = 0;\\n        \\n        for (int i =0; i< logs.size(); i++){\\n            if (logs[i] == \"../\") {\\n                if (count != 0) count--;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1229983,
                "title": "c-0ms-stack-easy-to-understand-with-explanation",
                "content": "```\\n//You can understand easily by understanding that pop is basically one step back, so that \\n//means \"../\" and \"./\" means we are in the same folder so it\\'s obvious continue there (i.e no \\n//pushing in stack) and the reamaining action is getting inside a folder, so pushing in the stack. \\n//So at the end if we simply return the size of stack that means we have to go that much back \\n//to reach the root folder. There are just few edge cases that you need to see carefully, rest it\\'s \\n//pretty easy.\\n\\nclass Solution {\\npublic:\\n    int minOperations(vector<string>& logs) {\\n        int n = logs.size();\\n        stack<string> s;\\n        for(int i=0; i<n; i++) {\\n            if(logs[i]==\"../\" && !s.empty()) s.pop();\\n            else if(logs[i]==\"./\") continue;\\n            else if(logs[i]==\"../\" && s.empty()) continue;  //special case\\n            else s.push(logs[i]);\\n        }\\n        \\n        return s.empty() ? 0 : s.size();\\n    }\\n};\\n```\\n",
                "solutionTags": [],
                "code": "```\\n//You can understand easily by understanding that pop is basically one step back, so that \\n//means \"../\" and \"./\" means we are in the same folder so it\\'s obvious continue there (i.e no \\n//pushing in stack) and the reamaining action is getting inside a folder, so pushing in the stack. \\n//So at the end if we simply return the size of stack that means we have to go that much back \\n//to reach the root folder. There are just few edge cases that you need to see carefully, rest it\\'s \\n//pretty easy.\\n\\nclass Solution {\\npublic:\\n    int minOperations(vector<string>& logs) {\\n        int n = logs.size();\\n        stack<string> s;\\n        for(int i=0; i<n; i++) {\\n            if(logs[i]==\"../\" && !s.empty()) s.pop();\\n            else if(logs[i]==\"./\") continue;\\n            else if(logs[i]==\"../\" && s.empty()) continue;  //special case\\n            else s.push(logs[i]);\\n        }\\n        \\n        return s.empty() ? 0 : s.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1221698,
                "title": "java-100-fast-easy-to-understand",
                "content": "```\\npublic int minOperations(String[] logs) {\\n\\tint ops = 0;\\n\\tfor (String log : logs) {\\n\\t\\tif (log.equals(\"../\")) {\\n\\t\\t\\tif (ops != 0)\\n\\t\\t\\t\\tops--;\\n\\t\\t} else if (log.equals(\"./\")) {\\n\\t\\t\\tcontinue;\\n\\t\\t} else {\\n\\t\\t\\tops++;\\n\\t\\t}\\n\\t}\\n\\treturn ops;\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic int minOperations(String[] logs) {\\n\\tint ops = 0;\\n\\tfor (String log : logs) {\\n\\t\\tif (log.equals(\"../\")) {\\n\\t\\t\\tif (ops != 0)\\n\\t\\t\\t\\tops--;\\n\\t\\t} else if (log.equals(\"./\")) {\\n\\t\\t\\tcontinue;\\n\\t\\t} else {\\n\\t\\t\\tops++;\\n\\t\\t}\\n\\t}\\n\\treturn ops;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1220046,
                "title": "python-a-single-pass-solution",
                "content": "```\\nclass Solution:\\n    def minOperations(self, logs: List[str]) -> int:\\n        counter = 0\\n        for log in logs:\\n            if log == \"../\":\\n                counter = max(0, counter - 1)\\n            elif log != \"./\":\\n                counter += 1\\n        return  counter\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def minOperations(self, logs: List[str]) -> int:\\n        counter = 0\\n        for log in logs:\\n            if log == \"../\":\\n                counter = max(0, counter - 1)\\n            elif log != \"./\":\\n                counter += 1\\n        return  counter\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1208698,
                "title": "python-3-one-line",
                "content": "Use `reduce` to keep track of the depth as we iterate through the folders.\\nUse `dict.get` with a default value to calculate the depth change:\\n  * `../` -> depth - 1 (but no lower than 0)\\n  * `./` -> depth\\n  * anything else -> depth + 1 \\n\\n```python\\nclass Solution:\\n  def minOperations(self, L: List[str]) -> int:\\n    return reduce(lambda d,l: {\"../\":max(d-1,0), \"./\":d}.get(l, d+1), L, 0)\\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n  def minOperations(self, L: List[str]) -> int:\\n    return reduce(lambda d,l: {\"../\":max(d-1,0), \"./\":d}.get(l, d+1), L, 0)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1175717,
                "title": "js-straightforward-solution-with-stack-68ms",
                "content": "```\\nvar minOperations = function(logs) {\\n    const stack = [];\\n\\n    for(let log of logs){\\n        if(log === \"../\") stack.pop();\\n        else if(log === \"./\") continue;\\n        else stack.push(log)\\n    }  \\n\\n    return stack.length;\\n};\\n```\\nI\\'d love to hear your suggestions, thanks!",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar minOperations = function(logs) {\\n    const stack = [];\\n\\n    for(let log of logs){\\n        if(log === \"../\") stack.pop();\\n        else if(log === \"./\") continue;\\n        else stack.push(log)\\n    }  \\n\\n    return stack.length;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1155639,
                "title": "java-ez-stack",
                "content": "class Solution {\\n    public int minOperations(String[] logs) {\\n\\t\\n        Stack<String> stk=new Stack<>();\\n        for(String log:logs)\\n        {\\n            if(log.equals(\"../\"))\\n            {\\n                if(stk.size()>0)\\n                    stk.pop();\\n            }\\n            else if(!log.equals(\"./\"))\\n                stk.push(log);\\n        }\\n        return stk.size();\\n        \\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int minOperations(String[] logs) {\\n\\t\\n        Stack<String> stk=new Stack<>();\\n        for(String log:logs)\\n        {\\n            if(log.equals(\"../\"))\\n            {\\n                if(stk.size()>0)\\n                    stk.pop();\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1154304,
                "title": "swift-100-no-stack",
                "content": "```\\nclass Solution {\\n    func minOperations(_ logs: [String]) -> Int {\\n        var steps = 0\\n        for log in logs {\\n            switch log {\\n                case \"../\":\\n                    steps -= 1\\n                    steps = max(steps, 0)\\n                case \"./\":\\n                    break\\n                default:\\n                    steps += 1\\n            }\\n        }\\n        return steps\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    func minOperations(_ logs: [String]) -> Int {\\n        var steps = 0\\n        for log in logs {\\n            switch log {\\n                case \"../\":\\n                    steps -= 1\\n                    steps = max(steps, 0)\\n                case \"./\":\\n                    break\\n                default:\\n                    steps += 1\\n            }\\n        }\\n        return steps\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1131355,
                "title": "rust-clean-match",
                "content": "```rust\\nimpl Solution {\\n    pub fn min_operations(logs: Vec<String>) -> i32 {\\n        logs.iter().fold(0, |acc, log| match log.as_str() {\\n            \"../\" if acc > 0 => acc - 1,\\n            \"../\" | \"./\" => acc,\\n            _ => acc + 1,\\n        })\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```rust\\nimpl Solution {\\n    pub fn min_operations(logs: Vec<String>) -> i32 {\\n        logs.iter().fold(0, |acc, log| match log.as_str() {\\n            \"../\" if acc > 0 => acc - 1,\\n            \"../\" | \"./\" => acc,\\n            _ => acc + 1,\\n        })\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1110092,
                "title": "java-simple-solution-0ms-beats-100",
                "content": "If you think of the directory hierarchy as a tree structure, this question is simply to figure out where you stand in the tree (the depth from the root or the main folder in this case) after performing all the operations in the logs array.\\n\\nHaving said that, we start from the main folder, where depth is 0. \\n\\nWhen encounter  \"../\", depth decrease by 1,  unless depth is at 0, then stay at 0; \\n\\nWhen encounter \"./\", do nothing. \\n\\nOtherwise, when encounter any other String, depth increase by one. \\n\\nAt the end, the final depth value will be what it takes to return back to the main folder.\\n\\n```\\nclass Solution {\\n    public int minOperations(String[] logs) {\\n        \\n        int depth = 0;\\n        for (String s : logs)\\n        {\\n           if (\"../\".equals(s))\\n           {\\n              depth = depth == 0 ? 0 : depth - 1;\\n           }\\n           else if (\"./\".equals(s));\\n           else\\n           {\\n               depth++;\\n           }\\n        }\\n        return depth;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minOperations(String[] logs) {\\n        \\n        int depth = 0;\\n        for (String s : logs)\\n        {\\n           if (\"../\".equals(s))\\n           {\\n              depth = depth == 0 ? 0 : depth - 1;\\n           }\\n           else if (\"./\".equals(s));\\n           else\\n           {\\n               depth++;\\n           }\\n        }\\n        return depth;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1095666,
                "title": "simple-java-solution-no-stack",
                "content": "```\\nclass Solution {\\n    public int minOperations(String[] logs) {\\n        int counter = 0;\\n        for(int i =0 ;i<logs.length;i++){\\n            \\n            if(logs[i].equals(\"./\"))\\n                continue;\\n            else if(logs[i].equals(\"../\")){\\n                counter -=1;\\n            }else{\\n                counter++;\\n            }\\n            if(counter <0){\\n                counter = 0;\\n            }\\n        }\\n        return counter;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minOperations(String[] logs) {\\n        int counter = 0;\\n        for(int i =0 ;i<logs.length;i++){\\n            \\n            if(logs[i].equals(\"./\"))\\n                continue;\\n            else if(logs[i].equals(\"../\")){\\n                counter -=1;\\n            }else{\\n                counter++;\\n            }\\n            if(counter <0){\\n                counter = 0;\\n            }\\n        }\\n        return counter;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1048167,
                "title": "go-solution-faster-than-100",
                "content": "The else if with `long != \"../\"` is here because in the first if it says if `len(stack) > 0 && log == \"../\"` which means that if `log == \"../\"` and `len(stack)` is smaller than `0` the code will just append `\"../\"`\\n\\n```\\nfunc minOperations(logs []string) int {\\n\\tstack := []string{}\\n\\n\\tfor _, log := range logs {\\n\\t\\tif len(stack) > 0 && log == \"../\" {\\n\\t\\t\\tstack = stack[:len(stack)-1]\\n\\t\\t} else if log == \"./\" {\\n\\t\\t\\tcontinue\\n\\t\\t} else if log != \"../\" { \\n\\t\\t\\tstack = append(stack, log)\\n\\t\\t}\\n\\t}\\n\\tfmt.Println(stack)\\n\\treturn len(stack)\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nfunc minOperations(logs []string) int {\\n\\tstack := []string{}\\n\\n\\tfor _, log := range logs {\\n\\t\\tif len(stack) > 0 && log == \"../\" {\\n\\t\\t\\tstack = stack[:len(stack)-1]\\n\\t\\t} else if log == \"./\" {\\n\\t\\t\\tcontinue\\n\\t\\t} else if log != \"../\" { \\n\\t\\t\\tstack = append(stack, log)\\n\\t\\t}\\n\\t}\\n\\tfmt.Println(stack)\\n\\treturn len(stack)\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 896197,
                "title": "c-simple-and-understandable-approach",
                "content": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<string>& logs) {\\n        int count=0;\\n        for(int i=0;i<logs.size();i++)\\n        {\\n            if(logs[i]==\"./\")continue;\\n            if(logs[i]==\"../\" && count==0)continue;\\n            if(logs[i]==\"../\" && count!=0)count--;\\n            else count++;\\n            \\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<string>& logs) {\\n        int count=0;\\n        for(int i=0;i<logs.size();i++)\\n        {\\n            if(logs[i]==\"./\")continue;\\n            if(logs[i]==\"../\" && count==0)continue;\\n            if(logs[i]==\"../\" && count!=0)count--;\\n            else count++;\\n            \\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 883835,
                "title": "stack-based-solution-o-n-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<string>& A) {\\n        stack<int> st;\\n        for(int i = 0 ; i < A.size() ; i++){\\n            if(A[i].size() == 3 and A[i][0] == \\'.\\'){\\n                if(st.size() > 0 )  // move up the folder means u can remove it  only if there is an element\\n                    st.pop(); // left in stack\\n            }else if(A[i].size() == 2 and A[i][0] == \\'.\\'){ // do nothing\\n                \\n            }else{\\n                st.push(1);  // increase stack size \\n            }\\n        }\\n        return st.size();  // return size of stack\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<string>& A) {\\n        stack<int> st;\\n        for(int i = 0 ; i < A.size() ; i++){\\n            if(A[i].size() == 3 and A[i][0] == \\'.\\'){\\n                if(st.size() > 0 )  // move up the folder means u can remove it  only if there is an element\\n                    st.pop(); // left in stack\\n            }else if(A[i].size() == 2 and A[i][0] == \\'.\\'){ // do nothing\\n                \\n            }else{\\n                st.push(1);  // increase stack size \\n            }\\n        }\\n        return st.size();  // return size of stack\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 883234,
                "title": "easy-python-solution-time-better-than-70-space-better-than-90",
                "content": "```\\nclass Solution:\\n    def minOperations(self, logs: List[str]) -> int:\\n        stack = []\\n        stack_top = -1\\n        pointer = 0\\n        while pointer < len(logs):\\n            if logs[pointer] == \"../\":\\n                if stack_top != -1:\\n                    stack.pop(-1)\\n                    stack_top-=1\\n                pointer+=1\\n            elif logs[pointer] == \"./\":\\n                pointer+=1\\n            else:\\n                stack.append(logs[pointer])\\n                stack_top+=1\\n                pointer+=1\\n        return len(stack)\\n    \\n```\\nGITHUB for more solutions: https://github.com/Kushagrabainsla/Leetcode_DSA",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minOperations(self, logs: List[str]) -> int:\\n        stack = []\\n        stack_top = -1\\n        pointer = 0\\n        while pointer < len(logs):\\n            if logs[pointer] == \"../\":\\n                if stack_top != -1:\\n                    stack.pop(-1)\\n                    stack_top-=1\\n                pointer+=1\\n            elif logs[pointer] == \"./\":\\n                pointer+=1\\n            else:\\n                stack.append(logs[pointer])\\n                stack_top+=1\\n                pointer+=1\\n        return len(stack)\\n    \\n```",
                "codeTag": "Java"
            },
            {
                "id": 882024,
                "title": "c-4-ms-and-8-ms-solutions-stack-approach-o-1-space",
                "content": "***Runtime: 4 ms, faster than 99.25% of C++ online submissions for Crawler Log Folder.\\nMemory Usage: 11 MB, less than 12.36% of C++ online submissions for Crawler Log Folder.***\\n```\\nclass Solution {\\npublic:\\n    int minOperations(vector<string>& logs) {\\n        stack<string> path;\\n        for(auto log:logs){\\n            if(log == \"../\" && !path.empty()){\\n                path.pop();\\n            }\\n            if(log != \"../\" && log != \"./\"){\\n                path.push(log);\\n            }\\n        }\\n        return path.size();\\n    }\\n};\\n```\\n\\n***Runtime: 8 ms, faster than 89.41% of C++ online submissions for Crawler Log Folder.\\nMemory Usage: 10.7 MB, less than 71.34% of C++ online submissions for Crawler Log Folder.***\\n```\\nclass Solution {\\npublic:\\n    int minOperations(vector<string>& logs) {\\n        int result = 0;\\n        for(auto log:logs){\\n            if(log == \"../\"){\\n                result = max(0, result-1);\\n            }else if(log != \"./\"){\\n                result++;\\n            }\\n        }\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<string>& logs) {\\n        stack<string> path;\\n        for(auto log:logs){\\n            if(log == \"../\" && !path.empty()){\\n                path.pop();\\n            }\\n            if(log != \"../\" && log != \"./\"){\\n                path.push(log);\\n            }\\n        }\\n        return path.size();\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int minOperations(vector<string>& logs) {\\n        int result = 0;\\n        for(auto log:logs){\\n            if(log == \"../\"){\\n                result = max(0, result-1);\\n            }else if(log != \"./\"){\\n                result++;\\n            }\\n        }\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 878901,
                "title": "simple-java-o-n-solution",
                "content": "```\\nclass Solution {\\n    public int minOperations(String[] logs) {\\n        int level = 0;\\n        for (String log : logs) {\\n            if (log.equals(\"../\")) {\\n                if (level > 0) level--;\\n            } else if (log.equals(\"./\")) {\\n                \\n            } else {\\n                level++;\\n            }\\n        }\\n        return level;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minOperations(String[] logs) {\\n        int level = 0;\\n        for (String log : logs) {\\n            if (log.equals(\"../\")) {\\n                if (level > 0) level--;\\n            } else if (log.equals(\"./\")) {\\n                \\n            } else {\\n                level++;\\n            }\\n        }\\n        return level;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 876216,
                "title": "c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<string>& logs,int cnt=0) {\\n        for(auto str:logs){\\n            if(str==\"../\")  cnt = max(0,--cnt);\\n            else if(str!=\"./\") cnt++;\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<string>& logs,int cnt=0) {\\n        for(auto str:logs){\\n            if(str==\"../\")  cnt = max(0,--cnt);\\n            else if(str!=\"./\") cnt++;\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 872459,
                "title": "a-c-python-3-solution-stack-time-complexity-o-n-easy-to-understand",
                "content": "```\\nclass Solution:\\n    def minOperations(self, logs: List[str]) -> int:\\n        stack = []\\n        n = len(logs)\\n        for i in range(n):\\n            a = logs[i]\\n            print (\"i  = \", i, \" a = \", a)\\n            if (a == \"../\"):\\n                if (len(stack) > 0):\\n                    stack.pop()\\n            elif (a == \"./\"):\\n                continue\\n            else:\\n                stack.append(a)\\n                \\n        print (\"end stack = \", stack)\\n        return len(stack)\\n            \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minOperations(self, logs: List[str]) -> int:\\n        stack = []\\n        n = len(logs)\\n        for i in range(n):\\n            a = logs[i]\\n            print (\"i  = \", i, \" a = \", a)\\n            if (a == \"../\"):\\n                if (len(stack) > 0):\\n                    stack.pop()\\n            elif (a == \"./\"):\\n                continue\\n            else:\\n                stack.append(a)\\n                \\n        print (\"end stack = \", stack)\\n        return len(stack)\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 867307,
                "title": "c-easy-solution-o-n",
                "content": "```\\nint minOperations(vector<string>& logs) {\\n\\tint res = 0;\\n\\tfor (string s : logs) {\\n\\t\\tif (s == \"./\")\\n\\t\\t\\tcontinue;\\n\\t\\telse if (s != \"../\")\\n\\t\\t\\tres++;\\n\\t\\telse if (res)\\n\\t\\t\\tres--;\\n\\t}\\n\\treturn res;\\n}\\n```\\n",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nint minOperations(vector<string>& logs) {\\n\\tint res = 0;\\n\\tfor (string s : logs) {\\n\\t\\tif (s == \"./\")\\n\\t\\t\\tcontinue;\\n\\t\\telse if (s != \"../\")\\n\\t\\t\\tres++;\\n\\t\\telse if (res)\\n\\t\\t\\tres--;\\n\\t}\\n\\treturn res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 867016,
                "title": "swift-beats-100-simple-solution",
                "content": "```\\nfunc minOperations(_ logs: [String]) -> Int {\\n      var count = 0\\n      for log in logs where log != \"./\" {\\n        count += log == \"../\" ? -1 : 1\\n        count = count < 0 ? 0 : count\\n      }\\n      return count\\n    }\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nfunc minOperations(_ logs: [String]) -> Int {\\n      var count = 0\\n      for log in logs where log != \"./\" {\\n        count += log == \"../\" ? -1 : 1\\n        count = count < 0 ? 0 : count\\n      }\\n      return count\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 866969,
                "title": "100-faster-100-memory-c-c-javascript-java",
                "content": "C\\n```\\nint minOperations(char ** logs, int logsSize){\\n    int res = 0;\\n        for(int i =0;i<logsSize;i++){\\n            if(strcmp(logs[i],\"./\") == 0)continue;\\n            else if(strcmp(logs[i],\"../\") == 0){\\n                if(res !=0)res--;\\n            }\\n            else res++;\\n        }\\n        \\n        return res;\\n}\\n```\\n\\nC++\\n\\n```\\nclass Solution {\\npublic:\\n    int minOperations(vector<string>& logs) {\\n        int res = 0;\\n        for(int i =0;i<logs.size();i++){\\n            if(logs[i].compare(\"./\") == 0)continue;\\n            else if(logs[i].compare(\"../\") == 0){\\n                if(res !=0)res--;\\n            }\\n            else res++;\\n        }\\n        \\n        return res;\\n    }\\n};\\n```\\nJava\\n```\\nclass Solution {\\n    public int minOperations(String[] logs) {\\n        int res = 0;\\n        for(int i =0;i<logs.length;i++){\\n            if(logs[i].equals(\"./\"))continue;\\n            else if(logs[i].equals(\"../\")){\\n                if(res !=0)res--;\\n            }\\n            else res++;\\n        }\\n        \\n        return res;\\n        \\n    }\\n}\\n```\\nJavaScript\\n```\\nvar minOperations = function(logs) {\\n    var res = 0;\\n        for(var i =0;i<logs.length;i++){\\n            if(logs[i] == (\"./\")){}\\n            else if(logs[i] == (\"../\")){\\n                if(res !=0)res--;\\n            }\\n            else res++;\\n        }\\n        \\n        return res;\\n};\\n```",
                "solutionTags": [
                    "Java",
                    "C",
                    "JavaScript"
                ],
                "code": "```\\nint minOperations(char ** logs, int logsSize){\\n    int res = 0;\\n        for(int i =0;i<logsSize;i++){\\n            if(strcmp(logs[i],\"./\") == 0)continue;\\n            else if(strcmp(logs[i],\"../\") == 0){\\n                if(res !=0)res--;\\n            }\\n            else res++;\\n        }\\n        \\n        return res;\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    int minOperations(vector<string>& logs) {\\n        int res = 0;\\n        for(int i =0;i<logs.size();i++){\\n            if(logs[i].compare(\"./\") == 0)continue;\\n            else if(logs[i].compare(\"../\") == 0){\\n                if(res !=0)res--;\\n            }\\n            else res++;\\n        }\\n        \\n        return res;\\n    }\\n};\\n```\n```\\nclass Solution {\\n    public int minOperations(String[] logs) {\\n        int res = 0;\\n        for(int i =0;i<logs.length;i++){\\n            if(logs[i].equals(\"./\"))continue;\\n            else if(logs[i].equals(\"../\")){\\n                if(res !=0)res--;\\n            }\\n            else res++;\\n        }\\n        \\n        return res;\\n        \\n    }\\n}\\n```\n```\\nvar minOperations = function(logs) {\\n    var res = 0;\\n        for(var i =0;i<logs.length;i++){\\n            if(logs[i] == (\"./\")){}\\n            else if(logs[i] == (\"../\")){\\n                if(res !=0)res--;\\n            }\\n            else res++;\\n        }\\n        \\n        return res;\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 866794,
                "title": "beginner-friendly-solution-with-clean-explanation",
                "content": "Number of operations to get back to main folder is equal to the number of levels we are away from main folder.\\nTo keep track of number of levels (depth) we are in, let us use `res` variable.\\n`res = 0` for main folder.\\n\\n```\\nclass Solution {\\n    public int minOperations(String[] logs) {\\n        int res = 0;\\n        for(int i=0;i<logs.length;i++){\\n            String currOperation = logs[i];\\n\\t\\t\\t//If not home and back operation - We go back one level.\\n            if(res>0 && \"../\".equals(currOperation)) res--; \\n\\t\\t\\t//If ./ or if (main folder and ../) we do nothing.\\n            else if(currOperation.startsWith(\".\")) continue;\\n\\t\\t\\t//If forward operation - We add one level.\\n            else res++;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minOperations(String[] logs) {\\n        int res = 0;\\n        for(int i=0;i<logs.length;i++){\\n            String currOperation = logs[i];\\n\\t\\t\\t//If not home and back operation - We go back one level.\\n            if(res>0 && \"../\".equals(currOperation)) res--; \\n\\t\\t\\t//If ./ or if (main folder and ../) we do nothing.\\n            else if(currOperation.startsWith(\".\")) continue;\\n\\t\\t\\t//If forward operation - We add one level.\\n            else res++;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 866691,
                "title": "c-straightforward-single-pass-with-brief-explanation-o-1-space",
                "content": "**Brief Explanation**\\nIncrement minimum operations required for every move to child folder. Decrement minimum operations required **iff** currently the minimum operations required are greater than **0** (*i.e. we are not at the main folder already*) and current operation is move to parent folder.\\n\\n```\\nclass Solution {\\npublic:\\n    int minOperations(vector<string>& logs) {\\n        int min_ops = 0;\\n        for (const auto& log: logs) {\\n            if (log[0] != \\'.\\') {\\n                min_ops++;\\n            }\\n            else if (log == \"../\" && min_ops > 0) {\\n                min_ops--;\\n            }\\n        }\\n        return min_ops;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<string>& logs) {\\n        int min_ops = 0;\\n        for (const auto& log: logs) {\\n            if (log[0] != \\'.\\') {\\n                min_ops++;\\n            }\\n            else if (log == \"../\" && min_ops > 0) {\\n                min_ops--;\\n            }\\n        }\\n        return min_ops;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 866604,
                "title": "python-easy-short-obvious",
                "content": "```\\nclass Solution:\\n    def minOperations(self, logs: List[str]) -> int:\\n        \\n        depth=0\\n        for operation in logs:\\n            if operation==\"../\": depth = max(0, depth -1)\\n            if (operation != \"../\") and (operation !=\"./\"): depth += 1\\n                \\n        return depth\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minOperations(self, logs: List[str]) -> int:\\n        \\n        depth=0\\n        for operation in logs:\\n            if operation==\"../\": depth = max(0, depth -1)\\n            if (operation != \"../\") and (operation !=\"./\"): depth += 1\\n                \\n        return depth\\n```",
                "codeTag": "Java"
            },
            {
                "id": 866552,
                "title": "c-1-liner",
                "content": "```cpp\\nint minOperations(vector<string>& logs) {\\n    return accumulate(logs.begin(), logs.end(), 0, [](int n, const string &s) { return s == \"../\" ? max(0, n - 1) : (s == \"./\" ? n : n + 1); });\\n}\\n```\\nNormal version:\\n```cpp\\nint minOperations(vector<string>& logs) {\\n    int ans = 0;\\n    for (auto & s : logs) {\\n        if (s == \"../\")\\n            ans = max(0, ans - 1);\\n        else if (s != \"./\")\\n            ++ans;\\n    }\\n    return ans;\\n}\\n```\\nT: O(n)\\nS: O(1)\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```cpp\\nint minOperations(vector<string>& logs) {\\n    return accumulate(logs.begin(), logs.end(), 0, [](int n, const string &s) { return s == \"../\" ? max(0, n - 1) : (s == \"./\" ? n : n + 1); });\\n}\\n```\n```cpp\\nint minOperations(vector<string>& logs) {\\n    int ans = 0;\\n    for (auto & s : logs) {\\n        if (s == \"../\")\\n            ans = max(0, ans - 1);\\n        else if (s != \"./\")\\n            ++ans;\\n    }\\n    return ans;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 866537,
                "title": "java-very-simple-o-n-solution",
                "content": "```\\nclass Solution {\\n    public int minOperations(String[] logs) {\\n        int depth=0;\\n        for (String l : logs) {\\n            if (l.charAt(1)==\\'.\\') {\\n                if (depth > 0) {\\n                    depth--;\\n                }\\n            } else if (l.charAt(0)!=\\'.\\') depth++;\\n        }\\n        return depth;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minOperations(String[] logs) {\\n        int depth=0;\\n        for (String l : logs) {\\n            if (l.charAt(1)==\\'.\\') {\\n                if (depth > 0) {\\n                    depth--;\\n                }\\n            } else if (l.charAt(0)!=\\'.\\') depth++;\\n        }\\n        return depth;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 866405,
                "title": "c-simple-solution-with-comments",
                "content": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<string>& logs) {\\n        int op = 0;\\n        \\n        for(int i = 0 ; i < logs.size() ; i++)\\n        {\\n            if(logs[i][0] != \\'.\\') // go inside folder\\n            {\\n                op++;\\n            }\\n            else if(logs[i][1] != \\'/\\') // ../\\n            {\\n                op = max(op-1 , 0); \\n            }\\n            else\\n            {\\n                // do nothing\\n            }\\n        }\\n        return max(0,op);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<string>& logs) {\\n        int op = 0;\\n        \\n        for(int i = 0 ; i < logs.size() ; i++)\\n        {\\n            if(logs[i][0] != \\'.\\') // go inside folder\\n            {\\n                op++;\\n            }\\n            else if(logs[i][1] != \\'/\\') // ../\\n            {\\n                op = max(op-1 , 0); \\n            }\\n            else\\n            {\\n                // do nothing\\n            }\\n        }\\n        return max(0,op);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 866401,
                "title": "simple-python3-solution-o-n",
                "content": "The approach is very simple. Whenever **\"../\"** is encountered **decrement** ops by one ( only if ops is not zero), if **\"./\"** is encountered do **nothing** ( i.e don\\'t update ops ).\\n\\nFinally if we encounter any other **string** in the list just **increment** the value of ops by one because no matter what it is ( for eg. it can be **\"d1/\"**,**d2/** etc )we are supposed to enter into new child file\\n```\\nclass Solution:\\n    def minOperations(self, logs: List[str]) -> int:\\n        ops=0\\n        for i in range(len(logs)):\\n            if logs[i]==\\'../\\':\\n                if ops==0:\\n                    continue\\n                ops-=1\\n            elif logs[i]==\\'./\\':\\n                continue\\n            else:\\n                ops+=1\\n        return ops\\n```\\n",
                "solutionTags": [
                    "Python3",
                    "Iterator"
                ],
                "code": "```\\nclass Solution:\\n    def minOperations(self, logs: List[str]) -> int:\\n        ops=0\\n        for i in range(len(logs)):\\n            if logs[i]==\\'../\\':\\n                if ops==0:\\n                    continue\\n                ops-=1\\n            elif logs[i]==\\'./\\':\\n                continue\\n            else:\\n                ops+=1\\n        return ops\\n```",
                "codeTag": "Java"
            },
            {
                "id": 866395,
                "title": "c-o-n-time-o-1-space",
                "content": "Runtime: 132 ms\\nMemory Usage: 25.3 MB\\n```\\n    public int MinOperations(string[] logs) {\\n        \\n        int depth = 0;\\n        \\n        foreach(string k in logs)\\n        {\\n            if (k == \"./\") { continue; }\\n            if (k == \"../\") { if (depth > 0) { depth--; } }\\n            else { depth++; }\\n        }\\n        \\n        return depth;\\n    }",
                "solutionTags": [],
                "code": "Runtime: 132 ms\\nMemory Usage: 25.3 MB\\n```\\n    public int MinOperations(string[] logs) {\\n        \\n        int depth = 0;\\n        \\n        foreach(string k in logs)\\n        {\\n            if (k == \"./\") { continue; }\\n            if (k == \"../\") { if (depth > 0) { depth--; } }\\n            else { depth++; }\\n        }\\n        \\n        return depth;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 866394,
                "title": "java-efficient-solution-using-map",
                "content": "```\\npublic int minOperations(String[] logs) {\\n        Map<String, Integer> map = new HashMap<>();\\n        map.put(\"./\", 0);\\n        map.put(\"../\", -1);\\n        \\n        int ans = 0;\\n        for(int i=0;i<logs.length;i++) {\\n            if(map.containsKey(logs[i])) {\\n                ans += map.get(logs[i]);\\n                if(ans < 0) ans = 0;\\n            } else {\\n                ans += 1;\\n            }\\n        }\\n        \\n        return ans;\\n    }",
                "solutionTags": [],
                "code": "```\\npublic int minOperations(String[] logs) {\\n        Map<String, Integer> map = new HashMap<>();\\n        map.put(\"./\", 0);\\n        map.put(\"../\", -1);\\n        \\n        int ans = 0;\\n        for(int i=0;i<logs.length;i++) {\\n            if(map.containsKey(logs[i])) {\\n                ans += map.get(logs[i]);\\n                if(ans < 0) ans = 0;\\n            } else {\\n                ans += 1;\\n            }\\n        }\\n        \\n        return ans;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 866385,
                "title": "go",
                "content": "func minOperations(logs []string) int {\\n    var level int \\n    \\n    for i := range logs {\\n        if logs[i] == \"./\" {\\n            continue\\n        } else if logs[i] == \"../\" {\\n            level = max(level -1 , 0)\\n        } else {\\n            level++\\n        }\\n    }\\n    return level\\n    \\n}\\nfunc max(i,j int) int {\\n    if i >= j {\\n        return i\\n    }\\n     \\n    return j\\n}",
                "solutionTags": [],
                "code": "func minOperations(logs []string) int {\\n    var level int \\n    \\n    for i := range logs {\\n        if logs[i] == \"./\" {\\n            continue\\n        } else if logs[i] == \"../\" {\\n            level = max(level -1 , 0)\\n        } else {\\n            level++\\n        }\\n    }\\n    return level\\n    \\n}\\nfunc max(i,j int) int {\\n    if i >= j {\\n        return i\\n    }\\n     \\n    return j\\n}",
                "codeTag": "Unknown"
            },
            {
                "id": 866381,
                "title": "javascript-solution",
                "content": "```\\n/**\\n * @param {string[]} logs\\n * @return {number}\\n */\\nvar minOperations = function(logs) {\\n    let level = 0;\\n    for(let i=0; i<logs.length; i++){\\n        if(logs[i]===\"../\"){\\n            if(level!==0){\\n                level--;\\n            }\\n        }else if(logs[i]===\"./\"){\\n            continue;\\n        }else{\\n            level++;\\n        }\\n    }\\n    return level;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * @param {string[]} logs\\n * @return {number}\\n */\\nvar minOperations = function(logs) {\\n    let level = 0;\\n    for(let i=0; i<logs.length; i++){\\n        if(logs[i]===\"../\"){\\n            if(level!==0){\\n                level--;\\n            }\\n        }else if(logs[i]===\"./\"){\\n            continue;\\n        }else{\\n            level++;\\n        }\\n    }\\n    return level;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 866355,
                "title": "python-easy-sol-o-n-time-o-1-space",
                "content": "```\\nclass Solution:\\n    def minOperations(self, logs: List[str]) -> int:\\n        count = 0\\n        \\n        for item in logs:\\n            if item == \\'../\\':\\n                if count > 0:\\n                    count -= 1\\n            \\n            elif item == \\'./\\':\\n                pass\\n            \\n            else:\\n                count += 1\\n            \\n            \\n        return count if count > 0 else 0\\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minOperations(self, logs: List[str]) -> int:\\n        count = 0\\n        \\n        for item in logs:\\n            if item == \\'../\\':\\n                if count > 0:\\n                    count -= 1\\n            \\n            elif item == \\'./\\':\\n                pass\\n            \\n            else:\\n                count += 1\\n            \\n            \\n        return count if count > 0 else 0\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 866353,
                "title": "kotlin-o-n",
                "content": "```\\nfun minOperations(logs: Array<String>): Int {\\n        var counter = 0\\n        \\n        logs.forEach { log ->\\n            when (log) {\\n                \"../\" -> counter = maxOf(0, counter - 1)\\n                \"./\" -> Unit // Do nothing\\n                else -> counter++\\n            }\\n        }\\n        \\n        return counter\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nfun minOperations(logs: Array<String>): Int {\\n        var counter = 0\\n        \\n        logs.forEach { log ->\\n            when (log) {\\n                \"../\" -> counter = maxOf(0, counter - 1)\\n                \"./\" -> Unit // Do nothing\\n                else -> counter++\\n            }\\n        }\\n        \\n        return counter\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 866352,
                "title": "stack-python",
                "content": "```\\nclass Solution:\\n    def minOperations(self, logs: List[str]) -> int:\\n        \\n        stack=[]\\n        stack.append(\".\")\\n        for operation in logs:\\n            \\n            if operation==\"./\":\\n                continue\\n            elif operation==\"../\":\\n                if len(stack)>1:\\n                    stack.pop()\\n            else:\\n                stack.append(operation)\\n        return len(stack)-1\\n            \\n            \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minOperations(self, logs: List[str]) -> int:\\n        \\n        stack=[]\\n        stack.append(\".\")\\n        for operation in logs:\\n            \\n            if operation==\"./\":\\n                continue\\n            elif operation==\"../\":\\n                if len(stack)>1:\\n                    stack.pop()\\n            else:\\n                stack.append(operation)\\n        return len(stack)-1\\n            \\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 866348,
                "title": "easy-solution-in-cpp",
                "content": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<string>& logs) {\\n        vector<string> v;\\n        for(string s : logs){\\n            if(s == \"../\"){\\n                if(v.empty()) continue;\\n                v.pop_back();\\n            }\\n            \\n            else if(s == \"./\"){\\n                continue;\\n            }\\n        \\n            else{\\n                v.push_back(s);\\n            }\\n            \\n        }\\n        return (int)v.size();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<string>& logs) {\\n        vector<string> v;\\n        for(string s : logs){\\n            if(s == \"../\"){\\n                if(v.empty()) continue;\\n                v.pop_back();\\n            }\\n            \\n            else if(s == \"./\"){\\n                continue;\\n            }\\n        \\n            else{\\n                v.push_back(s);\\n            }\\n            \\n        }\\n        return (int)v.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 866341,
                "title": "java-o-n",
                "content": "```\\nclass Solution {\\n    public int minOperations(String[] logs) {\\n        int ans = 0;\\n        for(String s: logs){\\n            ans = s.charAt(0) != \\'.\\' ? ans + 1 : s.charAt(1) == \\'.\\' ? Math.max(0, ans-1) : ans;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minOperations(String[] logs) {\\n        int ans = 0;\\n        for(String s: logs){\\n            ans = s.charAt(0) != \\'.\\' ? ans + 1 : s.charAt(1) == \\'.\\' ? Math.max(0, ans-1) : ans;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4087660,
                "title": "1ms-simple-4-line-approach",
                "content": "\\n\\n# Approach\\n1. Initialize a variable count to keep track of the current directory level.\\n2. Iterate through each string log in the logs array.\\n3. For each log entry:\\n- If it is \"../\" (representing moving up one level in the directory hierarchy), decrement count by 1, but only if count is greater than 0 (to avoid going below the root level).\\n- If it is \"./\" (representing staying in the current directory), skip this log entry and continue to the next one.\\n- For any other log entry, increment count by 1, representing moving into a subdirectory.\\n4. After processing all log entries, count will represent the minimum number of operations required to reach the final directory.\\n5. Return the count as the result.\\n\\n# Complexity\\n- Time complexity:\\nThe code iterates through each log entry in the logs array, so the time complexity is O(n), where n is the number of log entries.\\n\\n- Space complexity:\\nThe code uses a single integer variable count, so the space complexity is O(1), as it doesn\\'t depend on the size of the input.\\n# Code\\n```\\nclass Solution {\\n    public int minOperations(String[] logs) {\\n        int count=0;\\n        for(String log: logs){\\n            if(log.equals(\"../\")) count=count==0?0:count-1;\\n            else if(log.equals(\"./\")) continue;\\n            else count++;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public int minOperations(String[] logs) {\\n        int count=0;\\n        for(String log: logs){\\n            if(log.equals(\"../\")) count=count==0?0:count-1;\\n            else if(log.equals(\"./\")) continue;\\n            else count++;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4083989,
                "title": "96-89-javascript",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {string[]} logs\\n * @return {number}\\n */\\nvar minOperations = function(logs) {\\n    const stack = []\\n    logs.forEach((each)=>{\\n        if(each === \"../\"){\\n            stack.pop()\\n        }else if( each == \\'./\\'){}\\n        else{\\n            stack.push(each)\\n        }\\n    })\\n\\n    return stack.length\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string[]} logs\\n * @return {number}\\n */\\nvar minOperations = function(logs) {\\n    const stack = []\\n    logs.forEach((each)=>{\\n        if(each === \"../\"){\\n            stack.pop()\\n        }else if( each == \\'./\\'){}\\n        else{\\n            stack.push(each)\\n        }\\n    })\\n\\n    return stack.length\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4072573,
                "title": "no-stack-no-problem",
                "content": "# Code\\n```\\nclass Solution:\\n    def minOperations(self, logs: List[str]) -> int:\\n        level = 0\\n        for log in logs:\\n            if log == \\'../\\':\\n                level -= 1 if level > 0 else 0\\n            elif log == \\'./\\':\\n                continue\\n            else:\\n                level += 1\\n        return level\\n\\n\\n            \\n\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minOperations(self, logs: List[str]) -> int:\\n        level = 0\\n        for log in logs:\\n            if log == \\'../\\':\\n                level -= 1 if level > 0 else 0\\n            elif log == \\'./\\':\\n                continue\\n            else:\\n                level += 1\\n        return level\\n\\n\\n            \\n\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 4064511,
                "title": "c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minOperations(vector<string>& logs) {\\n        int ans=0;\\n        for(int i=0;i<logs.size();i++){\\n            if(logs[i]==\"../\"){\\n                if(ans>0){\\n                    ans--;\\n                }\\n            }else{\\n                    if(logs[i]!=\"./\"){\\n                        ans++;\\n                    }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<string>& logs) {\\n        int ans=0;\\n        for(int i=0;i<logs.size();i++){\\n            if(logs[i]==\"../\"){\\n                if(ans>0){\\n                    ans--;\\n                }\\n            }else{\\n                    if(logs[i]!=\"./\"){\\n                        ans++;\\n                    }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4062491,
                "title": "simple-js",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {string[]} logs\\n * @return {number}\\n */\\nvar minOperations = function (logs) {\\n    console.log(logs);\\n    var ct = 0;\\n    for (var i = 0; i < logs.length; i++) {\\n        if (logs[i] == \"../\" ) {\\n            if( ct != 0)\\n            {\\n                ct--;\\n            }\\n        }\\n        if (logs[i] != \"./\" && logs[i] != \"../\") {\\n            ct++;\\n        }\\n    }\\n    if (ct <= 0) {\\n        return 0;\\n    }\\n    return ct;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string[]} logs\\n * @return {number}\\n */\\nvar minOperations = function (logs) {\\n    console.log(logs);\\n    var ct = 0;\\n    for (var i = 0; i < logs.length; i++) {\\n        if (logs[i] == \"../\" ) {\\n            if( ct != 0)\\n            {\\n                ct--;\\n            }\\n        }\\n        if (logs[i] != \"./\" && logs[i] != \"../\") {\\n            ct++;\\n        }\\n    }\\n    if (ct <= 0) {\\n        return 0;\\n    }\\n    return ct;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4058241,
                "title": "beginner-friendly-just-a-linear-traversal-optimize-solution-100-beats-2ms",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minOperations(String[] logs) {\\n        int depth=0;\\n        for(String log : logs){\\n            if(log.equals(\"./\")) continue;\\n            else if(log.equals(\"../\")){\\n                depth--;\\n                if(depth < 0) depth = 0;\\n            }\\n            else depth++;\\n        }\\n\\n        return depth;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "String",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\n    public int minOperations(String[] logs) {\\n        int depth=0;\\n        for(String log : logs){\\n            if(log.equals(\"./\")) continue;\\n            else if(log.equals(\"../\")){\\n                depth--;\\n                if(depth < 0) depth = 0;\\n            }\\n            else depth++;\\n        }\\n\\n        return depth;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4052451,
                "title": "java-solution-easy-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minOperations(String[] logs) {\\n        Stack<String> stack = new Stack<>();\\n        for(String c: logs){\\n            if(c.equals(\"../\")){\\n                if(!stack.isEmpty()){\\n                    stack.pop();\\n                }\\n            }\\n            else if (c.equals(\"./\")){\\n                  continue;\\n            }\\n            else{\\n                stack.push(c);\\n            }\\n        }\\n        return stack.size();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minOperations(String[] logs) {\\n        Stack<String> stack = new Stack<>();\\n        for(String c: logs){\\n            if(c.equals(\"../\")){\\n                if(!stack.isEmpty()){\\n                    stack.pop();\\n                }\\n            }\\n            else if (c.equals(\"./\")){\\n                  continue;\\n            }\\n            else{\\n                stack.push(c);\\n            }\\n        }\\n        return stack.size();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4050431,
                "title": "easy-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minOperations(String[] logs) {\\n        Stack<String> st = new Stack<>();\\n        for(int i=0;i<logs.length;i++){\\n            if(st.size()== 0 && logs[i].equals(\"../\")){\\n                continue;\\n            }\\n            if(st.size()>0 && logs[i].equals(\"../\")){\\n                st.pop();\\n            }\\n            else if(logs[i].equals(\"./\")){\\n                continue;\\n            }else{\\n                st.push(logs[i]);\\n            }\\n        }\\n      \\n        return st.size();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minOperations(String[] logs) {\\n        Stack<String> st = new Stack<>();\\n        for(int i=0;i<logs.length;i++){\\n            if(st.size()== 0 && logs[i].equals(\"../\")){\\n                continue;\\n            }\\n            if(st.size()>0 && logs[i].equals(\"../\")){\\n                st.pop();\\n            }\\n            else if(logs[i].equals(\"./\")){\\n                continue;\\n            }else{\\n                st.push(logs[i]);\\n            }\\n        }\\n      \\n        return st.size();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4043161,
                "title": "java-simple-approach-using-stack",
                "content": "# Intuition\\nStack used\\n\\n# Approach\\npush :- For the folder\\npop :- \"../\" \\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\n    public int minOperations(String[] logs) {\\n        Stack<String> stack = new Stack<>();\\n        int ans = 0;\\n        for (String log : logs) {\\n            if (!stack.isEmpty() && log.equals(\"../\")) {\\n                stack.pop();\\n            } else if (log.equals(\"./\")) {\\n                continue;\\n            } else if (!log.equals(\"../\")) {\\n                stack.push(log);\\n            }\\n        }\\n        ans = stack.size();\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minOperations(String[] logs) {\\n        Stack<String> stack = new Stack<>();\\n        int ans = 0;\\n        for (String log : logs) {\\n            if (!stack.isEmpty() && log.equals(\"../\")) {\\n                stack.pop();\\n            } else if (log.equals(\"./\")) {\\n                continue;\\n            } else if (!log.equals(\"../\")) {\\n                stack.push(log);\\n            }\\n        }\\n        ans = stack.size();\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4032650,
                "title": "simple-solution",
                "content": "```\\nclass Solution:\\n    def minOperations(self, logs: List[str]) -> int:\\n        depth = 0\\n        for log in logs:\\n            if \"..\" in log:\\n                if depth:\\n                    depth -= 1\\n            elif \".\" not in log:\\n                depth += 1\\n        return depth\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minOperations(self, logs: List[str]) -> int:\\n        depth = 0\\n        for log in logs:\\n            if \"..\" in log:\\n                if depth:\\n                    depth -= 1\\n            elif \".\" not in log:\\n                depth += 1\\n        return depth\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4029933,
                "title": "fastest-response-time-say-hii-amit-flutter",
                "content": "# Intuition\\n1. Remove \"./\" from list becase there is no effect of it so it will save loop time and memory\\n2. if i found \"../\" then minStep counter will decrese it means back to main but if we are alredy on main then do notheing (if minStep == 0 no need --)\\n3. if there are any folder name then we will increse steps\\n\\n# Code\\n```\\nclass Solution {\\n  int minOperations(List<String> logs) {\\n    int minStep = 0;\\n    logs.removeWhere((item) => item == \"./\");\\n    \\n    for (int i = 0; i < logs.length; i++) {\\n      if (logs[i] == \"../\") {\\n        if (minStep > 0) minStep--;\\n      } else\\n        minStep++;\\n    }\\n    return minStep;\\n  }\\n}\\n```\\n\\n*need **memory usage is still 50%** need help to improve it drop your comment below\\n\\n## Connect with me here : \\nhttps://linktr.ee/amit.flutter",
                "solutionTags": [
                    "Dart",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n  int minOperations(List<String> logs) {\\n    int minStep = 0;\\n    logs.removeWhere((item) => item == \"./\");\\n    \\n    for (int i = 0; i < logs.length; i++) {\\n      if (logs[i] == \"../\") {\\n        if (minStep > 0) minStep--;\\n      } else\\n        minStep++;\\n    }\\n    return minStep;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4024271,
                "title": "c-solution",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n- Space complexity: $$O(1)$$\\n\\n# Code\\n```\\npublic class Solution\\n{\\n    public int MinOperations(string[] logs)\\n    {\\n        var depth = 0;\\n        foreach (var log in logs)\\n        {\\n            if (log == \"../\")\\n            {\\n                if (depth > 0)\\n                {\\n                    depth--;\\n                }\\n            }\\n            else if (log != \"./\")\\n            {\\n                depth++;\\n            }\\n        }\\n\\n        return depth;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution\\n{\\n    public int MinOperations(string[] logs)\\n    {\\n        var depth = 0;\\n        foreach (var log in logs)\\n        {\\n            if (log == \"../\")\\n            {\\n                if (depth > 0)\\n                {\\n                    depth--;\\n                }\\n            }\\n            else if (log != \"./\")\\n            {\\n                depth++;\\n            }\\n        }\\n\\n        return depth;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4014791,
                "title": "typescript-javascript-solution",
                "content": "```ts\\nfunction minOperations(logs: string[]): number {\\n    let count: number = 0;\\n    for(let dir of logs){\\n        if(dir === \\'./\\') continue;\\n        if(dir === \\'../\\') {\\n            count = count == 0 ? 0 : --count;\\n             continue;\\n        }\\n        ++count;\\n    }\\n    return count;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "```ts\\nfunction minOperations(logs: string[]): number {\\n    let count: number = 0;\\n    for(let dir of logs){\\n        if(dir === \\'./\\') continue;\\n        if(dir === \\'../\\') {\\n            count = count == 0 ? 0 : --count;\\n             continue;\\n        }\\n        ++count;\\n    }\\n    return count;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4013882,
                "title": "c-stack-implementation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nvoid push(int stack[],int *t,int val,int l)\\n{\\n    if(*t==l-1) return;\\n    else\\n    stack[++(*t)];\\n}\\nvoid pop(int *t)\\n{\\n    if(*t==-1) return;\\n    else\\n    (*t)--;\\n}\\nint minOperations(char ** logs, int logsSize){\\n  char stack[logsSize];\\n  int top=-1;\\n  for(int i=0;i<logsSize;i++)\\n  {\\n      if(strcmp(logs[i],\"../\")==0) pop(&top);\\n      else if(strcmp(logs[i],\"./\")==0) continue;\\n      else push(stack,&top,i+1,logsSize);\\n  }\\n  int m=0;\\n  while(top>=0)\\n  {\\n      m++;\\n      top--;\\n  }\\n  return m;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nvoid push(int stack[],int *t,int val,int l)\\n{\\n    if(*t==l-1) return;\\n    else\\n    stack[++(*t)];\\n}\\nvoid pop(int *t)\\n{\\n    if(*t==-1) return;\\n    else\\n    (*t)--;\\n}\\nint minOperations(char ** logs, int logsSize){\\n  char stack[logsSize];\\n  int top=-1;\\n  for(int i=0;i<logsSize;i++)\\n  {\\n      if(strcmp(logs[i],\"../\")==0) pop(&top);\\n      else if(strcmp(logs[i],\"./\")==0) continue;\\n      else push(stack,&top,i+1,logsSize);\\n  }\\n  int m=0;\\n  while(top>=0)\\n  {\\n      m++;\\n      top--;\\n  }\\n  return m;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4008572,
                "title": "easy-cpp-solution-beats-90-70-in-runtime-beginner-friendly",
                "content": "![image.png](https://assets.leetcode.com/users/images/682a1150-642f-40f6-8880-81f5d4c4b631_1693982120.7181227.png)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minOperations(vector<string>& logs) {\\n        stack<string> st;\\n        int sz = logs.size();\\n        \\n        for(int i=0; i<sz; i++){\\n            if(logs[i] == \"../\"){\\n                if(st.size()) st.pop();\\n            }\\n            else if(logs[i] != \"./\"){\\n                st.push(logs[i]);\\n            }\\n        }\\n\\n        return st.size();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<string>& logs) {\\n        stack<string> st;\\n        int sz = logs.size();\\n        \\n        for(int i=0; i<sz; i++){\\n            if(logs[i] == \"../\"){\\n                if(st.size()) st.pop();\\n            }\\n            else if(logs[i] != \"./\"){\\n                st.push(logs[i]);\\n            }\\n        }\\n\\n        return st.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4003760,
                "title": "using-if-else",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nsimply by using if else\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def minOperations(self, logs: List[str]) -> int:\\n        count = 0\\n        for i in range(0,len(logs)):\\n            if logs[i] == \"./\":\\n                count+=0\\n            elif logs[i] == \"../\":\\n                if count>0:\\n                    count-=1\\n                else:\\n                    count\\n            else:\\n                count+=1\\n        if count>0:\\n            return count\\n        else:\\n            return 0\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minOperations(self, logs: List[str]) -> int:\\n        count = 0\\n        for i in range(0,len(logs)):\\n            if logs[i] == \"./\":\\n                count+=0\\n            elif logs[i] == \"../\":\\n                if count>0:\\n                    count-=1\\n                else:\\n                    count\\n            else:\\n                count+=1\\n        if count>0:\\n            return count\\n        else:\\n            return 0\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3996617,
                "title": "c-solution-using-iterative-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nI have used iterative approach here. But if you want, you can also use stack to solve it.\\n\\n# Approach\\nIterative approach\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minOperations(vector<string>& logs) {\\n        int count = 0;\\n\\n        for (int i = 0; i < logs.size(); i++) {\\n            if (logs[i] == \"./\") {\\n                // Do nothing, stay in the same folder\\n            } else if (logs[i] == \"../\") {\\n                // Go up to the parent folder\\n                if (count > 0) {\\n                    count--;\\n                }\\n            } else {\\n                // Move to a child folder\\n                count++;\\n            }\\n        }\\n\\n        return max(0, count);\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<string>& logs) {\\n        int count = 0;\\n\\n        for (int i = 0; i < logs.size(); i++) {\\n            if (logs[i] == \"./\") {\\n                // Do nothing, stay in the same folder\\n            } else if (logs[i] == \"../\") {\\n                // Go up to the parent folder\\n                if (count > 0) {\\n                    count--;\\n                }\\n            } else {\\n                // Move to a child folder\\n                count++;\\n            }\\n        }\\n\\n        return max(0, count);\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3988567,
                "title": "easy-to-understand-better-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nUsing Stack\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minOperations(vector<string>& logs) {\\n        stack<string>s1;\\n        for(string s : logs){\\n            if(s == \"./\"){\\n                continue;\\n            }\\n            else if(s == \"../\"){\\n                if(s1.size() != 0){\\n                   s1.pop();\\n                }   \\n            }\\n            else{\\n                s1.push(s);\\n            }\\n        }\\n        return s1.size();\\n    }\\n}; // please upvote if you like\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<string>& logs) {\\n        stack<string>s1;\\n        for(string s : logs){\\n            if(s == \"./\"){\\n                continue;\\n            }\\n            else if(s == \"../\"){\\n                if(s1.size() != 0){\\n                   s1.pop();\\n                }   \\n            }\\n            else{\\n                s1.push(s);\\n            }\\n        }\\n        return s1.size();\\n    }\\n}; // please upvote if you like\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3988503,
                "title": "php-simple-o-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n\\n    /**\\n     * @param String[] $logs\\n     * @return Integer\\n     */\\n    function minOperations($logs) {\\n        $steps = 0;\\n        foreach ($logs as $log) {\\n            if ($log === \\'./\\') {\\n                continue;\\n            }\\n\\n            if ($log === \\'../\\') {\\n                $steps = $steps > 0 ? $steps - 1 : $steps;\\n            } else {\\n                $steps++;\\n            }\\n        }\\n        return $steps;\\n    }\\n}\\n```",
                "solutionTags": [
                    "PHP"
                ],
                "code": "```\\nclass Solution {\\n\\n    /**\\n     * @param String[] $logs\\n     * @return Integer\\n     */\\n    function minOperations($logs) {\\n        $steps = 0;\\n        foreach ($logs as $log) {\\n            if ($log === \\'./\\') {\\n                continue;\\n            }\\n\\n            if ($log === \\'../\\') {\\n                $steps = $steps > 0 ? $steps - 1 : $steps;\\n            } else {\\n                $steps++;\\n            }\\n        }\\n        return $steps;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3984841,
                "title": "java-and-python-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n\\n# Java\\n```\\nclass Solution {\\n    public int minOperations(String[] logs) {\\n        int main = 0;\\n        for(String log: logs){\\n            if(log.endsWith(\"../\") && main > 0){\\n                main -= 1;\\n            }else if(log.endsWith(\"./\")){\\n                main += 0;\\n            }else{\\n                main += 1;\\n            }\\n        }\\n        return main;\\n    }\\n}\\n```\\n\\n# Python\\n```\\n def minOperations(self, logs: List[str]) -> int:\\n        step = 0\\n        for log in logs:\\n            print(log)\\n            if log.endswith(\"../\") and step > 0:\\n                step -= 1\\n            elif log.endswith(\"./\"):\\n                step += 0\\n            elif log.endswith(\"/\"):\\n                step += 1\\n        return step\\n```",
                "solutionTags": [
                    "Java",
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution {\\n    public int minOperations(String[] logs) {\\n        int main = 0;\\n        for(String log: logs){\\n            if(log.endsWith(\"../\") && main > 0){\\n                main -= 1;\\n            }else if(log.endsWith(\"./\")){\\n                main += 0;\\n            }else{\\n                main += 1;\\n            }\\n        }\\n        return main;\\n    }\\n}\\n```\n```\\n def minOperations(self, logs: List[str]) -> int:\\n        step = 0\\n        for log in logs:\\n            print(log)\\n            if log.endswith(\"../\") and step > 0:\\n                step -= 1\\n            elif log.endswith(\"./\"):\\n                step += 0\\n            elif log.endswith(\"/\"):\\n                step += 1\\n        return step\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3984665,
                "title": "c-easy-constant-memory-solution",
                "content": "# Intuition\\nNo need to record the events/directories in a stack.\\n\\n# Approach\\nMaintain a counter which tracks how far we are from the main folder at any point\\n\\n# Complexity\\n- Time complexity: O(N)\\n\\n- Space complexity: O(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    // Time: O(N)\\n    // Space: O(1)\\n    int minOperations(vector<string>& A) {\\n        int op_count = 0;\\n        for (string& s : A) {\\n            if (s == \"../\") {\\n                if (op_count != 0)\\n                    op_count--;\\n            }\\n            else if (s == \"./\") continue;\\n            else op_count++;\\n        }\\n\\n        return op_count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    // Time: O(N)\\n    // Space: O(1)\\n    int minOperations(vector<string>& A) {\\n        int op_count = 0;\\n        for (string& s : A) {\\n            if (s == \"../\") {\\n                if (op_count != 0)\\n                    op_count--;\\n            }\\n            else if (s == \"./\") continue;\\n            else op_count++;\\n        }\\n\\n        return op_count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3984278,
                "title": "python-stack-easy-beginner-friendly",
                "content": "# Please upvote if you find it useful\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def minOperations(self, logs: List[str]) -> int:\\n        stk = []\\n        for operation in logs:\\n            if operation == \"../\":\\n                if stk:\\n                    stk.pop()\\n            elif operation != \"./\":\\n                stk.append(operation)\\n        return len(stk)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minOperations(self, logs: List[str]) -> int:\\n        stk = []\\n        for operation in logs:\\n            if operation == \"../\":\\n                if stk:\\n                    stk.pop()\\n            elif operation != \"./\":\\n                stk.append(operation)\\n        return len(stk)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3982099,
                "title": "simple-solution-using-stack-in-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. --> We can use a stack to record the number of files away from main we are.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. --> We will pop from the stack when we need to go back and we can push to the stack when we move forwards.\\n\\n# Code\\n```\\nimport java.util.*;\\n\\nclass Solution {\\n    public int minOperations(String[] logs) {\\n        \\n        // we will use a stack to keep track of our distance from the main file\\n        Stack<Integer> stack = new Stack<>();\\n\\n        // we will check each operation and convert it to an \"action\"\\n        for(String op: logs) {\\n            \\n            // if operation is \"go back\" then we will pop a value of the stack\\n            if(op.equals(\"../\")) {\\n                if(!stack.isEmpty()) {\\n                    stack.pop();\\n                }\\n                \\n            // if the operation is not \"stay in place\" and not \"go back\" then we will add to the top of the stack    \\n            } else if(!op.equals(\"./\")) {\\n                stack.push(1);\\n            }\\n        }\\n        \\n        // we will return the size of the stack as that is the number of operations away from main we are.\\n        return stack.size();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nimport java.util.*;\\n\\nclass Solution {\\n    public int minOperations(String[] logs) {\\n        \\n        // we will use a stack to keep track of our distance from the main file\\n        Stack<Integer> stack = new Stack<>();\\n\\n        // we will check each operation and convert it to an \"action\"\\n        for(String op: logs) {\\n            \\n            // if operation is \"go back\" then we will pop a value of the stack\\n            if(op.equals(\"../\")) {\\n                if(!stack.isEmpty()) {\\n                    stack.pop();\\n                }\\n                \\n            // if the operation is not \"stay in place\" and not \"go back\" then we will add to the top of the stack    \\n            } else if(!op.equals(\"./\")) {\\n                stack.push(1);\\n            }\\n        }\\n        \\n        // we will return the size of the stack as that is the number of operations away from main we are.\\n        return stack.size();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3981476,
                "title": "simple-js-solution",
                "content": "```\\n/**\\n * @param {string[]} logs\\n * @return {number}\\n */\\nconst minOperations = function(logs) {\\n\\n    let result = 0\\n\\n    for (let i = 0; i < logs.length; i++) {\\n\\n        let curr = logs[i]\\n\\n        if (curr === \\'./\\') {\\n            result = result\\n        } else if (curr === \\'../\\' && result > 0) {\\n            result--\\n        } else if (curr === \\'../\\' && result === 0) {\\n            result = result\\n        } else {\\n            result++\\n        }\\n\\n    }\\n\\n    return result\\n\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string[]} logs\\n * @return {number}\\n */\\nconst minOperations = function(logs) {\\n\\n    let result = 0\\n\\n    for (let i = 0; i < logs.length; i++) {\\n\\n        let curr = logs[i]\\n\\n        if (curr === \\'./\\') {\\n            result = result\\n        } else if (curr === \\'../\\' && result > 0) {\\n            result--\\n        } else if (curr === \\'../\\' && result === 0) {\\n            result = result\\n        } else {\\n            result++\\n        }\\n\\n    }\\n\\n    return result\\n\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3979514,
                "title": "easy-and-fast-solution",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\n - to check if the file vistited and this movement is into the child of this file do `if(a[0]==act[o]&&a[length-2]==act[length-3]`\\n - for example d12 and d121  \\n# Complexity\\n- Time complexity:$$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minOperations(vector<string>& logs) {\\n     stack<string>st;\\n     for(string act:logs){\\n         if(act==\"../\"){\\n             if(!st.empty())\\n              st.pop();\\n         }\\n        else if(act==\"./\")\\n           continue;\\n        else{\\n          if(!st.empty()){\\n           string a=st.top();\\n            if(a[0]==act[0]&&a[a.length()-2]==act[act.length()-3])\\n               continue;\\n          }\\n          st.push(act);\\n        }\\n     }\\n     int op=0;\\n     while(!st.empty()){ \\n      op++;\\n     st.pop();\\n     }\\n     return op;   \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<string>& logs) {\\n     stack<string>st;\\n     for(string act:logs){\\n         if(act==\"../\"){\\n             if(!st.empty())\\n              st.pop();\\n         }\\n        else if(act==\"./\")\\n           continue;\\n        else{\\n          if(!st.empty()){\\n           string a=st.top();\\n            if(a[0]==act[0]&&a[a.length()-2]==act[act.length()-3])\\n               continue;\\n          }\\n          st.push(act);\\n        }\\n     }\\n     int op=0;\\n     while(!st.empty()){ \\n      op++;\\n     st.pop();\\n     }\\n     return op;   \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3978876,
                "title": "clean-concise-readable-and-easy-to-understand-code",
                "content": "# Intuition\\n  Simple approach dude : If we encounter \"x/\" folder then simply we have to push it into the stack and as soon as we encounter \"../\" this string then simply we have to pop the last folder from the stack because this is how the folder works , as suppose firstly I am in the D drive then i move to it\\'s child E drive so when I write \"../\" so when I pop E from the stack then I will reach back to the D drive again . That\\'s why I have pushed \"x/\" named folder in the Stack and when I countered \"../\" this string so I have popped the last folder from the stack. No need to check for the string \"./\" because it means that we should remain sit in the same folder means we don\\'t have to perform any operation so there is no point to check for it as we don\\' have do anything in such cases .\\n\\nIn the end simply return the size of the stack because the element present in the stack took us to came out from that folder to main folder.\\n\\n# Approach\\n  LIFO based approach .\\n\\n# Complexity\\n- Time complexity:\\n  O(n)\\n\\n- Space complexity:\\n  O(n)\\n\\n# Code\\n```\\nclass Solution {\\n    public int minOperations(String[] logs) {\\n        Stack<String>stack = new Stack<>();\\n        for(String s:logs){\\n            if(!s.equals(\"../\") && !s.equals(\"./\")) stack.push(s);\\n            else if(s.equals(\"../\") && !stack.isEmpty()) stack.pop();\\n        }\\n        return stack.size();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "String",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\n    public int minOperations(String[] logs) {\\n        Stack<String>stack = new Stack<>();\\n        for(String s:logs){\\n            if(!s.equals(\"../\") && !s.equals(\"./\")) stack.push(s);\\n            else if(s.equals(\"../\") && !stack.isEmpty()) stack.pop();\\n        }\\n        return stack.size();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3975874,
                "title": "kotlin-simple-solution-with-when",
                "content": "# Intuition\\nClarity of code, one cycle.\\n\\n# Approach\\nCycle for the input array, \"when\" for founded actions in array.\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\nclass Solution {\\n    fun minOperations(logs: Array<String>): Int {\\n        var countDownDirectories = 0\\n\\n        for (i in logs){\\n            when (i){\\n                \"./\" -> continue\\n                \"../\" -> {\\n                    if (countDownDirectories > 0) countDownDirectories --\\n                }\\n                else -> countDownDirectories ++\\n            }\\n        }\\n\\n        return countDownDirectories\\n    }\\n}\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\nclass Solution {\\n    fun minOperations(logs: Array<String>): Int {\\n        var countDownDirectories = 0\\n\\n        for (i in logs){\\n            when (i){\\n                \"./\" -> continue\\n                \"../\" -> {\\n                    if (countDownDirectories > 0) countDownDirectories --\\n                }\\n                else -> countDownDirectories ++\\n            }\\n        }\\n\\n        return countDownDirectories\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3967403,
                "title": "easy-to-understand",
                "content": "```\\nclass Solution {\\n    public int minOperations(String[] logs) {\\n        int count = 0;\\n        for(int i=0; i<logs.length; i++){\\n            // if first character of log is digit or character then increment the count.\\n            char ch = logs[i].charAt(0);\\n            if((ch >= \\'a\\' && ch <= \\'z\\') || Character.isDigit(ch)){\\n                count++;\\n            }\\n            // if log is equals to \"../\" and count is less than or equals to 0 then don\\'t increment count.\\n            else if(logs[i].equals(\"../\")){\\n                if(count<=0) continue;\\n                else count--;\\n            }\\n            else{\\n                continue;\\n            }\\n        }\\n        if(count < 0) count = 0;\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minOperations(String[] logs) {\\n        int count = 0;\\n        for(int i=0; i<logs.length; i++){\\n            // if first character of log is digit or character then increment the count.\\n            char ch = logs[i].charAt(0);\\n            if((ch >= \\'a\\' && ch <= \\'z\\') || Character.isDigit(ch)){\\n                count++;\\n            }\\n            // if log is equals to \"../\" and count is less than or equals to 0 then don\\'t increment count.\\n            else if(logs[i].equals(\"../\")){\\n                if(count<=0) continue;\\n                else count--;\\n            }\\n            else{\\n                continue;\\n            }\\n        }\\n        if(count < 0) count = 0;\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1798209,
                "content": [
                    {
                        "username": "fuc-",
                        "content": "The 2 hints provided are the same, kindly look into it! Cheers!"
                    },
                    {
                        "username": "soumyajit_0",
                        "content": "The question setter went out of Hints. :3"
                    },
                    {
                        "username": "soumyajit_0",
                        "content": "The guy who used Stack for solving this question should be declared as the most hardworking person on this planet after ChatGPT."
                    },
                    {
                        "username": "Coder-Haris",
                        "content": "haha\\n"
                    },
                    {
                        "username": "M_Suleman",
                        "content": "The solution is simple.\\n->create count varable\\n->If first char of log[i] is digit or charcter i.e(d2/, h21/) etc. Then increment count\\n->if you face \"../\" decrement count.\\n-> if you encounter \"./\" leave it \\n\\nSorry for my bad English.\\n"
                    },
                    {
                        "username": "piyush_mehta22",
                        "content": "when there is a stack, there is always a +1, -1.\\nconstant space\\uD83D\\uDE43"
                    },
                    {
                        "username": "yeedaKing",
                        "content": "just create a stack and append or pop folders to the stack based on the operations... then return the length of the stack"
                    },
                    {
                        "username": "jtoumi",
                        "content": "the description is misleading !!!\\nThis might help: think about how to get the final depth (after all operations have been performed)  "
                    },
                    {
                        "username": "anmol_8862",
                        "content": "The description is tricky.\\nyou need to give the minimum operation required to go back to main folder after performing whole operations of the given logs array"
                    }
                ]
            },
            {
                "id": 1980281,
                "content": [
                    {
                        "username": "fuc-",
                        "content": "The 2 hints provided are the same, kindly look into it! Cheers!"
                    },
                    {
                        "username": "soumyajit_0",
                        "content": "The question setter went out of Hints. :3"
                    },
                    {
                        "username": "soumyajit_0",
                        "content": "The guy who used Stack for solving this question should be declared as the most hardworking person on this planet after ChatGPT."
                    },
                    {
                        "username": "Coder-Haris",
                        "content": "haha\\n"
                    },
                    {
                        "username": "M_Suleman",
                        "content": "The solution is simple.\\n->create count varable\\n->If first char of log[i] is digit or charcter i.e(d2/, h21/) etc. Then increment count\\n->if you face \"../\" decrement count.\\n-> if you encounter \"./\" leave it \\n\\nSorry for my bad English.\\n"
                    },
                    {
                        "username": "piyush_mehta22",
                        "content": "when there is a stack, there is always a +1, -1.\\nconstant space\\uD83D\\uDE43"
                    },
                    {
                        "username": "yeedaKing",
                        "content": "just create a stack and append or pop folders to the stack based on the operations... then return the length of the stack"
                    },
                    {
                        "username": "jtoumi",
                        "content": "the description is misleading !!!\\nThis might help: think about how to get the final depth (after all operations have been performed)  "
                    },
                    {
                        "username": "anmol_8862",
                        "content": "The description is tricky.\\nyou need to give the minimum operation required to go back to main folder after performing whole operations of the given logs array"
                    }
                ]
            },
            {
                "id": 2022316,
                "content": [
                    {
                        "username": "fuc-",
                        "content": "The 2 hints provided are the same, kindly look into it! Cheers!"
                    },
                    {
                        "username": "soumyajit_0",
                        "content": "The question setter went out of Hints. :3"
                    },
                    {
                        "username": "soumyajit_0",
                        "content": "The guy who used Stack for solving this question should be declared as the most hardworking person on this planet after ChatGPT."
                    },
                    {
                        "username": "Coder-Haris",
                        "content": "haha\\n"
                    },
                    {
                        "username": "M_Suleman",
                        "content": "The solution is simple.\\n->create count varable\\n->If first char of log[i] is digit or charcter i.e(d2/, h21/) etc. Then increment count\\n->if you face \"../\" decrement count.\\n-> if you encounter \"./\" leave it \\n\\nSorry for my bad English.\\n"
                    },
                    {
                        "username": "piyush_mehta22",
                        "content": "when there is a stack, there is always a +1, -1.\\nconstant space\\uD83D\\uDE43"
                    },
                    {
                        "username": "yeedaKing",
                        "content": "just create a stack and append or pop folders to the stack based on the operations... then return the length of the stack"
                    },
                    {
                        "username": "jtoumi",
                        "content": "the description is misleading !!!\\nThis might help: think about how to get the final depth (after all operations have been performed)  "
                    },
                    {
                        "username": "anmol_8862",
                        "content": "The description is tricky.\\nyou need to give the minimum operation required to go back to main folder after performing whole operations of the given logs array"
                    }
                ]
            },
            {
                "id": 2019251,
                "content": [
                    {
                        "username": "fuc-",
                        "content": "The 2 hints provided are the same, kindly look into it! Cheers!"
                    },
                    {
                        "username": "soumyajit_0",
                        "content": "The question setter went out of Hints. :3"
                    },
                    {
                        "username": "soumyajit_0",
                        "content": "The guy who used Stack for solving this question should be declared as the most hardworking person on this planet after ChatGPT."
                    },
                    {
                        "username": "Coder-Haris",
                        "content": "haha\\n"
                    },
                    {
                        "username": "M_Suleman",
                        "content": "The solution is simple.\\n->create count varable\\n->If first char of log[i] is digit or charcter i.e(d2/, h21/) etc. Then increment count\\n->if you face \"../\" decrement count.\\n-> if you encounter \"./\" leave it \\n\\nSorry for my bad English.\\n"
                    },
                    {
                        "username": "piyush_mehta22",
                        "content": "when there is a stack, there is always a +1, -1.\\nconstant space\\uD83D\\uDE43"
                    },
                    {
                        "username": "yeedaKing",
                        "content": "just create a stack and append or pop folders to the stack based on the operations... then return the length of the stack"
                    },
                    {
                        "username": "jtoumi",
                        "content": "the description is misleading !!!\\nThis might help: think about how to get the final depth (after all operations have been performed)  "
                    },
                    {
                        "username": "anmol_8862",
                        "content": "The description is tricky.\\nyou need to give the minimum operation required to go back to main folder after performing whole operations of the given logs array"
                    }
                ]
            },
            {
                "id": 1979113,
                "content": [
                    {
                        "username": "fuc-",
                        "content": "The 2 hints provided are the same, kindly look into it! Cheers!"
                    },
                    {
                        "username": "soumyajit_0",
                        "content": "The question setter went out of Hints. :3"
                    },
                    {
                        "username": "soumyajit_0",
                        "content": "The guy who used Stack for solving this question should be declared as the most hardworking person on this planet after ChatGPT."
                    },
                    {
                        "username": "Coder-Haris",
                        "content": "haha\\n"
                    },
                    {
                        "username": "M_Suleman",
                        "content": "The solution is simple.\\n->create count varable\\n->If first char of log[i] is digit or charcter i.e(d2/, h21/) etc. Then increment count\\n->if you face \"../\" decrement count.\\n-> if you encounter \"./\" leave it \\n\\nSorry for my bad English.\\n"
                    },
                    {
                        "username": "piyush_mehta22",
                        "content": "when there is a stack, there is always a +1, -1.\\nconstant space\\uD83D\\uDE43"
                    },
                    {
                        "username": "yeedaKing",
                        "content": "just create a stack and append or pop folders to the stack based on the operations... then return the length of the stack"
                    },
                    {
                        "username": "jtoumi",
                        "content": "the description is misleading !!!\\nThis might help: think about how to get the final depth (after all operations have been performed)  "
                    },
                    {
                        "username": "anmol_8862",
                        "content": "The description is tricky.\\nyou need to give the minimum operation required to go back to main folder after performing whole operations of the given logs array"
                    }
                ]
            },
            {
                "id": 1968836,
                "content": [
                    {
                        "username": "fuc-",
                        "content": "The 2 hints provided are the same, kindly look into it! Cheers!"
                    },
                    {
                        "username": "soumyajit_0",
                        "content": "The question setter went out of Hints. :3"
                    },
                    {
                        "username": "soumyajit_0",
                        "content": "The guy who used Stack for solving this question should be declared as the most hardworking person on this planet after ChatGPT."
                    },
                    {
                        "username": "Coder-Haris",
                        "content": "haha\\n"
                    },
                    {
                        "username": "M_Suleman",
                        "content": "The solution is simple.\\n->create count varable\\n->If first char of log[i] is digit or charcter i.e(d2/, h21/) etc. Then increment count\\n->if you face \"../\" decrement count.\\n-> if you encounter \"./\" leave it \\n\\nSorry for my bad English.\\n"
                    },
                    {
                        "username": "piyush_mehta22",
                        "content": "when there is a stack, there is always a +1, -1.\\nconstant space\\uD83D\\uDE43"
                    },
                    {
                        "username": "yeedaKing",
                        "content": "just create a stack and append or pop folders to the stack based on the operations... then return the length of the stack"
                    },
                    {
                        "username": "jtoumi",
                        "content": "the description is misleading !!!\\nThis might help: think about how to get the final depth (after all operations have been performed)  "
                    },
                    {
                        "username": "anmol_8862",
                        "content": "The description is tricky.\\nyou need to give the minimum operation required to go back to main folder after performing whole operations of the given logs array"
                    }
                ]
            },
            {
                "id": 1930046,
                "content": [
                    {
                        "username": "fuc-",
                        "content": "The 2 hints provided are the same, kindly look into it! Cheers!"
                    },
                    {
                        "username": "soumyajit_0",
                        "content": "The question setter went out of Hints. :3"
                    },
                    {
                        "username": "soumyajit_0",
                        "content": "The guy who used Stack for solving this question should be declared as the most hardworking person on this planet after ChatGPT."
                    },
                    {
                        "username": "Coder-Haris",
                        "content": "haha\\n"
                    },
                    {
                        "username": "M_Suleman",
                        "content": "The solution is simple.\\n->create count varable\\n->If first char of log[i] is digit or charcter i.e(d2/, h21/) etc. Then increment count\\n->if you face \"../\" decrement count.\\n-> if you encounter \"./\" leave it \\n\\nSorry for my bad English.\\n"
                    },
                    {
                        "username": "piyush_mehta22",
                        "content": "when there is a stack, there is always a +1, -1.\\nconstant space\\uD83D\\uDE43"
                    },
                    {
                        "username": "yeedaKing",
                        "content": "just create a stack and append or pop folders to the stack based on the operations... then return the length of the stack"
                    },
                    {
                        "username": "jtoumi",
                        "content": "the description is misleading !!!\\nThis might help: think about how to get the final depth (after all operations have been performed)  "
                    },
                    {
                        "username": "anmol_8862",
                        "content": "The description is tricky.\\nyou need to give the minimum operation required to go back to main folder after performing whole operations of the given logs array"
                    }
                ]
            }
        ]
    },
    {
        "title": "Maximum Profit of Operating a Centennial Wheel",
        "question_content": "<p>You are the operator of a Centennial Wheel that has <strong>four gondolas</strong>, and each gondola has room for <strong>up</strong> <strong>to</strong> <strong>four people</strong>. You have the ability to rotate the gondolas <strong>counterclockwise</strong>, which costs you <code>runningCost</code> dollars.</p>\n\n<p>You are given an array <code>customers</code> of length <code>n</code> where <code>customers[i]</code> is the number of new customers arriving just before the <code>i<sup>th</sup></code> rotation (0-indexed). This means you <strong>must rotate the wheel </strong><code>i</code><strong> times before the </strong><code>customers[i]</code><strong> customers arrive</strong>. <strong>You cannot make customers wait if there is room in the gondola</strong>. Each customer pays <code>boardingCost</code> dollars when they board on the gondola closest to the ground and will exit once that gondola reaches the ground again.</p>\n\n<p>You can stop the wheel at any time, including <strong>before</strong> <strong>serving</strong> <strong>all</strong> <strong>customers</strong>. If you decide to stop serving customers, <strong>all subsequent rotations are free</strong> in order to get all the customers down safely. Note that if there are currently more than four customers waiting at the wheel, only four will board the gondola, and the rest will wait <strong>for the next rotation</strong>.</p>\n\n<p>Return<em> the minimum number of rotations you need to perform to maximize your profit.</em> If there is <strong>no scenario</strong> where the profit is positive, return <code>-1</code>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/09/09/wheeldiagram12.png\" style=\"width: 700px; height: 225px;\" />\n<pre>\n<strong>Input:</strong> customers = [8,3], boardingCost = 5, runningCost = 6\n<strong>Output:</strong> 3\n<strong>Explanation:</strong> The numbers written on the gondolas are the number of people currently there.\n1. 8 customers arrive, 4 board and 4 wait for the next gondola, the wheel rotates. Current profit is 4 * $5 - 1 * $6 = $14.\n2. 3 customers arrive, the 4 waiting board the wheel and the other 3 wait, the wheel rotates. Current profit is 8 * $5 - 2 * $6 = $28.\n3. The final 3 customers board the gondola, the wheel rotates. Current profit is 11 * $5 - 3 * $6 = $37.\nThe highest profit was $37 after rotating the wheel 3 times.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> customers = [10,9,6], boardingCost = 6, runningCost = 4\n<strong>Output:</strong> 7\n<strong>Explanation:</strong>\n1. 10 customers arrive, 4 board and 6 wait for the next gondola, the wheel rotates. Current profit is 4 * $6 - 1 * $4 = $20.\n2. 9 customers arrive, 4 board and 11 wait (2 originally waiting, 9 newly waiting), the wheel rotates. Current profit is 8 * $6 - 2 * $4 = $40.\n3. The final 6 customers arrive, 4 board and 13 wait, the wheel rotates. Current profit is 12 * $6 - 3 * $4 = $60.\n4. 4 board and 9 wait, the wheel rotates. Current profit is 16 * $6 - 4 * $4 = $80.\n5. 4 board and 5 wait, the wheel rotates. Current profit is 20 * $6 - 5 * $4 = $100.\n6. 4 board and 1 waits, the wheel rotates. Current profit is 24 * $6 - 6 * $4 = $120.\n7. 1 boards, the wheel rotates. Current profit is 25 * $6 - 7 * $4 = $122.\nThe highest profit was $122 after rotating the wheel 7 times.\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> customers = [3,4,0,5,1], boardingCost = 1, runningCost = 92\n<strong>Output:</strong> -1\n<strong>Explanation:</strong>\n1. 3 customers arrive, 3 board and 0 wait, the wheel rotates. Current profit is 3 * $1 - 1 * $92 = -$89.\n2. 4 customers arrive, 4 board and 0 wait, the wheel rotates. Current profit is 7 * $1 - 2 * $92 = -$177.\n3. 0 customers arrive, 0 board and 0 wait, the wheel rotates. Current profit is 7 * $1 - 3 * $92 = -$269.\n4. 5 customers arrive, 4 board and 1 waits, the wheel rotates. Current profit is 11 * $1 - 4 * $92 = -$357.\n5. 1 customer arrives, 2 board and 0 wait, the wheel rotates. Current profit is 13 * $1 - 5 * $92 = -$447.\nThe profit was never positive, so return -1.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>n == customers.length</code></li>\n\t<li><code>1 &lt;= n &lt;= 10<sup>5</sup></code></li>\n\t<li><code>0 &lt;= customers[i] &lt;= 50</code></li>\n\t<li><code>1 &lt;= boardingCost, runningCost &lt;= 100</code></li>\n</ul>\n",
        "solutions": [
            {
                "id": 866409,
                "title": "java-simple-o-n-greedy",
                "content": "Cleaner ones:\\ntime: O(N), N is the total passenger count / 4;\\n```\\n    public int minOperationsMaxProfit(int[] cs, int bc, int rc) {\\n        int run = 0, maxRun = 1, prof = 0, maxProf = prof, sum = 0, i = 0;\\n        while (sum > 0 || i < cs.length) {\\n            if (i < cs.length) sum += cs[i++];\\n            int bd = Math.min(4, sum);  // boarding people by greedy. \\n            sum -= bd;\\n            prof = prof + bd * bc - rc;\\n            run++;\\n            if (prof > maxProf) {\\n                maxProf = prof;\\n                maxRun = run;\\n            }\\n        }\\n        return maxProf > 0 ? maxRun : -1;\\n    }\\n```\\n",
                "solutionTags": [],
                "code": "```\\n    public int minOperationsMaxProfit(int[] cs, int bc, int rc) {\\n        int run = 0, maxRun = 1, prof = 0, maxProf = prof, sum = 0, i = 0;\\n        while (sum > 0 || i < cs.length) {\\n            if (i < cs.length) sum += cs[i++];\\n            int bd = Math.min(4, sum);  // boarding people by greedy. \\n            sum -= bd;\\n            prof = prof + bd * bc - rc;\\n            run++;\\n            if (prof > maxProf) {\\n                maxProf = prof;\\n                maxRun = run;\\n            }\\n        }\\n        return maxProf > 0 ? maxRun : -1;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 868458,
                "title": "c-simulation",
                "content": "Just do exactly what the problem says until you run out of customers. Track the maximum profit so far and it\\'s turn number.\\n\\n```cpp\\nint minOperationsMaxProfit(vector<int>& cust, int boardingCost, int runningCost) {\\n    int wait = 0, prof = 0, max_prof = 0, max_i = -1;\\n    for (int i = 0; i < cust.size() || wait > 0; ++i) {\\n        if (i < cust.size())\\n            wait += cust[i];\\n        prof += min(4, wait) * boardingCost - runningCost;\\n        wait -= min(4, wait);\\n        if (max_prof < prof) {\\n            max_prof = prof;\\n            max_i = i + 1;\\n        }\\n    }\\n    return max_i;\\n}\\n```",
                "solutionTags": [],
                "code": "```cpp\\nint minOperationsMaxProfit(vector<int>& cust, int boardingCost, int runningCost) {\\n    int wait = 0, prof = 0, max_prof = 0, max_i = -1;\\n    for (int i = 0; i < cust.size() || wait > 0; ++i) {\\n        if (i < cust.size())\\n            wait += cust[i];\\n        prof += min(4, wait) * boardingCost - runningCost;\\n        wait -= min(4, wait);\\n        if (max_prof < prof) {\\n            max_prof = prof;\\n            max_i = i + 1;\\n        }\\n    }\\n    return max_i;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 866375,
                "title": "very-easy-idea-simulation-problem-readable-code-with-comments",
                "content": "```\\n\\n/*\\n\\nOne small idea that makes the code a lot simpler is to only accept 4 customers from customers[i] \\nat a time and defer the rest into\\ncustomer[i+1].\\nAt the end we can deal with all the waiting customers at once.\\n\\n*/\\n\\nclass Solution {\\n\\tint rotations = 0;  // Stores number of rotations made so far.\\n    int profit = 0;        // Stores current profit after \"rotations\" rotations.\\n\\tint maxProfit = 0;  // Stores max profit reached so far.\\n\\tint bestRotations = 0;   // Stores rotations corresponding to \"maxProfit\".\\n\\n\\n    int bCost, rCost;  // Boarding and Running costs.\\npublic:\\n\\n    // Updates the necessary variables and computes maxProfit, bestRotations etc.\\n    void report(int boarded) {\\n        profit += (boarded*bCost - rCost);  // add the profit earned.\\n        rotations++;                        // count this rotation.\\n        if (profit > maxProfit) {           // update maximum profit.\\n            maxProfit = profit;\\n            bestRotations = rotations;\\n        }\\n    }\\n    \\n    int minOperationsMaxProfit(vector<int>& customers, int boardingCost, int runnningCost) {\\n        bCost = boardingCost;\\n        rCost = runnningCost;\\n        int n = customers.size();\\n        for (int i=0; i<n-1; i++) {   // For each group of customers -\\n            if (customers[i] > 4) {   // Limit it to just 4\\n                customers[i+1] += (customers[i]-4);  // Add remaining to next\\n                customers[i] = 4;  // update the current group.\\n            }\\n            report(customers[i]);  // generate report of this rotation\\n        }\\n        \\n        int waiting = customers[n-1]; \\n        while (waiting > 0) {\\n            int boarded = min(4, waiting); // max 4 at a time.\\n            waiting -= boarded; // reduce the people in waiting\\n            report(boarded);  // generate report\\n        }\\n        \\n        return maxProfit > 0 ? bestRotations : -1;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n\\n/*\\n\\nOne small idea that makes the code a lot simpler is to only accept 4 customers from customers[i] \\nat a time and defer the rest into\\ncustomer[i+1].\\nAt the end we can deal with all the waiting customers at once.\\n\\n*/\\n\\nclass Solution {\\n\\tint rotations = 0;  // Stores number of rotations made so far.\\n    int profit = 0;        // Stores current profit after \"rotations\" rotations.\\n\\tint maxProfit = 0;  // Stores max profit reached so far.\\n\\tint bestRotations = 0;   // Stores rotations corresponding to \"maxProfit\".\\n\\n\\n    int bCost, rCost;  // Boarding and Running costs.\\npublic:\\n\\n    // Updates the necessary variables and computes maxProfit, bestRotations etc.\\n    void report(int boarded) {\\n        profit += (boarded*bCost - rCost);  // add the profit earned.\\n        rotations++;                        // count this rotation.\\n        if (profit > maxProfit) {           // update maximum profit.\\n            maxProfit = profit;\\n            bestRotations = rotations;\\n        }\\n    }\\n    \\n    int minOperationsMaxProfit(vector<int>& customers, int boardingCost, int runnningCost) {\\n        bCost = boardingCost;\\n        rCost = runnningCost;\\n        int n = customers.size();\\n        for (int i=0; i<n-1; i++) {   // For each group of customers -\\n            if (customers[i] > 4) {   // Limit it to just 4\\n                customers[i+1] += (customers[i]-4);  // Add remaining to next\\n                customers[i] = 4;  // update the current group.\\n            }\\n            report(customers[i]);  // generate report of this rotation\\n        }\\n        \\n        int waiting = customers[n-1]; \\n        while (waiting > 0) {\\n            int boarded = min(4, waiting); // max 4 at a time.\\n            waiting -= boarded; // reduce the people in waiting\\n            report(boarded);  // generate report\\n        }\\n        \\n        return maxProfit > 0 ? bestRotations : -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 866356,
                "title": "python3-simulation",
                "content": "\\n```\\nclass Solution:\\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\\n        ans = -1\\n        most = pnl = waiting = 0\\n        for i, x in enumerate(customers): \\n            waiting += x # more people waiting in line \\n            waiting -= (chg := min(4, waiting)) # boarding \\n            pnl += chg * boardingCost - runningCost \\n            if most < pnl: ans, most = i+1, pnl\\n        q, r = divmod(waiting, 4)\\n        if 4*boardingCost > runningCost: ans += q\\n        if r*boardingCost > runningCost: ans += 1\\n        return ans \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\\n        ans = -1\\n        most = pnl = waiting = 0\\n        for i, x in enumerate(customers): \\n            waiting += x # more people waiting in line \\n            waiting -= (chg := min(4, waiting)) # boarding \\n            pnl += chg * boardingCost - runningCost \\n            if most < pnl: ans, most = i+1, pnl\\n        q, r = divmod(waiting, 4)\\n        if 4*boardingCost > runningCost: ans += q\\n        if r*boardingCost > runningCost: ans += 1\\n        return ans \\n```",
                "codeTag": "Java"
            },
            {
                "id": 866896,
                "title": "simulate-the-problem-detailed-explanation-java",
                "content": "```\\npublic int minOperationsMaxProfit(int[] customers, int boardingCost, int runningCost) {\\n    //Keep track of customers who are waiting and customers who are on-board.\\n\\tint waitingCustomers = customers[0], totalOnBoard = 0;\\n    int result = -1, maxProfit = 0;\\n    for(int i=1; i<customers.length || waitingCustomers>0; i++){\\n         //In one round you can board max. 4 customers\\n\\t\\tint newlyOnboarded = Math.min(4,waitingCustomers);\\n\\t\\t//Substract newlyOnBoarded customer from waiting-list.\\n        waitingCustomers-=newlyOnboarded;\\n        totalOnBoard+=newlyOnboarded;\\n\\n        int profit = totalOnBoard*boardingCost - i*runningCost;\\n\\t\\t//If the profit is maximum, update the result.\\n        if(profit>maxProfit){\\n            maxProfit = profit;\\n            result = i;\\n        }\\n\\t\\t//customers will be added to waiting customer count.\\n        if(i<customers.length) waitingCustomers +=customers[i];\\n    }\\n    return result;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic int minOperationsMaxProfit(int[] customers, int boardingCost, int runningCost) {\\n    //Keep track of customers who are waiting and customers who are on-board.\\n\\tint waitingCustomers = customers[0], totalOnBoard = 0;\\n    int result = -1, maxProfit = 0;\\n    for(int i=1; i<customers.length || waitingCustomers>0; i++){\\n         //In one round you can board max. 4 customers\\n\\t\\tint newlyOnboarded = Math.min(4,waitingCustomers);\\n\\t\\t//Substract newlyOnBoarded customer from waiting-list.\\n        waitingCustomers-=newlyOnboarded;\\n        totalOnBoard+=newlyOnboarded;\\n\\n        int profit = totalOnBoard*boardingCost - i*runningCost;\\n\\t\\t//If the profit is maximum, update the result.\\n        if(profit>maxProfit){\\n            maxProfit = profit;\\n            result = i;\\n        }\\n\\t\\t//customers will be added to waiting customer count.\\n        if(i<customers.length) waitingCustomers +=customers[i];\\n    }\\n    return result;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 917385,
                "title": "python-c-easy-solution-o-n",
                "content": "**C++**\\n```\\nclass Solution {\\npublic:\\n    int minOperationsMaxProfit(vector<int>& customers, int boardingCost, int runningCost) {\\n        int rotate = 0, total = 0, money = 0, num = 0, i;\\n\\t\\tint maxx = INT_MIN, ans = rotate;\\n        for(i = 0; i< customers.size(); i++){\\n            total += customers[i];\\n            rotate = i+1;\\n            if(total >= 4) {num += 4; total -= 4;}\\n            else { num += total; total = 0;}\\n            money = num * boardingCost - rotate * runningCost;\\n            if(maxx < money) {maxx = money; ans = rotate;}\\n        }\\n        while(total > 0){\\n            rotate = i+1;\\n            if(total >= 4) {num += 4; total -= 4;}\\n            else { num += total; total = 0;}\\n            money = num * boardingCost - rotate * runningCost;\\n            if(maxx < money) {maxx = money; ans = rotate;}\\n            i++;\\n\\n        }\\n        if(maxx < 0) return -1;\\n        return ans;\\n    }\\n};\\n```\\n**Python**\\n\\n```\\nimport sys\\nMIN_INT = -sys.maxsize-1\\nclass Solution:\\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\\n        maxx = MIN_INT\\n        rotate = total =  ans = money = num = i = 0\\n        for i in range(len(customers)):\\n            total += customers[i]\\n            rotate = i+1\\n            if total >= 4:\\n                num += 4\\n                total -= 4\\n            else: \\n                num += total\\n                total = 0\\n            money = num * boardingCost - rotate * runningCost\\n            if maxx < money:\\n                maxx = money\\n                ans = rotate\\n        i+=1\\n        while(total > 0):\\n            rotate = i+1\\n            if total >= 4:\\n                num += 4\\n                total -= 4\\n            else: \\n                num += total\\n                total = 0\\n            money = num * boardingCost - rotate * runningCost\\n            if maxx < money:\\n                maxx = money\\n                ans = rotate\\n            i+=1\\n        if maxx < 0: return -1\\n        return ans\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperationsMaxProfit(vector<int>& customers, int boardingCost, int runningCost) {\\n        int rotate = 0, total = 0, money = 0, num = 0, i;\\n\\t\\tint maxx = INT_MIN, ans = rotate;\\n        for(i = 0; i< customers.size(); i++){\\n            total += customers[i];\\n            rotate = i+1;\\n            if(total >= 4) {num += 4; total -= 4;}\\n            else { num += total; total = 0;}\\n            money = num * boardingCost - rotate * runningCost;\\n            if(maxx < money) {maxx = money; ans = rotate;}\\n        }\\n        while(total > 0){\\n            rotate = i+1;\\n            if(total >= 4) {num += 4; total -= 4;}\\n            else { num += total; total = 0;}\\n            money = num * boardingCost - rotate * runningCost;\\n            if(maxx < money) {maxx = money; ans = rotate;}\\n            i++;\\n\\n        }\\n        if(maxx < 0) return -1;\\n        return ans;\\n    }\\n};\\n```\n```\\nimport sys\\nMIN_INT = -sys.maxsize-1\\nclass Solution:\\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\\n        maxx = MIN_INT\\n        rotate = total =  ans = money = num = i = 0\\n        for i in range(len(customers)):\\n            total += customers[i]\\n            rotate = i+1\\n            if total >= 4:\\n                num += 4\\n                total -= 4\\n            else: \\n                num += total\\n                total = 0\\n            money = num * boardingCost - rotate * runningCost\\n            if maxx < money:\\n                maxx = money\\n                ans = rotate\\n        i+=1\\n        while(total > 0):\\n            rotate = i+1\\n            if total >= 4:\\n                num += 4\\n                total -= 4\\n            else: \\n                num += total\\n                total = 0\\n            money = num * boardingCost - rotate * runningCost\\n            if maxx < money:\\n                maxx = money\\n                ans = rotate\\n            i+=1\\n        if maxx < 0: return -1\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 876078,
                "title": "python-easiest-to-understand-imo",
                "content": "We need to keep track of the profit at that iteration and compare it to our max profit. We don\\'t return a value which is not the maxProfit. This is was the case I struggled with.\\n\\n```\\ni = 1 # start at 1\\nwaiting, onBoard, result, maxProfit  = customers[0],  0, -1, 0\\n        while i < len(customers) or waiting > 0:\\n            newToOnboard = min(4, waiting) # get 4 or remainder + current passangers\\n\\n            waiting -= newToOnboard # remove people waiting\\n            onBoard += newToOnboard # add people to go\\n\\n            profit = onBoard*boardingCost - i*runningCost # get profit of all to go\\n\\n            if(profit>maxProfit): # if profit is over max then reset the maxProfit\\n                maxProfit = profit\\n                result = i\\n            if(i<len(customers)): waiting +=customers[i] # stop adding customers once we finish list\\n            i +=  1\\n        return result",
                "solutionTags": [],
                "code": "We need to keep track of the profit at that iteration and compare it to our max profit. We don\\'t return a value which is not the maxProfit. This is was the case I struggled with.\\n\\n```\\ni = 1 # start at 1\\nwaiting, onBoard, result, maxProfit  = customers[0],  0, -1, 0\\n        while i < len(customers) or waiting > 0:\\n            newToOnboard = min(4, waiting) # get 4 or remainder + current passangers\\n\\n            waiting -= newToOnboard # remove people waiting\\n            onBoard += newToOnboard # add people to go\\n\\n            profit = onBoard*boardingCost - i*runningCost # get profit of all to go\\n\\n            if(profit>maxProfit): # if profit is over max then reset the maxProfit\\n                maxProfit = profit\\n                result = i\\n            if(i<len(customers)): waiting +=customers[i] # stop adding customers once we finish list\\n            i +=  1\\n        return result",
                "codeTag": "Unknown"
            },
            {
                "id": 866526,
                "title": "python-simulation",
                "content": "```\\nclass Solution:\\n    def minOperationsMaxProfit(self, arr: List[int], boardingCost : int, runningCost : int) -> int:\\n        # Dividing people in the groups of <=4\\n        grps = []\\n        # length of customers array\\n        n = len(arr)\\n        # rem--> number of people waiting\\n        rem = 0\\n        \\n        # traversing the customers array\\n        for i in range(n):\\n            # total number of people available right now \\n            avail = arr[i]+rem\\n            # number of available people >=4 then append grp of 4 and update remaining [rem]\\n            if avail>=4:\\n                avail-=4\\n                grps.append(4)\\n                rem = avail\\n            # number of available people <4  then make group of available people and update remaining [rem=0]\\n            else:\\n                rem = 0\\n                grps.append(avail)\\n        \\n        # make groups of 4 until remaining >=4 otherwise make <4 and break\\n        while rem>0:\\n            if rem>=4:\\n                rem-=4\\n                grps.append(4)\\n            else:\\n                grps.append(rem)\\n                rem = 0\\n        \\n        # mex--> represents maximum profit\\n        mex = -10**10\\n        # cost--> represents current total cost\\n        cost = 0\\n        # ind --> represents rotation number\\n        ind = 0\\n        for i in range(len(grps)):\\n            # calculate net cost till now\\n            cost+= boardingCost*grps[i]-runningCost\\n            # upadte max profit and rotation number\\n            if mex<cost:\\n                mex = max(mex,cost)\\n                ind = i+1\\n        # max profit< 0\\n        if mex<0:\\n            return -1\\n        # return rotation number\\n        return ind\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minOperationsMaxProfit(self, arr: List[int], boardingCost : int, runningCost : int) -> int:\\n        # Dividing people in the groups of <=4\\n        grps = []\\n        # length of customers array\\n        n = len(arr)\\n        # rem--> number of people waiting\\n        rem = 0\\n        \\n        # traversing the customers array\\n        for i in range(n):\\n            # total number of people available right now \\n            avail = arr[i]+rem\\n            # number of available people >=4 then append grp of 4 and update remaining [rem]\\n            if avail>=4:\\n                avail-=4\\n                grps.append(4)\\n                rem = avail\\n            # number of available people <4  then make group of available people and update remaining [rem=0]\\n            else:\\n                rem = 0\\n                grps.append(avail)\\n        \\n        # make groups of 4 until remaining >=4 otherwise make <4 and break\\n        while rem>0:\\n            if rem>=4:\\n                rem-=4\\n                grps.append(4)\\n            else:\\n                grps.append(rem)\\n                rem = 0\\n        \\n        # mex--> represents maximum profit\\n        mex = -10**10\\n        # cost--> represents current total cost\\n        cost = 0\\n        # ind --> represents rotation number\\n        ind = 0\\n        for i in range(len(grps)):\\n            # calculate net cost till now\\n            cost+= boardingCost*grps[i]-runningCost\\n            # upadte max profit and rotation number\\n            if mex<cost:\\n                mex = max(mex,cost)\\n                ind = i+1\\n        # max profit< 0\\n        if mex<0:\\n            return -1\\n        # return rotation number\\n        return ind\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 866471,
                "title": "java-beats-100-time-and-space",
                "content": "```\\nclass Solution {\\n    public int minOperationsMaxProfit(int[] customers, int boardingCost, int runningCost) {\\n        int i=0,profit=0,extra=0,maxprofit=0,rotations=0,waiting=0;    \\n        while(i<customers.length || extra>0){\\n            waiting=i<customers.length?customers[i]+extra:extra;\\n            profit += Math.min(waiting,4) * boardingCost - runningCost;\\n            rotations = profit>maxprofit? i+1 : rotations;\\n            maxprofit = profit>maxprofit? profit : maxprofit;\\n            extra = waiting>4 ? waiting-4 : 0;\\n            i++;\\n        }\\n        return rotations==0?-1:rotations;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minOperationsMaxProfit(int[] customers, int boardingCost, int runningCost) {\\n        int i=0,profit=0,extra=0,maxprofit=0,rotations=0,waiting=0;    \\n        while(i<customers.length || extra>0){\\n            waiting=i<customers.length?customers[i]+extra:extra;\\n            profit += Math.min(waiting,4) * boardingCost - runningCost;\\n            rotations = profit>maxprofit? i+1 : rotations;\\n            maxprofit = profit>maxprofit? profit : maxprofit;\\n            extra = waiting>4 ? waiting-4 : 0;\\n            i++;\\n        }\\n        return rotations==0?-1:rotations;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 866607,
                "title": "c-o-n-simple-code-explained",
                "content": "\\tHint to try yourselves.\\n\\t1. Accumulate the customers in every rotation and compute the total profit till now.\\n\\t2. Keep the rotation count where max profit occurs.\\n\\t\\n\\tSolution Approach:\\n\\tVariable - 1. currentProfit - keeps track of cumulative profit\\n\\t\\t\\t   2. totalCustomer - updates total customer in queue before the wheel runs once\\n\\t\\t\\t   3. maxProfit - maximum profit till now\\n\\t\\t\\t   4. ans - total number of rotation when maxProfit was encountered\\n\\n\\tCode Explanation:\\n\\tTraverese the array and add the customers[i] to total waiting customer i.e totalCustomer\\n\\tNow after the for loop exits we haave made n number of total rotations.\\n\\tIf there are still customers i.e then board them 4 at once and calculate the profit and keep the max profit.\\n\\tWhereever max profit occurs store that count.\\n\\t\\n\\tExample 1: \\n\\tInput: customers = [10,9,6], boardingCost = 6, runningCost = 4\\n\\t\\n\\ti =0 \\n\\ttotal customer 10 \\n\\tCurrent profit is 4 * $6 - 1 * $4 = $20. max profit = 20 , ans =i+1 =1\\n\\ttotalCustomer=6\\n\\t\\n\\ti=1\\n\\ttotal customer 6+9=15 (6 waiting previously and 9 new arrived) \\n\\t Current profit is 8 * $6 - 2 * $4 = $40.. max profit = 40 , ans =i+1 =2\\n\\t totalCustomer=11\\n\\t \\n\\t i=2\\n\\ttotal customer 11+6=17 (11 waiting previously and 6 new arrived) \\n\\tCurrent profit is 12 * $6 - 3 * $4 = $60.. max profit = 60 , ans =i+1 =3\\n\\ttotalCustomer=13\\n\\t\\n\\tNow the for loop exits\\n\\tfor i=3,4,5 profit keep increasing similarly and totalRotations is 6\\n\\tnow again for i=6 ony 1 person boards the wheel which gives final maximum profit as 122\\n\\tand totalRotations as 7;\\n\\t\\n\\tExample 2;\\n\\tInput: customers = [10,10,6,4,7], boardingCost = 3, runningCost = 8\\n\\tI hope you all have got the logic so lets skip this to  i=8\\n\\tfor 8 the roation profit is 32\\n\\tfor 9 th rotation its 36\\n\\tbut in last as only person boards the wheel profit therfore reduces to 31.\\n\\t\\n\\tSo we return 9 where maximum profit occured.\\n\\t\\n\\tIf profit was never positive return -1;\\n\\n```\\nclass Solution\\n{\\npublic:\\n    int minOperationsMaxProfit(vector<int> &customers, int boardingCost, int runningCost)\\n    {\\n        int n = customers.size(), i;\\n        int currentProfit = 0;\\n        int totalCustomer = 0;\\n        int maxProfit = 0;\\n        int ans = -1;\\n        for (i = 0; i < n; i++)\\n        {\\n            totalCustomer += customers[i];\\n            if (totalCustomer >= 4)\\n            {\\n                totalCustomer -= 4;\\n                currentProfit += 4 * boardingCost - runningCost;\\n                if (currentProfit > maxProfit)\\n                {\\n                    maxProfit = currentProfit;\\n                    ans = i + 1;\\n                }\\n            }\\n            else\\n            {\\n                currentProfit += totalCustomer * boardingCost - runningCost;\\n                totalCustomer = 0;\\n                if (currentProfit > maxProfit)\\n                {\\n                    maxProfit = currentProfit;\\n                    ans = i + 1;\\n                }\\n            }\\n        }\\n        int totalRoatation = n;\\n        while (totalCustomer > 0)\\n        {\\n\\n            if (totalCustomer >= 4)\\n            {\\n                totalCustomer -= 4;\\n                currentProfit += 4 * boardingCost - runningCost;\\n                totalRoatation++;\\n                if (currentProfit > maxProfit)\\n                {\\n                    maxProfit = currentProfit;\\n                    ans = i + 1;\\n                }\\n                i++;\\n            }\\n            else\\n            {\\n                currentProfit += totalCustomer * boardingCost - runningCost;\\n                totalCustomer = 0;\\n                totalRoatation++;\\n                if (currentProfit > maxProfit)\\n                {\\n                    maxProfit = currentProfit;\\n                    ans = i + 1;\\n                }\\n                i++;\\n            }\\n        }\\n        if (currentProfit > 0)\\n            return ans;\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution\\n{\\npublic:\\n    int minOperationsMaxProfit(vector<int> &customers, int boardingCost, int runningCost)\\n    {\\n        int n = customers.size(), i;\\n        int currentProfit = 0;\\n        int totalCustomer = 0;\\n        int maxProfit = 0;\\n        int ans = -1;\\n        for (i = 0; i < n; i++)\\n        {\\n            totalCustomer += customers[i];\\n            if (totalCustomer >= 4)\\n            {\\n                totalCustomer -= 4;\\n                currentProfit += 4 * boardingCost - runningCost;\\n                if (currentProfit > maxProfit)\\n                {\\n                    maxProfit = currentProfit;\\n                    ans = i + 1;\\n                }\\n            }\\n            else\\n            {\\n                currentProfit += totalCustomer * boardingCost - runningCost;\\n                totalCustomer = 0;\\n                if (currentProfit > maxProfit)\\n                {\\n                    maxProfit = currentProfit;\\n                    ans = i + 1;\\n                }\\n            }\\n        }\\n        int totalRoatation = n;\\n        while (totalCustomer > 0)\\n        {\\n\\n            if (totalCustomer >= 4)\\n            {\\n                totalCustomer -= 4;\\n                currentProfit += 4 * boardingCost - runningCost;\\n                totalRoatation++;\\n                if (currentProfit > maxProfit)\\n                {\\n                    maxProfit = currentProfit;\\n                    ans = i + 1;\\n                }\\n                i++;\\n            }\\n            else\\n            {\\n                currentProfit += totalCustomer * boardingCost - runningCost;\\n                totalCustomer = 0;\\n                totalRoatation++;\\n                if (currentProfit > maxProfit)\\n                {\\n                    maxProfit = currentProfit;\\n                    ans = i + 1;\\n                }\\n                i++;\\n            }\\n        }\\n        if (currentProfit > 0)\\n            return ans;\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 866597,
                "title": "java-clear-solution-in-linear-time",
                "content": "Rotate till customers are there or are in waiting. If customer available then add them to waiting count (doing this because we can choose customers from waiting pool as well as customers at current index). Extract at max 4 customers from waiting and update profit and rotate. If profit exceeds max profit update max rotations.\\n```\\nclass Solution {\\n    public int minOperationsMaxProfit(int[] customers, int boardingCost, int runningCost) {\\n        int profit = 0;\\n        int maxProfit = 0;\\n        int rotations = 0;\\n        int maxRotations = -1;\\n        int waiting = 0;\\n        int i = 0;\\n        while (i < customers.length || waiting > 0) {\\n\\t\\t\\t// We can choose customers from waiting pool as well as customers at current index\\n            if (i < customers.length) {\\n                waiting += customers[i++];\\n            }\\n\\t\\t\\t// Try accomodating as much customers (max possible is 4)\\n\\t\\t\\t// If more than 4 available then use 4 else use all of the waiting\\n            int count = (waiting >= 4) ? 4 : waiting;\\n            waiting -= count;\\n            profit += count * boardingCost - runningCost;\\n            rotations++;\\n            if (profit > maxProfit) {\\n                maxProfit = profit;\\n                maxRotations = rotations;\\n            }\\n        }\\n        return maxRotations;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minOperationsMaxProfit(int[] customers, int boardingCost, int runningCost) {\\n        int profit = 0;\\n        int maxProfit = 0;\\n        int rotations = 0;\\n        int maxRotations = -1;\\n        int waiting = 0;\\n        int i = 0;\\n        while (i < customers.length || waiting > 0) {\\n\\t\\t\\t// We can choose customers from waiting pool as well as customers at current index\\n            if (i < customers.length) {\\n                waiting += customers[i++];\\n            }\\n\\t\\t\\t// Try accomodating as much customers (max possible is 4)\\n\\t\\t\\t// If more than 4 available then use 4 else use all of the waiting\\n            int count = (waiting >= 4) ? 4 : waiting;\\n            waiting -= count;\\n            profit += count * boardingCost - runningCost;\\n            rotations++;\\n            if (profit > maxProfit) {\\n                maxProfit = profit;\\n                maxRotations = rotations;\\n            }\\n        }\\n        return maxRotations;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1371844,
                "title": "python-o-n-solution-faster-than-100",
                "content": "**First Observation:** If `boardingCost * 4 <= runningCost`, there is no way to make profit, so return `-1`  \\n  \\n**Second Observation**: Instead of looping with increment of 4 per cycle, if we can directly calculate number of rounds for the given number of *waiting* customers, we can save a lot of time.\\nLet\\'s say there are 18 customers, so number of rounds = `18//4 = 4`, so instead of looping 4 times we can directly update our *rotation count*. But what will be the *waiting count* now? Is it 2?\\n\\n**Third Observation**: Continuing with the above example, by the time we complete our 4 rounds, more customers might have come, so our *waiting count won\\'t be 2*.\\n\\n**Fourth Observation**: We can handle `customers[i : j]` at once using the above technique only iff, *waiting customers* till `j` is greater than minimum number of *waiting customers for index j*.\\nFor Example, `[6, 2, 1, 1, 8, 3]`\\nHere for index 0, `minimum waiting customers = 4` and `waiting customers = 6` , since `6 > 4`, so we can include\\n\\nFor index 1,  `minimum waiting customers = 4+4 = 8` and `waiting customers = 6+2 = 8` so we can include. Remember we are just looking upto which index we can handle at once, we haven\\'t handled them yet.\\n\\nFor index 2  `minimum waiting customers = 4+4+4 = 12` and `waiting customers = 6+2+1 = 9`, since `9 < 12` we will stop here and handle cases upto index 2, i.e, `[6 ,2, 1]`\\nWhich will be 2 rounds with 4 passengers each and 1 more round with 1 passenger.\\n\\nFor index 3, we will reset,  `minimum waiting customers = 4` and  `waiting customers = 1`, since `1 < 4`, we will handle it\\n\\nFor index 4, we will reset,  `minimum waiting customers = 4` and  `waiting customers = 8`, since `8 > 4`, we will include it\\n\\nFor index 5,  `minimum waiting customers = 4+4` and  `waiting customers = 8+3`, since `11 > 4`, we will include it\\n\\nSince customer list is over, we will now handle everything.\\n\\nMake sure to calculate **profit** whenever you handle customers and update accordingly.\\n\\n```python\\nclass Solution:\\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\\n\\t\\t# Our First obsevation\\n        if boardingCost*4 <= runningCost: return -1\\n        \\n        n = len(customers)\\n        count = 0              # To keep track of number of rounds\\n        max_count = 0          # To keep track of round where we had maximum profit\\n        profit = 0             # Profit till now\\n        max_profit = 0         # Maximum Profit till now\\n        i = 0                  # Index of customer list\\n        while i < n:\\n            wait = 0           # We will always start with 0 waiting customers\\n            min_wait = 0       # Minimum waiting count to include\\n\\t\\t\\t\\n\\t\\t\\t# Include all customers[i] until wait >= min_wait\\n            while i < n and wait >= min_wait:\\n                wait += customers[i]\\n                min_wait += 4\\n                i += 1\\n\\t\\t\\t\\t\\n\\t\\t\\t# Calcuate number of rounds and update count and profit\\n            rounds = wait//4\\n            count += rounds\\n            profit += rounds*(4*boardingCost - runningCost)\\n\\t\\t\\t\\n\\t\\t\\t# Update max_profit and max_count if required\\n            if profit > max_profit:\\n                max_profit = profit\\n                max_count = count\\n            \\n\\t\\t\\t# Update waiting customer count\\n            wait %= 4\\n\\t\\t\\t\\n\\t\\t\\t# If some passengers are still waiting, do one more round\\n            if wait > 0 or rounds == 0:\\n                count += 1\\n                profit += wait*boardingCost - runningCost\\n                wait = 0   # No more passengers are waiting,  for sure\\n\\t\\t\\t\\t# Update max_profit and max_count if required\\n                if profit > max_profit:\\n                    max_profit = profit\\n                    max_count = count \\n\\n\\t\\t# If max_count is still 0, then our wheel hasn\\'t moved at all\\n\\t\\t# Return -1 in this case, otherwise return max_count\\n        return max_count if max_count else -1\\n```\\n\\n**Submission details**: Runtime: 900 ms, faster than 100.00% of Python3 online submissions for Maximum Profit of Operating a Centennial Wheel.\\nMemory Usage: 17.8 MB, less than 29.09% of Python3 online submissions for Maximum Profit of Operating a Centennial Wheel.\\n\\nHope it helps you :)",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```python\\nclass Solution:\\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\\n\\t\\t# Our First obsevation\\n        if boardingCost*4 <= runningCost: return -1\\n        \\n        n = len(customers)\\n        count = 0              # To keep track of number of rounds\\n        max_count = 0          # To keep track of round where we had maximum profit\\n        profit = 0             # Profit till now\\n        max_profit = 0         # Maximum Profit till now\\n        i = 0                  # Index of customer list\\n        while i < n:\\n            wait = 0           # We will always start with 0 waiting customers\\n            min_wait = 0       # Minimum waiting count to include\\n\\t\\t\\t\\n\\t\\t\\t# Include all customers[i] until wait >= min_wait\\n            while i < n and wait >= min_wait:\\n                wait += customers[i]\\n                min_wait += 4\\n                i += 1\\n\\t\\t\\t\\t\\n\\t\\t\\t# Calcuate number of rounds and update count and profit\\n            rounds = wait//4\\n            count += rounds\\n            profit += rounds*(4*boardingCost - runningCost)\\n\\t\\t\\t\\n\\t\\t\\t# Update max_profit and max_count if required\\n            if profit > max_profit:\\n                max_profit = profit\\n                max_count = count\\n            \\n\\t\\t\\t# Update waiting customer count\\n            wait %= 4\\n\\t\\t\\t\\n\\t\\t\\t# If some passengers are still waiting, do one more round\\n            if wait > 0 or rounds == 0:\\n                count += 1\\n                profit += wait*boardingCost - runningCost\\n                wait = 0   # No more passengers are waiting,  for sure\\n\\t\\t\\t\\t# Update max_profit and max_count if required\\n                if profit > max_profit:\\n                    max_profit = profit\\n                    max_count = count \\n\\n\\t\\t# If max_count is still 0, then our wheel hasn\\'t moved at all\\n\\t\\t# Return -1 in this case, otherwise return max_count\\n        return max_count if max_count else -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3124803,
                "title": "c-99ms-solution-explained",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nMy intuition for solving this problem is to use a greedy approach\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nI will use a greedy approach to solve this problem. I will iterate through the customers array and for each iteration, I will calculate the maximum number of customers boarded, calculate the profit, and compare it with the current maximum profit. If the calculated profit is higher, I will update the maximum profit and the number of rotations.\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nwhere n is the length of the customers array.\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n#pragma GCC optimize(\"Ofast\",\"inline\",\"fast-math\",\"unroll-loops\",\"no-stack-protector\")\\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,avx2,tune=native\",\"f16c\")\\nstatic const auto fast = []() {ios_base::sync_with_stdio(false); cin.tie(0); cout.tie(0); return 0; } ();class Solution {\\npublic:\\n    int minOperationsMaxProfit(vector<int>& customers, int boardingCost, int runningCost) {\\n        int n = customers.size();\\n        int maxRotations = 0;\\n        int profit = 0;\\n        int rotations = 0;\\n        int waiting = 0;\\n        int maxProfit = 0;\\n        for (int i = 0; i < n || waiting > 0; ++i) {\\n            if (i < n) waiting += customers[i];\\n            profit += boarding(waiting, boardingCost, runningCost);\\n            ++rotations;\\n            if (profit > maxProfit) {\\n                maxProfit = profit;\\n                maxRotations = rotations;\\n            }\\n        }\\n        return maxProfit > 0 ? maxRotations : -1;\\n    }\\n    \\n    int boarding(int& waiting, int boardingCost, int runningCost) {\\n        int board = min(waiting, 4);\\n        waiting -= board;\\n        return board * boardingCost - runningCost;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Simulation"
                ],
                "code": "```\\n#pragma GCC optimize(\"Ofast\",\"inline\",\"fast-math\",\"unroll-loops\",\"no-stack-protector\")\\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,avx2,tune=native\",\"f16c\")\\nstatic const auto fast = []() {ios_base::sync_with_stdio(false); cin.tie(0); cout.tie(0); return 0; } ();class Solution {\\npublic:\\n    int minOperationsMaxProfit(vector<int>& customers, int boardingCost, int runningCost) {\\n        int n = customers.size();\\n        int maxRotations = 0;\\n        int profit = 0;\\n        int rotations = 0;\\n        int waiting = 0;\\n        int maxProfit = 0;\\n        for (int i = 0; i < n || waiting > 0; ++i) {\\n            if (i < n) waiting += customers[i];\\n            profit += boarding(waiting, boardingCost, runningCost);\\n            ++rotations;\\n            if (profit > maxProfit) {\\n                maxProfit = profit;\\n                maxRotations = rotations;\\n            }\\n        }\\n        return maxProfit > 0 ? maxRotations : -1;\\n    }\\n    \\n    int boarding(int& waiting, int boardingCost, int runningCost) {\\n        int board = min(waiting, 4);\\n        waiting -= board;\\n        return board * boardingCost - runningCost;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1358305,
                "title": "java-solution-basic-calculation",
                "content": "```\\nclass Solution {\\n    public int minOperationsMaxProfit(int[] customers, int boardingCost, int runningCost) {\\n        \\n        int len = customers.length;\\n        int waiting = 0;\\n        \\n        int idx = 0;\\n        int max = 0;\\n        int rotation = -1;\\n        int cost = 0;\\n        while(idx < len || waiting > 0)\\n        {\\n            int val = idx < len ? customers[idx] : 0 ;\\n            if(idx < len && customers[idx] > 4)\\n            {\\n                waiting += (val - 4);\\n                val = 4;\\n            }\\n            \\n            if( val < 4 && waiting > 0)\\n            {\\n                int free = 4 - val;\\n                val += waiting >= free ? free : waiting;\\n                waiting = waiting >= free ? waiting - free : 0;\\n            }\\n            \\n            cost = cost +  ((boardingCost * val) - runningCost);\\n            \\n            if(max < cost)\\n            {\\n                max = cost;\\n                rotation = idx+ 1;\\n            }\\n            idx++;\\n        }        \\n        return rotation;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int minOperationsMaxProfit(int[] customers, int boardingCost, int runningCost) {\\n        \\n        int len = customers.length;\\n        int waiting = 0;\\n        \\n        int idx = 0;\\n        int max = 0;\\n        int rotation = -1;\\n        int cost = 0;\\n        while(idx < len || waiting > 0)\\n        {\\n            int val = idx < len ? customers[idx] : 0 ;\\n            if(idx < len && customers[idx] > 4)\\n            {\\n                waiting += (val - 4);\\n                val = 4;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1088901,
                "title": "c-greedy",
                "content": "```\\nclass Solution {\\npublic:\\n    int minOperationsMaxProfit(vector<int>& customers, int boardingCost, int runningCost) {\\n        int x = runningCost / boardingCost;\\n        if(x >= 4) return -1;\\n        \\n        int wait = 0, profit = 0, maxProfit = INT_MIN, ans = -1;\\n        int r = 0;\\n        while(true) {\\n            if(r < customers.size()) wait += customers[r];\\n            int board = min(wait, 4); // Board as many people as possible.\\n            wait -= board;\\n            \\n            profit += board * boardingCost - runningCost;\\n            \\n            if(profit > 0 && profit > maxProfit) {\\n                ans = r+1;\\n                maxProfit = profit;\\n            }\\n            \\n            if(r >= customers.size() && wait == 0) break;\\n            r++;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperationsMaxProfit(vector<int>& customers, int boardingCost, int runningCost) {\\n        int x = runningCost / boardingCost;\\n        if(x >= 4) return -1;\\n        \\n        int wait = 0, profit = 0, maxProfit = INT_MIN, ans = -1;\\n        int r = 0;\\n        while(true) {\\n            if(r < customers.size()) wait += customers[r];\\n            int board = min(wait, 4); // Board as many people as possible.\\n            wait -= board;\\n            \\n            profit += board * boardingCost - runningCost;\\n            \\n            if(profit > 0 && profit > maxProfit) {\\n                ans = r+1;\\n                maxProfit = profit;\\n            }\\n            \\n            if(r >= customers.size() && wait == 0) break;\\n            r++;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 896189,
                "title": "c-simple-approach-as-mentioned-in-the-question",
                "content": "```\\nclass Solution {\\npublic:\\n    int minOperationsMaxProfit(vector<int>& customers, int boardingCost, int runningCost) {\\n        int sum=0,profit=0,count=0,gondola=0;\\n        vector<int> p;\\n        p.push_back(-1);\\n        for(int i=0;i<customers.size();i++)\\n        {\\n            if(customers[i]<=4){gondola+=customers[i];\\n                                customers[i]=0;}\\n            else {\\n                gondola+=4;\\n                customers[i]-=4;\\n                if(i<customers.size()-1)customers[i+1]+=customers[i];\\n            }\\n            count++;\\n            profit=gondola*boardingCost - count*runningCost;\\n            p.push_back(profit);\\n            if(i==customers.size() && customers[i]==0)break;\\n            if(i==customers.size()-1)\\n            {\\n                while(customers[i]>0)\\n                {\\n                    if(customers[i]<=4){\\n                        gondola+=customers[i];\\n                        customers[i]=0;\\n                    }\\n                    else{\\n                    gondola+=4;\\n                    customers[i]-=4;}\\n                    count++;\\n                     profit=gondola*boardingCost - count*runningCost;\\n                    p.push_back(profit);\\n                }\\n            }\\n        }\\n        int maxim=INT_MIN,ans;\\n       if(p.back()<=0)return -1;\\n        else {\\n           for(int j=1;j<p.size();j++) {\\n               if(p[j]>maxim)ans=j;\\n               maxim=max(maxim,p[j]);\\n           }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperationsMaxProfit(vector<int>& customers, int boardingCost, int runningCost) {\\n        int sum=0,profit=0,count=0,gondola=0;\\n        vector<int> p;\\n        p.push_back(-1);\\n        for(int i=0;i<customers.size();i++)\\n        {\\n            if(customers[i]<=4){gondola+=customers[i];\\n                                customers[i]=0;}\\n            else {\\n                gondola+=4;\\n                customers[i]-=4;\\n                if(i<customers.size()-1)customers[i+1]+=customers[i];\\n            }\\n            count++;\\n            profit=gondola*boardingCost - count*runningCost;\\n            p.push_back(profit);\\n            if(i==customers.size() && customers[i]==0)break;\\n            if(i==customers.size()-1)\\n            {\\n                while(customers[i]>0)\\n                {\\n                    if(customers[i]<=4){\\n                        gondola+=customers[i];\\n                        customers[i]=0;\\n                    }\\n                    else{\\n                    gondola+=4;\\n                    customers[i]-=4;}\\n                    count++;\\n                     profit=gondola*boardingCost - count*runningCost;\\n                    p.push_back(profit);\\n                }\\n            }\\n        }\\n        int maxim=INT_MIN,ans;\\n       if(p.back()<=0)return -1;\\n        else {\\n           for(int j=1;j<p.size();j++) {\\n               if(p[j]>maxim)ans=j;\\n               maxim=max(maxim,p[j]);\\n           }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 874943,
                "title": "c-straightforward-simulation-greedy-approach",
                "content": "```\\nclass Solution {\\npublic:\\n    int minOperationsMaxProfit(vector<int>& customers, int boarding_cost, int running_cost) {\\n        int maximum_profit = 0, maximum_profit_run = -1, boarded = 0, waiting = 0;\\n        for (auto i = 0; i < customers.size() || waiting > 0; i++) {\\n            if (i < customers.size()) {\\n                // Add customers arriving just before ith rotation to waiting customers.\\n                waiting += customers[i];\\n            }\\n            \\n            // Update total boarded customers. At most 4 customers can board, but if there are less than 4 customers waiting, then only those will board.\\n            boarded += min(4, waiting);\\n            \\n            // Reduce the number of waiting customers.\\n            waiting = max(0, waiting - 4);\\n            \\n            // Compute the profit after current rotation.\\n            auto current_profit = (boarded * boarding_cost) - ((i + 1) * running_cost);\\n            if (maximum_profit < current_profit) {\\n                maximum_profit = current_profit;\\n                maximum_profit_run = i + 1;\\n            }\\n        }\\n        \\n        // If maximum profit possible is not positive, return -1. Otherwise return the rotation after which profit is maximum.\\n        return maximum_profit > 0 ? maximum_profit_run : -1;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperationsMaxProfit(vector<int>& customers, int boarding_cost, int running_cost) {\\n        int maximum_profit = 0, maximum_profit_run = -1, boarded = 0, waiting = 0;\\n        for (auto i = 0; i < customers.size() || waiting > 0; i++) {\\n            if (i < customers.size()) {\\n                // Add customers arriving just before ith rotation to waiting customers.\\n                waiting += customers[i];\\n            }\\n            \\n            // Update total boarded customers. At most 4 customers can board, but if there are less than 4 customers waiting, then only those will board.\\n            boarded += min(4, waiting);\\n            \\n            // Reduce the number of waiting customers.\\n            waiting = max(0, waiting - 4);\\n            \\n            // Compute the profit after current rotation.\\n            auto current_profit = (boarded * boarding_cost) - ((i + 1) * running_cost);\\n            if (maximum_profit < current_profit) {\\n                maximum_profit = current_profit;\\n                maximum_profit_run = i + 1;\\n            }\\n        }\\n        \\n        // If maximum profit possible is not positive, return -1. Otherwise return the rotation after which profit is maximum.\\n        return maximum_profit > 0 ? maximum_profit_run : -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 869288,
                "title": "python3-simple-simulation-o-n-940ms-100",
                "content": "```\\nclass Solution:\\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\\n        wait = 0\\n        pro = 0\\n        high = 0\\n        res = -1\\n        for i in range(len(customers)):\\n            vacc = 4 - wait\\n            if vacc <= 0:\\n                wait += customers[i] - 4\\n                pro += 4 * boardingCost - runningCost\\n            # board all\\n            elif customers[i] <= vacc: # board=customers[i]+wait\\n                pro += boardingCost * (customers[i] + wait) - runningCost\\n                wait = 0\\n            else:\\n                pro += boardingCost * 4 - runningCost\\n                wait += customers[i] - 4\\n            if pro > high:\\n                high = pro\\n                res = i\\n        # determine after all arrives\\n        pro_per = boardingCost * 4 - runningCost\\n        if pro_per > 0:\\n            last = wait % 4\\n            if wait >= 4:\\n                if boardingCost * last - runningCost > 0: return len(customers) + wait // 4 + 1\\n                else: return len(customers) + wait // 4\\n            if boardingCost * last - runningCost > 0: return len(customers) + 1\\n        return res + 1 if res >= 0 else -1\\n```\\nTwo parts: when customers incoming; after all customers arrived.\\nFor the first part, simple simulation.\\nFor the second part, determine whether profit per round with 4 or fewer (at the very last round) is positive.",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\\n        wait = 0\\n        pro = 0\\n        high = 0\\n        res = -1\\n        for i in range(len(customers)):\\n            vacc = 4 - wait\\n            if vacc <= 0:\\n                wait += customers[i] - 4\\n                pro += 4 * boardingCost - runningCost\\n            # board all\\n            elif customers[i] <= vacc: # board=customers[i]+wait\\n                pro += boardingCost * (customers[i] + wait) - runningCost\\n                wait = 0\\n            else:\\n                pro += boardingCost * 4 - runningCost\\n                wait += customers[i] - 4\\n            if pro > high:\\n                high = pro\\n                res = i\\n        # determine after all arrives\\n        pro_per = boardingCost * 4 - runningCost\\n        if pro_per > 0:\\n            last = wait % 4\\n            if wait >= 4:\\n                if boardingCost * last - runningCost > 0: return len(customers) + wait // 4 + 1\\n                else: return len(customers) + wait // 4\\n            if boardingCost * last - runningCost > 0: return len(customers) + 1\\n        return res + 1 if res >= 0 else -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 867960,
                "title": "java-beats-100-time-and-space",
                "content": "```\\nclass Solution {\\n    public int minOperationsMaxProfit(int[] customers, int boardingCost, int runningCost) {\\n        int profit = 0, peeps = 0, max = 0, maxRotations = -1, iterations = 0;\\n        while (peeps > 0 || iterations < customers.length){\\n            if (iterations < customers.length){\\n                peeps += customers[iterations];\\n            }\\n            int customersToBoard = Math.min(peeps, 4);\\n            profit += customersToBoard * boardingCost - runningCost;\\n            peeps -= customersToBoard;\\n            \\n            iterations++;\\n            if (max < profit){\\n                max = profit;\\n                maxRotations = iterations;\\n            }\\n        }\\n        return maxRotations;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minOperationsMaxProfit(int[] customers, int boardingCost, int runningCost) {\\n        int profit = 0, peeps = 0, max = 0, maxRotations = -1, iterations = 0;\\n        while (peeps > 0 || iterations < customers.length){\\n            if (iterations < customers.length){\\n                peeps += customers[iterations];\\n            }\\n            int customersToBoard = Math.min(peeps, 4);\\n            profit += customersToBoard * boardingCost - runningCost;\\n            peeps -= customersToBoard;\\n            \\n            iterations++;\\n            if (max < profit){\\n                max = profit;\\n                maxRotations = iterations;\\n            }\\n        }\\n        return maxRotations;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 867766,
                "title": "simple-java-greedy-solution-with-description-9ms-single-loop",
                "content": "Till no more new customers are coming we must compute profit (no of waiting customers = 0 and no new customers are coming).\\nStore maxProfit and it\\'s corresponding shift no. Return the shift no corresponding to the maximum profit.\\n```\\nclass Solution {\\n    public int minOperationsMaxProfit(int[] customers, int boardingCost, int runningCost) {\\n        int noWaiting = 0;\\n        int maxProfit = -1;\\n        int profit = -1;\\n        int shifts = 0;\\n        int i = 0;\\n        int maxShifts = -1;\\n        do {\\n            \\n            if(i < customers.length) {\\n                noWaiting += customers[i];\\n                i++;\\n            }\\n            if(noWaiting > 4) {\\n                noWaiting -= 4;\\n                profit += 4 * boardingCost - runningCost;\\n            }\\n            else {\\n                profit += noWaiting * boardingCost - runningCost;\\n                noWaiting = 0;\\n            }\\n            shifts++;\\n            if(profit > maxProfit) {\\n                maxShifts = shifts;\\n                maxProfit = profit;\\n            }\\n        } while(noWaiting > 0 || i < customers.length);\\n        return maxShifts;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minOperationsMaxProfit(int[] customers, int boardingCost, int runningCost) {\\n        int noWaiting = 0;\\n        int maxProfit = -1;\\n        int profit = -1;\\n        int shifts = 0;\\n        int i = 0;\\n        int maxShifts = -1;\\n        do {\\n            \\n            if(i < customers.length) {\\n                noWaiting += customers[i];\\n                i++;\\n            }\\n            if(noWaiting > 4) {\\n                noWaiting -= 4;\\n                profit += 4 * boardingCost - runningCost;\\n            }\\n            else {\\n                profit += noWaiting * boardingCost - runningCost;\\n                noWaiting = 0;\\n            }\\n            shifts++;\\n            if(profit > maxProfit) {\\n                maxShifts = shifts;\\n                maxProfit = profit;\\n            }\\n        } while(noWaiting > 0 || i < customers.length);\\n        return maxShifts;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 867139,
                "title": "java-100-faster",
                "content": "```\\n public static int minOperationsMaxProfit(int[] customers, int boardingCost, int runningCost) {\\n\\n        int maxProfit = -1;\\n        int maxRounds = 0;\\n        int currentProfit = 0;\\n        int currentround = 0;\\n        int prev = 0;\\n        for (int x: customers)\\n        {\\n            if (prev + x <=4)\\n            {\\n                currentProfit += (prev + x) * boardingCost - runningCost;\\n                prev = 0;\\n            }\\n            else {\\n                currentProfit += 4*boardingCost - runningCost;\\n                prev = prev + x - 4;\\n            }\\n            currentround++;\\n            if (maxProfit < currentProfit)\\n            {\\n                maxProfit = currentProfit;\\n                maxRounds = currentround;\\n            }\\n        }\\n\\n        while (prev != 0)\\n        {\\n            if (prev <= 4)\\n            {\\n                currentProfit += prev*boardingCost - runningCost;\\n                prev = 0;\\n            }else\\n            {\\n                currentProfit += 4*boardingCost - runningCost;\\n                prev = prev -4;\\n            }\\n            currentround++;\\n            if (maxProfit < currentProfit)\\n            {\\n                maxProfit = currentProfit;\\n                maxRounds = currentround;\\n            }\\n        }\\n\\n      return maxProfit > 0 ? maxRounds : -1;\\n    }",
                "solutionTags": [],
                "code": "```\\n public static int minOperationsMaxProfit(int[] customers, int boardingCost, int runningCost) {\\n\\n        int maxProfit = -1;\\n        int maxRounds = 0;\\n        int currentProfit = 0;\\n        int currentround = 0;\\n        int prev = 0;\\n        for (int x: customers)\\n        {\\n            if (prev + x <=4)\\n            {\\n                currentProfit += (prev + x) * boardingCost - runningCost;\\n                prev = 0;\\n            }\\n            else {\\n                currentProfit += 4*boardingCost - runningCost;\\n                prev = prev + x - 4;\\n            }\\n            currentround++;\\n            if (maxProfit < currentProfit)\\n            {\\n                maxProfit = currentProfit;\\n                maxRounds = currentround;\\n            }\\n        }\\n\\n        while (prev != 0)\\n        {\\n            if (prev <= 4)\\n            {\\n                currentProfit += prev*boardingCost - runningCost;\\n                prev = 0;\\n            }else\\n            {\\n                currentProfit += 4*boardingCost - runningCost;\\n                prev = prev -4;\\n            }\\n            currentround++;\\n            if (maxProfit < currentProfit)\\n            {\\n                maxProfit = currentProfit;\\n                maxRounds = currentround;\\n            }\\n        }\\n\\n      return maxProfit > 0 ? maxRounds : -1;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 866440,
                "title": "c-o-n",
                "content": "Runtime: 288 ms\\nMemory Usage: 45.6 MB\\n```\\n    public int MinOperationsMaxProfit(int[] customers, int boardingCost, int runningCost) {\\n        \\n        int waiting = 0;\\n        int maxProfit = -1;\\n        int profit = 0;\\n        int rotations = 0;\\n        int result = 0;\\n        int p;\\n        \\n            \\n        for(int i=0; i< customers.Length; i++)\\n        {\\n            waiting += customers[i];\\n            p = (waiting > 4)? 4 : waiting % 4;\\n            waiting -=p;\\n            \\n            profit += p * boardingCost - runningCost;\\n            rotations++;\\n            \\n            if (profit > maxProfit) { maxProfit =  profit; result = rotations; }\\n        }\\n        \\n        if (waiting > 0)\\n        {\\n            int rem = waiting % 4;\\n            int div = waiting / 4;\\n            \\n            if (div > 0)\\n            {\\n                profit += div * (4 * boardingCost - runningCost);\\n                rotations += div; \\n                \\n                if (profit > maxProfit) { maxProfit =  profit; result = rotations; }\\n            }\\n            \\n            if (rem > 0)\\n            {\\n                profit += rem * boardingCost - runningCost;\\n                rotations++; \\n                \\n                if (profit > maxProfit) { maxProfit =  profit; result = rotations; }\\n            }            \\n        }\\n\\n        \\n        return (maxProfit == -1)? -1 : result;\\n    }",
                "solutionTags": [],
                "code": "Runtime: 288 ms\\nMemory Usage: 45.6 MB\\n```\\n    public int MinOperationsMaxProfit(int[] customers, int boardingCost, int runningCost) {\\n        \\n        int waiting = 0;\\n        int maxProfit = -1;\\n        int profit = 0;\\n        int rotations = 0;\\n        int result = 0;\\n        int p;\\n        \\n            \\n        for(int i=0; i< customers.Length; i++)\\n        {\\n            waiting += customers[i];\\n            p = (waiting > 4)? 4 : waiting % 4;\\n            waiting -=p;\\n            \\n            profit += p * boardingCost - runningCost;\\n            rotations++;\\n            \\n            if (profit > maxProfit) { maxProfit =  profit; result = rotations; }\\n        }\\n        \\n        if (waiting > 0)\\n        {\\n            int rem = waiting % 4;\\n            int div = waiting / 4;\\n            \\n            if (div > 0)\\n            {\\n                profit += div * (4 * boardingCost - runningCost);\\n                rotations += div; \\n                \\n                if (profit > maxProfit) { maxProfit =  profit; result = rotations; }\\n            }\\n            \\n            if (rem > 0)\\n            {\\n                profit += rem * boardingCost - runningCost;\\n                rotations++; \\n                \\n                if (profit > maxProfit) { maxProfit =  profit; result = rotations; }\\n            }            \\n        }\\n\\n        \\n        return (maxProfit == -1)? -1 : result;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 866413,
                "title": "c-o-1-space-o-n-time-simple-solution-just-go-through-line-by-line-explanation-added",
                "content": "Intuition:We just want to maximize profit and we want to return minimum number of rounds we need to maximize that profit.\\nSo, There is nothing to worry about this line in problem statement \\'You can stop the wheel at any time, including before serving all customers. If you decide to stop serving customers, all subsequent rotations are free in order to get all the customers down safely. Note that if there are currently more than four customers waiting at the wheel, only four will board the gondola, and the rest will wait for the next rotation.\\'\\nAlgorithm:\\n1.first update total customers in rem variable as remaining+=custumer[i]\\n2.At each step updating total available customers for ride as available+=min(4,remaining),  each step we cannot take more than 4 customers to  our ride so  we use min(4,remaining);\\n3.Subtract the number of customers from total remaining customers.\\n4.Update result.\\n\\n```\\nclass Solution {\\npublic:\\n    int minOperationsMaxProfit(vector<int>& a, int board, int run) {\\n        int n=a.size(),ans=INT_MIN;\\n        int cnt=1; \\n        long long res; //res will keep track of profit at each step;\\n        long long rem=0,tp,h=4; \\n        int ava=0,sub;\\n        for(int i=0;i<n;i++)\\n        {\\n            rem+=a[i]; //rem will keep track of total remaining customers at each step\\n            ava+=min(h,rem); //updating ava ,we cannot add more than 4 customers to our ride;\\n            sub=min(h,rem);  //sub will take care of how many customers we have to subtract from remaining customers.\\n            rem-=sub; //reducing number of remaining customers\\n            res=(ava*board)-(cnt*run); //calculating result.\\n            if(res>ans)\\n            {\\n                ans=res;\\n                tp=cnt; // tp variable will keep track of our required number of rounds for maximum profit.\\n            }\\n            cnt++; //cnt will keep track of number of rounds.\\n        }\\n       while(rem>0) //taking care of remaining customers if any \\n        {\\n           if(rem<=0) break;\\n            ava+=min(h,rem);\\n            sub=min(h,rem);\\n            rem-=sub;\\n            res=(ava*board)-(cnt*run);\\n            if(res>ans)\\n            {\\n                ans=res;\\n                tp=cnt;\\n            }\\n            cnt++;\\n        }\\n        if(ans<=0) return -1;\\n        else return tp;\\n    }\\n};\\n```\\nHope it helps:)",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperationsMaxProfit(vector<int>& a, int board, int run) {\\n        int n=a.size(),ans=INT_MIN;\\n        int cnt=1; \\n        long long res; //res will keep track of profit at each step;\\n        long long rem=0,tp,h=4; \\n        int ava=0,sub;\\n        for(int i=0;i<n;i++)\\n        {\\n            rem+=a[i]; //rem will keep track of total remaining customers at each step\\n            ava+=min(h,rem); //updating ava ,we cannot add more than 4 customers to our ride;\\n            sub=min(h,rem);  //sub will take care of how many customers we have to subtract from remaining customers.\\n            rem-=sub; //reducing number of remaining customers\\n            res=(ava*board)-(cnt*run); //calculating result.\\n            if(res>ans)\\n            {\\n                ans=res;\\n                tp=cnt; // tp variable will keep track of our required number of rounds for maximum profit.\\n            }\\n            cnt++; //cnt will keep track of number of rounds.\\n        }\\n       while(rem>0) //taking care of remaining customers if any \\n        {\\n           if(rem<=0) break;\\n            ava+=min(h,rem);\\n            sub=min(h,rem);\\n            rem-=sub;\\n            res=(ava*board)-(cnt*run);\\n            if(res>ans)\\n            {\\n                ans=res;\\n                tp=cnt;\\n            }\\n            cnt++;\\n        }\\n        if(ans<=0) return -1;\\n        else return tp;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4016368,
                "title": "easy-java-solution-simulation",
                "content": "\\n# Complexity\\n- Time complexity:\\nO(totalCustomers/4);\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minOperationsMaxProfit(int[] customers, int boardingCost, int runningCost) {\\n        int rotatn = 0;\\n        int cust = 0;\\n        int profit = Integer.MIN_VALUE;\\n        int prRotn = 0;\\n        int cSit = 0;\\n\\n        for(int i = 0 ; i < customers.length ; i++){\\n            cust += customers[i];\\n            rotatn++;\\n\\n            int prof = 0;\\n            if(cust >= 4){\\n                \\n                cust = cust - 4;\\n                cSit += 4;\\n            }else{\\n                cSit += cust;\\n                cust = 0;\\n            }\\n            prof = cSit*boardingCost - rotatn*runningCost ;\\n            if(prof > profit){\\n                profit = prof;\\n                prRotn = rotatn;\\n            }  \\n        }\\n        while(cust > 0){\\n            rotatn++;\\n\\n            int prof = 0;\\n            if(cust >= 4){\\n                cust = cust - 4;\\n                cSit += 4;\\n            }else{\\n                cSit += cust;\\n                cust = 0;\\n            }\\n            prof = cSit*boardingCost - rotatn*runningCost ;\\n\\n            if(prof > profit){\\n                profit = prof;\\n\\n                prRotn = rotatn;\\n            } \\n        }\\n        if(profit > 0) return prRotn;\\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Simulation"
                ],
                "code": "```\\nclass Solution {\\n    public int minOperationsMaxProfit(int[] customers, int boardingCost, int runningCost) {\\n        int rotatn = 0;\\n        int cust = 0;\\n        int profit = Integer.MIN_VALUE;\\n        int prRotn = 0;\\n        int cSit = 0;\\n\\n        for(int i = 0 ; i < customers.length ; i++){\\n            cust += customers[i];\\n            rotatn++;\\n\\n            int prof = 0;\\n            if(cust >= 4){\\n                \\n                cust = cust - 4;\\n                cSit += 4;\\n            }else{\\n                cSit += cust;\\n                cust = 0;\\n            }\\n            prof = cSit*boardingCost - rotatn*runningCost ;\\n            if(prof > profit){\\n                profit = prof;\\n                prRotn = rotatn;\\n            }  \\n        }\\n        while(cust > 0){\\n            rotatn++;\\n\\n            int prof = 0;\\n            if(cust >= 4){\\n                cust = cust - 4;\\n                cSit += 4;\\n            }else{\\n                cSit += cust;\\n                cust = 0;\\n            }\\n            prof = cSit*boardingCost - rotatn*runningCost ;\\n\\n            if(prof > profit){\\n                profit = prof;\\n\\n                prRotn = rotatn;\\n            } \\n        }\\n        if(profit > 0) return prRotn;\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4012141,
                "title": "easy-to-understand-javascript-solution",
                "content": "# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```\\nvar minOperationsMaxProfit = function(customers, boardingCost, runningCost) {\\n    const result = { rotate: -1, profit: 0 };\\n    let wait = profit = rotate = 0;\\n\\n    for (const customer of customers) {\\n        wait += customer;\\n        runningWheel();\\n    }\\n    while (wait > 0) runningWheel();\\n\\n    return result.rotate;\\n\\n    function runningWheel() {\\n        rotate += 1;\\n        profit += wait >= 4\\n            ? 4 * boardingCost - runningCost\\n            : wait * boardingCost - runningCost;\\n\\n        wait = Math.max(wait - 4, 0);\\n        if (profit < 0 || result.profit >= profit) return;\\n        result.rotate = rotate;\\n        result.profit = profit;\\n    }\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar minOperationsMaxProfit = function(customers, boardingCost, runningCost) {\\n    const result = { rotate: -1, profit: 0 };\\n    let wait = profit = rotate = 0;\\n\\n    for (const customer of customers) {\\n        wait += customer;\\n        runningWheel();\\n    }\\n    while (wait > 0) runningWheel();\\n\\n    return result.rotate;\\n\\n    function runningWheel() {\\n        rotate += 1;\\n        profit += wait >= 4\\n            ? 4 * boardingCost - runningCost\\n            : wait * boardingCost - runningCost;\\n\\n        wait = Math.max(wait - 4, 0);\\n        if (profit < 0 || result.profit >= profit) return;\\n        result.rotate = rotate;\\n        result.profit = profit;\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3992743,
                "title": "javascript-1599-maximum-profit-of-operating-a-centennial-wheel",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nDo as problem suggests\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n\\n```\\nvar minOperationsMaxProfit = function (customers, boardingCost, runningCost) {\\n  const n = customers.length\\n  let maxRotations = 0\\n  let waitingCustomers = 0\\n  let currentProfit = 0\\n  let maxProfit = 0\\n\\n  for (let rotation = 1; rotation <= n || waitingCustomers > 0; rotation++) {\\n    if (rotation <= n) {\\n      waitingCustomers += customers[rotation - 1]\\n    }\\n    const boardedRiders = Math.min(waitingCustomers, 4)\\n    waitingCustomers -= boardedRiders\\n    currentProfit += boardedRiders * boardingCost - runningCost\\n\\n    if (currentProfit > maxProfit) {\\n      maxProfit = currentProfit\\n      maxRotations = rotation\\n    }\\n  }\\n\\n  return maxRotations || -1\\n}\\n```\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar minOperationsMaxProfit = function (customers, boardingCost, runningCost) {\\n  const n = customers.length\\n  let maxRotations = 0\\n  let waitingCustomers = 0\\n  let currentProfit = 0\\n  let maxProfit = 0\\n\\n  for (let rotation = 1; rotation <= n || waitingCustomers > 0; rotation++) {\\n    if (rotation <= n) {\\n      waitingCustomers += customers[rotation - 1]\\n    }\\n    const boardedRiders = Math.min(waitingCustomers, 4)\\n    waitingCustomers -= boardedRiders\\n    currentProfit += boardedRiders * boardingCost - runningCost\\n\\n    if (currentProfit > maxProfit) {\\n      maxProfit = currentProfit\\n      maxRotations = rotation\\n    }\\n  }\\n\\n  return maxRotations || -1\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3968662,
                "title": "c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n public:\\n  int minOperationsMaxProfit(vector<int>& customers, int boardingCost,\\n                             int runningCost) {\\n    int waiting = 0;\\n    int profit = 0;\\n    int maxProfit = 0;\\n    int rotate = 0;\\n    int maxRotate = -1;\\n    int i = 0;\\n\\n    while (waiting > 0 || i < customers.size()) {\\n      if (i < customers.size())\\n        waiting += customers[i++];\\n      // Onboard new customers\\n      const int newOnboard = min(waiting, 4);\\n      waiting -= newOnboard;\\n      profit += newOnboard * boardingCost - runningCost;\\n      ++rotate;\\n      if (profit > maxProfit) {\\n        maxProfit = profit;\\n        maxRotate = rotate;\\n      }\\n    }\\n\\n    return maxRotate;\\n  }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n public:\\n  int minOperationsMaxProfit(vector<int>& customers, int boardingCost,\\n                             int runningCost) {\\n    int waiting = 0;\\n    int profit = 0;\\n    int maxProfit = 0;\\n    int rotate = 0;\\n    int maxRotate = -1;\\n    int i = 0;\\n\\n    while (waiting > 0 || i < customers.size()) {\\n      if (i < customers.size())\\n        waiting += customers[i++];\\n      // Onboard new customers\\n      const int newOnboard = min(waiting, 4);\\n      waiting -= newOnboard;\\n      profit += newOnboard * boardingCost - runningCost;\\n      ++rotate;\\n      if (profit > maxProfit) {\\n        maxProfit = profit;\\n        maxRotate = rotate;\\n      }\\n    }\\n\\n    return maxRotate;\\n  }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3852855,
                "title": "c-faster-than-100ms-clean-explanation-nice-variable-naming",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int minOperationsMaxProfit(vector<int>& customers, int boardingCost, int runningCost) {\\n        // Intution\\n        // The idea in here is really very simple. We will maintain the variable to keep track of baorded customers and also we will keep the number of rotations made till now. At any instance we can stop the gondola so we will at every position check if the profit is maximum or not. If the profit at the index is max then we will change the current index to the number which we obtained now. We need to keep track of waiting number of customers and every time we will board a minimum of waiting and the board and the current profit earned will be the number of persons enjoyed the rotation and the number of times wheel was rotated for running the gondon.\\n\\n        \\n        // This is used to store max profit earned till now\\n\\n        int profit = INT_MIN;\\n\\n        // This is used to store the optimal number of moves\\n\\n        int optimal = -1;\\n\\n        // Variable to store number of waiting customers\\n\\n        int waiting = 0;\\n\\n        // Variable to stores number of rotations made\\n        int number = 1;\\n\\n        // Vairable to store boarded number of customers\\n        int boarded = 0;\\n\\n        // Looping and checking if at the current turn we can obtain max answer\\n        for(auto &cust : customers){\\n            waiting += cust;\\n            boarded += min(4, waiting);\\n            int currProfit = boarded * boardingCost - number * runningCost;\\n            if(currProfit > profit){\\n                profit = currProfit;\\n                optimal = number;\\n            }\\n            waiting -= min(4, waiting);\\n            number += 1;\\n        }\\n\\n        // Also, checking for the waiting customers\\n\\n        while(waiting > 0){\\n            boarded += min(4, waiting);\\n            int currProfit = boarded * boardingCost - number * runningCost;\\n            if(currProfit > profit){\\n                profit = currProfit;\\n                optimal = number;\\n            }\\n            waiting -= min(4, waiting);\\n            number += 1;\\n        }\\n\\n        return profit > 0 ? optimal : -1;\\n\\n    }\\n};\\n```\\n**Please upvote if you like the solution.**\\n![Screenshot 2023-08-02 at 4.49.00 PM.png](https://assets.leetcode.com/users/images/3b8a4366-0dc8-4c18-a11d-b1b23d1539c7_1690975213.9889958.png)\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperationsMaxProfit(vector<int>& customers, int boardingCost, int runningCost) {\\n        // Intution\\n        // The idea in here is really very simple. We will maintain the variable to keep track of baorded customers and also we will keep the number of rotations made till now. At any instance we can stop the gondola so we will at every position check if the profit is maximum or not. If the profit at the index is max then we will change the current index to the number which we obtained now. We need to keep track of waiting number of customers and every time we will board a minimum of waiting and the board and the current profit earned will be the number of persons enjoyed the rotation and the number of times wheel was rotated for running the gondon.\\n\\n        \\n        // This is used to store max profit earned till now\\n\\n        int profit = INT_MIN;\\n\\n        // This is used to store the optimal number of moves\\n\\n        int optimal = -1;\\n\\n        // Variable to store number of waiting customers\\n\\n        int waiting = 0;\\n\\n        // Variable to stores number of rotations made\\n        int number = 1;\\n\\n        // Vairable to store boarded number of customers\\n        int boarded = 0;\\n\\n        // Looping and checking if at the current turn we can obtain max answer\\n        for(auto &cust : customers){\\n            waiting += cust;\\n            boarded += min(4, waiting);\\n            int currProfit = boarded * boardingCost - number * runningCost;\\n            if(currProfit > profit){\\n                profit = currProfit;\\n                optimal = number;\\n            }\\n            waiting -= min(4, waiting);\\n            number += 1;\\n        }\\n\\n        // Also, checking for the waiting customers\\n\\n        while(waiting > 0){\\n            boarded += min(4, waiting);\\n            int currProfit = boarded * boardingCost - number * runningCost;\\n            if(currProfit > profit){\\n                profit = currProfit;\\n                optimal = number;\\n            }\\n            waiting -= min(4, waiting);\\n            number += 1;\\n        }\\n\\n        return profit > 0 ? optimal : -1;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3788148,
                "title": "java-solution-faster-than-90",
                "content": "# Intuition\\nNeed to calculate the the profit at each step.\\n\\n# Approach\\n1)Calculate the profit at step for max people and pass rest to next index\\n2)do it till last index\\n3)then for people of last index calculate people/4 and people%4\\nbecause last remaining people may reduce the profit\\n4)at each point note max ans and at that point nos of rotation and according to that the point when it was max rotation is need to be returned\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\n    public int minOperationsMaxProfit(int[] cus, int board, int run) {\\n        if(4*board<run)return -1;\\n        int ans=0,max=0,ro=0,anro=0;\\n        for(int i=0;i<cus.length-1;i++)\\n        {\\n            int t=cus[i];\\n            if(t>4){cus[i+1]+=cus[i]-4;cus[i]=4;}\\n            ans+=(cus[i]*board)-(run);\\n            int o=max;ro++;\\n            max=Math.max(max,ans);\\n            if(o!=max){anro=ro;}\\n            \\n        }\\n        System.out.print(anro);\\n        int h=cus[cus.length-1];\\nif(h>0)\\n{\\n    int j=h/4;\\n    if((h%4)==0){ans+=(4*j*board)-(j*run);ro+=j;if(ans>max){anro=ro;}}\\n    else{\\n        if(h<4){ans+=(h*board)-(run);ro++;if(ans>max){anro=ro;}}\\n        else{\\n            ans+=(4*j*board)-(j*run);\\n            ro+=j;if(ans>max){anro=ro;}\\n            int g=h%4;\\n            ans+=(g*board)-run;\\n            if(((g*board)-run)>0)ro++;\\n            if(ans>max){anro=ro;}\\n        }\\n    }\\n}\\n\\nreturn anro==0?-1:anro;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minOperationsMaxProfit(int[] cus, int board, int run) {\\n        if(4*board<run)return -1;\\n        int ans=0,max=0,ro=0,anro=0;\\n        for(int i=0;i<cus.length-1;i++)\\n        {\\n            int t=cus[i];\\n            if(t>4){cus[i+1]+=cus[i]-4;cus[i]=4;}\\n            ans+=(cus[i]*board)-(run);\\n            int o=max;ro++;\\n            max=Math.max(max,ans);\\n            if(o!=max){anro=ro;}\\n            \\n        }\\n        System.out.print(anro);\\n        int h=cus[cus.length-1];\\nif(h>0)\\n{\\n    int j=h/4;\\n    if((h%4)==0){ans+=(4*j*board)-(j*run);ro+=j;if(ans>max){anro=ro;}}\\n    else{\\n        if(h<4){ans+=(h*board)-(run);ro++;if(ans>max){anro=ro;}}\\n        else{\\n            ans+=(4*j*board)-(j*run);\\n            ro+=j;if(ans>max){anro=ro;}\\n            int g=h%4;\\n            ans+=(g*board)-run;\\n            if(((g*board)-run)>0)ro++;\\n            if(ans>max){anro=ro;}\\n        }\\n    }\\n}\\n\\nreturn anro==0?-1:anro;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3788147,
                "title": "java-solution-faster-than-90",
                "content": "# Intuition\\nNeed to calculate the the profit at each step.\\n\\n# Approach\\n1)Calculate the profit at step for max people and pass rest to next index\\n2)do it till last index\\n3)then for people of last index calculate people/4 and people%4\\nbecause last remaining people may reduce the profit\\n4)at each point note max ans and at that point nos of rotation and according to that the point when it was max rotation is need to be returned\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\n    public int minOperationsMaxProfit(int[] cus, int board, int run) {\\n        if(4*board<run)return -1;\\n        int ans=0,max=0,ro=0,anro=0;\\n        for(int i=0;i<cus.length-1;i++)\\n        {\\n            int t=cus[i];\\n            if(t>4){cus[i+1]+=cus[i]-4;cus[i]=4;}\\n            ans+=(cus[i]*board)-(run);\\n            int o=max;ro++;\\n            max=Math.max(max,ans);\\n            if(o!=max){anro=ro;}\\n            \\n        }\\n        System.out.print(anro);\\n        int h=cus[cus.length-1];\\nif(h>0)\\n{\\n    int j=h/4;\\n    if((h%4)==0){ans+=(4*j*board)-(j*run);ro+=j;if(ans>max){anro=ro;}}\\n    else{\\n        if(h<4){ans+=(h*board)-(run);ro++;if(ans>max){anro=ro;}}\\n        else{\\n            ans+=(4*j*board)-(j*run);\\n            ro+=j;if(ans>max){anro=ro;}\\n            int g=h%4;\\n            ans+=(g*board)-run;\\n            if(((g*board)-run)>0)ro++;\\n            if(ans>max){anro=ro;}\\n        }\\n    }\\n}\\n\\nreturn anro==0?-1:anro;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minOperationsMaxProfit(int[] cus, int board, int run) {\\n        if(4*board<run)return -1;\\n        int ans=0,max=0,ro=0,anro=0;\\n        for(int i=0;i<cus.length-1;i++)\\n        {\\n            int t=cus[i];\\n            if(t>4){cus[i+1]+=cus[i]-4;cus[i]=4;}\\n            ans+=(cus[i]*board)-(run);\\n            int o=max;ro++;\\n            max=Math.max(max,ans);\\n            if(o!=max){anro=ro;}\\n            \\n        }\\n        System.out.print(anro);\\n        int h=cus[cus.length-1];\\nif(h>0)\\n{\\n    int j=h/4;\\n    if((h%4)==0){ans+=(4*j*board)-(j*run);ro+=j;if(ans>max){anro=ro;}}\\n    else{\\n        if(h<4){ans+=(h*board)-(run);ro++;if(ans>max){anro=ro;}}\\n        else{\\n            ans+=(4*j*board)-(j*run);\\n            ro+=j;if(ans>max){anro=ro;}\\n            int g=h%4;\\n            ans+=(g*board)-run;\\n            if(((g*board)-run)>0)ro++;\\n            if(ans>max){anro=ro;}\\n        }\\n    }\\n}\\n\\nreturn anro==0?-1:anro;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3688726,
                "title": "python3-o-n-simplest-simulation-beats-90-users-simple-and-elegant",
                "content": "```\\nclass Solution:\\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\\n        maxProfit=-1\\n        ans=i=curRounds=curCustomers=rem=0\\n        while i<len(customers) or rem:\\n            if i<len(customers):\\n                rem+=customers[i]\\n                i+=1\\n            curRounds+=1\\n            if rem-4>=0:\\n                rem-=4\\n                curCustomers+=4\\n            else:\\n                curCustomers+=rem\\n                rem=0\\n            curProfit=(curCustomers*boardingCost)-(curRounds*runningCost)\\n            if curProfit>maxProfit:\\n                maxProfit=curProfit\\n                ans=curRounds\\n        return -1 if maxProfit<=0 else ans\\n```",
                "solutionTags": [
                    "Python3",
                    "Simulation"
                ],
                "code": "```\\nclass Solution:\\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\\n        maxProfit=-1\\n        ans=i=curRounds=curCustomers=rem=0\\n        while i<len(customers) or rem:\\n            if i<len(customers):\\n                rem+=customers[i]\\n                i+=1\\n            curRounds+=1\\n            if rem-4>=0:\\n                rem-=4\\n                curCustomers+=4\\n            else:\\n                curCustomers+=rem\\n                rem=0\\n            curProfit=(curCustomers*boardingCost)-(curRounds*runningCost)\\n            if curProfit>maxProfit:\\n                maxProfit=curProfit\\n                ans=curRounds\\n        return -1 if maxProfit<=0 else ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3573104,
                "title": "simple-rust-solution-using-simulation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe basic idea is to simulate the rotations of the wheel based on the number of customers. We will also keep track of the maximum profit we encounter across this entire simulation.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe create variables to keep track of the number of customers waiting `num_waiting`, maximum profit encountered `max_profit`, the rotation count where we encouter this maximum profit `rotations_where_max_profit`, as well as the current total profit `profit` and current rotation count `rotations`.\\n\\nWe then create a while loop which terminates only when we account for all customers, which means we must both have exceeded the length of the customer vector and have the number of customers waiting be 0 to exit the loop.\\n\\nWithin this loop, we simply find the number of customers we can board (upto 4) and calculate the profit based on this number. If the profit exceeds our previously seen maximum profit, we update both the rotation count where this happens as well as the maximum profit number. We return the rotation count where we encoutered the maximum profit (or -1 if we never see a profit).\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(c)$$ where c is the total number of customers (sum of customers vector)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(1)$$\\n\\n# Code\\n```\\nimpl Solution {\\n    pub fn min_operations_max_profit(customers: Vec<i32>, boarding_cost: i32, running_cost: i32) -> i32 {\\n        let mut num_waiting: i32 = customers[0];\\n        let mut max_profit: i32 = 0;\\n        let mut rotations_where_max_profit: i32 = -1;\\n        let mut profit: i32 = 0;\\n        let mut rotations: usize = 1;\\n\\n        while rotations < customers.len() || num_waiting > 0 {\\n            \\n            let num_boarding = std::cmp::min(4, num_waiting);\\n            num_waiting -= num_boarding;\\n            profit += boarding_cost * num_boarding - running_cost;\\n            \\n            if profit > max_profit {\\n                rotations_where_max_profit = rotations as i32;\\n                max_profit = profit;\\n            }\\n\\n            if rotations < customers.len() {\\n                num_waiting += customers[rotations];\\n            }\\n            rotations += 1;\\n        }\\n        return rotations_where_max_profit;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust",
                    "Simulation"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn min_operations_max_profit(customers: Vec<i32>, boarding_cost: i32, running_cost: i32) -> i32 {\\n        let mut num_waiting: i32 = customers[0];\\n        let mut max_profit: i32 = 0;\\n        let mut rotations_where_max_profit: i32 = -1;\\n        let mut profit: i32 = 0;\\n        let mut rotations: usize = 1;\\n\\n        while rotations < customers.len() || num_waiting > 0 {\\n            \\n            let num_boarding = std::cmp::min(4, num_waiting);\\n            num_waiting -= num_boarding;\\n            profit += boarding_cost * num_boarding - running_cost;\\n            \\n            if profit > max_profit {\\n                rotations_where_max_profit = rotations as i32;\\n                max_profit = profit;\\n            }\\n\\n            if rotations < customers.len() {\\n                num_waiting += customers[rotations];\\n            }\\n            rotations += 1;\\n        }\\n        return rotations_where_max_profit;\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3391513,
                "title": "board-passengers-only-when-it-is-possible",
                "content": "# Intuition\\nParse through all the inputs.\\n\\nBoard only when it is profitable (onboarding n people makes more money than it costs to run the wheel).\\n\\n# Code\\n```\\nclass Solution:\\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\\n        result = -1\\n        profit = 0\\n        max_profit = 0\\n        waiting = 0\\n        for i,c in enumerate(customers):\\n            waiting += c\\n            boarding = 0\\n            if waiting >=4:\\n                boarding = 4\\n            else:\\n                boarding = waiting\\n            if boarding*boardingCost > runningCost:\\n                waiting -= boarding\\n                profit += (boarding*boardingCost) - runningCost\\n                if profit > max_profit:\\n                    max_profit = profit\\n                    result = i+1\\n        q, r = divmod(waiting, 4)\\n        if 4*boardingCost > runningCost: result += q\\n        if r*boardingCost > runningCost: result += 1\\n        return result\\n                \\n        \\n                \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\\n        result = -1\\n        profit = 0\\n        max_profit = 0\\n        waiting = 0\\n        for i,c in enumerate(customers):\\n            waiting += c\\n            boarding = 0\\n            if waiting >=4:\\n                boarding = 4\\n            else:\\n                boarding = waiting\\n            if boarding*boardingCost > runningCost:\\n                waiting -= boarding\\n                profit += (boarding*boardingCost) - runningCost\\n                if profit > max_profit:\\n                    max_profit = profit\\n                    result = i+1\\n        q, r = divmod(waiting, 4)\\n        if 4*boardingCost > runningCost: result += q\\n        if r*boardingCost > runningCost: result += 1\\n        return result\\n                \\n        \\n                \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3355705,
                "title": "beats-100-memory",
                "content": "# Code\\n```\\nfunction minOperationsMaxProfit(customers: number[], boardingCost: number, runningCost: number): number {\\n  let profit = 0;\\n  let maxProfitRound = -1;\\n  let maxProfit = -Infinity;\\n  let round = 1\\n  while (true) {\\n    let toBoard = 0\\n    const maybeBoard = customers.shift()\\n    if (maybeBoard) {\\n      toBoard = Math.min(maybeBoard, 4)\\n      const rest = maybeBoard - toBoard\\n      if (rest > 0) {\\n        if (typeof customers[0] == \"number\") {\\n          customers[0] += rest\\n        } else {\\n          customers.push(rest)\\n        }\\n      }\\n      profit += boardingCost * toBoard\\n    }\\n    profit -= runningCost\\n    if (profit > 0 && maxProfit < profit) {\\n      maxProfit = profit\\n      maxProfitRound = round\\n    }\\n    round++\\n    if (customers.length === 0) break;\\n  }\\n  return maxProfitRound\\n};\\n\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\nfunction minOperationsMaxProfit(customers: number[], boardingCost: number, runningCost: number): number {\\n  let profit = 0;\\n  let maxProfitRound = -1;\\n  let maxProfit = -Infinity;\\n  let round = 1\\n  while (true) {\\n    let toBoard = 0\\n    const maybeBoard = customers.shift()\\n    if (maybeBoard) {\\n      toBoard = Math.min(maybeBoard, 4)\\n      const rest = maybeBoard - toBoard\\n      if (rest > 0) {\\n        if (typeof customers[0] == \"number\") {\\n          customers[0] += rest\\n        } else {\\n          customers.push(rest)\\n        }\\n      }\\n      profit += boardingCost * toBoard\\n    }\\n    profit -= runningCost\\n    if (profit > 0 && maxProfit < profit) {\\n      maxProfit = profit\\n      maxProfitRound = round\\n    }\\n    round++\\n    if (customers.length === 0) break;\\n  }\\n  return maxProfitRound\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3259000,
                "title": "lc-1599-m-python3-a-plain-solution",
                "content": "Determine the actual length of the customers\\' queue, and then use the iteration. (This approach is straightforward but not fast.)\\n\\n```python3 []\\nclass Solution:\\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\\n        if 4 * boardingCost < runningCost:\\n            return -1\\n        \\n        more_than_once = list(filter(lambda x: x > 4, customers))\\n        customers += [0] * (ceil(sum(more_than_once)/4) - len(more_than_once))\\n        n = len(customers)\\n        total_profit = max_profit = min(customers[0], 4) * boardingCost - runningCost\\n        if n > 1:\\n            customers[1] += max(0, customers[0]-4)\\n\\n        res = 1\\n        for i in range(1, n):\\n            profit = min(customers[i], 4) * boardingCost - runningCost\\n            total_profit += profit\\n            if i + 1 < n:\\n                customers[i+1] += max(0, customers[i]-4)\\n            if total_profit > max_profit:\\n                max_profit = total_profit\\n                res = i + 1\\n        \\n        return res if max_profit > 0 else -1\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```python3 []\\nclass Solution:\\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\\n        if 4 * boardingCost < runningCost:\\n            return -1\\n        \\n        more_than_once = list(filter(lambda x: x > 4, customers))\\n        customers += [0] * (ceil(sum(more_than_once)/4) - len(more_than_once))\\n        n = len(customers)\\n        total_profit = max_profit = min(customers[0], 4) * boardingCost - runningCost\\n        if n > 1:\\n            customers[1] += max(0, customers[0]-4)\\n\\n        res = 1\\n        for i in range(1, n):\\n            profit = min(customers[i], 4) * boardingCost - runningCost\\n            total_profit += profit\\n            if i + 1 < n:\\n                customers[i+1] += max(0, customers[i]-4)\\n            if total_profit > max_profit:\\n                max_profit = total_profit\\n                res = i + 1\\n        \\n        return res if max_profit > 0 else -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3255475,
                "title": "python-simple-maths",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def minOperationsMaxProfit(self, customers, boardingCost, runningCost):\\n        n, profit, i, waiting, max_val, max_valAt = len(customers), 0, 0, 0, 0, 0\\n\\n        while (waiting > 0 or i < n):\\n            if i < n:\\n                waiting += customers[i]\\n            \\n            min_val = min(4,waiting)\\n            profit += min_val*boardingCost - runningCost\\n            waiting -= min_val\\n\\n            if profit > max_val:\\n                max_val = profit\\n                max_valAt = i + 1\\n\\n            i += 1\\n\\n        return max_valAt if max_valAt > 0 else -1\\n\\n\\n\\n\\n\\n\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minOperationsMaxProfit(self, customers, boardingCost, runningCost):\\n        n, profit, i, waiting, max_val, max_valAt = len(customers), 0, 0, 0, 0, 0\\n\\n        while (waiting > 0 or i < n):\\n            if i < n:\\n                waiting += customers[i]\\n            \\n            min_val = min(4,waiting)\\n            profit += min_val*boardingCost - runningCost\\n            waiting -= min_val\\n\\n            if profit > max_val:\\n                max_val = profit\\n                max_valAt = i + 1\\n\\n            i += 1\\n\\n        return max_valAt if max_valAt > 0 else -1\\n\\n\\n\\n\\n\\n\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3175264,
                "title": "just-a-runnable-solution",
                "content": "# Code\\n```\\nimpl Solution {\\n    pub fn min_operations_max_profit(customers: Vec<i32>, boarding_cost: i32, running_cost: i32) -> i32 {\\n        let mut profit = 0;\\n        let mut max_profit = 0;\\n        let mut max_profit_rotation = 0;\\n        let mut waiting = 0;\\n        for (i, &c) in customers.iter().enumerate() {\\n            waiting += c;\\n            let boarding = std::cmp::min(waiting, 4);\\n            waiting -= boarding;\\n            profit += boarding * boarding_cost - running_cost;\\n            if profit > max_profit {\\n                max_profit = profit;\\n                max_profit_rotation = i as i32 + 1;\\n            }\\n        }\\n        let mut i = customers.len() as i32;\\n        while waiting > 0 {\\n            let boarding = std::cmp::min(waiting, 4);\\n            waiting -= boarding;\\n            profit += boarding * boarding_cost - running_cost;\\n            i += 1;\\n            if profit > max_profit {\\n                max_profit = profit;\\n                max_profit_rotation = i;\\n            }\\n        }\\n        if max_profit > 0 {\\n            max_profit_rotation\\n        } else {\\n            -1\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn min_operations_max_profit(customers: Vec<i32>, boarding_cost: i32, running_cost: i32) -> i32 {\\n        let mut profit = 0;\\n        let mut max_profit = 0;\\n        let mut max_profit_rotation = 0;\\n        let mut waiting = 0;\\n        for (i, &c) in customers.iter().enumerate() {\\n            waiting += c;\\n            let boarding = std::cmp::min(waiting, 4);\\n            waiting -= boarding;\\n            profit += boarding * boarding_cost - running_cost;\\n            if profit > max_profit {\\n                max_profit = profit;\\n                max_profit_rotation = i as i32 + 1;\\n            }\\n        }\\n        let mut i = customers.len() as i32;\\n        while waiting > 0 {\\n            let boarding = std::cmp::min(waiting, 4);\\n            waiting -= boarding;\\n            profit += boarding * boarding_cost - running_cost;\\n            i += 1;\\n            if profit > max_profit {\\n                max_profit = profit;\\n                max_profit_rotation = i;\\n            }\\n        }\\n        if max_profit > 0 {\\n            max_profit_rotation\\n        } else {\\n            -1\\n        }\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2992772,
                "title": "wa-can-someone-help",
                "content": "Can someone explain what I may be doing wrong?\\nhttps://leetcode.com/submissions/detail/870460598/",
                "solutionTags": [],
                "code": "",
                "codeTag": "Unknown"
            },
            {
                "id": 2600023,
                "title": "python-solution",
                "content": "```\\ndef minOperationsMaxProfit(self, nums: List[int], c1: int, c2: int) -> int:\\n\\tpre, nums = 0, deque(nums)\\n\\tcur_pro, cur_n, ans_pro, ans_n = 0, 0, 0, -1\\n\\twhile(pre>0 or nums):\\n\\t\\tcur_n += 1\\n\\t\\tif nums:\\n\\t\\t\\tpre += nums.popleft()\\n\\t\\tk = min(4, pre)\\n\\t\\tpre -= k\\n\\t\\tcur_pro += (c1*k-c2)\\n\\t\\tif cur_pro > ans_pro:\\n\\t\\t\\tans_pro, ans_n = cur_pro, cur_n\\n\\treturn ans_n if ans_pro else -1\\n```",
                "solutionTags": [],
                "code": "```\\ndef minOperationsMaxProfit(self, nums: List[int], c1: int, c2: int) -> int:\\n\\tpre, nums = 0, deque(nums)\\n\\tcur_pro, cur_n, ans_pro, ans_n = 0, 0, 0, -1\\n\\twhile(pre>0 or nums):\\n\\t\\tcur_n += 1\\n\\t\\tif nums:\\n\\t\\t\\tpre += nums.popleft()\\n\\t\\tk = min(4, pre)\\n\\t\\tpre -= k\\n\\t\\tcur_pro += (c1*k-c2)\\n\\t\\tif cur_pro > ans_pro:\\n\\t\\t\\tans_pro, ans_n = cur_pro, cur_n\\n\\treturn ans_n if ans_pro else -1\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2511851,
                "title": "c-solution-runtime-100-faster-memory-100-less",
                "content": "```\\npublic class Solution {\\n    public int MinOperationsMaxProfit(int[] customers, int boardingCost, int runningCost) {\\n        int group = 0;\\n        int totalRotations = 1;\\n        int currentProfit = 0;\\n        (int rotation, int profit) best = (0,0);\\n        \\n        // if enough customers have arrived, we can do multiple groups to make 4 people\\n        while (group < customers.Length) {\\n            var boardingNumber = 0;\\n            if (customers[group] > 4){\\n                boardingNumber = 4;\\n                customers[group]-= boardingNumber;\\n            } else {\\n                boardingNumber = customers[group];\\n                group++;\\n\\n                while (group < totalRotations && group < customers.Length && boardingNumber < 4){\\n                    if (customers[group] > 0) { \\n                        customers[group]--;\\n                        boardingNumber++;\\n                    }\\n                    if (customers[group] == 0)\\n                        group++;\\n                }\\n            }\\n            \\n            currentProfit+= (boardingCost * boardingNumber - runningCost);\\n            \\n            if (currentProfit > best.profit)\\n                best = (totalRotations, currentProfit);\\n            \\n            totalRotations++;\\n        }\\n        \\n        return best.rotation > 0 ? best.rotation : -1;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int MinOperationsMaxProfit(int[] customers, int boardingCost, int runningCost) {\\n        int group = 0;\\n        int totalRotations = 1;\\n        int currentProfit = 0;\\n        (int rotation, int profit) best = (0,0);\\n        \\n        // if enough customers have arrived, we can do multiple groups to make 4 people\\n        while (group < customers.Length) {\\n            var boardingNumber = 0;\\n            if (customers[group] > 4){\\n                boardingNumber = 4;\\n                customers[group]-= boardingNumber;\\n            } else {\\n                boardingNumber = customers[group];\\n                group++;\\n\\n                while (group < totalRotations && group < customers.Length && boardingNumber < 4){\\n                    if (customers[group] > 0) { \\n                        customers[group]--;\\n                        boardingNumber++;\\n                    }\\n                    if (customers[group] == 0)\\n                        group++;\\n                }\\n            }\\n            \\n            currentProfit+= (boardingCost * boardingNumber - runningCost);\\n            \\n            if (currentProfit > best.profit)\\n                best = (totalRotations, currentProfit);\\n            \\n            totalRotations++;\\n        }\\n        \\n        return best.rotation > 0 ? best.rotation : -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2467928,
                "title": "c-solution-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    int minOperationsMaxProfit(vector<int>& customers, int boardingCost, int runningCost) {\\n        int maxProfit=0;\\n        int round=0, ans=0, servedCust=0, remCust=0,i=0;\\n        \\n        while(i<customers.size() || remCust>0)\\n        {\\n            if(i<customers.size()) remCust += customers[i];\\n            round++;\\n            i++;\\n            if(remCust>=4)\\n            {\\n                servedCust += 4;\\n                remCust -= 4; \\n            }\\n            else\\n            {\\n                servedCust += remCust;\\n                remCust = 0;\\n            }\\n            \\n            int p = (servedCust*boardingCost)-(round*runningCost);\\n            if(p>maxProfit) \\n            {\\n                maxProfit = p;\\n                ans = round;\\n            }\\n        }\\n        return maxProfit==0?-1:ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Iterator"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperationsMaxProfit(vector<int>& customers, int boardingCost, int runningCost) {\\n        int maxProfit=0;\\n        int round=0, ans=0, servedCust=0, remCust=0,i=0;\\n        \\n        while(i<customers.size() || remCust>0)\\n        {\\n            if(i<customers.size()) remCust += customers[i];\\n            round++;\\n            i++;\\n            if(remCust>=4)\\n            {\\n                servedCust += 4;\\n                remCust -= 4; \\n            }\\n            else\\n            {\\n                servedCust += remCust;\\n                remCust = 0;\\n            }\\n            \\n            int p = (servedCust*boardingCost)-(round*runningCost);\\n            if(p>maxProfit) \\n            {\\n                maxProfit = p;\\n                ans = round;\\n            }\\n        }\\n        return maxProfit==0?-1:ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2320987,
                "title": "python-3-simulation-clean-code",
                "content": "long code but faster because of less Comparison\\'s and less variables used:\\n\\n\\tclass Solution:\\n\\t\\tdef minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\\n\\t\\t\\tmax_profit=Profit=curr=0\\n\\t\\t\\tmax_profit_rotation=-1\\n\\t\\t\\tfor i,x in enumerate(customers):\\n\\t\\t\\t\\tcurr+=x\\n\\t\\t\\t\\tchange=min(curr,4)\\n\\t\\t\\t\\tcurr-=change\\n\\t\\t\\t\\tProfit+=change*boardingCost-runningCost\\n\\t\\t\\t\\tif Profit>max_profit:\\n\\t\\t\\t\\t\\tmax_profit=Profit\\n\\t\\t\\t\\t\\tmax_profit_rotation=i+1\\n\\n\\t\\t\\ta,b=curr//4,curr%4\\n\\t\\t\\tmax_profit_rotation+=a if (4*boardingCost-runningCost)>0 else 0\\n\\t\\t\\tmax_profit_rotation+=1 if (b*boardingCost-runningCost)>0 else 0\\n\\t\\t\\treturn max_profit_rotation\\n\\t\\t\\t\\nShort code but with some Extra comparison:\\n\\n\\t\\n\\tclass Solution:\\n\\t\\tdef minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\\n\\t\\t\\tmax_profit=Profit=t=curr=0\\n\\t\\t\\tmax_profit_rotation=-1\\n\\t\\t\\ti,n=0,len(customers)\\n\\t\\t\\twhile i<n or curr:\\n\\t\\t\\t\\tcurr+=customers[i] if i<n else 0\\n\\t\\t\\t\\tProfit+=min(4,curr)*boardingCost-runningCost\\n\\t\\t\\t\\tt+=1\\n\\t\\t\\t\\tif Profit>max_profit:\\n\\t\\t\\t\\t\\tmax_profit=Profit\\n\\t\\t\\t\\t\\tmax_profit_rotation=t\\n\\t\\t\\t\\tcurr-=min(4,curr)\\n\\t\\t\\t\\ti+=1\\n\\t\\t\\treturn max_profit_rotation\\n\\t\\t\\t\\n",
                "solutionTags": [
                    "Python3",
                    "Simulation"
                ],
                "code": "long code but faster because of less Comparison\\'s and less variables used:\\n\\n\\tclass Solution:\\n\\t\\tdef minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\\n\\t\\t\\tmax_profit=Profit=curr=0\\n\\t\\t\\tmax_profit_rotation=-1\\n\\t\\t\\tfor i,x in enumerate(customers):\\n\\t\\t\\t\\tcurr+=x\\n\\t\\t\\t\\tchange=min(curr,4)\\n\\t\\t\\t\\tcurr-=change\\n\\t\\t\\t\\tProfit+=change*boardingCost-runningCost\\n\\t\\t\\t\\tif Profit>max_profit:\\n\\t\\t\\t\\t\\tmax_profit=Profit\\n\\t\\t\\t\\t\\tmax_profit_rotation=i+1\\n\\n\\t\\t\\ta,b=curr//4,curr%4\\n\\t\\t\\tmax_profit_rotation+=a if (4*boardingCost-runningCost)>0 else 0\\n\\t\\t\\tmax_profit_rotation+=1 if (b*boardingCost-runningCost)>0 else 0\\n\\t\\t\\treturn max_profit_rotation\\n\\t\\t\\t\\nShort code but with some Extra comparison:\\n\\n\\t\\n\\tclass Solution:\\n\\t\\tdef minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\\n\\t\\t\\tmax_profit=Profit=t=curr=0\\n\\t\\t\\tmax_profit_rotation=-1\\n\\t\\t\\ti,n=0,len(customers)\\n\\t\\t\\twhile i<n or curr:\\n\\t\\t\\t\\tcurr+=customers[i] if i<n else 0\\n\\t\\t\\t\\tProfit+=min(4,curr)*boardingCost-runningCost\\n\\t\\t\\t\\tt+=1\\n\\t\\t\\t\\tif Profit>max_profit:\\n\\t\\t\\t\\t\\tmax_profit=Profit\\n\\t\\t\\t\\t\\tmax_profit_rotation=t\\n\\t\\t\\t\\tcurr-=min(4,curr)\\n\\t\\t\\t\\ti+=1\\n\\t\\t\\treturn max_profit_rotation\\n\\t\\t\\t\\n",
                "codeTag": "Java"
            },
            {
                "id": 2309665,
                "title": "not-very-fast-but-explained-with-comments-python3",
                "content": "\\'\\'\\'\\nclass Solution(object):\\n    def minOperationsMaxProfit(self, customers, boardingCost, runningCost):\\n        \"\"\"\\n        :type customers: List[int]\\n        :type boardingCost: int\\n        :type runningCost: int\\n        :rtype: int\\n        \"\"\"\\n        \\n        q = []\\n        first_round = True\\n        for i in range(len(customers)):\\n            while True:\\n                sample = min(customers[i],4)\\n\\n                if sample == 4:\\n                    q.append(sample)\\n                    customers[i] = customers[i] - sample\\n\\n                if sample == 0 and first_round == True:\\n                    q.append(sample)\\n\\n                if sample < 4 and first_round == True and sample >= 1:\\n                    q.append(sample)\\n                    customers[i] = customers[i] - sample\\n\\n\\n                if sample < 4 and first_round == False and sample >= 1:\\n                    if i == len(customers) - 1:\\n                        q.append(sample)\\n                        break\\n                    customers[i+1] = customers[i] + customers[i+1]  \\n                    customers[i] = customers[i] - sample\\n                    first_round = False\\n                    break\\n\\n                if customers[i] == 0:\\n                    break\\n\\n                first_round = False\\n\\n\\n        profits = []\\n        profit = 0\\n\\n        for ppl in q:\\n            profit = ppl * boardingCost - runningCost + profit\\n            profits.append(profit)\\n\\n        if profits[len(profits)-1] <= 0:\\n            return -1\\n\\n\\n        max_val = max(profits)\\n        min_round = profits.index(max_val)\\n        return min_round+1\\n\\'\\'\\'\\n\\nThis problem is not very hard however, the describtion is so bad. \\n\\nWhen you come and try to attempt this challenge make sure to have the this  in mind: \\n1- That if you know how the queue will be organized you nearly solved the problem. \\n\\nfor example the q for customers = [0,0,0,0,0,50] is \\nq = [0, 0, 0, 0, 0, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 2]\\n\\nsee that you will still rotate the wheel even if there is no one. \\n\\nexample2: \\ncustomers = [3,4,0,5,1]\\nq = [3, 4, 0, 4, 2]\\n\\nYou see that if the number of customers less than  4 and this is the first time you look at those waiting customers in that index you will select all of them! However, when you loop and this is the second time you look at those customers in the same index you will try to take all of them (4 in this case) which being as greedy as possible and the customers were waiting before. \\n\\n\\nMy code by no mean is fast but it does the job. Maybe the explaination is a little vague as well feel free to ask questions here!",
                "solutionTags": [],
                "code": "\\'\\'\\'\\nclass Solution(object):\\n    def minOperationsMaxProfit(self, customers, boardingCost, runningCost):\\n        \"\"\"\\n        :type customers: List[int]\\n        :type boardingCost: int\\n        :type runningCost: int\\n        :rtype: int\\n        \"\"\"\\n        \\n        q = []\\n        first_round = True\\n        for i in range(len(customers)):\\n            while True:\\n                sample = min(customers[i],4)\\n\\n                if sample == 4:\\n                    q.append(sample)\\n                    customers[i] = customers[i] - sample\\n\\n                if sample == 0 and first_round == True:\\n                    q.append(sample)\\n\\n                if sample < 4 and first_round == True and sample >= 1:\\n                    q.append(sample)\\n                    customers[i] = customers[i] - sample\\n\\n\\n                if sample < 4 and first_round == False and sample >= 1:\\n                    if i == len(customers) - 1:\\n                        q.append(sample)\\n                        break\\n                    customers[i+1] = customers[i] + customers[i+1]  \\n                    customers[i] = customers[i] - sample\\n                    first_round = False\\n                    break\\n\\n                if customers[i] == 0:\\n                    break\\n\\n                first_round = False\\n\\n\\n        profits = []\\n        profit = 0\\n\\n        for ppl in q:\\n            profit = ppl * boardingCost - runningCost + profit\\n            profits.append(profit)\\n\\n        if profits[len(profits)-1] <= 0:\\n            return -1\\n\\n\\n        max_val = max(profits)\\n        min_round = profits.index(max_val)\\n        return min_round+1\\n\\'\\'\\'\\n\\nThis problem is not very hard however, the describtion is so bad. \\n\\nWhen you come and try to attempt this challenge make sure to have the this  in mind: \\n1- That if you know how the queue will be organized you nearly solved the problem. \\n\\nfor example the q for customers = [0,0,0,0,0,50] is \\nq = [0, 0, 0, 0, 0, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 2]\\n\\nsee that you will still rotate the wheel even if there is no one. \\n\\nexample2: \\ncustomers = [3,4,0,5,1]\\nq = [3, 4, 0, 4, 2]\\n\\nYou see that if the number of customers less than  4 and this is the first time you look at those waiting customers in that index you will select all of them! However, when you loop and this is the second time you look at those customers in the same index you will try to take all of them (4 in this case) which being as greedy as possible and the customers were waiting before. \\n\\n\\nMy code by no mean is fast but it does the job. Maybe the explaination is a little vague as well feel free to ask questions here!",
                "codeTag": "Java"
            },
            {
                "id": 2240888,
                "title": "c-literally-simulated-the-whole-process",
                "content": "```\\nclass Solution {\\npublic:\\n    int minOperationsMaxProfit(vector<int>& customers, int BC , int RC) {\\n        int maxProfit = INT_MIN , profit = 0 , rots = 1 , maxRots = 0 ;\\n        int waiting = 0 , totalPeople = 0 ;\\n        \\n        for(int i = 0 ; i < customers.size() ; ++i ){\\n            int onBoard = min(4,customers[i]) ;\\n            totalPeople += onBoard ;\\n            waiting += abs(customers[i] - onBoard) ;\\n            \\n            if(onBoard < 4){\\n                int diff = abs(4 - onBoard) ;\\n                int take = min(waiting,diff) ;\\n                waiting -= take ; totalPeople += take ; onBoard += take ; \\n            }\\n            profit = totalPeople * BC  - rots * RC ;\\n            if(maxProfit < profit) maxProfit = profit , maxRots = rots ;\\n            ++rots ;\\n        }\\n        while(waiting){\\n            int onBoard = min(4,waiting) ;\\n            totalPeople += onBoard ;\\n            waiting -= onBoard ;\\n            profit = totalPeople * BC - rots *RC ;\\n            if(maxProfit < profit) maxProfit = profit , maxRots = rots ;\\n            ++rots ;\\n        } \\n        return maxProfit > 0 ? maxRots : -1 ;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperationsMaxProfit(vector<int>& customers, int BC , int RC) {\\n        int maxProfit = INT_MIN , profit = 0 , rots = 1 , maxRots = 0 ;\\n        int waiting = 0 , totalPeople = 0 ;\\n        \\n        for(int i = 0 ; i < customers.size() ; ++i ){\\n            int onBoard = min(4,customers[i]) ;\\n            totalPeople += onBoard ;\\n            waiting += abs(customers[i] - onBoard) ;\\n            \\n            if(onBoard < 4){\\n                int diff = abs(4 - onBoard) ;\\n                int take = min(waiting,diff) ;\\n                waiting -= take ; totalPeople += take ; onBoard += take ; \\n            }\\n            profit = totalPeople * BC  - rots * RC ;\\n            if(maxProfit < profit) maxProfit = profit , maxRots = rots ;\\n            ++rots ;\\n        }\\n        while(waiting){\\n            int onBoard = min(4,waiting) ;\\n            totalPeople += onBoard ;\\n            waiting -= onBoard ;\\n            profit = totalPeople * BC - rots *RC ;\\n            if(maxProfit < profit) maxProfit = profit , maxRots = rots ;\\n            ++rots ;\\n        } \\n        return maxProfit > 0 ? maxRots : -1 ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2128647,
                "title": "c-basic-implementation",
                "content": "```\\nclass Solution {\\npublic:\\n    int minOperationsMaxProfit(vector<int>& c, int b, int r) {\\n        int wt=0,ind=-1,mx=0,n=size(c),prof=0;\\n        for(int i=0;i<n||wt>0;++i){\\n            if(i<n)wt+=c[i];\\n            int go=min(4,wt);\\n            prof+=go*b-r;\\n            wt-=go;\\n            if(mx<prof){\\n                mx=prof;\\n                ind=i+1;\\n            }            \\n        }\\n        return ind;        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperationsMaxProfit(vector<int>& c, int b, int r) {\\n        int wt=0,ind=-1,mx=0,n=size(c),prof=0;\\n        for(int i=0;i<n||wt>0;++i){\\n            if(i<n)wt+=c[i];\\n            int go=min(4,wt);\\n            prof+=go*b-r;\\n            wt-=go;\\n            if(mx<prof){\\n                mx=prof;\\n                ind=i+1;\\n            }            \\n        }\\n        return ind;        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2108313,
                "title": "simulation",
                "content": "Though it would be more decent to merge the two while-loops,\\nI prefer this way to separate two logic units and avoid putting if-condition inside loops.\\n\\n```cpp\\nint n = customers.size();\\nint waiting = 0;\\nint boarding = 0;\\nint profit = 0;\\nint max_profit = 0;\\nint max_profit_at = -1;\\nint i = 0;\\n\\nwhile (i < n)\\n{\\n\\t// new customers arrive.\\n\\twaiting += customers[i];\\n\\t\\n\\t// at most board 4 customers at a time.\\n\\tboarding = min(4, waiting);\\n\\twaiting -= boarding;\\n\\t// accumulate the profit.\\n\\tprofit += (boardingCost * boarding) - runningCost;\\n\\t\\n\\t++ i;\\n\\t\\n\\t// update the max profit.\\n\\tif (max_profit < profit)\\n\\t{\\n\\t\\tmax_profit = profit;\\n\\t\\tmax_profit_at = i;\\n\\t}\\n}\\n\\n// while there are customers awaiting.\\nwhile (waiting)\\n{\\n\\tboarding = min(4, waiting);\\n\\twaiting -= boarding;\\n\\tprofit += (boardingCost * boarding) - runningCost;\\n\\t\\n\\t++ i;\\n\\t\\n\\tif (max_profit < profit)\\n\\t{\\n\\t\\tmax_profit = profit;\\n\\t\\tmax_profit_at = i;\\n\\t}\\n}\\n\\nreturn max_profit_at;\\n```\\n",
                "solutionTags": [
                    "C",
                    "Simulation"
                ],
                "code": "```cpp\\nint n = customers.size();\\nint waiting = 0;\\nint boarding = 0;\\nint profit = 0;\\nint max_profit = 0;\\nint max_profit_at = -1;\\nint i = 0;\\n\\nwhile (i < n)\\n{\\n\\t// new customers arrive.\\n\\twaiting += customers[i];\\n\\t\\n\\t// at most board 4 customers at a time.\\n\\tboarding = min(4, waiting);\\n\\twaiting -= boarding;\\n\\t// accumulate the profit.\\n\\tprofit += (boardingCost * boarding) - runningCost;\\n\\t\\n\\t++ i;\\n\\t\\n\\t// update the max profit.\\n\\tif (max_profit < profit)\\n\\t{\\n\\t\\tmax_profit = profit;\\n\\t\\tmax_profit_at = i;\\n\\t}\\n}\\n\\n// while there are customers awaiting.\\nwhile (waiting)\\n{\\n\\tboarding = min(4, waiting);\\n\\twaiting -= boarding;\\n\\tprofit += (boardingCost * boarding) - runningCost;\\n\\t\\n\\t++ i;\\n\\t\\n\\tif (max_profit < profit)\\n\\t{\\n\\t\\tmax_profit = profit;\\n\\t\\tmax_profit_at = i;\\n\\t}\\n}\\n\\nreturn max_profit_at;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2085542,
                "title": "c",
                "content": "```\\nclass Solution {\\npublic:\\n    int minOperationsMaxProfit(vector<int>& customers, int boardingCost, int runningCost) {\\n\\n        int n = customers.size(),wait = 0,board=0,curProfit = 0, maxProfit = INT_MIN,minRotate = -1,round = 0,i = 0;\\n        while (true) {\\n            round++;\\n            if (i < n) wait += customers[i++];\\n            board = min(4, wait);\\n            wait -= board;\\n            curProfit += board * boardingCost - runningCost;\\n\\n            if (curProfit > maxProfit) {\\n                minRotate = round;\\n                maxProfit = curProfit;\\n            }\\n\\n            if (i == n && wait <= 0) break;\\n        }\\n        \\n        return maxProfit <= 0 ? -1 : minRotate;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperationsMaxProfit(vector<int>& customers, int boardingCost, int runningCost) {\\n\\n        int n = customers.size(),wait = 0,board=0,curProfit = 0, maxProfit = INT_MIN,minRotate = -1,round = 0,i = 0;\\n        while (true) {\\n            round++;\\n            if (i < n) wait += customers[i++];\\n            board = min(4, wait);\\n            wait -= board;\\n            curProfit += board * boardingCost - runningCost;\\n\\n            if (curProfit > maxProfit) {\\n                minRotate = round;\\n                maxProfit = curProfit;\\n            }\\n\\n            if (i == n && wait <= 0) break;\\n        }\\n        \\n        return maxProfit <= 0 ? -1 : minRotate;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1963523,
                "title": "100-faster-easy-javascript",
                "content": "```\\nvar minOperationsMaxProfit = function(customers, bCost, rCost) {\\n    let max=0; let ans=-1;\\n    var extra=0; var people;\\n    var total=0; let count=0;\\n    for(let i=0; i<customers.length; i++){\\n       count++;\\n       \\n       extra+=customers[i];\\n       if(extra>=4){ people=4; }\\n       else{ people=extra; }\\n       extra-=people;\\n       total+=people;\\n\\n      let profit=(total*bCost)-(count*rCost);\\n      if(profit>max){ max=profit; ans=count; }\\n    }\\n    while(extra){\\n       count++;\\n       if(extra>=4){ people=4; }\\n       else{ people=extra; }\\n       extra-=people;\\n       total+=people;\\n  \\n       let profit=(total*bCost)-(count*rCost);\\n       if(profit>max){ max=profit; ans=count; }\\n    }\\n    return ans;       \\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar minOperationsMaxProfit = function(customers, bCost, rCost) {\\n    let max=0; let ans=-1;\\n    var extra=0; var people;\\n    var total=0; let count=0;\\n    for(let i=0; i<customers.length; i++){\\n       count++;\\n       \\n       extra+=customers[i];\\n       if(extra>=4){ people=4; }\\n       else{ people=extra; }\\n       extra-=people;\\n       total+=people;\\n\\n      let profit=(total*bCost)-(count*rCost);\\n      if(profit>max){ max=profit; ans=count; }\\n    }\\n    while(extra){\\n       count++;\\n       if(extra>=4){ people=4; }\\n       else{ people=extra; }\\n       extra-=people;\\n       total+=people;\\n  \\n       let profit=(total*bCost)-(count*rCost);\\n       if(profit>max){ max=profit; ans=count; }\\n    }\\n    return ans;       \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1674698,
                "title": "long-simulation-easy-to-understand",
                "content": "\\tclass Solution {\\n\\tpublic:\\n\\t\\tint minOperationsMaxProfit(vector<int>& customers, int boardingCost, int runningCost) {\\n\\t\\t\\tint i = 0;\\n\\t\\t\\tint answer = 0;\\n\\t\\t\\tint temp = 0;\\n\\t\\t\\tint rides = 0;\\n\\t\\t\\tint customer = 0;\\n\\n\\t\\t\\twhile(i<customers.size()){\\n\\t\\t\\t\\tcustomer+= customers[i];\\n\\t\\t\\t\\ttemp-=runningCost;\\n\\t\\t\\t\\tif(customer>=4){\\n\\t\\t\\t\\t\\ttemp+= boardingCost*4;\\n\\t\\t\\t\\t\\tcustomer-=4;\\n\\t\\t\\t\\t}else if(customer==3){\\n\\t\\t\\t\\t\\ttemp+= boardingCost*3;\\n\\t\\t\\t\\t\\tcustomer-=3;\\n\\t\\t\\t\\t}else if(customer==2){\\n\\t\\t\\t\\t\\ttemp+= boardingCost*2;\\n\\t\\t\\t\\t\\tcustomer-=2;\\n\\t\\t\\t\\t}else if(customer==1){\\n\\t\\t\\t\\t\\ttemp+= boardingCost*1;\\n\\t\\t\\t\\t\\tcustomer-=1;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\ti++;\\n\\t\\t\\t\\tif(answer<temp){\\n\\t\\t\\t\\t\\tanswer = temp;\\n\\t\\t\\t\\t\\trides = i;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\twhile(customer>0){\\n\\t\\t\\t\\ttemp-=runningCost;\\n\\t\\t\\t\\tif(customer>=4){\\n\\t\\t\\t\\t\\ttemp+= boardingCost*4;\\n\\t\\t\\t\\t\\tcustomer-=4;\\n\\t\\t\\t\\t}else if(customer==3){\\n\\t\\t\\t\\t\\ttemp+= boardingCost*3;\\n\\t\\t\\t\\t\\tcustomer-=3;\\n\\t\\t\\t\\t}else if(customer==2){\\n\\t\\t\\t\\t\\ttemp+= boardingCost*2;\\n\\t\\t\\t\\t\\tcustomer-=2;\\n\\t\\t\\t\\t}else if(customer==1){\\n\\t\\t\\t\\t\\ttemp+= boardingCost*1;\\n\\t\\t\\t\\t\\tcustomer-=1;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\ti++;\\n\\t\\t\\t\\tif(answer<temp){\\n\\t\\t\\t\\t\\tanswer = temp;\\n\\t\\t\\t\\t\\trides = i;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tif(rides == 0){\\n\\t\\t\\t\\treturn -1;\\n\\t\\t\\t}\\n\\t\\t\\treturn rides;\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tint minOperationsMaxProfit(vector<int>& customers, int boardingCost, int runningCost) {\\n\\t\\t\\tint i = 0;\\n\\t\\t\\tint answer = 0;\\n\\t\\t\\tint temp = 0;\\n\\t\\t\\tint rides = 0;\\n\\t\\t\\tint customer = 0;\\n\\n\\t\\t\\twhile(i<customers.size()){\\n\\t\\t\\t\\tcustomer+= customers[i];\\n\\t\\t\\t\\ttemp-=runningCost;\\n\\t\\t\\t\\tif(customer>=4){\\n\\t\\t\\t\\t\\ttemp+= boardingCost*4;\\n\\t\\t\\t\\t\\tcustomer-=4;\\n\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1571897,
                "title": "python3-easy-to-understand",
                "content": "```\\nclass Solution:\\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\\n        if 4 * boardingCost <= runningCost:\\n            return -1\\n        customer = 0\\n        max_profit = profit = 0\\n        r = 0\\n        out = -1\\n        while customer or r < len(customers):\\n            if r < len(customers):\\n                customer += customers[r]\\n            r += 1\\n            n = min(4, customer)\\n            # print(f\"r = {r} n ={n} {n * boardingCost - runningCost}\")\\n            profit += n * boardingCost - runningCost\\n            if profit > max_profit:\\n                out = r\\n                max_profit = profit\\n            customer -= n\\n        return out\\n            \\n        \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\\n        if 4 * boardingCost <= runningCost:\\n            return -1\\n        customer = 0\\n        max_profit = profit = 0\\n        r = 0\\n        out = -1\\n        while customer or r < len(customers):\\n            if r < len(customers):\\n                customer += customers[r]\\n            r += 1\\n            n = min(4, customer)\\n            # print(f\"r = {r} n ={n} {n * boardingCost - runningCost}\")\\n            profit += n * boardingCost - runningCost\\n            if profit > max_profit:\\n                out = r\\n                max_profit = profit\\n            customer -= n\\n        return out\\n            \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1545127,
                "title": "java-simulation-o-n-concise-beat-99",
                "content": "I would like to call out and seperate the \"serving all the remaining waiting line after n shifts \" from the for loop, b/c if there are a lot of remaining passengers after n shfits, the other solutions which combine both cases will have the time complexity of O(sum(customers)) instead of O(length(customers)), it may not a big downside with customers[i] <= 50, but if the customers[i] could be as large as n. Then the time comlexity of the other solution could be O(n^2).\\n```\\nclass Solution {\\n    public int minOperationsMaxProfit(int[] customers, int boardingCost, int runningCost) {\\n        int maxProfit = 0, shift = -1, waiting = 0, profit = 0;\\n        for(int i = 0; i < customers.length; i++) {\\n            waiting += customers[i]; // In each shift adding new passenger to the waiting line\\n            profit += Math.min(waiting, 4) * boardingCost - runningCost;\\n            if(profit > maxProfit) {\\n                shift = i + 1;\\n                maxProfit = profit;\\n            }\\n            waiting = Math.max(waiting - 4, 0);\\n        }\\n        if(boardingCost * 4 > runningCost) { // profitable to serve all the remaining waiting line?\\n            shift += waiting / 4;\\n            shift += waiting % 4 * boardingCost - runningCost > 0 ? 1:0; // profitable for the last round?\\n        }\\n        return shift;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minOperationsMaxProfit(int[] customers, int boardingCost, int runningCost) {\\n        int maxProfit = 0, shift = -1, waiting = 0, profit = 0;\\n        for(int i = 0; i < customers.length; i++) {\\n            waiting += customers[i]; // In each shift adding new passenger to the waiting line\\n            profit += Math.min(waiting, 4) * boardingCost - runningCost;\\n            if(profit > maxProfit) {\\n                shift = i + 1;\\n                maxProfit = profit;\\n            }\\n            waiting = Math.max(waiting - 4, 0);\\n        }\\n        if(boardingCost * 4 > runningCost) { // profitable to serve all the remaining waiting line?\\n            shift += waiting / 4;\\n            shift += waiting % 4 * boardingCost - runningCost > 0 ? 1:0; // profitable for the last round?\\n        }\\n        return shift;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1535377,
                "title": "mistake-in-example-4",
                "content": "Please help me to understand why in the example 4 the result should be 9 and not 10",
                "solutionTags": [],
                "code": "",
                "codeTag": "Unknown"
            },
            {
                "id": 1494199,
                "title": "python-simulation",
                "content": "```\\nclass Solution:\\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\\n        \\n        def rotate(wheel):\\n            return [0, wheel[0], wheel[1], wheel[2]]\\n        \\n        waiting = customers[0]\\n        wheel = [0, 0, 0, 0]\\n        rotations = 0\\n        maxp = [-float(\\'inf\\'), 0]\\n        admissions = 0\\n        i = 0\\n        while waiting > 0 or i < len(customers):\\n            if waiting > 0:\\n                if waiting > 4:\\n                    wheel[0] = 4\\n                    waiting -= 4\\n                    admissions += 4\\n                    wheel = rotate(wheel)\\n                else:\\n                    wheel[0] = waiting\\n                    admissions += waiting\\n                    waiting = 0\\n                    wheel = rotate(wheel)\\n            rotations += 1\\n            profit = admissions * boardingCost - rotations * runningCost\\n            if profit > maxp[0]:\\n                maxp = [profit, rotations]\\n            if rotations < len(customers):\\n                waiting += customers[rotations]\\n            i += 1\\n            \\n        return maxp[1] if maxp[0] > 0 else -1\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\\n        \\n        def rotate(wheel):\\n            return [0, wheel[0], wheel[1], wheel[2]]\\n        \\n        waiting = customers[0]\\n        wheel = [0, 0, 0, 0]\\n        rotations = 0\\n        maxp = [-float(\\'inf\\'), 0]\\n        admissions = 0\\n        i = 0\\n        while waiting > 0 or i < len(customers):\\n            if waiting > 0:\\n                if waiting > 4:\\n                    wheel[0] = 4\\n                    waiting -= 4\\n                    admissions += 4\\n                    wheel = rotate(wheel)\\n                else:\\n                    wheel[0] = waiting\\n                    admissions += waiting\\n                    waiting = 0\\n                    wheel = rotate(wheel)\\n            rotations += 1\\n            profit = admissions * boardingCost - rotations * runningCost\\n            if profit > maxp[0]:\\n                maxp = [profit, rotations]\\n            if rotations < len(customers):\\n                waiting += customers[rotations]\\n            i += 1\\n            \\n        return maxp[1] if maxp[0] > 0 else -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1465193,
                "title": "java-solution",
                "content": "\\tclass Solution {\\n    public int minOperationsMaxProfit(int[] customers, int boardingCost, int runningCost) {\\n        int waiting = 0, riding = 0, profit = 0, maxProfit = -1, maxRotation = -1, rotation = 0;\\n        int index = 0;\\n        while(index < customers.length || waiting > 0)\\n        {\\n            waiting += index >= customers.length ? 0 : customers[index];\\n            index++;\\n            if(waiting > 0)\\n            {\\n                int newriders = waiting >= 4 ? 4 : waiting;\\n                riding += newriders;\\n                waiting = waiting - newriders;\\n            }\\n            \\n            rotation++;\\n            profit = riding*boardingCost - runningCost*rotation;\\n            if(maxProfit < profit)\\n            {\\n                maxProfit = profit;\\n                maxRotation = rotation;\\n            }\\n        }\\n        \\n        return profit <= 0 ? -1 : maxRotation;\\n    }\\n\\t}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int minOperationsMaxProfit(int[] customers, int boardingCost, int runningCost) {\\n        int waiting = 0, riding = 0, profit = 0, maxProfit = -1, maxRotation = -1, rotation = 0;\\n        int index = 0;\\n        while(index < customers.length || waiting > 0)\\n        {\\n            waiting += index >= customers.length ? 0 : customers[index];\\n            index++;\\n            if(waiting > 0)\\n            {\\n                int newriders = waiting >= 4 ? 4 : waiting;\\n                riding += newriders;\\n                waiting = waiting - newriders;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1460317,
                "title": "just-simulation-should-have-been-an-easy-question-but-really-lousy-description",
                "content": "```scala\\n  def minOperationsMaxProfit(customers: Array[Int], boardingCost: Int, runningCost: Int): Int = {\\n\\n    var times   = 0\\n    var total   = 0\\n    var waiting = 0\\n    var max     = 0\\n    var res     = -1\\n    var i       = 0\\n\\n    while (waiting > 0 || i < customers.length) {\\n      if (i < customers.length) waiting += customers(i)\\n      i += 1\\n      val board = if (waiting <= 4) waiting else 4\\n      times += 1\\n      total += boardingCost * board - runningCost\\n      waiting -= board\\n      if (total > max) {\\n        max = total\\n        res = times\\n      }\\n\\n    }\\n\\n    if (max > 0) res else -1\\n  }\\n```",
                "solutionTags": [],
                "code": "```scala\\n  def minOperationsMaxProfit(customers: Array[Int], boardingCost: Int, runningCost: Int): Int = {\\n\\n    var times   = 0\\n    var total   = 0\\n    var waiting = 0\\n    var max     = 0\\n    var res     = -1\\n    var i       = 0\\n\\n    while (waiting > 0 || i < customers.length) {\\n      if (i < customers.length) waiting += customers(i)\\n      i += 1\\n      val board = if (waiting <= 4) waiting else 4\\n      times += 1\\n      total += boardingCost * board - runningCost\\n      waiting -= board\\n      if (total > max) {\\n        max = total\\n        res = times\\n      }\\n\\n    }\\n\\n    if (max > 0) res else -1\\n  }\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1453449,
                "title": "naive-approach-python-solution",
                "content": "```\\nclass Solution:\\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\\n        \\n        if len(customers)==1:\\n            if customers[0]<4:\\n                return -1\\n        \\n        l = []\\n        count = 1\\n        waiting = 0\\n        boardedPeople = 0\\n        for i in range(len(customers)):\\n            \\n            waiting+=customers[i]\\n            \\n            boardedPeople += min(4,waiting)\\n            diff=min(4,waiting)\\n            waiting-=diff\\n            profit = boardingCost*boardedPeople - runningCost*count\\n            l.append(profit)\\n            count+=1\\n            \\n            \\n        while waiting>0:\\n            \\n            boardedPeople += min(4,waiting)\\n            \\n            profit = boardingCost*boardedPeople - runningCost*count\\n            l.append(profit)\\n            waiting-=min(4,waiting)\\n            count+=1\\n            \\n          \\n        mx = max(l)\\n        if mx < 0:\\n            return -1\\n        \\n        return l.index(mx)+1\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\\n        \\n        if len(customers)==1:\\n            if customers[0]<4:\\n                return -1\\n        \\n        l = []\\n        count = 1\\n        waiting = 0\\n        boardedPeople = 0\\n        for i in range(len(customers)):\\n            \\n            waiting+=customers[i]\\n            \\n            boardedPeople += min(4,waiting)\\n            diff=min(4,waiting)\\n            waiting-=diff\\n            profit = boardingCost*boardedPeople - runningCost*count\\n            l.append(profit)\\n            count+=1\\n            \\n            \\n        while waiting>0:\\n            \\n            boardedPeople += min(4,waiting)\\n            \\n            profit = boardingCost*boardedPeople - runningCost*count\\n            l.append(profit)\\n            waiting-=min(4,waiting)\\n            count+=1\\n            \\n          \\n        mx = max(l)\\n        if mx < 0:\\n            return -1\\n        \\n        return l.index(mx)+1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1452334,
                "title": "c-o-n-o-1-space",
                "content": "```\\npublic class Solution {\\n    public int MinOperationsMaxProfit(int[] customers, int boardingCost, int runningCost) {\\n        int pSoFar = 0;\\n        int maxP = int.MinValue;\\n        int optimalRotation = 0;\\n        int rotationCount = 0;\\n        int rem = 0;\\n        for(int i = 0; i < customers.Length; i++) {\\n            rem = rem + customers[i];\\n            int cProfit = 0;\\n            if (rem >=4) {\\n                cProfit = boardingCost * 4 - 1 * runningCost;\\n                rem = rem - 4;\\n                rotationCount++;\\n            } else if (rem != 0){\\n                cProfit = boardingCost * rem - 1 * runningCost;\\n                rem = 0;\\n                rotationCount++;\\n            } else {\\n                rotationCount++;\\n                continue;\\n            }\\n            \\n            pSoFar += cProfit;\\n            if (pSoFar > maxP) {\\n                maxP = pSoFar;\\n                optimalRotation = rotationCount;\\n            }\\n        }\\n        \\n        while (rem != 0) {\\n            int cProfit = 0;\\n            if (rem >=4) {\\n                cProfit = boardingCost * 4 - 1 * runningCost;\\n                rem = rem - 4;\\n                rotationCount++;\\n            } else if (rem != 0){\\n                cProfit = boardingCost * rem - 1 * runningCost;\\n                rem = 0;\\n                rotationCount++;\\n            }\\n            \\n            pSoFar += cProfit;\\n            if (pSoFar > maxP) {\\n                maxP = pSoFar;\\n                optimalRotation = rotationCount;\\n            }\\n        }\\n        \\n        if (maxP <= 0) {\\n            return -1;\\n        }\\n        \\n        return optimalRotation;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int MinOperationsMaxProfit(int[] customers, int boardingCost, int runningCost) {\\n        int pSoFar = 0;\\n        int maxP = int.MinValue;\\n        int optimalRotation = 0;\\n        int rotationCount = 0;\\n        int rem = 0;\\n        for(int i = 0; i < customers.Length; i++) {\\n            rem = rem + customers[i];\\n            int cProfit = 0;\\n            if (rem >=4) {\\n                cProfit = boardingCost * 4 - 1 * runningCost;\\n                rem = rem - 4;\\n                rotationCount++;\\n            } else if (rem != 0){\\n                cProfit = boardingCost * rem - 1 * runningCost;\\n                rem = 0;\\n                rotationCount++;\\n            } else {\\n                rotationCount++;\\n                continue;\\n            }\\n            \\n            pSoFar += cProfit;\\n            if (pSoFar > maxP) {\\n                maxP = pSoFar;\\n                optimalRotation = rotationCount;\\n            }\\n        }\\n        \\n        while (rem != 0) {\\n            int cProfit = 0;\\n            if (rem >=4) {\\n                cProfit = boardingCost * 4 - 1 * runningCost;\\n                rem = rem - 4;\\n                rotationCount++;\\n            } else if (rem != 0){\\n                cProfit = boardingCost * rem - 1 * runningCost;\\n                rem = 0;\\n                rotationCount++;\\n            }\\n            \\n            pSoFar += cProfit;\\n            if (pSoFar > maxP) {\\n                maxP = pSoFar;\\n                optimalRotation = rotationCount;\\n            }\\n        }\\n        \\n        if (maxP <= 0) {\\n            return -1;\\n        }\\n        \\n        return optimalRotation;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1431384,
                "title": "typescript-one-loop-solution",
                "content": "```typescript\\nfunction minOperationsMaxProfit(customers: number[], boardingCost: number, runningCost: number): number {\\n    let rotation = 0;\\n    let waiting = 0;\\n    let boarded = 0;\\n    let maxProfit = 0;\\n    let maxProfitRotation = -1;\\n    while (rotation < customers.length || waiting > 0) {\\n        waiting += customers[rotation] || 0;\\n        boarded += Math.min(waiting, 4);\\n        waiting -= Math.min(waiting, 4);\\n        ++rotation;\\n        let profit = boarded * boardingCost - rotation * runningCost;\\n        if (maxProfit < profit) {\\n            maxProfit = profit;\\n            maxProfitRotation = rotation;\\n        }\\n    }\\n    return maxProfitRotation;\\n};\\n```",
                "solutionTags": [],
                "code": "```typescript\\nfunction minOperationsMaxProfit(customers: number[], boardingCost: number, runningCost: number): number {\\n    let rotation = 0;\\n    let waiting = 0;\\n    let boarded = 0;\\n    let maxProfit = 0;\\n    let maxProfitRotation = -1;\\n    while (rotation < customers.length || waiting > 0) {\\n        waiting += customers[rotation] || 0;\\n        boarded += Math.min(waiting, 4);\\n        waiting -= Math.min(waiting, 4);\\n        ++rotation;\\n        let profit = boarded * boardingCost - rotation * runningCost;\\n        if (maxProfit < profit) {\\n            maxProfit = profit;\\n            maxProfitRotation = rotation;\\n        }\\n    }\\n    return maxProfitRotation;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1310291,
                "title": "simple-go",
                "content": "```\\nfunc minOperationsMaxProfit(customers []int, boardingCost int, runningCost int) int {\\n    waiting := 0\\n    curProfit := 0\\n    maxProfit := 0\\n    maxProfitIndex := -1\\n    \\n    idx := 0\\n    \\n    for idx < len(customers) || waiting > 0 {\\n        if idx < len(customers) {\\n            waiting += customers[idx]\\n        }\\n        if waiting > 0 {\\n            boardNow := 0\\n            if waiting >= 4 {\\n                boardNow = 4\\n                waiting -= 4\\n            } else {\\n                boardNow = waiting\\n                waiting = 0\\n            }\\n            curProfit += boardingCost * boardNow - runningCost\\n            if curProfit > maxProfit {\\n                maxProfit = curProfit\\n                maxProfitIndex = idx\\n            }\\n        }\\n        idx++\\n    }\\n    if maxProfitIndex != -1 { // compensation for being zero-index\\n        maxProfitIndex += 1\\n    }\\n    return maxProfitIndex\\n}\\n\\nfunc max(a, b int) int {\\n    if a > b {\\n        return a\\n    }\\n    return b\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nfunc minOperationsMaxProfit(customers []int, boardingCost int, runningCost int) int {\\n    waiting := 0\\n    curProfit := 0\\n    maxProfit := 0\\n    maxProfitIndex := -1\\n    \\n    idx := 0\\n    \\n    for idx < len(customers) || waiting > 0 {\\n        if idx < len(customers) {\\n            waiting += customers[idx]\\n        }\\n        if waiting > 0 {\\n            boardNow := 0\\n            if waiting >= 4 {\\n                boardNow = 4\\n                waiting -= 4\\n            } else {\\n                boardNow = waiting\\n                waiting = 0\\n            }\\n            curProfit += boardingCost * boardNow - runningCost\\n            if curProfit > maxProfit {\\n                maxProfit = curProfit\\n                maxProfitIndex = idx\\n            }\\n        }\\n        idx++\\n    }\\n    if maxProfitIndex != -1 { // compensation for being zero-index\\n        maxProfitIndex += 1\\n    }\\n    return maxProfitIndex\\n}\\n\\nfunc max(a, b int) int {\\n    if a > b {\\n        return a\\n    }\\n    return b\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1290792,
                "title": "golang-solution",
                "content": "```\\nfunc minOperationsMaxProfit(customers []int, boardingCost int, runningCost int) int {\\n    tot := 0\\n    i:=0\\n    cust := 0\\n    for ;i<len(customers) || cust > 0; i++ {\\n        if i<len(customers) {\\n            cust+=customers[i]\\n        }\\n        if cust>0 {\\n            v := min(cust, 4)\\n            val := v*boardingCost - runningCost\\n            tot += val\\n            cust-=v\\n            if val <= 0 {\\n                break\\n            }\\n        }\\n    }\\n    if tot <= 0 {\\n        return -1\\n    }\\n    return i\\n}\\nfunc min(a,b int) int {\\n    if a<b {\\n        return a\\n    }\\n    return b\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nfunc minOperationsMaxProfit(customers []int, boardingCost int, runningCost int) int {\\n    tot := 0\\n    i:=0\\n    cust := 0\\n    for ;i<len(customers) || cust > 0; i++ {\\n        if i<len(customers) {\\n            cust+=customers[i]\\n        }\\n        if cust>0 {\\n            v := min(cust, 4)\\n            val := v*boardingCost - runningCost\\n            tot += val\\n            cust-=v\\n            if val <= 0 {\\n                break\\n            }\\n        }\\n    }\\n    if tot <= 0 {\\n        return -1\\n    }\\n    return i\\n}\\nfunc min(a,b int) int {\\n    if a<b {\\n        return a\\n    }\\n    return b\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1267592,
                "title": "javascript-o-n-simulation-faster-than-78",
                "content": "```\\n/**\\n * @param {number[]} customers\\n * @param {number} boardingCost\\n * @param {number} runningCost\\n * @return {number}\\n */\\nvar minOperationsMaxProfit = function(customers, boardingCost, runningCost) {\\n    if (runningCost >= boardingCost * 4)    return -1\\n    \\n    \\n    let earning = 0\\n    let cost = 0\\n    let waiting = 0\\n    let profit = 0\\n    let maxProfit = 0\\n    let bestTime = -1\\n    \\n    \\n    for (const val of customers.values()) {\\n        waiting += val\\n        \\n        if (waiting > 4) {\\n            earning += 4 * boardingCost\\n            waiting -= 4\\n        } else {\\n            earning += waiting * boardingCost\\n            waiting = 0\\n        }\\n\\n        cost += runningCost\\n        \\n        const time = cost / runningCost\\n        profit = earning - cost\\n\\n        if (profit >= maxProfit) {\\n            maxProfit = profit\\n            bestTime = time\\n        }\\n    }\\n    \\n    \\n    if (waiting > 0) {\\n        let lastSize = waiting % 4\\n        if (lastSize === 0) lastSize = 4\\n        const rotateCount = Math.ceil(waiting / 4)\\n        \\n        \\n        cost += rotateCount * runningCost\\n        earning += waiting * boardingCost\\n        waiting = 0\\n        \\n        const time = cost / runningCost\\n        profit = earning - cost\\n\\n        if (profit > maxProfit) {\\n            maxProfit = profit\\n            bestTime = time\\n        }\\n        \\n        \\n        const lastDiff = lastSize * boardingCost - runningCost\\n        if (lastDiff <= 0 && rotateCount > 1) {\\n            maxProfit -= lastDiff\\n            bestTime--\\n        }\\n    }\\n    \\n    \\n    if (maxProfit <= 0) return -1\\n    return bestTime\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * @param {number[]} customers\\n * @param {number} boardingCost\\n * @param {number} runningCost\\n * @return {number}\\n */\\nvar minOperationsMaxProfit = function(customers, boardingCost, runningCost) {\\n    if (runningCost >= boardingCost * 4)    return -1\\n    \\n    \\n    let earning = 0\\n    let cost = 0\\n    let waiting = 0\\n    let profit = 0\\n    let maxProfit = 0\\n    let bestTime = -1\\n    \\n    \\n    for (const val of customers.values()) {\\n        waiting += val\\n        \\n        if (waiting > 4) {\\n            earning += 4 * boardingCost\\n            waiting -= 4\\n        } else {\\n            earning += waiting * boardingCost\\n            waiting = 0\\n        }\\n\\n        cost += runningCost\\n        \\n        const time = cost / runningCost\\n        profit = earning - cost\\n\\n        if (profit >= maxProfit) {\\n            maxProfit = profit\\n            bestTime = time\\n        }\\n    }\\n    \\n    \\n    if (waiting > 0) {\\n        let lastSize = waiting % 4\\n        if (lastSize === 0) lastSize = 4\\n        const rotateCount = Math.ceil(waiting / 4)\\n        \\n        \\n        cost += rotateCount * runningCost\\n        earning += waiting * boardingCost\\n        waiting = 0\\n        \\n        const time = cost / runningCost\\n        profit = earning - cost\\n\\n        if (profit > maxProfit) {\\n            maxProfit = profit\\n            bestTime = time\\n        }\\n        \\n        \\n        const lastDiff = lastSize * boardingCost - runningCost\\n        if (lastDiff <= 0 && rotateCount > 1) {\\n            maxProfit -= lastDiff\\n            bestTime--\\n        }\\n    }\\n    \\n    \\n    if (maxProfit <= 0) return -1\\n    return bestTime\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1262378,
                "title": "python-simulation",
                "content": "```\\nclass Solution:\\n    def minOperationsMaxProfit(self, customers: List[int], bc: int, rc: int) -> int:\\n        d=0;c=0;p=customers[::-1]\\n        while p:\\n            n=p.pop()\\n            if n==0 and d>=0:c+=1;continue\\n            old=d\\n            if n<=4:d+=(n*bc)-rc\\n            else:\\n                n-=4\\n                d+=((4*bc)-rc)\\n                if p:p[-1]+=n\\n                else:p.append(n)\\n            if d-old>0:c+=1\\n        return c if c>0 else -1\\n            \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minOperationsMaxProfit(self, customers: List[int], bc: int, rc: int) -> int:\\n        d=0;c=0;p=customers[::-1]\\n        while p:\\n            n=p.pop()\\n            if n==0 and d>=0:c+=1;continue\\n            old=d\\n            if n<=4:d+=(n*bc)-rc\\n            else:\\n                n-=4\\n                d+=((4*bc)-rc)\\n                if p:p[-1]+=n\\n                else:p.append(n)\\n            if d-old>0:c+=1\\n        return c if c>0 else -1\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1255006,
                "title": "kotlin-faster-100-memory-usage-100",
                "content": "```\\nclass Solution {\\n    fun minOperationsMaxProfit(customers: IntArray, boardingCost: Int, runningCost: Int): Int {\\n        var ridingP = 0\\n        var waitingP = 0\\n        var res = 0\\n        var idx = 0\\n        var max = -987654321\\n        var ans = 0\\n\\n        while (true) {\\n            if(waitingP <= 0 && idx >= customers.size) {\\n                break\\n            }\\n\\n            if (idx < customers.size) {\\n                waitingP += customers[idx]\\n            }\\n            if (waitingP >= 4) {\\n                ridingP = 4\\n                waitingP -= 4\\n            } else {\\n                ridingP = waitingP\\n                waitingP = 0\\n            }\\n\\n            res += ridingP * boardingCost - runningCost\\n            //println(\"$ridingP * $boardingCost - $runningCost = $res\")\\n\\n            if(max < res) {\\n                max = res\\n                ans = idx\\n            }\\n            idx++\\n        }\\n\\n        if(max <= 0) {\\n            return -1\\n        }\\n\\n        return ans + 1\\n    }\\n}\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\nclass Solution {\\n    fun minOperationsMaxProfit(customers: IntArray, boardingCost: Int, runningCost: Int): Int {\\n        var ridingP = 0\\n        var waitingP = 0\\n        var res = 0\\n        var idx = 0\\n        var max = -987654321\\n        var ans = 0\\n\\n        while (true) {\\n            if(waitingP <= 0 && idx >= customers.size) {\\n                break\\n            }\\n\\n            if (idx < customers.size) {\\n                waitingP += customers[idx]\\n            }\\n            if (waitingP >= 4) {\\n                ridingP = 4\\n                waitingP -= 4\\n            } else {\\n                ridingP = waitingP\\n                waitingP = 0\\n            }\\n\\n            res += ridingP * boardingCost - runningCost\\n            //println(\"$ridingP * $boardingCost - $runningCost = $res\")\\n\\n            if(max < res) {\\n                max = res\\n                ans = idx\\n            }\\n            idx++\\n        }\\n\\n        if(max <= 0) {\\n            return -1\\n        }\\n\\n        return ans + 1\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1217698,
                "title": "swift-solution-simulation",
                "content": "Swift solution (simulation)\\n```\\nclass Solution {\\n    func minOperationsMaxProfit(_ customers: [Int], _ boardingCost: Int, _ runningCost: Int) -> Int {\\n        var waiting = 0, profit = 0, maxProfit = 0, turn = 0, result = -1\\n        func run() {\\n            let ongoing = min(waiting, 4)\\n            waiting -= ongoing\\n            profit += ongoing * boardingCost - runningCost\\n            turn += 1\\n            if profit > maxProfit {\\n                maxProfit = profit\\n                result = turn\\n            }\\n        }\\n        for customer in customers {\\n            waiting += customer\\n            run()\\n        }\\n        while waiting > 0 {\\n            run()\\n        }\\n        return result\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func minOperationsMaxProfit(_ customers: [Int], _ boardingCost: Int, _ runningCost: Int) -> Int {\\n        var waiting = 0, profit = 0, maxProfit = 0, turn = 0, result = -1\\n        func run() {\\n            let ongoing = min(waiting, 4)\\n            waiting -= ongoing\\n            profit += ongoing * boardingCost - runningCost\\n            turn += 1\\n            if profit > maxProfit {\\n                maxProfit = profit\\n                result = turn\\n            }\\n        }\\n        for customer in customers {\\n            waiting += customer\\n            run()\\n        }\\n        while waiting > 0 {\\n            run()\\n        }\\n        return result\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1195020,
                "title": "c-simulation-the-steps",
                "content": "* We simulate the behavior of the centennial wheel. For each rotation we update the # of waiting passengers, maximum/current profit, as well as the minimum rotate so far.\\n```\\nclass Solution {\\npublic:\\n    int minOperationsMaxProfit(vector<int>& customers, int boardingCost, int runningCost) {\\n        int wait = 0, curProfit = 0, maxProfit = 0, minRotate = -1, size = customers.size();\\n        vector<int> wheel(4, 0);\\n        for (int i = 0; (i < size || wait > 0) && !isFull(wheel); ++i)\\n        {\\n            int passengers = wheel[i % 4], cust = i < size ? customers[i] : 0;\\n            int board = min(4 - passengers, wait + cust);\\n            wait += cust - board;\\n            curProfit += board * boardingCost - runningCost;\\n            \\n            if (curProfit > maxProfit)\\n            {\\n                maxProfit = curProfit;\\n                minRotate = i + 1;\\n            }\\n        }\\n        \\n        return minRotate;\\n    }\\n    \\nprivate:\\n    inline bool isFull(const vector<int>& wheel)\\n    {\\n        return wheel == vector<int>{4, 4, 4, 4};\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperationsMaxProfit(vector<int>& customers, int boardingCost, int runningCost) {\\n        int wait = 0, curProfit = 0, maxProfit = 0, minRotate = -1, size = customers.size();\\n        vector<int> wheel(4, 0);\\n        for (int i = 0; (i < size || wait > 0) && !isFull(wheel); ++i)\\n        {\\n            int passengers = wheel[i % 4], cust = i < size ? customers[i] : 0;\\n            int board = min(4 - passengers, wait + cust);\\n            wait += cust - board;\\n            curProfit += board * boardingCost - runningCost;\\n            \\n            if (curProfit > maxProfit)\\n            {\\n                maxProfit = curProfit;\\n                minRotate = i + 1;\\n            }\\n        }\\n        \\n        return minRotate;\\n    }\\n    \\nprivate:\\n    inline bool isFull(const vector<int>& wheel)\\n    {\\n        return wheel == vector<int>{4, 4, 4, 4};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1189557,
                "title": "two-loops",
                "content": "```\\nclass Solution:\\n    def minOperationsMaxProfit(self, customers, boardingCost: int, runningCost: int) -> int:\\n        profit = 0\\n        waiting = 0\\n        lst_profit = []\\n        for arrived in customers:\\n            waiting += arrived\\n            loading = min(4, waiting)\\n            waiting -= loading\\n            profit += loading * boardingCost - runningCost\\n            lst_profit.append(profit)\\n        while waiting:\\n            loading = min(4, waiting)\\n            waiting -= loading\\n            profit += loading * boardingCost - runningCost\\n            lst_profit.append(profit)\\n        max_profit = max(lst_profit)\\n        return lst_profit.index(max_profit) + 1 if max_profit > 0 else -1\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minOperationsMaxProfit(self, customers, boardingCost: int, runningCost: int) -> int:\\n        profit = 0\\n        waiting = 0\\n        lst_profit = []\\n        for arrived in customers:\\n            waiting += arrived\\n            loading = min(4, waiting)\\n            waiting -= loading\\n            profit += loading * boardingCost - runningCost\\n            lst_profit.append(profit)\\n        while waiting:\\n            loading = min(4, waiting)\\n            waiting -= loading\\n            profit += loading * boardingCost - runningCost\\n            lst_profit.append(profit)\\n        max_profit = max(lst_profit)\\n        return lst_profit.index(max_profit) + 1 if max_profit > 0 else -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1094459,
                "title": "java-10ms-simple-solution-easy-to-understand",
                "content": "```\\nclass Solution {\\n    public int minOperationsMaxProfit(int[] customers, int boardingCost, int runningCost) {\\n        int waiting=0;\\n        int max=0;\\n        int profit=0;\\n        int running=0;\\n        int boarded=0;\\n        int gain_rotation=0;\\n        for(int i=0;i<customers.length;i++){\\n            running++;\\n            if(customers[i]>=4){\\n                waiting+=customers[i]-4;\\n                boarded+=4;\\n                profit=(boarded*boardingCost)-(running*runningCost);\\n                if(profit>max){\\n                    max=profit;\\n                    gain_rotation=running;\\n                }\\n            }else{\\n                if(waiting>=4-customers[i]){\\n                    boarded+=4;\\n                    waiting-=4-customers[i];\\n                }else{\\n                    boarded+=customers[i];\\n                }\\n                profit=(boarded*boardingCost)-(running*runningCost);\\n                if(profit>max){\\n                    max=profit;\\n                    gain_rotation=running;\\n                    \\n                }\\n            }\\n        }\\n        while(waiting>0){\\n            running++;\\n            if(waiting>=4){\\n                boarded+=4;\\n                waiting-=4;\\n                profit=(boarded*boardingCost)-(running*runningCost);\\n                if(profit>max){\\n                    max=profit;\\n                    gain_rotation=running;\\n                }\\n            }else{\\n                boarded+=waiting;\\n                waiting=0;\\n                profit=(boarded*boardingCost)-(running*runningCost);\\n                if(profit>max){\\n                    max=profit;\\n                    gain_rotation=running;\\n                }\\n            }\\n        }\\n        return max==0?-1:gain_rotation;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minOperationsMaxProfit(int[] customers, int boardingCost, int runningCost) {\\n        int waiting=0;\\n        int max=0;\\n        int profit=0;\\n        int running=0;\\n        int boarded=0;\\n        int gain_rotation=0;\\n        for(int i=0;i<customers.length;i++){\\n            running++;\\n            if(customers[i]>=4){\\n                waiting+=customers[i]-4;\\n                boarded+=4;\\n                profit=(boarded*boardingCost)-(running*runningCost);\\n                if(profit>max){\\n                    max=profit;\\n                    gain_rotation=running;\\n                }\\n            }else{\\n                if(waiting>=4-customers[i]){\\n                    boarded+=4;\\n                    waiting-=4-customers[i];\\n                }else{\\n                    boarded+=customers[i];\\n                }\\n                profit=(boarded*boardingCost)-(running*runningCost);\\n                if(profit>max){\\n                    max=profit;\\n                    gain_rotation=running;\\n                    \\n                }\\n            }\\n        }\\n        while(waiting>0){\\n            running++;\\n            if(waiting>=4){\\n                boarded+=4;\\n                waiting-=4;\\n                profit=(boarded*boardingCost)-(running*runningCost);\\n                if(profit>max){\\n                    max=profit;\\n                    gain_rotation=running;\\n                }\\n            }else{\\n                boarded+=waiting;\\n                waiting=0;\\n                profit=(boarded*boardingCost)-(running*runningCost);\\n                if(profit>max){\\n                    max=profit;\\n                    gain_rotation=running;\\n                }\\n            }\\n        }\\n        return max==0?-1:gain_rotation;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1077817,
                "title": "scenario-outcome",
                "content": "[0,4,1]\\n43\\n54\\n\\nAccording to me result should be 1 rotation as profit would be maximized:\\n4*43 - 1*54 = 118\\n\\nbut answer expected is two rotation where profit will be\\n4*43 - 2 * 54 = 107\\n\\nAny ideas?",
                "solutionTags": [],
                "code": "[0,4,1]\\n43\\n54\\n\\nAccording to me result should be 1 rotation as profit would be maximized:\\n4*43 - 1*54 = 118\\n\\nbut answer expected is two rotation where profit will be\\n4*43 - 2 * 54 = 107\\n\\nAny ideas?",
                "codeTag": "Unknown"
            },
            {
                "id": 1069445,
                "title": "java-short-solution",
                "content": "```\\n    public int minOperationsMaxProfit(int[] customers, int boardingCost, int runningCost) {\\n        int r = 0, p = 0, max_p = 0, max_r = -1, count = 0, idx = 0;\\n        while(idx < customers.length || count > 0) {\\n            int e = idx < customers.length ? customers[idx++] : 0;\\n            r++;\\n            count += e;\\n            int on = Math.min(count, 4);\\n            count -= on;\\n            \\n            p += boardingCost*on - runningCost;\\n            \\n            if(p > max_p) {\\n                max_p = p;\\n                max_r = r;\\n            }\\n        }\\n        return max_r;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public int minOperationsMaxProfit(int[] customers, int boardingCost, int runningCost) {\\n        int r = 0, p = 0, max_p = 0, max_r = -1, count = 0, idx = 0;\\n        while(idx < customers.length || count > 0) {\\n            int e = idx < customers.length ? customers[idx++] : 0;\\n            r++;\\n            count += e;\\n            int on = Math.min(count, 4);\\n            count -= on;\\n            \\n            p += boardingCost*on - runningCost;\\n            \\n            if(p > max_p) {\\n                max_p = p;\\n                max_r = r;\\n            }\\n        }\\n        return max_r;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1067632,
                "title": "java-greedy",
                "content": "```\\nclass Solution {\\n    public int minOperationsMaxProfit(int[] customers, int boardingCost, int runningCost) {\\n\\t\\t// if running cost is too high, it\\'s not possible to make profit\\n        if(runningCost>=4*boardingCost) return -1;\\n        int profit=0,maxProfit=0,waitingCnt=0,opCnt=0,result=-1;\\n        while(true) {\\n\\t\\t\\t// running cost\\n            profit-=runningCost;\\n            if(opCnt<customers.length) {\\n\\t\\t\\t\\t// add customer to waiting list\\n                waitingCnt+=customers[opCnt];\\n            }\\n\\t\\t\\t\\n\\t\\t\\t// add operation count\\n            opCnt++;\\n\\t\\t\\t\\n\\t\\t\\t// onboard and make profit\\n            var onboard=Math.min(4,waitingCnt);\\n            waitingCnt-=onboard;\\n            profit+=onboard*boardingCost;\\n\\t\\t\\t\\n\\t\\t\\t// check if make better profit \\n            if(profit>maxProfit) {\\n                maxProfit=profit;\\n                result=opCnt;\\n            }\\n            \\n\\t\\t\\t// quit if there is no more new customer and waiting list is empty\\n            if(waitingCnt==0&&opCnt>=customers.length) break;\\n        }\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minOperationsMaxProfit(int[] customers, int boardingCost, int runningCost) {\\n\\t\\t// if running cost is too high, it\\'s not possible to make profit\\n        if(runningCost>=4*boardingCost) return -1;\\n        int profit=0,maxProfit=0,waitingCnt=0,opCnt=0,result=-1;\\n        while(true) {\\n\\t\\t\\t// running cost\\n            profit-=runningCost;\\n            if(opCnt<customers.length) {\\n\\t\\t\\t\\t// add customer to waiting list\\n                waitingCnt+=customers[opCnt];\\n            }\\n\\t\\t\\t\\n\\t\\t\\t// add operation count\\n            opCnt++;\\n\\t\\t\\t\\n\\t\\t\\t// onboard and make profit\\n            var onboard=Math.min(4,waitingCnt);\\n            waitingCnt-=onboard;\\n            profit+=onboard*boardingCost;\\n\\t\\t\\t\\n\\t\\t\\t// check if make better profit \\n            if(profit>maxProfit) {\\n                maxProfit=profit;\\n                result=opCnt;\\n            }\\n            \\n\\t\\t\\t// quit if there is no more new customer and waiting list is empty\\n            if(waitingCnt==0&&opCnt>=customers.length) break;\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1030200,
                "title": "c-14-line",
                "content": "```\\n    int minOperationsMaxProfit(vector<int>& customers, int boardingCost, int runningCost) {\\n        int maxProfit = 0, curProfit = 0, bestRotate = 0, numRotate = 0, numWait = 0;\\n        auto oneRotate = [&]() mutable{\\n            int numIn = min(4, numWait);\\n            numWait -= numIn;\\n            numRotate++;\\n            curProfit += numIn * boardingCost - runningCost;\\n            if(curProfit > maxProfit) maxProfit = curProfit, bestRotate = numRotate;\\n        };\\n                \\n        for(auto x:customers){\\n            numWait += x;\\n            oneRotate();\\n        }\\n        while(numWait > 0) oneRotate();\\n        return maxProfit > 0 ? bestRotate : -1; \\n    }",
                "solutionTags": [],
                "code": "```\\n    int minOperationsMaxProfit(vector<int>& customers, int boardingCost, int runningCost) {\\n        int maxProfit = 0, curProfit = 0, bestRotate = 0, numRotate = 0, numWait = 0;\\n        auto oneRotate = [&]() mutable{\\n            int numIn = min(4, numWait);\\n            numWait -= numIn;\\n            numRotate++;\\n            curProfit += numIn * boardingCost - runningCost;\\n            if(curProfit > maxProfit) maxProfit = curProfit, bestRotate = numRotate;\\n        };\\n                \\n        for(auto x:customers){\\n            numWait += x;\\n            oneRotate();\\n        }\\n        while(numWait > 0) oneRotate();\\n        return maxProfit > 0 ? bestRotate : -1; \\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1016720,
                "title": "c-100-100",
                "content": "to be honest surprised with result, didnt even try smaller types, noone practice C nowadays?\\n\\n...\\nint minOperationsMaxProfit(int* customers, int customersSize, int boardingCost, int runningCost)\\n{\\n\\n    int bestprofit[2]= {0,0}; /*Rotation,profit*/\\n    int gondola_max = 4;\\n    int pplOnGondola = 0;\\n    int waiting_ppl = 0;\\n    int i = 0;\\n    int iter = 1;\\n    int sum = 0;\\n    bool flag = false;\\n\\t\\n    while( waiting_ppl != 0 || i < customersSize )\\n    {\\n\\t\\n        if (i < customersSize)\\n        {\\n            waiting_ppl += customers[i];\\n            i++;\\n        }\\n\\t\\t\\n        if (gondola_max < waiting_ppl)\\n        {\\n            pplOnGondola += gondola_max;\\n            waiting_ppl -=gondola_max;\\n        }\\n\\t\\t\\n        else{\\n            pplOnGondola += waiting_ppl;\\n            waiting_ppl= 0;\\n        }\\n\\t\\t\\n        sum = (pplOnGondola*boardingCost)-(iter*runningCost);\\n\\n        if(bestprofit[1]<sum)\\n        {\\n            bestprofit[0]=iter;\\n            bestprofit[1]=sum;\\n            flag=true;\\n        }\\n        sum = 0;\\n        iter +=1; \\n    }\\n    if (flag==false)\\n    {\\n        return -1;\\n    }\\n    else{\\n        return bestprofit[0];\\n    }\\n}\\n...",
                "solutionTags": [],
                "code": "to be honest surprised with result, didnt even try smaller types, noone practice C nowadays?\\n\\n...\\nint minOperationsMaxProfit(int* customers, int customersSize, int boardingCost, int runningCost)\\n{\\n\\n    int bestprofit[2]= {0,0}; /*Rotation,profit*/\\n    int gondola_max = 4;\\n    int pplOnGondola = 0;\\n    int waiting_ppl = 0;\\n    int i = 0;\\n    int iter = 1;\\n    int sum = 0;\\n    bool flag = false;\\n\\t\\n    while( waiting_ppl != 0 || i < customersSize )\\n    {\\n\\t\\n        if (i < customersSize)\\n        {\\n            waiting_ppl += customers[i];\\n            i++;\\n        }\\n\\t\\t\\n        if (gondola_max < waiting_ppl)\\n        {\\n            pplOnGondola += gondola_max;\\n            waiting_ppl -=gondola_max;\\n        }\\n\\t\\t\\n        else{\\n            pplOnGondola += waiting_ppl;\\n            waiting_ppl= 0;\\n        }\\n\\t\\t\\n        sum = (pplOnGondola*boardingCost)-(iter*runningCost);\\n\\n        if(bestprofit[1]<sum)\\n        {\\n            bestprofit[0]=iter;\\n            bestprofit[1]=sum;\\n            flag=true;\\n        }\\n        sum = 0;\\n        iter +=1; \\n    }\\n    if (flag==false)\\n    {\\n        return -1;\\n    }\\n    else{\\n        return bestprofit[0];\\n    }\\n}\\n...",
                "codeTag": "Unknown"
            },
            {
                "id": 1013725,
                "title": "my-java-solution-9ms",
                "content": "The problem is nothing special but the description itself is a bit confusing (or too much detailed information).\\n\\n```\\nclass Solution {\\n    public int minOperationsMaxProfit(int[] customers, int boardingCost, int runningCost) {\\n        int res = -1, profit = 0, maxProfit = 0, currCustomers = 0, rotations = 0;\\n        \\n        while (rotations < customers.length || currCustomers > 0) {\\n            if (rotations < customers.length)\\n                currCustomers += customers[rotations];\\n            int board = currCustomers >= 4 ? 4 : currCustomers;\\n            profit += board * boardingCost - runningCost;\\n            \\n            if (profit > maxProfit) {\\n                maxProfit = profit;\\n                res = rotations + 1;\\n            }\\n            currCustomers -= board;\\n            rotations++;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minOperationsMaxProfit(int[] customers, int boardingCost, int runningCost) {\\n        int res = -1, profit = 0, maxProfit = 0, currCustomers = 0, rotations = 0;\\n        \\n        while (rotations < customers.length || currCustomers > 0) {\\n            if (rotations < customers.length)\\n                currCustomers += customers[rotations];\\n            int board = currCustomers >= 4 ? 4 : currCustomers;\\n            profit += board * boardingCost - runningCost;\\n            \\n            if (profit > maxProfit) {\\n                maxProfit = profit;\\n                res = rotations + 1;\\n            }\\n            currCustomers -= board;\\n            rotations++;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 997205,
                "title": "c-simulation-solution",
                "content": "Run-time is `O(N)`, space is `O(1)`. \\n\\n```\\nclass Solution {\\npublic:\\n    int minOperationsMaxProfit(vector<int>& customers, int boardingCost, int runningCost) {\\n        int maxProfit{0}, counter{-1}, numPeople{0}, curProfit{0};\\n        for(int i{0}, j{1}, size{(int)customers.size()}; i < size || numPeople; ++i, ++j) {\\n            if(i < size) numPeople += customers[i];\\n            int board{std::min(4,numPeople)};\\n            numPeople -= board;\\n            curProfit += board * boardingCost - runningCost;\\n            if(curProfit > maxProfit) maxProfit = curProfit, counter = j;\\n        }\\n        \\n        return counter;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperationsMaxProfit(vector<int>& customers, int boardingCost, int runningCost) {\\n        int maxProfit{0}, counter{-1}, numPeople{0}, curProfit{0};\\n        for(int i{0}, j{1}, size{(int)customers.size()}; i < size || numPeople; ++i, ++j) {\\n            if(i < size) numPeople += customers[i];\\n            int board{std::min(4,numPeople)};\\n            numPeople -= board;\\n            curProfit += board * boardingCost - runningCost;\\n            if(curProfit > maxProfit) maxProfit = curProfit, counter = j;\\n        }\\n        \\n        return counter;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 946205,
                "title": "simple-c-code-faster-than-94-37-c-submissions",
                "content": "Take a variable ```buffer``` which will store the number of customer currently in the queue. If ```buffer<=4```, empty the buffer and if ```buffer>4``` place 4 customer into the gondola and perform further rotation. Keep filling ```buffer``` till the customers array is empty.\\n\\n```\\nclass Solution {\\npublic:\\n    int minOperationsMaxProfit(vector<int>& customers, int boardingCost, int runningCost) {\\n        int max_profit = 0;\\n        int rotations = -1;\\n        int n = customers.size();\\n        if(n==0) return -1;\\n        int buffer = 0;\\n        int profit = 0;\\n        int i=0;\\n        while(buffer!=0 || i<n) {\\n            if(i<n) buffer+=customers[i];\\n            if(buffer<4) {\\n                profit+=((buffer*boardingCost)-runningCost);\\n                buffer=0;\\n            } else {\\n                profit+=((4*boardingCost)-runningCost);\\n                buffer-=4;\\n            }\\n            if(profit>max_profit) {\\n                max_profit=profit;\\n                rotations=i+1;\\n            }\\n            i++;\\n        }\\n        return rotations;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```buffer```\n```buffer<=4```\n```buffer>4```\n```buffer```\n```\\nclass Solution {\\npublic:\\n    int minOperationsMaxProfit(vector<int>& customers, int boardingCost, int runningCost) {\\n        int max_profit = 0;\\n        int rotations = -1;\\n        int n = customers.size();\\n        if(n==0) return -1;\\n        int buffer = 0;\\n        int profit = 0;\\n        int i=0;\\n        while(buffer!=0 || i<n) {\\n            if(i<n) buffer+=customers[i];\\n            if(buffer<4) {\\n                profit+=((buffer*boardingCost)-runningCost);\\n                buffer=0;\\n            } else {\\n                profit+=((4*boardingCost)-runningCost);\\n                buffer-=4;\\n            }\\n            if(profit>max_profit) {\\n                max_profit=profit;\\n                rotations=i+1;\\n            }\\n            i++;\\n        }\\n        return rotations;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 912457,
                "title": "java-with-comments",
                "content": "```\\npublic int minOperationsMaxProfit(int[] customers, int boardingCost, int runningCost) {\\n        \\n        int qCnt = 0, max = 0, profit = 0, i = 0, rotateCnt = 0;\\n        int res = -1;\\n\\t\\t\\n\\t\\t//continue while there is queue or there are new customers\\n        while (qCnt > 0 || i < customers.length) {\\n            int currCnt = 0;\\n\\t\\t\\t\\n\\t\\t\\t//add new customers if avail\\n            if (i < customers.length) {\\n                qCnt += customers[i++];\\n            }\\n\\n          //calculate current number of customer\\n            if (qCnt >= 4) {\\n                currCnt = 4;\\n                qCnt -= 4;\\n            } else {\\n                currCnt = qCnt;\\n                qCnt = 0;\\n            }\\n\\t\\t\\t\\n\\t\\t\\t//calculate current round profit\\n            profit += (currCnt * boardingCost - runningCost);\\n            rotateCnt++;\\n\\t\\t\\t\\n\\t\\t\\t//store to results if profit is more\\n            if (profit > max) {\\n                max = profit;\\n                res = rotateCnt;\\n            }\\n        }\\n        return res;\\n    }\\n\\t```",
                "solutionTags": [],
                "code": "```\\npublic int minOperationsMaxProfit(int[] customers, int boardingCost, int runningCost) {\\n        \\n        int qCnt = 0, max = 0, profit = 0, i = 0, rotateCnt = 0;\\n        int res = -1;\\n\\t\\t\\n\\t\\t//continue while there is queue or there are new customers\\n        while (qCnt > 0 || i < customers.length) {\\n            int currCnt = 0;\\n\\t\\t\\t\\n\\t\\t\\t//add new customers if avail\\n            if (i < customers.length) {\\n                qCnt += customers[i++];\\n            }\\n\\n          //calculate current number of customer\\n            if (qCnt >= 4) {\\n                currCnt = 4;\\n                qCnt -= 4;\\n            } else {\\n                currCnt = qCnt;\\n                qCnt = 0;\\n            }\\n\\t\\t\\t\\n\\t\\t\\t//calculate current round profit\\n            profit += (currCnt * boardingCost - runningCost);\\n            rotateCnt++;\\n\\t\\t\\t\\n\\t\\t\\t//store to results if profit is more\\n            if (profit > max) {\\n                max = profit;\\n                res = rotateCnt;\\n            }\\n        }\\n        return res;\\n    }\\n\\t```",
                "codeTag": "Unknown"
            },
            {
                "id": 885982,
                "title": "golang-solution",
                "content": "```go\\nfunc minOperationsMaxProfit(customers []int, boardingCost int, runningCost int) int {\\n    \\n    waiting := 0\\n    served := 0\\n    \\n    rotation := 1\\n    max := -1\\n    optimalRotation := -1\\n    for {\\n        newCustomers := waiting\\n        if rotation <= len(customers) {\\n            newCustomers = customers[rotation-1] + waiting \\n        }\\n \\n        if newCustomers >= 4 {\\n            waiting = newCustomers - 4\\n            served += 4\\n        } else {\\n            waiting = 0\\n            served += newCustomers\\n        }\\n        \\n        newProfit := calculateProfit(served, rotation, boardingCost, runningCost)\\n        if max < newProfit {\\n            max = newProfit\\n            optimalRotation = rotation\\n        }\\n        if rotation > len(customers) && waiting == 0 {\\n            break\\n        }\\n        rotation++\\n\\n    }\\n    \\n    if max <= 0 {\\n        return -1\\n    }\\n\\n    return optimalRotation\\n}\\n\\nfunc calculateProfit(served, rotation, boardingCost, runningCost int) int {\\n    // fmt.Println(served, boardingCost, rotation, runningCost)\\n    return served*boardingCost - rotation * runningCost\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```go\\nfunc minOperationsMaxProfit(customers []int, boardingCost int, runningCost int) int {\\n    \\n    waiting := 0\\n    served := 0\\n    \\n    rotation := 1\\n    max := -1\\n    optimalRotation := -1\\n    for {\\n        newCustomers := waiting\\n        if rotation <= len(customers) {\\n            newCustomers = customers[rotation-1] + waiting \\n        }\\n \\n        if newCustomers >= 4 {\\n            waiting = newCustomers - 4\\n            served += 4\\n        } else {\\n            waiting = 0\\n            served += newCustomers\\n        }\\n        \\n        newProfit := calculateProfit(served, rotation, boardingCost, runningCost)\\n        if max < newProfit {\\n            max = newProfit\\n            optimalRotation = rotation\\n        }\\n        if rotation > len(customers) && waiting == 0 {\\n            break\\n        }\\n        rotation++\\n\\n    }\\n    \\n    if max <= 0 {\\n        return -1\\n    }\\n\\n    return optimalRotation\\n}\\n\\nfunc calculateProfit(served, rotation, boardingCost, runningCost int) int {\\n    // fmt.Println(served, boardingCost, rotation, runningCost)\\n    return served*boardingCost - rotation * runningCost\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 882525,
                "title": "java-straight-forward-solution",
                "content": "```\\nclass Solution {\\n    public int minOperationsMaxProfit(int[] customers, int boardingCost, int runningCost) {\\n        int rest = 0, i = 0, max = 0, profit = 0, time = 0, res = -1;\\n        while (i < customers.length || rest > 0) {\\n            time++;\\n            if (i < customers.length) rest += customers[i++];\\n            if (rest >= 4) {\\n                profit += boardingCost * 4;\\n                rest -= 4;\\n            } else {\\n                profit += boardingCost * rest;\\n                rest = 0;\\n            }\\n            profit -= runningCost;\\n            if (profit > max) {\\n                max = profit;\\n                res = time;\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minOperationsMaxProfit(int[] customers, int boardingCost, int runningCost) {\\n        int rest = 0, i = 0, max = 0, profit = 0, time = 0, res = -1;\\n        while (i < customers.length || rest > 0) {\\n            time++;\\n            if (i < customers.length) rest += customers[i++];\\n            if (rest >= 4) {\\n                profit += boardingCost * 4;\\n                rest -= 4;\\n            } else {\\n                profit += boardingCost * rest;\\n                rest = 0;\\n            }\\n            profit -= runningCost;\\n            if (profit > max) {\\n                max = profit;\\n                res = time;\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 875718,
                "title": "c-greedy-approach",
                "content": "```\\nclass Solution {\\npublic:\\n    /*\\n    [10,10,6,4,7]\\n    3\\n    8\\n    */\\n    int minOperationsMaxProfit(vector<int>& customers, int boardingCost, int runningCost) {\\n        int i=0;\\n        int rc = 1, ans, cc = 0; //rc -- current running counter; cc -- current customer count\\n        int tempProfit, profit = 0; \\n        int tot = 0; //waiting customers\\n        while(i<customers.size() || tot > 0) {\\n            if(i<customers.size()) tot += customers[i];\\n            if(tot >= 4) {\\n                cc += 4;\\n                tot -= 4;\\n            } else {\\n                cc += tot;\\n                tot = 0;\\n            }\\n            tempProfit = cc*boardingCost - (rc*runningCost);\\n            if(tempProfit > profit) {\\n                profit = tempProfit;\\n                ans = rc;\\n            }\\n            rc++;\\n            i++;\\n        }\\n        return profit == 0 ? -1 : ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    /*\\n    [10,10,6,4,7]\\n    3\\n    8\\n    */\\n    int minOperationsMaxProfit(vector<int>& customers, int boardingCost, int runningCost) {\\n        int i=0;\\n        int rc = 1, ans, cc = 0; //rc -- current running counter; cc -- current customer count\\n        int tempProfit, profit = 0; \\n        int tot = 0; //waiting customers\\n        while(i<customers.size() || tot > 0) {\\n            if(i<customers.size()) tot += customers[i];\\n            if(tot >= 4) {\\n                cc += 4;\\n                tot -= 4;\\n            } else {\\n                cc += tot;\\n                tot = 0;\\n            }\\n            tempProfit = cc*boardingCost - (rc*runningCost);\\n            if(tempProfit > profit) {\\n                profit = tempProfit;\\n                ans = rc;\\n            }\\n            rc++;\\n            i++;\\n        }\\n        return profit == 0 ? -1 : ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 872937,
                "title": "javascript",
                "content": "```js\\nvar minOperationsMaxProfit = function(A, bc, rc) {\\n    let lineSize = 0;\\n    let max = 0;\\n    let profit = 0;\\n    let i = 0;\\n    let r = -1;\\n    while (lineSize || i < A.length) {\\n        if (A[i]) lineSize += A[i];\\n        const inSize = Math.min(4, lineSize);\\n        lineSize -= inSize;\\n        profit += (inSize * bc) - rc;\\n        ++i;\\n        if (profit > max) {\\n            r = i;\\n            max = profit;\\n        }\\n    }\\n    return r;\\n};\\n```",
                "solutionTags": [],
                "code": "```js\\nvar minOperationsMaxProfit = function(A, bc, rc) {\\n    let lineSize = 0;\\n    let max = 0;\\n    let profit = 0;\\n    let i = 0;\\n    let r = -1;\\n    while (lineSize || i < A.length) {\\n        if (A[i]) lineSize += A[i];\\n        const inSize = Math.min(4, lineSize);\\n        lineSize -= inSize;\\n        profit += (inSize * bc) - rc;\\n        ++i;\\n        if (profit > max) {\\n            r = i;\\n            max = profit;\\n        }\\n    }\\n    return r;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 871319,
                "title": "brute-force-easy-to-understand",
                "content": "class Solution {\\n    public int minOperationsMaxProfit(int[] customers, int boardingCost, int runningCost) {\\n        int profit = 0;\\n        int result = -1;\\n        int waiting = 0;\\n        int maxprofit = 0;\\n        \\n        for(int i = 0; i < customers.length || waiting > 0; i++){\\n            if(i < customers.length ){\\n                waiting += customers[i];\\n            }\\n            int onborading = Math.min(waiting,4);\\n            waiting -= onborading;\\n            profit += onborading * boardingCost;\\n            profit -= runningCost;\\n            if(profit > maxprofit){\\n                maxprofit = profit;\\n                result = i + 1;\\n            }\\n        }\\n        return result;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int minOperationsMaxProfit(int[] customers, int boardingCost, int runningCost) {\\n        int profit = 0;\\n        int result = -1;\\n        int waiting = 0;\\n        int maxprofit = 0;\\n        \\n        for(int i = 0; i < customers.length || waiting > 0; i++){\\n            if(i < customers.length ){\\n                waiting += customers[i];\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 871179,
                "title": "rust-translated-20ms-75",
                "content": "```rust\\nimpl Solution {\\n    pub fn min_operations_max_profit(\\n        customers: Vec<i32>,\\n        boarding_cost: i32,\\n        running_cost: i32,\\n    ) -> i32 {\\n        let mut run = 0;\\n        let mut max_run = 0;\\n        let mut profit = 0;\\n        let mut max_profit = 0;\\n        let mut sum = 0;\\n        let mut i = 0;\\n        while sum > 0 || i < customers.len() {\\n            if i < customers.len() {\\n                sum += customers[i];\\n                i += 1;\\n            }\\n            let board = if sum > 4 { 4 } else { sum };\\n            sum -= board;\\n            profit += board * boarding_cost - running_cost;\\n            run += 1;\\n            if profit > max_profit {\\n                max_profit = profit;\\n                max_run = run;\\n            }\\n        }\\n        if max_profit > 0 {\\n            max_run\\n        } else {\\n            -1\\n        }\\n    }\\n}\\n\\n#[cfg(test)]\\nmod tests {\\n    use super::*;\\n\\n    #[test]\\n    fn test_min_operations_max_profit() {\\n        assert_eq!(Solution::min_operations_max_profit(vec![8, 3], 5, 6), 3);\\n    }\\n\\n    #[test]\\n    fn test_min_operations_max_profit_02() {\\n        assert_eq!(Solution::min_operations_max_profit(vec![10, 9, 6], 6, 4), 7);\\n    }\\n\\n    #[test]\\n    fn test_min_operations_max_profit_03() {\\n        assert_eq!(\\n            Solution::min_operations_max_profit(vec![3, 4, 0, 5, 1], 1, 92),\\n            -1\\n        );\\n    }\\n\\n    #[test]\\n    fn test_min_operations_max_profit_04() {\\n        assert_eq!(\\n            Solution::min_operations_max_profit(vec![10, 10, 6, 4, 7], 3, 8),\\n            9\\n        );\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```rust\\nimpl Solution {\\n    pub fn min_operations_max_profit(\\n        customers: Vec<i32>,\\n        boarding_cost: i32,\\n        running_cost: i32,\\n    ) -> i32 {\\n        let mut run = 0;\\n        let mut max_run = 0;\\n        let mut profit = 0;\\n        let mut max_profit = 0;\\n        let mut sum = 0;\\n        let mut i = 0;\\n        while sum > 0 || i < customers.len() {\\n            if i < customers.len() {\\n                sum += customers[i];\\n                i += 1;\\n            }\\n            let board = if sum > 4 { 4 } else { sum };\\n            sum -= board;\\n            profit += board * boarding_cost - running_cost;\\n            run += 1;\\n            if profit > max_profit {\\n                max_profit = profit;\\n                max_run = run;\\n            }\\n        }\\n        if max_profit > 0 {\\n            max_run\\n        } else {\\n            -1\\n        }\\n    }\\n}\\n\\n#[cfg(test)]\\nmod tests {\\n    use super::*;\\n\\n    #[test]\\n    fn test_min_operations_max_profit() {\\n        assert_eq!(Solution::min_operations_max_profit(vec![8, 3], 5, 6), 3);\\n    }\\n\\n    #[test]\\n    fn test_min_operations_max_profit_02() {\\n        assert_eq!(Solution::min_operations_max_profit(vec![10, 9, 6], 6, 4), 7);\\n    }\\n\\n    #[test]\\n    fn test_min_operations_max_profit_03() {\\n        assert_eq!(\\n            Solution::min_operations_max_profit(vec![3, 4, 0, 5, 1], 1, 92),\\n            -1\\n        );\\n    }\\n\\n    #[test]\\n    fn test_min_operations_max_profit_04() {\\n        assert_eq!(\\n            Solution::min_operations_max_profit(vec![10, 10, 6, 4, 7], 3, 8),\\n            9\\n        );\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 869693,
                "title": "golang-116ms-100",
                "content": "```go\\nfunc minOperationsMaxProfit(customers []int, boardingCost int, runningCost int) int {\\n\\tprofit := math.MinInt32\\n\\tpeople := 0\\n\\twait := 0\\n\\tmaxRound := 0\\n\\tfor i, c := range customers {\\n\\t\\twait += c\\n\\t\\tpeople += c\\n\\t\\tif wait <= 4 {\\n\\t\\t\\twait = 0\\n\\t\\t} else {\\n\\t\\t\\twait -= 4\\n\\t\\t}\\n\\t\\tcurr, round := currentProfit(wait, people, i+1, boardingCost, runningCost)\\n\\t\\tif curr > profit {\\n\\t\\t\\tprofit = curr\\n\\t\\t\\tmaxRound = round\\n\\t\\t}\\n\\t}\\n\\tif profit <= 0 {\\n\\t\\treturn -1\\n\\t}\\n\\treturn maxRound\\n}\\n\\nfunc currentProfit(wait, people, round, boardingCost, runningCost int) (int, int) {\\n\\tround += wait/4\\n\\tprofit := (people - wait%4) * boardingCost - round * runningCost\\n\\tif wait % 4 != 0 {\\n\\t\\ttemp := people * boardingCost - (round+1) * runningCost\\n\\t\\tif temp > profit {\\n\\t\\t\\treturn temp, round+1\\n\\t\\t}\\n\\t}\\n\\treturn profit, round\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```go\\nfunc minOperationsMaxProfit(customers []int, boardingCost int, runningCost int) int {\\n\\tprofit := math.MinInt32\\n\\tpeople := 0\\n\\twait := 0\\n\\tmaxRound := 0\\n\\tfor i, c := range customers {\\n\\t\\twait += c\\n\\t\\tpeople += c\\n\\t\\tif wait <= 4 {\\n\\t\\t\\twait = 0\\n\\t\\t} else {\\n\\t\\t\\twait -= 4\\n\\t\\t}\\n\\t\\tcurr, round := currentProfit(wait, people, i+1, boardingCost, runningCost)\\n\\t\\tif curr > profit {\\n\\t\\t\\tprofit = curr\\n\\t\\t\\tmaxRound = round\\n\\t\\t}\\n\\t}\\n\\tif profit <= 0 {\\n\\t\\treturn -1\\n\\t}\\n\\treturn maxRound\\n}\\n\\nfunc currentProfit(wait, people, round, boardingCost, runningCost int) (int, int) {\\n\\tround += wait/4\\n\\tprofit := (people - wait%4) * boardingCost - round * runningCost\\n\\tif wait % 4 != 0 {\\n\\t\\ttemp := people * boardingCost - (round+1) * runningCost\\n\\t\\tif temp > profit {\\n\\t\\t\\treturn temp, round+1\\n\\t\\t}\\n\\t}\\n\\treturn profit, round\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 869623,
                "title": "python-linear-time",
                "content": "```\\nclass Solution:\\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\\n        if len(customers)==0:\\n            return -1\\n        wait = 0\\n        onboard = 0\\n        r=0\\n        max_prof, max_r, cost = float(\\'-inf\\'),0,0\\n        while customers[r] == 0:\\n            r+=1\\n            \\n        if customers:\\n            wait+=customers[r]\\n            while wait >0:\\n                c = min(wait, 4)\\n                wait = max(0, wait-4)\\n                onboard+=c\\n                r+=1\\n                cost = onboard*boardingCost - r*runningCost\\n                if cost >max_prof:\\n                    max_r = r\\n                    max_prof = cost\\n                if r<len(customers):\\n                    wait+=customers[r]\\n\\n        if max_prof <=0:\\n            return -1\\n        return max_r\\n            \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\\n        if len(customers)==0:\\n            return -1\\n        wait = 0\\n        onboard = 0\\n        r=0\\n        max_prof, max_r, cost = float(\\'-inf\\'),0,0\\n        while customers[r] == 0:\\n            r+=1\\n            \\n        if customers:\\n            wait+=customers[r]\\n            while wait >0:\\n                c = min(wait, 4)\\n                wait = max(0, wait-4)\\n                onboard+=c\\n                r+=1\\n                cost = onboard*boardingCost - r*runningCost\\n                if cost >max_prof:\\n                    max_r = r\\n                    max_prof = cost\\n                if r<len(customers):\\n                    wait+=customers[r]\\n\\n        if max_prof <=0:\\n            return -1\\n        return max_r\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 869303,
                "title": "passing-all-the-test-cases-except-last-two-which-case-missing",
                "content": "```\\nclass Solution {\\npublic:\\n    int minOperationsMaxProfit(vector<int>& customers, int boardingCost, int runningCost) {\\n        int sum = 0;\\n        int l = customers.size();\\n        for(int i = 0; i < l; i++){\\n            sum += customers[i];\\n        }\\n        int shift = sum / 4;\\n        int remain = sum - (shift * 4);\\n        //cout<<\"shift \"<<shift<<endl;\\n        //cout<<\"remain \"<<remain<<endl;\\n        int ans = INT_MIN;\\n        int j, index = 0;\\n        for(j = 1; j <= shift; j++){\\n            int cost = 4 * j * boardingCost - j * runningCost;\\n            if(ans < cost){\\n                ans = cost;\\n                index = j;\\n            }\\n        }\\n        if(remain > 0){\\n            int remainCost = sum * boardingCost - j *  runningCost;\\n            if(ans < remainCost){\\n                ans = remainCost;\\n                index = j;\\n            }\\n        }\\n        //cout<<\"ans \"<<ans<<endl;\\n        return ans < 0 ? -1 : index;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperationsMaxProfit(vector<int>& customers, int boardingCost, int runningCost) {\\n        int sum = 0;\\n        int l = customers.size();\\n        for(int i = 0; i < l; i++){\\n            sum += customers[i];\\n        }\\n        int shift = sum / 4;\\n        int remain = sum - (shift * 4);\\n        //cout<<\"shift \"<<shift<<endl;\\n        //cout<<\"remain \"<<remain<<endl;\\n        int ans = INT_MIN;\\n        int j, index = 0;\\n        for(j = 1; j <= shift; j++){\\n            int cost = 4 * j * boardingCost - j * runningCost;\\n            if(ans < cost){\\n                ans = cost;\\n                index = j;\\n            }\\n        }\\n        if(remain > 0){\\n            int remainCost = sum * boardingCost - j *  runningCost;\\n            if(ans < remainCost){\\n                ans = remainCost;\\n                index = j;\\n            }\\n        }\\n        //cout<<\"ans \"<<ans<<endl;\\n        return ans < 0 ? -1 : index;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 869291,
                "title": "python3-simple-simulation-o-n-940ms-100",
                "content": "```\\nclass Solution:\\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\\n        wait = 0\\n        pro = 0\\n        high = 0\\n        res = -1\\n        for i in range(len(customers)):\\n            vacc = 4 - wait\\n            if vacc <= 0:\\n                wait += customers[i] - 4\\n                pro += 4 * boardingCost - runningCost\\n            # board all\\n            elif customers[i] <= vacc: # board=customers[i]+wait\\n                pro += boardingCost * (customers[i] + wait) - runningCost\\n                wait = 0\\n            else:\\n                pro += boardingCost * 4 - runningCost\\n                wait += customers[i] - 4\\n            if pro > high:\\n                high = pro\\n                res = i\\n        # determine after all arrives\\n        pro_per = boardingCost * 4 - runningCost\\n        if pro_per > 0:\\n            last = wait % 4\\n            if wait >= 4:\\n                if boardingCost * last - runningCost > 0: return len(customers) + wait // 4 + 1\\n                else: return len(customers) + wait // 4\\n            if boardingCost * last - runningCost > 0: return len(customers) + 1\\n        return res + 1 if res >= 0 else -1\\n```\\nTwo parts: when customers incoming; after all customers arrived.\\nFor the first part, simple simulation.\\nFor the second part, determine whether profit per round with 4 or fewer (at the very last round) is positive.",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\\n        wait = 0\\n        pro = 0\\n        high = 0\\n        res = -1\\n        for i in range(len(customers)):\\n            vacc = 4 - wait\\n            if vacc <= 0:\\n                wait += customers[i] - 4\\n                pro += 4 * boardingCost - runningCost\\n            # board all\\n            elif customers[i] <= vacc: # board=customers[i]+wait\\n                pro += boardingCost * (customers[i] + wait) - runningCost\\n                wait = 0\\n            else:\\n                pro += boardingCost * 4 - runningCost\\n                wait += customers[i] - 4\\n            if pro > high:\\n                high = pro\\n                res = i\\n        # determine after all arrives\\n        pro_per = boardingCost * 4 - runningCost\\n        if pro_per > 0:\\n            last = wait % 4\\n            if wait >= 4:\\n                if boardingCost * last - runningCost > 0: return len(customers) + wait // 4 + 1\\n                else: return len(customers) + wait // 4\\n            if boardingCost * last - runningCost > 0: return len(customers) + 1\\n        return res + 1 if res >= 0 else -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 869130,
                "title": "c-easy-to-understand",
                "content": "```\\n int minOperationsMaxProfit(vector<int>& customers, int boardingCost, int runningCost) {\\n        int que=0, maxProfit = INT_MIN, profit=0, people=0;\\n        int i=1, count=1 ,maxCount=-1;\\n        que = customers[0];\\n \\n        while(que > 0 || i<customers.size() )\\n        {\\n            people = people + min(4, que);\\n            profit = (people*boardingCost) - (count * runningCost);\\n     \\n            if(profit > maxProfit)\\n            {\\n                maxCount = count;\\n                maxProfit = profit;\\n            }\\n            que = max(que-4, 0);\\n            if(i<customers.size())\\n                que = que+customers[i];\\n           \\n            i++;\\n            count++;\\n        }\\n    return maxProfit >=0? maxCount: -1;\\n    }",
                "solutionTags": [],
                "code": "```\\n int minOperationsMaxProfit(vector<int>& customers, int boardingCost, int runningCost) {\\n        int que=0, maxProfit = INT_MIN, profit=0, people=0;\\n        int i=1, count=1 ,maxCount=-1;\\n        que = customers[0];\\n \\n        while(que > 0 || i<customers.size() )\\n        {\\n            people = people + min(4, que);\\n            profit = (people*boardingCost) - (count * runningCost);\\n     \\n            if(profit > maxProfit)\\n            {\\n                maxCount = count;\\n                maxProfit = profit;\\n            }\\n            que = max(que-4, 0);\\n            if(i<customers.size())\\n                que = que+customers[i];\\n           \\n            i++;\\n            count++;\\n        }\\n    return maxProfit >=0? maxCount: -1;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 869126,
                "title": "c-solution",
                "content": "class Solution {\\npublic:\\n    int minOperationsMaxProfit(vector<int>& customers, int boardingCost, int runningCost) {\\n        int n=customers.size();\\n        if(n==0)\\n        {\\n            return -1;\\n        }\\n        int sum=0;\\n        int ind=-1;\\n        int mx=0;\\n        int total=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            total=total+customers[i];\\n            int profit=0;\\n            int temp;\\n            if(total>=4)\\n            {\\n                temp=4;\\n                total=total-4;\\n            }\\n            else\\n            {\\n                temp=total;\\n                total=0;\\n            }\\n            sum=sum+temp;\\n            profit=sum*boardingCost-(i+1)*runningCost;\\n            if(profit>mx)\\n            {\\n                mx=profit;\\n                ind=i+1;\\n            }\\n        }\\n        int round=n+1;\\n        while(total>0)\\n        {\\n            int profit=0;\\n            int temp;\\n            if(total>=4)\\n            {\\n                temp=4;\\n                total=total-4;\\n            }\\n            else\\n            {\\n                temp=total;\\n                total=0;\\n            }\\n            sum=sum+temp;\\n            profit=sum*boardingCost-(round)*runningCost;\\n            \\n            if(mx<profit)\\n            {\\n                mx=profit;\\n                ind=round;\\n            }\\n            round++;\\n        }\\n        if(ind==-1)\\n        {\\n            return -1;\\n        }\\n        else\\n        {\\n        return ind;\\n        }\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int minOperationsMaxProfit(vector<int>& customers, int boardingCost, int runningCost) {\\n        int n=customers.size();\\n        if(n==0)\\n        {\\n            return -1;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 868944,
                "title": "c-simple",
                "content": "```\\n int minOperationsMaxProfit(vector<int>& customers, int boardingCost, int runningCost) {\\n        int maxProfit = 0, ans = 0;\\n        int n = 0, i=0;\\n        int count = 0;\\n        while(i<customers.size() || n>0){\\n            if(i<customers.size())\\n                n+=customers[i++];\\n            int m = min(4, n);\\n            n = n-m>0? n-m: 0;\\n            int temp = m*boardingCost - runningCost;\\n            count++;\\n            if(maxProfit+temp > maxProfit){\\n                maxProfit +=temp;\\n                ans = count;\\n            }\\n        }\\n        \\n        return maxProfit == 0? -1: ans;\\n        \\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n int minOperationsMaxProfit(vector<int>& customers, int boardingCost, int runningCost) {\\n        int maxProfit = 0, ans = 0;\\n        int n = 0, i=0;\\n        int count = 0;\\n        while(i<customers.size() || n>0){\\n            if(i<customers.size())\\n                n+=customers[i++];\\n            int m = min(4, n);\\n            n = n-m>0? n-m: 0;\\n            int temp = m*boardingCost - runningCost;\\n            count++;\\n            if(maxProfit+temp > maxProfit){\\n                maxProfit +=temp;\\n                ans = count;\\n            }\\n        }\\n        \\n        return maxProfit == 0? -1: ans;\\n        \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 868826,
                "title": "python-solution-faster-than-100",
                "content": "\\t\\tdef minOperationsMaxProfit(self, customers, boardingCost, runningCost):\\n\\t\\t\\tans=0\\n\\t\\t\\tro =0\\n\\t\\t\\tr=t=p_max=0\\n\\t\\t\\tfor i in customers:\\n\\t\\t\\t\\tc=0\\n\\t\\t\\t\\tro+=1\\n\\t\\t\\t\\tif r<=0:\\n\\t\\t\\t\\t\\tt += min(4,i) \\n\\t\\t\\t\\t\\tr = max(0,i-4)\\n\\t\\t\\t\\t\\tc = t*boardingCost - ro*runningCost\\n\\t\\t\\t\\t\\tif c>p_max:\\n\\t\\t\\t\\t\\t\\tp_max=c\\n\\t\\t\\t\\t\\t\\tans=ro\\n\\n\\t\\t\\t\\telif r>0:\\n\\t\\t\\t\\t\\tt += 4\\n\\t\\t\\t\\t\\tr += i-4\\n\\t\\t\\t\\t\\tc = t*boardingCost - ro*runningCost\\n\\t\\t\\t\\t\\tif c>p_max:\\n\\t\\t\\t\\t\\t\\tp_max=c\\n\\t\\t\\t\\t\\t\\tans = ro\\n\\n\\t\\t\\twhile r>0:\\n\\t\\t\\t\\tro +=1\\n\\t\\t\\t\\tc=0\\n\\t\\t\\t\\tt += min(4,r)\\n\\t\\t\\t\\tr -= 4\\n\\t\\t\\t\\tc = t*boardingCost - ro*runningCost\\n\\t\\t\\t\\tif c>p_max:\\n\\t\\t\\t\\t\\tp_max= c\\n\\t\\t\\t\\t\\tans = ro\\n\\t\\t\\tif p_max==0:\\n\\t\\t\\t\\treturn -1\\n\\t\\t\\telse:\\n\\t\\t\\t\\treturn ans",
                "solutionTags": [],
                "code": "\\t\\tdef minOperationsMaxProfit(self, customers, boardingCost, runningCost):\\n\\t\\t\\tans=0\\n\\t\\t\\tro =0\\n\\t\\t\\tr=t=p_max=0\\n\\t\\t\\tfor i in customers:\\n\\t\\t\\t\\tc=0\\n\\t\\t\\t\\tro+=1\\n\\t\\t\\t\\tif r<=0:\\n\\t\\t\\t\\t\\tt += min(4,i) \\n\\t\\t\\t\\t\\tr = max(0,i-4)\\n\\t\\t\\t\\t\\tc = t*boardingCost - ro*runningCost\\n\\t\\t\\t\\t\\tif c>p_max:\\n\\t\\t\\t\\t\\t\\tp_max=c\\n\\t\\t\\t\\t\\t\\tans=ro\\n\\n\\t\\t\\t\\telif r>0:\\n\\t\\t\\t\\t\\tt += 4\\n\\t\\t\\t\\t\\tr += i-4\\n\\t\\t\\t\\t\\tc = t*boardingCost - ro*runningCost\\n\\t\\t\\t\\t\\tif c>p_max:\\n\\t\\t\\t\\t\\t\\tp_max=c\\n\\t\\t\\t\\t\\t\\tans = ro\\n\\n\\t\\t\\twhile r>0:\\n\\t\\t\\t\\tro +=1\\n\\t\\t\\t\\tc=0\\n\\t\\t\\t\\tt += min(4,r)\\n\\t\\t\\t\\tr -= 4\\n\\t\\t\\t\\tc = t*boardingCost - ro*runningCost\\n\\t\\t\\t\\tif c>p_max:\\n\\t\\t\\t\\t\\tp_max= c\\n\\t\\t\\t\\t\\tans = ro\\n\\t\\t\\tif p_max==0:\\n\\t\\t\\t\\treturn -1\\n\\t\\t\\telse:\\n\\t\\t\\t\\treturn ans",
                "codeTag": "Python3"
            },
            {
                "id": 868824,
                "title": "greedy-javascript-straightforward",
                "content": "Not much to it. Just calculate the profit at each turn and keep track of which turn has the max profit.\\n\\n```\\nconst minOperationsMaxProfit = ( customers, boardingCost, runningCost ) => {\\n    let boarding, i = 0\\n    let sum = 0, waiting = 0\\n    let max = 1, turn = -1\\n\\n    while ( waiting || i < customers.length ) {\\n        waiting += customers[ i++ ] || 0\\n        boarding = Math.min( 4, waiting )\\n        \\n        sum += boardingCost * boarding - runningCost\\n        waiting -= boarding\\n\\n        if ( sum > max ) {\\n            max = sum\\n            turn = i\\n        }\\n    }\\n\\n    return turn\\n}\\n```\\n",
                "solutionTags": [
                    "JavaScript",
                    "Greedy"
                ],
                "code": "```\\nconst minOperationsMaxProfit = ( customers, boardingCost, runningCost ) => {\\n    let boarding, i = 0\\n    let sum = 0, waiting = 0\\n    let max = 1, turn = -1\\n\\n    while ( waiting || i < customers.length ) {\\n        waiting += customers[ i++ ] || 0\\n        boarding = Math.min( 4, waiting )\\n        \\n        sum += boardingCost * boarding - runningCost\\n        waiting -= boarding\\n\\n        if ( sum > max ) {\\n            max = sum\\n            turn = i\\n        }\\n    }\\n\\n    return turn\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 868668,
                "title": "java-solution-o-n-time-and-space-o-1",
                "content": "class Solution {\\n    public int minOperationsMaxProfit(int[] customers, int boardingCost, int runningCost) {\\n        int count=0,currentTotal = 0,total=0;\\n        int minMax = 0,currentProfit=0,profitCount=-1;\\n        int i=0;\\n        \\n        if(customers.length==0){\\n            profitCount=0;\\n        }\\n        \\n        do{\\n            count++;\\n            if(i<customers.length){\\n                currentTotal += customers[i];\\n                total += customers[i];\\n            }\\n            \\n            if(currentTotal>4){\\n                currentTotal -=4;\\n            }\\n            else{\\n                currentTotal = 0;\\n            }\\n            currentProfit = (((total-currentTotal)*boardingCost)-(count*runningCost));\\n            if(minMax< currentProfit){\\n                minMax = currentProfit;\\n                profitCount = count;\\n            }\\n            i++;\\n        }while(i<customers.length||currentTotal>0);\\n        \\n        \\n        return profitCount>=0?profitCount:-1;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int minOperationsMaxProfit(int[] customers, int boardingCost, int runningCost) {\\n        int count=0,currentTotal = 0,total=0;\\n        int minMax = 0,currentProfit=0,profitCount=-1;\\n        int i=0;\\n        \\n        if(customers.length==0){\\n            profitCount=0;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 868665,
                "title": "python-beats-100-time",
                "content": "```python\\nclass Solution:\\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\\n        ans , board , wait = 0 , 0 , 0\\n        mc, mv  , c = 0,0 , 0\\n        for cur in customers:\\n            c+=1# for counting in which time we are just rotating the wheel\\n            if cur >= 4 or cur + wait >=4:\\n                ans += 4* boardingCost - runningCost\\n                wait += cur - 4\\n            else:\\n                ans += (cur + wait) * boardingCost - runningCost\\n                wait = 0\\n            \\n            # for finding the maximum\\n            if ans > mv:    mv = ans;mc = c\\n        # if still wait is there means we will calculate the ans\\n        while wait > 0:\\n            c += 1\\n            if wait >= 4:\\n                ans += 4* boardingCost - runningCost\\n                \\n            else:\\n                ans += wait * boardingCost - runningCost\\n            wait -=4\\n            # for finding the maximum\\n            if ans > mv:    mv = ans;mc = c\\n        return mc if mc > 0 else -1\\n        \\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\\n        ans , board , wait = 0 , 0 , 0\\n        mc, mv  , c = 0,0 , 0\\n        for cur in customers:\\n            c+=1# for counting in which time we are just rotating the wheel\\n            if cur >= 4 or cur + wait >=4:\\n                ans += 4* boardingCost - runningCost\\n                wait += cur - 4\\n            else:\\n                ans += (cur + wait) * boardingCost - runningCost\\n                wait = 0\\n            \\n            # for finding the maximum\\n            if ans > mv:    mv = ans;mc = c\\n        # if still wait is there means we will calculate the ans\\n        while wait > 0:\\n            c += 1\\n            if wait >= 4:\\n                ans += 4* boardingCost - runningCost\\n                \\n            else:\\n                ans += wait * boardingCost - runningCost\\n            wait -=4\\n            # for finding the maximum\\n            if ans > mv:    mv = ans;mc = c\\n        return mc if mc > 0 else -1\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 868457,
                "title": "java-beaating-100-solution-with-explaination",
                "content": "class Solution {\\n    public int minOperationsMaxProfit(int[] customers, int boardingCost, int runningCost) {\\n\\t\\n       int wait=0,customer=0,mx=Integer.MIN_VALUE,currentProfit=0,round=-1;\\n        for(int i=1;i<=customers.length||wait>0;i++){\\n            wait=wait+ (i-1 < customers.length ? customers[i-1]:0);//if greater than length than no increment in wait as queue of customer ends\\n   \\n            if(wait>=4){  //the logic of customer waiting\\n             customer+=4;\\n                wait-=4;\\n            }else{                 //add current wait to customer \\n                customer+=wait;\\n                wait=0;\\n            }\\n            currentProfit = customer*boardingCost - i*runningCost; //cuurrent profit\\n            if(mx<currentProfit){ \\n                mx=currentProfit;\\n                round=i;      //round is the iteration times i.e the index or number of iteration with highest profit\\n            }\\n        }\\n        return currentProfit > 0 ? round:-1; //for last testcase negative profit than return -1\\n  \\n  }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int minOperationsMaxProfit(int[] customers, int boardingCost, int runningCost) {\\n\\t\\n       int wait=0,customer=0,mx=Integer.MIN_VALUE,currentProfit=0,round=-1;\\n        for(int i=1;i<=customers.length||wait>0;i++){\\n            wait=wait+ (i-1 < customers.length ? customers[i-1]:0);//if greater than length than no increment in wait as queue of customer ends\\n   \\n            if(wait>=4){  //the logic of customer waiting\\n             customer+=4;\\n                wait-=4;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 868370,
                "title": "c-o-n-simple-code",
                "content": "```\\n int minOperationsMaxProfit(vector<int>& customers, int boardingCost, int runningCost) {\\n        vector<int> lookup;\\n        int wait_people = 0;\\n        int next_batch = 0;\\n        int max_people_to_serve = 4;\\n        for (int i = 0 ; i < customers.size(); i++){\\n            wait_people  += customers[i];              \\n           if (wait_people >= max_people_to_serve) {\\n                lookup.push_back(max_people_to_serve);\\n                wait_people = wait_people - max_people_to_serve;\\n                cout <<  wait_people << endl;            \\n            }         \\n        }\\n         while (wait_people > 0) {\\n          if (wait_people >= max_people_to_serve) lookup.push_back(max_people_to_serve);\\n          else lookup.push_back(wait_people);  \\n          wait_people -= max_people_to_serve;\\n        }\\n        if (wait_people > 0) lookup.push_back(wait_people);\\n        int profit =0, max_profit = 0;\\n        if  (wait_people > 0)\\n            lookup.push_back(wait_people);\\n        int rounds = 0;\\n        for ( auto v : lookup)  {\\n            cout << v << \" \"; \\n             profit += v * boardingCost - 1 * runningCost;\\n            cout << profit  << \" \" << max_profit;\\n            if (profit >  max_profit) {\\n              max_profit = profit;\\n              ++rounds;\\n            }\\n        }\\n        cout << \"profit \" << max_profit << \" \" << rounds  ;\\n        return max_profit > 0 ? rounds : -1;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n int minOperationsMaxProfit(vector<int>& customers, int boardingCost, int runningCost) {\\n        vector<int> lookup;\\n        int wait_people = 0;\\n        int next_batch = 0;\\n        int max_people_to_serve = 4;\\n        for (int i = 0 ; i < customers.size(); i++){\\n            wait_people  += customers[i];              \\n           if (wait_people >= max_people_to_serve) {\\n                lookup.push_back(max_people_to_serve);\\n                wait_people = wait_people - max_people_to_serve;\\n                cout <<  wait_people << endl;            \\n            }         \\n        }\\n         while (wait_people > 0) {\\n          if (wait_people >= max_people_to_serve) lookup.push_back(max_people_to_serve);\\n          else lookup.push_back(wait_people);  \\n          wait_people -= max_people_to_serve;\\n        }\\n        if (wait_people > 0) lookup.push_back(wait_people);\\n        int profit =0, max_profit = 0;\\n        if  (wait_people > 0)\\n            lookup.push_back(wait_people);\\n        int rounds = 0;\\n        for ( auto v : lookup)  {\\n            cout << v << \" \"; \\n             profit += v * boardingCost - 1 * runningCost;\\n            cout << profit  << \" \" << max_profit;\\n            if (profit >  max_profit) {\\n              max_profit = profit;\\n              ++rounds;\\n            }\\n        }\\n        cout << \"profit \" << max_profit << \" \" << rounds  ;\\n        return max_profit > 0 ? rounds : -1;\\n    }\\n```",
                "codeTag": "C++"
            },
            {
                "id": 868253,
                "title": "c-simulation",
                "content": "```\\nclass Solution {\\npublic:\\n    int minOperationsMaxProfit(vector<int>& customers, int boardingCost, int runningCost) {\\n        int rot = -2, mxm = 0, waiting = 0, n = customers.size(), profit = 0, i = 0;\\n        while (waiting > 0 or i < n) {\\n            if (i < n) \\n                waiting += customers[i];\\n            profit = profit + min(4, waiting) * boardingCost - runningCost;\\n            if (profit > mxm) {\\n                mxm = profit;\\n                rot = i;\\n            }\\n            waiting -= min(4, waiting);\\n            ++i;\\n        }\\n        return rot+1;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperationsMaxProfit(vector<int>& customers, int boardingCost, int runningCost) {\\n        int rot = -2, mxm = 0, waiting = 0, n = customers.size(), profit = 0, i = 0;\\n        while (waiting > 0 or i < n) {\\n            if (i < n) \\n                waiting += customers[i];\\n            profit = profit + min(4, waiting) * boardingCost - runningCost;\\n            if (profit > mxm) {\\n                mxm = profit;\\n                rot = i;\\n            }\\n            waiting -= min(4, waiting);\\n            ++i;\\n        }\\n        return rot+1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 868052,
                "title": "video-solution",
                "content": "https://youtu.be/ynxGGIoVY3g",
                "solutionTags": [],
                "code": "",
                "codeTag": "Unknown"
            },
            {
                "id": 868007,
                "title": "python-time-o-n-and-space-o-1",
                "content": "```\\nclass Solution:\\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\\n        \\n        rotations = 0\\n        profit, max_profit = 0, 0\\n        res = -1\\n        \\n        def xreport(boarded:int):\\n            nonlocal profit, rotations, max_profit, res\\n            profit +=boarded*boardingCost - runningCost\\n            rotations +=1\\n            if profit>max_profit:\\n                max_profit = profit\\n                res = rotations\\n            #print(f\\'p: {profit}, mprofit: {max_profit}, rotations:{rotations}\\')\\n            return\\n        \\n        for i in range(len(customers)-1):\\n            if customers[i] >4:\\n                customers[i+1]+=customers[i]-4\\n                customers[i] =4\\n            \\n            xreport(customers[i])\\n        \\n            \\n        waiting = customers[-1]\\n        while waiting>0:\\n            if waiting>4:\\n                waiting-=4\\n                xreport(4)\\n            else:\\n                xreport(waiting)\\n                waiting = 0\\n            \\n        return res\\n\\t\\t",
                "solutionTags": [
                    "Python3"
                ],
                "code": "class Solution:\\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\\n        \\n        rotations = 0\\n        profit, max_profit = 0, 0\\n        res = -1\\n        \\n        def xreport(boarded:int):\\n            nonlocal profit, rotations, max_profit, res\\n            profit +=boarded*boardingCost - runningCost\\n            rotations +=1\\n            if profit>max_profit:\\n                max_profit = profit\\n                res = rotations\\n            #print(f\\'p: {profit}",
                "codeTag": "Java"
            },
            {
                "id": 867879,
                "title": "1599-maximum-profit-centennial-wheel-bug-in-example-3",
                "content": "Example 3 says:\\n\\nInput: customers = [3,4,0,5,1], boardingCost = 1, runningCost = 92\\nOutput: -1\\nExplanation:\\n1. 3 customers arrive, 3 board and 0 wait, the wheel rotates. Current profit is 3 * $1 - 1 * $92 = -$89.\\n2. 4 customers arrive, 4 board and 0 wait, the wheel rotates. Current profit is 7 * $1 - 2 * $92 = -$177.\\n3. 0 customers arrive, 0 board and 0 wait, the wheel rotates. Current profit is 7 * $1 - 3 * $92 = -$269.\\n*4. 5 customers arrive, 4 board and 1 waits, the wheel rotates. Current profit is 12  $1 - 4  $92 = -$356.*\\n5. 1 customer arrives, 2 board and 0 wait, the wheel rotates. Current profit is 13 * $1 - 5 * $92 = -$447.\\nThe profit was never positive, so return -1.\\n\\n----\\nAt time 4 it says \"4 board and 1 waits\" which is correct.  But it shows riders boarded jump from 7 at time 3, to 12 at time 4.  You can\\'t board 5 riders, max is 4.  Line 4 above should say:\\n\\n\"4. 5 customers arrive, 4 board and 1 waits, the wheel rotates. Current profit is 11  $1 - 4  $92 = -$357.\"\\n\\nI mention this because the bug/error in the example description cost me about 10 minutes to figure out it was wrong, during Weekly Contest 208 on 9/26/2020.  So I lost 10 minutes time/placement... (whining)",
                "solutionTags": [],
                "code": "Example 3 says:\\n\\nInput: customers = [3,4,0,5,1], boardingCost = 1, runningCost = 92\\nOutput: -1\\nExplanation:\\n1. 3 customers arrive, 3 board and 0 wait, the wheel rotates. Current profit is 3 * $1 - 1 * $92 = -$89.\\n2. 4 customers arrive, 4 board and 0 wait, the wheel rotates. Current profit is 7 * $1 - 2 * $92 = -$177.\\n3. 0 customers arrive, 0 board and 0 wait, the wheel rotates. Current profit is 7 * $1 - 3 * $92 = -$269.\\n*4. 5 customers arrive, 4 board and 1 waits, the wheel rotates. Current profit is 12  $1 - 4  $92 = -$356.*\\n5. 1 customer arrives, 2 board and 0 wait, the wheel rotates. Current profit is 13 * $1 - 5 * $92 = -$447.\\nThe profit was never positive, so return -1.\\n\\n----\\nAt time 4 it says \"4 board and 1 waits\" which is correct.  But it shows riders boarded jump from 7 at time 3, to 12 at time 4.  You can\\'t board 5 riders, max is 4.  Line 4 above should say:\\n\\n\"4. 5 customers arrive, 4 board and 1 waits, the wheel rotates. Current profit is 11  $1 - 4  $92 = -$357.\"\\n\\nI mention this because the bug/error in the example description cost me about 10 minutes to figure out it was wrong, during Weekly Contest 208 on 9/26/2020.  So I lost 10 minutes time/placement... (whining)",
                "codeTag": "Unknown"
            },
            {
                "id": 867855,
                "title": "c-o-n-easy-to-understand",
                "content": "```\\n/*\\n    Calculate running cost accumulated. Return max.\\n*/\\n\\npublic class Solution {\\n    public int MinOperationsMaxProfit(int[] customers, int boardingCost, int runningCost) {\\n        int accumulated = customers[0];\\n        int profit = 0, maxProfit = Int32.MinValue, index = -1, i = 0;  \\n        while ( accumulated > 0 || i < customers.Length ) {      \\n            int toBoard = accumulated >= 4? 4: accumulated;\\n            accumulated -= toBoard;\\n            \\n            profit+= toBoard * boardingCost - runningCost;\\n            if (profit > maxProfit && profit > 0){\\n                maxProfit = profit;\\n                index = i + 1;\\n            }\\n            \\n            i++;\\n            \\n            accumulated += i < customers.Length? customers[i] : 0; \\n        }\\n        \\n        return index;      \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n/*\\n    Calculate running cost accumulated. Return max.\\n*/\\n\\npublic class Solution {\\n    public int MinOperationsMaxProfit(int[] customers, int boardingCost, int runningCost) {\\n        int accumulated = customers[0];\\n        int profit = 0, maxProfit = Int32.MinValue, index = -1, i = 0;  \\n        while ( accumulated > 0 || i < customers.Length ) {      \\n            int toBoard = accumulated >= 4? 4: accumulated;\\n            accumulated -= toBoard;\\n            \\n            profit+= toBoard * boardingCost - runningCost;\\n            if (profit > maxProfit && profit > 0){\\n                maxProfit = profit;\\n                index = i + 1;\\n            }\\n            \\n            i++;\\n            \\n            accumulated += i < customers.Length? customers[i] : 0; \\n        }\\n        \\n        return index;      \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 867836,
                "title": "python3-simulation",
                "content": "\\n```\\nclass Solution:\\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\\n        if not customers: return 0\\n        rem = 0 # remaining customers waiting for onboard\\n        customers = customers[::-1] # reverse it for popping out easily\\n        t = 1\\n        onboard = 0\\n        ans = -1\\n        maxa = 0\\n        while customers or rem:\\n            if customers:\\n                rem += customers.pop()\\n            onboard += min(rem, 4)\\n            cur = onboard * boardingCost - runningCost * t\\n            if cur > maxa:\\n                maxa = cur\\n                ans = t\\n                \\n            t += 1\\n            rem -= min(rem, 4)\\n        return ans\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\\n        if not customers: return 0\\n        rem = 0 # remaining customers waiting for onboard\\n        customers = customers[::-1] # reverse it for popping out easily\\n        t = 1\\n        onboard = 0\\n        ans = -1\\n        maxa = 0\\n        while customers or rem:\\n            if customers:\\n                rem += customers.pop()\\n            onboard += min(rem, 4)\\n            cur = onboard * boardingCost - runningCost * t\\n            if cur > maxa:\\n                maxa = cur\\n                ans = t\\n                \\n            t += 1\\n            rem -= min(rem, 4)\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 867730,
                "title": "cpp-soln",
                "content": "class Solution {\\npublic:\\n    int minOperationsMaxProfit(vector<int>& a, int board, int run) {\\n        int ind=0;\\n        int wait=0,profit=0,max=INT_MIN,best=0;\\n        for(int i=0;i<a.size();i++){\\n           int on = min(wait+a[i],4);\\n            \\n            wait += a[i]-on;\\n            \\n            profit += on*board-run;\\n            if(profit>max){\\n                max = profit;\\n                best = ind+1;\\n            }\\n            ind++;\\n        }\\n        while(wait>0){\\n            int on = min(wait,4);\\n            wait = wait-on;\\n            \\n            profit += on*board-run;\\n            if(profit>max){\\n                max = profit;\\n                best = ind+1;\\n            }\\n            ind++;\\n        }\\n        if(profit<0)\\n            return -1;\\n        return best;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int minOperationsMaxProfit(vector<int>& a, int board, int run) {\\n        int ind=0;\\n        int wait=0,profit=0,max=INT_MIN,best=0;\\n        for(int i=0;i<a.size();i++){\\n           int on = min(wait+a[i],4);\\n            \\n            wait += a[i]-on;\\n            \\n            profit += on*board-run;\\n            if(profit>max){\\n                max = profit;\\n                best = ind+1;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 867667,
                "title": "simulation-in-python-o-n",
                "content": "The idea of the solution is to simulate what is described in the \"lengthy\" desription of the problem. we try to board as much as cusotmers in each turn if it is more than 4 then we add them to waiting customers and in each tuen keep track of profit. The edge case was when the first element in the customers is zero.\\n\\n```class Solution(object):\\n    def minOperationsMaxProfit(self, customers, boardingCost, runningCost):\\n        \"\"\"\\n        :type customers: List[int]\\n        :type boardingCost: int\\n        :type runningCost: int\\n        :rtype: int\\n        \"\"\"\\n        if runningCost >= 4 * boardingCost:\\n            return -1\\n        profit = 0\\n        max_profit = float(\\'-inf\\')\\n        wc = customers[0]\\n        i = 1\\n        rot = 1\\n        max_rot = 0\\n        print len(customers)\\n        while  wc > 0 or i < len(customers):\\n            \\n                if wc >= 4:\\n                    #print wc\\n                    wc -=  4 \\n                    profit += 4 * boardingCost\\n               elif wc < 4:\\n                    bc = wc\\n                    wc = 0\\n                    profit +=  bc * boardingCost\\n                profit -= runningCost\\n                prev = max_profit\\n                max_profit = max(profit, max_profit)\\n                if max_profit != prev:\\n                    max_rot = rot\\n                if i < len(customers):\\n                    wc += customers[i]\\n                    i+=1\\n                    \\n                rot +=1\\n                \\n        if max_profit > 0:\\n            return max_rot\\n        else:\\n            return -1\\n```",
                "solutionTags": [],
                "code": "```class Solution(object):\\n    def minOperationsMaxProfit(self, customers, boardingCost, runningCost):\\n        \"\"\"\\n        :type customers: List[int]\\n        :type boardingCost: int\\n        :type runningCost: int\\n        :rtype: int\\n        \"\"\"\\n        if runningCost >= 4 * boardingCost:\\n            return -1\\n        profit = 0\\n        max_profit = float(\\'-inf\\')\\n        wc = customers[0]\\n        i = 1\\n        rot = 1\\n        max_rot = 0\\n        print len(customers)\\n        while  wc > 0 or i < len(customers):\\n            \\n                if wc >= 4:\\n                    #print wc\\n                    wc -=  4 \\n                    profit += 4 * boardingCost\\n               elif wc < 4:\\n                    bc = wc\\n                    wc = 0\\n                    profit +=  bc * boardingCost\\n                profit -= runningCost\\n                prev = max_profit\\n                max_profit = max(profit, max_profit)\\n                if max_profit != prev:\\n                    max_rot = rot\\n                if i < len(customers):\\n                    wc += customers[i]\\n                    i+=1\\n                    \\n                rot +=1\\n                \\n        if max_profit > 0:\\n            return max_rot\\n        else:\\n            return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 867640,
                "title": "java-another-stupid-problem",
                "content": "```\\nclass Solution {\\n    public int minOperationsMaxProfit(int[] customers, int boardingCost, int runningCost) {\\n        int profit = 0;\\n        int wait = 0;\\n        int rot = 0;\\n        int max = Integer.MIN_VALUE;\\n        int res = -1;\\n        while (rot < customers.length) {\\n            wait += customers[rot];\\n            profit += Math.min(4, wait) * boardingCost - runningCost;\\n            rot++;\\n            if (profit > max) {\\n                max = profit;\\n                res = rot;\\n            }\\n            wait -= Math.min(4, wait);\\n        }\\n        while (wait > 0) {\\n            profit += Math.min(4, wait) * boardingCost - runningCost;\\n            wait -= Math.min(4, wait);\\n            rot++;\\n            if (profit > max) {\\n                max = profit;\\n                res = rot;\\n            }\\n        }\\n        if (max < 0) {\\n            return -1;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minOperationsMaxProfit(int[] customers, int boardingCost, int runningCost) {\\n        int profit = 0;\\n        int wait = 0;\\n        int rot = 0;\\n        int max = Integer.MIN_VALUE;\\n        int res = -1;\\n        while (rot < customers.length) {\\n            wait += customers[rot];\\n            profit += Math.min(4, wait) * boardingCost - runningCost;\\n            rot++;\\n            if (profit > max) {\\n                max = profit;\\n                res = rot;\\n            }\\n            wait -= Math.min(4, wait);\\n        }\\n        while (wait > 0) {\\n            profit += Math.min(4, wait) * boardingCost - runningCost;\\n            wait -= Math.min(4, wait);\\n            rot++;\\n            if (profit > max) {\\n                max = profit;\\n                res = rot;\\n            }\\n        }\\n        if (max < 0) {\\n            return -1;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 867635,
                "title": "java-o-n-solution",
                "content": "```\\nclass Solution {\\n    public int minOperationsMaxProfit(int[] customers, int boardingCost, int runningCost) {\\n        int max = Integer.MIN_VALUE;\\n        int count=0, maxcount=0;\\n        int remCustomers =0, currCost = 0;\\n        for(int i=0; i< customers.length; i++){\\n            remCustomers += customers[i];\\n            if(remCustomers >4){\\n                remCustomers -=4;\\n                currCost += 4* boardingCost - runningCost;\\n            }else{\\n                currCost += remCustomers*boardingCost - runningCost;\\n                remCustomers = 0;\\n            }\\n            count++;\\n            if(currCost > max){\\n                max = currCost;\\n                maxcount = count;\\n            }\\n        }\\n        while(remCustomers > 0){\\n            if(remCustomers >4){\\n                remCustomers -=4;\\n                currCost += 4* boardingCost - runningCost;\\n            }else{\\n                currCost += remCustomers*boardingCost - runningCost;\\n                remCustomers = 0;\\n            }\\n            count++;\\n            if(currCost > max){\\n                max = currCost;\\n                maxcount = count;\\n            }\\n        }\\n        return max>0?maxcount:-1;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minOperationsMaxProfit(int[] customers, int boardingCost, int runningCost) {\\n        int max = Integer.MIN_VALUE;\\n        int count=0, maxcount=0;\\n        int remCustomers =0, currCost = 0;\\n        for(int i=0; i< customers.length; i++){\\n            remCustomers += customers[i];\\n            if(remCustomers >4){\\n                remCustomers -=4;\\n                currCost += 4* boardingCost - runningCost;\\n            }else{\\n                currCost += remCustomers*boardingCost - runningCost;\\n                remCustomers = 0;\\n            }\\n            count++;\\n            if(currCost > max){\\n                max = currCost;\\n                maxcount = count;\\n            }\\n        }\\n        while(remCustomers > 0){\\n            if(remCustomers >4){\\n                remCustomers -=4;\\n                currCost += 4* boardingCost - runningCost;\\n            }else{\\n                currCost += remCustomers*boardingCost - runningCost;\\n                remCustomers = 0;\\n            }\\n            count++;\\n            if(currCost > max){\\n                max = currCost;\\n                maxcount = count;\\n            }\\n        }\\n        return max>0?maxcount:-1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 867560,
                "title": "swift-o-n",
                "content": "```\\nclass Solution {\\n    func minOperationsMaxProfit(_ customers: [Int], _ boardingCost: Int, _ runningCost: Int) -> Int {\\n        var maxProfit = 0\\n        var maxRotation = 0\\n        var waitingCustomers = 0\\n        var profit = 0\\n        var rotation = 0\\n        \\n        for _customers in customers{\\n            waitingCustomers += _customers\\n            helper(&waitingCustomers, &maxProfit, &maxRotation, &profit, &rotation, boardingCost, runningCost)\\n        }\\n        \\n        \\n        while waitingCustomers > 0{\\n            helper(&waitingCustomers, &maxProfit, &maxRotation, &profit, &rotation, boardingCost, runningCost)\\n        }\\n        \\n        return maxRotation > 0 ? maxRotation : -1\\n    }\\n    \\n    private func helper(_ waitingCustomers: inout Int, _ maxProfit: inout Int, _ maxRotation: inout Int, _ profit: inout Int, _ rotation: inout Int, _ boardingCost: Int, _ runningCost: Int){\\n        let onboardingCustomers = min(waitingCustomers, 4)\\n        waitingCustomers -= onboardingCustomers            \\n        profit += onboardingCustomers * boardingCost - runningCost\\n        rotation += 1\\n        if maxProfit < profit{\\n            maxProfit = profit\\n            maxRotation = rotation\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    func minOperationsMaxProfit(_ customers: [Int], _ boardingCost: Int, _ runningCost: Int) -> Int {\\n        var maxProfit = 0\\n        var maxRotation = 0\\n        var waitingCustomers = 0\\n        var profit = 0\\n        var rotation = 0\\n        \\n        for _customers in customers{\\n            waitingCustomers += _customers\\n            helper(&waitingCustomers, &maxProfit, &maxRotation, &profit, &rotation, boardingCost, runningCost)\\n        }\\n        \\n        \\n        while waitingCustomers > 0{\\n            helper(&waitingCustomers, &maxProfit, &maxRotation, &profit, &rotation, boardingCost, runningCost)\\n        }\\n        \\n        return maxRotation > 0 ? maxRotation : -1\\n    }\\n    \\n    private func helper(_ waitingCustomers: inout Int, _ maxProfit: inout Int, _ maxRotation: inout Int, _ profit: inout Int, _ rotation: inout Int, _ boardingCost: Int, _ runningCost: Int){\\n        let onboardingCustomers = min(waitingCustomers, 4)\\n        waitingCustomers -= onboardingCustomers            \\n        profit += onboardingCustomers * boardingCost - runningCost\\n        rotation += 1\\n        if maxProfit < profit{\\n            maxProfit = profit\\n            maxRotation = rotation\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 867552,
                "title": "simple-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int minOperationsMaxProfit(vector<int>& customers, int boardingCost, int runningCost) {\\n        int cost=0,time=-1,curr=0;\\n        int count=0;\\n        int n=customers.size(),i=0;\\n        int cust=0;\\n        do{\\n            //curr++;\\n            if(i<n)\\n                count+=customers[i];\\n            i++;\\n            if(count>=4){\\n                cust+=4;\\n                count-=4;\\n            }\\n            else if(count>0 && count<4){\\n                cust+=count;\\n                count=0;\\n            }\\n            cost=boardingCost*cust-runningCost*i;\\n            \\n            if(curr<cost){\\n                curr=cost;\\n                time=i;\\n            }\\n            //cout<<cost<<\" \";\\n            \\n        } while(count>0 || i<n);\\n        return time;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperationsMaxProfit(vector<int>& customers, int boardingCost, int runningCost) {\\n        int cost=0,time=-1,curr=0;\\n        int count=0;\\n        int n=customers.size(),i=0;\\n        int cust=0;\\n        do{\\n            //curr++;\\n            if(i<n)\\n                count+=customers[i];\\n            i++;\\n            if(count>=4){\\n                cust+=4;\\n                count-=4;\\n            }\\n            else if(count>0 && count<4){\\n                cust+=count;\\n                count=0;\\n            }\\n            cost=boardingCost*cust-runningCost*i;\\n            \\n            if(curr<cost){\\n                curr=cost;\\n                time=i;\\n            }\\n            //cout<<cost<<\" \";\\n            \\n        } while(count>0 || i<n);\\n        return time;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 867513,
                "title": "java-simple-o-n-solution-sequential-processing-input",
                "content": "```\\n\\nclass Solution {\\n    public int minOperationsMaxProfit(int[] customers, int boardingCost, int runningCost) {\\n        int ans = 0; \\n        int moves = 1;\\n        int balance = 0;\\n        int max = 0;\\n        int p = 0;\\n        for(int i=0; i< customers.length; i++){\\n            balance += customers[i];\\n            int px = Math.min(balance, 4);\\n            balance = balance - px;\\n            p+=px;\\n            int curr =  (p*boardingCost) - runningCost*moves;\\n            if(Math.abs(max) < Math.abs(curr)){\\n                max  = curr;\\n                ans = moves;\\n            }\\n            moves++;\\n        }\\n        while(balance > 0){\\n            int py = Math.min(balance, 4);\\n            balance = balance - py;\\n            p += py;\\n            int c = (p*boardingCost) - runningCost*moves;\\n            if(Math.abs(max) < Math.abs(c)){\\n                max  = c;\\n                ans = moves;\\n            }\\n            moves++;\\n        }\\n        return max >0? ans:-1;\\n    }\\n}\\n\\n```",
                "solutionTags": [],
                "code": "```\\n\\nclass Solution {\\n    public int minOperationsMaxProfit(int[] customers, int boardingCost, int runningCost) {\\n        int ans = 0; \\n        int moves = 1;\\n        int balance = 0;\\n        int max = 0;\\n        int p = 0;\\n        for(int i=0; i< customers.length; i++){\\n            balance += customers[i];\\n            int px = Math.min(balance, 4);\\n            balance = balance - px;\\n            p+=px;\\n            int curr =  (p*boardingCost) - runningCost*moves;\\n            if(Math.abs(max) < Math.abs(curr)){\\n                max  = curr;\\n                ans = moves;\\n            }\\n            moves++;\\n        }\\n        while(balance > 0){\\n            int py = Math.min(balance, 4);\\n            balance = balance - py;\\n            p += py;\\n            int c = (p*boardingCost) - runningCost*moves;\\n            if(Math.abs(max) < Math.abs(c)){\\n                max  = c;\\n                ans = moves;\\n            }\\n            moves++;\\n        }\\n        return max >0? ans:-1;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 867470,
                "title": "java-solution",
                "content": "```\\nclass Solution {\\n    public int minOperationsMaxProfit(int[] customers, int boardingCost, int runningCost) {\\n        int waiting = 0;\\n        int count = 0;\\n        int profit = 0;\\n        int max = -1;\\n        int maxCount = 0;\\n        for(int i : customers){\\n           waiting += i;\\n           int val = waiting>4? 4:waiting;\\n           waiting = val>4? waiting-4:waiting-val;\\n           count++;\\n           profit = val>0?profit+(val*boardingCost - runningCost): profit - runningCost;\\n            if(profit>max){\\n                max = profit;\\n                maxCount = count;\\n            }\\n        }\\n        \\n        while(waiting>0){\\n            int val = waiting>4? 4:waiting;\\n           waiting = val>4? waiting-4:waiting-val;\\n           count++;\\n           profit = val>0?profit+(val*boardingCost - runningCost): profit - runningCost;\\n             if(profit>max){\\n                max = profit;\\n                maxCount = count;\\n            }\\n        }\\n        \\n        if(max>0){\\n            return maxCount;\\n        }else{\\n            return -1;\\n        }\\n    }\\n}``\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minOperationsMaxProfit(int[] customers, int boardingCost, int runningCost) {\\n        int waiting = 0;\\n        int count = 0;\\n        int profit = 0;\\n        int max = -1;\\n        int maxCount = 0;\\n        for(int i : customers){\\n           waiting += i;\\n           int val = waiting>4? 4:waiting;\\n           waiting = val>4? waiting-4:waiting-val;\\n           count++;\\n           profit = val>0?profit+(val*boardingCost - runningCost): profit - runningCost;\\n            if(profit>max){\\n                max = profit;\\n                maxCount = count;\\n            }\\n        }\\n        \\n        while(waiting>0){\\n            int val = waiting>4? 4:waiting;\\n           waiting = val>4? waiting-4:waiting-val;\\n           count++;\\n           profit = val>0?profit+(val*boardingCost - runningCost): profit - runningCost;\\n             if(profit>max){\\n                max = profit;\\n                maxCount = count;\\n            }\\n        }\\n        \\n        if(max>0){\\n            return maxCount;\\n        }else{\\n            return -1;\\n        }\\n    }\\n}``\\n```",
                "codeTag": "Java"
            },
            {
                "id": 867440,
                "title": "o-n-greedy-implementation",
                "content": "```\\nclass Solution {\\npublic:\\n    int minOperationsMaxProfit(vector<int>& customers, int boardingCost, int runningCost) {\\n        int profit = 0, k = 0, n = customers.size();\\n        \\n        if(n < 1) {\\n            return -1;\\n        }\\n        \\n        for(int i = 0; i < n; i++) {\\n            if(i) {\\n                customers[i] += max(0, customers[i-1] - 4);\\n            }\\n            profit += min(4, customers[i]) * boardingCost - runningCost;\\n        }\\n        \\n        int c = max(0, customers.back() - 4);\\n        profit += (4 * boardingCost - runningCost) * (c / 4);\\n        \\n        if(c % 4 * boardingCost - runningCost > 0) {\\n            n++;\\n        }\\n        \\n        if(profit <= 0) {\\n            return -1;\\n        }\\n        \\n        return n + (c / 4);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperationsMaxProfit(vector<int>& customers, int boardingCost, int runningCost) {\\n        int profit = 0, k = 0, n = customers.size();\\n        \\n        if(n < 1) {\\n            return -1;\\n        }\\n        \\n        for(int i = 0; i < n; i++) {\\n            if(i) {\\n                customers[i] += max(0, customers[i-1] - 4);\\n            }\\n            profit += min(4, customers[i]) * boardingCost - runningCost;\\n        }\\n        \\n        int c = max(0, customers.back() - 4);\\n        profit += (4 * boardingCost - runningCost) * (c / 4);\\n        \\n        if(c % 4 * boardingCost - runningCost > 0) {\\n            n++;\\n        }\\n        \\n        if(profit <= 0) {\\n            return -1;\\n        }\\n        \\n        return n + (c / 4);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 867429,
                "title": "my-python-solution-using-simulation-to-solve-the-problem",
                "content": "Just using simulation to solve the problem, the code is a little bit tricky, since I find that we only the max_op_nb. There is no need to store all the money earned after each operation.\\n\\n````python\\nclass Solution:\\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\\n        # simulation of operations\\n        res = []\\n        remaining = 0\\n        nb_roation = 0\\n        total_boardingCost = 0\\n\\n        while customers:\\n            nb_roation += 1\\n            if (customers[0] + remaining) <= 4:\\n                total_boardingCost += boardingCost * (customers[0] + remaining)\\n                remaining = 0\\n            else:\\n                total_boardingCost += boardingCost * 4\\n                remaining += customers[0] - 4\\n            res.append( total_boardingCost - runningCost * nb_roation)\\n            customers.pop(0)\\n        \\n        # clear waiting lines\\n        while remaining:\\n            nb_roation += 1\\n            if remaining >= 4:\\n                total_boardingCost += boardingCost * 4\\n                remaining -= 4\\n            else:\\n                total_boardingCost += boardingCost * remaining\\n                remaining = 0\\n            res.append( total_boardingCost - runningCost * nb_roation)\\n        \\n        if max(res) < 0:\\n            return -1\\n        else:\\n            return res.index(max(res)) + 1\\n        \\n```",
                "solutionTags": [
                    "Python3",
                    "Simulation"
                ],
                "code": "````python\\nclass Solution:\\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\\n        # simulation of operations\\n        res = []\\n        remaining = 0\\n        nb_roation = 0\\n        total_boardingCost = 0\\n\\n        while customers:\\n            nb_roation += 1\\n            if (customers[0] + remaining) <= 4:\\n                total_boardingCost += boardingCost * (customers[0] + remaining)\\n                remaining = 0\\n            else:\\n                total_boardingCost += boardingCost * 4\\n                remaining += customers[0] - 4\\n            res.append( total_boardingCost - runningCost * nb_roation)\\n            customers.pop(0)\\n        \\n        # clear waiting lines\\n        while remaining:\\n            nb_roation += 1\\n            if remaining >= 4:\\n                total_boardingCost += boardingCost * 4\\n                remaining -= 4\\n            else:\\n                total_boardingCost += boardingCost * remaining\\n                remaining = 0\\n            res.append( total_boardingCost - runningCost * nb_roation)\\n        \\n        if max(res) < 0:\\n            return -1\\n        else:\\n            return res.index(max(res)) + 1\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 867385,
                "title": "c-easy-solution-in-o-n-with-constant-space",
                "content": "class Solution {\\npublic:\\n    int minOperationsMaxProfit(vector<int>& customers, int boardingCost, int runningCost) {\\n        int c=0,r=0,rem=0,p_max=-1,ans=0;\\n        for(int i=0;i<customers.size() || (rem);i++)\\n        {\\n            r++;\\n            if(i<customers.size())\\n                rem+=customers[i];\\n            else\\n                rem+=0;\\n            if(rem<4)\\n            {\\n                c+=rem;\\n                rem=0;\\n            }\\n            else\\n            {\\n                c+=4;\\n                rem-=4;\\n            }\\n            int p=c*boardingCost-r*runningCost;\\n            if(p>p_max)\\n            {\\n                p_max=p;\\n                ans=r;\\n            }\\n        }\\n        if(p_max<0)\\n            return -1;\\n        else\\n            return ans;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int minOperationsMaxProfit(vector<int>& customers, int boardingCost, int runningCost) {\\n        int c=0,r=0,rem=0,p_max=-1,ans=0;\\n        for(int i=0;i<customers.size() || (rem);i++)\\n        {\\n            r++;\\n            if(i<customers.size())\\n                rem+=customers[i];\\n            else\\n                rem+=0;\\n            if(rem<4)\\n            {\\n                c+=rem;\\n                rem=0;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 867357,
                "title": "java-easy-to-understand",
                "content": "```\\npublic int minOperationsMaxProfit(int[] customers, int boardingCost, int runningCost) {\\n        \\n        int totalCustomerWaitingForBoarding = customers[0], totalCustomersBoarded = 0;\\n        int maxProfit = 0, profit = 0, res = 0;\\n        \\n        for(int shift = 1; shift < customers.length || totalCustomerWaitingForBoarding > 0 ; shift++ ){\\n            \\n            int customerBoarding = Math.min(4, totalCustomerWaitingForBoarding); \\n            totalCustomerWaitingForBoarding -= customerBoarding;\\n            totalCustomersBoarded += customerBoarding;\\n            \\n            profit = (totalCustomersBoarded * boardingCost) - (shift * runningCost); \\n            \\n            if (profit > maxProfit){  \\n                maxProfit = profit;   \\n                res = shift;   \\n            }\\n            \\n            if (shift < customers.length){ \\n                totalCustomerWaitingForBoarding += customers[shift];  \\n            }\\n        }\\n        return (maxProfit == 0) ? -1 : res;\\n    }",
                "solutionTags": [],
                "code": "```\\npublic int minOperationsMaxProfit(int[] customers, int boardingCost, int runningCost) {\\n        \\n        int totalCustomerWaitingForBoarding = customers[0], totalCustomersBoarded = 0;\\n        int maxProfit = 0, profit = 0, res = 0;\\n        \\n        for(int shift = 1; shift < customers.length || totalCustomerWaitingForBoarding > 0 ; shift++ ){\\n            \\n            int customerBoarding = Math.min(4, totalCustomerWaitingForBoarding); \\n            totalCustomerWaitingForBoarding -= customerBoarding;\\n            totalCustomersBoarded += customerBoarding;\\n            \\n            profit = (totalCustomersBoarded * boardingCost) - (shift * runningCost); \\n            \\n            if (profit > maxProfit){  \\n                maxProfit = profit;   \\n                res = shift;   \\n            }\\n            \\n            if (shift < customers.length){ \\n                totalCustomerWaitingForBoarding += customers[shift];  \\n            }\\n        }\\n        return (maxProfit == 0) ? -1 : res;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 867345,
                "title": "doubt-in-approaching",
                "content": "Just a question, if we should consider the rotating cost to let the customers go down as well",
                "solutionTags": [],
                "code": "",
                "codeTag": "Unknown"
            },
            {
                "id": 867324,
                "title": "java-solution-super-easy-to-understand",
                "content": "```\\nclass Solution {\\n    public int minOperationsMaxProfit(int[] customers, int boardingCost, int runningCost) {\\n        int remaning = 0;\\n        int maxProfit = 0;\\n        int maxRotation = 0;\\n        int rotation = 1;\\n        int current_people_in_wheel = 0;\\n        for(int i=0 ; i<customers.length ; i++){\\n           // int people_boarding_currently = 0;\\n           int profit = 0;\\n           int current_total = remaning + customers[i];\\n           if(current_total > 4){\\n              remaning = current_total - 4;\\n             current_people_in_wheel += 4;\\n            \\n           }\\n          else{\\n            remaning = 0;\\n            current_people_in_wheel += current_total;\\n          }\\n          profit = current_people_in_wheel*boardingCost - rotation*runningCost;\\n          if(profit > maxProfit){\\n            maxProfit = profit;\\n            maxRotation = rotation;\\n          }\\n          rotation++;\\n           \\n        }\\n        while(remaning != 0){\\n           int profit = 0;\\n          if(remaning > 4){\\n            current_people_in_wheel += 4;\\n            remaning -= 4;\\n          }\\n          else{\\n             current_people_in_wheel += remaning;\\n             remaning -= remaning;\\n          }\\n          profit = current_people_in_wheel*boardingCost - rotation*runningCost;\\n          if(profit > maxProfit){\\n            maxProfit = profit;\\n            maxRotation = rotation;\\n          }\\n          rotation++; \\n        }\\n      \\n        return maxProfit == 0?-1:maxRotation;\\n       \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minOperationsMaxProfit(int[] customers, int boardingCost, int runningCost) {\\n        int remaning = 0;\\n        int maxProfit = 0;\\n        int maxRotation = 0;\\n        int rotation = 1;\\n        int current_people_in_wheel = 0;\\n        for(int i=0 ; i<customers.length ; i++){\\n           // int people_boarding_currently = 0;\\n           int profit = 0;\\n           int current_total = remaning + customers[i];\\n           if(current_total > 4){\\n              remaning = current_total - 4;\\n             current_people_in_wheel += 4;\\n            \\n           }\\n          else{\\n            remaning = 0;\\n            current_people_in_wheel += current_total;\\n          }\\n          profit = current_people_in_wheel*boardingCost - rotation*runningCost;\\n          if(profit > maxProfit){\\n            maxProfit = profit;\\n            maxRotation = rotation;\\n          }\\n          rotation++;\\n           \\n        }\\n        while(remaning != 0){\\n           int profit = 0;\\n          if(remaning > 4){\\n            current_people_in_wheel += 4;\\n            remaning -= 4;\\n          }\\n          else{\\n             current_people_in_wheel += remaning;\\n             remaning -= remaning;\\n          }\\n          profit = current_people_in_wheel*boardingCost - rotation*runningCost;\\n          if(profit > maxProfit){\\n            maxProfit = profit;\\n            maxRotation = rotation;\\n          }\\n          rotation++; \\n        }\\n      \\n        return maxProfit == 0?-1:maxRotation;\\n       \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 867313,
                "title": "super-easy-c-solution-100-faster-runtime-and-memory",
                "content": "```class Solution {\\npublic:\\n    int minOperationsMaxProfit(vector<int>& nums, int boardingCost, int runningCost) {\\n        if(nums.size()==0) return 0;\\n        \\n        int curr = 0;\\n        int count = 0;\\n        int inside = 0;\\n        int cost = 0;\\n        int pos = 1;\\n        int maxCost = -1;\\n        int hook = 0;\\n        \\n        for(int i =0;i<nums.size();i++){\\n            pos = i +1;\\n            curr += nums[i];\\n            if(curr>4){\\n                curr-=4;\\n                inside += 4;\\n            }\\n            else{\\n                \\n                inside += curr;\\n                curr = 0;\\n            }\\n            cost = inside*boardingCost - pos*runningCost;\\n            if(cost>maxCost){\\n                maxCost = cost;\\n                hook  = pos;\\n            }\\n        }\\n        \\n        while(curr>0){\\n            pos++;\\n            if(curr>4){\\n                curr-=4;\\n                inside += 4;\\n            }\\n            else{\\n                \\n                inside += curr;\\n                curr = 0;\\n            }\\n            cost = inside*boardingCost - pos * runningCost;\\n            if(cost>maxCost){\\n                maxCost = cost;\\n                hook = pos;\\n            }\\n        }\\n        if(hook == 0){\\n            return -1;\\n        }\\n        \\n        return hook;\\n        \\n        \\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    int minOperationsMaxProfit(vector<int>& nums, int boardingCost, int runningCost) {\\n        if(nums.size()==0) return 0;\\n        \\n        int curr = 0;\\n        int count = 0;\\n        int inside = 0;\\n        int cost = 0;\\n        int pos = 1;\\n        int maxCost = -1;\\n        int hook = 0;\\n        \\n        for(int i =0;i<nums.size();i++){\\n            pos = i +1;\\n            curr += nums[i];\\n            if(curr>4){\\n                curr-=4;\\n                inside += 4;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 867306,
                "title": "java-solution-runtime-8-ms-memory-usage-49-3-mb",
                "content": "import java.io.*;\\n\\nclass Solution\\n{\\n    public int minOperationsMaxProfit(int[] customers, int boardingCost, int runningCost)\\n    {\\n\\n        int current_customers = 0;\\n        int waiting_customers = 0;\\n        int rotations = 0;\\n        int out = 0;\\n        int max_profit = -1;\\n\\n        for(int i = 0; i < customers.length; i++)\\n        {\\n            rotations += 1;\\n            if (i < customers.length)\\n                waiting_customers += customers[i];\\n            else\\n                i = 0;\\n            if (waiting_customers < 4)\\n            {\\n                current_customers += waiting_customers;\\n                waiting_customers = 0;\\n            }\\n            else\\n            {\\n                current_customers += 4;\\n                waiting_customers -= 4;\\n            }\\n            int profit = current_customers * boardingCost - rotations * runningCost;\\n            if (profit > max_profit)\\n            {\\n                max_profit = profit;\\n                out = rotations;\\n            }\\n        }\\n\\n        while(waiting_customers != 0)\\n        {\\n            rotations += 1;\\n            if (waiting_customers < 4)\\n            {\\n                current_customers += waiting_customers;\\n                waiting_customers = 0;\\n            }\\n            else\\n            {\\n                current_customers += 4;\\n                waiting_customers -= 4;\\n            }\\n            int profit = current_customers * boardingCost - rotations * runningCost;\\n            if (profit > max_profit)\\n            {\\n                max_profit = profit;\\n                out = rotations;\\n            }\\n        }\\n\\n        if (max_profit < 0)\\n            return -1;\\n        else\\n            return out;\\n\\n    }\\n}\\n",
                "solutionTags": [],
                "code": "class Solution\\n{\\n    public int minOperationsMaxProfit(int[] customers, int boardingCost, int runningCost)\\n    {\\n\\n        int current_customers = 0;\\n        int waiting_customers = 0;\\n        int rotations = 0;\\n        int out = 0;\\n        int max_profit = -1;\\n\\n        for(int i = 0; i < customers.length; i++)\\n        {\\n            rotations += 1;\\n            if (i < customers.length)\\n                waiting_customers += customers[i];\\n            else\\n                i = 0;\\n            if (waiting_customers < 4)\\n            {\\n                current_customers += waiting_customers;\\n                waiting_customers = 0;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 867276,
                "title": "c-simple-simulation-very-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    int minOperationsMaxProfit(vector<int>& customers, int boardingCost, int runningCost) {\\n        int n = customers.size(); if (n == 0) return -1;\\n        int waiting = 0, onboard  = 0, rotations = 0, maxcost = -1, i = 0, cost = 0, maxi;\\n        while (true) {\\n            if (i < n ) waiting += customers[i];\\n            int newonboarded = (waiting < 4)? waiting: 4;\\n            onboard += newonboarded;\\n            waiting -= newonboarded;\\n            i ++;\\n            cost = onboard * boardingCost - i * runningCost;\\n            if (cost > maxcost) {\\n                maxi = i;\\n                maxcost = cost;\\n            }\\n            if (waiting == 0 && i >= n) break;\\n        }\\n        return maxcost == -1 ? -1 : maxi;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperationsMaxProfit(vector<int>& customers, int boardingCost, int runningCost) {\\n        int n = customers.size(); if (n == 0) return -1;\\n        int waiting = 0, onboard  = 0, rotations = 0, maxcost = -1, i = 0, cost = 0, maxi;\\n        while (true) {\\n            if (i < n ) waiting += customers[i];\\n            int newonboarded = (waiting < 4)? waiting: 4;\\n            onboard += newonboarded;\\n            waiting -= newonboarded;\\n            i ++;\\n            cost = onboard * boardingCost - i * runningCost;\\n            if (cost > maxcost) {\\n                maxi = i;\\n                maxcost = cost;\\n            }\\n            if (waiting == 0 && i >= n) break;\\n        }\\n        return maxcost == -1 ? -1 : maxi;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 867235,
                "title": "java-simple-o-m-time-solution",
                "content": "```\\nclass Solution {\\n    public int minOperationsMaxProfit(int[] customers, int boardingCost, int runningCost) {\\n        int mx = 0, answer = -1;\\n        int cur = 0;\\n        int waiting = 0;\\n        int index = 0;\\n        \\n        while (waiting > 0 || index < customers.length) {\\n            if (index < customers.length) {\\n                waiting += customers[index];\\n            }\\n            \\n            int boarding = Math.min(waiting, 4);\\n            waiting -= boarding;\\n            cur += boarding * boardingCost;\\n            cur -= runningCost;\\n            index++;\\n            \\n            if (cur > mx) {\\n                mx = cur;\\n                answer = index;\\n            }\\n        }\\n        \\n        \\n        return answer;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minOperationsMaxProfit(int[] customers, int boardingCost, int runningCost) {\\n        int mx = 0, answer = -1;\\n        int cur = 0;\\n        int waiting = 0;\\n        int index = 0;\\n        \\n        while (waiting > 0 || index < customers.length) {\\n            if (index < customers.length) {\\n                waiting += customers[index];\\n            }\\n            \\n            int boarding = Math.min(waiting, 4);\\n            waiting -= boarding;\\n            cur += boarding * boardingCost;\\n            cur -= runningCost;\\n            index++;\\n            \\n            if (cur > mx) {\\n                mx = cur;\\n                answer = index;\\n            }\\n        }\\n        \\n        \\n        return answer;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 867158,
                "title": "python-beautiful-easy-and-most-readable-o-n-solution-well-commented",
                "content": "```\\nclass Solution:\\n\\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\\n        \\n        CAPACITY = 4\\n        NO_PROFIT = -1\\n        \\n        numCustomersWaiting = 0\\n        totalCustomers = 0\\n\\n        currentProfit = NO_PROFIT\\n        previousProfit = NO_PROFIT\\n        maxProfit = NO_PROFIT\\n        \\n        numRotations = 0\\n        minRotationsForMaxProfit = NO_PROFIT\\n        \\n        while customers or numCustomersWaiting:\\n            \\n            # GET THE NEXT GROUP OF CUSTOMERS\\n            currentNumCustomers = customers.pop(0) if customers else 0\\n            \\n            # ADD TO TOTAL NUMBER OF CUSTOMERS WAITING\\n            numCustomersWaiting += currentNumCustomers \\n            \\n            # BOARD THE NEXT GROUP, 4 IS THE CAPACITY\\n            numCustomersBoarding = min(numCustomersWaiting, CAPACITY)\\n            \\n            # REMOVE BOARDING GROUP FROM NUMBER OF CUSTOMERS WAITING\\n            numCustomersWaiting = numCustomersWaiting - numCustomersBoarding\\n                       \\n            # KEEP TOTAL COUNT OF CUSTOMERS TO CALCULATE PROFIT\\n            totalCustomers += numCustomersBoarding\\n            \\n            # ROTATE THE CENTENNIAL WHEEL\\n            numRotations += 1\\n            \\n            # CALCULATE CURRENT PROFIT\\n            currentProfit = (totalCustomers * boardingCost) - (numRotations * runningCost)\\n            \\n            # MAINTAIN HIGHEST PROFIT NUMBER FOR RETURN\\n            if 0 < currentProfit > maxProfit:\\n                maxProfit = currentProfit\\n                minRotationsForMaxProfit = numRotations\\n            \\n            # SET UP FOR NEXT ITERATION\\n            previousProfit = currentProfit\\n            \\n        return minRotationsForMaxProfit\\n\\t\\t\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n\\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\\n        \\n        CAPACITY = 4\\n        NO_PROFIT = -1\\n        \\n        numCustomersWaiting = 0\\n        totalCustomers = 0\\n\\n        currentProfit = NO_PROFIT\\n        previousProfit = NO_PROFIT\\n        maxProfit = NO_PROFIT\\n        \\n        numRotations = 0\\n        minRotationsForMaxProfit = NO_PROFIT\\n        \\n        while customers or numCustomersWaiting:\\n            \\n            # GET THE NEXT GROUP OF CUSTOMERS\\n            currentNumCustomers = customers.pop(0) if customers else 0\\n            \\n            # ADD TO TOTAL NUMBER OF CUSTOMERS WAITING\\n            numCustomersWaiting += currentNumCustomers \\n            \\n            # BOARD THE NEXT GROUP, 4 IS THE CAPACITY\\n            numCustomersBoarding = min(numCustomersWaiting, CAPACITY)\\n            \\n            # REMOVE BOARDING GROUP FROM NUMBER OF CUSTOMERS WAITING\\n            numCustomersWaiting = numCustomersWaiting - numCustomersBoarding\\n                       \\n            # KEEP TOTAL COUNT OF CUSTOMERS TO CALCULATE PROFIT\\n            totalCustomers += numCustomersBoarding\\n            \\n            # ROTATE THE CENTENNIAL WHEEL\\n            numRotations += 1\\n            \\n            # CALCULATE CURRENT PROFIT\\n            currentProfit = (totalCustomers * boardingCost) - (numRotations * runningCost)\\n            \\n            # MAINTAIN HIGHEST PROFIT NUMBER FOR RETURN\\n            if 0 < currentProfit > maxProfit:\\n                maxProfit = currentProfit\\n                minRotationsForMaxProfit = numRotations\\n            \\n            # SET UP FOR NEXT ITERATION\\n            previousProfit = currentProfit\\n            \\n        return minRotationsForMaxProfit\\n\\t\\t\\n```",
                "codeTag": "Java"
            },
            {
                "id": 867145,
                "title": "python-o-n-beats-66",
                "content": "```\\nclass Solution:\\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int):\\n        if 4*boardingCost < runningCost:\\n            return -1\\n        \\n        n = len(customers)\\n        maxtotal, maxrotations = 0, -1\\n        total, rotations = 0, 1\\n        i = 0\\n        \\n        while True:\\n            if i == n-1 and customers[n-1] == 0:\\n                break\\n                \\n            if customers[i]>4:\\n                total += boardingCost*4 - runningCost\\n                \\n                if i < n-1:\\n                    customers[i+1] += customers[i]-4\\n                    customers[i] = 0\\n                else:\\n                    customers[i] -= 4\\n                    \\n            else:\\n                total += customers[i]*boardingCost - runningCost\\n                customers[i] = 0\\n            \\n            if total>maxtotal:\\n                maxtotal = total\\n                maxrotations = rotations\\n                \\n            if i<n-1: i += 1\\n            rotations += 1\\n            \\n        return maxrotations\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int):\\n        if 4*boardingCost < runningCost:\\n            return -1\\n        \\n        n = len(customers)\\n        maxtotal, maxrotations = 0, -1\\n        total, rotations = 0, 1\\n        i = 0\\n        \\n        while True:\\n            if i == n-1 and customers[n-1] == 0:\\n                break\\n                \\n            if customers[i]>4:\\n                total += boardingCost*4 - runningCost\\n                \\n                if i < n-1:\\n                    customers[i+1] += customers[i]-4\\n                    customers[i] = 0\\n                else:\\n                    customers[i] -= 4\\n                    \\n            else:\\n                total += customers[i]*boardingCost - runningCost\\n                customers[i] = 0\\n            \\n            if total>maxtotal:\\n                maxtotal = total\\n                maxrotations = rotations\\n                \\n            if i<n-1: i += 1\\n            rotations += 1\\n            \\n        return maxrotations\\n```",
                "codeTag": "Java"
            },
            {
                "id": 867089,
                "title": "java-2ms-100-beats-other-java-submissions-by-space-and-time",
                "content": "The idea is to find the remaining customers after iterating all customer to which calculate the rotation required.\\n\\n```\\nclass Solution {\\n    public int minOperationsMaxProfit(int[] customers, int boardingCost, int runningCost) {\\n        if (4 * boardingCost <= runningCost) {\\n            return -1;\\n        }\\n\\n        int remainingCustomers = 0;\\n        for (int i = 0; i < customers.length; i++) {\\n            customers[i] = customers[i] + remainingCustomers;\\n            remainingCustomers = customers[i] - Math.min(customers[i], 4);\\n        }\\n\\n        return customers.length + findRotations(remainingCustomers, boardingCost, runningCost);\\n    }\\n\\n    public int findRotations(int ramainingCustomers, int boardingCost, int runningCost) {\\n        int rotations = ramainingCustomers / 4;\\n        int r = ramainingCustomers % 4;\\n\\n        int profit = (ramainingCustomers - r) * boardingCost - (rotations * runningCost);\\n\\n        for (int i = ramainingCustomers - r + 1; i <= ramainingCustomers; i++) {\\n            int t = i * boardingCost - ((rotations + 1) * runningCost);\\n            if (t > profit) {\\n                return rotations + 1;\\n            }\\n        }\\n        return rotations;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minOperationsMaxProfit(int[] customers, int boardingCost, int runningCost) {\\n        if (4 * boardingCost <= runningCost) {\\n            return -1;\\n        }\\n\\n        int remainingCustomers = 0;\\n        for (int i = 0; i < customers.length; i++) {\\n            customers[i] = customers[i] + remainingCustomers;\\n            remainingCustomers = customers[i] - Math.min(customers[i], 4);\\n        }\\n\\n        return customers.length + findRotations(remainingCustomers, boardingCost, runningCost);\\n    }\\n\\n    public int findRotations(int ramainingCustomers, int boardingCost, int runningCost) {\\n        int rotations = ramainingCustomers / 4;\\n        int r = ramainingCustomers % 4;\\n\\n        int profit = (ramainingCustomers - r) * boardingCost - (rotations * runningCost);\\n\\n        for (int i = ramainingCustomers - r + 1; i <= ramainingCustomers; i++) {\\n            int t = i * boardingCost - ((rotations + 1) * runningCost);\\n            if (t > profit) {\\n                return rotations + 1;\\n            }\\n        }\\n        return rotations;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 867051,
                "title": "python-easy-code-solution",
                "content": "```\\nclass Solution:\\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\\n        total = 0 #total number of people currently available to ride\\n        totalProf = 0 #total global profit earned till now\\n        ans = 0  #minimum number of rides that need to be taken to earn max profit\\n        rides = 0 #number of rides done till any specific time\\n        prof = 0 #local profit/running profit.\\n        for i in customers:\\n            total += i\\n            rides+=1\\n            canRide = min(4,total)\\n            prof += canRide * boardingCost - runningCost\\n            total -= canRide\\n            if prof > totalProf:\\n                totalProf = prof\\n                ans = rides\\n        #no more people will arrive. So, try to maximize profit by using the remanining people.\\n        while total > 0:\\n            rides+=1\\n            canRide = min(4,total)\\n            prof += canRide * boardingCost - runningCost\\n            total -= canRide\\n            if prof > totalProf:\\n                totalProf = prof\\n                ans = rides\\n        if totalProf <= 0:\\n            return -1\\n        return ans\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\\n        total = 0 #total number of people currently available to ride\\n        totalProf = 0 #total global profit earned till now\\n        ans = 0  #minimum number of rides that need to be taken to earn max profit\\n        rides = 0 #number of rides done till any specific time\\n        prof = 0 #local profit/running profit.\\n        for i in customers:\\n            total += i\\n            rides+=1\\n            canRide = min(4,total)\\n            prof += canRide * boardingCost - runningCost\\n            total -= canRide\\n            if prof > totalProf:\\n                totalProf = prof\\n                ans = rides\\n        #no more people will arrive. So, try to maximize profit by using the remanining people.\\n        while total > 0:\\n            rides+=1\\n            canRide = min(4,total)\\n            prof += canRide * boardingCost - runningCost\\n            total -= canRide\\n            if prof > totalProf:\\n                totalProf = prof\\n                ans = rides\\n        if totalProf <= 0:\\n            return -1\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 866990,
                "title": "java-simple-solution-beats-100-o-n-time-o-1-space",
                "content": "Calculate the totOnBoard by keeping track of incoming customers, as well as wait list. Ensure to only pick 4 from combined lists. When the customers drain out, then drain out the wait list. Track the profit across the rotations.\\n\\nTime `O(N)` Space `O(1)`\\n\\n```\\nclass Solution {\\n    public int minOperationsMaxProfit(int[] customers, int boardingCost, int runningCost) {\\n        int totOnBoard = 0, totWaiting = 0, maxProfit = 0, numTimes = -1;\\n        for (int i = 0; i < customers.length || totWaiting > 0; i++) {\\n            int boardedCurrentCycle = 0;\\n            if (i < customers.length) {\\n                boardedCurrentCycle = Math.min(4, customers[i]);\\n                totWaiting += customers[i] - boardedCurrentCycle;\\n            }\\n            \\n            if (boardedCurrentCycle < 4 && totWaiting > 0) {\\n                int broughInFromWaitList = Math.min(4-boardedCurrentCycle, totWaiting);\\n                boardedCurrentCycle +=  broughInFromWaitList;\\n                totWaiting -=  broughInFromWaitList;\\n            }\\n            totOnBoard += boardedCurrentCycle;\\n            int profitSoFar = boardingCost*totOnBoard - runningCost*(i+1);\\n            if (profitSoFar > maxProfit) {\\n                numTimes = i+1;\\n                maxProfit = profitSoFar;\\n            }\\n        }\\n        return numTimes;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minOperationsMaxProfit(int[] customers, int boardingCost, int runningCost) {\\n        int totOnBoard = 0, totWaiting = 0, maxProfit = 0, numTimes = -1;\\n        for (int i = 0; i < customers.length || totWaiting > 0; i++) {\\n            int boardedCurrentCycle = 0;\\n            if (i < customers.length) {\\n                boardedCurrentCycle = Math.min(4, customers[i]);\\n                totWaiting += customers[i] - boardedCurrentCycle;\\n            }\\n            \\n            if (boardedCurrentCycle < 4 && totWaiting > 0) {\\n                int broughInFromWaitList = Math.min(4-boardedCurrentCycle, totWaiting);\\n                boardedCurrentCycle +=  broughInFromWaitList;\\n                totWaiting -=  broughInFromWaitList;\\n            }\\n            totOnBoard += boardedCurrentCycle;\\n            int profitSoFar = boardingCost*totOnBoard - runningCost*(i+1);\\n            if (profitSoFar > maxProfit) {\\n                numTimes = i+1;\\n                maxProfit = profitSoFar;\\n            }\\n        }\\n        return numTimes;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 866961,
                "title": "java-greedy-o-n-well-explained",
                "content": "This solution involves taking at most 4 values at a time.  These values (no. of customers) we can get from either the new set of customers, or from remaining ones.\\nWe keep track of remaining (waiting) number of people, and when new set of customers come, we update the count of waiting set of customers.\\nalso, **GREEDILY** number of people to board = Minimum of (new set of customers coming, 4).\\n\\nSince each onboarding is a rotation in itself, we increment rotation by 1.\\nWe also keep track of profit updating it cumulatively and update the maximum profit , also updating the rotation at which we got the maximum profit. \\nIf the maxProfit is positive, we return it or else -1. (No need to check profit here, since max profit will always be greater than profit.)\\n\\n```\\nclass Solution {\\n    public int minOperationsMaxProfit(int[] customers, int boardingCost, int runningCost) {\\n        int remaining = 0;\\n        int cIdx = 0, l = customers.length;\\n        int profit = 0, maxProfit = 0, rotation = 0, rotationAtMaxProfit = 0;\\n        \\n        while(cIdx<l || remaining!=0){\\n            if(cIdx<l)\\n                remaining += customers[cIdx++];\\n            int onBoard = Math.min(remaining,4);\\n            remaining -=onBoard;\\n            profit += onBoard*boardingCost - runningCost;\\n            rotation++;\\n            if(profit > maxProfit){\\n                maxProfit = profit;\\n                rotationAtMaxProfit = rotation;\\n            }\\n        }\\n        \\n        return (maxProfit>0) ? rotationAtMaxProfit : -1;\\n        \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minOperationsMaxProfit(int[] customers, int boardingCost, int runningCost) {\\n        int remaining = 0;\\n        int cIdx = 0, l = customers.length;\\n        int profit = 0, maxProfit = 0, rotation = 0, rotationAtMaxProfit = 0;\\n        \\n        while(cIdx<l || remaining!=0){\\n            if(cIdx<l)\\n                remaining += customers[cIdx++];\\n            int onBoard = Math.min(remaining,4);\\n            remaining -=onBoard;\\n            profit += onBoard*boardingCost - runningCost;\\n            rotation++;\\n            if(profit > maxProfit){\\n                maxProfit = profit;\\n                rotationAtMaxProfit = rotation;\\n            }\\n        }\\n        \\n        return (maxProfit>0) ? rotationAtMaxProfit : -1;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 866948,
                "title": "java-with-simple-comments-time-complexity-o-n",
                "content": "\\nThe idea is to allow 4 customers who have been waiting untill the ```i```th rotation is done  ( denoted by ```customers[i]``` )  and then, calculate the profit at every rotation while keeping two constraints \\n\\nFirst is  ->  _the wheel must have been rotated \\'i\\' times before the ith iteration  \\nSecond is  ->  maximum of 4 persons can board the gandola._\\n\\n```\\nclass Solution {\\n    public int minOperationsMaxProfit(int[] customers, int boardingCost, int runningCost) {\\n        //calculate profit at each step and then store max profit.\\n        \\n        int totalC = 0, nR=0, maxNR = 0, waiting=0, maxProfit = - (int) 10e9 ;\\n        for(int i=0 ; i<customers.length ; i++) {\\n            waiting += customers[i] ; \\n            if(nR < i) nR = i;\\n            if(waiting > 0) {\\n                //fill max of 4 customers.\\n                int d = Math.min(waiting,4);\\n                waiting -= d;\\n                totalC += d;\\n                nR++;\\n                int p = totalC*boardingCost - runningCost*nR;\\n               //boarded d at round nR, profit booked = p;\\n                if(p > maxProfit){\\n                    maxNR = nR;\\n                    maxProfit = p;\\n                }\\n            }\\n        }\\n        \\n        while(waiting > 0){\\n           //fill max of 4 customers.\\n            int d = Math.min(waiting,4);\\n            waiting -= d;\\n            totalC += d;\\n            nR++;\\n            int p = totalC*boardingCost - runningCost*nR;\\n            //boarded d at round nR, profit booked = p;\\n            if(p > maxProfit){\\n                maxNR = nR;\\n                maxProfit = p;\\n            }\\n        }\\n        return maxProfit > 0 ? maxNR : -1;\\n   }\\n}",
                "solutionTags": [],
                "code": "```i```\n```customers[i]```",
                "codeTag": "Unknown"
            },
            {
                "id": 866904,
                "title": "python3-o-n-solution",
                "content": "```\\nclass Solution:\\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\\n        if not customers:\\n            return -1\\n        i, profit, maxi, res = 1, 0, -1, -1\\n        board = min(4, customers[0])\\n        wait = customers[0] - board\\n        while i < len(customers) or wait > 0:\\n            profit += board * boardingCost - runningCost\\n            if profit > maxi:\\n                maxi = profit\\n                res = i\\n            \\n            if i < len(customers):\\n\\t\\t\\t\\t# there are still customers to arrive\\n                board = min(4, wait + customers[i])\\n                wait = wait - board + customers[i]\\n            else:\\n\\t\\t\\t\\t# all remaining customers are now waiting\\n                board = min(4, wait)\\n                wait = wait - board\\n\\n            i += 1\\n        profit += board * boardingCost - runningCost\\n        if profit > maxi:\\n            maxi = profit\\n            res = i \\n        \\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\\n        if not customers:\\n            return -1\\n        i, profit, maxi, res = 1, 0, -1, -1\\n        board = min(4, customers[0])\\n        wait = customers[0] - board\\n        while i < len(customers) or wait > 0:\\n            profit += board * boardingCost - runningCost\\n            if profit > maxi:\\n                maxi = profit\\n                res = i\\n            \\n            if i < len(customers):\\n\\t\\t\\t\\t# there are still customers to arrive\\n                board = min(4, wait + customers[i])\\n                wait = wait - board + customers[i]\\n            else:\\n\\t\\t\\t\\t# all remaining customers are now waiting\\n                board = min(4, wait)\\n                wait = wait - board\\n\\n            i += 1\\n        profit += board * boardingCost - runningCost\\n        if profit > maxi:\\n            maxi = profit\\n            res = i \\n        \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 866876,
                "title": "c-simple-solution",
                "content": "```\\npublic class Solution {\\n    \\n    int maxProfit;\\n    int minRotationForMaxProfit;\\n    int boardingCost;\\n    int runningCost;\\n    \\n    public int MinOperationsMaxProfit(int[] customers, int boardingCost, int runningCost) \\n    {\\n        this.boardingCost = boardingCost;\\n        this.runningCost = runningCost;\\n        this.maxProfit = -1;\\n        this.minRotationForMaxProfit = -1;\\n        int waitingClients = 0, rotation = 0, boardedCustomers = 0;\\n        \\n        foreach(int customer in customers)\\n        {\\n            waitingClients+=customer;\\n            calculateProfit(ref boardedCustomers, ref rotation, ref waitingClients);\\n        }\\n        while(waitingClients>0)\\n        {\\n            calculateProfit(ref boardedCustomers, ref rotation, ref waitingClients);\\n        }\\n        return minRotationForMaxProfit;\\n    }\\n    \\n    private void calculateProfit(ref int boardedCustomers, ref int rotation, ref int waitingClients)\\n\\t{\\n        int board = Math.Min(4,waitingClients);\\n        waitingClients-= board;\\n        boardedCustomers += board;\\n        rotation++;\\n        int profit = (boardedCustomers * boardingCost) - (rotation * runningCost);\\n        if(maxProfit<profit)\\n        {\\n            maxProfit = profit;\\n            minRotationForMaxProfit = rotation;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    \\n    int maxProfit;\\n    int minRotationForMaxProfit;\\n    int boardingCost;\\n    int runningCost;\\n    \\n    public int MinOperationsMaxProfit(int[] customers, int boardingCost, int runningCost) \\n    {\\n        this.boardingCost = boardingCost;\\n        this.runningCost = runningCost;\\n        this.maxProfit = -1;\\n        this.minRotationForMaxProfit = -1;\\n        int waitingClients = 0, rotation = 0, boardedCustomers = 0;\\n        \\n        foreach(int customer in customers)\\n        {\\n            waitingClients+=customer;\\n            calculateProfit(ref boardedCustomers, ref rotation, ref waitingClients);\\n        }\\n        while(waitingClients>0)\\n        {\\n            calculateProfit(ref boardedCustomers, ref rotation, ref waitingClients);\\n        }\\n        return minRotationForMaxProfit;\\n    }\\n    \\n    private void calculateProfit(ref int boardedCustomers, ref int rotation, ref int waitingClients)\\n\\t{\\n        int board = Math.Min(4,waitingClients);\\n        waitingClients-= board;\\n        boardedCustomers += board;\\n        rotation++;\\n        int profit = (boardedCustomers * boardingCost) - (rotation * runningCost);\\n        if(maxProfit<profit)\\n        {\\n            maxProfit = profit;\\n            minRotationForMaxProfit = rotation;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 866867,
                "title": "javascript-endless-loop",
                "content": "```\\nconst minOperationsMaxProfit = (customers, boardingCost, runningCost) => {\\n    let rotate = 0;\\n    let wait = 0;\\n    let board = 0;\\n    let record = [];\\n    let n = customers.length;\\n    while (true) {\\n        if (rotate > n && record.length == 0) return -1;\\n        let l = record[record.length - 1];\\n        let sl = record[record.length - 2];\\n        if (l <= sl) break;\\n        rotate++;\\n        if (customers.length != 0) {\\n            wait += customers[0];\\n            customers.shift();\\n        }\\n        if (wait > 4) {\\n            board += 4;\\n            wait -= 4;\\n        } else {\\n            let tmp = wait;\\n            wait-= tmp;\\n            board += tmp;\\n        }\\n        let profit = board * boardingCost - rotate * runningCost;\\n        if(profit > 0) record.push(profit);\\n    }\\n    return rotate - 1;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nconst minOperationsMaxProfit = (customers, boardingCost, runningCost) => {\\n    let rotate = 0;\\n    let wait = 0;\\n    let board = 0;\\n    let record = [];\\n    let n = customers.length;\\n    while (true) {\\n        if (rotate > n && record.length == 0) return -1;\\n        let l = record[record.length - 1];\\n        let sl = record[record.length - 2];\\n        if (l <= sl) break;\\n        rotate++;\\n        if (customers.length != 0) {\\n            wait += customers[0];\\n            customers.shift();\\n        }\\n        if (wait > 4) {\\n            board += 4;\\n            wait -= 4;\\n        } else {\\n            let tmp = wait;\\n            wait-= tmp;\\n            board += tmp;\\n        }\\n        let profit = board * boardingCost - rotate * runningCost;\\n        if(profit > 0) record.push(profit);\\n    }\\n    return rotate - 1;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 866860,
                "title": "java-greedy-9-ms-faster-than-100-00-48-9-mb-less-than-100-00",
                "content": "```\\nclass Solution {\\n    public int minOperationsMaxProfit(int[] customers, int boardingCost, int runningCost) {\\n        if (4 * boardingCost <= runningCost) {\\n            return -1;\\n        }\\n        int max = 0;\\n        int maxCnt = 0;\\n        int left = 0;\\n        int profit = 0;\\n        int cnt = 0;\\n        int i = 0;\\n        int n = customers.length;\\n        while (left > 0 || i < n) {\\n            if (i < n) {\\n                left += customers[i++];\\n            }\\n            int cur = Math.min(left, 4);\\n            left -= cur;\\n            ++cnt;\\n            profit += boardingCost * cur - runningCost;\\n            if (profit > max) {\\n                max = profit;\\n                maxCnt = cnt;\\n            }\\n        }\\n        return max > 0 ? maxCnt : -1;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minOperationsMaxProfit(int[] customers, int boardingCost, int runningCost) {\\n        if (4 * boardingCost <= runningCost) {\\n            return -1;\\n        }\\n        int max = 0;\\n        int maxCnt = 0;\\n        int left = 0;\\n        int profit = 0;\\n        int cnt = 0;\\n        int i = 0;\\n        int n = customers.length;\\n        while (left > 0 || i < n) {\\n            if (i < n) {\\n                left += customers[i++];\\n            }\\n            int cur = Math.min(left, 4);\\n            left -= cur;\\n            ++cnt;\\n            profit += boardingCost * cur - runningCost;\\n            if (profit > max) {\\n                max = profit;\\n                maxCnt = cnt;\\n            }\\n        }\\n        return max > 0 ? maxCnt : -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 866802,
                "title": "java-ac-solution-using-lot-of-variables",
                "content": "```\\nclass Solution {\\n    public int minOperationsMaxProfit(int[] customers, int boardingCost, int runningCost) {\\n        \\n        int maxProfit = 0;\\n        int waiting = 0;\\n        int i = 0;\\n        int index = 0;\\n        int profit = 0;\\n        int ans = 0;\\n        \\n        for(i=0; i<customers.length; i++){\\n            profit = 0;\\n            \\n            if(waiting > 0){\\n                customers[i] += waiting;\\n            }\\n            \\n            if(customers[i] > 4){\\n                waiting = customers[i] - 4;\\n                index = 4 * (i+1);\\n            }\\n            else{\\n                index = customers[i];\\n            }\\n            \\n            profit = index * boardingCost - (i+1) * runningCost;\\n            if(profit > maxProfit){\\n                maxProfit = profit;\\n                ans = i+1;\\n            }\\n        }\\n        \\n        while(waiting > 0){\\n            if(waiting <= 4){\\n                profit = (index+waiting) * boardingCost - (i+1) * runningCost;\\n                waiting = 0;\\n            }\\n            else{\\n                index += 4;\\n                profit = (index) * boardingCost - (i+1) * runningCost;\\n                waiting -= 4;\\n            }\\n            \\n            i++;\\n            if(profit > maxProfit){\\n                maxProfit = profit;\\n                ans = i;\\n            }\\n        }\\n        \\n        return maxProfit==0 ? -1 : ans;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minOperationsMaxProfit(int[] customers, int boardingCost, int runningCost) {\\n        \\n        int maxProfit = 0;\\n        int waiting = 0;\\n        int i = 0;\\n        int index = 0;\\n        int profit = 0;\\n        int ans = 0;\\n        \\n        for(i=0; i<customers.length; i++){\\n            profit = 0;\\n            \\n            if(waiting > 0){\\n                customers[i] += waiting;\\n            }\\n            \\n            if(customers[i] > 4){\\n                waiting = customers[i] - 4;\\n                index = 4 * (i+1);\\n            }\\n            else{\\n                index = customers[i];\\n            }\\n            \\n            profit = index * boardingCost - (i+1) * runningCost;\\n            if(profit > maxProfit){\\n                maxProfit = profit;\\n                ans = i+1;\\n            }\\n        }\\n        \\n        while(waiting > 0){\\n            if(waiting <= 4){\\n                profit = (index+waiting) * boardingCost - (i+1) * runningCost;\\n                waiting = 0;\\n            }\\n            else{\\n                index += 4;\\n                profit = (index) * boardingCost - (i+1) * runningCost;\\n                waiting -= 4;\\n            }\\n            \\n            i++;\\n            if(profit > maxProfit){\\n                maxProfit = profit;\\n                ans = i;\\n            }\\n        }\\n        \\n        return maxProfit==0 ? -1 : ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 866779,
                "title": "you-will-like-this-c",
                "content": "```\\n int minOperationsMaxProfit(vector<int>& customers, int boardingCost, int runningCost) {\\n        \\n        vector<int>profitarr;\\n        \\n        int left=0,board,prevboard=0,prevrot=0,currot,jawab,x,profit,loss;\\n        \\n        for(int i=0;i<customers.size();i++){\\n            \\n             x=customers[i]+left;\\n            \\n            if(x>4){\\n             board=prevboard+4;\\n             left=x-4;}\\n            \\n            else{\\n             board=prevboard+x;\\n             left=0;}\\n            \\n            prevboard=board;\\n            \\n             profit=board*boardingCost;\\n            currot=prevrot+1;\\n            \\n             loss=(currot)*runningCost;\\n            prevrot=currot;\\n            \\n            profitarr.push_back(profit-loss);\\n        }\\n           while(left>0) //taking care of remaining customers if any \\n        {\\n                \\n            if(left>4){\\n             board=prevboard+4;\\n             left-=4;}\\n            \\n            else{\\n             board=prevboard+left;\\n             left=0;}\\n            \\n            prevboard=board;\\n            \\n            profit=board*boardingCost;\\n            currot=prevrot+1;\\n            \\n            loss=(currot)*runningCost;\\n            prevrot=currot;\\n            \\n            profitarr.push_back(profit-loss);\\n           \\n           \\n        }\\n        \\n        \\n        int maax=INT_MIN;\\n        \\n        for(int i=0;i<profitarr.size();i++){\\n            \\n            if(profitarr[i]>maax)\\n                \\n            {\\n               maax=profitarr[i];\\n               jawab=i;\\n            }\\n        }\\n        if(maax<0) return -1;\\n        \\n        else return jawab+1;}\\n```",
                "solutionTags": [],
                "code": "```\\n int minOperationsMaxProfit(vector<int>& customers, int boardingCost, int runningCost) {\\n        \\n        vector<int>profitarr;\\n        \\n        int left=0,board,prevboard=0,prevrot=0,currot,jawab,x,profit,loss;\\n        \\n        for(int i=0;i<customers.size();i++){\\n            \\n             x=customers[i]+left;\\n            \\n            if(x>4){\\n             board=prevboard+4;\\n             left=x-4;}\\n            \\n            else{\\n             board=prevboard+x;\\n             left=0;}\\n            \\n            prevboard=board;\\n            \\n             profit=board*boardingCost;\\n            currot=prevrot+1;\\n            \\n             loss=(currot)*runningCost;\\n            prevrot=currot;\\n            \\n            profitarr.push_back(profit-loss);\\n        }\\n           while(left>0) //taking care of remaining customers if any \\n        {\\n                \\n            if(left>4){\\n             board=prevboard+4;\\n             left-=4;}\\n            \\n            else{\\n             board=prevboard+left;\\n             left=0;}\\n            \\n            prevboard=board;\\n            \\n            profit=board*boardingCost;\\n            currot=prevrot+1;\\n            \\n            loss=(currot)*runningCost;\\n            prevrot=currot;\\n            \\n            profitarr.push_back(profit-loss);\\n           \\n           \\n        }\\n        \\n        \\n        int maax=INT_MIN;\\n        \\n        for(int i=0;i<profitarr.size();i++){\\n            \\n            if(profitarr[i]>maax)\\n                \\n            {\\n               maax=profitarr[i];\\n               jawab=i;\\n            }\\n        }\\n        if(maax<0) return -1;\\n        \\n        else return jawab+1;}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 866774,
                "title": "c-o-n-simple-solution-comment-100-100",
                "content": "```\\nclass Solution {\\npublic:\\n    int minOperationsMaxProfit(vector<int>& customers, int boardingCost, int runningCost) {\\n\\n        int i=0, waitingCustomers = 0, boardedCustomers = 0, maximumProfit = INT_MIN, rotations = 0;\\n        while(i < customers.size() || waitingCustomers > 0)\\n        {\\n        \\t//Process customer at index i, and add them in waiting lists.\\n            if(i < customers.size())\\n                waitingCustomers += customers[i];\\n            \\n            i++;\\n            \\n            //If there are customers, process them.\\n            if(waitingCustomers > 0)\\n            {\\n            \\t//At a time max 4 can board\\n                int canBoard = (waitingCustomers >= 4 ? 4 : waitingCustomers);\\n                boardedCustomers += canBoard;\\n                waitingCustomers -= canBoard;\\n                \\n\\t\\t\\t\\t//Calculate the profit.\\n                int profit = (boardedCustomers * boardingCost) - ( (i) *runningCost);\\n                if(maximumProfit < profit)\\n                {\\n                    maximumProfit = profit;\\n                    rotations = i;\\n                }                \\n            }\\n        }\\n        \\n        return maximumProfit < 0 ? -1 : rotations;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperationsMaxProfit(vector<int>& customers, int boardingCost, int runningCost) {\\n\\n        int i=0, waitingCustomers = 0, boardedCustomers = 0, maximumProfit = INT_MIN, rotations = 0;\\n        while(i < customers.size() || waitingCustomers > 0)\\n        {\\n        \\t//Process customer at index i, and add them in waiting lists.\\n            if(i < customers.size())\\n                waitingCustomers += customers[i];\\n            \\n            i++;\\n            \\n            //If there are customers, process them.\\n            if(waitingCustomers > 0)\\n            {\\n            \\t//At a time max 4 can board\\n                int canBoard = (waitingCustomers >= 4 ? 4 : waitingCustomers);\\n                boardedCustomers += canBoard;\\n                waitingCustomers -= canBoard;\\n                \\n\\t\\t\\t\\t//Calculate the profit.\\n                int profit = (boardedCustomers * boardingCost) - ( (i) *runningCost);\\n                if(maximumProfit < profit)\\n                {\\n                    maximumProfit = profit;\\n                    rotations = i;\\n                }                \\n            }\\n        }\\n        \\n        return maximumProfit < 0 ? -1 : rotations;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 866761,
                "title": "east-to-understand-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int minOperationsMaxProfit(vector<int>& c, int bCost, int rCost) {\\n        int in_queue = 0;\\n        int n_rotations = 0;\\n        int boarded = 0;\\n        \\n        int ans = 0;\\n        int max_profit = 0;\\n        \\n        int i = 0;\\n        while(in_queue > 0 || i < c.size()){\\n            if( i < c.size())\\n                in_queue += c[i++];\\n            n_rotations++;\\n            if(in_queue < 4){\\n                boarded += in_queue;\\n                in_queue = 0;\\n            }\\n            else {\\n                boarded += 4;\\n                in_queue = in_queue - 4;\\n            }\\n            \\n            auto curr_profit = (boarded * bCost) - (n_rotations * rCost);\\n            if(curr_profit > max_profit){\\n                ans = n_rotations;\\n                max_profit = curr_profit;\\n            }\\n        }\\n\\n        if(ans == 0)\\n            return -1;\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperationsMaxProfit(vector<int>& c, int bCost, int rCost) {\\n        int in_queue = 0;\\n        int n_rotations = 0;\\n        int boarded = 0;\\n        \\n        int ans = 0;\\n        int max_profit = 0;\\n        \\n        int i = 0;\\n        while(in_queue > 0 || i < c.size()){\\n            if( i < c.size())\\n                in_queue += c[i++];\\n            n_rotations++;\\n            if(in_queue < 4){\\n                boarded += in_queue;\\n                in_queue = 0;\\n            }\\n            else {\\n                boarded += 4;\\n                in_queue = in_queue - 4;\\n            }\\n            \\n            auto curr_profit = (boarded * bCost) - (n_rotations * rCost);\\n            if(curr_profit > max_profit){\\n                ans = n_rotations;\\n                max_profit = curr_profit;\\n            }\\n        }\\n\\n        if(ans == 0)\\n            return -1;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 866734,
                "title": "c-easy-approach",
                "content": "```\\nclass Solution {\\npublic:\\n    int minOperationsMaxProfit(vector<int>& customers, int boardingCost, int runningCost) {\\n        int waiting = 0, cost = 0, rounds = 0, maxCost = 0, maxRound = -1;\\n        for (int i = 0; i < customers.size(); i++)  {\\n            waiting+=customers[i];\\n            if (waiting >=4 ) {\\n                cost+=(4 * boardingCost);\\n                waiting-=4;\\n            } else {\\n                cost+=(waiting * boardingCost);\\n                waiting = 0;\\n            } \\n            cost-=runningCost;\\n            rounds++;\\n            if (cost > maxCost) {\\n                maxRound = rounds;\\n                maxCost = cost;\\n            } \\n        }\\n        while(waiting) {\\n            if (waiting >=4) {\\n                cost+=(4 * boardingCost);\\n                waiting-=4;         \\n            } else {\\n                cost+=waiting * boardingCost;\\n                waiting = 0;\\n            }  \\n            cost-=runningCost;\\n            rounds++;\\n            if (cost > maxCost) {\\n                maxRound = rounds;\\n                maxCost = cost; \\n            } \\n        }\\n        return maxRound; \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperationsMaxProfit(vector<int>& customers, int boardingCost, int runningCost) {\\n        int waiting = 0, cost = 0, rounds = 0, maxCost = 0, maxRound = -1;\\n        for (int i = 0; i < customers.size(); i++)  {\\n            waiting+=customers[i];\\n            if (waiting >=4 ) {\\n                cost+=(4 * boardingCost);\\n                waiting-=4;\\n            } else {\\n                cost+=(waiting * boardingCost);\\n                waiting = 0;\\n            } \\n            cost-=runningCost;\\n            rounds++;\\n            if (cost > maxCost) {\\n                maxRound = rounds;\\n                maxCost = cost;\\n            } \\n        }\\n        while(waiting) {\\n            if (waiting >=4) {\\n                cost+=(4 * boardingCost);\\n                waiting-=4;         \\n            } else {\\n                cost+=waiting * boardingCost;\\n                waiting = 0;\\n            }  \\n            cost-=runningCost;\\n            rounds++;\\n            if (cost > maxCost) {\\n                maxRound = rounds;\\n                maxCost = cost; \\n            } \\n        }\\n        return maxRound; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 866728,
                "title": "go-single-pass-o-n",
                "content": "After seeing example, I thought this problem is about checking `final profit > final cost`. For each round, maximum 4 people can get in, which means max profit each round is `4 * boardingCost`, so if `runningCost >= 4 * boardingCost` means this centennial will never able to profit.\\n\\nBut last paragraph says about stopping wheel, I was wondering what it is saying, then I realized that it is trying to handle folloing conditions of customers: [4, 0, 0, 0, 0, 0]. After 4 people coming, there\\'s no other people which means maximum profitable can only occurs at first round.\\n\\n```golang\\nfunc minOperationsMaxProfit(customers []int, boardingCost int, runningCost int) int {\\n\\t// never profitable\\n\\tif runningCost >= boardingCost*4 {\\n\\t\\treturn -1\\n\\t}\\n\\n\\tvar profit, cost, waiting int\\n\\tmaxProfit, maxProfitAt := 0, -1\\n\\n\\t// what if at some point, 0 customer come, e.g. [4, 0, 0, 0, 0]\\n\\tfor i := 0; i < len(customers) || waiting > 0; i++ {\\n\\t\\tif i < len(customers) {\\n\\t\\t\\twaiting += customers[i]\\n\\t\\t}\\n\\t\\tcost += runningCost\\n\\n\\t\\tprofit += min(4, waiting) * boardingCost\\n\\t\\twaiting = max(0, waiting-4)\\n\\n\\t\\tif c := profit - cost; c > maxProfit {\\n\\t\\t\\tmaxProfit = c\\n\\t\\t\\tmaxProfitAt = i + 1\\n\\t\\t}\\n\\t}\\n\\n\\treturn maxProfitAt\\n}\\n\\nfunc max(i, j int) int {\\n\\tif i >= j {\\n\\t\\treturn i\\n\\t}\\n\\treturn j\\n}\\n\\nfunc min(i, j int) int {\\n\\tif i <= j {\\n\\t\\treturn i\\n\\t}\\n\\treturn j\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```golang\\nfunc minOperationsMaxProfit(customers []int, boardingCost int, runningCost int) int {\\n\\t// never profitable\\n\\tif runningCost >= boardingCost*4 {\\n\\t\\treturn -1\\n\\t}\\n\\n\\tvar profit, cost, waiting int\\n\\tmaxProfit, maxProfitAt := 0, -1\\n\\n\\t// what if at some point, 0 customer come, e.g. [4, 0, 0, 0, 0]\\n\\tfor i := 0; i < len(customers) || waiting > 0; i++ {\\n\\t\\tif i < len(customers) {\\n\\t\\t\\twaiting += customers[i]\\n\\t\\t}\\n\\t\\tcost += runningCost\\n\\n\\t\\tprofit += min(4, waiting) * boardingCost\\n\\t\\twaiting = max(0, waiting-4)\\n\\n\\t\\tif c := profit - cost; c > maxProfit {\\n\\t\\t\\tmaxProfit = c\\n\\t\\t\\tmaxProfitAt = i + 1\\n\\t\\t}\\n\\t}\\n\\n\\treturn maxProfitAt\\n}\\n\\nfunc max(i, j int) int {\\n\\tif i >= j {\\n\\t\\treturn i\\n\\t}\\n\\treturn j\\n}\\n\\nfunc min(i, j int) int {\\n\\tif i <= j {\\n\\t\\treturn i\\n\\t}\\n\\treturn j\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 866724,
                "title": "java-solution-at-contest",
                "content": "Guess this is greedy problem? \\u9898\\u76EE\\u63CF\\u8FF0\\u5F88\\u590D\\u6742\\uFF0C\\u4F46\\u6CA1\\u89C9\\u5F97\\u6709\\u5565\\u7279\\u522B\\u7684\\u8003\\u70B9\\u3002\\n```\\nclass Solution {\\n    public int minOperationsMaxProfit(int[] customers, int boardingCost, int runningCost) {\\n        int remain = 0, count = 0;\\n        int run = 0;\\n        int max = Integer.MIN_VALUE;\\n        List<Integer> res = new ArrayList<>();\\n        for (int i = 0; i < customers.length; i++) {\\n            remain += customers[i];\\n            if (remain >= 4) {\\n                remain -= 4;\\n                run += 4;\\n            } else {\\n                run += remain;\\n                remain = 0;\\n            }\\n            count++;\\n            \\n            int profit = boardingCost * run - runningCost * count;\\n            max = Math.max(max, profit);\\n            res.add(profit);\\n        }\\n        \\n        while (remain > 0) {\\n            if (remain >= 4) {\\n                remain -= 4;\\n                run += 4;\\n            } else {\\n                run += remain;\\n                remain = 0;\\n            }\\n            count++;\\n            int profit = boardingCost * run - runningCost * count;\\n            max = Math.max(max, profit);\\n            res.add(profit);\\n            \\n        }\\n        \\n        if (max < 0) return -1;\\n        \\n        for (int i = 0; i < res.size(); i++) {\\n            if (res.get(i) == max) {\\n                return i + 1;\\n            }\\n        }\\n        \\n        return 0;\\n        \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minOperationsMaxProfit(int[] customers, int boardingCost, int runningCost) {\\n        int remain = 0, count = 0;\\n        int run = 0;\\n        int max = Integer.MIN_VALUE;\\n        List<Integer> res = new ArrayList<>();\\n        for (int i = 0; i < customers.length; i++) {\\n            remain += customers[i];\\n            if (remain >= 4) {\\n                remain -= 4;\\n                run += 4;\\n            } else {\\n                run += remain;\\n                remain = 0;\\n            }\\n            count++;\\n            \\n            int profit = boardingCost * run - runningCost * count;\\n            max = Math.max(max, profit);\\n            res.add(profit);\\n        }\\n        \\n        while (remain > 0) {\\n            if (remain >= 4) {\\n                remain -= 4;\\n                run += 4;\\n            } else {\\n                run += remain;\\n                remain = 0;\\n            }\\n            count++;\\n            int profit = boardingCost * run - runningCost * count;\\n            max = Math.max(max, profit);\\n            res.add(profit);\\n            \\n        }\\n        \\n        if (max < 0) return -1;\\n        \\n        for (int i = 0; i < res.size(); i++) {\\n            if (res.get(i) == max) {\\n                return i + 1;\\n            }\\n        }\\n        \\n        return 0;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 866717,
                "title": "just-greedy-but-it-is-hard-to-understand-the-problem",
                "content": "The most hard part is to understand the problem itself.\\n\\nBecause it says \\\\`I \\' can stop the game any time, So:\\n\\n- At first, I thought it was ask for the max profile \\\\`I\\' can earn. If \\\\`I\\u2019 can earn money (the profile is always negative), it is OK \\\\`I\\u2019 just don\\u2019t play this game. So max profile is 0, why -1? Alright, it is my mistake.\\n- When I read it one more time, I am confused again. If \\\\`I\\u2019 do not play this, the max profit (0) is got when rotate wheel 0 times, why -1?\\n\\nFinally, I try to forget the \\\\`Why -1 not 0\\u2019, and just code it, and it actually gets accepted\\u2026  \\uD83D\\uDE05\\t :sweat_smile:\\n\\nAccidentally, I find the markdown render in LeetCode doesn\\u2019t support emoji shortcode, sad\\u2026 \\uD83D\\uDE1E :disappointed:\\n\\n```c++\\nint minOperationsMaxProfit(vector<int>& C, int B, int R)\\n{\\n  int len = static_cast<int>(C.size());\\n  int profile = 0, ans = -1;\\n  int cur = 0, num = 0, play;\\n  vector<pair<int, int>> A;\\n  for (int i = 0; i < len; ++i)\\n  {\\n    num += C[i];\\n    play = min(num, 4);\\n    num -= play;\\n    cur += play * B - R;\\n    if (cur > profile)\\n    {\\n      profile = cur;\\n      ans = i + 1;\\n    }\\n  }\\n  for (int i = len; num > 0; ++i)\\n  {\\n    play = min(num, 4);\\n    num -= play;\\n    cur += play * B - R;\\n    if (cur > profile)\\n    {\\n      profile = cur;\\n      ans = i + 1;\\n    }\\n  }\\n  return ans;\\n}\\n```",
                "solutionTags": [],
                "code": "```c++\\nint minOperationsMaxProfit(vector<int>& C, int B, int R)\\n{\\n  int len = static_cast<int>(C.size());\\n  int profile = 0, ans = -1;\\n  int cur = 0, num = 0, play;\\n  vector<pair<int, int>> A;\\n  for (int i = 0; i < len; ++i)\\n  {\\n    num += C[i];\\n    play = min(num, 4);\\n    num -= play;\\n    cur += play * B - R;\\n    if (cur > profile)\\n    {\\n      profile = cur;\\n      ans = i + 1;\\n    }\\n  }\\n  for (int i = len; num > 0; ++i)\\n  {\\n    play = min(num, 4);\\n    num -= play;\\n    cur += play * B - R;\\n    if (cur > profile)\\n    {\\n      profile = cur;\\n      ans = i + 1;\\n    }\\n  }\\n  return ans;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 866697,
                "title": "easy-java-solution",
                "content": "class Solution {\\n    public int minOperationsMaxProfit(int[] customers, int boardingCost, int runningCost) {\\n        if(customers.length==0)\\n            return 0;\\n        int sum=0;\\n        int count=0;\\n        int left=0;\\n        int ans=0;\\n        int d=0;\\n        int max=-1;\\n        for(int i=0;i<customers.length;i++)\\n        {    \\n            \\n             left+=customers[i];\\n            \\n            \\n           \\n            if(left>4)\\n            { left=left-4;\\n            sum=sum+4;}\\n            else\\n            {sum=sum+left;\\n             left=0;}\\n             \\n             \\n            count++;\\n             d=sum*boardingCost-count*runningCost;\\n            if(d>max)\\n            {max=Math.max(max,sum*boardingCost-count*runningCost);\\n             ans=count;}\\n        }\\n        while(left>0)\\n        {\\n            if(left>4)\\n            { left-=4;\\n            sum+=4;}\\n            else\\n            {\\n                sum+=left;\\n                left=0;\\n            }\\n            count++;\\n            d=sum*boardingCost-count*runningCost;\\n            if(d>max)\\n            {max=Math.max(max,sum*boardingCost-count*runningCost);\\n             ans=count;}\\n             //max=Math.max(max,sum*boardingCost-count*runningCost);\\n        }\\n        if(max<0)\\n            return -1;\\n        else\\n            return ans;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int minOperationsMaxProfit(int[] customers, int boardingCost, int runningCost) {\\n        if(customers.length==0)\\n            return 0;\\n        int sum=0;\\n        int count=0;\\n        int left=0;\\n        int ans=0;\\n        int d=0;\\n        int max=-1;\\n        for(int i=0;i<customers.length;i++)\\n        {    \\n            \\n             left+=customers[i];\\n            \\n            \\n           \\n            if(left>4)\\n            { left=left-4;\\n            sum=sum+4;}",
                "codeTag": "Java"
            },
            {
                "id": 866694,
                "title": "java-clear-and-easy-solution-beats-100-time",
                "content": "```\\nclass Solution {\\n    public int minOperationsMaxProfit(int[] customers, int boardingCost, int runningCost) {\\n        if(customers.length == 0)\\n            return 0;\\n        int pass = customers[0], profit = 0, i = 1, served = 0, rotation = 0, res = -1;\\n        \\n        while(pass > 0 || i < customers.length) {\\n\\t\\t\\tint onboard = Math.max(4, pass);\\n\\t\\t\\tserved += onboard;\\n\\t\\t\\tpass -= onboard;\\n\\t\\t\\t\\n            rotation++;\\n            int pr = served * boardingCost - runningCost * rotation;\\n            if(pr > profit) {\\n                profit = pr;\\n                res = rotation;\\n            }\\n            \\n            pass += i < customers.length ? customers[i++] : 0;\\n        }\\n        \\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minOperationsMaxProfit(int[] customers, int boardingCost, int runningCost) {\\n        if(customers.length == 0)\\n            return 0;\\n        int pass = customers[0], profit = 0, i = 1, served = 0, rotation = 0, res = -1;\\n        \\n        while(pass > 0 || i < customers.length) {\\n\\t\\t\\tint onboard = Math.max(4, pass);\\n\\t\\t\\tserved += onboard;\\n\\t\\t\\tpass -= onboard;\\n\\t\\t\\t\\n            rotation++;\\n            int pr = served * boardingCost - runningCost * rotation;\\n            if(pr > profit) {\\n                profit = pr;\\n                res = rotation;\\n            }\\n            \\n            pass += i < customers.length ? customers[i++] : 0;\\n        }\\n        \\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 866670,
                "title": "c-solution-simply-simulate-the-process",
                "content": "```\\nclass Solution {\\npublic:\\n    int minOperationsMaxProfit(vector<int>& customers, int boardingCost, int runningCost) {\\n        int result = -1;\\n        int remaining = 0;\\n        int profit = 0;\\n        int afterProfit = 0;\\n        int i = 0;\\n        while(i < customers.size() || remaining > 0){\\n            if(i < customers.size()) remaining += customers[i];\\n            int num = min(remaining, 4);     \\n            afterProfit = profit + num * boardingCost - runningCost;\\n            if(afterProfit > profit){\\n                result = i + 1;\\n            }\\n            profit = afterProfit;\\n            i++;\\n            remaining -= num;\\n        }\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperationsMaxProfit(vector<int>& customers, int boardingCost, int runningCost) {\\n        int result = -1;\\n        int remaining = 0;\\n        int profit = 0;\\n        int afterProfit = 0;\\n        int i = 0;\\n        while(i < customers.size() || remaining > 0){\\n            if(i < customers.size()) remaining += customers[i];\\n            int num = min(remaining, 4);     \\n            afterProfit = profit + num * boardingCost - runningCost;\\n            if(afterProfit > profit){\\n                result = i + 1;\\n            }\\n            profit = afterProfit;\\n            i++;\\n            remaining -= num;\\n        }\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 866642,
                "title": "c-o-n-brute-force",
                "content": "```csharp\\npublic int MinOperationsMaxProfit(int[] customers, int boardingCost, int runningCost)\\n{\\n\\tint maxProfit = int.MinValue;\\n\\tint waitingCustomers = 0;\\n\\tint maxCapacity = 4;\\n\\tint rotationCount = 0;\\n\\tint result = 0;\\n\\tint profit = 0;\\n\\n\\tfor (int i = 0; i < customers.Length; i++)\\n\\t{\\n\\t\\trotationCount++;\\n\\t\\tint currentCount;\\n\\n\\t\\tint customer = customers[i] + waitingCustomers;\\n\\t\\tif (customer >= maxCapacity)\\n\\t\\t{\\n\\t\\t\\tcurrentCount = maxCapacity;\\n\\t\\t\\twaitingCustomers = customer - maxCapacity;\\n\\t\\t}\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tcurrentCount = customer;\\n\\t\\t\\twaitingCustomers = 0;\\n\\t\\t}\\n\\n\\t\\tprofit += (currentCount * boardingCost) - runningCost;\\n\\t\\tif (profit > maxProfit)\\n\\t\\t{\\n\\t\\t\\tmaxProfit = profit;\\n\\t\\t\\tresult = rotationCount;\\n\\t\\t}                \\n\\t}\\n\\n\\twhile (waitingCustomers > 0)\\n\\t{\\n\\t\\trotationCount++;\\n\\t\\tint currentCount = waitingCustomers <= maxCapacity ? waitingCustomers : maxCapacity;\\n\\t\\twaitingCustomers -= currentCount;\\n\\n\\t\\tprofit += (currentCount * boardingCost) - runningCost;\\n\\t\\tif (profit > maxProfit)\\n\\t\\t{\\n\\t\\t\\tmaxProfit = profit;\\n\\t\\t\\tresult = rotationCount;\\n\\t\\t}               \\n\\t}\\n\\n\\treturn maxProfit < 0 ? -1 : result;\\n}\\n```",
                "solutionTags": [],
                "code": "```csharp\\npublic int MinOperationsMaxProfit(int[] customers, int boardingCost, int runningCost)\\n{\\n\\tint maxProfit = int.MinValue;\\n\\tint waitingCustomers = 0;\\n\\tint maxCapacity = 4;\\n\\tint rotationCount = 0;\\n\\tint result = 0;\\n\\tint profit = 0;\\n\\n\\tfor (int i = 0; i < customers.Length; i++)\\n\\t{\\n\\t\\trotationCount++;\\n\\t\\tint currentCount;\\n\\n\\t\\tint customer = customers[i] + waitingCustomers;\\n\\t\\tif (customer >= maxCapacity)\\n\\t\\t{\\n\\t\\t\\tcurrentCount = maxCapacity;\\n\\t\\t\\twaitingCustomers = customer - maxCapacity;\\n\\t\\t}\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tcurrentCount = customer;\\n\\t\\t\\twaitingCustomers = 0;\\n\\t\\t}\\n\\n\\t\\tprofit += (currentCount * boardingCost) - runningCost;\\n\\t\\tif (profit > maxProfit)\\n\\t\\t{\\n\\t\\t\\tmaxProfit = profit;\\n\\t\\t\\tresult = rotationCount;\\n\\t\\t}                \\n\\t}\\n\\n\\twhile (waitingCustomers > 0)\\n\\t{\\n\\t\\trotationCount++;\\n\\t\\tint currentCount = waitingCustomers <= maxCapacity ? waitingCustomers : maxCapacity;\\n\\t\\twaitingCustomers -= currentCount;\\n\\n\\t\\tprofit += (currentCount * boardingCost) - runningCost;\\n\\t\\tif (profit > maxProfit)\\n\\t\\t{\\n\\t\\t\\tmaxProfit = profit;\\n\\t\\t\\tresult = rotationCount;\\n\\t\\t}               \\n\\t}\\n\\n\\treturn maxProfit < 0 ? -1 : result;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 866635,
                "title": "java-simple-and-clean-solution",
                "content": "```\\npublic int minOperationsMaxProfit(int[] customers, int boardingCost, int runningCost) {\\n        int customersLeft = 0, currProfit = 0, maxProfit = 0;\\n        int i = 0, rotations = -1;\\n\\n        while (i < customers.length || customersLeft > 0) {\\n            if (i < customers.length) {\\n                customersLeft += customers[i];\\n            }\\n\\n            int thisRoundCustomers = Math.min(customersLeft, 4);\\n            customersLeft -= thisRoundCustomers;\\n\\n            currProfit += (thisRoundCustomers * boardingCost) - runningCost;\\n            if (currProfit > maxProfit) {\\n                maxProfit = currProfit;\\n                rotations = i + 1;\\n            }\\n\\n            i++;\\n        }\\n\\n        return rotations;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic int minOperationsMaxProfit(int[] customers, int boardingCost, int runningCost) {\\n        int customersLeft = 0, currProfit = 0, maxProfit = 0;\\n        int i = 0, rotations = -1;\\n\\n        while (i < customers.length || customersLeft > 0) {\\n            if (i < customers.length) {\\n                customersLeft += customers[i];\\n            }\\n\\n            int thisRoundCustomers = Math.min(customersLeft, 4);\\n            customersLeft -= thisRoundCustomers;\\n\\n            currProfit += (thisRoundCustomers * boardingCost) - runningCost;\\n            if (currProfit > maxProfit) {\\n                maxProfit = currProfit;\\n                rotations = i + 1;\\n            }\\n\\n            i++;\\n        }\\n\\n        return rotations;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 866628,
                "title": "c-o-n-time-and-o-1-space",
                "content": "```\\nclass Solution {\\npublic:\\n    int minOperationsMaxProfit(vector<int>& customers, int boardingCost, int runningCost) \\n\\t{\\n\\t\\tif(boardingCost * 4 < runningCost)\\n\\t\\t\\treturn -1;\\n\\n    \\tlong long int res = -1, max_profit = 0, curr_profit = 0;\\n    \\tfor(int i = 0; i < customers.size(); i++)\\n    \\t{\\n    \\t\\tif(i > 0)\\n    \\t\\t\\tcustomers[i] += max(0, customers[i - 1] - 4);\\n    \\t\\t\\n    \\t\\tint boarding = min(4, customers[i]);\\n    \\t\\t\\n    \\t\\tint profit = boarding * boardingCost - runningCost;\\n    \\t\\tcurr_profit += profit;\\n    \\t\\tif(curr_profit > max_profit)\\n    \\t\\t{\\n    \\t\\t\\tmax_profit = curr_profit;\\n    \\t\\t\\tres = i + 1;\\n    \\t\\t}\\n    \\t}\\n\\n    \\t\\n    \\tcustomers.back() -= 4;\\n\\n    \\tif(customers.back() > 0)\\n    \\t\\tcurr_profit += (boardingCost * (customers.back() / 4) * 4) - (customers.back() / 4) * runningCost;\\n\\n    \\tif(curr_profit > max_profit)\\n    \\t\\tres = customers.size() + customers.back() / 4;\\n\\n    \\tif((customers.back() % 4 * boardingCost) > runningCost)\\n    \\t\\tres = customers.size() + customers.back() / 4 + 1; \\n\\n    \\treturn res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperationsMaxProfit(vector<int>& customers, int boardingCost, int runningCost) \\n\\t{\\n\\t\\tif(boardingCost * 4 < runningCost)\\n\\t\\t\\treturn -1;\\n\\n    \\tlong long int res = -1, max_profit = 0, curr_profit = 0;\\n    \\tfor(int i = 0; i < customers.size(); i++)\\n    \\t{\\n    \\t\\tif(i > 0)\\n    \\t\\t\\tcustomers[i] += max(0, customers[i - 1] - 4);\\n    \\t\\t\\n    \\t\\tint boarding = min(4, customers[i]);\\n    \\t\\t\\n    \\t\\tint profit = boarding * boardingCost - runningCost;\\n    \\t\\tcurr_profit += profit;\\n    \\t\\tif(curr_profit > max_profit)\\n    \\t\\t{\\n    \\t\\t\\tmax_profit = curr_profit;\\n    \\t\\t\\tres = i + 1;\\n    \\t\\t}\\n    \\t}\\n\\n    \\t\\n    \\tcustomers.back() -= 4;\\n\\n    \\tif(customers.back() > 0)\\n    \\t\\tcurr_profit += (boardingCost * (customers.back() / 4) * 4) - (customers.back() / 4) * runningCost;\\n\\n    \\tif(curr_profit > max_profit)\\n    \\t\\tres = customers.size() + customers.back() / 4;\\n\\n    \\tif((customers.back() % 4 * boardingCost) > runningCost)\\n    \\t\\tres = customers.size() + customers.back() / 4 + 1; \\n\\n    \\treturn res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 866625,
                "title": "java-easy",
                "content": "```\\nclass Solution {\\n    public int minOperationsMaxProfit(int[] customers, int boardingCost, int runningCost) {\\n        int customersWaiting = 0;\\n        int profit = 0;\\n        int maxProfit = -1;\\n        int roationNoWhenProfitisMax = -1;\\n        int customersOnBoard = 0;\\n        int rotation = 0;\\n        \\n        for(int i=0; i<customers.length; i++){\\n            customersWaiting+=customers[i];\\n            int board= customersWaiting>=4 ? 4: customersWaiting;\\n            customersOnBoard+=board;\\n            customersWaiting-=board;\\n            rotation++;\\n            \\n            profit = customersOnBoard*boardingCost - rotation*runningCost;\\n            \\n            if(maxProfit < profit){\\n                maxProfit = profit;\\n                roationNoWhenProfitisMax = rotation;\\n            }\\n            \\n        }\\n        \\n        while(customersWaiting!=0){\\n            int board= customersWaiting>=4 ? 4: customersWaiting;\\n            customersOnBoard+=board;\\n            customersWaiting-=board;\\n            rotation++;\\n            \\n            profit = customersOnBoard*boardingCost - rotation*runningCost;\\n            \\n            if(maxProfit < profit){\\n                maxProfit = profit;\\n                roationNoWhenProfitisMax = rotation;\\n            }   \\n        }\\n        \\n        return roationNoWhenProfitisMax;\\n        \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minOperationsMaxProfit(int[] customers, int boardingCost, int runningCost) {\\n        int customersWaiting = 0;\\n        int profit = 0;\\n        int maxProfit = -1;\\n        int roationNoWhenProfitisMax = -1;\\n        int customersOnBoard = 0;\\n        int rotation = 0;\\n        \\n        for(int i=0; i<customers.length; i++){\\n            customersWaiting+=customers[i];\\n            int board= customersWaiting>=4 ? 4: customersWaiting;\\n            customersOnBoard+=board;\\n            customersWaiting-=board;\\n            rotation++;\\n            \\n            profit = customersOnBoard*boardingCost - rotation*runningCost;\\n            \\n            if(maxProfit < profit){\\n                maxProfit = profit;\\n                roationNoWhenProfitisMax = rotation;\\n            }\\n            \\n        }\\n        \\n        while(customersWaiting!=0){\\n            int board= customersWaiting>=4 ? 4: customersWaiting;\\n            customersOnBoard+=board;\\n            customersWaiting-=board;\\n            rotation++;\\n            \\n            profit = customersOnBoard*boardingCost - rotation*runningCost;\\n            \\n            if(maxProfit < profit){\\n                maxProfit = profit;\\n                roationNoWhenProfitisMax = rotation;\\n            }   \\n        }\\n        \\n        return roationNoWhenProfitisMax;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 866623,
                "title": "simple-c-beats-100-few-lines-greedy-solution",
                "content": "result: the final profits\\ntimes: the final return value\\ncurrent: the current profits\\npeople: current number of people waiting\\nnumber: number of new arriving people in current round\\nboardWheel: people boarding the wheel currently\\n```\\nint minOperationsMaxProfit(vector<int>& customers, int boardingCost, int runningCost) \\n{\\n\\tint result=-1,times=-1,current=0,people=0;\\n\\tfor(int i=0;i<customers.size()||people>0;i++)\\n\\t{\\n\\t\\tint number=(i<customers.size())?customers[i]:0;\\n\\t\\tint boardWheel=min(4,number+people);\\n\\t\\tpeople+=number-boardWheel;\\n\\t\\tcurrent+=boardWheel*boardingCost-runningCost;\\n\\t\\tif(current>result)\\n\\t\\t{\\n\\t\\t\\tresult=current;\\n\\t\\t\\ttimes=i+1;\\n\\t\\t}\\n\\t}\\n\\treturn times;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nint minOperationsMaxProfit(vector<int>& customers, int boardingCost, int runningCost) \\n{\\n\\tint result=-1,times=-1,current=0,people=0;\\n\\tfor(int i=0;i<customers.size()||people>0;i++)\\n\\t{\\n\\t\\tint number=(i<customers.size())?customers[i]:0;\\n\\t\\tint boardWheel=min(4,number+people);\\n\\t\\tpeople+=number-boardWheel;\\n\\t\\tcurrent+=boardWheel*boardingCost-runningCost;\\n\\t\\tif(current>result)\\n\\t\\t{\\n\\t\\t\\tresult=current;\\n\\t\\t\\ttimes=i+1;\\n\\t\\t}\\n\\t}\\n\\treturn times;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 866615,
                "title": "need-help-java-solved",
                "content": "```java\\nclass Solution {\\n    public int minOperationsMaxProfit(int[] customers, int boardingCost, int runningCost) {\\n\\n        int sum = 0;\\n        int profit = 0;\\n        int maxProfit = 0;\\n        int run = 0;\\n        int maxRun = 0;\\n        \\n        for(int i=0; i<customers.length; i++) {\\n            sum += customers[i];   // The total customers arrivied when i-th batch customers arrived.\\n            profit = Math.min(sum, 4 * (i+1)) * boardingCost - (i+1) * runningCost;  // After (i+1) rotations, at most 4*(i+1) customers can on board.\\n            run++;  // Wrong here! If there is no customer waiting, it needs no rotation.\\n            \\n            if(profit > maxProfit) {\\n                maxProfit = profit;\\n                maxRun = run;\\n            }\\n        }\\n        sum -= 4 * customers.length;\\n\\n        while(sum >= 4) {\\n            profit += (4 * boardingCost - runningCost);\\n            sum -= 4;\\n            run++;\\n            if(profit > maxProfit) {\\n                maxProfit = profit;\\n                maxRun = run;\\n            }\\n        }\\n        if(sum > 0) {\\n            profit += (sum * boardingCost - runningCost);\\n            run++;\\n            if(profit > maxProfit) {\\n                maxProfit = profit;\\n                maxRun = run;\\n            }\\n        }\\n        return (maxProfit < 0) ? -1 : maxRun;\\n    }\\n}\\n```\\n\\nUnpass Test: \\n```java\\n[0,43,37,9,23,35,18,7,45,3,8,24,1,6,37,2,38,15,1,14,39,27,4,25,27,33,43,8,44,30,38,40,20,5,17,27,43,11,6,2,30,49,30,25,32,3,18,23,45,43,30,14,41,17,42,42,44,38,18,26,32,48,37,5,37,21,2,9,48,48,40,45,25,30,49,41,4,48,40,29,23,17,7,5,44,23,43,9,35,26,44,3,26,16,31,11,9,4,28,49,43,39,9,39,37,7,6,7,16,1,30,2,4,43,23,16,39,5,30,23,39,29,31,26,35,15,5,11,45,44,45,43,4,24,40,7,36,10,10,18,6,20,13,11,20,3,32,49,34,41,13,11,3,13,0,13,44,48,43,23,12,23,2]\\n43\\n54\\n```\\n\\nOutput: 992\\nExpect: 993",
                "solutionTags": [],
                "code": "```java\\nclass Solution {\\n    public int minOperationsMaxProfit(int[] customers, int boardingCost, int runningCost) {\\n\\n        int sum = 0;\\n        int profit = 0;\\n        int maxProfit = 0;\\n        int run = 0;\\n        int maxRun = 0;\\n        \\n        for(int i=0; i<customers.length; i++) {\\n            sum += customers[i];   // The total customers arrivied when i-th batch customers arrived.\\n            profit = Math.min(sum, 4 * (i+1)) * boardingCost - (i+1) * runningCost;  // After (i+1) rotations, at most 4*(i+1) customers can on board.\\n            run++;  // Wrong here! If there is no customer waiting, it needs no rotation.\\n            \\n            if(profit > maxProfit) {\\n                maxProfit = profit;\\n                maxRun = run;\\n            }\\n        }\\n        sum -= 4 * customers.length;\\n\\n        while(sum >= 4) {\\n            profit += (4 * boardingCost - runningCost);\\n            sum -= 4;\\n            run++;\\n            if(profit > maxProfit) {\\n                maxProfit = profit;\\n                maxRun = run;\\n            }\\n        }\\n        if(sum > 0) {\\n            profit += (sum * boardingCost - runningCost);\\n            run++;\\n            if(profit > maxProfit) {\\n                maxProfit = profit;\\n                maxRun = run;\\n            }\\n        }\\n        return (maxProfit < 0) ? -1 : maxRun;\\n    }\\n}\\n```\n```java\\n[0,43,37,9,23,35,18,7,45,3,8,24,1,6,37,2,38,15,1,14,39,27,4,25,27,33,43,8,44,30,38,40,20,5,17,27,43,11,6,2,30,49,30,25,32,3,18,23,45,43,30,14,41,17,42,42,44,38,18,26,32,48,37,5,37,21,2,9,48,48,40,45,25,30,49,41,4,48,40,29,23,17,7,5,44,23,43,9,35,26,44,3,26,16,31,11,9,4,28,49,43,39,9,39,37,7,6,7,16,1,30,2,4,43,23,16,39,5,30,23,39,29,31,26,35,15,5,11,45,44,45,43,4,24,40,7,36,10,10,18,6,20,13,11,20,3,32,49,34,41,13,11,3,13,0,13,44,48,43,23,12,23,2]\\n43\\n54\\n```",
                "codeTag": "Java"
            },
            {
                "id": 866611,
                "title": "some-test-cases-fail-python3",
                "content": "Simple brute force approach, not sure why few test cases are failing, any idea please?\\n\\n\\n\\n\\t\\tboarded = 0\\n        shifts_so_far = 0\\n        max_shifts = -1\\n        max_profit = float(\\'-inf\\')\\n        shifts = 0\\n        waiting = 0\\n        \\n        for c in customers:\\n            waiting = waiting+c\\n            while waiting>=4:\\n                boarded += 4\\n                shifts += 1\\n                profit = boarded*boardingCost - shifts*runningCost\\n                if profit>0 and profit>max_profit:\\n                    max_profit = profit\\n                    max_shifts = shifts\\n\\n                waiting -= 4\\n            else:\\n                continue\\n        \\n        \\n        shifts += 1\\n        boarded += waiting\\n        profit = boarded*boardingCost - shifts*runningCost\\n        if profit>0 and profit>max_profit:\\n            print (shifts)\\n            max_profit = profit\\n            max_shifts = shifts    \\n        waiting = 0\\n                \\n        \\n        return max_shifts",
                "solutionTags": [],
                "code": "Simple brute force approach, not sure why few test cases are failing, any idea please?\\n\\n\\n\\n\\t\\tboarded = 0\\n        shifts_so_far = 0\\n        max_shifts = -1\\n        max_profit = float(\\'-inf\\')\\n        shifts = 0\\n        waiting = 0\\n        \\n        for c in customers:\\n            waiting = waiting+c\\n            while waiting>=4:\\n                boarded += 4\\n                shifts += 1\\n                profit = boarded*boardingCost - shifts*runningCost\\n                if profit>0 and profit>max_profit:\\n                    max_profit = profit\\n                    max_shifts = shifts\\n\\n                waiting -= 4\\n            else:\\n                continue\\n        \\n        \\n        shifts += 1\\n        boarded += waiting\\n        profit = boarded*boardingCost - shifts*runningCost\\n        if profit>0 and profit>max_profit:\\n            print (shifts)\\n            max_profit = profit\\n            max_shifts = shifts    \\n        waiting = 0\\n                \\n        \\n        return max_shifts",
                "codeTag": "Unknown"
            },
            {
                "id": 866610,
                "title": "python-solution",
                "content": "\\tclass Solution:\\n\\t\\tdef minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:        \\n\\t\\t\\tremain = 0\\n\\t\\t\\tboard = 0\\n\\t\\t\\tprofit = -float(\"inf\")\\n\\t\\t\\tcnt = 0\\n\\t\\t\\tres = 0\\n\\t\\t\\twhile board != sum(customers):\\n\\t\\t\\t\\tfor i in customers:\\n\\t\\t\\t\\t\\tremain += i                \\n\\t\\t\\t\\t\\tif remain > 4:\\n\\t\\t\\t\\t\\t\\tboard += 4\\n\\t\\t\\t\\t\\t\\tremain -= 4\\n\\t\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\t\\tboard += remain\\n\\t\\t\\t\\t\\t\\tremain = 0\\n\\t\\t\\t\\t\\tif board * boardingCost - (cnt + 1) * runningCost > profit:\\n\\t\\t\\t\\t\\t\\tprofit = board * boardingCost - (cnt + 1) * runningCost\\n\\t\\t\\t\\t\\t\\tres = cnt + 1\\n\\t\\t\\t\\t\\tcnt += 1\\n\\t\\t\\t\\twhile remain > 0:\\n\\t\\t\\t\\t\\tif remain > 4:\\n\\t\\t\\t\\t\\t\\tboard += 4\\n\\t\\t\\t\\t\\t\\tremain -= 4\\n\\t\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\t\\tboard += remain\\n\\t\\t\\t\\t\\t\\tremain = 0\\n\\t\\t\\t\\t\\tif board * boardingCost - (cnt + 1) * runningCost > profit:\\n\\t\\t\\t\\t\\t\\tprofit = board * boardingCost - (cnt + 1) * runningCost\\n\\t\\t\\t\\t\\t\\tres = cnt + 1\\n\\t\\t\\t\\t\\tcnt += 1\\n\\t\\t\\tif profit > 0:\\n\\t\\t\\t\\treturn res\\n\\t\\t\\telse:\\n\\t\\t\\t\\treturn -1",
                "solutionTags": [],
                "code": "\\tclass Solution:\\n\\t\\tdef minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:        \\n\\t\\t\\tremain = 0\\n\\t\\t\\tboard = 0\\n\\t\\t\\tprofit = -float(\"inf\")\\n\\t\\t\\tcnt = 0\\n\\t\\t\\tres = 0\\n\\t\\t\\twhile board != sum(customers):\\n\\t\\t\\t\\tfor i in customers:\\n\\t\\t\\t\\t\\tremain += i                \\n\\t\\t\\t\\t\\tif remain > 4:\\n\\t\\t\\t\\t\\t\\tboard += 4\\n\\t\\t\\t\\t\\t\\tremain -= 4\\n\\t\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\t\\tboard += remain\\n\\t\\t\\t\\t\\t\\tremain = 0\\n\\t\\t\\t\\t\\tif board * boardingCost - (cnt + 1) * runningCost > profit:\\n\\t\\t\\t\\t\\t\\tprofit = board * boardingCost - (cnt + 1) * runningCost\\n\\t\\t\\t\\t\\t\\tres = cnt + 1\\n\\t\\t\\t\\t\\tcnt += 1\\n\\t\\t\\t\\twhile remain > 0:\\n\\t\\t\\t\\t\\tif remain > 4:\\n\\t\\t\\t\\t\\t\\tboard += 4\\n\\t\\t\\t\\t\\t\\tremain -= 4\\n\\t\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\t\\tboard += remain\\n\\t\\t\\t\\t\\t\\tremain = 0\\n\\t\\t\\t\\t\\tif board * boardingCost - (cnt + 1) * runningCost > profit:\\n\\t\\t\\t\\t\\t\\tprofit = board * boardingCost - (cnt + 1) * runningCost\\n\\t\\t\\t\\t\\t\\tres = cnt + 1\\n\\t\\t\\t\\t\\tcnt += 1\\n\\t\\t\\tif profit > 0:\\n\\t\\t\\t\\treturn res\\n\\t\\t\\telse:\\n\\t\\t\\t\\treturn -1",
                "codeTag": "Java"
            },
            {
                "id": 866598,
                "title": "java-o-n-easy-solution-with-comments",
                "content": "The goal here is to record the best possible(profitable or maximum) cost and rotations  that can be acheived  during the entire process (until all customers are served). The best possible solution is to simulate the rotation and record the profit for each rotation.  \\nUPDATE - A greedy solution also works. well with less code\\n```\\nclass Solution {\\n     int cost = 0; \\n     int times  = 0;\\n      int ans = Integer.MIN_VALUE;\\n    public int minOperationsMaxProfit(int[] customers, int boardingCost, int runningCost) {\\n        int n = customers.length; \\n      \\n        int totalBoarded =0; // curr boarded passengers\\n        int waiting = 0; // waiting queue\\n        int rotate = 0;\\n       \\n        for(int i = 0 ; i < n ; i++){\\n            rotate++; // rotate the wheel for every input irrespective of 0 or more customers;\\n            waiting += customers[i]; // add the customers to waiting queue first\\n            if(waiting > 4){\\n                waiting-= 4;\\n                totalBoarded += 4;\\n            }else{\\n                totalBoarded += waiting;\\n                waiting = 0;\\n            }\\t\\t\\n\\t\\t\\tcalculatecostSofar(totalBoarded,boardingCost,rotate,runningCost);             \\n        }\\n\\t\\t// After servicing all customers , if still there are customers in waiting queue , repeat the same process;\\n         while(waiting > 0){\\n            rotate ++; \\n            if(waiting > 4){\\n                waiting-= 4;\\n                totalBoarded += 4;\\n            }else{\\n                totalBoarded += waiting;\\n                waiting = 0;\\n            }\\n          calculatecostSofar(totalBoarded,boardingCost,rotate,runningCost);    \\n        }\\n\\t\\t//if the answer is less than 0 then the spinner did not get a profit atall so return -1 else return the recorded \\n\\t\\t//optimal times rotated.\\n\\t\\treturn ans < 0 ? -1 : times;\\n    }\\n\\tprivate void calculatecostSofar(int boarded, int boardincost, int rotationsMadeSofar, int runningCost){\\n\\t       //calculate cost ref quest\\n\\t\\t\\tcost = boarded * boardincost - rotationsMadeSofar * runningCost;\\n\\t\\t\\t//Check if the cost is greater than the one recorded so far , if yes update the final answer\\n\\t\\t\\t// Note - the question states that , if during the process at any point i get a positive amount \\n\\t\\t\\t//that is the maximum amount i get, so i need to record that value . \\n\\t\\t\\tif(cost > ans){\\n                ans = cost;\\n                times = rotationsMadeSofar;\\n           }\\n\\t}  \\n}",
                "solutionTags": [],
                "code": "class Solution {\\n     int cost = 0; \\n     int times  = 0;\\n      int ans = Integer.MIN_VALUE;\\n    public int minOperationsMaxProfit(int[] customers, int boardingCost, int runningCost) {\\n        int n = customers.length; \\n      \\n        int totalBoarded =0; // curr boarded passengers\\n        int waiting = 0; // waiting queue\\n        int rotate = 0;\\n       \\n        for(int i = 0 ; i < n ; i++){\\n            rotate++; // rotate the wheel for every input irrespective of 0 or more customers;\\n            waiting += customers[i]; // add the customers to waiting queue first\\n            if(waiting > 4){\\n                waiting-= 4;\\n                totalBoarded += 4;\\n            }",
                "codeTag": "Java"
            }
        ],
        "discussions": []
    },
    {
        "title": "Throne Inheritance",
        "question_content": "<p>A kingdom consists of a king, his children, his grandchildren, and so on. Every once in a while, someone in the family dies or a child is born.</p>\n\n<p>The kingdom has a well-defined order of inheritance that consists of the king as the first member. Let&#39;s define the recursive function <code>Successor(x, curOrder)</code>, which given a person <code>x</code> and the inheritance order so far, returns who should be the next person after <code>x</code> in the order of inheritance.</p>\n\n<pre>\nSuccessor(x, curOrder):\n    if x has no children or all of x&#39;s children are in curOrder:\n        if x is the king return null\n        else return Successor(x&#39;s parent, curOrder)\n    else return x&#39;s oldest child who&#39;s not in curOrder\n</pre>\n\n<p>For example, assume we have a kingdom that consists of the king, his children Alice and Bob (Alice is older than Bob), and finally Alice&#39;s son Jack.</p>\n\n<ol>\n\t<li>In the beginning, <code>curOrder</code> will be <code>[&quot;king&quot;]</code>.</li>\n\t<li>Calling <code>Successor(king, curOrder)</code> will return Alice, so we append to <code>curOrder</code> to get <code>[&quot;king&quot;, &quot;Alice&quot;]</code>.</li>\n\t<li>Calling <code>Successor(Alice, curOrder)</code> will return Jack, so we append to <code>curOrder</code> to get <code>[&quot;king&quot;, &quot;Alice&quot;, &quot;Jack&quot;]</code>.</li>\n\t<li>Calling <code>Successor(Jack, curOrder)</code> will return Bob, so we append to <code>curOrder</code> to get <code>[&quot;king&quot;, &quot;Alice&quot;, &quot;Jack&quot;, &quot;Bob&quot;]</code>.</li>\n\t<li>Calling <code>Successor(Bob, curOrder)</code> will return <code>null</code>. Thus the order of inheritance will be <code>[&quot;king&quot;, &quot;Alice&quot;, &quot;Jack&quot;, &quot;Bob&quot;]</code>.</li>\n</ol>\n\n<p>Using the above function, we can always obtain a unique order of inheritance.</p>\n\n<p>Implement the <code>ThroneInheritance</code> class:</p>\n\n<ul>\n\t<li><code>ThroneInheritance(string kingName)</code> Initializes an object of the <code>ThroneInheritance</code> class. The name of the king is given as part of the constructor.</li>\n\t<li><code>void birth(string parentName, string childName)</code> Indicates that <code>parentName</code> gave birth to <code>childName</code>.</li>\n\t<li><code>void death(string name)</code> Indicates the death of <code>name</code>. The death of the person doesn&#39;t affect the <code>Successor</code> function nor the current inheritance order. You can treat it as just marking the person as dead.</li>\n\t<li><code>string[] getInheritanceOrder()</code> Returns a list representing the current order of inheritance <strong>excluding</strong> dead people.</li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input</strong>\n[&quot;ThroneInheritance&quot;, &quot;birth&quot;, &quot;birth&quot;, &quot;birth&quot;, &quot;birth&quot;, &quot;birth&quot;, &quot;birth&quot;, &quot;getInheritanceOrder&quot;, &quot;death&quot;, &quot;getInheritanceOrder&quot;]\n[[&quot;king&quot;], [&quot;king&quot;, &quot;andy&quot;], [&quot;king&quot;, &quot;bob&quot;], [&quot;king&quot;, &quot;catherine&quot;], [&quot;andy&quot;, &quot;matthew&quot;], [&quot;bob&quot;, &quot;alex&quot;], [&quot;bob&quot;, &quot;asha&quot;], [null], [&quot;bob&quot;], [null]]\n<strong>Output</strong>\n[null, null, null, null, null, null, null, [&quot;king&quot;, &quot;andy&quot;, &quot;matthew&quot;, &quot;bob&quot;, &quot;alex&quot;, &quot;asha&quot;, &quot;catherine&quot;], null, [&quot;king&quot;, &quot;andy&quot;, &quot;matthew&quot;, &quot;alex&quot;, &quot;asha&quot;, &quot;catherine&quot;]]\n\n<strong>Explanation</strong>\nThroneInheritance t= new ThroneInheritance(&quot;king&quot;); // order: <strong>king</strong>\nt.birth(&quot;king&quot;, &quot;andy&quot;); // order: king &gt; <strong>andy</strong>\nt.birth(&quot;king&quot;, &quot;bob&quot;); // order: king &gt; andy &gt; <strong>bob</strong>\nt.birth(&quot;king&quot;, &quot;catherine&quot;); // order: king &gt; andy &gt; bob &gt; <strong>catherine</strong>\nt.birth(&quot;andy&quot;, &quot;matthew&quot;); // order: king &gt; andy &gt; <strong>matthew</strong> &gt; bob &gt; catherine\nt.birth(&quot;bob&quot;, &quot;alex&quot;); // order: king &gt; andy &gt; matthew &gt; bob &gt; <strong>alex</strong> &gt; catherine\nt.birth(&quot;bob&quot;, &quot;asha&quot;); // order: king &gt; andy &gt; matthew &gt; bob &gt; alex &gt; <strong>asha</strong> &gt; catherine\nt.getInheritanceOrder(); // return [&quot;king&quot;, &quot;andy&quot;, &quot;matthew&quot;, &quot;bob&quot;, &quot;alex&quot;, &quot;asha&quot;, &quot;catherine&quot;]\nt.death(&quot;bob&quot;); // order: king &gt; andy &gt; matthew &gt; <strong><s>bob</s></strong> &gt; alex &gt; asha &gt; catherine\nt.getInheritanceOrder(); // return [&quot;king&quot;, &quot;andy&quot;, &quot;matthew&quot;, &quot;alex&quot;, &quot;asha&quot;, &quot;catherine&quot;]\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= kingName.length, parentName.length, childName.length, name.length &lt;= 15</code></li>\n\t<li><code>kingName</code>, <code>parentName</code>, <code>childName</code>, and <code>name</code> consist of lowercase English letters only.</li>\n\t<li>All arguments <code>childName</code> and <code>kingName</code> are <strong>distinct</strong>.</li>\n\t<li>All <code>name</code> arguments of <code>death</code> will be passed to either the constructor or as <code>childName</code> to <code>birth</code> first.</li>\n\t<li>For each call to&nbsp;<code>birth(parentName, childName)</code>, it is guaranteed that&nbsp;<code>parentName</code> is alive.</li>\n\t<li>At most <code>10<sup>5</sup></code> calls will be made to <code>birth</code> and <code>death</code>.</li>\n\t<li>At most <code>10</code> calls will be made to <code>getInheritanceOrder</code>.</li>\n</ul>\n",
        "solutions": [
            {
                "id": 866400,
                "title": "textbook-dfs-problem-with-convoluted-wording",
                "content": "```\\nclass ThroneInheritance {\\n    unordered_map<string, bool> dead;   // Just to keep track of alive people\\n    unordered_map<string, vector<string>> family;  \\n    string root;\\npublic:\\n    ThroneInheritance(string kingName) {\\n        root = kingName;\\n    }\\n    \\n    void birth(string parentName, string childName) {\\n        family[parentName].push_back(childName);    // Appending at the end takes care of oldest to yongest \\n    }\\n    \\n    void death(string name) {\\n        dead[name] = true;\\n    }\\n    \\n    void dfs(vector<string> &ans, string root) {\\n        if (!dead[root]) {           // Just check if dead before inserting into the order.\\n            ans.push_back(root);\\n        }\\n        for (string child: family[root]) {\\n            dfs(ans, child);\\n        }\\n    }\\n    \\n    vector<string> getInheritanceOrder() {\\n        vector<string> ans;\\n        dfs(ans, root);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass ThroneInheritance {\\n    unordered_map<string, bool> dead;   // Just to keep track of alive people\\n    unordered_map<string, vector<string>> family;  \\n    string root;\\npublic:\\n    ThroneInheritance(string kingName) {\\n        root = kingName;\\n    }\\n    \\n    void birth(string parentName, string childName) {\\n        family[parentName].push_back(childName);    // Appending at the end takes care of oldest to yongest \\n    }\\n    \\n    void death(string name) {\\n        dead[name] = true;\\n    }\\n    \\n    void dfs(vector<string> &ans, string root) {\\n        if (!dead[root]) {           // Just check if dead before inserting into the order.\\n            ans.push_back(root);\\n        }\\n        for (string child: family[root]) {\\n            dfs(ans, child);\\n        }\\n    }\\n    \\n    vector<string> getInheritanceOrder() {\\n        vector<string> ans;\\n        dfs(ans, root);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 866653,
                "title": "python3-go-concise-dfs",
                "content": "`Python 3`\\n```python\\nclass ThroneInheritance:\\n\\n    def __init__(self, kingName: str):\\n        self.nation = defaultdict(list)\\n        self.king = kingName\\n        self.dead = set()\\n\\n    def birth(self, parentName: str, childName: str) -> None:\\n        self.nation[parentName].append(childName)\\n\\n    def death(self, name: str) -> None:\\n        self.dead.add(name)\\n\\n    def getInheritanceOrder(self) -> List[str]:\\n        self.ans = []\\n        self.dfs(self.king)\\n        return self.ans\\n    \\n    def dfs(self, cur):\\n        if cur not in self.dead:\\n            self.ans.append(cur)\\n        for child in self.nation[cur]:\\n            self.dfs(child)\\n```\\n\\n`Golang`\\n```go\\ntype ThroneInheritance struct {\\n    nation map[string][]string\\n    dead map[string]bool\\n    king string\\n}\\n\\n\\nfunc Constructor(kingName string) ThroneInheritance {\\n    instance := ThroneInheritance{\\n        nation: make(map[string][]string),\\n        dead: make(map[string]bool),\\n        king: kingName,\\n    }\\n    return instance\\n}\\n\\n\\nfunc (this *ThroneInheritance) Birth(parentName string, childName string)  {\\n    this.nation[parentName] = append(this.nation[parentName], childName)\\n}\\n\\n\\nfunc (this *ThroneInheritance) Death(name string)  {\\n    this.dead[name] = true\\n}\\n\\n\\nfunc (this *ThroneInheritance) GetInheritanceOrder() []string {\\n    ans := []string{}\\n    this.dfs(this.king, &ans)\\n    return ans\\n}\\n\\nfunc (this *ThroneInheritance) dfs(cur string, ans *[]string) {\\n    if _, existed := this.dead[cur]; !existed {\\n        *ans = append(*ans, cur)\\n    }\\n    for _, child := range this.nation[cur] {\\n        this.dfs(child, ans)\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```python\\nclass ThroneInheritance:\\n\\n    def __init__(self, kingName: str):\\n        self.nation = defaultdict(list)\\n        self.king = kingName\\n        self.dead = set()\\n\\n    def birth(self, parentName: str, childName: str) -> None:\\n        self.nation[parentName].append(childName)\\n\\n    def death(self, name: str) -> None:\\n        self.dead.add(name)\\n\\n    def getInheritanceOrder(self) -> List[str]:\\n        self.ans = []\\n        self.dfs(self.king)\\n        return self.ans\\n    \\n    def dfs(self, cur):\\n        if cur not in self.dead:\\n            self.ans.append(cur)\\n        for child in self.nation[cur]:\\n            self.dfs(child)\\n```\n```go\\ntype ThroneInheritance struct {\\n    nation map[string][]string\\n    dead map[string]bool\\n    king string\\n}\\n\\n\\nfunc Constructor(kingName string) ThroneInheritance {\\n    instance := ThroneInheritance{\\n        nation: make(map[string][]string),\\n        dead: make(map[string]bool),\\n        king: kingName,\\n    }\\n    return instance\\n}\\n\\n\\nfunc (this *ThroneInheritance) Birth(parentName string, childName string)  {\\n    this.nation[parentName] = append(this.nation[parentName], childName)\\n}\\n\\n\\nfunc (this *ThroneInheritance) Death(name string)  {\\n    this.dead[name] = true\\n}\\n\\n\\nfunc (this *ThroneInheritance) GetInheritanceOrder() []string {\\n    ans := []string{}\\n    this.dfs(this.king, &ans)\\n    return ans\\n}\\n\\nfunc (this *ThroneInheritance) dfs(cur string, ans *[]string) {\\n    if _, existed := this.dead[cur]; !existed {\\n        *ans = append(*ans, cur)\\n    }\\n    for _, child := range this.nation[cur] {\\n        this.dfs(child, ans)\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 866464,
                "title": "java-hashmap-and-nested-children",
                "content": "The Successor API is just to show the logic of inheritance, don\\'t be fooled by this.\\nOr to use [HashSet](https://leetcode.com/problems/throne-inheritance/discuss/866464/Java-HashMap-and-Nested-children/711773) to mark Death.\\n```\\nclass ThroneInheritance {\\n    String kingName;\\n    Map<String, List<String>> map = new HashMap<>();  // for cache children;\\n    Map<String, Boolean> alive = new HashMap<>();\\n    public ThroneInheritance(String kingName) {\\n        this.kingName = kingName;\\n    }\\n    \\n    public void birth(String pn, String cn) {\\n        map.computeIfAbsent(pn, k -> new ArrayList<>());\\n        map.get(pn).add(cn);\\n    }\\n    \\n    public void death(String name) {\\n        alive.put(name, false);\\n    }\\n    \\n    public List<String> getInheritanceOrder() {\\n        List<String> list = getList(kingName);  //all list with alive and died\\n        List<String> res = new ArrayList<>();\\n        for (String s : list)\\n            if (alive.getOrDefault(s, true)) res.add(s);  // remove died\\n        return res;\\n    }\\n    \\n    private List<String> getList(String p) {   // recursion to get children and build the inheritance list;\\n        List<String> res = new ArrayList<>();\\n        res.add(p);\\n        List<String> cs = map.getOrDefault(p, new ArrayList<>());\\n        for (String c : cs) {\\n            List<String> tmp = getList(c);\\n            for (String cc : tmp) res.add(cc);\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass ThroneInheritance {\\n    String kingName;\\n    Map<String, List<String>> map = new HashMap<>();  // for cache children;\\n    Map<String, Boolean> alive = new HashMap<>();\\n    public ThroneInheritance(String kingName) {\\n        this.kingName = kingName;\\n    }\\n    \\n    public void birth(String pn, String cn) {\\n        map.computeIfAbsent(pn, k -> new ArrayList<>());\\n        map.get(pn).add(cn);\\n    }\\n    \\n    public void death(String name) {\\n        alive.put(name, false);\\n    }\\n    \\n    public List<String> getInheritanceOrder() {\\n        List<String> list = getList(kingName);  //all list with alive and died\\n        List<String> res = new ArrayList<>();\\n        for (String s : list)\\n            if (alive.getOrDefault(s, true)) res.add(s);  // remove died\\n        return res;\\n    }\\n    \\n    private List<String> getList(String p) {   // recursion to get children and build the inheritance list;\\n        List<String> res = new ArrayList<>();\\n        res.add(p);\\n        List<String> cs = map.getOrDefault(p, new ArrayList<>());\\n        for (String c : cs) {\\n            List<String> tmp = getList(c);\\n            for (String cc : tmp) res.add(cc);\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 868470,
                "title": "hashmap-inheritance-tree",
                "content": "We can use a hash map to track a person\\'s name (and their \\'dead\\' status) and a list of their children. This is basically a tree, and when traversed pre-order, it gives us the order we need.\\n\\n```cpp\\nunordered_map<string, pair<bool, vector<string>>> m;\\nstring king;\\nThroneInheritance(string king) : king(king) {}\\nvoid birth(string parent, string child) { m[parent].second.push_back(child); }\\nvoid death(string name) { m[name].first = true; }\\nvoid traverse(string &name, vector<string> &res) {\\n    if (!m[name].first)\\n        res.push_back(name);\\n    for (auto child : m[name].second)\\n        traverse(child, res);\\n}\\nvector<string> getInheritanceOrder() {\\n    vector<string> res;\\n    traverse(king, res);\\n    return res;\\n}\\n```",
                "solutionTags": [],
                "code": "```cpp\\nunordered_map<string, pair<bool, vector<string>>> m;\\nstring king;\\nThroneInheritance(string king) : king(king) {}\\nvoid birth(string parent, string child) { m[parent].second.push_back(child); }\\nvoid death(string name) { m[name].first = true; }\\nvoid traverse(string &name, vector<string> &res) {\\n    if (!m[name].first)\\n        res.push_back(name);\\n    for (auto child : m[name].second)\\n        traverse(child, res);\\n}\\nvector<string> getInheritanceOrder() {\\n    vector<string> res;\\n    traverse(king, res);\\n    return res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 873221,
                "title": "c-solution-easy-dfs-good-variable-names",
                "content": "Don\\'t mind, variable names is for fun. People who know Hindi can understand them.\\n```\\nclass ThroneInheritance {\\npublic:\\n    unordered_map<string,vector<string>> bche;\\n    unordered_map<string,bool> dead;\\n    string king;\\n    ThroneInheritance(string kingName) {\\n        king=kingName;\\n    }\\n    void birth(string parentName, string childName) {\\n        bche[parentName].push_back(childName);\\n    }\\n    void death(string name) {\\n        dead[name]=1;\\n    }\\n    void dfs(vector<string>& ans,string papa){\\n        if(!dead[papa]) ans.push_back(papa);\\n        for(auto bcha:bche[papa]){\\n            dfs(ans,bcha);\\n        }\\n    }\\n    vector<string> getInheritanceOrder() {\\n        vector<string> ans;\\n        dfs(ans,king);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass ThroneInheritance {\\npublic:\\n    unordered_map<string,vector<string>> bche;\\n    unordered_map<string,bool> dead;\\n    string king;\\n    ThroneInheritance(string kingName) {\\n        king=kingName;\\n    }\\n    void birth(string parentName, string childName) {\\n        bche[parentName].push_back(childName);\\n    }\\n    void death(string name) {\\n        dead[name]=1;\\n    }\\n    void dfs(vector<string>& ans,string papa){\\n        if(!dead[papa]) ans.push_back(papa);\\n        for(auto bcha:bche[papa]){\\n            dfs(ans,bcha);\\n        }\\n    }\\n    vector<string> getInheritanceOrder() {\\n        vector<string> ans;\\n        dfs(ans,king);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 866472,
                "title": "java-python-3-dfs-w-brief-description-and-analysis",
                "content": "1. Use a `HashMap/defaultdict` to build familiy tree;\\n2. Use a `Set` to store the member(s) passed away to avoid the dead being on inheritance list;\\n3. Use DFS to get the inheritance order.\\n\\n```java\\n    private Map<String, List<String>> familyTree = new HashMap<>();\\n    private Set<String> dead = new HashSet<>();\\n    private String king;\\n\\n    public ThroneInheritance(String kingName) {\\n        king = kingName;\\n    }\\n    \\n    public void birth(String parentName, String childName) {\\n        familyTree.computeIfAbsent(parentName, l -> new ArrayList<>()).add(childName);\\n    }\\n    \\n    public void death(String name) {\\n        dead.add(name);\\n    }\\n    \\n    public List<String> getInheritanceOrder() {\\n        List<String> inheritanceOrder = new ArrayList<>();\\n        dfs(king, familyTree, dead, inheritanceOrder);\\n        return inheritanceOrder;\\n    }\\n    private void dfs(String p, Map<String, List<String>> familyTree, Set<String> dead, List<String> inheritanceOrder) {\\n        if (!dead.contains(p)) {\\n            inheritanceOrder.add(p);\\n        }\\n        for (String kid : familyTree.getOrDefault(p, Collections.emptyList())) {\\n            dfs(kid, familyTree, dead, inheritanceOrder);\\n        }\\n    }\\n```\\n```python\\n    def __init__(self, kingName: str):\\n        self.family_tree = collections.defaultdict(list)\\n        self.king = kingName\\n        self.dead = set()\\n\\n    def birth(self, parentName: str, childName: str) -> None:\\n        self.family_tree[parentName].append(childName)\\n\\n    def death(self, name: str) -> None:\\n        self.dead.add(name)\\n\\n    def getInheritanceOrder(self) -> List[str]:\\n        \\n        def dfs(name: str) -> None:\\n            if name not in self.dead:\\n                inheritance_order.append(name)\\n            for kid in self.family_tree[name]:\\n                dfs(kid)\\n\\n        inheritance_order = []\\n        dfs(self.king)\\n        return inheritance_order\\n```\\n**Analysis:**\\n\\nTime & space: O(n), where n is the total number of the family members.",
                "solutionTags": [],
                "code": "```java\\n    private Map<String, List<String>> familyTree = new HashMap<>();\\n    private Set<String> dead = new HashSet<>();\\n    private String king;\\n\\n    public ThroneInheritance(String kingName) {\\n        king = kingName;\\n    }\\n    \\n    public void birth(String parentName, String childName) {\\n        familyTree.computeIfAbsent(parentName, l -> new ArrayList<>()).add(childName);\\n    }\\n    \\n    public void death(String name) {\\n        dead.add(name);\\n    }\\n    \\n    public List<String> getInheritanceOrder() {\\n        List<String> inheritanceOrder = new ArrayList<>();\\n        dfs(king, familyTree, dead, inheritanceOrder);\\n        return inheritanceOrder;\\n    }\\n    private void dfs(String p, Map<String, List<String>> familyTree, Set<String> dead, List<String> inheritanceOrder) {\\n        if (!dead.contains(p)) {\\n            inheritanceOrder.add(p);\\n        }\\n        for (String kid : familyTree.getOrDefault(p, Collections.emptyList())) {\\n            dfs(kid, familyTree, dead, inheritanceOrder);\\n        }\\n    }\\n```\n```python\\n    def __init__(self, kingName: str):\\n        self.family_tree = collections.defaultdict(list)\\n        self.king = kingName\\n        self.dead = set()\\n\\n    def birth(self, parentName: str, childName: str) -> None:\\n        self.family_tree[parentName].append(childName)\\n\\n    def death(self, name: str) -> None:\\n        self.dead.add(name)\\n\\n    def getInheritanceOrder(self) -> List[str]:\\n        \\n        def dfs(name: str) -> None:\\n            if name not in self.dead:\\n                inheritance_order.append(name)\\n            for kid in self.family_tree[name]:\\n                dfs(kid)\\n\\n        inheritance_order = []\\n        dfs(self.king)\\n        return inheritance_order\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 866362,
                "title": "python-n-ary-family-tree-annotated",
                "content": "A N-ary tree is a good fit for this problem because we are representing a family tree where each parent may have 0, 1, ..., N children.  \\n\\nWhat makes this N-ary tree special is that the children are stored in a list, because the order they were born matters.  \\n\\nThus **the order of inheritance** (our answer) **is simply a pre-order traversal** (visit root, then first child, then second child, ..., then last child) **of the N-ary tree**.  \\n\\nHope this helps!\\n\\n```python\\nclass Node(object):\\n    def __init__(self, name):\\n        self.name = name\\n        self.children = [] # Use a list to store children, because birth order matters\\n\\nclass Nary_Tree(object):\\n    def __init__(self, kingName):\\n        self.root = Node(kingName)\\n        self.family_tree = {kingName : self.root} # Use a hash-map for O(1) lookup: name -> node\\n        self.dead = set()                         # Keep a set of all people who have died\\n    \\n    def birth(self, parent_name, child_name):\\n        parent_node = self.family_tree[parent_name] # Go to the parent node\\n        child_node = Node(child_name)               # Create a child node\\n        parent_node.children.append(child_node)     # Add child to parent\\'s list of children\\n        self.family_tree[child_name] = child_node   # Add child to hash-map for O(1) lookup by child\\'s name (in case the child gives birth later)\\n    \\n    def inheritance_order(self):\\n\\t\\t\\'\\'\\'Pre-order Traversal of the Nary-Tree and return names\\n\\t\\tin the order they are visited (if they are not dead)\\'\\'\\'\\n        order = []\\n        def helper(node):\\n            nonlocal order\\n            if node.name not in self.dead:\\n                order.append(node.name)\\n            for i,child in enumerate(node.children):\\n                helper(node.children[i])\\n        helper(self.root)\\n        return order\\n\\nclass ThroneInheritance:\\n\\n    def __init__(self, kingName: str):\\n        self.tree = Nary_Tree(kingName)\\n\\n    def birth(self, parentName: str, childName: str) -> None:\\n        self.tree.birth(parentName, childName)\\n\\n    def death(self, name: str) -> None:\\n        self.tree.dead.add(name)\\n\\n    def getInheritanceOrder(self) -> List[str]:\\n        return self.tree.inheritance_order()\\n```",
                "solutionTags": [],
                "code": "```python\\nclass Node(object):\\n    def __init__(self, name):\\n        self.name = name\\n        self.children = [] # Use a list to store children, because birth order matters\\n\\nclass Nary_Tree(object):\\n    def __init__(self, kingName):\\n        self.root = Node(kingName)\\n        self.family_tree = {kingName : self.root} # Use a hash-map for O(1) lookup: name -> node\\n        self.dead = set()                         # Keep a set of all people who have died\\n    \\n    def birth(self, parent_name, child_name):\\n        parent_node = self.family_tree[parent_name] # Go to the parent node\\n        child_node = Node(child_name)               # Create a child node\\n        parent_node.children.append(child_node)     # Add child to parent\\'s list of children\\n        self.family_tree[child_name] = child_node   # Add child to hash-map for O(1) lookup by child\\'s name (in case the child gives birth later)\\n    \\n    def inheritance_order(self):\\n\\t\\t\\'\\'\\'Pre-order Traversal of the Nary-Tree and return names\\n\\t\\tin the order they are visited (if they are not dead)\\'\\'\\'\\n        order = []\\n        def helper(node):\\n            nonlocal order\\n            if node.name not in self.dead:\\n                order.append(node.name)\\n            for i,child in enumerate(node.children):\\n                helper(node.children[i])\\n        helper(self.root)\\n        return order\\n\\nclass ThroneInheritance:\\n\\n    def __init__(self, kingName: str):\\n        self.tree = Nary_Tree(kingName)\\n\\n    def birth(self, parentName: str, childName: str) -> None:\\n        self.tree.birth(parentName, childName)\\n\\n    def death(self, name: str) -> None:\\n        self.tree.dead.add(name)\\n\\n    def getInheritanceOrder(self) -> List[str]:\\n        return self.tree.inheritance_order()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1337943,
                "title": "c-super-simple-solution-very-short-functions",
                "content": "```\\nclass ThroneInheritance {\\npublic:\\n    ThroneInheritance(string kingName) {\\n        curr_king = kingName;\\n    }\\n    \\n    void birth(string parentName, string childName) {\\n        children[parentName].push_back(childName);\\n    }\\n    \\n    void death(string name) {\\n        dead.insert(name);\\n    }\\n    \\n    void rec(string parent) {\\n        if (!dead.count(parent)) inheritance.push_back(parent);\\n        for (auto child : children[parent])\\n            rec(child);\\n    }\\n    \\n    vector<string> getInheritanceOrder() {\\n        inheritance = {};\\n        rec(curr_king);\\n        return inheritance;\\n    }\\n    \\nprivate:\\n    unordered_map<string, vector<string>> children;\\n    vector<string> inheritance;\\n    unordered_set<string> dead;\\n    string curr_king;\\n};\\n```\\n**Like it? please upvote!**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass ThroneInheritance {\\npublic:\\n    ThroneInheritance(string kingName) {\\n        curr_king = kingName;\\n    }\\n    \\n    void birth(string parentName, string childName) {\\n        children[parentName].push_back(childName);\\n    }\\n    \\n    void death(string name) {\\n        dead.insert(name);\\n    }\\n    \\n    void rec(string parent) {\\n        if (!dead.count(parent)) inheritance.push_back(parent);\\n        for (auto child : children[parent])\\n            rec(child);\\n    }\\n    \\n    vector<string> getInheritanceOrder() {\\n        inheritance = {};\\n        rec(curr_king);\\n        return inheritance;\\n    }\\n    \\nprivate:\\n    unordered_map<string, vector<string>> children;\\n    vector<string> inheritance;\\n    unordered_set<string> dead;\\n    string curr_king;\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 877922,
                "title": "java-solution-n-ary",
                "content": "```\\nclass Tree{\\n    List<Tree>child;\\n    String name;\\n    public Tree(String name,List<Tree>child){\\n        this.name=name;\\n        this.child=child;\\n    }\\n}\\nclass ThroneInheritance {\\n    private Set<String>death;\\n    private Tree tree;\\n    private Map<String,Tree>addtoTree;\\n    public ThroneInheritance(String kingName) {\\n      death=new HashSet<>();  \\n      tree=new Tree(kingName,new ArrayList());\\n      addtoTree=new HashMap();\\n      addtoTree.put(kingName,tree);   \\n    }\\n    \\n    public void birth(String parentName, String childName) {\\n           Tree tmp =addtoTree.get(parentName);\\n           Tree childtree=new Tree(childName,new ArrayList());\\n           tmp.child.add(childtree);\\n            addtoTree.put( childName,childtree); \\n    }\\n    \\n    public void death(String name) {\\n        death.add(name);\\n    }\\n    \\n    public List<String> getInheritanceOrder() {\\n        List<String>ans=new ArrayList<>();\\n        preOreder(tree,ans,death);\\n        return ans;\\n    }\\n    \\n    void preOreder(Tree n,List<String>ans,Set<String>death){\\n        if(n==null)return;\\n        if(!death.contains(n.name))ans.add(n.name);\\n         for(Tree name:n.child){\\n            preOreder(name,ans,death);\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Tree{\\n    List<Tree>child;\\n    String name;\\n    public Tree(String name,List<Tree>child){\\n        this.name=name;\\n        this.child=child;\\n    }\\n}\\nclass ThroneInheritance {\\n    private Set<String>death;\\n    private Tree tree;\\n    private Map<String,Tree>addtoTree;\\n    public ThroneInheritance(String kingName) {\\n      death=new HashSet<>();  \\n      tree=new Tree(kingName,new ArrayList());\\n      addtoTree=new HashMap();\\n      addtoTree.put(kingName,tree);   \\n    }\\n    \\n    public void birth(String parentName, String childName) {\\n           Tree tmp =addtoTree.get(parentName);\\n           Tree childtree=new Tree(childName,new ArrayList());\\n           tmp.child.add(childtree);\\n            addtoTree.put( childName,childtree); \\n    }\\n    \\n    public void death(String name) {\\n        death.add(name);\\n    }\\n    \\n    public List<String> getInheritanceOrder() {\\n        List<String>ans=new ArrayList<>();\\n        preOreder(tree,ans,death);\\n        return ans;\\n    }\\n    \\n    void preOreder(Tree n,List<String>ans,Set<String>death){\\n        if(n==null)return;\\n        if(!death.contains(n.name))ans.add(n.name);\\n         for(Tree name:n.child){\\n            preOreder(name,ans,death);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3557544,
                "title": "java-simple-100-solution",
                "content": "```java\\nclass ThroneInheritance {\\n    private Person king;\\n    private final Map<String, Person> persons;\\n\\n    public ThroneInheritance(final String kingName) {\\n        this.king = new Person(kingName);\\n\\n        this.persons = new HashMap<>();\\n\\n        this.persons.put(kingName, this.king);\\n    }\\n    \\n    public void birth(final String parentName, final String childName) {\\n        final Person child = new Person(childName);\\n\\n        this.persons.get(parentName).children().add(child);\\n        this.persons.put(childName, child);\\n    }\\n    \\n    public void death(final String name) {\\n        this.persons.get(name).isAlive(false);\\n    }\\n    \\n    public List<String> getInheritanceOrder() {\\n        List<String> result = new ArrayList<>();\\n\\n        this.dfs(this.king, result);\\n\\n        return result;\\n    }\\n\\n    private void dfs(Person king, List<String> result) {\\n        if(king != null) {\\n            if(king.isAlive())\\n                result.add(king.name());\\n\\n            for(Person child : king.children())\\n                dfs(child, result);\\n        }\\n    }\\n\\n    private final class Person {\\n        private final String name;\\n        private final List<Person> children;\\n        private boolean isAlive;\\n\\n        public Person(final String name) {\\n            this.name = name;\\n            this.children = new ArrayList<>();\\n            this.isAlive = true;\\n        }\\n\\n        public String name() {\\n            return this.name;\\n        }\\n\\n        public List<Person> children() {\\n            return this.children;\\n        }\\n\\n        public boolean isAlive() {\\n            return this.isAlive;\\n        }\\n\\n        public void isAlive(final boolean isAlive) {\\n            this.isAlive = isAlive;\\n        }\\n    }\\n}\\n\\n/**\\n * Your ThroneInheritance object will be instantiated and called as such:\\n * ThroneInheritance obj = new ThroneInheritance(kingName);\\n * obj.birth(parentName,childName);\\n * obj.death(name);\\n * List<String> param_3 = obj.getInheritanceOrder();\\n */\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```java\\nclass ThroneInheritance {\\n    private Person king;\\n    private final Map<String, Person> persons;\\n\\n    public ThroneInheritance(final String kingName) {\\n        this.king = new Person(kingName);\\n\\n        this.persons = new HashMap<>();\\n\\n        this.persons.put(kingName, this.king);\\n    }\\n    \\n    public void birth(final String parentName, final String childName) {\\n        final Person child = new Person(childName);\\n\\n        this.persons.get(parentName).children().add(child);\\n        this.persons.put(childName, child);\\n    }\\n    \\n    public void death(final String name) {\\n        this.persons.get(name).isAlive(false);\\n    }\\n    \\n    public List<String> getInheritanceOrder() {\\n        List<String> result = new ArrayList<>();\\n\\n        this.dfs(this.king, result);\\n\\n        return result;\\n    }\\n\\n    private void dfs(Person king, List<String> result) {\\n        if(king != null) {\\n            if(king.isAlive())\\n                result.add(king.name());\\n\\n            for(Person child : king.children())\\n                dfs(child, result);\\n        }\\n    }\\n\\n    private final class Person {\\n        private final String name;\\n        private final List<Person> children;\\n        private boolean isAlive;\\n\\n        public Person(final String name) {\\n            this.name = name;\\n            this.children = new ArrayList<>();\\n            this.isAlive = true;\\n        }\\n\\n        public String name() {\\n            return this.name;\\n        }\\n\\n        public List<Person> children() {\\n            return this.children;\\n        }\\n\\n        public boolean isAlive() {\\n            return this.isAlive;\\n        }\\n\\n        public void isAlive(final boolean isAlive) {\\n            this.isAlive = isAlive;\\n        }\\n    }\\n}\\n\\n/**\\n * Your ThroneInheritance object will be instantiated and called as such:\\n * ThroneInheritance obj = new ThroneInheritance(kingName);\\n * obj.birth(parentName,childName);\\n * obj.death(name);\\n * List<String> param_3 = obj.getInheritanceOrder();\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3190486,
                "title": "c-solution-dfs-with-map",
                "content": "```\\nclass ThroneInheritance {\\npublic:\\n    unordered_map<string, vector<string>> map;\\n    unordered_set<string> dead;\\n    string nameOfKing;\\n    \\n    ThroneInheritance(string kingName) {\\n        nameOfKing= kingName;\\n    }\\n    \\n    void birth(string par, string child) {\\n        map[par].push_back(child);\\n    }\\n    \\n    void death(string name) {\\n        dead.insert(name);\\n    }\\n    \\n    \\n    void helper(string par, vector<string> &ans){\\n        if(dead.count(par)==0) ans.push_back(par);\\n        for(auto child:map[par]) helper(child, ans);\\n    }\\n    \\n    vector<string> getInheritanceOrder() {\\n        vector<string> ans;\\n        helper(nameOfKing, ans);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass ThroneInheritance {\\npublic:\\n    unordered_map<string, vector<string>> map;\\n    unordered_set<string> dead;\\n    string nameOfKing;\\n    \\n    ThroneInheritance(string kingName) {\\n        nameOfKing= kingName;\\n    }\\n    \\n    void birth(string par, string child) {\\n        map[par].push_back(child);\\n    }\\n    \\n    void death(string name) {\\n        dead.insert(name);\\n    }\\n    \\n    \\n    void helper(string par, vector<string> &ans){\\n        if(dead.count(par)==0) ans.push_back(par);\\n        for(auto child:map[par]) helper(child, ans);\\n    }\\n    \\n    vector<string> getInheritanceOrder() {\\n        vector<string> ans;\\n        helper(nameOfKing, ans);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2658980,
                "title": "hashmap-n-ary-tree-solution-c-solution-with-comments-beats-90-online-submissions",
                "content": "```\\nclass ThroneInheritance {\\nprivate:\\n    struct Tree{//Structure of N-ary Tree\\n        string name;//Storing names\\n        vector<Tree*> childrens;//storing childrens\\n    };\\npublic:\\n    Tree* root;\\n    unordered_map<string,Tree*> mp;//HashMap to mark dead peoples\\n    ThroneInheritance(string kingName) {\\n        root=new Tree();\\n        root->name=kingName;\\n        mp[kingName]=root;\\n    }\\n    \\n    void birth(string parentName, string childName) {\\n        Tree* child=new Tree();\\n        child->name=childName;\\n        mp[parentName]->childrens.push_back(child);//Making Link from parent to newborn child\\n        mp[childName]=child;\\n    }\\n    \\n    void death(string name) {\\n        mp[name]=NULL;//Marking Dead peoples\\n    }\\n    void dfs(Tree* root,vector<string>& ans){//DFS call to get the inheritance order\\n        if(mp[root->name]!=NULL)    ans.push_back(root->name);//Checking if current people is dead, if dead then not including that person in our inheritance order\\n        for(int i=0;i<root->childrens.size();i++){//Childrens will be present in inheritance order doesn\\'t matter if their parent is dead or alive\\n            dfs(root->childrens[i],ans);\\n        }\\n        return;\\n    }\\n    vector<string> getInheritanceOrder() {\\n        vector<string> ans;\\n        dfs(root,ans);\\n        return ans;\\n    }\\n};\\n\\n/**\\n * Your ThroneInheritance object will be instantiated and called as such:\\n * ThroneInheritance* obj = new ThroneInheritance(kingName);\\n * obj->birth(parentName,childName);\\n * obj->death(name);\\n * vector<string> param_3 = obj->getInheritanceOrder();\\n */\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Tree"
                ],
                "code": "```\\nclass ThroneInheritance {\\nprivate:\\n    struct Tree{//Structure of N-ary Tree\\n        string name;//Storing names\\n        vector<Tree*> childrens;//storing childrens\\n    };\\npublic:\\n    Tree* root;\\n    unordered_map<string,Tree*> mp;//HashMap to mark dead peoples\\n    ThroneInheritance(string kingName) {\\n        root=new Tree();\\n        root->name=kingName;\\n        mp[kingName]=root;\\n    }\\n    \\n    void birth(string parentName, string childName) {\\n        Tree* child=new Tree();\\n        child->name=childName;\\n        mp[parentName]->childrens.push_back(child);//Making Link from parent to newborn child\\n        mp[childName]=child;\\n    }\\n    \\n    void death(string name) {\\n        mp[name]=NULL;//Marking Dead peoples\\n    }\\n    void dfs(Tree* root,vector<string>& ans){//DFS call to get the inheritance order\\n        if(mp[root->name]!=NULL)    ans.push_back(root->name);//Checking if current people is dead, if dead then not including that person in our inheritance order\\n        for(int i=0;i<root->childrens.size();i++){//Childrens will be present in inheritance order doesn\\'t matter if their parent is dead or alive\\n            dfs(root->childrens[i],ans);\\n        }\\n        return;\\n    }\\n    vector<string> getInheritanceOrder() {\\n        vector<string> ans;\\n        dfs(root,ans);\\n        return ans;\\n    }\\n};\\n\\n/**\\n * Your ThroneInheritance object will be instantiated and called as such:\\n * ThroneInheritance* obj = new ThroneInheritance(kingName);\\n * obj->birth(parentName,childName);\\n * obj->death(name);\\n * vector<string> param_3 = obj->getInheritanceOrder();\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1672894,
                "title": "easiest-intuitive-recursive-solusion",
                "content": "Problem description is confusing, but...\\nIf we look at the explanation of the example problem. It is clear that inheritance goes in a DFS order. Kind of like this->\\n\\nKing -> 1st Child -> If first child has childs -> ...\\n\\t\\t-> 2nd Child -> If sencond child has childs -> ..\\n\\t\\t... and so on..\\n\\nSo, we can easity implement the solution with DFS.\\nWe just need to keep track of the dead ones.\\n\\nIf someone is dead from the inheritance list, we just don\\'t add him to our return list.\\n\\nC++ Solution:\\n```\\nclass ThroneInheritance {\\nprivate:\\n    unordered_map<string, vector<string>> mp;\\n    unordered_map<string, int> isDead;\\n    string root;\\n    \\n    void makeList(vector<string>& list, string p) {\\n        if(!isDead[p])\\n            list.push_back(p);\\n        for(string child : mp[p]) {\\n            makeList(list, child);\\n        }\\n    }\\n    \\npublic:\\n    ThroneInheritance(string kingName) {\\n        root = kingName;\\n    }\\n    \\n    void birth(string parentName, string childName) {\\n        mp[parentName].push_back(childName);\\n    }\\n    \\n    void death(string name) {\\n        isDead[name] = 1;\\n    }\\n    \\n    vector<string> getInheritanceOrder() {\\n        vector<string> res;\\n        makeList(res, root);\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Recursion"
                ],
                "code": "```\\nclass ThroneInheritance {\\nprivate:\\n    unordered_map<string, vector<string>> mp;\\n    unordered_map<string, int> isDead;\\n    string root;\\n    \\n    void makeList(vector<string>& list, string p) {\\n        if(!isDead[p])\\n            list.push_back(p);\\n        for(string child : mp[p]) {\\n            makeList(list, child);\\n        }\\n    }\\n    \\npublic:\\n    ThroneInheritance(string kingName) {\\n        root = kingName;\\n    }\\n    \\n    void birth(string parentName, string childName) {\\n        mp[parentName].push_back(childName);\\n    }\\n    \\n    void death(string name) {\\n        isDead[name] = 1;\\n    }\\n    \\n    vector<string> getInheritanceOrder() {\\n        vector<string> res;\\n        makeList(res, root);\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1630969,
                "title": "c-easy-solution-with-dfs-and-map",
                "content": "// map to keep a record of people who are dead or alive\\n// also map is used here to keep record of child and simple dfs traversal\\n\\n\\n```\\nclass ThroneInheritance {\\npublic:\\n    \\n    unordered_map<string,vector<string>> mad;\\n    unordered_map<string,bool> rec;\\n    string kina;\\n    ThroneInheritance(string kingName) {\\n        mad.clear();\\n        rec.clear();\\n        rec[kingName]=true;\\n        mad[kingName].push_back(\"\");\\n        mad[kingName].pop_back();\\n        kina=kingName;\\n    }\\n    \\n    void birth(string parentName, string childName) {\\n        mad[parentName].push_back(childName);\\n        rec[childName]=true;\\n    }\\n    \\n    void death(string name) {\\n        rec[name]=false;\\n    }\\n    \\n    void dfs(string name,vector<string>&v)\\n    {\\n        for(auto it:mad[name])\\n        {\\n            if(rec[it])\\n            {\\n                v.push_back(it);\\n            }\\n            dfs(it,v);\\n        }\\n    }\\n    \\n    vector<string> getInheritanceOrder() {\\n        \\n        vector<string> ans;\\n        if(rec[kina])\\n            ans.push_back(kina);\\n        dfs(kina,ans);\\n        \\n        return ans;\\n        \\n    }\\n};\\n",
                "solutionTags": [],
                "code": "// map to keep a record of people who are dead or alive\\n// also map is used here to keep record of child and simple dfs traversal\\n\\n\\n```\\nclass ThroneInheritance {\\npublic:\\n    \\n    unordered_map<string,vector<string>> mad;\\n    unordered_map<string,bool> rec;\\n    string kina;\\n    ThroneInheritance(string kingName) {\\n        mad.clear();\\n        rec.clear();\\n        rec[kingName]=true;\\n        mad[kingName].push_back(\"\");\\n        mad[kingName].pop_back();\\n        kina=kingName;\\n    }\\n    \\n    void birth(string parentName, string childName) {\\n        mad[parentName].push_back(childName);\\n        rec[childName]=true;\\n    }\\n    \\n    void death(string name) {\\n        rec[name]=false;\\n    }\\n    \\n    void dfs(string name,vector<string>&v)\\n    {\\n        for(auto it:mad[name])\\n        {\\n            if(rec[it])\\n            {\\n                v.push_back(it);\\n            }\\n            dfs(it,v);\\n        }\\n    }\\n    \\n    vector<string> getInheritanceOrder() {\\n        \\n        vector<string> ans;\\n        if(rec[kina])\\n            ans.push_back(kina);\\n        dfs(kina,ans);\\n        \\n        return ans;\\n        \\n    }\\n};\\n",
                "codeTag": "Java"
            },
            {
                "id": 886928,
                "title": "python-3-hash-table-preorder-traversal",
                "content": "```\\nclass TreeNode:\\n\\n    def __init__(self, name: str):\\n        self.name = name\\n        self.is_alive = True\\n        self.children = []\\n\\n\\nclass ThroneInheritance:\\n\\n    def __init__(self, kingName: str):\\n        self.root = TreeNode(kingName)\\n        self.nodes = {kingName: self.root}\\n\\n    def birth(self, parentName: str, childName: str) -> None:\\n        child = TreeNode(childName)\\n        self.nodes[parentName].children.append(child)\\n        self.nodes[childName] = child\\n\\n    def death(self, name: str) -> None:\\n        self.nodes[name].is_alive = False\\n\\n    def getInheritanceOrder(self):\\n        \"\"\"\\n        This method derives the inheritance order from this\\n        object\\'s inheritance tree.\\n\\n        :return: Array of names in inheritance order\\n        :rtype: list[str]\\n        \"\"\"\\n        def recursive(head: TreeNode, inherit):\\n            if head.is_alive:\\n                inherit.append(head.name)\\n            for child in head.children:\\n                inherit = recursive(child, inherit)\\n            return inherit\\n\\n        return recursive(self.root, [])\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass TreeNode:\\n\\n    def __init__(self, name: str):\\n        self.name = name\\n        self.is_alive = True\\n        self.children = []\\n\\n\\nclass ThroneInheritance:\\n\\n    def __init__(self, kingName: str):\\n        self.root = TreeNode(kingName)\\n        self.nodes = {kingName: self.root}\\n\\n    def birth(self, parentName: str, childName: str) -> None:\\n        child = TreeNode(childName)\\n        self.nodes[parentName].children.append(child)\\n        self.nodes[childName] = child\\n\\n    def death(self, name: str) -> None:\\n        self.nodes[name].is_alive = False\\n\\n    def getInheritanceOrder(self):\\n        \"\"\"\\n        This method derives the inheritance order from this\\n        object\\'s inheritance tree.\\n\\n        :return: Array of names in inheritance order\\n        :rtype: list[str]\\n        \"\"\"\\n        def recursive(head: TreeNode, inherit):\\n            if head.is_alive:\\n                inherit.append(head.name)\\n            for child in head.children:\\n                inherit = recursive(child, inherit)\\n            return inherit\\n\\n        return recursive(self.root, [])\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 868858,
                "title": "dfs-javascript",
                "content": "```\\nconst ThroneInheritance = function(kingName) {\\n    this.dead = new Map()\\n    this.map  = new Map()\\n    \\n    this.map.set( \\'king\\', [] )\\n}\\n\\nThroneInheritance.prototype.birth = function(parentName, childName) {\\n    this.map.get( parentName ).push( childName )\\n    this.map.set( childName, [] )\\n}\\n\\nThroneInheritance.prototype.death = function(name) {\\n    this.dead.set( name, true )\\n}\\n\\nThroneInheritance.prototype.getInheritanceOrder = function() {\\n    const r = ( parent, order ) => {\\n        if ( ! this.dead.has( parent ) ) order.push( parent )\\n\\n        this.map\\n            .get( parent )\\n            .forEach( child => r( child, order ) )\\n        \\n        return order\\n    }\\n    \\n    return r( \\'king\\', [] )\\n}\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Depth-First Search"
                ],
                "code": "```\\nconst ThroneInheritance = function(kingName) {\\n    this.dead = new Map()\\n    this.map  = new Map()\\n    \\n    this.map.set( \\'king\\', [] )\\n}\\n\\nThroneInheritance.prototype.birth = function(parentName, childName) {\\n    this.map.get( parentName ).push( childName )\\n    this.map.set( childName, [] )\\n}\\n\\nThroneInheritance.prototype.death = function(name) {\\n    this.dead.set( name, true )\\n}\\n\\nThroneInheritance.prototype.getInheritanceOrder = function() {\\n    const r = ( parent, order ) => {\\n        if ( ! this.dead.has( parent ) ) order.push( parent )\\n\\n        this.map\\n            .get( parent )\\n            .forEach( child => r( child, order ) )\\n        \\n        return order\\n    }\\n    \\n    return r( \\'king\\', [] )\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 868742,
                "title": "c-map-and-dfs",
                "content": "```\\nclass ThroneInheritance {\\npublic:\\n    unordered_map<string, vector<string>> parentChild;\\n    unordered_map<string, bool> alive;\\n    ThroneInheritance(string kingName) {\\n        alive[kingName] = true;\\n    }\\n    \\n    void birth(string parentName, string childName) {\\n        parentChild[parentName].push_back(childName);\\n        alive[childName] = true;\\n    }\\n    \\n    void death(string name) {\\n        alive[name] = false;\\n    }\\n    \\n    vector<string> getInheritanceOrder() {\\n        vector<string> ord;\\n        stack<string> nodes;\\n        nodes.push(\"king\");\\n        while (!nodes.empty()) {\\n            string top = nodes.top();\\n            nodes.pop();\\n            if (alive[top])\\n                ord.push_back(top);\\n            vector<string> children = parentChild[top];\\n            reverse(children.begin(), children.end());\\n            for (string child : children)\\n                nodes.push(child);\\n        }\\n        return ord;\\n    }\\n};\\n\\n/**\\n * Your ThroneInheritance object will be instantiated and called as such:\\n * ThroneInheritance* obj = new ThroneInheritance(kingName);\\n * obj->birth(parentName,childName);\\n * obj->death(name);\\n * vector<string> param_3 = obj->getInheritanceOrder();\\n */\\n ```",
                "solutionTags": [],
                "code": "```\\nclass ThroneInheritance {\\npublic:\\n    unordered_map<string, vector<string>> parentChild;\\n    unordered_map<string, bool> alive;\\n    ThroneInheritance(string kingName) {\\n        alive[kingName] = true;\\n    }\\n    \\n    void birth(string parentName, string childName) {\\n        parentChild[parentName].push_back(childName);\\n        alive[childName] = true;\\n    }\\n    \\n    void death(string name) {\\n        alive[name] = false;\\n    }\\n    \\n    vector<string> getInheritanceOrder() {\\n        vector<string> ord;\\n        stack<string> nodes;\\n        nodes.push(\"king\");\\n        while (!nodes.empty()) {\\n            string top = nodes.top();\\n            nodes.pop();\\n            if (alive[top])\\n                ord.push_back(top);\\n            vector<string> children = parentChild[top];\\n            reverse(children.begin(), children.end());\\n            for (string child : children)\\n                nodes.push(child);\\n        }\\n        return ord;\\n    }\\n};\\n\\n/**\\n * Your ThroneInheritance object will be instantiated and called as such:\\n * ThroneInheritance* obj = new ThroneInheritance(kingName);\\n * obj->birth(parentName,childName);\\n * obj->death(name);\\n * vector<string> param_3 = obj->getInheritanceOrder();\\n */\\n ```",
                "codeTag": "Java"
            },
            {
                "id": 866562,
                "title": "python-dfs",
                "content": "```\\nclass ThroneInheritance:\\n\\n    def __init__(self, kingName: str):\\n        # Taking kingName as root\\n        self.root = kingName\\n\\n        # notDead will hold all the people who are alive and their level number\\n        self.alive = {}\\n        self.alive[kingName] = 0\\n        \\n        # hold edges existing in our graph\\n        self.edges = {self.root:[]}\\n    \\n    def birth(self, parentName: str, childName: str) -> None:\\n        # birth --> new child so update alive\\n        self.alive[childName] = self.alive[parentName]+1\\n        \\n        # add parent to child edges in the edges dictionary\\n        if parentName in self.edges:\\n            self.edges[parentName].append(childName)\\n            if childName not in self.edges:\\n                self.edges[childName] = []\\n        else:\\n            if childName not in self.edges:\\n                self.edges[childName] = []\\n            self.edges[parentName] = [childName]\\n            \\n    \\n    def death(self, name: str) -> None:\\n        # removing the dead people from alive map\\n        del self.alive[name]\\n        \\n    def getInheritanceOrder(self) -> List[str]:\\n        \\n        hierarchy = []\\n        def dfs(cur,parent=-1):\\n            nonlocal hierarchy\\n            \\n            # current person available in alive then only add in hierarchy\\n            if cur in self.alive:\\n                hierarchy.append(cur)\\n            \\n            # traverse all the children of current node\\n            for i in self.edges[cur]:\\n                if i!=parent:\\n                    dfs(i,cur)\\n        dfs(self.root)\\n        return hierarchy\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Depth-First Search"
                ],
                "code": "```\\nclass ThroneInheritance:\\n\\n    def __init__(self, kingName: str):\\n        # Taking kingName as root\\n        self.root = kingName\\n\\n        # notDead will hold all the people who are alive and their level number\\n        self.alive = {}\\n        self.alive[kingName] = 0\\n        \\n        # hold edges existing in our graph\\n        self.edges = {self.root:[]}\\n    \\n    def birth(self, parentName: str, childName: str) -> None:\\n        # birth --> new child so update alive\\n        self.alive[childName] = self.alive[parentName]+1\\n        \\n        # add parent to child edges in the edges dictionary\\n        if parentName in self.edges:\\n            self.edges[parentName].append(childName)\\n            if childName not in self.edges:\\n                self.edges[childName] = []\\n        else:\\n            if childName not in self.edges:\\n                self.edges[childName] = []\\n            self.edges[parentName] = [childName]\\n            \\n    \\n    def death(self, name: str) -> None:\\n        # removing the dead people from alive map\\n        del self.alive[name]\\n        \\n    def getInheritanceOrder(self) -> List[str]:\\n        \\n        hierarchy = []\\n        def dfs(cur,parent=-1):\\n            nonlocal hierarchy\\n            \\n            # current person available in alive then only add in hierarchy\\n            if cur in self.alive:\\n                hierarchy.append(cur)\\n            \\n            # traverse all the children of current node\\n            for i in self.edges[cur]:\\n                if i!=parent:\\n                    dfs(i,cur)\\n        dfs(self.root)\\n        return hierarchy\\n```",
                "codeTag": "Java"
            },
            {
                "id": 866515,
                "title": "python-parent-children-backtracking-dfs",
                "content": "Using \\'successor\\' for this problem is in-efficient. Knowing that before implementing would be wise. But I wasn\\'t that wise.\\n```python\\nclass Family:\\n    def __init__(self, parent):\\n        self.parent = parent\\n        self.children = []\\n    \\n    def __repr(self):\\n        return f\"parent: {self.parent}, children: {self.children}\"\\n        \\nclass ThroneInheritance:\\n\\n    def __init__(self, kingName: str):\\n        self.isdead = set()\\n        self.hierarchy = defaultdict(Family)\\n        self.hierarchy[kingName] = Family(None)\\n\\n    def birth(self, parentName: str, childName: str) -> None:\\n        self.hierarchy[parentName].children.append(childName)\\n        self.hierarchy[childName] = Family(parentName)\\n        \\n    def death(self, name: str) -> None:\\n        self.isdead.add(name)\\n\\n    def getInheritanceOrder(self) -> List[str]:            \\n        # def successor(x, curorder):\\n        #     if not self.hierarchy[x].children or all(child in curorder for child in self.hierarchy[x].children):\\n        #         if x == \\'king\\': return None\\n        #         else: return successor(self.hierarchy[x].parent, curorder)\\n        #     else:\\n        #         for child in self.hierarchy[x].children:\\n        #             if child not in curorder:\\n        #                 return child\\n        # curorder = [\\'king\\']\\n        # curorder_set = (\\'king\\')\\n        # nxt = successor(\\'king\\', curorder_set)\\n        # while nxt:\\n        #     curorder.append(nxt)\\n        #     nxt = successor(curorder[-1], curorder)\\n        \\n\\t\\t# DFS\\n        curorderq, curorder = collections.deque([\\'king\\']), []\\n        while curorderq:\\n            curorder.append(curorderq.popleft())\\n            if self.hierarchy[curorder[-1]].children:\\n                for achild in self.hierarchy[curorder[-1]].children[::-1]:\\n                    curorderq.appendleft(achild)\\n\\n\\t\\t# remove dead people\\n        return [a for a in curorder if not a in self.isdead]\\n\\n\\n# Your ThroneInheritance object will be instantiated and called as such:\\n# obj = ThroneInheritance(kingName)\\n# obj.birth(parentName,childName)\\n# obj.death(name)\\n# param_3 = obj.getInheritanceOrder()\\n```",
                "solutionTags": [],
                "code": "```python\\nclass Family:\\n    def __init__(self, parent):\\n        self.parent = parent\\n        self.children = []\\n    \\n    def __repr(self):\\n        return f\"parent: {self.parent}, children: {self.children}\"\\n        \\nclass ThroneInheritance:\\n\\n    def __init__(self, kingName: str):\\n        self.isdead = set()\\n        self.hierarchy = defaultdict(Family)\\n        self.hierarchy[kingName] = Family(None)\\n\\n    def birth(self, parentName: str, childName: str) -> None:\\n        self.hierarchy[parentName].children.append(childName)\\n        self.hierarchy[childName] = Family(parentName)\\n        \\n    def death(self, name: str) -> None:\\n        self.isdead.add(name)\\n\\n    def getInheritanceOrder(self) -> List[str]:            \\n        # def successor(x, curorder):\\n        #     if not self.hierarchy[x].children or all(child in curorder for child in self.hierarchy[x].children):\\n        #         if x == \\'king\\': return None\\n        #         else: return successor(self.hierarchy[x].parent, curorder)\\n        #     else:\\n        #         for child in self.hierarchy[x].children:\\n        #             if child not in curorder:\\n        #                 return child\\n        # curorder = [\\'king\\']\\n        # curorder_set = (\\'king\\')\\n        # nxt = successor(\\'king\\', curorder_set)\\n        # while nxt:\\n        #     curorder.append(nxt)\\n        #     nxt = successor(curorder[-1], curorder)\\n        \\n\\t\\t# DFS\\n        curorderq, curorder = collections.deque([\\'king\\']), []\\n        while curorderq:\\n            curorder.append(curorderq.popleft())\\n            if self.hierarchy[curorder[-1]].children:\\n                for achild in self.hierarchy[curorder[-1]].children[::-1]:\\n                    curorderq.appendleft(achild)\\n\\n\\t\\t# remove dead people\\n        return [a for a in curorder if not a in self.isdead]\\n\\n\\n# Your ThroneInheritance object will be instantiated and called as such:\\n# obj = ThroneInheritance(kingName)\\n# obj.birth(parentName,childName)\\n# obj.death(name)\\n# param_3 = obj.getInheritanceOrder()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 866504,
                "title": "python-using-node-class",
                "content": "```\\nclass Node:\\n    def __init__(self, name):\\n        self.name = name \\n        self.alive = True\\n        self.childs = []\\n\\n    def addChild(self, child):\\n        self.childs.append(child)\\n\\nclass ThroneInheritance:\\n    def __init__(self, kingName: str):\\n        self.king = Node(kingName)\\n        self.d = {kingName: self.king}\\n\\n    def birth(self, parentName: str, childName: str) -> None:\\n        self.d[childName] = Node(childName)\\n        self.d[parentName].addChild(self.d[childName])\\n        \\n    def death(self, name: str) -> None:\\n        self.d[name].alive = False \\n\\n    def getInheritanceOrder(self) -> List[str]:\\n        def dfs(node):\\n            ans = [node.name]*node.alive\\n            for x in node.childs:\\n                ans.extend(dfs(x))\\n            return ans \\n        \\n        return dfs(self.king)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Node:\\n    def __init__(self, name):\\n        self.name = name \\n        self.alive = True\\n        self.childs = []\\n\\n    def addChild(self, child):\\n        self.childs.append(child)\\n\\nclass ThroneInheritance:\\n    def __init__(self, kingName: str):\\n        self.king = Node(kingName)\\n        self.d = {kingName: self.king}\\n\\n    def birth(self, parentName: str, childName: str) -> None:\\n        self.d[childName] = Node(childName)\\n        self.d[parentName].addChild(self.d[childName])\\n        \\n    def death(self, name: str) -> None:\\n        self.d[name].alive = False \\n\\n    def getInheritanceOrder(self) -> List[str]:\\n        def dfs(node):\\n            ans = [node.name]*node.alive\\n            for x in node.childs:\\n                ans.extend(dfs(x))\\n            return ans \\n        \\n        return dfs(self.king)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 866495,
                "title": "c-simple-solution-using-two-dictionaries-one-for-children-and-one-for-alive-status",
                "content": "```csharp\\npublic class ThroneInheritance\\n{\\n\\tDictionary<string, List<string>> childrens = new Dictionary<string, List<string>>();\\n\\tDictionary<string, bool> isAliveMap = new Dictionary<string, bool>();\\n\\tstring kingName;\\n\\n\\tpublic ThroneInheritance(string kingName)\\n\\t{                \\n\\t\\tchildrens[kingName] = new List<string>();\\n\\t\\tthis.kingName = kingName;\\n\\t\\tisAliveMap.Add(kingName, true);\\n\\t}\\n\\n\\tpublic void Birth(string parentName, string childName)\\n\\t{                \\n\\t\\tchildrens[childName] = new List<string>();\\n\\t\\tchildrens[parentName].Add(childName);\\n\\t\\tisAliveMap.Add(childName, true);\\n\\t}\\n\\n\\tpublic void Death(string name)\\n\\t{                \\n\\t\\tisAliveMap[name] = false;\\n\\t}\\n\\n\\tpublic IList<string> GetInheritanceOrder()\\n\\t{\\n\\t\\tList<string> result = new List<string>();\\n\\n\\t\\tif (isAliveMap[this.kingName])\\n\\t\\t{\\n\\t\\t\\tresult.Add(kingName);\\n\\t\\t}\\n\\n\\t\\taddChildrens(this.kingName, result);\\n\\t\\treturn result;\\n\\t}\\n\\n\\n\\tprivate void addChildrens(string parent, List<string> result)\\n\\t{\\n\\t\\tforeach (var children in childrens[parent])\\n\\t\\t{\\n\\t\\t\\tif (isAliveMap[children])\\n\\t\\t\\t{\\n\\t\\t\\t\\tresult.Add(children);\\n\\t\\t\\t}\\n\\n\\t\\t\\taddChildrens(children, result);\\n\\t\\t}\\n\\t}\\n}\\n```",
                "solutionTags": [],
                "code": "```csharp\\npublic class ThroneInheritance\\n{\\n\\tDictionary<string, List<string>> childrens = new Dictionary<string, List<string>>();\\n\\tDictionary<string, bool> isAliveMap = new Dictionary<string, bool>();\\n\\tstring kingName;\\n\\n\\tpublic ThroneInheritance(string kingName)\\n\\t{                \\n\\t\\tchildrens[kingName] = new List<string>();\\n\\t\\tthis.kingName = kingName;\\n\\t\\tisAliveMap.Add(kingName, true);\\n\\t}\\n\\n\\tpublic void Birth(string parentName, string childName)\\n\\t{                \\n\\t\\tchildrens[childName] = new List<string>();\\n\\t\\tchildrens[parentName].Add(childName);\\n\\t\\tisAliveMap.Add(childName, true);\\n\\t}\\n\\n\\tpublic void Death(string name)\\n\\t{                \\n\\t\\tisAliveMap[name] = false;\\n\\t}\\n\\n\\tpublic IList<string> GetInheritanceOrder()\\n\\t{\\n\\t\\tList<string> result = new List<string>();\\n\\n\\t\\tif (isAliveMap[this.kingName])\\n\\t\\t{\\n\\t\\t\\tresult.Add(kingName);\\n\\t\\t}\\n\\n\\t\\taddChildrens(this.kingName, result);\\n\\t\\treturn result;\\n\\t}\\n\\n\\n\\tprivate void addChildrens(string parent, List<string> result)\\n\\t{\\n\\t\\tforeach (var children in childrens[parent])\\n\\t\\t{\\n\\t\\t\\tif (isAliveMap[children])\\n\\t\\t\\t{\\n\\t\\t\\t\\tresult.Add(children);\\n\\t\\t\\t}\\n\\n\\t\\t\\taddChildrens(children, result);\\n\\t\\t}\\n\\t}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 866465,
                "title": "whats-wrong-with-my-python-solution",
                "content": "This is my TLE code in python.\\nIs it impossible to use list for this problem ?\\n\\n```\\nclass ThroneInheritance:\\n\\n    def __init__(self, kingName: str):\\n        self.listt=[kingName]\\n\\n    def birth(self, parentName: str, childName: str) -> None:\\n        end=parentName+\"END\"\\n        if end in self.listt:\\n            place_to_append=self.listt.index(end)\\n            self.listt.insert(place_to_append, childName)\\n        else:\\n            place_to_append= self.listt.index(parentName)\\n            self.listt.insert(place_to_append+1, childName)\\n            self.listt.insert(place_to_append+2, parentName+\"END\")\\n        # print(self.listt)\\n        \\n\\n    def death(self, name: str) -> None:\\n        self.listt.remove(name)\\n        # print(self.listt)\\n\\n    def getInheritanceOrder(self) -> List[str]:\\n        newlist=[s for s in self.listt if \\'END\\' not in s]\\n        return newlist",
                "solutionTags": [],
                "code": "This is my TLE code in python.\\nIs it impossible to use list for this problem ?\\n\\n```\\nclass ThroneInheritance:\\n\\n    def __init__(self, kingName: str):\\n        self.listt=[kingName]\\n\\n    def birth(self, parentName: str, childName: str) -> None:\\n        end=parentName+\"END\"\\n        if end in self.listt:\\n            place_to_append=self.listt.index(end)\\n            self.listt.insert(place_to_append, childName)\\n        else:\\n            place_to_append= self.listt.index(parentName)\\n            self.listt.insert(place_to_append+1, childName)\\n            self.listt.insert(place_to_append+2, parentName+\"END\")\\n        # print(self.listt)\\n        \\n\\n    def death(self, name: str) -> None:\\n        self.listt.remove(name)\\n        # print(self.listt)\\n\\n    def getInheritanceOrder(self) -> List[str]:\\n        newlist=[s for s in self.listt if \\'END\\' not in s]\\n        return newlist",
                "codeTag": "Java"
            },
            {
                "id": 866452,
                "title": "c-simple-solution-dfs-using-hashmap-and-hashset",
                "content": "```\\nvector<string> v;\\nunordered_map<string, vector<string>> hash;\\nunordered_set<string> dth;\\n\\nstring king;\\nThroneInheritance(string kingName) {\\n\\tking = kingName;\\n}\\n\\nvoid birth(string parentName, string childName) {\\n\\thash[parentName].push_back(childName);\\n}\\n\\nvoid death(string name) {\\n\\tdth.insert(name);\\n}\\n\\nvoid helper(string s)\\n{\\n\\tfor(int i=0; i<hash[s].size(); i++)\\n\\t{\\n\\t\\tif(!dth.count(hash[s][i]))\\n\\t\\t\\tv.push_back(hash[s][i]);\\n\\t\\tif(hash.count(hash[s][i]))\\n\\t\\t\\thelper(hash[s][i]);\\n\\t}\\n}\\nvector<string> getInheritanceOrder() {\\n\\tv.clear();\\n\\tif(!dth.count(king))\\n\\t\\tv.push_back(king);\\n\\thelper(king);\\n\\treturn v;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nvector<string> v;\\nunordered_map<string, vector<string>> hash;\\nunordered_set<string> dth;\\n\\nstring king;\\nThroneInheritance(string kingName) {\\n\\tking = kingName;\\n}\\n\\nvoid birth(string parentName, string childName) {\\n\\thash[parentName].push_back(childName);\\n}\\n\\nvoid death(string name) {\\n\\tdth.insert(name);\\n}\\n\\nvoid helper(string s)\\n{\\n\\tfor(int i=0; i<hash[s].size(); i++)\\n\\t{\\n\\t\\tif(!dth.count(hash[s][i]))\\n\\t\\t\\tv.push_back(hash[s][i]);\\n\\t\\tif(hash.count(hash[s][i]))\\n\\t\\t\\thelper(hash[s][i]);\\n\\t}\\n}\\nvector<string> getInheritanceOrder() {\\n\\tv.clear();\\n\\tif(!dth.count(king))\\n\\t\\tv.push_back(king);\\n\\thelper(king);\\n\\treturn v;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 866433,
                "title": "python-solution-using-dfs-with-explanation",
                "content": "```\\nclass ThroneInheritance:\\n    def __init__(self, kingName: str):\\n        #for keeping track of parents and their children\\n        self.people = {kingName:[]}\\n        \\n        #for keeping track of dead people\\n        self.dead = dict()\\n        \\n        #storing the king name\\n        self.kn = kingName\\n\\n    def birth(self, parentName: str, childName: str) -> None:\\n        #if parent name already exists in our hashmap then append current childname to child list\\n        if self.people.get(parentName, 0) != 0:\\n            self.people[parentName].append(childName)\\n            \\n        #if parent name is not in our hashmap create new key value pair\\n        else:\\n            self.people[parentName] = [childName]\\n\\n    def death(self, name: str) -> None:\\n        #when a dead person is reported we create a key value pair in this hashmap\\n        self.dead[name] = 1\\n\\n    def getInheritanceOrder(self) -> List[str]:\\n        #for storing result\\n        res = []\\n        \\n        #Defining DFS function for finding all parents and their children \\n        def dfs(curr, res):\\n            #if current person is dead then we don\\'t append it to result\\n            if self.dead.get(curr, 0) == 0:\\n                res.append(curr)\\n            if curr in self.people.keys():\\n                for i in self.people[curr]:\\n                    dfs(i, res)\\n                    \\n        #starting DFS from king name\\n        dfs(self.kn, res)\\n        return res\\n```\\n\\nIf you have any doubt feel free to ask in the comments!",
                "solutionTags": [],
                "code": "```\\nclass ThroneInheritance:\\n    def __init__(self, kingName: str):\\n        #for keeping track of parents and their children\\n        self.people = {kingName:[]}\\n        \\n        #for keeping track of dead people\\n        self.dead = dict()\\n        \\n        #storing the king name\\n        self.kn = kingName\\n\\n    def birth(self, parentName: str, childName: str) -> None:\\n        #if parent name already exists in our hashmap then append current childname to child list\\n        if self.people.get(parentName, 0) != 0:\\n            self.people[parentName].append(childName)\\n            \\n        #if parent name is not in our hashmap create new key value pair\\n        else:\\n            self.people[parentName] = [childName]\\n\\n    def death(self, name: str) -> None:\\n        #when a dead person is reported we create a key value pair in this hashmap\\n        self.dead[name] = 1\\n\\n    def getInheritanceOrder(self) -> List[str]:\\n        #for storing result\\n        res = []\\n        \\n        #Defining DFS function for finding all parents and their children \\n        def dfs(curr, res):\\n            #if current person is dead then we don\\'t append it to result\\n            if self.dead.get(curr, 0) == 0:\\n                res.append(curr)\\n            if curr in self.people.keys():\\n                for i in self.people[curr]:\\n                    dfs(i, res)\\n                    \\n        #starting DFS from king name\\n        dfs(self.kn, res)\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 866364,
                "title": "python3-pre-order-traversal",
                "content": "\\n```\\nclass ThroneInheritance:\\n\\n    def __init__(self, kingName: str):\\n        self.dead = set()\\n        self.graph = {kingName: []}\\n        self.root = kingName\\n\\n    def birth(self, parentName: str, childName: str) -> None:\\n        self.graph.setdefault(parentName, []).append(childName)\\n\\n    def death(self, name: str) -> None:\\n        self.dead.add(name)\\n\\n    def getInheritanceOrder(self) -> List[str]:\\n        \\n        def dfs(n):\\n            \"\"\"Pre-order traverse the graph.\"\"\"\\n            if n not in self.dead: ans.append(n)\\n            for nn in self.graph.get(n, []): dfs(nn)\\n        \\n        ans = []\\n        dfs(self.root)\\n        return ans \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass ThroneInheritance:\\n\\n    def __init__(self, kingName: str):\\n        self.dead = set()\\n        self.graph = {kingName: []}\\n        self.root = kingName\\n\\n    def birth(self, parentName: str, childName: str) -> None:\\n        self.graph.setdefault(parentName, []).append(childName)\\n\\n    def death(self, name: str) -> None:\\n        self.dead.add(name)\\n\\n    def getInheritanceOrder(self) -> List[str]:\\n        \\n        def dfs(n):\\n            \"\"\"Pre-order traverse the graph.\"\"\"\\n            if n not in self.dead: ans.append(n)\\n            for nn in self.graph.get(n, []): dfs(nn)\\n        \\n        ans = []\\n        dfs(self.root)\\n        return ans \\n```",
                "codeTag": "Java"
            },
            {
                "id": 866345,
                "title": "python-preorder",
                "content": "```\\nclass ThroneInheritance:\\n\\n    def __init__(self, kingName: str):\\n        self.graph = collections.defaultdict(list)\\n        self.deaths = set()\\n        self.root = kingName\\n        \\n\\n    def birth(self, parentName: str, childName: str) -> None:\\n        self.graph[parentName].append(childName)\\n        \\n\\n    def death(self, name: str) -> None:\\n        self.deaths.add(name)\\n     \\n    def inorder(self, root,result):\\n        if root not in self.deaths:\\n            result.append(root)\\n        childs = self.graph[root]\\n        for child in childs:\\n            self.inorder(child,result)\\n        \\n\\n    def getInheritanceOrder(self) -> List[str]:\\n        result = []\\n        self.inorder(self.root,result)\\n        return result\\n```",
                "solutionTags": [],
                "code": "```\\nclass ThroneInheritance:\\n\\n    def __init__(self, kingName: str):\\n        self.graph = collections.defaultdict(list)\\n        self.deaths = set()\\n        self.root = kingName\\n        \\n\\n    def birth(self, parentName: str, childName: str) -> None:\\n        self.graph[parentName].append(childName)\\n        \\n\\n    def death(self, name: str) -> None:\\n        self.deaths.add(name)\\n     \\n    def inorder(self, root,result):\\n        if root not in self.deaths:\\n            result.append(root)\\n        childs = self.graph[root]\\n        for child in childs:\\n            self.inorder(child,result)\\n        \\n\\n    def getInheritanceOrder(self) -> List[str]:\\n        result = []\\n        self.inorder(self.root,result)\\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 866344,
                "title": "preorder-java",
                "content": "```\\nclass ThroneInheritance {\\n    HashMap<String, Node> map = new HashMap<>();\\n    Node root;\\n    public ThroneInheritance(String kingName) {\\n        root = new Node(kingName);\\n        map.put(kingName, root);\\n    }\\n    \\n    public void birth(String parentName, String childName) {\\n        Node parent = map.get(parentName);\\n        Node child = new Node(childName);\\n        parent.children.add(child);\\n        map.put(childName, child);\\n    }\\n    \\n    public void death(String name) {\\n        map.get(name).isDead = true;\\n    }\\n    \\n    public List<String> getInheritanceOrder() {\\n        List<String> res = new ArrayList<>();\\n        preorder(root, res);\\n        return res;\\n    }\\n    \\n    public void preorder(Node node, List<String> res) {\\n        if(node == null) return;\\n        if(!node.isDead) res.add(node.name);\\n        for(Node child : node.children) {\\n            preorder(child, res);\\n        }\\n    }\\n    \\n    public class Node {\\n        String name;\\n        boolean isDead;\\n        List<Node> children;\\n        \\n        public Node (String name) {\\n            this.name = name;\\n            children = new ArrayList<>();\\n            isDead = false;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass ThroneInheritance {\\n    HashMap<String, Node> map = new HashMap<>();\\n    Node root;\\n    public ThroneInheritance(String kingName) {\\n        root = new Node(kingName);\\n        map.put(kingName, root);\\n    }\\n    \\n    public void birth(String parentName, String childName) {\\n        Node parent = map.get(parentName);\\n        Node child = new Node(childName);\\n        parent.children.add(child);\\n        map.put(childName, child);\\n    }\\n    \\n    public void death(String name) {\\n        map.get(name).isDead = true;\\n    }\\n    \\n    public List<String> getInheritanceOrder() {\\n        List<String> res = new ArrayList<>();\\n        preorder(root, res);\\n        return res;\\n    }\\n    \\n    public void preorder(Node node, List<String> res) {\\n        if(node == null) return;\\n        if(!node.isDead) res.add(node.name);\\n        for(Node child : node.children) {\\n            preorder(child, res);\\n        }\\n    }\\n    \\n    public class Node {\\n        String name;\\n        boolean isDead;\\n        List<Node> children;\\n        \\n        public Node (String name) {\\n            this.name = name;\\n            children = new ArrayList<>();\\n            isDead = false;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3916944,
                "title": "simple-java-solution",
                "content": "# Code\\n```\\nclass ThroneInheritance {\\n    HashMap<String,ArrayList<String>> h;\\n    String king=\"\";\\n    HashSet<String> hset=new HashSet<String>();\\n    public ThroneInheritance(String kingName) {\\n        h=new HashMap<String,ArrayList<String>>();\\n        king=kingName;\\n    }\\n    \\n    public void birth(String parentName, String childName) {\\n        if(!h.containsKey(parentName))\\n        {\\n            ArrayList<String> l=new ArrayList<String>();\\n            l.add(childName);\\n            h.put(parentName,l);\\n        }\\n        else\\n        {\\n             ArrayList<String> l=h.get(parentName);\\n            l.add(childName);\\n            h.put(parentName,l);\\n        }\\n    }\\n    \\n    public void death(String name) {\\n        hset.add(name);\\n    }\\n    \\n    public List<String> getInheritanceOrder() {\\n        ArrayList<String> result=new ArrayList<String>();\\n        Stack<String> stck=new Stack<String>();\\n        stck.add(king);\\n        while(stck.size()>0)\\n        {\\n            String s=stck.pop();\\n            if(!hset.contains(s))\\n            {\\n                result.add(s);\\n            }\\n            if(h.containsKey(s))\\n            {\\n                ArrayList<String> l=h.get(s);\\n                for(int j=l.size()-1;j>=0;j--)\\n                {\\n                    stck.push(l.get(j));\\n                }\\n            }\\n        }\\n\\n        return result;\\n        \\n    }\\n}\\n\\n/**\\n * Your ThroneInheritance object will be instantiated and called as such:\\n * ThroneInheritance obj = new ThroneInheritance(kingName);\\n * obj.birth(parentName,childName);\\n * obj.death(name);\\n * List<String> param_3 = obj.getInheritanceOrder();\\n */\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass ThroneInheritance {\\n    HashMap<String,ArrayList<String>> h;\\n    String king=\"\";\\n    HashSet<String> hset=new HashSet<String>();\\n    public ThroneInheritance(String kingName) {\\n        h=new HashMap<String,ArrayList<String>>();\\n        king=kingName;\\n    }\\n    \\n    public void birth(String parentName, String childName) {\\n        if(!h.containsKey(parentName))\\n        {\\n            ArrayList<String> l=new ArrayList<String>();\\n            l.add(childName);\\n            h.put(parentName,l);\\n        }\\n        else\\n        {\\n             ArrayList<String> l=h.get(parentName);\\n            l.add(childName);\\n            h.put(parentName,l);\\n        }\\n    }\\n    \\n    public void death(String name) {\\n        hset.add(name);\\n    }\\n    \\n    public List<String> getInheritanceOrder() {\\n        ArrayList<String> result=new ArrayList<String>();\\n        Stack<String> stck=new Stack<String>();\\n        stck.add(king);\\n        while(stck.size()>0)\\n        {\\n            String s=stck.pop();\\n            if(!hset.contains(s))\\n            {\\n                result.add(s);\\n            }\\n            if(h.containsKey(s))\\n            {\\n                ArrayList<String> l=h.get(s);\\n                for(int j=l.size()-1;j>=0;j--)\\n                {\\n                    stck.push(l.get(j));\\n                }\\n            }\\n        }\\n\\n        return result;\\n        \\n    }\\n}\\n\\n/**\\n * Your ThroneInheritance object will be instantiated and called as such:\\n * ThroneInheritance obj = new ThroneInheritance(kingName);\\n * obj.birth(parentName,childName);\\n * obj.death(name);\\n * List<String> param_3 = obj.getInheritanceOrder();\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2850200,
                "title": "java-hashmap-n-ary-tree-dfs-traversal-explained",
                "content": "**Intuition:**\\n* To store multiple children, we will use n-ary tree data structure.\\n* To mark birth and death, we will use HashMap.\\n* To get inheritance order, we will use DFS preorder traversal.\\n\\n```\\n// Time complexity: birth: O(1), death: O(1), getInheritanceOrder: O(N Log N)\\n// Space complexity: O(N)\\n\\nclass ThroneInheritance {\\n    private Person king;\\n    private Map<String, Person> persons;\\n\\n     public ThroneInheritance(String kingName) {\\n        king = new Person(kingName);\\n        persons = new HashMap<>();\\n        persons.put(kingName, king);\\n    }\\n    \\n    public void birth(String parentName, String childName) {\\n        Person parent = persons.get(parentName);\\n\\t\\tPerson newChild = new Person(childName);\\n        parent.getChildren().add(newChild);\\n\\t\\tpersons.put(childName, newChild);\\n    }\\n    \\n    public void death(String name) {\\n        Person person = persons.get(name);\\n        person.setIsAlive(false);\\n    }\\n    \\n    public List<String> getInheritanceOrder() {\\n        List<String> order = new LinkedList<>();\\n        dfs(order, king);\\n        return order;\\n    }\\n    \\n    private void dfs(List<String> order, Person person) {\\n        if(person.getIsAlive())\\n            order.add(person.getName());\\n        \\n        for (Person child : person.getChildren()) \\n            dfs(order, child);\\n    }\\n}\\n\\nclass Person {\\n    private String name;\\n    private List<Person> children;\\n    private boolean isAlive;\\n    \\n    public Person(String name) {\\n        this.name = name;\\n        children = new LinkedList<>();\\n        isAlive = true;\\n    }\\n    \\n    public String getName() {\\n        return this.name;\\n    }\\n\\t\\n\\tpublic List<Person> getChildren() {\\n\\t\\treturn this.children;\\n\\t}\\n    \\n    public boolean getIsAlive() {\\n        return this.isAlive;\\n    }\\n\\t\\n\\tpublic void setIsAlive(boolean flag) {\\n\\t\\tthis.isAlive = flag;\\n\\t}\\n}\\n```\\n\\n**Please upvote if you find this solution useful. Happy Coding!**",
                "solutionTags": [
                    "Java",
                    "Depth-First Search"
                ],
                "code": "```\\n// Time complexity: birth: O(1), death: O(1), getInheritanceOrder: O(N Log N)\\n// Space complexity: O(N)\\n\\nclass ThroneInheritance {\\n    private Person king;\\n    private Map<String, Person> persons;\\n\\n     public ThroneInheritance(String kingName) {\\n        king = new Person(kingName);\\n        persons = new HashMap<>();\\n        persons.put(kingName, king);\\n    }\\n    \\n    public void birth(String parentName, String childName) {\\n        Person parent = persons.get(parentName);\\n\\t\\tPerson newChild = new Person(childName);\\n        parent.getChildren().add(newChild);\\n\\t\\tpersons.put(childName, newChild);\\n    }\\n    \\n    public void death(String name) {\\n        Person person = persons.get(name);\\n        person.setIsAlive(false);\\n    }\\n    \\n    public List<String> getInheritanceOrder() {\\n        List<String> order = new LinkedList<>();\\n        dfs(order, king);\\n        return order;\\n    }\\n    \\n    private void dfs(List<String> order, Person person) {\\n        if(person.getIsAlive())\\n            order.add(person.getName());\\n        \\n        for (Person child : person.getChildren()) \\n            dfs(order, child);\\n    }\\n}\\n\\nclass Person {\\n    private String name;\\n    private List<Person> children;\\n    private boolean isAlive;\\n    \\n    public Person(String name) {\\n        this.name = name;\\n        children = new LinkedList<>();\\n        isAlive = true;\\n    }\\n    \\n    public String getName() {\\n        return this.name;\\n    }\\n\\t\\n\\tpublic List<Person> getChildren() {\\n\\t\\treturn this.children;\\n\\t}\\n    \\n    public boolean getIsAlive() {\\n        return this.isAlive;\\n    }\\n\\t\\n\\tpublic void setIsAlive(boolean flag) {\\n\\t\\tthis.isAlive = flag;\\n\\t}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2403593,
                "title": "python-solution",
                "content": "```\\nclass ThroneInheritance:\\n\\n    def __init__(self, kingName: str):\\n        self.tree = {kingName: [True]}\\n        self.king = kingName\\n\\n    def birth(self, parentName: str, childName: str) -> None:\\n        self.tree[parentName].append(childName)\\n        self.tree[childName] = [True]\\n\\n    def death(self, name: str) -> None:\\n        self.tree[name][0] = False\\n\\n    def getInheritanceOrder(self) -> List[str]:\\n        return self.getOrder(self.king)\\n\\n    def getOrder(self, name):\\n        res = [name] if self.tree[name][0] else []\\n        for child in self.tree[name][1:]:\\n            res += self.getOrder(child)\\n        return res\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass ThroneInheritance:\\n\\n    def __init__(self, kingName: str):\\n        self.tree = {kingName: [True]}\\n        self.king = kingName\\n\\n    def birth(self, parentName: str, childName: str) -> None:\\n        self.tree[parentName].append(childName)\\n        self.tree[childName] = [True]\\n\\n    def death(self, name: str) -> None:\\n        self.tree[name][0] = False\\n\\n    def getInheritanceOrder(self) -> List[str]:\\n        return self.getOrder(self.king)\\n\\n    def getOrder(self, name):\\n        res = [name] if self.tree[name][0] else []\\n        for child in self.tree[name][1:]:\\n            res += self.getOrder(child)\\n        return res\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1989935,
                "title": "small-and-concise-code-c-generic-tree-dfs",
                "content": "```\\n//----------------------------------------------------------------------------------------------------------------\\n// JO BHI SUCCESSOR BANAO USKE LIYE BHI EK NODE CREATE KRNA\\n// AUR US NODE KA ADDRESS MAP STORE KAR LENA, BCZ AGAR ADDRESS HOGA TOH USKE CHILD EASILY ADD HO JAAYENGE.\\n// BHALE HI AAGE KOI CHILD ADD NA HO\\n//----------------------------------------------------------------------------------------------------------------\\n//JISKI BHI DEATH HO, MAP MAIN USKA NAME CHANGE KR DO, \\n//MATLAB KUCH AISA KR DO KI TUM SAMJH JAO YE DEAD HAI, LIKE USKE NAME SE PEHLE (*) ADD KR DO\\n//----------------------------------------------------------------------------------------------------------------\\n//ORDER LAANE KE LIYE DFS USE KRO,\\n//DFS KI STARTING PARENT NODE SE HOGI, AND PARENT GOLBAL VARIABLE King MAIN STORED HAI.\\n//JIS BHI NODE PAR JAO, AGAR WO DEAD NI HAI, TOH USSE ADD KR LO ORDER MAIN\\n//AND CURRENT NODE KE DOOSRE CHILDS PR JAANSE SE PEHLE, CURRENT CHILD KE CHILDS\\' KO STORE KARAO\\n//USKE LIYE CURRENT CHILD PR DFS CALL KR DO.\\n//----------------------------------------------------------------------------------------------------------------\\n\\nclass generic\\n{\\npublic:\\n    string MyName;\\n    vector<string> child;\\n    generic(string a)\\n    {\\n        MyName = a;\\n    }\\n    generic(string a, string b)\\n    {\\n        MyName = a;\\n        child.push_back(b);\\n    }\\n};\\n\\nmap<string, generic *> mp;\\n\\nstring King = NULL;\\n\\nclass ThroneInheritance\\n{\\npublic:\\n    void dfs(string King, vector<string> &ans)\\n    {\\n        if (mp[King]->MyName[0] != \\'*\\')\\n            ans.push_back(mp[King]->MyName);\\n        for (auto it : mp[King]->child)\\n            dfs(it, ans);\\n    }\\n    ThroneInheritance(string kingName)\\n    {\\n        King = kingName;\\n        generic *temp = new generic(kingName);\\n        mp[kingName] = temp;\\n    }\\n\\n    void birth(string parentName, string childName)\\n    {\\n        mp[parentName]->child.push_back(childName);\\n        generic *temp2 = new generic(childName);\\n        mp[childName] = temp2;\\n    }\\n\\n    void death(string name)\\n    {\\n        string a = mp[name]->MyName;\\n        mp[name]->MyName = \\'*\\' + a;\\n    }\\n\\n    vector<string> getInheritanceOrder()\\n    {\\n        vector<string> order;\\n        dfs(King, order);\\n        return order;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Depth-First Search"
                ],
                "code": "```\\n//----------------------------------------------------------------------------------------------------------------\\n// JO BHI SUCCESSOR BANAO USKE LIYE BHI EK NODE CREATE KRNA\\n// AUR US NODE KA ADDRESS MAP STORE KAR LENA, BCZ AGAR ADDRESS HOGA TOH USKE CHILD EASILY ADD HO JAAYENGE.\\n// BHALE HI AAGE KOI CHILD ADD NA HO\\n//----------------------------------------------------------------------------------------------------------------\\n//JISKI BHI DEATH HO, MAP MAIN USKA NAME CHANGE KR DO, \\n//MATLAB KUCH AISA KR DO KI TUM SAMJH JAO YE DEAD HAI, LIKE USKE NAME SE PEHLE (*) ADD KR DO\\n//----------------------------------------------------------------------------------------------------------------\\n//ORDER LAANE KE LIYE DFS USE KRO,\\n//DFS KI STARTING PARENT NODE SE HOGI, AND PARENT GOLBAL VARIABLE King MAIN STORED HAI.\\n//JIS BHI NODE PAR JAO, AGAR WO DEAD NI HAI, TOH USSE ADD KR LO ORDER MAIN\\n//AND CURRENT NODE KE DOOSRE CHILDS PR JAANSE SE PEHLE, CURRENT CHILD KE CHILDS\\' KO STORE KARAO\\n//USKE LIYE CURRENT CHILD PR DFS CALL KR DO.\\n//----------------------------------------------------------------------------------------------------------------\\n\\nclass generic\\n{\\npublic:\\n    string MyName;\\n    vector<string> child;\\n    generic(string a)\\n    {\\n        MyName = a;\\n    }\\n    generic(string a, string b)\\n    {\\n        MyName = a;\\n        child.push_back(b);\\n    }\\n};\\n\\nmap<string, generic *> mp;\\n\\nstring King = NULL;\\n\\nclass ThroneInheritance\\n{\\npublic:\\n    void dfs(string King, vector<string> &ans)\\n    {\\n        if (mp[King]->MyName[0] != \\'*\\')\\n            ans.push_back(mp[King]->MyName);\\n        for (auto it : mp[King]->child)\\n            dfs(it, ans);\\n    }\\n    ThroneInheritance(string kingName)\\n    {\\n        King = kingName;\\n        generic *temp = new generic(kingName);\\n        mp[kingName] = temp;\\n    }\\n\\n    void birth(string parentName, string childName)\\n    {\\n        mp[parentName]->child.push_back(childName);\\n        generic *temp2 = new generic(childName);\\n        mp[childName] = temp2;\\n    }\\n\\n    void death(string name)\\n    {\\n        string a = mp[name]->MyName;\\n        mp[name]->MyName = \\'*\\' + a;\\n    }\\n\\n    vector<string> getInheritanceOrder()\\n    {\\n        vector<string> order;\\n        dfs(King, order);\\n        return order;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1312845,
                "title": "python3-tree-to-hashmap",
                "content": "Using a tree is most natural. Then with the TLE the hashmap (3rd) solution became most natural. I added the second solution as an intermediate just because.\\n\\n```\\nclass TreeNode:\\n\\n    def __init__(self, name: str):\\n        self.name = name\\n        self.children = []\\n\\n    def __iter__(self):\\n        if self:\\n            yield self\\n            for child in self.children:\\n                yield from child\\n\\n    def __repr__(self):\\n        return f\"{self.__class__.__name__}: {self.name}\"\\n\\n\\nclass ThroneInheritance:  # Turns out they don\\'t want just a tree: TLE: 46 / 49 test cases passed.\\n\\n    def __init__(self, kingName: str):\\n        self.root = TreeNode(kingName)\\n        self.deceased = set()\\n\\n    def birth(self, parentName: str, childName: str) -> None:  # O(n) time\\n        parent = next(node for node in self.root if node.name == parentName)\\n        parent.children.append(TreeNode(childName))\\n\\n    def death(self, name: str) -> None:  # O(1) time\\n        self.deceased.add(name)\\n\\n    def getInheritanceOrder(self) -> List[str]:  # O(n) time\\n        return list(filter(lambda n: n not in self.deceased, (node.name for node in self.root)))\\n\\n\\nclass ThroneInheritance:  # tree + hashmap: 996 ms\\n\\n    def __init__(self, kingName: str):\\n        self.root = TreeNode(kingName)\\n        self.nodes = {kingName: self.root}\\n        self.deceased = set()\\n\\n    def birth(self, parentName: str, childName: str) -> None:  # O(1) time\\n        self.nodes[childName] = TreeNode(childName)\\n        self.nodes[parentName].children.append(self.nodes[childName])\\n\\n    def death(self, name: str) -> None:  # O(1) time\\n        self.deceased.add(name)\\n\\n    def getInheritanceOrder(self) -> List[str]:  # O(n) time\\n        return list(filter(lambda n: n not in self.deceased, (node.name for node in self.root)))\\n\\n\\nclass ThroneInheritance:  # just a hashmap: 784 ms\\n\\n    def __init__(self, kingName: str):\\n        self.king = kingName\\n        self.children = {kingName: []}\\n        self.deceased = set()\\n\\n    def birth(self, parentName: str, childName: str) -> None:  # O(1) time\\n        self.children.setdefault(parentName, []).append(childName)\\n\\n    def death(self, name: str) -> None:  # O(1) time\\n        self.deceased.add(name)\\n\\n    def getInheritanceOrder(self) -> List[str]:  # O(n) time\\n        queue, order = [self.king], []\\n        while queue:\\n            node = queue.pop()\\n            order.append(node)\\n            queue.extend(reversed(self.children.get(node, [])))\\n        return list(filter(lambda n: n not in self.deceased, order))\\n```",
                "solutionTags": [],
                "code": "```\\nclass TreeNode:\\n\\n    def __init__(self, name: str):\\n        self.name = name\\n        self.children = []\\n\\n    def __iter__(self):\\n        if self:\\n            yield self\\n            for child in self.children:\\n                yield from child\\n\\n    def __repr__(self):\\n        return f\"{self.__class__.__name__}: {self.name}\"\\n\\n\\nclass ThroneInheritance:  # Turns out they don\\'t want just a tree: TLE: 46 / 49 test cases passed.\\n\\n    def __init__(self, kingName: str):\\n        self.root = TreeNode(kingName)\\n        self.deceased = set()\\n\\n    def birth(self, parentName: str, childName: str) -> None:  # O(n) time\\n        parent = next(node for node in self.root if node.name == parentName)\\n        parent.children.append(TreeNode(childName))\\n\\n    def death(self, name: str) -> None:  # O(1) time\\n        self.deceased.add(name)\\n\\n    def getInheritanceOrder(self) -> List[str]:  # O(n) time\\n        return list(filter(lambda n: n not in self.deceased, (node.name for node in self.root)))\\n\\n\\nclass ThroneInheritance:  # tree + hashmap: 996 ms\\n\\n    def __init__(self, kingName: str):\\n        self.root = TreeNode(kingName)\\n        self.nodes = {kingName: self.root}\\n        self.deceased = set()\\n\\n    def birth(self, parentName: str, childName: str) -> None:  # O(1) time\\n        self.nodes[childName] = TreeNode(childName)\\n        self.nodes[parentName].children.append(self.nodes[childName])\\n\\n    def death(self, name: str) -> None:  # O(1) time\\n        self.deceased.add(name)\\n\\n    def getInheritanceOrder(self) -> List[str]:  # O(n) time\\n        return list(filter(lambda n: n not in self.deceased, (node.name for node in self.root)))\\n\\n\\nclass ThroneInheritance:  # just a hashmap: 784 ms\\n\\n    def __init__(self, kingName: str):\\n        self.king = kingName\\n        self.children = {kingName: []}\\n        self.deceased = set()\\n\\n    def birth(self, parentName: str, childName: str) -> None:  # O(1) time\\n        self.children.setdefault(parentName, []).append(childName)\\n\\n    def death(self, name: str) -> None:  # O(1) time\\n        self.deceased.add(name)\\n\\n    def getInheritanceOrder(self) -> List[str]:  # O(n) time\\n        queue, order = [self.king], []\\n        while queue:\\n            node = queue.pop()\\n            order.append(node)\\n            queue.extend(reversed(self.children.get(node, [])))\\n        return list(filter(lambda n: n not in self.deceased, order))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1198212,
                "title": "easy-c-n-ary-94-fastest",
                "content": "```\\nclass ThroneInheritance {\\npublic:\\n    struct Node\\n    {\\n        string val;\\n        vector<Node*> children;\\n        Node(string s): val(s) {}\\n        Node(string s,vector<Node*> child_) : val(s){\\n            children=child_;\\n        }\\n    };\\n    Node* root;\\n    unordered_map<string,Node*> mp;\\n    ThroneInheritance(string kingName) {\\n        root=new Node(kingName);\\n        mp[kingName]=root;\\n    }\\n    \\n    void birth(string parentName, string childName) {\\n        Node* child=new Node(childName);\\n        mp[childName]=child;\\n        mp[parentName]->children.push_back(child);\\n        \\n    }\\n    \\n    void death(string name) {\\n        mp[name]=NULL;\\n    }\\n    void dfs(Node* root, vector<string> &res){\\n        if(mp[root->val])res.push_back(root->val);\\n        for(auto i:root->children){\\n            dfs(i,res);\\n        }\\n        \\n    }\\n    vector<string> getInheritanceOrder() {\\n        vector<string> res;\\n        if(!root)return res;\\n        dfs(root,res);\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass ThroneInheritance {\\npublic:\\n    struct Node\\n    {\\n        string val;\\n        vector<Node*> children;\\n        Node(string s): val(s) {}\\n        Node(string s,vector<Node*> child_) : val(s){\\n            children=child_;\\n        }\\n    };\\n    Node* root;\\n    unordered_map<string,Node*> mp;\\n    ThroneInheritance(string kingName) {\\n        root=new Node(kingName);\\n        mp[kingName]=root;\\n    }\\n    \\n    void birth(string parentName, string childName) {\\n        Node* child=new Node(childName);\\n        mp[childName]=child;\\n        mp[parentName]->children.push_back(child);\\n        \\n    }\\n    \\n    void death(string name) {\\n        mp[name]=NULL;\\n    }\\n    void dfs(Node* root, vector<string> &res){\\n        if(mp[root->val])res.push_back(root->val);\\n        for(auto i:root->children){\\n            dfs(i,res);\\n        }\\n        \\n    }\\n    vector<string> getInheritanceOrder() {\\n        vector<string> res;\\n        if(!root)return res;\\n        dfs(root,res);\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1069762,
                "title": "java-dfs-solution",
                "content": "```\\n    Set<String> dead;\\n    Map<String, List<String>> map;\\n    String root;\\n    public ThroneInheritance(String kingName) {\\n        dead = new HashSet<>();\\n        map = new HashMap<>();\\n        root = kingName;\\n    }\\n    \\n    public void birth(String parentName, String childName) {\\n        map.computeIfAbsent(parentName, a->new ArrayList<>()).add(childName);\\n    }\\n    \\n    public void death(String name) {\\n        dead.add(name);\\n    }\\n    \\n    public List<String> getInheritanceOrder() {\\n        List<String> res = new ArrayList<>();\\n        dfs(root, res);\\n        return res;\\n    }\\n    \\n    void dfs(String root, List<String> res) {\\n        if(!dead.contains(root)) res.add(root);\\n        if(!map.containsKey(root)) return;\\n        for(String nxt : map.get(root)) dfs(nxt, res);\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    Set<String> dead;\\n    Map<String, List<String>> map;\\n    String root;\\n    public ThroneInheritance(String kingName) {\\n        dead = new HashSet<>();\\n        map = new HashMap<>();\\n        root = kingName;\\n    }\\n    \\n    public void birth(String parentName, String childName) {\\n        map.computeIfAbsent(parentName, a->new ArrayList<>()).add(childName);\\n    }\\n    \\n    public void death(String name) {\\n        dead.add(name);\\n    }\\n    \\n    public List<String> getInheritanceOrder() {\\n        List<String> res = new ArrayList<>();\\n        dfs(root, res);\\n        return res;\\n    }\\n    \\n    void dfs(String root, List<String> res) {\\n        if(!dead.contains(root)) res.add(root);\\n        if(!map.containsKey(root)) return;\\n        for(String nxt : map.get(root)) dfs(nxt, res);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1008189,
                "title": "c-668ms-looking-for-better-solution",
                "content": "Let me know if you can beat 668ms.\\n```\\nstruct Person {\\n    Person(string name) : name(name) {}\\n    \\n    string name;\\n    bool alive = true;\\n    vector<unique_ptr<Person>> children;\\n};\\n\\n\\nclass ThroneInheritance {\\npublic:\\n    ThroneInheritance(string kingName) : m_root(kingName) {\\n        m_people[kingName] = &m_root;\\n    }\\n    \\n    void birth(string parentName, string childName) {\\n        auto& children = m_people[parentName]->children;\\n        children.push_back(make_unique<Person>(childName));\\n        m_people[childName] = children.back().get();\\n    }\\n    \\n    void death(string name) {\\n        m_people[name]->alive = false;\\n    }\\n    \\n    vector<string> getInheritanceOrder() {\\n        vector<string> output;\\n        process(m_root, output);\\n        return output;\\n    }\\n    \\n    void process(Person const& person, vector<string>& output) {\\n        if (person.alive) output.push_back(person.name);\\n        \\n        for (unique_ptr<Person> const& child : person.children) {\\n            process(*child, output);\\n        }\\n    }\\n    \\n    Person m_root;\\n    unordered_map<string, Person*> m_people;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nstruct Person {\\n    Person(string name) : name(name) {}\\n    \\n    string name;\\n    bool alive = true;\\n    vector<unique_ptr<Person>> children;\\n};\\n\\n\\nclass ThroneInheritance {\\npublic:\\n    ThroneInheritance(string kingName) : m_root(kingName) {\\n        m_people[kingName] = &m_root;\\n    }\\n    \\n    void birth(string parentName, string childName) {\\n        auto& children = m_people[parentName]->children;\\n        children.push_back(make_unique<Person>(childName));\\n        m_people[childName] = children.back().get();\\n    }\\n    \\n    void death(string name) {\\n        m_people[name]->alive = false;\\n    }\\n    \\n    vector<string> getInheritanceOrder() {\\n        vector<string> output;\\n        process(m_root, output);\\n        return output;\\n    }\\n    \\n    void process(Person const& person, vector<string>& output) {\\n        if (person.alive) output.push_back(person.name);\\n        \\n        for (unique_ptr<Person> const& child : person.children) {\\n            process(*child, output);\\n        }\\n    }\\n    \\n    Person m_root;\\n    unordered_map<string, Person*> m_people;\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 877657,
                "title": "c-dfs-solution",
                "content": "\\'\\'\\'\\nclass ThroneInheritance {\\npublic:\\n    ThroneInheritance(string kingName) {\\n        king = kingName;\\n    }\\n    \\n    void birth(string parentName, string childName) {\\n        mp[parentName].push_back(childName);\\n    }    \\n    void death(string name) {\\n        dead.insert(name);\\n    }\\n    \\n    vector<string> getInheritanceOrder() {\\n        vector<string> res;\\n        successor(king,res);\\n        return res;\\n    }\\n    \\nprivate:\\n    string king;\\n    unordered_map<string,vector<string>> mp;\\n    unordered_set<string> dead;\\n\\n    void successor(string parent, vector<string>&res)\\n    {\\n        if(dead.find(parent)==dead.end())\\n            res.push_back(parent);\\n\\n        vector<string> children = mp[parent];\\n        for(auto child:children)\\n            successor(child,res);   \\n    }    \\n};\\n\\'\\'\\'",
                "solutionTags": [],
                "code": "\\'\\'\\'\\nclass ThroneInheritance {\\npublic:\\n    ThroneInheritance(string kingName) {\\n        king = kingName;\\n    }\\n    \\n    void birth(string parentName, string childName) {\\n        mp[parentName].push_back(childName);\\n    }    \\n    void death(string name) {\\n        dead.insert(name);\\n    }\\n    \\n    vector<string> getInheritanceOrder() {\\n        vector<string> res;\\n        successor(king,res);\\n        return res;\\n    }\\n    \\nprivate:\\n    string king;\\n    unordered_map<string,vector<string>> mp;\\n    unordered_set<string> dead;\\n\\n    void successor(string parent, vector<string>&res)\\n    {\\n        if(dead.find(parent)==dead.end())\\n            res.push_back(parent);\\n\\n        vector<string> children = mp[parent];\\n        for(auto child:children)\\n            successor(child,res);   \\n    }    \\n};\\n\\'\\'\\'",
                "codeTag": "Java"
            },
            {
                "id": 875625,
                "title": "java-straight-forward-dfs-with-name-caching",
                "content": "```\\nclass Node {\\n    String name;\\n    boolean deleted;\\n    List<Node> childs = new ArrayList<>();\\n\\n    Node(String name) {\\n        this.name = name;\\n    }\\n}\\n\\nclass ThroneInheritance {\\n    Node head;\\n    Map<String, Node> nNode = new HashMap<>();\\n\\n    public ThroneInheritance(String kingName) {\\n        head = new Node(kingName);\\n        nNode.put(kingName, head);\\n    }\\n    \\n    public void birth(String parentName, String childName) {\\n        Node parentNode = nNode.get(parentName);\\n        Node childNode = new Node(childName);\\n        parentNode.childs.add(childNode);\\n        nNode.put(childName, childNode);\\n    }\\n    \\n    public void death(String name) {\\n        Node curNode = nNode.get(name);\\n        if(curNode != null) {\\n            curNode.deleted = true;\\n        }\\n\\n    }\\n    \\n    public List<String> getInheritanceOrder() {\\n        return dfs(head);\\n    }\\n    \\n    List<String> dfs(Node node) {\\n        List<String> order = new ArrayList<>();\\n        if(!node.deleted) {\\n            order.add(node.name);\\n        }\\n        for(Node e : node.childs) {\\n            order.addAll(dfs(e));\\n        }\\n        return order;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Node {\\n    String name;\\n    boolean deleted;\\n    List<Node> childs = new ArrayList<>();\\n\\n    Node(String name) {\\n        this.name = name;\\n    }\\n}\\n\\nclass ThroneInheritance {\\n    Node head;\\n    Map<String, Node> nNode = new HashMap<>();\\n\\n    public ThroneInheritance(String kingName) {\\n        head = new Node(kingName);\\n        nNode.put(kingName, head);\\n    }\\n    \\n    public void birth(String parentName, String childName) {\\n        Node parentNode = nNode.get(parentName);\\n        Node childNode = new Node(childName);\\n        parentNode.childs.add(childNode);\\n        nNode.put(childName, childNode);\\n    }\\n    \\n    public void death(String name) {\\n        Node curNode = nNode.get(name);\\n        if(curNode != null) {\\n            curNode.deleted = true;\\n        }\\n\\n    }\\n    \\n    public List<String> getInheritanceOrder() {\\n        return dfs(head);\\n    }\\n    \\n    List<String> dfs(Node node) {\\n        List<String> order = new ArrayList<>();\\n        if(!node.deleted) {\\n            order.add(node.name);\\n        }\\n        for(Node e : node.childs) {\\n            order.addAll(dfs(e));\\n        }\\n        return order;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 875232,
                "title": "c-solution-dfs-based",
                "content": "```\\nclass ThroneInheritance {\\npublic: \\n    class node\\n    {\\n       public: \\n       string name; \\n       vector<node*>children; \\n        \\n        node(string a)\\n        {\\n            name=a;  \\n      \\n        }\\n    };   \\n    unordered_map<string,bool>dead;  \\n    unordered_map<string,node*>m;  \\n    vector<string>order;    \\n    \\n    string king;  \\n    ThroneInheritance(string kingName) {\\n        \\n        node *n; \\n        n=new node(kingName);     \\n        m[kingName]=n;\\n        king=kingName;  \\n    }\\n    \\n    void birth(string parent, string child) {\\n        \\n        node *n=new node(child); \\n        node *p;  \\n        m[child]=n; \\n        p=m[parent];  \\n        if(p!=NULL){\\n        p->children.push_back(n);  \\n        }\\n        else\\n        {\\n            cout<<parent<<\" \";\\n        }\\n         \\n    }\\n    \\n    void death(string name) {\\n         dead[name]=true;        \\n    }\\n    \\n    void solve(node *n )\\n    {\\n        \\n        if(n==NULL)\\n        {\\n            return ;  \\n        }\\n         \\n        order.push_back(n->name); \\n        \\n        for(auto  x:n->children)\\n        {\\n            solve(x); \\n            \\n        }\\n        \\n    }\\n    vector<string> getInheritanceOrder() {\\n          \\n      \\n        \\n        order.clear(); \\n        node *n; \\n        n=m[king];  \\n        solve(n);  \\n        vector<string>ans;  \\n        \\n        for(int i=0;i<order.size();i++)\\n        {\\n            if(dead[order[i]]==false)\\n            {\\n                ans.push_back(order[i]); \\n            }\\n        }\\n        \\n        return ans; \\n        \\n    }\\n};\\n",
                "solutionTags": [],
                "code": "```\\nclass ThroneInheritance {\\npublic: \\n    class node\\n    {\\n       public: \\n       string name; \\n       vector<node*>children; \\n        \\n        node(string a)\\n        {\\n            name=a;  \\n      \\n        }\\n    };   \\n    unordered_map<string,bool>dead;  \\n    unordered_map<string,node*>m;  \\n    vector<string>order;    \\n    \\n    string king;  \\n    ThroneInheritance(string kingName) {\\n        \\n        node *n; \\n        n=new node(kingName);     \\n        m[kingName]=n;\\n        king=kingName;  \\n    }\\n    \\n    void birth(string parent, string child) {\\n        \\n        node *n=new node(child); \\n        node *p;  \\n        m[child]=n; \\n        p=m[parent];  \\n        if(p!=NULL){\\n        p->children.push_back(n);  \\n        }\\n        else\\n        {\\n            cout<<parent<<\" \";\\n        }\\n         \\n    }\\n    \\n    void death(string name) {\\n         dead[name]=true;        \\n    }\\n    \\n    void solve(node *n )\\n    {\\n        \\n        if(n==NULL)\\n        {\\n            return ;  \\n        }\\n         \\n        order.push_back(n->name); \\n        \\n        for(auto  x:n->children)\\n        {\\n            solve(x); \\n            \\n        }\\n        \\n    }\\n    vector<string> getInheritanceOrder() {\\n          \\n      \\n        \\n        order.clear(); \\n        node *n; \\n        n=m[king];  \\n        solve(n);  \\n        vector<string>ans;  \\n        \\n        for(int i=0;i<order.size();i++)\\n        {\\n            if(dead[order[i]]==false)\\n            {\\n                ans.push_back(order[i]); \\n            }\\n        }\\n        \\n        return ans; \\n        \\n    }\\n};\\n",
                "codeTag": "C++"
            },
            {
                "id": 872761,
                "title": "c-map-and-iterative-dfs-commented",
                "content": "```\\nclass ThroneInheritance {\\n   unordered_map<string, vector<string>> umap;     //parent and list of children\\n   stack<string> st;\\n    unordered_map<string, bool> dead;       // keep track of dead people, (map was faster than vector, vector gave TLE)\\n    string kName;               // king name\\npublic:\\n    ThroneInheritance(string kingName) {\\n       kName = kingName;\\n    }\\n    \\n    void birth(string parentName, string childName) { \\n            umap[parentName].push_back(childName);      // make parent->child map\\n    }\\n    \\n    void death(string name) {\\n        dead[name]=true;            \\n    }\\n    \\n    vector<string> getInheritanceOrder() {\\n        vector<string> str;\\n        string name;\\n        int i;\\n        vector<string> v;\\n        st.push(kName);     // push king to stack\\n        \\n        while(!st.empty())\\n        {\\n            name = st.top();\\n      \\n            if(dead[name] != true)      // if the person is not dead, add it to the final list\\n                str.push_back(name);\\n            st.pop();\\n            \\n            auto p= umap.find(name);    // find top of stack into map\\n            if(p != umap.end())\\n            {\\n            v = p->second;\\n            for(i=v.size()-1; i>=0; i--)        // traverse all children of tos person and push them to stack\\n                st.push(v[i]);\\n            }\\n         }\\n        return str;\\n    }",
                "solutionTags": [
                    "C",
                    "Stack",
                    "Depth-First Search",
                    "Iterator"
                ],
                "code": "```\\nclass ThroneInheritance {\\n   unordered_map<string, vector<string>> umap;     //parent and list of children\\n   stack<string> st;\\n    unordered_map<string, bool> dead;       // keep track of dead people, (map was faster than vector, vector gave TLE)\\n    string kName;               // king name\\npublic:\\n    ThroneInheritance(string kingName) {\\n       kName = kingName;\\n    }\\n    \\n    void birth(string parentName, string childName) { \\n            umap[parentName].push_back(childName);      // make parent->child map\\n    }\\n    \\n    void death(string name) {\\n        dead[name]=true;            \\n    }\\n    \\n    vector<string> getInheritanceOrder() {\\n        vector<string> str;\\n        string name;\\n        int i;\\n        vector<string> v;\\n        st.push(kName);     // push king to stack\\n        \\n        while(!st.empty())\\n        {\\n            name = st.top();\\n      \\n            if(dead[name] != true)      // if the person is not dead, add it to the final list\\n                str.push_back(name);\\n            st.pop();\\n            \\n            auto p= umap.find(name);    // find top of stack into map\\n            if(p != umap.end())\\n            {\\n            v = p->second;\\n            for(i=v.size()-1; i>=0; i--)        // traverse all children of tos person and push them to stack\\n                st.push(v[i]);\\n            }\\n         }\\n        return str;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 869404,
                "title": "java-construct-inheritance-tree-map-and-dfs",
                "content": "```\\nclass ThroneInheritance {\\n    \\n    class TreeNode {\\n        String parent;\\n        List<TreeNode> children;\\n        boolean dead;\\n        \\n        public TreeNode(String parent) {\\n            this.parent = parent;\\n            this.children = new ArrayList<>();\\n        }\\n    }\\n    \\n    TreeNode kingdom;\\n    Map<String, TreeNode> map;\\n\\n    public ThroneInheritance(String kingName) {\\n        this.map = new HashMap<>();\\n        this.kingdom = new TreeNode(kingName);\\n        \\n        map.put(kingName, this.kingdom);\\n    }\\n    \\n    public void birth(String parentName, String childName) {\\n        TreeNode child = new TreeNode(childName);\\n        map.put(childName, child);\\n        \\n        map.get(parentName).children.add(child);\\n    }\\n    \\n    public void death(String name) {\\n        map.get(name).dead = true;\\n    }\\n    \\n    public List<String> getInheritanceOrder() {\\n        List<String> result = new ArrayList<>();\\n        \\n        dfs(kingdom, result); \\n        \\n        return result;\\n    }\\n    \\n    private void dfs(TreeNode parent, List<String> res) {\\n        if (!parent.dead) {\\n            res.add(parent.parent);\\n        }\\n        \\n        for (TreeNode t : parent.children) {\\n            dfs(t, res);\\n        }\\n    }\\n}\\n\\n/**\\n * Your ThroneInheritance object will be instantiated and called as such:\\n * ThroneInheritance obj = new ThroneInheritance(kingName);\\n * obj.birth(parentName,childName);\\n * obj.death(name);\\n * List<String> param_3 = obj.getInheritanceOrder();\\n */\\n```",
                "solutionTags": [],
                "code": "```\\nclass ThroneInheritance {\\n    \\n    class TreeNode {\\n        String parent;\\n        List<TreeNode> children;\\n        boolean dead;\\n        \\n        public TreeNode(String parent) {\\n            this.parent = parent;\\n            this.children = new ArrayList<>();\\n        }\\n    }\\n    \\n    TreeNode kingdom;\\n    Map<String, TreeNode> map;\\n\\n    public ThroneInheritance(String kingName) {\\n        this.map = new HashMap<>();\\n        this.kingdom = new TreeNode(kingName);\\n        \\n        map.put(kingName, this.kingdom);\\n    }\\n    \\n    public void birth(String parentName, String childName) {\\n        TreeNode child = new TreeNode(childName);\\n        map.put(childName, child);\\n        \\n        map.get(parentName).children.add(child);\\n    }\\n    \\n    public void death(String name) {\\n        map.get(name).dead = true;\\n    }\\n    \\n    public List<String> getInheritanceOrder() {\\n        List<String> result = new ArrayList<>();\\n        \\n        dfs(kingdom, result); \\n        \\n        return result;\\n    }\\n    \\n    private void dfs(TreeNode parent, List<String> res) {\\n        if (!parent.dead) {\\n            res.add(parent.parent);\\n        }\\n        \\n        for (TreeNode t : parent.children) {\\n            dfs(t, res);\\n        }\\n    }\\n}\\n\\n/**\\n * Your ThroneInheritance object will be instantiated and called as such:\\n * ThroneInheritance obj = new ThroneInheritance(kingName);\\n * obj.birth(parentName,childName);\\n * obj.death(name);\\n * List<String> param_3 = obj.getInheritanceOrder();\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 868793,
                "title": "golang-solution-instead-of-death-set-used-a-parameter-in-member",
                "content": "```golang\\ntype ThroneInheritance struct {\\n    king *member // root node\\n    nodeMap map[string]*member // node address map\\n    count int // total alive members in the family, just to optimize memory allocations in GetInheritanceOrder\\n}\\n\\ntype member struct {\\n    isDead bool\\n    name string\\n    children []*member\\n}\\n\\nfunc newMember(name string) *member {\\n    return &member{name: name}\\n}\\n\\nfunc Constructor(kingName string) ThroneInheritance {\\n    king := newMember(kingName)\\n    nodeMap := make(map[string]*member)\\n    nodeMap[kingName] = king\\n    return ThroneInheritance{king: king, nodeMap: nodeMap, count: 1}\\n}\\n\\nfunc (this *ThroneInheritance) Birth(parentName string, childName string)  {\\n    child := newMember(childName)\\n    this.nodeMap[parentName].children = append(this.nodeMap[parentName].children, child)\\n    this.nodeMap[childName] = child\\n    this.count++\\n}\\n\\nfunc (this *ThroneInheritance) Death(name string)  {\\n    this.nodeMap[name].isDead = true\\n    this.count--\\n}\\n\\nfunc (this *ThroneInheritance) GetInheritanceOrder() []string {\\n    result := make([]string, 0, this.count)\\n    var preorder func(root *member)\\n    preorder = func(root *member) {\\n        if root == nil {\\n            return\\n        }\\n        if root.isDead == false {\\n            result = append(result, root.name)\\n        }\\n        for _, child := range root.children {\\n            preorder(child)\\n        }\\n    }\\n    preorder(this.king)\\n    return result\\n}\\n```",
                "solutionTags": [],
                "code": "```golang\\ntype ThroneInheritance struct {\\n    king *member // root node\\n    nodeMap map[string]*member // node address map\\n    count int // total alive members in the family, just to optimize memory allocations in GetInheritanceOrder\\n}\\n\\ntype member struct {\\n    isDead bool\\n    name string\\n    children []*member\\n}\\n\\nfunc newMember(name string) *member {\\n    return &member{name: name}\\n}\\n\\nfunc Constructor(kingName string) ThroneInheritance {\\n    king := newMember(kingName)\\n    nodeMap := make(map[string]*member)\\n    nodeMap[kingName] = king\\n    return ThroneInheritance{king: king, nodeMap: nodeMap, count: 1}\\n}\\n\\nfunc (this *ThroneInheritance) Birth(parentName string, childName string)  {\\n    child := newMember(childName)\\n    this.nodeMap[parentName].children = append(this.nodeMap[parentName].children, child)\\n    this.nodeMap[childName] = child\\n    this.count++\\n}\\n\\nfunc (this *ThroneInheritance) Death(name string)  {\\n    this.nodeMap[name].isDead = true\\n    this.count--\\n}\\n\\nfunc (this *ThroneInheritance) GetInheritanceOrder() []string {\\n    result := make([]string, 0, this.count)\\n    var preorder func(root *member)\\n    preorder = func(root *member) {\\n        if root == nil {\\n            return\\n        }\\n        if root.isDead == false {\\n            result = append(result, root.name)\\n        }\\n        for _, child := range root.children {\\n            preorder(child)\\n        }\\n    }\\n    preorder(this.king)\\n    return result\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 868115,
                "title": "java-map-set-stack",
                "content": "Just used a stack instead of recursion.\\nMap the parent to the children. Insert all dead people to the set.\\nKey is to insert the children in reverse onto the stack for each person from the map.\\n\\n```\\nclass ThroneInheritance {\\n    \\n    ArrayList<String> curOrder;\\n    Set<String> deathSet;\\n    Map<String, List<String>> children;\\n    String king;\\n    Stack<String> stack = new Stack<String>();\\n\\n    public ThroneInheritance(String kingName) {\\n        curOrder = new ArrayList<String>();\\n        stack.push(kingName);\\n        deathSet = new HashSet<String>();\\n        children = new HashMap<>();\\n        king = kingName;\\n    }\\n    \\n    public void birth(String parentName, String childName) {\\n        children.putIfAbsent(parentName, new ArrayList<String>());\\n        children.get(parentName).add(childName);\\n    }\\n    \\n    public void death(String name) {\\n        deathSet.add(name);\\n    }\\n    \\n    public List<String> getInheritanceOrder() {\\n        curOrder = new ArrayList<String>();\\n        while(!stack.isEmpty()) {\\n            String curr = stack.pop();\\n            if(!deathSet.contains(curr)) { curOrder.add(curr); }\\n            List<String> curArr = children.get(curr);\\n            if(curArr == null) { continue; }\\n            int n = curArr.size();\\n            for(int i = n-1; i >= 0; i--) {\\n                stack.push(curArr.get(i));\\n            }\\n        }\\n        stack.push(king);\\n        return curOrder;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Stack"
                ],
                "code": "```\\nclass ThroneInheritance {\\n    \\n    ArrayList<String> curOrder;\\n    Set<String> deathSet;\\n    Map<String, List<String>> children;\\n    String king;\\n    Stack<String> stack = new Stack<String>();\\n\\n    public ThroneInheritance(String kingName) {\\n        curOrder = new ArrayList<String>();\\n        stack.push(kingName);\\n        deathSet = new HashSet<String>();\\n        children = new HashMap<>();\\n        king = kingName;\\n    }\\n    \\n    public void birth(String parentName, String childName) {\\n        children.putIfAbsent(parentName, new ArrayList<String>());\\n        children.get(parentName).add(childName);\\n    }\\n    \\n    public void death(String name) {\\n        deathSet.add(name);\\n    }\\n    \\n    public List<String> getInheritanceOrder() {\\n        curOrder = new ArrayList<String>();\\n        while(!stack.isEmpty()) {\\n            String curr = stack.pop();\\n            if(!deathSet.contains(curr)) { curOrder.add(curr); }\\n            List<String> curArr = children.get(curr);\\n            if(curArr == null) { continue; }\\n            int n = curArr.size();\\n            for(int i = n-1; i >= 0; i--) {\\n                stack.push(curArr.get(i));\\n            }\\n        }\\n        stack.push(king);\\n        return curOrder;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 866919,
                "title": "c-path-compression-in-birth-faster-than-dfs-100-runtime-memory",
                "content": "**Brief Explanation**\\nMaintain the inheritance order *(including the dead)* from the start in `inheritance_order_` list.\\nSimply iterate over  `inheritance_order_` list and filter out dead members during `getInheritanceOrder()`.\\n\\n```\\nclass ThroneInheritance {\\npublic:\\n    ThroneInheritance(string king_name) {\\n        auto it = inheritance_order_.emplace(inheritance_order_.end(), king_name);\\n        hash_[king_name] = it;\\n    }\\n    \\n    void birth(string parent_name, string child_name) {\\n        auto &it = hash_[parent_name];\\n        while(it != inheritance_order_.end() && it != hash_[*it]) {\\n            it = hash_[*it];\\n        }\\n        it = inheritance_order_.emplace(++it, child_name);\\n        hash_[child_name] = it;\\n    }\\n    \\n    void death(string name) {\\n        deaths_.insert(name);\\n    }\\n    \\n    vector<string> getInheritanceOrder() {\\n        vector<string> inheritance_order;\\n        for (const auto& current: inheritance_order_) {\\n            if (!deaths_.count(current)) {\\n                inheritance_order.push_back(current);\\n            }\\n        }\\n        return inheritance_order;\\n    }\\n    \\nprivate:\\n    unordered_set<string> deaths_;\\n    unordered_map<string, list<string>::iterator> hash_;\\n    list<string> inheritance_order_;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass ThroneInheritance {\\npublic:\\n    ThroneInheritance(string king_name) {\\n        auto it = inheritance_order_.emplace(inheritance_order_.end(), king_name);\\n        hash_[king_name] = it;\\n    }\\n    \\n    void birth(string parent_name, string child_name) {\\n        auto &it = hash_[parent_name];\\n        while(it != inheritance_order_.end() && it != hash_[*it]) {\\n            it = hash_[*it];\\n        }\\n        it = inheritance_order_.emplace(++it, child_name);\\n        hash_[child_name] = it;\\n    }\\n    \\n    void death(string name) {\\n        deaths_.insert(name);\\n    }\\n    \\n    vector<string> getInheritanceOrder() {\\n        vector<string> inheritance_order;\\n        for (const auto& current: inheritance_order_) {\\n            if (!deaths_.count(current)) {\\n                inheritance_order.push_back(current);\\n            }\\n        }\\n        return inheritance_order;\\n    }\\n    \\nprivate:\\n    unordered_set<string> deaths_;\\n    unordered_map<string, list<string>::iterator> hash_;\\n    list<string> inheritance_order_;\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 866884,
                "title": "java-easy-hashmap",
                "content": "````\\n Map<String, Boolean> alive;\\n    Map<String, LinkedList<String>> family;\\n    String root;\\n\\n    public ThroneInheritance(String kingName) {\\n        root = kingName;\\n        alive = new HashMap<>();\\n        family = new HashMap<>();\\n        family.put(kingName, new LinkedList<>());\\n        alive.put(kingName, true);\\n    }\\n\\n    public void birth(String parentName, String childName) {\\n        family.get(parentName).add(childName);\\n        family.put(childName, new LinkedList<>());\\n        alive.put(childName, true);\\n    }\\n\\n    public void death(String name) {\\n        alive.put(name, false);\\n    }\\n\\n\\n    public List<String> getInheritanceOrder() {\\n        List<String> list = new LinkedList<>();\\n        dfs(root, list);\\n        return list;\\n    }\\n\\n    private void dfs(String root, List<String> list) {\\n        if (alive.get(root)) {\\n            list.add(root);\\n        }\\n\\n        if (family.get(root) != null) {\\n            for (String s : family.get(root)) {\\n                dfs(s, list);\\n            }\\n        }\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "````\\n Map<String, Boolean> alive;\\n    Map<String, LinkedList<String>> family;\\n    String root;\\n\\n    public ThroneInheritance(String kingName) {\\n        root = kingName;\\n        alive = new HashMap<>();\\n        family = new HashMap<>();\\n        family.put(kingName, new LinkedList<>());\\n        alive.put(kingName, true);\\n    }\\n\\n    public void birth(String parentName, String childName) {\\n        family.get(parentName).add(childName);\\n        family.put(childName, new LinkedList<>());\\n        alive.put(childName, true);\\n    }\\n\\n    public void death(String name) {\\n        alive.put(name, false);\\n    }\\n\\n\\n    public List<String> getInheritanceOrder() {\\n        List<String> list = new LinkedList<>();\\n        dfs(root, list);\\n        return list;\\n    }\\n\\n    private void dfs(String root, List<String> list) {\\n        if (alive.get(root)) {\\n            list.add(root);\\n        }\\n\\n        if (family.get(root) != null) {\\n            for (String s : family.get(root)) {\\n                dfs(s, list);\\n            }\\n        }\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 866832,
                "title": "javascript-100",
                "content": "```\\n/**\\n * @param {string} kingName\\n */\\nvar ThroneInheritance = function(kingName) {\\n    this.list = {name: kingName, children:[]};\\n    this.map = {};\\n    this.map[kingName] = this.list;\\n};\\n\\n/** \\n * @param {string} parentName \\n * @param {string} childName\\n * @return {void}\\n */\\nThroneInheritance.prototype.birth = function(parentName, childName) {\\n    const p = this.map[parentName];\\n    const c = {name: childName, children: []};\\n    p.children.push(c);\\n    this.map[childName] = c;\\n};\\n\\n/** \\n * @param {string} name\\n * @return {void}\\n */\\nThroneInheritance.prototype.death = function(name) {\\n    this.map[name].isDead = true;\\n};\\n\\n/**\\n * @return {string[]}\\n */\\nThroneInheritance.prototype.getInheritanceOrder = function() {\\n    let result = [];\\n    const getResult = function(p) {\\n        if (!p.isDead) {\\n            result.push(p.name);\\n        }\\n        p.children.forEach(getResult);\\n    };\\n    getResult(this.list);\\n    return result;\\n};\\n\\n/** \\n * Your ThroneInheritance object will be instantiated and called as such:\\n * var obj = new ThroneInheritance(kingName)\\n * obj.birth(parentName,childName)\\n * obj.death(name)\\n * var param_3 = obj.getInheritanceOrder()\\n */\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * @param {string} kingName\\n */\\nvar ThroneInheritance = function(kingName) {\\n    this.list = {name: kingName, children:[]};\\n    this.map = {};\\n    this.map[kingName] = this.list;\\n};\\n\\n/** \\n * @param {string} parentName \\n * @param {string} childName\\n * @return {void}\\n */\\nThroneInheritance.prototype.birth = function(parentName, childName) {\\n    const p = this.map[parentName];\\n    const c = {name: childName, children: []};\\n    p.children.push(c);\\n    this.map[childName] = c;\\n};\\n\\n/** \\n * @param {string} name\\n * @return {void}\\n */\\nThroneInheritance.prototype.death = function(name) {\\n    this.map[name].isDead = true;\\n};\\n\\n/**\\n * @return {string[]}\\n */\\nThroneInheritance.prototype.getInheritanceOrder = function() {\\n    let result = [];\\n    const getResult = function(p) {\\n        if (!p.isDead) {\\n            result.push(p.name);\\n        }\\n        p.children.forEach(getResult);\\n    };\\n    getResult(this.list);\\n    return result;\\n};\\n\\n/** \\n * Your ThroneInheritance object will be instantiated and called as such:\\n * var obj = new ThroneInheritance(kingName)\\n * obj.birth(parentName,childName)\\n * obj.death(name)\\n * var param_3 = obj.getInheritanceOrder()\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 866768,
                "title": "python3-faster-than-100",
                "content": "```\\nimport collections\\nclass ThroneInheritance:\\n\\n    def __init__(self, kingName: str):\\n        self.king=kingName\\n        self.children = collections.defaultdict(list)\\n        self.dead=collections.defaultdict(bool)\\n\\n    def birth(self, parentName: str, childName: str) -> None:\\n        \\n        self.children[parentName].append(childName)\\n\\n    def death(self, name: str) -> None:\\n        self.dead[name]=True\\n\\n    def getInheritanceOrder(self) -> List[str]:\\n        \\n        stack=[self.king]\\n        ans=[]\\n        while stack:\\n            node=stack.pop()\\n            if not self.dead[node]: ans.append(node)\\n            for child in reversed(self.children[node]):\\n                stack.append(child)\\n\\n        return ans\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nimport collections\\nclass ThroneInheritance:\\n\\n    def __init__(self, kingName: str):\\n        self.king=kingName\\n        self.children = collections.defaultdict(list)\\n        self.dead=collections.defaultdict(bool)\\n\\n    def birth(self, parentName: str, childName: str) -> None:\\n        \\n        self.children[parentName].append(childName)\\n\\n    def death(self, name: str) -> None:\\n        self.dead[name]=True\\n\\n    def getInheritanceOrder(self) -> List[str]:\\n        \\n        stack=[self.king]\\n        ans=[]\\n        while stack:\\n            node=stack.pop()\\n            if not self.dead[node]: ans.append(node)\\n            for child in reversed(self.children[node]):\\n                stack.append(child)\\n\\n        return ans\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 866692,
                "title": "set-for-deathlist-matters-a-lot",
                "content": "This is not difficult question. However during contest I\\'m always having issue passing the last big test case. Then I tried a lot like memoization blabla.\\nIt turns out I used List for deathList, but NOT Set. I\\u2018d assume not to much difference because people only die once, we won\\'t keep adding duplicate. However, Set.contains() is O(1) while List.contains() is O(n)\\n\\u7EC6\\u8282\\u51B3\\u5B9A\\u6210\\u8D25~~~\\n```\\nclass ThroneInheritance {\\n\\n    Map<String, List<String>> map;\\n    String kingName;\\n    Set<String> deathList;\\n    public ThroneInheritance(String kingName) {\\n        this.kingName = kingName;\\n        deathList = new HashSet<>();\\n        map = new HashMap<>();\\n    }\\n    \\n    public void birth(String parentName, String childName) {\\n        if (!map.containsKey(parentName)) {\\n            map.put(parentName, new ArrayList<>());\\n        }\\n        map.get(parentName).add(childName);\\n    \\n    }\\n    \\n    public void death(String name) {      \\n        deathList.add(name);\\n    }\\n    \\n    public List<String> getInheritanceOrder() {\\n        return dfs(kingName, deathList);\\n    }\\n    \\n    \\n    public List<String> dfs(String name, Set<String> deathList) {\\n        List<String> path = new ArrayList<>();\\n\\n        if (!deathList.contains(name))\\n            path.add(name);\\n        \\n        List<String> children = map.getOrDefault(name, new ArrayList<>());\\n        for (String child : children) {\\n            path.addAll(dfs(child, deathList));\\n        }\\n        \\n        return path;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass ThroneInheritance {\\n\\n    Map<String, List<String>> map;\\n    String kingName;\\n    Set<String> deathList;\\n    public ThroneInheritance(String kingName) {\\n        this.kingName = kingName;\\n        deathList = new HashSet<>();\\n        map = new HashMap<>();\\n    }\\n    \\n    public void birth(String parentName, String childName) {\\n        if (!map.containsKey(parentName)) {\\n            map.put(parentName, new ArrayList<>());\\n        }\\n        map.get(parentName).add(childName);\\n    \\n    }\\n    \\n    public void death(String name) {      \\n        deathList.add(name);\\n    }\\n    \\n    public List<String> getInheritanceOrder() {\\n        return dfs(kingName, deathList);\\n    }\\n    \\n    \\n    public List<String> dfs(String name, Set<String> deathList) {\\n        List<String> path = new ArrayList<>();\\n\\n        if (!deathList.contains(name))\\n            path.add(name);\\n        \\n        List<String> children = map.getOrDefault(name, new ArrayList<>());\\n        for (String child : children) {\\n            path.addAll(dfs(child, deathList));\\n        }\\n        \\n        return path;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 866609,
                "title": "faster-than-100-python",
                "content": "```\\nclass ThroneInheritance(object):\\n\\n    def __init__(self, kingName):\\n        \"\"\"\\n        :type kingName: str\\n        \"\"\"\\n        self.hashT = {}\\n        self.hashT[kingName] = []\\n        self.kingName = kingName\\n        self.death_list = set()\\n        return None\\n        \\n\\n    def birth(self, parentName, childName):\\n        \"\"\"\\n        :type parentName: str\\n        :type childName: str\\n        :rtype: None\\n        \"\"\"\\n        self.hashT[childName] = []\\n        self.hashT[parentName].append(childName)\\n        return None\\n        \\n\\n    def death(self, name):\\n        \"\"\"\\n        :type name: str\\n        :rtype: None\\n        \"\"\"\\n        self.death_list.add(name)\\n        return None\\n        \\n\\n    def getInheritanceOrder(self):\\n        \"\"\"\\n        :rtype: List[str]\\n        \"\"\"\\n        def getOrder(root, out):\\n            if root not in self.death_list:\\n                out.append(root)\\n            for child in self.hashT[root]:\\n                out = getOrder(child, out)\\n            return out\\n        \\n        out = getOrder(self.kingName, [])\\n    \\n        return out\\n```",
                "solutionTags": [],
                "code": "```\\nclass ThroneInheritance(object):\\n\\n    def __init__(self, kingName):\\n        \"\"\"\\n        :type kingName: str\\n        \"\"\"\\n        self.hashT = {}\\n        self.hashT[kingName] = []\\n        self.kingName = kingName\\n        self.death_list = set()\\n        return None\\n        \\n\\n    def birth(self, parentName, childName):\\n        \"\"\"\\n        :type parentName: str\\n        :type childName: str\\n        :rtype: None\\n        \"\"\"\\n        self.hashT[childName] = []\\n        self.hashT[parentName].append(childName)\\n        return None\\n        \\n\\n    def death(self, name):\\n        \"\"\"\\n        :type name: str\\n        :rtype: None\\n        \"\"\"\\n        self.death_list.add(name)\\n        return None\\n        \\n\\n    def getInheritanceOrder(self):\\n        \"\"\"\\n        :rtype: List[str]\\n        \"\"\"\\n        def getOrder(root, out):\\n            if root not in self.death_list:\\n                out.append(root)\\n            for child in self.hashT[root]:\\n                out = getOrder(child, out)\\n            return out\\n        \\n        out = getOrder(self.kingName, [])\\n    \\n        return out\\n```",
                "codeTag": "Java"
            },
            {
                "id": 866588,
                "title": "java-dfs-preorder-solution-o-n",
                "content": "Create a tree for the family.\\n```birth``` - When a parent gave birth to a child, creating a new node in the parent\\'s children list.\\n```death``` - When someone is dead, set the ```isDead``` flag ture. So, when calling ```getInheritanceOrder()```, this node will be ignored.\\n```getInheritanceOrder``` - Find the preorder of the family tree.\\n\\n```\\nclass ThroneInheritance {\\n\\n    class Node{\\n        Node parent;\\n        String name;\\n        boolean isDead = false;\\n        List<Node> children = new ArrayList<>();\\n        Node(String n) { this.name = n; }\\n    }\\n    \\n    Node root;\\n    HashMap<String, Node> map = new HashMap<>();\\n    \\n    public ThroneInheritance(String kingName) {\\n        root = new Node(kingName);\\n        map.put(kingName, root);\\n    }\\n    \\n    public void birth(String parentName, String childName) {\\n        Node parent = map.get(parentName);\\n        Node child = new Node(childName);\\n        child.parent = parent;\\n        parent.children.add(child);\\n        map.put(childName, child);\\n    }\\n    \\n    public void death(String name) {\\n        Node dead = map.remove(name);\\n        dead.isDead = true;\\n    }\\n    \\n    public List<String> getInheritanceOrder() {\\n        List<String> ans = new ArrayList<>();\\n        dfs(root, ans);\\n        return ans;\\n    }\\n    \\n    private void dfs(Node root, List<String> ans) {\\n        if(root == null) return;\\n        if(!root.isDead) ans.add(root.name);\\n        for(Node child : root.children) {\\n            dfs(child, ans);\\n        }\\n    }\\n}\\n```\\n\\n* Time: \\n```birth = O(1)```\\n```death = O(1)```\\n```getInheritanceOrder = O(N)```\\n* Space: ```O(N)```",
                "solutionTags": [],
                "code": "```birth```\n```death```\n```isDead```\n```getInheritanceOrder()```\n```getInheritanceOrder```\n```\\nclass ThroneInheritance {\\n\\n    class Node{\\n        Node parent;\\n        String name;\\n        boolean isDead = false;\\n        List<Node> children = new ArrayList<>();\\n        Node(String n) { this.name = n; }\\n    }\\n    \\n    Node root;\\n    HashMap<String, Node> map = new HashMap<>();\\n    \\n    public ThroneInheritance(String kingName) {\\n        root = new Node(kingName);\\n        map.put(kingName, root);\\n    }\\n    \\n    public void birth(String parentName, String childName) {\\n        Node parent = map.get(parentName);\\n        Node child = new Node(childName);\\n        child.parent = parent;\\n        parent.children.add(child);\\n        map.put(childName, child);\\n    }\\n    \\n    public void death(String name) {\\n        Node dead = map.remove(name);\\n        dead.isDead = true;\\n    }\\n    \\n    public List<String> getInheritanceOrder() {\\n        List<String> ans = new ArrayList<>();\\n        dfs(root, ans);\\n        return ans;\\n    }\\n    \\n    private void dfs(Node root, List<String> ans) {\\n        if(root == null) return;\\n        if(!root.isDead) ans.add(root.name);\\n        for(Node child : root.children) {\\n            dfs(child, ans);\\n        }\\n    }\\n}\\n```\n```birth = O(1)```\n```death = O(1)```\n```getInheritanceOrder = O(N)```\n```O(N)```",
                "codeTag": "Java"
            },
            {
                "id": 866584,
                "title": "cpp-simple-dfs-beats-100-in-time",
                "content": "```\\nclass ThroneInheritance {\\npublic:\\n    struct Node\\n    {\\n        string name;\\n        bool alive=true;\\n        vector<Node *> child; \\n    };\\n    Node *new1(string as)\\n    {\\n        Node *temp=new Node();\\n        temp->name=as;\\n        return temp;\\n    }    \\n    Node *root=NULL;   \\n    unordered_map<string,pair<Node*,Node*>> mp;\\n    ThroneInheritance(string kingName) {\\n        root=new1(kingName);\\n        mp[kingName]={root,NULL};\\n    }\\n    \\n    void birth(string parentName, string childName) {\\n       auto it=mp.find(parentName);\\n                pair<Node*,Node*> p=it->second;\\n                Node *t=new1(childName);\\n                (p.first->child).push_back(t);\\n                mp.insert(make_pair(childName,make_pair(t,p.first)));\\n          \\n    \\n    }\\n    \\n    void death(string name) {\\n         auto it=mp.find(name);  \\n        if(it->first==name)\\n             {\\n                pair<Node*,Node*> p=it->second;\\n                p.first->alive=false;\\n               // break;\\n                 \\n             }\\n         \\n    }\\n    void dfs(Node *q,vector<string> &ans, map<string,bool> &mp)\\n    {\\n\\n        if(q->alive==true)\\n                    ans.push_back(q->name);\\n                for(int i=0;i<q->child.size();i++)\\n                {   \\n                  dfs(q->child[i],ans,mp);     \\n                \\n                }\\n    }\\n    vector<string> getInheritanceOrder() {\\n    \\n        vector<string> ans;\\n        ans.clear();\\n        if(root==NULL)return {};\\n        map<string,bool> mp;\\n        dfs(root,ans,mp);\\n       \\n        return ans;\\n        \\n    }\\n};\\n\\n\\n\\n/**\\n * Your ThroneInheritance object will be instantiated and called as such:\\n * ThroneInheritance* obj = new ThroneInheritance(kingName);\\n * obj->birth(parentName,childName);\\n * obj->death(name);\\n * vector<string> param_3 = obj->getInheritanceOrder();\\n */",
                "solutionTags": [],
                "code": "```\\nclass ThroneInheritance {\\npublic:\\n    struct Node\\n    {\\n        string name;\\n        bool alive=true;\\n        vector<Node *> child; \\n    };\\n    Node *new1(string as)\\n    {\\n        Node *temp=new Node();\\n        temp->name=as;\\n        return temp;\\n    }    \\n    Node *root=NULL;   \\n    unordered_map<string,pair<Node*,Node*>> mp;\\n    ThroneInheritance(string kingName) {\\n        root=new1(kingName);\\n        mp[kingName]={root,NULL};\\n    }\\n    \\n    void birth(string parentName, string childName) {\\n       auto it=mp.find(parentName);\\n                pair<Node*,Node*> p=it->second;\\n                Node *t=new1(childName);\\n                (p.first->child).push_back(t);\\n                mp.insert(make_pair(childName,make_pair(t,p.first)));\\n          \\n    \\n    }\\n    \\n    void death(string name) {\\n         auto it=mp.find(name);  \\n        if(it->first==name)\\n             {\\n                pair<Node*,Node*> p=it->second;\\n                p.first->alive=false;\\n               // break;\\n                 \\n             }\\n         \\n    }\\n    void dfs(Node *q,vector<string> &ans, map<string,bool> &mp)\\n    {\\n\\n        if(q->alive==true)\\n                    ans.push_back(q->name);\\n                for(int i=0;i<q->child.size();i++)\\n                {   \\n                  dfs(q->child[i],ans,mp);     \\n                \\n                }\\n    }\\n    vector<string> getInheritanceOrder() {\\n    \\n        vector<string> ans;\\n        ans.clear();\\n        if(root==NULL)return {};\\n        map<string,bool> mp;\\n        dfs(root,ans,mp);\\n       \\n        return ans;\\n        \\n    }\\n};\\n\\n\\n\\n/**\\n * Your ThroneInheritance object will be instantiated and called as such:\\n * ThroneInheritance* obj = new ThroneInheritance(kingName);\\n * obj->birth(parentName,childName);\\n * obj->death(name);\\n * vector<string> param_3 = obj->getInheritanceOrder();\\n */",
                "codeTag": "Java"
            },
            {
                "id": 866500,
                "title": "javascript-hashmap-with-deadlist",
                "content": "```\\nvar bloodList = function(name, parent = null) {\\n    return {\\n        name,\\n        children: []\\n    };\\n}\\n\\nvar ThroneInheritance = function(kingName) {\\n    this.nameMap = new Map();\\n    this.nameMap.set(kingName, bloodList(kingName));\\n    this.king = kingName;\\n    this.deadList = new Set();\\n};\\n\\n/** \\n * @param {string} parentName \\n * @param {string} childName\\n * @return {void}\\n */\\nThroneInheritance.prototype.birth = function(parentName, childName) {\\n    const parent = this.nameMap.get(parentName);\\n    const childId = bloodList(childName, parent);\\n    this.nameMap.set(childName, childId);\\n    parent.children.push(childId);\\n};\\n\\n/** \\n * @param {string} name\\n * @return {void}\\n */\\nThroneInheritance.prototype.death = function(name) {\\n    this.deadList.add(name);\\n};\\n\\n/**\\n * @return {string[]}\\n */\\nfunction updateList(list, nameId, deadList) {\\n    if (!deadList.has(nameId.name))\\n        list.push(nameId.name);\\n    \\n    for (let child of nameId.children) {\\n        updateList(list, child, deadList);\\n    }\\n}\\n\\nThroneInheritance.prototype.getInheritanceOrder = function() {\\n    let list = [];\\n    updateList(list, this.nameMap.get(this.king), this.deadList);\\n    return list;\\n};\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar bloodList = function(name, parent = null) {\\n    return {\\n        name,\\n        children: []\\n    };\\n}\\n\\nvar ThroneInheritance = function(kingName) {\\n    this.nameMap = new Map();\\n    this.nameMap.set(kingName, bloodList(kingName));\\n    this.king = kingName;\\n    this.deadList = new Set();\\n};\\n\\n/** \\n * @param {string} parentName \\n * @param {string} childName\\n * @return {void}\\n */\\nThroneInheritance.prototype.birth = function(parentName, childName) {\\n    const parent = this.nameMap.get(parentName);\\n    const childId = bloodList(childName, parent);\\n    this.nameMap.set(childName, childId);\\n    parent.children.push(childId);\\n};\\n\\n/** \\n * @param {string} name\\n * @return {void}\\n */\\nThroneInheritance.prototype.death = function(name) {\\n    this.deadList.add(name);\\n};\\n\\n/**\\n * @return {string[]}\\n */\\nfunction updateList(list, nameId, deadList) {\\n    if (!deadList.has(nameId.name))\\n        list.push(nameId.name);\\n    \\n    for (let child of nameId.children) {\\n        updateList(list, child, deadList);\\n    }\\n}\\n\\nThroneInheritance.prototype.getInheritanceOrder = function() {\\n    let list = [];\\n    updateList(list, this.nameMap.get(this.king), this.deadList);\\n    return list;\\n};\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 866499,
                "title": "dfs-traversal-c",
                "content": "simple dfs traversal\\n```\\nclass ThroneInheritance {\\n    map<string,vector<string>> m;\\n    string king;\\n    unordered_set<string> s;\\npublic:\\n    ThroneInheritance(string kingName) {\\n        king = kingName;\\n    }\\n    \\n    void birth(string parentName, string childName) {\\n        m[parentName].push_back(childName);\\n    }\\n    \\n    void death(string name) {\\n        s.insert(name);\\n    }\\n    \\n    void dfs(string vx,map<string,vector<string>>& m,vector<string>& ans)\\n    {\\n        if(s.count(vx) <= 0)\\n            ans.push_back(vx);\\n        auto it = m[vx];\\n        for(string x:it)\\n        {\\n            dfs(x,m,ans);\\n        }\\n    }\\n    vector<string> getInheritanceOrder() {\\n        vector<string> ans;\\n        dfs(king,m,ans);\\n        return ans;\\n    }\\n};\\n\\n/**\\n * Your ThroneInheritance object will be instantiated and called as such:\\n * ThroneInheritance* obj = new ThroneInheritance(kingName);\\n * obj->birth(parentName,childName);\\n * obj->death(name);\\n * vector<string> param_3 = obj->getInheritanceOrder();\\n */\\n```",
                "solutionTags": [],
                "code": "```\\nclass ThroneInheritance {\\n    map<string,vector<string>> m;\\n    string king;\\n    unordered_set<string> s;\\npublic:\\n    ThroneInheritance(string kingName) {\\n        king = kingName;\\n    }\\n    \\n    void birth(string parentName, string childName) {\\n        m[parentName].push_back(childName);\\n    }\\n    \\n    void death(string name) {\\n        s.insert(name);\\n    }\\n    \\n    void dfs(string vx,map<string,vector<string>>& m,vector<string>& ans)\\n    {\\n        if(s.count(vx) <= 0)\\n            ans.push_back(vx);\\n        auto it = m[vx];\\n        for(string x:it)\\n        {\\n            dfs(x,m,ans);\\n        }\\n    }\\n    vector<string> getInheritanceOrder() {\\n        vector<string> ans;\\n        dfs(king,m,ans);\\n        return ans;\\n    }\\n};\\n\\n/**\\n * Your ThroneInheritance object will be instantiated and called as such:\\n * ThroneInheritance* obj = new ThroneInheritance(kingName);\\n * obj->birth(parentName,childName);\\n * obj->death(name);\\n * vector<string> param_3 = obj->getInheritanceOrder();\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 866498,
                "title": "easy-c-solution-using-n-ary-tree",
                "content": "```\\nclass ThroneInheritance {\\npublic:\\n    class Person{\\n        public:\\n        bool isDead;\\n        vector<Person*> children;\\n        string name;\\n        Person(string nam){\\n            isDead=false;\\n            name=nam;\\n        }\\n        void die(){\\n            isDead=true;\\n        }\\n    };\\n    Person* family;\\n    unordered_map<string,Person*> people;\\n    ThroneInheritance(string kingName) {\\n        family=new Person(kingName);\\n        people[kingName]=family;\\n    }\\n    \\n    void birth(string parentName, string childName) {\\n        Person* father=people[parentName];\\n        Person* child=new Person(childName);\\n        people[childName]=child;\\n        father->children.push_back(child);\\n    }\\n    \\n    void death(string name) {\\n        people[name]->die();\\n    }\\n    \\n    vector<string> getInheritanceOrder() {\\n        vector<string> order;\\n        getOrder(family,order);\\n        return order;\\n    }\\n    void getOrder(Person* root,vector<string>& order)\\n    {\\n        if(!root->isDead)\\n            order.push_back(root->name);\\n        for(Person* child:root->children)\\n        {\\n            getOrder(child,order);\\n        }\\n    }\\n};\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass ThroneInheritance {\\npublic:\\n    class Person{\\n        public:\\n        bool isDead;\\n        vector<Person*> children;\\n        string name;\\n        Person(string nam){\\n            isDead=false;\\n            name=nam;\\n        }\\n        void die(){\\n            isDead=true;\\n        }\\n    };\\n    Person* family;\\n    unordered_map<string,Person*> people;\\n    ThroneInheritance(string kingName) {\\n        family=new Person(kingName);\\n        people[kingName]=family;\\n    }\\n    \\n    void birth(string parentName, string childName) {\\n        Person* father=people[parentName];\\n        Person* child=new Person(childName);\\n        people[childName]=child;\\n        father->children.push_back(child);\\n    }\\n    \\n    void death(string name) {\\n        people[name]->die();\\n    }\\n    \\n    vector<string> getInheritanceOrder() {\\n        vector<string> order;\\n        getOrder(family,order);\\n        return order;\\n    }\\n    void getOrder(Person* root,vector<string>& order)\\n    {\\n        if(!root->isDead)\\n            order.push_back(root->name);\\n        for(Person* child:root->children)\\n        {\\n            getOrder(child,order);\\n        }\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 866484,
                "title": "js-map-n-ary-tree",
                "content": "\\tfunction People(name, parentName) {\\n\\t\\tthis.name = name;\\n\\t\\tthis.isLive = true;\\n\\t\\tthis.parentName = parentName;\\n\\t\\tthis.children = [];\\n\\n\\t\\treturn this;\\n\\t}\\n\\n\\tvar ThroneInheritance = function(kingName) {\\n\\t\\tthis.map = {};\\n\\t\\tthis.map[kingName] = new People(kingName);\\n\\t\\tthis.kingName = kingName;\\n\\t};\\n\\n\\t/** \\n\\t * @param {string} parentName \\n\\t * @param {string} childName\\n\\t * @return {void}\\n\\t */\\n\\tThroneInheritance.prototype.birth = function(parentName, childName) {\\n\\t\\tconst people = new People(childName, parentName);\\n\\t\\tconst parent = this.map[parentName];\\n\\t\\tparent.children.push(people);\\n\\t\\tthis.map[childName] = people;\\n\\t};\\n\\n\\t/** \\n\\t * @param {string} name\\n\\t * @return {void}\\n\\t */\\n\\tThroneInheritance.prototype.death = function(name) {\\n\\t\\tthis.map[name].isLive = false;\\n\\t};\\n\\n\\t/**\\n\\t * @return {string[]}\\n\\t */\\n\\tThroneInheritance.prototype.getInheritanceOrder = function() {\\n\\t\\tconst res = [];\\n\\t\\tdfs(this.map[this.kingName])\\n\\n\\t\\treturn res;\\n\\n\\t\\tfunction dfs(root) {\\n\\t\\t\\tif (!root) return;\\n\\t\\t\\tif (root.isLive) {\\n\\t\\t\\t\\tres.push(root.name);\\n\\t\\t\\t}\\n\\n\\t\\t\\tfor (let child of root.children) {\\n\\t\\t\\t\\tdfs(child);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t};\\n",
                "solutionTags": [],
                "code": "\\tfunction People(name, parentName) {\\n\\t\\tthis.name = name;\\n\\t\\tthis.isLive = true;\\n\\t\\tthis.parentName = parentName;\\n\\t\\tthis.children = [];\\n\\n\\t\\treturn this;\\n\\t}\\n\\n\\tvar ThroneInheritance = function(kingName) {\\n\\t\\tthis.map = {};\\n\\t\\tthis.map[kingName] = new People(kingName);\\n\\t\\tthis.kingName = kingName;\\n\\t};\\n\\n\\t/** \\n\\t * @param {string} parentName \\n\\t * @param {string} childName\\n\\t * @return {void}\\n\\t */\\n\\tThroneInheritance.prototype.birth = function(parentName, childName) {\\n\\t\\tconst people = new People(childName, parentName);\\n\\t\\tconst parent = this.map[parentName];\\n\\t\\tparent.children.push(people);\\n\\t\\tthis.map[childName] = people;\\n\\t};\\n\\n\\t/** \\n\\t * @param {string} name\\n\\t * @return {void}\\n\\t */\\n\\tThroneInheritance.prototype.death = function(name) {\\n\\t\\tthis.map[name].isLive = false;\\n\\t};\\n\\n\\t/**\\n\\t * @return {string[]}\\n\\t */\\n\\tThroneInheritance.prototype.getInheritanceOrder = function() {\\n\\t\\tconst res = [];\\n\\t\\tdfs(this.map[this.kingName])\\n\\n\\t\\treturn res;\\n\\n\\t\\tfunction dfs(root) {\\n\\t\\t\\tif (!root) return;\\n\\t\\t\\tif (root.isLive) {\\n\\t\\t\\t\\tres.push(root.name);\\n\\t\\t\\t}\\n\\n\\t\\t\\tfor (let child of root.children) {\\n\\t\\t\\t\\tdfs(child);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t};\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 866382,
                "title": "dfs-java",
                "content": "```\\n\\nclass ThroneInheritance {\\n    Map<String, List<String>> map;\\n    Map<String, Boolean> aliveMap;\\n    public ThroneInheritance(String kingName) {\\n        map = new HashMap<>();\\n        aliveMap = new HashMap<>();\\n        map.put(kingName, new ArrayList<>());\\n        aliveMap.put(kingName, true);\\n    }\\n\\n    public void birth(String parentName, String childName) {\\n        List<String> childs = map.get(parentName);\\n        map.putIfAbsent(childName, new ArrayList<>());\\n        childs.add(childName);\\n        aliveMap.put(childName, true);\\n    }\\n\\n    public void death(String name) {\\n        aliveMap.put(name, false);\\n    }\\n\\n    public List<String> getInheritanceOrder() {\\n        List<String> curorder = new ArrayList<>();\\n        dfs(\"king\", curorder);\\n        return curorder;\\n    }\\n\\n    public void dfs(String cur, List<String> order){\\n        if(aliveMap.get(cur)){\\n            order.add(cur);\\n        }\\n        List<String> childdren = map.get(cur);\\n        if(childdren == null) return;\\n        for (String child : childdren){\\n            dfs(child, order);\\n        }\\n    }\\n}\\n\\n```",
                "solutionTags": [],
                "code": "```\\n\\nclass ThroneInheritance {\\n    Map<String, List<String>> map;\\n    Map<String, Boolean> aliveMap;\\n    public ThroneInheritance(String kingName) {\\n        map = new HashMap<>();\\n        aliveMap = new HashMap<>();\\n        map.put(kingName, new ArrayList<>());\\n        aliveMap.put(kingName, true);\\n    }\\n\\n    public void birth(String parentName, String childName) {\\n        List<String> childs = map.get(parentName);\\n        map.putIfAbsent(childName, new ArrayList<>());\\n        childs.add(childName);\\n        aliveMap.put(childName, true);\\n    }\\n\\n    public void death(String name) {\\n        aliveMap.put(name, false);\\n    }\\n\\n    public List<String> getInheritanceOrder() {\\n        List<String> curorder = new ArrayList<>();\\n        dfs(\"king\", curorder);\\n        return curorder;\\n    }\\n\\n    public void dfs(String cur, List<String> order){\\n        if(aliveMap.get(cur)){\\n            order.add(cur);\\n        }\\n        List<String> childdren = map.get(cur);\\n        if(childdren == null) return;\\n        for (String child : childdren){\\n            dfs(child, order);\\n        }\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4084837,
                "title": "beats-100-runtime-c-hash-table-n-ary-tree",
                "content": "\\n\\n# Code\\n```\\nclass Node\\n{\\n    public:\\n        string name;\\n        bool alive=true;\\n        vector<Node*> children;\\n        Node(){}\\n        Node(string name)\\n        {\\n            this->alive = true;\\n            this->name = name;\\n        }\\n};\\nclass ThroneInheritance {\\npublic:\\n    Node * root;\\n    unordered_map<string,Node*> hash;\\n    ThroneInheritance(string kingName) {\\n        root = new Node(kingName);\\n        hash[kingName] = root;\\n    }\\n    \\n    \\n    void birth(string parentName, string childName) {\\n    Node * newNode = new Node(childName);\\n       hash[parentName]->children.push_back(newNode);\\n       hash[childName] = newNode;\\n        \\n    }\\n \\n    void death(string name) {\\n        hash[name]->alive = false;\\n    }\\n    \\n    void preorder(Node* root,vector<string> &ans)\\n    {\\n        if (root != NULL)\\n        {\\n            if (root->alive)\\n            {\\n                ans.push_back(root->name);\\n            }\\n           \\n            for (int i = 0;i<root->children.size();i++)\\n            {\\n                preorder(root->children[i],ans);\\n            }\\n        }\\n    }\\n    vector<string> getInheritanceOrder() {\\n        vector<string> ans;\\n        preorder(root,ans);\\n        return ans;\\n    }\\n};\\n\\n/**\\n * Your ThroneInheritance object will be instantiated and called as such:\\n * ThroneInheritance* obj = new ThroneInheritance(kingName);\\n * obj->birth(parentName,childName);\\n * obj->death(name);\\n * vector<string> param_3 = obj->getInheritanceOrder();\\n */\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Tree"
                ],
                "code": "```\\nclass Node\\n{\\n    public:\\n        string name;\\n        bool alive=true;\\n        vector<Node*> children;\\n        Node(){}\\n        Node(string name)\\n        {\\n            this->alive = true;\\n            this->name = name;\\n        }\\n};\\nclass ThroneInheritance {\\npublic:\\n    Node * root;\\n    unordered_map<string,Node*> hash;\\n    ThroneInheritance(string kingName) {\\n        root = new Node(kingName);\\n        hash[kingName] = root;\\n    }\\n    \\n    \\n    void birth(string parentName, string childName) {\\n    Node * newNode = new Node(childName);\\n       hash[parentName]->children.push_back(newNode);\\n       hash[childName] = newNode;\\n        \\n    }\\n \\n    void death(string name) {\\n        hash[name]->alive = false;\\n    }\\n    \\n    void preorder(Node* root,vector<string> &ans)\\n    {\\n        if (root != NULL)\\n        {\\n            if (root->alive)\\n            {\\n                ans.push_back(root->name);\\n            }\\n           \\n            for (int i = 0;i<root->children.size();i++)\\n            {\\n                preorder(root->children[i],ans);\\n            }\\n        }\\n    }\\n    vector<string> getInheritanceOrder() {\\n        vector<string> ans;\\n        preorder(root,ans);\\n        return ans;\\n    }\\n};\\n\\n/**\\n * Your ThroneInheritance object will be instantiated and called as such:\\n * ThroneInheritance* obj = new ThroneInheritance(kingName);\\n * obj->birth(parentName,childName);\\n * obj->death(name);\\n * vector<string> param_3 = obj->getInheritanceOrder();\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4016343,
                "title": "easy-to-understand-javascript-solution-dfs-hashmap",
                "content": "# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\nvar ThroneInheritance = function(kingName) {\\n    this.king = kingName;\\n    this.deathSet = new Set();\\n    this.throneMap = new Map([[kingName, []]]);\\n};\\n\\nThroneInheritance.prototype.birth = function(parentName, childName) {\\n    const children =  this.throneMap.get(parentName) ?? [];\\n\\n    children.push(childName);\\n    this.throneMap.set(parentName, children);\\n    this.throneMap.set(childName, []);\\n};\\n\\nThroneInheritance.prototype.death = function(name) {\\n    this.deathSet.add(name);\\n};\\n\\nThroneInheritance.prototype.getInheritanceOrder = function() {\\n    const result = [];\\n    const generateInheritanceOrder = (name) => {\\n        const children = this.throneMap.get(name);\\n\\n        !this.deathSet.has(name) && result.push(name);\\n        children.forEach(generateInheritanceOrder);\\n    };\\n\\n    generateInheritanceOrder(this.king);\\n    return result;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar ThroneInheritance = function(kingName) {\\n    this.king = kingName;\\n    this.deathSet = new Set();\\n    this.throneMap = new Map([[kingName, []]]);\\n};\\n\\nThroneInheritance.prototype.birth = function(parentName, childName) {\\n    const children =  this.throneMap.get(parentName) ?? [];\\n\\n    children.push(childName);\\n    this.throneMap.set(parentName, children);\\n    this.throneMap.set(childName, []);\\n};\\n\\nThroneInheritance.prototype.death = function(name) {\\n    this.deathSet.add(name);\\n};\\n\\nThroneInheritance.prototype.getInheritanceOrder = function() {\\n    const result = [];\\n    const generateInheritanceOrder = (name) => {\\n        const children = this.throneMap.get(name);\\n\\n        !this.deathSet.has(name) && result.push(name);\\n        children.forEach(generateInheritanceOrder);\\n    };\\n\\n    generateInheritanceOrder(this.king);\\n    return result;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4002349,
                "title": "using-two-maps-and-dfs-very-easy-approach",
                "content": "class ThroneInheritance {\\n    private:\\n    unordered_map<string,vector<string>> map_child;\\n    map<string,int> arr;\\n    string root;\\npublic:\\n    ThroneInheritance(string kingName) {\\n        arr.clear();\\n        root=kingName;\\n        arr[kingName]=1;\\n        map_child.clear();\\n    }\\n    \\n    void birth(string parentName, string child) {\\n        map_child[parentName].emplace_back(child);\\n        arr[child]=1;\\n    }\\n    \\n    void death(string name) {\\n        arr[name]=0;\\n    }\\n    \\n    void dfs(string src,vector<string>& ans){\\n        if(arr[src]==1){\\n            ans.emplace_back(src);\\n        }\\n        for(auto i: map_child[src]){\\n            dfs(i,ans);\\n        }\\n    }\\n    \\n    vector<string> getInheritanceOrder() {\\n        vector<string> ans;\\n        dfs(root,ans);\\n        return ans;\\n    }\\n};\\n\\n/**\\n * Your ThroneInheritance object will be instantiated and called as such:\\n * ThroneInheritance* obj = new ThroneInheritance(kingName);\\n * obj->birth(parentName,childName);\\n * obj->death(name);\\n * vector<string> param_3 = obj->getInheritanceOrder();\\n */",
                "solutionTags": [
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "class ThroneInheritance {\\n    private:\\n    unordered_map<string,vector<string>> map_child;\\n    map<string,int> arr;\\n    string root;\\npublic:\\n    ThroneInheritance(string kingName) {\\n        arr.clear();\\n        root=kingName;\\n        arr[kingName]=1;\\n        map_child.clear();\\n    }\\n    \\n    void birth(string parentName, string child) {\\n        map_child[parentName].emplace_back(child);\\n        arr[child]=1;\\n    }\\n    \\n    void death(string name) {\\n        arr[name]=0;\\n    }\\n    \\n    void dfs(string src,vector<string>& ans){\\n        if(arr[src]==1){\\n            ans.emplace_back(src);\\n        }\\n        for(auto i: map_child[src]){\\n            dfs(i,ans);\\n        }\\n    }\\n    \\n    vector<string> getInheritanceOrder() {\\n        vector<string> ans;\\n        dfs(root,ans);\\n        return ans;\\n    }\\n};\\n\\n/**\\n * Your ThroneInheritance object will be instantiated and called as such:\\n * ThroneInheritance* obj = new ThroneInheritance(kingName);\\n * obj->birth(parentName,childName);\\n * obj->death(name);\\n * vector<string> param_3 = obj->getInheritanceOrder();\\n */",
                "codeTag": "Java"
            },
            {
                "id": 3969778,
                "title": "simple-n-ary-tree-solution-modularized-code",
                "content": "# Code\\n```\\nstruct Node\\n{\\n    string name;\\n    vector<Node *> children;\\n    Node()\\n    {\\n        name = \"\";\\n    }\\n    Node(string name)\\n    {\\n        this->name = name;\\n    }\\n    Node *createChild(string name)\\n    {\\n        Node *child = new Node(name);\\n        this->children.push_back(child);\\n        return child;\\n    }\\n};\\nclass ThroneInheritance\\n{\\n    Node *king;\\n    map<string, Node *> mapping;\\n\\npublic:\\n    ThroneInheritance(string kingName)\\n    {\\n        king = new Node(kingName);\\n        mapping[kingName] = king;\\n    }\\n\\n    void birth(string parentName, string childName)\\n    {\\n        auto parent = mapping[parentName];\\n        auto child = parent->createChild(childName);\\n        mapping[childName] = child;\\n    }\\n\\n    void death(string name)\\n    {\\n        mapping[name]->name.push_back(\\'*\\');\\n    }\\n    void preOrder(Node *root, vector<string> &ans)\\n    {\\n        if (root == NULL)\\n            return;\\n        if (root->name.back() != \\'*\\')\\n            ans.push_back(root->name);\\n        for (auto &x : root->children)\\n        {\\n            preOrder(x, ans);\\n        }\\n    }\\n    vector<string> getInheritanceOrder()\\n    {\\n        vector<string> ans;\\n        preOrder(king, ans);\\n        return ans;\\n    }\\n};\\n\\n/**\\n * Your ThroneInheritance object will be instantiated and called as such:\\n * ThroneInheritance* obj = new ThroneInheritance(kingName);\\n * obj->birth(parentName,childName);\\n * obj->death(name);\\n * vector<string> param_3 = obj->getInheritanceOrder();\\n */\\n```",
                "solutionTags": [
                    "C++",
                    "Tree"
                ],
                "code": "```\\nstruct Node\\n{\\n    string name;\\n    vector<Node *> children;\\n    Node()\\n    {\\n        name = \"\";\\n    }\\n    Node(string name)\\n    {\\n        this->name = name;\\n    }\\n    Node *createChild(string name)\\n    {\\n        Node *child = new Node(name);\\n        this->children.push_back(child);\\n        return child;\\n    }\\n};\\nclass ThroneInheritance\\n{\\n    Node *king;\\n    map<string, Node *> mapping;\\n\\npublic:\\n    ThroneInheritance(string kingName)\\n    {\\n        king = new Node(kingName);\\n        mapping[kingName] = king;\\n    }\\n\\n    void birth(string parentName, string childName)\\n    {\\n        auto parent = mapping[parentName];\\n        auto child = parent->createChild(childName);\\n        mapping[childName] = child;\\n    }\\n\\n    void death(string name)\\n    {\\n        mapping[name]->name.push_back(\\'*\\');\\n    }\\n    void preOrder(Node *root, vector<string> &ans)\\n    {\\n        if (root == NULL)\\n            return;\\n        if (root->name.back() != \\'*\\')\\n            ans.push_back(root->name);\\n        for (auto &x : root->children)\\n        {\\n            preOrder(x, ans);\\n        }\\n    }\\n    vector<string> getInheritanceOrder()\\n    {\\n        vector<string> ans;\\n        preOrder(king, ans);\\n        return ans;\\n    }\\n};\\n\\n/**\\n * Your ThroneInheritance object will be instantiated and called as such:\\n * ThroneInheritance* obj = new ThroneInheritance(kingName);\\n * obj->birth(parentName,childName);\\n * obj->death(name);\\n * vector<string> param_3 = obj->getInheritanceOrder();\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3734150,
                "title": "java-dfs-hashmap-person-object-73-faster",
                "content": "# Intuition\\n- Created Person class (GraphNode) which might have many children (in ArrayList) and boolean field isAlive.\\n- Created HashMap to store name -> Person pairs to enter changes by birth and death methods.\\n- in getInheritanceOrder() I just call DFS method and go thru family graph by using Preorder traversal technique and check if a person is alive.\\n\\n# Complexity\\n- Time complexity: \\ngetInheritanceOrder() - O(N)\\nbirth() and death() - O(1)\\n\\n# Code\\n```\\nclass ThroneInheritance {\\n\\n    Map<String, Person> map;\\n    String kingName;\\n    public ThroneInheritance(String kingName) {\\n        map = new HashMap<>();\\n        this.kingName = kingName;\\n        map.put(kingName, new Person(kingName));\\n    }\\n\\n    public void birth(String parentName, String childName) {\\n        Person p = map.get(parentName);\\n        Person child = new Person(childName);\\n        p.children.add(child);\\n        map.put(childName, child);\\n    }\\n\\n    public void death(String name) {\\n        map.get(name).isAlive = false;\\n    }\\n\\n    public List<String> getInheritanceOrder() {\\n        List<String> list = new ArrayList<>();\\n        dfs(map.get(kingName), list);\\n        return list;\\n    }\\n\\n    private void dfs(Person person, List<String> list) {\\n        if (person == null) return;\\n        \\n        if (person.isAlive) list.add(person.name);\\n        for (int i = 0; i < person.children.size(); i++) {\\n            dfs(person.children.get(i), list);\\n        }\\n    }\\n}\\n\\nclass Person {\\n    String name;\\n    List<Person> children;\\n\\n    boolean isAlive;\\n\\n    public Person(String name) {\\n        this.name = name;\\n        children = new ArrayList<>();\\n        isAlive = true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass ThroneInheritance {\\n\\n    Map<String, Person> map;\\n    String kingName;\\n    public ThroneInheritance(String kingName) {\\n        map = new HashMap<>();\\n        this.kingName = kingName;\\n        map.put(kingName, new Person(kingName));\\n    }\\n\\n    public void birth(String parentName, String childName) {\\n        Person p = map.get(parentName);\\n        Person child = new Person(childName);\\n        p.children.add(child);\\n        map.put(childName, child);\\n    }\\n\\n    public void death(String name) {\\n        map.get(name).isAlive = false;\\n    }\\n\\n    public List<String> getInheritanceOrder() {\\n        List<String> list = new ArrayList<>();\\n        dfs(map.get(kingName), list);\\n        return list;\\n    }\\n\\n    private void dfs(Person person, List<String> list) {\\n        if (person == null) return;\\n        \\n        if (person.isAlive) list.add(person.name);\\n        for (int i = 0; i < person.children.size(); i++) {\\n            dfs(person.children.get(i), list);\\n        }\\n    }\\n}\\n\\nclass Person {\\n    String name;\\n    List<Person> children;\\n\\n    boolean isAlive;\\n\\n    public Person(String name) {\\n        this.name = name;\\n        children = new ArrayList<>();\\n        isAlive = true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3705788,
                "title": "python-n-tree",
                "content": "# Intuition\\nJust construct n-tree and maintain set of dead people.\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(n)$$ - getInheritanceOrder\\n$$O(1)$$ - birth\\n$$O(1)$$ - death\\n\\n# Code\\n```\\nclass ThroneInheritance:\\n\\n    def __init__(self, kingName: str):\\n        self.succ = defaultdict(list)\\n        self.king = kingName\\n        self.dead = set()\\n        \\n    def birth(self, parentName: str, childName: str) -> None:\\n        self.succ[parentName].append(childName)\\n\\n    def death(self, name: str) -> None:\\n        self.dead.add(name)\\n\\n    def collect(self, name, order):\\n        if name not in self.dead: order.append(name)\\n        for child in self.succ[name]: self.collect(child, order)\\n\\n    def getInheritanceOrder(self) -> List[str]:\\n        result = []\\n        self.collect(self.king, result)\\n        return result        \\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Tree"
                ],
                "code": "```\\nclass ThroneInheritance:\\n\\n    def __init__(self, kingName: str):\\n        self.succ = defaultdict(list)\\n        self.king = kingName\\n        self.dead = set()\\n        \\n    def birth(self, parentName: str, childName: str) -> None:\\n        self.succ[parentName].append(childName)\\n\\n    def death(self, name: str) -> None:\\n        self.dead.add(name)\\n\\n    def collect(self, name, order):\\n        if name not in self.dead: order.append(name)\\n        for child in self.succ[name]: self.collect(child, order)\\n\\n    def getInheritanceOrder(self) -> List[str]:\\n        result = []\\n        self.collect(self.king, result)\\n        return result        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3702617,
                "title": "using-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass ThroneInheritance {\\n\\n    String kingName;\\n    Map<String,List<String>> map = new HashMap<>();\\n    Map<String,Boolean> alive = new HashMap<>();\\n\\n    public ThroneInheritance(String kingName) {\\n        this.kingName = kingName;    \\n    }\\n    \\n    public void birth(String parentName, String childName) {\\n        map.computeIfAbsent(parentName, k-> new ArrayList<>());\\n        map.get(parentName).add(childName);\\n    }\\n    \\n    public void death(String name) {\\n        alive.put(name,false);\\n    }\\n    \\n    public List<String> getInheritanceOrder() {\\n        List<String> list = getList(this.kingName);\\n        List<String> res = new ArrayList<>();\\n        for(String str : list){\\n            if(alive.getOrDefault(str,true)){\\n                res.add(str);\\n            }\\n        }\\n        return res;\\n    }\\n    private List<String> getList(String p){\\n        List<String> res = new ArrayList<>();\\n        res.add(p);\\n        List<String> child = map.getOrDefault(p, new ArrayList<>());\\n        for(String c : child){\\n            List<String> curr = getList(c);\\n            for(String cc: curr){\\n                res.add(cc);\\n            }\\n        }\\n        return res;\\n    }\\n}\\n\\n/**\\n * Your ThroneInheritance object will be instantiated and called as such:\\n * ThroneInheritance obj = new ThroneInheritance(kingName);\\n * obj.birth(parentName,childName);\\n * obj.death(name);\\n * List<String> param_3 = obj.getInheritanceOrder();\\n */\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass ThroneInheritance {\\n\\n    String kingName;\\n    Map<String,List<String>> map = new HashMap<>();\\n    Map<String,Boolean> alive = new HashMap<>();\\n\\n    public ThroneInheritance(String kingName) {\\n        this.kingName = kingName;    \\n    }\\n    \\n    public void birth(String parentName, String childName) {\\n        map.computeIfAbsent(parentName, k-> new ArrayList<>());\\n        map.get(parentName).add(childName);\\n    }\\n    \\n    public void death(String name) {\\n        alive.put(name,false);\\n    }\\n    \\n    public List<String> getInheritanceOrder() {\\n        List<String> list = getList(this.kingName);\\n        List<String> res = new ArrayList<>();\\n        for(String str : list){\\n            if(alive.getOrDefault(str,true)){\\n                res.add(str);\\n            }\\n        }\\n        return res;\\n    }\\n    private List<String> getList(String p){\\n        List<String> res = new ArrayList<>();\\n        res.add(p);\\n        List<String> child = map.getOrDefault(p, new ArrayList<>());\\n        for(String c : child){\\n            List<String> curr = getList(c);\\n            for(String cc: curr){\\n                res.add(cc);\\n            }\\n        }\\n        return res;\\n    }\\n}\\n\\n/**\\n * Your ThroneInheritance object will be instantiated and called as such:\\n * ThroneInheritance obj = new ThroneInheritance(kingName);\\n * obj.birth(parentName,childName);\\n * obj.death(name);\\n * List<String> param_3 = obj.getInheritanceOrder();\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3685091,
                "title": "java-tree-recursion-hashing",
                "content": "```\\nclass ThroneInheritance {\\n    \\n    HashMap<String,FamTree> map;\\n    FamTree throne;\\n    public ThroneInheritance(String kingName) {\\n        //intitalize the hashmap\\n        map = new HashMap<>();\\n        FamTree king = new FamTree(kingName);\\n        map.put(kingName,king);\\n        throne = king;\\n    }\\n    \\n    public void birth(String parentName, String childName) {\\n        FamTree child = new FamTree(childName);\\n        map.put(childName,child);\\n        map.get(parentName).childs.add(child);\\n      //  System.out.println(map.get(parentName).childs.size());\\n    }\\n    \\n    public void death(String name) {\\n        map.get(name).isDead = true;\\n    }\\n    \\n    public List<String> getInheritanceOrder() {\\n        //pre order traversal\\n        return  doPreorderTraversal(new ArrayList<>(),throne);\\n    }\\n    \\n    private List<String> doPreorderTraversal(List<String> list,FamTree curr){\\n        \\n        if(!curr.isDead){\\n           list.add(curr.name);    \\n        }\\n        \\n        if(curr.childs.isEmpty()){\\n            return list;\\n        }\\n        \\n        for(FamTree chThrone : curr.childs){\\n            doPreorderTraversal(list,chThrone);\\n        }\\n        \\n        return list;\\n    }\\n}\\n\\nclass FamTree{\\n    \\n    String name;\\n    List<FamTree> childs;\\n    boolean isDead;\\n    \\n    public FamTree(String name){\\n        this.isDead = false;\\n        this.childs = new ArrayList<>();\\n        this.name = name;\\n    }\\n}\\n\\n/**\\n * Your ThroneInheritance object will be instantiated and called as such:\\n * ThroneInheritance obj = new ThroneInheritance(kingName);\\n * obj.birth(parentName,childName);\\n * obj.death(name);\\n * List<String> param_3 = obj.getInheritanceOrder();\\n */\\n```",
                "solutionTags": [
                    "Java",
                    "Tree",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass ThroneInheritance {\\n    \\n    HashMap<String,FamTree> map;\\n    FamTree throne;\\n    public ThroneInheritance(String kingName) {\\n        //intitalize the hashmap\\n        map = new HashMap<>();\\n        FamTree king = new FamTree(kingName);\\n        map.put(kingName,king);\\n        throne = king;\\n    }\\n    \\n    public void birth(String parentName, String childName) {\\n        FamTree child = new FamTree(childName);\\n        map.put(childName,child);\\n        map.get(parentName).childs.add(child);\\n      //  System.out.println(map.get(parentName).childs.size());\\n    }\\n    \\n    public void death(String name) {\\n        map.get(name).isDead = true;\\n    }\\n    \\n    public List<String> getInheritanceOrder() {\\n        //pre order traversal\\n        return  doPreorderTraversal(new ArrayList<>(),throne);\\n    }\\n    \\n    private List<String> doPreorderTraversal(List<String> list,FamTree curr){\\n        \\n        if(!curr.isDead){\\n           list.add(curr.name);    \\n        }\\n        \\n        if(curr.childs.isEmpty()){\\n            return list;\\n        }\\n        \\n        for(FamTree chThrone : curr.childs){\\n            doPreorderTraversal(list,chThrone);\\n        }\\n        \\n        return list;\\n    }\\n}\\n\\nclass FamTree{\\n    \\n    String name;\\n    List<FamTree> childs;\\n    boolean isDead;\\n    \\n    public FamTree(String name){\\n        this.isDead = false;\\n        this.childs = new ArrayList<>();\\n        this.name = name;\\n    }\\n}\\n\\n/**\\n * Your ThroneInheritance object will be instantiated and called as such:\\n * ThroneInheritance obj = new ThroneInheritance(kingName);\\n * obj.birth(parentName,childName);\\n * obj.death(name);\\n * List<String> param_3 = obj.getInheritanceOrder();\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3676967,
                "title": "sharing-my-kotlin-solution",
                "content": "sorry no explanation\\n# Code\\n```\\nclass ThroneInheritance(kingName: String) {\\n    var root: MyTreeNode\\n    private val familyTreeMap = mutableMapOf<String, MyTreeNode>()\\n\\n    init {\\n        root = MyTreeNode(name = kingName)\\n        familyTreeMap[kingName] = root\\n    }\\n\\n    fun birth(parentName: String, childName: String) {\\n        val parent = familyTreeMap[parentName]!!\\n        val child = MyTreeNode(name = childName)\\n        parent.children.add(child)\\n        familyTreeMap[child.name] = child\\n    }\\n\\n    fun death(name: String) {\\n        familyTreeMap[name]?.isDead = true\\n    }\\n\\n    fun getInheritanceOrder(): List<String> {\\n        val res = mutableListOf<String>()\\n\\n        // DFS Search\\n        fun searchChild(root: MyTreeNode?) {\\n            if (root == null) {\\n                return\\n            }\\n\\n            if (!root.isDead) {\\n                res.add(root.name)\\n            }\\n\\n            root.children.forEach {\\n                searchChild(it)    \\n            }\\n            \\n        }\\n        searchChild(root)\\n        return res\\n    }\\n}\\n\\ndata class MyTreeNode(\\n    val name: String,\\n    val children: MutableList<MyTreeNode?> = mutableListOf(),\\n    var isDead: Boolean = false\\n)\\n\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\nclass ThroneInheritance(kingName: String) {\\n    var root: MyTreeNode\\n    private val familyTreeMap = mutableMapOf<String, MyTreeNode>()\\n\\n    init {\\n        root = MyTreeNode(name = kingName)\\n        familyTreeMap[kingName] = root\\n    }\\n\\n    fun birth(parentName: String, childName: String) {\\n        val parent = familyTreeMap[parentName]!!\\n        val child = MyTreeNode(name = childName)\\n        parent.children.add(child)\\n        familyTreeMap[child.name] = child\\n    }\\n\\n    fun death(name: String) {\\n        familyTreeMap[name]?.isDead = true\\n    }\\n\\n    fun getInheritanceOrder(): List<String> {\\n        val res = mutableListOf<String>()\\n\\n        // DFS Search\\n        fun searchChild(root: MyTreeNode?) {\\n            if (root == null) {\\n                return\\n            }\\n\\n            if (!root.isDead) {\\n                res.add(root.name)\\n            }\\n\\n            root.children.forEach {\\n                searchChild(it)    \\n            }\\n            \\n        }\\n        searchChild(root)\\n        return res\\n    }\\n}\\n\\ndata class MyTreeNode(\\n    val name: String,\\n    val children: MutableList<MyTreeNode?> = mutableListOf(),\\n    var isDead: Boolean = false\\n)\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3639841,
                "title": "java-tree-using-map-set-dfs-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass ThroneInheritance {\\n\\n    String kingName;\\n    Map<String, List<String>> inheritance;\\n    Set<String> deaths;\\n\\n    public ThroneInheritance(String kingName) {\\n        this.kingName = kingName;\\n        inheritance = new HashMap<>();\\n        deaths = new HashSet<>();\\n        inheritance.put(kingName, new ArrayList<>());\\n    }\\n    \\n    public void birth(String parentName, String childName) {\\n        inheritance.putIfAbsent(parentName, new ArrayList<>());\\n        inheritance.get(parentName).add(childName);\\n    }\\n    \\n    public void death(String name) {\\n        deaths.add(name);\\n    }\\n    \\n\\n    private void helper(String parent, List<String> orders){\\n        if(!deaths.contains(parent)) orders.add(parent);\\n        for(String child : inheritance.getOrDefault(parent, new ArrayList<>())){\\n            helper(child, orders);\\n        }\\n    }\\n\\n    public List<String> getInheritanceOrder() {\\n        List<String> orders = new ArrayList<>();\\n        helper(kingName, orders);\\n        return orders;\\n    }\\n}\\n\\n/**\\n * Your ThroneInheritance object will be instantiated and called as such:\\n * ThroneInheritance obj = new ThroneInheritance(kingName);\\n * obj.birth(parentName,childName);\\n * obj.death(name);\\n * List<String> param_3 = obj.getInheritanceOrder();\\n */\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass ThroneInheritance {\\n\\n    String kingName;\\n    Map<String, List<String>> inheritance;\\n    Set<String> deaths;\\n\\n    public ThroneInheritance(String kingName) {\\n        this.kingName = kingName;\\n        inheritance = new HashMap<>();\\n        deaths = new HashSet<>();\\n        inheritance.put(kingName, new ArrayList<>());\\n    }\\n    \\n    public void birth(String parentName, String childName) {\\n        inheritance.putIfAbsent(parentName, new ArrayList<>());\\n        inheritance.get(parentName).add(childName);\\n    }\\n    \\n    public void death(String name) {\\n        deaths.add(name);\\n    }\\n    \\n\\n    private void helper(String parent, List<String> orders){\\n        if(!deaths.contains(parent)) orders.add(parent);\\n        for(String child : inheritance.getOrDefault(parent, new ArrayList<>())){\\n            helper(child, orders);\\n        }\\n    }\\n\\n    public List<String> getInheritanceOrder() {\\n        List<String> orders = new ArrayList<>();\\n        helper(kingName, orders);\\n        return orders;\\n    }\\n}\\n\\n/**\\n * Your ThroneInheritance object will be instantiated and called as such:\\n * ThroneInheritance obj = new ThroneInheritance(kingName);\\n * obj.birth(parentName,childName);\\n * obj.death(name);\\n * List<String> param_3 = obj.getInheritanceOrder();\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3634928,
                "title": "swift-beautiful-tree-data-structure-solution",
                "content": "```\\nclass ThroneInheritance {\\n    var king: Person\\n    var person: [String: Person] = [:]\\n\\n    init(_ kingName: String) {\\n        king = Person(name: kingName)\\n        person = [kingName: king]\\n    }\\n    \\n    func birth(_ parentName: String, _ childName: String) {\\n        let parent = person[parentName]!\\n        let child = parent.addChild(name: childName)\\n        person[child.name] = child\\n    }\\n    \\n    func death(_ name: String) {\\n        let deadPerson = person[name]!\\n        deadPerson.markDead()\\n    }\\n    \\n    func getInheritanceOrder() -> [String] {\\n        func dfs(_ person: Person) -> [String] {\\n            (person.isAlive ? [person.name] : []) + person.children.map { dfs($0) }.joined()\\n        }\\n        return dfs(king)\\n    }\\n}\\n\\n// Tree\\nclass Person {\\n    let name: String\\n    var children: [Person]\\n    var isAlive: Bool\\n\\n    init(name: String) {\\n        self.name = name\\n        self.children = []\\n        self.isAlive = true\\n    }\\n\\n    func addChild(name: String) -> Person {\\n        let child = Person(name: name)\\n        children.append(child)\\n        return child\\n    }\\n\\n    func markDead() {\\n        isAlive = false\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift",
                    "Hash Table",
                    "Tree"
                ],
                "code": "```\\nclass ThroneInheritance {\\n    var king: Person\\n    var person: [String: Person] = [:]\\n\\n    init(_ kingName: String) {\\n        king = Person(name: kingName)\\n        person = [kingName: king]\\n    }\\n    \\n    func birth(_ parentName: String, _ childName: String) {\\n        let parent = person[parentName]!\\n        let child = parent.addChild(name: childName)\\n        person[child.name] = child\\n    }\\n    \\n    func death(_ name: String) {\\n        let deadPerson = person[name]!\\n        deadPerson.markDead()\\n    }\\n    \\n    func getInheritanceOrder() -> [String] {\\n        func dfs(_ person: Person) -> [String] {\\n            (person.isAlive ? [person.name] : []) + person.children.map { dfs($0) }.joined()\\n        }\\n        return dfs(king)\\n    }\\n}\\n\\n// Tree\\nclass Person {\\n    let name: String\\n    var children: [Person]\\n    var isAlive: Bool\\n\\n    init(name: String) {\\n        self.name = name\\n        self.children = []\\n        self.isAlive = true\\n    }\\n\\n    func addChild(name: String) -> Person {\\n        let child = Person(name: name)\\n        children.append(child)\\n        return child\\n    }\\n\\n    func markDead() {\\n        isAlive = false\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3597350,
                "title": "easy-java-solution-beats-90-online-solution",
                "content": "# Code\\n```\\nclass ThroneInheritance {\\n\\n    class Tree{\\n        String name;\\n        boolean isalive;\\n        LinkedList<Tree> children;\\n\\n        Tree(String name){\\n            this.name = name;\\n            isalive = true;\\n            children = new LinkedList<>();\\n        }\\n    }\\n\\n    Tree root;\\n    HashMap<String, Tree> mapper;\\n    List<String> ans;\\n\\n    public ThroneInheritance(String kingName) {\\n        root = new Tree(kingName);\\n        mapper = new HashMap<>();\\n        mapper.put(kingName, root);\\n    }\\n    \\n    public void birth(String parentName, String childName) {\\n\\n        Tree parent = mapper.get(parentName);\\n        Tree child = new Tree(childName);\\n\\n        parent.children.add(child);\\n\\n        mapper.put(childName, child);\\n    }\\n    \\n    public void death(String name) {\\n        Tree res = mapper.get(name);\\n\\n        res.isalive = false;\\n    }\\n    \\n    public List<String> getInheritanceOrder() {\\n        ans = new ArrayList<>();\\n        Tree res = root;\\n\\n        traverse(res);\\n\\n        return ans;\\n    }\\n\\n    public void traverse(Tree res){\\n        if(res == null){\\n            return ;\\n        }\\n\\n        if(res.isalive){\\n            ans.add(res.name);\\n        }\\n\\n        for(Tree it : res.children){\\n            traverse(it);\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Hash Table",
                    "Tree",
                    "Depth-First Search",
                    "Design"
                ],
                "code": "```\\nclass ThroneInheritance {\\n\\n    class Tree{\\n        String name;\\n        boolean isalive;\\n        LinkedList<Tree> children;\\n\\n        Tree(String name){\\n            this.name = name;\\n            isalive = true;\\n            children = new LinkedList<>();\\n        }\\n    }\\n\\n    Tree root;\\n    HashMap<String, Tree> mapper;\\n    List<String> ans;\\n\\n    public ThroneInheritance(String kingName) {\\n        root = new Tree(kingName);\\n        mapper = new HashMap<>();\\n        mapper.put(kingName, root);\\n    }\\n    \\n    public void birth(String parentName, String childName) {\\n\\n        Tree parent = mapper.get(parentName);\\n        Tree child = new Tree(childName);\\n\\n        parent.children.add(child);\\n\\n        mapper.put(childName, child);\\n    }\\n    \\n    public void death(String name) {\\n        Tree res = mapper.get(name);\\n\\n        res.isalive = false;\\n    }\\n    \\n    public List<String> getInheritanceOrder() {\\n        ans = new ArrayList<>();\\n        Tree res = root;\\n\\n        traverse(res);\\n\\n        return ans;\\n    }\\n\\n    public void traverse(Tree res){\\n        if(res == null){\\n            return ;\\n        }\\n\\n        if(res.isalive){\\n            ans.add(res.name);\\n        }\\n\\n        for(Tree it : res.children){\\n            traverse(it);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3585485,
                "title": "go-beginner",
                "content": "\\n# Code\\n```\\ntype person struct {\\n    name string\\n    parent *person\\n    children []*person\\n    isAlive bool\\n}\\n\\nfunc newPerson(name string) *person {\\n    p := person{}\\n    p.name = name\\n    p.children = make([]*person, 0)\\n    p.isAlive = true\\n    return &p\\n}\\n\\ntype ThroneInheritance struct {\\n    king *person\\n    dic map[string]*person\\n}\\n\\n\\nfunc Constructor(kingName string) ThroneInheritance {\\n    t := ThroneInheritance{}\\n    t.dic = make(map[string]*person)\\n    k := t.addPerson(kingName)\\n    t.king = k\\n    return t\\n}\\n\\nfunc (t *ThroneInheritance) addPerson(name string) *person {\\n    p := newPerson(name)\\n    t.dic[name] = p\\n    return p\\n}\\n\\n\\nfunc (t *ThroneInheritance) Birth(parentName string, childName string)  {\\n    c := t.addPerson(childName)\\n    p := t.dic[parentName]\\n    p.children = append(p.children, c)\\n}\\n\\n\\nfunc (t *ThroneInheritance) Death(name string)  {\\n    p := t.dic[name]\\n    p.isAlive = false\\n}\\n\\nfunc (t *ThroneInheritance) traverseOrder(p *person, order *[]string, visited map[string]bool) {\\n    if p.isAlive {\\n        *order = append(*order, p.name)\\n    }\\n    //fmt.Println(\"Visiting\", p.name)\\n    visited[p.name] = true\\n\\n    for _, c := range p.children {\\n        if _, ok := visited[c.name]; !ok {\\n            t.traverseOrder(c, order, visited)\\n        }\\n    }\\n\\n    if p.parent != nil {\\n        if _, ok := visited[p.parent.name]; !ok {\\n            t.traverseOrder(p.parent, order, visited)\\n        }\\n    }\\n}\\n\\nfunc (t *ThroneInheritance) GetInheritanceOrder() []string {\\n    order := []string{}\\n    visited := map[string]bool{}\\n    t.traverseOrder(t.king, &order, visited)\\n    return order\\n}\\n\\n\\n/**\\n * Your ThroneInheritance object will be instantiated and called as such:\\n * obj := Constructor(kingName);\\n * obj.Birth(parentName,childName);\\n * obj.Death(name);\\n * param_3 := obj.GetInheritanceOrder();\\n */\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\ntype person struct {\\n    name string\\n    parent *person\\n    children []*person\\n    isAlive bool\\n}\\n\\nfunc newPerson(name string) *person {\\n    p := person{}\\n    p.name = name\\n    p.children = make([]*person, 0)\\n    p.isAlive = true\\n    return &p\\n}\\n\\ntype ThroneInheritance struct {\\n    king *person\\n    dic map[string]*person\\n}\\n\\n\\nfunc Constructor(kingName string) ThroneInheritance {\\n    t := ThroneInheritance{}\\n    t.dic = make(map[string]*person)\\n    k := t.addPerson(kingName)\\n    t.king = k\\n    return t\\n}\\n\\nfunc (t *ThroneInheritance) addPerson(name string) *person {\\n    p := newPerson(name)\\n    t.dic[name] = p\\n    return p\\n}\\n\\n\\nfunc (t *ThroneInheritance) Birth(parentName string, childName string)  {\\n    c := t.addPerson(childName)\\n    p := t.dic[parentName]\\n    p.children = append(p.children, c)\\n}\\n\\n\\nfunc (t *ThroneInheritance) Death(name string)  {\\n    p := t.dic[name]\\n    p.isAlive = false\\n}\\n\\nfunc (t *ThroneInheritance) traverseOrder(p *person, order *[]string, visited map[string]bool) {\\n    if p.isAlive {\\n        *order = append(*order, p.name)\\n    }\\n    //fmt.Println(\"Visiting\", p.name)\\n    visited[p.name] = true\\n\\n    for _, c := range p.children {\\n        if _, ok := visited[c.name]; !ok {\\n            t.traverseOrder(c, order, visited)\\n        }\\n    }\\n\\n    if p.parent != nil {\\n        if _, ok := visited[p.parent.name]; !ok {\\n            t.traverseOrder(p.parent, order, visited)\\n        }\\n    }\\n}\\n\\nfunc (t *ThroneInheritance) GetInheritanceOrder() []string {\\n    order := []string{}\\n    visited := map[string]bool{}\\n    t.traverseOrder(t.king, &order, visited)\\n    return order\\n}\\n\\n\\n/**\\n * Your ThroneInheritance object will be instantiated and called as such:\\n * obj := Constructor(kingName);\\n * obj.Birth(parentName,childName);\\n * obj.Death(name);\\n * param_3 := obj.GetInheritanceOrder();\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3508617,
                "title": "c-best-different-approaches-with-complete-explanation",
                "content": "# https://leetcode.com/problems/throne-inheritance/description/\\n# Letcode : 1600 ( Asked in a Product based Company)\\n\\n# Intuition\\nAs problem describes about the family and hierarchy, so hierarchical data structure can be used. Tree data structure is good to use.\\nTree : can be used to store the parent and child relationships.\\nThe order of inheritance is basically the DFS or preorder traversal of the Tree ( just we have to ignore the Dead Person/nodes)\\n\\n\\n# Approach\\n3 Approaches are shown in below codes\\n\\n# Approach 1: \\n\\nUses Tree data structure to store the parent and child relationships.\\nProblem: In birth(): Searching the parent to whom we have to add the child, takes lot of time as searching always starts from root node( king)\\nIn death(): Again searching the node to mark dead takes lot of time as searching always starts from root node( king)\\n\\nSo it give Time Limit Exceeded\\n\\nNote: dead status is put in each node.( isAlive)\\n\\n# Approach 2:\\nTo sae search time, we use unordered map also along with Tree.\\n\\nIn map we store the personName as key and the Node address ( as value ) in which personName is stored\\n\\nSo when we need to search for a person, we can directly access that person in O(1) time\\n\\nThis solution works FINE.\\n\\nNote: dead status is put in each node.( isAlive)\\n\\n# Approach 3:\\nHere we avoided the use of Tree and used a map for showing the parent child relationship.\\nEx: King -> <A, B, C> \\n    A    -> <M>\\n    B    -> <Alice>\\nunordered_map<string,vector<string>>\\nunordered_map is used as access to key is O(1)\\nchild are added in the order they take birth .\\n\\n\\nFor dead person status,we took a set . It stores name of dead persons.\\nWe can use another map also for keeping dead person status.",
                "solutionTags": [
                    "C++"
                ],
                "code": "# https://leetcode.com/problems/throne-inheritance/description/\\n# Letcode : 1600 ( Asked in a Product based Company)\\n\\n# Intuition\\nAs problem describes about the family and hierarchy, so hierarchical data structure can be used. Tree data structure is good to use.\\nTree : can be used to store the parent and child relationships.\\nThe order of inheritance is basically the DFS or preorder traversal of the Tree ( just we have to ignore the Dead Person/nodes)\\n\\n\\n# Approach\\n3 Approaches are shown in below codes\\n\\n# Approach 1: \\n\\nUses Tree data structure to store the parent and child relationships.\\nProblem: In birth(): Searching the parent to whom we have to add the child, takes lot of time as searching always starts from root node( king)\\nIn death(): Again searching the node to mark dead takes lot of time as searching always starts from root node( king)\\n\\nSo it give Time Limit Exceeded\\n\\nNote: dead status is put in each node.( isAlive)\\n\\n# Approach 2:\\nTo sae search time, we use unordered map also along with Tree.\\n\\nIn map we store the personName as key and the Node address ( as value ) in which personName is stored\\n\\nSo when we need to search for a person, we can directly access that person in O(1) time\\n\\nThis solution works FINE.\\n\\nNote: dead status is put in each node.( isAlive)\\n\\n# Approach 3:\\nHere we avoided the use of Tree and used a map for showing the parent child relationship.\\nEx: King -> <A, B, C> \\n    A    -> <M>\\n    B    -> <Alice>\\nunordered_map<string,vector<string>>\\nunordered_map is used as access to key is O(1)\\nchild are added in the order they take birth .\\n\\n\\nFor dead person status,we took a set . It stores name of dead persons.\\nWe can use another map also for keeping dead person status.",
                "codeTag": "Unknown"
            },
            {
                "id": 3468351,
                "title": "c-n-ary-tree-with-hash-map-easy-to-understand-87-faster",
                "content": "```\\nclass ThroneInheritance {\\npublic:\\n    struct Node {\\n        \\n        // Keep track of name for inheritance order and hashing\\n        string name;\\n        \\n        // Keep track of children for n-ary tree traversal\\n        vector<Node*> children;\\n        \\n        // Marker indicating dead/alive\\n        bool alive;\\n        \\n        // Constructor\\n        Node(string name, vector<Node*> children, bool alive) {\\n            this->name = name;\\n            this->children = children;\\n            this->alive = alive;\\n        }\\n    };\\n\\n    // Start of the n-ary family tree\\n    Node* root;\\n\\n    // Hash map to quickly access nodes by name (1-to-1 mapping).\\n    // Names are assumed to be distinct in problem constraints.\\n    unordered_map<string, Node*> nameMap;\\n\\n    ThroneInheritance(string kingName) {\\n        root = new Node(kingName, {}, true);\\n        nameMap[kingName] = root;\\n    }\\n\\n    void birth(string parentName, string childName) {\\n        Node* parent = nameMap[parentName];\\n        Node* child = new Node(childName, {}, true);\\n        parent->children.push_back(child);\\n        nameMap[childName] = child;\\n    }\\n\\n    void death(string name) {\\n        Node* timeToDie = nameMap[name];\\n        timeToDie->alive = false;\\n    }\\n\\n    // Traverse the family tree with preOrder traversal (i.e. depth first search)\\n    vector<string> getInheritanceOrder() {\\n        stack<Node*> stack;\\n        vector<string> preOrder;\\n        stack.push(root);\\n        while (!stack.empty()) {\\n            Node* curr = stack.top();\\n            stack.pop();\\n            if (curr->alive) {\\n                preOrder.push_back(curr->name);\\n            }\\n            \\n            // Push all of the children into the stack from right to left.\\n            // (So the first born child is on top of the stack)\\n            for (int i = curr->children.size() - 1; i >= 0; i--) {\\n                stack.push(curr->children[i]);\\n            }\\n        }\\n        \\n        return preOrder;\\n    }                                                       \\n};\\n\\n/**\\n * Your ThroneInheritance object will be instantiated and called as such:\\n * ThroneInheritance* obj = new ThroneInheritance(kingName);\\n * obj->birth(parentName,childName);\\n * obj->death(name);\\n * vector<string> param_3 = obj->getInheritanceOrder();\\n */\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass ThroneInheritance {\\npublic:\\n    struct Node {\\n        \\n        // Keep track of name for inheritance order and hashing\\n        string name;\\n        \\n        // Keep track of children for n-ary tree traversal\\n        vector<Node*> children;\\n        \\n        // Marker indicating dead/alive\\n        bool alive;\\n        \\n        // Constructor\\n        Node(string name, vector<Node*> children, bool alive) {\\n            this->name = name;\\n            this->children = children;\\n            this->alive = alive;\\n        }\\n    };\\n\\n    // Start of the n-ary family tree\\n    Node* root;\\n\\n    // Hash map to quickly access nodes by name (1-to-1 mapping).\\n    // Names are assumed to be distinct in problem constraints.\\n    unordered_map<string, Node*> nameMap;\\n\\n    ThroneInheritance(string kingName) {\\n        root = new Node(kingName, {}, true);\\n        nameMap[kingName] = root;\\n    }\\n\\n    void birth(string parentName, string childName) {\\n        Node* parent = nameMap[parentName];\\n        Node* child = new Node(childName, {}, true);\\n        parent->children.push_back(child);\\n        nameMap[childName] = child;\\n    }\\n\\n    void death(string name) {\\n        Node* timeToDie = nameMap[name];\\n        timeToDie->alive = false;\\n    }\\n\\n    // Traverse the family tree with preOrder traversal (i.e. depth first search)\\n    vector<string> getInheritanceOrder() {\\n        stack<Node*> stack;\\n        vector<string> preOrder;\\n        stack.push(root);\\n        while (!stack.empty()) {\\n            Node* curr = stack.top();\\n            stack.pop();\\n            if (curr->alive) {\\n                preOrder.push_back(curr->name);\\n            }\\n            \\n            // Push all of the children into the stack from right to left.\\n            // (So the first born child is on top of the stack)\\n            for (int i = curr->children.size() - 1; i >= 0; i--) {\\n                stack.push(curr->children[i]);\\n            }\\n        }\\n        \\n        return preOrder;\\n    }                                                       \\n};\\n\\n/**\\n * Your ThroneInheritance object will be instantiated and called as such:\\n * ThroneInheritance* obj = new ThroneInheritance(kingName);\\n * obj->birth(parentName,childName);\\n * obj->death(name);\\n * vector<string> param_3 = obj->getInheritanceOrder();\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3424747,
                "title": "simple-python3-dfs",
                "content": "\\n\\n# Code\\n```\\nclass ThroneInheritance:\\n\\n    def __init__(self, kingName: str):\\n        self.family = defaultdict(list)\\n        self.king = kingName\\n        self.dead = defaultdict(bool)\\n        \\n    def birth(self, parentName: str, childName: str) -> None:\\n        self.family[parentName].append(childName)\\n\\n    def death(self, name: str) -> None:\\n        self.dead[name] = True\\n\\n    def getInheritanceOrder(self) -> List[str]:\\n        visited = set()\\n        curOrder = [self.king] if not self.dead[self.king] else []\\n\\n        def successor(parent, curOrder):\\n            if parent not in visited:\\n                visited.add(parent)\\n                for child in self.family[parent]:\\n                    if not self.dead[child]:\\n                        curOrder.append(child)\\n                    successor(child,curOrder)\\n            return curOrder\\n        \\n        return successor(self.king, curOrder)\\n\\n\\n\\n\\n        \\n\\n\\n# Your ThroneInheritance object will be instantiated and called as such:\\n# obj = ThroneInheritance(kingName)\\n# obj.birth(parentName,childName)\\n# obj.death(name)\\n# param_3 = obj.getInheritanceOrder()\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass ThroneInheritance:\\n\\n    def __init__(self, kingName: str):\\n        self.family = defaultdict(list)\\n        self.king = kingName\\n        self.dead = defaultdict(bool)\\n        \\n    def birth(self, parentName: str, childName: str) -> None:\\n        self.family[parentName].append(childName)\\n\\n    def death(self, name: str) -> None:\\n        self.dead[name] = True\\n\\n    def getInheritanceOrder(self) -> List[str]:\\n        visited = set()\\n        curOrder = [self.king] if not self.dead[self.king] else []\\n\\n        def successor(parent, curOrder):\\n            if parent not in visited:\\n                visited.add(parent)\\n                for child in self.family[parent]:\\n                    if not self.dead[child]:\\n                        curOrder.append(child)\\n                    successor(child,curOrder)\\n            return curOrder\\n        \\n        return successor(self.king, curOrder)\\n\\n\\n\\n\\n        \\n\\n\\n# Your ThroneInheritance object will be instantiated and called as such:\\n# obj = ThroneInheritance(kingName)\\n# obj.birth(parentName,childName)\\n# obj.death(name)\\n# param_3 = obj.getInheritanceOrder()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3403815,
                "title": "python-doubly-linked-list-solution-with-explanation",
                "content": "```python\\n\\'\\'\\'\\nwe can use Doubly Linked List to maintain InheritanceOrder.\\nthere has two hash map in Doubly Linked List, one is to record the last child for each parent, if the person has no child, its last child will be itself,\\nanother is to record the location of the node.\\nIf someone\\'s child is born, we can use first hash map to find the node whose last child is itself from his descendants and insert the child next to the node and update the last child of the parent.\\n\\ne.g. \\nt.birth(\"king\", \"andy\");\\nt.birth(\"andy\", \"matthew\");\\nking -> andy -> matthew\\nself.lastChild:\\nking -> andy\\nandy -> matthew\\nmatthew -> matthew\\nt.birth(\"king\", \"bob\"); // insert bob next to matthew\\n\\nsc is O(n)\\ntc of birth is O(depth of family tree)\\ntc of death is O(1)\\ntc of getInheritanceOrder is O(n)\\n\\'\\'\\'\\nclass Node:\\n    def __init__(self, name=\\'\\'):\\n        self.name = name\\n        self.next = None\\n        self.prev = None\\n        self.status = True\\n\\nclass DoublyLinkedList:\\n    def __init__(self):\\n        self.head = Node()\\n        self.tail = Node()\\n        self.head.next = self.tail\\n        self.tail.prev = self.head\\n        self.lastChild = {}\\n        self.nameToNode = {}\\n\\n    def insertToTail(self, node):\\n        self.insertToNextOfTarget(self.tail.prev, node)\\n        \\n    def insertToLastOfName(self, name:str, node:\\'Node\\'):\\n        parent = name\\n        cur = self.lastChild[name]\\n        while cur.name != name:\\n            name = cur.name\\n            cur = self.lastChild[name]\\n        self.insertToNextOfTarget(cur, node)\\n        self.lastChild[parent] = self.lastChild[node.name]\\n\\n    def insertToNextOfTarget(self, target, node):\\n        node.prev = target\\n        node.next = target.next\\n        target.next.prev = node\\n        target.next = node\\n        self.lastChild[node.name] = node\\n        self.nameToNode[node.name] = node\\n\\n        \\n        \\nclass ThroneInheritance:\\n\\n    def __init__(self, kingName: str):\\n        self.dll = DoublyLinkedList()\\n        self.dll.insertToTail(Node(kingName))\\n\\n    def birth(self, parentName: str, childName: str) -> None:\\n        self.dll.insertToLastOfName(parentName, Node(childName))\\n\\n    def death(self, name: str) -> None:\\n        self.dll.nameToNode[name].status = False\\n\\n    def getInheritanceOrder(self) -> List[str]:\\n        cur = self.dll.head.next\\n        ans = []\\n        while cur != self.dll.tail:\\n            if cur.status: ans.append(cur.name)\\n            cur = cur.next\\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Hash Table",
                    "Doubly-Linked List"
                ],
                "code": "```python\\n\\'\\'\\'\\nwe can use Doubly Linked List to maintain InheritanceOrder.\\nthere has two hash map in Doubly Linked List, one is to record the last child for each parent, if the person has no child, its last child will be itself,\\nanother is to record the location of the node.\\nIf someone\\'s child is born, we can use first hash map to find the node whose last child is itself from his descendants and insert the child next to the node and update the last child of the parent.\\n\\ne.g. \\nt.birth(\"king\", \"andy\");\\nt.birth(\"andy\", \"matthew\");\\nking -> andy -> matthew\\nself.lastChild:\\nking -> andy\\nandy -> matthew\\nmatthew -> matthew\\nt.birth(\"king\", \"bob\"); // insert bob next to matthew\\n\\nsc is O(n)\\ntc of birth is O(depth of family tree)\\ntc of death is O(1)\\ntc of getInheritanceOrder is O(n)\\n\\'\\'\\'\\nclass Node:\\n    def __init__(self, name=\\'\\'):\\n        self.name = name\\n        self.next = None\\n        self.prev = None\\n        self.status = True\\n\\nclass DoublyLinkedList:\\n    def __init__(self):\\n        self.head = Node()\\n        self.tail = Node()\\n        self.head.next = self.tail\\n        self.tail.prev = self.head\\n        self.lastChild = {}\\n        self.nameToNode = {}\\n\\n    def insertToTail(self, node):\\n        self.insertToNextOfTarget(self.tail.prev, node)\\n        \\n    def insertToLastOfName(self, name:str, node:\\'Node\\'):\\n        parent = name\\n        cur = self.lastChild[name]\\n        while cur.name != name:\\n            name = cur.name\\n            cur = self.lastChild[name]\\n        self.insertToNextOfTarget(cur, node)\\n        self.lastChild[parent] = self.lastChild[node.name]\\n\\n    def insertToNextOfTarget(self, target, node):\\n        node.prev = target\\n        node.next = target.next\\n        target.next.prev = node\\n        target.next = node\\n        self.lastChild[node.name] = node\\n        self.nameToNode[node.name] = node\\n\\n        \\n        \\nclass ThroneInheritance:\\n\\n    def __init__(self, kingName: str):\\n        self.dll = DoublyLinkedList()\\n        self.dll.insertToTail(Node(kingName))\\n\\n    def birth(self, parentName: str, childName: str) -> None:\\n        self.dll.insertToLastOfName(parentName, Node(childName))\\n\\n    def death(self, name: str) -> None:\\n        self.dll.nameToNode[name].status = False\\n\\n    def getInheritanceOrder(self) -> List[str]:\\n        cur = self.dll.head.next\\n        ans = []\\n        while cur != self.dll.tail:\\n            if cur.status: ans.append(cur.name)\\n            cur = cur.next\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3385393,
                "title": "c-simple-dfs-hash-map",
                "content": "\\n# Code\\n```\\nclass ThroneInheritance {\\npublic:\\n    map<string,int> m;\\n    unordered_map<string,vector<string>> adj;\\n    string king = \"\";\\n    ThroneInheritance(string kingName) {\\n        adj.clear();\\n        m.clear();\\n        king  = kingName;\\n    }\\n    \\n    void birth(string parentName, string childName) {\\n        adj[parentName].push_back(childName);\\n    }\\n    \\n    void death(string name) {\\n        m[name]++;\\n    }\\n    void dfs(string node,vector<string>& ans,map<string,int>& vis)\\n    {\\n        vis[node] = 1;\\n        if(m.find(node)==m.end())\\n        ans.push_back(node);\\n        for(auto &i:adj[node])\\n        {\\n            if(vis.find(i)==vis.end())\\n            {\\n                dfs(i,ans,vis);\\n            }\\n        }\\n    }\\n    vector<string> getInheritanceOrder() {\\n        vector<string> ans;\\n        map<string,int> vis;\\n        dfs(king,ans,vis);\\n        return ans;\\n    }\\n};\\n\\n/**\\n * Your ThroneInheritance object will be instantiated and called as such:\\n * ThroneInheritance* obj = new ThroneInheritance(kingName);\\n * obj->birth(parentName,childName);\\n * obj->death(name);\\n * vector<string> param_3 = obj->getInheritanceOrder();\\n */\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass ThroneInheritance {\\npublic:\\n    map<string,int> m;\\n    unordered_map<string,vector<string>> adj;\\n    string king = \"\";\\n    ThroneInheritance(string kingName) {\\n        adj.clear();\\n        m.clear();\\n        king  = kingName;\\n    }\\n    \\n    void birth(string parentName, string childName) {\\n        adj[parentName].push_back(childName);\\n    }\\n    \\n    void death(string name) {\\n        m[name]++;\\n    }\\n    void dfs(string node,vector<string>& ans,map<string,int>& vis)\\n    {\\n        vis[node] = 1;\\n        if(m.find(node)==m.end())\\n        ans.push_back(node);\\n        for(auto &i:adj[node])\\n        {\\n            if(vis.find(i)==vis.end())\\n            {\\n                dfs(i,ans,vis);\\n            }\\n        }\\n    }\\n    vector<string> getInheritanceOrder() {\\n        vector<string> ans;\\n        map<string,int> vis;\\n        dfs(king,ans,vis);\\n        return ans;\\n    }\\n};\\n\\n/**\\n * Your ThroneInheritance object will be instantiated and called as such:\\n * ThroneInheritance* obj = new ThroneInheritance(kingName);\\n * obj->birth(parentName,childName);\\n * obj->death(name);\\n * vector<string> param_3 = obj->getInheritanceOrder();\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3297777,
                "title": "go-o-1-birth-o-1-dead",
                "content": "# Space complexity\\n$$O(n)$$ with large constant\\n\\n# Code\\n```\\ntype Tree struct {\\n\\tisDead   bool\\n\\tname     string\\n\\tchildren []*Tree\\n}\\n\\ntype ThroneInheritance struct {\\n\\tmapping map[string]*Tree\\n\\troot    *Tree\\n}\\n\\nfunc Constructor(kingName string) ThroneInheritance {\\n\\tmapping := map[string]*Tree{}\\n\\troot := &Tree{false, kingName, nil}\\n\\tmapping[kingName] = root\\n\\treturn ThroneInheritance{mapping, root}\\n}\\n\\nfunc (this *ThroneInheritance) Birth(parentName string, childName string) {\\n\\tparent := this.mapping[parentName]\\n\\tchild := &Tree{false, childName, nil}\\n\\tparent.children = append(parent.children, child)\\n\\tthis.mapping[childName] = child\\n}\\n\\nfunc (this *ThroneInheritance) Death(name string) {\\n\\tthis.mapping[name].isDead = true\\n}\\n\\nvar (\\n\\tans []string\\n)\\n\\nfunc iterate(node *Tree) {\\n\\tif !node.isDead {\\n\\t\\tans = append(ans, node.name)\\n\\t}\\n\\tfor _, v := range node.children {\\n\\t\\titerate(v)\\n\\t}\\n}\\n\\nfunc (this *ThroneInheritance) GetInheritanceOrder() []string {\\n\\tans = []string{}\\n\\titerate(this.root)\\n\\treturn ans\\n}\\n\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\ntype Tree struct {\\n\\tisDead   bool\\n\\tname     string\\n\\tchildren []*Tree\\n}\\n\\ntype ThroneInheritance struct {\\n\\tmapping map[string]*Tree\\n\\troot    *Tree\\n}\\n\\nfunc Constructor(kingName string) ThroneInheritance {\\n\\tmapping := map[string]*Tree{}\\n\\troot := &Tree{false, kingName, nil}\\n\\tmapping[kingName] = root\\n\\treturn ThroneInheritance{mapping, root}\\n}\\n\\nfunc (this *ThroneInheritance) Birth(parentName string, childName string) {\\n\\tparent := this.mapping[parentName]\\n\\tchild := &Tree{false, childName, nil}\\n\\tparent.children = append(parent.children, child)\\n\\tthis.mapping[childName] = child\\n}\\n\\nfunc (this *ThroneInheritance) Death(name string) {\\n\\tthis.mapping[name].isDead = true\\n}\\n\\nvar (\\n\\tans []string\\n)\\n\\nfunc iterate(node *Tree) {\\n\\tif !node.isDead {\\n\\t\\tans = append(ans, node.name)\\n\\t}\\n\\tfor _, v := range node.children {\\n\\t\\titerate(v)\\n\\t}\\n}\\n\\nfunc (this *ThroneInheritance) GetInheritanceOrder() []string {\\n\\tans = []string{}\\n\\titerate(this.root)\\n\\treturn ans\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3272785,
                "title": "633-ms",
                "content": "```ruby\\nclass ThroneInheritance\\n\\n    def initialize k\\n        @n = { k => {} }\\n        @t = { k => @n[k] }\\n        @d = Set.new\\n    end\\n\\n    def birth p, c\\n        @n[p][c] = @n[c] = {}\\n    end\\n\\n    def death n\\n        @d << n\\n    end\\n\\n    def get_inheritance_order\\n        r = []\\n        f = -> c do\\n            c.each do\\n                r << _1 unless @d === _1\\n                f.call _2\\n            end\\n        end\\n        f.call @t\\n        r\\n    end\\n\\nend\\n```",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```ruby\\nclass ThroneInheritance\\n\\n    def initialize k\\n        @n = { k => {} }\\n        @t = { k => @n[k] }\\n        @d = Set.new\\n    end\\n\\n    def birth p, c\\n        @n[p][c] = @n[c] = {}\\n    end\\n\\n    def death n\\n        @d << n\\n    end\\n\\n    def get_inheritance_order\\n        r = []\\n        f = -> c do\\n            c.each do\\n                r << _1 unless @d === _1\\n                f.call _2\\n            end\\n        end\\n        f.call @t\\n        r\\n    end\\n\\nend\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3262008,
                "title": "c",
                "content": "```\\nclass ThroneInheritance {\\nprivate: \\n    string kingName ;\\n    unordered_set<string>dead ;\\n    unordered_map<string, vector<string>>family ; //{parent, child}\\n    \\n    void dfs(string& name, vector<string>&ret){\\n        if(!dead.count(name))\\n            ret.push_back(name) ;\\n        for(auto& child : family[name])\\n            dfs(child, ret) ;\\n    }\\npublic:\\n    ThroneInheritance(string kingName) {\\n        this->kingName = kingName ;        \\n    }\\n    \\n    void birth(string parentName, string childName) {\\n        family[parentName].push_back(childName) ;\\n    }\\n    \\n    void death(string name) {\\n        dead.insert(name) ;\\n    }\\n    \\n    vector<string> getInheritanceOrder() {\\n        vector<string>ans ;\\n        dfs(kingName, ans) ;\\n        return ans ;\\n    }\\n};\\n\\n/**\\n * Your ThroneInheritance object will be instantiated and called as such:\\n * ThroneInheritance* obj = new ThroneInheritance(kingName);\\n * obj->birth(parentName,childName);\\n * obj->death(name);\\n * vector<string> param_3 = obj->getInheritanceOrder();\\n */\\n```",
                "solutionTags": [],
                "code": "```\\nclass ThroneInheritance {\\nprivate: \\n    string kingName ;\\n    unordered_set<string>dead ;\\n    unordered_map<string, vector<string>>family ; //{parent, child}\\n    \\n    void dfs(string& name, vector<string>&ret){\\n        if(!dead.count(name))\\n            ret.push_back(name) ;\\n        for(auto& child : family[name])\\n            dfs(child, ret) ;\\n    }\\npublic:\\n    ThroneInheritance(string kingName) {\\n        this->kingName = kingName ;        \\n    }\\n    \\n    void birth(string parentName, string childName) {\\n        family[parentName].push_back(childName) ;\\n    }\\n    \\n    void death(string name) {\\n        dead.insert(name) ;\\n    }\\n    \\n    vector<string> getInheritanceOrder() {\\n        vector<string>ans ;\\n        dfs(kingName, ans) ;\\n        return ans ;\\n    }\\n};\\n\\n/**\\n * Your ThroneInheritance object will be instantiated and called as such:\\n * ThroneInheritance* obj = new ThroneInheritance(kingName);\\n * obj->birth(parentName,childName);\\n * obj->death(name);\\n * vector<string> param_3 = obj->getInheritanceOrder();\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3261649,
                "title": "accepted-swift",
                "content": "```\\nclass ThroneInheritance {\\n\\n    private class Member {\\n        let name: String\\n        var children = [Member]()\\n        var dead = false\\n\\n        init(_ name: String) {\\n            self.name = name\\n        }\\n\\n        var inh: [String] {\\n            (dead ? [] : [name]) + children.flatMap(\\\\.inh)\\n        }\\n    }\\n\\n    private let king: Member\\n    private var idx = [String: Member]()\\n\\n    init(_ kingName: String) {\\n        king = Member(kingName)\\n        idx[kingName] = king\\n    }\\n    \\n    func birth(_ parentName: String, _ childName: String) {\\n        let new = Member(childName)\\n        idx[parentName]!.children.append(new)\\n        idx[childName] = new\\n    }\\n    \\n    func death(_ name: String) {\\n        idx[name]!.dead = true\\n    }\\n    \\n    func getInheritanceOrder() -> [String] {\\n        king.inh\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass ThroneInheritance {\\n\\n    private class Member {\\n        let name: String\\n        var children = [Member]()\\n        var dead = false\\n\\n        init(_ name: String) {\\n            self.name = name\\n        }\\n\\n        var inh: [String] {\\n            (dead ? [] : [name]) + children.flatMap(\\\\.inh)\\n        }\\n    }\\n\\n    private let king: Member\\n    private var idx = [String: Member]()\\n\\n    init(_ kingName: String) {\\n        king = Member(kingName)\\n        idx[kingName] = king\\n    }\\n    \\n    func birth(_ parentName: String, _ childName: String) {\\n        let new = Member(childName)\\n        idx[parentName]!.children.append(new)\\n        idx[childName] = new\\n    }\\n    \\n    func death(_ name: String) {\\n        idx[name]!.dead = true\\n    }\\n    \\n    func getInheritanceOrder() -> [String] {\\n        king.inh\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3237498,
                "title": "c-easy-and-fast-hashmap-recursion",
                "content": "```\\nclass ThroneInheritance {\\npublic:\\n    unordered_map<string,vector<string>>mp;\\n    unordered_map<string,bool>deathList;\\n    string root;\\n    \\n    ThroneInheritance(string kingName) {\\n        mp[kingName]={};\\n        root = kingName;\\n    }\\n    \\n    void birth(string parentName, string childName) {\\n        mp[parentName].push_back(childName);\\n        mp[childName]={};\\n    }\\n    \\n    void death(string name) {\\n        deathList[name]=true;\\n    }\\n    \\n    vector<string> getInheritanceOrder() {\\n        \\n        vector<string> list = Successor(root);\\n        return list;\\n    }\\n    vector<string> Successor(string &Parent){\\n\\n        vector<string> list;\\n        if(!deathList.count(Parent))\\n            list.push_back(Parent);\\n        \\n        for(auto it:mp[Parent]){\\n            vector<string> temp = Successor(it);\\n            list.insert(list.end(),temp.begin(),temp.end());\\n        }\\n        return list;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Recursion"
                ],
                "code": "```\\nclass ThroneInheritance {\\npublic:\\n    unordered_map<string,vector<string>>mp;\\n    unordered_map<string,bool>deathList;\\n    string root;\\n    \\n    ThroneInheritance(string kingName) {\\n        mp[kingName]={};\\n        root = kingName;\\n    }\\n    \\n    void birth(string parentName, string childName) {\\n        mp[parentName].push_back(childName);\\n        mp[childName]={};\\n    }\\n    \\n    void death(string name) {\\n        deathList[name]=true;\\n    }\\n    \\n    vector<string> getInheritanceOrder() {\\n        \\n        vector<string> list = Successor(root);\\n        return list;\\n    }\\n    vector<string> Successor(string &Parent){\\n\\n        vector<string> list;\\n        if(!deathList.count(Parent))\\n            list.push_back(Parent);\\n        \\n        for(auto it:mp[Parent]){\\n            vector<string> temp = Successor(it);\\n            list.insert(list.end(),temp.begin(),temp.end());\\n        }\\n        return list;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3207281,
                "title": "n-ary-tree-based-approach",
                "content": "\\n# Code\\n```\\nstruct Node{\\n    string val;\\n    bool isDead = false;\\n    vector<Node *> children;\\n    \\n    Node(string val){\\n        this->val = val;\\n    }\\n};\\n\\nclass ThroneInheritance {\\nprivate:\\n    Node *root;\\n\\n    //map to hold reference to every member of family tree\\n    unordered_map<string, Node *> mp;\\npublic:\\n    ThroneInheritance(string kingName) {\\n        root = new Node(kingName);\\n        mp[kingName] = root;\\n    }\\n    \\n    void birth(string parentName, string childName) {\\n        Node *child = new Node(childName);\\n        mp[parentName]->children.push_back(child);\\n        mp[childName] = child;\\n    }\\n    \\n    void death(string name) {\\n        mp[name]->isDead = true;\\n    }\\n    \\n    vector<string> getInheritanceOrder() {\\n        vector<string> res;\\n        get(res, root);\\n        return res;     \\n    }\\n\\n    void get(vector<string> &res, Node *root){\\n        if(!root->isDead) res.push_back(root->val);\\n        for(auto x : root->children){\\n            get(res, x);\\n        }\\n    }\\n};\\n\\n/**\\n * Your ThroneInheritance object will be instantiated and called as such:\\n * ThroneInheritance* obj = new ThroneInheritance(kingName);\\n * obj->birth(parentName,childName);\\n * obj->death(name);\\n * vector<string> param_3 = obj->getInheritanceOrder();\\n */\\n```",
                "solutionTags": [
                    "C++",
                    "Tree"
                ],
                "code": "```\\nstruct Node{\\n    string val;\\n    bool isDead = false;\\n    vector<Node *> children;\\n    \\n    Node(string val){\\n        this->val = val;\\n    }\\n};\\n\\nclass ThroneInheritance {\\nprivate:\\n    Node *root;\\n\\n    //map to hold reference to every member of family tree\\n    unordered_map<string, Node *> mp;\\npublic:\\n    ThroneInheritance(string kingName) {\\n        root = new Node(kingName);\\n        mp[kingName] = root;\\n    }\\n    \\n    void birth(string parentName, string childName) {\\n        Node *child = new Node(childName);\\n        mp[parentName]->children.push_back(child);\\n        mp[childName] = child;\\n    }\\n    \\n    void death(string name) {\\n        mp[name]->isDead = true;\\n    }\\n    \\n    vector<string> getInheritanceOrder() {\\n        vector<string> res;\\n        get(res, root);\\n        return res;     \\n    }\\n\\n    void get(vector<string> &res, Node *root){\\n        if(!root->isDead) res.push_back(root->val);\\n        for(auto x : root->children){\\n            get(res, x);\\n        }\\n    }\\n};\\n\\n/**\\n * Your ThroneInheritance object will be instantiated and called as such:\\n * ThroneInheritance* obj = new ThroneInheritance(kingName);\\n * obj->birth(parentName,childName);\\n * obj->death(name);\\n * vector<string> param_3 = obj->getInheritanceOrder();\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3182239,
                "title": "java-hashmap",
                "content": "\\n# Code\\n```\\nclass ThroneInheritance {\\n    private final Node root;\\n    private final Map<String, Node> map = new HashMap<>();\\n\\n    public ThroneInheritance(String kingName) {\\n        root = new Node(kingName);\\n        map.put(kingName, root);\\n    }\\n    \\n    public void birth(String parentName, String childName) {\\n        Node parentNode = map.get(parentName);\\n        Node newChildNode = new Node(childName);\\n        map.put(childName, newChildNode);\\n        parentNode.children.add(newChildNode);;\\n    }\\n    \\n    public void death(String name) {\\n        Node node = map.get(name);\\n        node.isDead = true;\\n    }\\n    \\n    public List<String> getInheritanceOrder() {\\n        List<String> res = new ArrayList<>();\\n        LinkedList<Node> stack = new LinkedList<>();\\n        stack.add(root);\\n        while (!stack.isEmpty()) {\\n            Node node = stack.pollFirst();\\n            if (!node.isDead) {\\n                res.add(node.name);\\n            }\\n            int n = node.children.size();\\n            for (int i = n - 1; i >= 0; i--) {\\n                stack.addFirst(node.children.get(i));\\n            }\\n        }\\n        return res;\\n    }\\n\\n    static class Node {\\n        public String name;\\n        public List<Node> children = new ArrayList<>();\\n        public boolean isDead;\\n\\n        public Node(String name) {\\n            this.name = name;\\n        } \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass ThroneInheritance {\\n    private final Node root;\\n    private final Map<String, Node> map = new HashMap<>();\\n\\n    public ThroneInheritance(String kingName) {\\n        root = new Node(kingName);\\n        map.put(kingName, root);\\n    }\\n    \\n    public void birth(String parentName, String childName) {\\n        Node parentNode = map.get(parentName);\\n        Node newChildNode = new Node(childName);\\n        map.put(childName, newChildNode);\\n        parentNode.children.add(newChildNode);;\\n    }\\n    \\n    public void death(String name) {\\n        Node node = map.get(name);\\n        node.isDead = true;\\n    }\\n    \\n    public List<String> getInheritanceOrder() {\\n        List<String> res = new ArrayList<>();\\n        LinkedList<Node> stack = new LinkedList<>();\\n        stack.add(root);\\n        while (!stack.isEmpty()) {\\n            Node node = stack.pollFirst();\\n            if (!node.isDead) {\\n                res.add(node.name);\\n            }\\n            int n = node.children.size();\\n            for (int i = n - 1; i >= 0; i--) {\\n                stack.addFirst(node.children.get(i));\\n            }\\n        }\\n        return res;\\n    }\\n\\n    static class Node {\\n        public String name;\\n        public List<Node> children = new ArrayList<>();\\n        public boolean isDead;\\n\\n        public Node(String name) {\\n            this.name = name;\\n        } \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3178658,
                "title": "just-a-runnable-solution",
                "content": "# Code\\n```\\nuse std::collections::HashMap;\\n\\nstruct ThroneInheritance {\\n    king: String,\\n    dead: HashMap<String, bool>,\\n    children: HashMap<String, Vec<String>>,\\n}\\n\\nimpl ThroneInheritance {\\n    fn new(king_name: String) -> Self {\\n        Self {\\n            king: king_name,\\n            dead: HashMap::new(),\\n            children: HashMap::new(),\\n        }\\n    }\\n\\n    fn birth(&mut self, parent_name: String, child_name: String) {\\n        self.children\\n            .entry(parent_name)\\n            .or_insert_with(Vec::new)\\n            .push(child_name);\\n    }\\n\\n    fn death(&mut self, name: String) {\\n        self.dead.insert(name, true);\\n    }\\n\\n    fn get_inheritance_order(&self) -> Vec<String> {\\n        let mut order = Vec::new();\\n        self.dfs(&self.king, &mut order);\\n        order\\n    }\\n\\n    fn dfs(&self, name: &str, order: &mut Vec<String>) {\\n        if !self.dead.contains_key(name) {\\n            order.push(name.to_string());\\n        }\\n        if let Some(children) = self.children.get(name) {\\n            for child in children {\\n                self.dfs(child, order);\\n            }\\n        }\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nuse std::collections::HashMap;\\n\\nstruct ThroneInheritance {\\n    king: String,\\n    dead: HashMap<String, bool>,\\n    children: HashMap<String, Vec<String>>,\\n}\\n\\nimpl ThroneInheritance {\\n    fn new(king_name: String) -> Self {\\n        Self {\\n            king: king_name,\\n            dead: HashMap::new(),\\n            children: HashMap::new(),\\n        }\\n    }\\n\\n    fn birth(&mut self, parent_name: String, child_name: String) {\\n        self.children\\n            .entry(parent_name)\\n            .or_insert_with(Vec::new)\\n            .push(child_name);\\n    }\\n\\n    fn death(&mut self, name: String) {\\n        self.dead.insert(name, true);\\n    }\\n\\n    fn get_inheritance_order(&self) -> Vec<String> {\\n        let mut order = Vec::new();\\n        self.dfs(&self.king, &mut order);\\n        order\\n    }\\n\\n    fn dfs(&self, name: &str, order: &mut Vec<String>) {\\n        if !self.dead.contains_key(name) {\\n            order.push(name.to_string());\\n        }\\n        if let Some(children) = self.children.get(name) {\\n            for child in children {\\n                self.dfs(child, order);\\n            }\\n        }\\n    }\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3098573,
                "title": "it-s-a-joke-very-easy-must-see",
                "content": "# Code\\n```\\nclass ThroneInheritance {\\npublic:\\n    string root = \"\";\\n    unordered_set<string>st;\\n    unordered_map<string,vector<string>>mp;\\n    ThroneInheritance(string kingName) \\n    {\\n        root = kingName;\\n    }\\n\\n    void birth(string parent, string child) \\n    {\\n         mp[parent].push_back(child);\\n    }\\n    \\n    void death(string name) \\n    {\\n         st.insert(name);    \\n    }\\n    \\n    vector<string> getInheritanceOrder() \\n    {\\n          vector<string>v;\\n          fun(root,v);\\n          return v;\\n    }\\n    void fun(string root,vector<string>&v)\\n    {\\n        if(st.find(root) == st.end())\\n        v.push_back(root);\\n\\n        for(string child : mp[root])\\n        fun(child,v);\\n    }\\n};\\n\\n/**\\n * Your ThroneInheritance object will be instantiated and called as such:\\n * ThroneInheritance* obj = new ThroneInheritance(kingName);\\n * obj->birth(parentName,childName);\\n * obj->death(name);\\n * vector<string> param_3 = obj->getInheritanceOrder();\\n */\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Tree",
                    "Depth-First Search",
                    "Design"
                ],
                "code": "```\\nclass ThroneInheritance {\\npublic:\\n    string root = \"\";\\n    unordered_set<string>st;\\n    unordered_map<string,vector<string>>mp;\\n    ThroneInheritance(string kingName) \\n    {\\n        root = kingName;\\n    }\\n\\n    void birth(string parent, string child) \\n    {\\n         mp[parent].push_back(child);\\n    }\\n    \\n    void death(string name) \\n    {\\n         st.insert(name);    \\n    }\\n    \\n    vector<string> getInheritanceOrder() \\n    {\\n          vector<string>v;\\n          fun(root,v);\\n          return v;\\n    }\\n    void fun(string root,vector<string>&v)\\n    {\\n        if(st.find(root) == st.end())\\n        v.push_back(root);\\n\\n        for(string child : mp[root])\\n        fun(child,v);\\n    }\\n};\\n\\n/**\\n * Your ThroneInheritance object will be instantiated and called as such:\\n * ThroneInheritance* obj = new ThroneInheritance(kingName);\\n * obj->birth(parentName,childName);\\n * obj->death(name);\\n * vector<string> param_3 = obj->getInheritanceOrder();\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3083557,
                "title": "java-dfs-pre-order-traversal-clean-code",
                "content": "# Code\\n```\\nclass ThroneInheritance {\\n\\n    class Royal {\\n        String name = \"\";\\n        boolean isAlive = true;\\n        List<Royal> children = new ArrayList<>();\\n        public Royal(String name) {\\n            this.name = name;\\n        }\\n    }\\n\\n    Royal root;\\n    Map<String, Royal> royalFamily;\\n\\n    public ThroneInheritance(String kingName) {\\n        root = new Royal(kingName);\\n        royalFamily = new HashMap<>();\\n        royalFamily.put(kingName, root);\\n    }\\n    \\n    public void birth(String parentName, String childName) {\\n        Royal member = royalFamily.get(parentName);\\n        Royal child = new Royal(childName);\\n        member.children.add(child);\\n        royalFamily.put(childName, child);\\n    }\\n    \\n    public void death(String name) {\\n        Royal member = royalFamily.get(name);\\n        member.isAlive = false;\\n    }\\n    \\n    public List<String> getInheritanceOrder() {\\n        List<String> res = new LinkedList<String>();\\n        traverse(root, res);\\n        return res;\\n    }\\n\\n    private void traverse(Royal root, List<String> res) {\\n        if (root.isAlive) {\\n            res.add(root.name);\\n        }\\n        for (Royal child : root.children) {\\n            traverse(child, res);\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass ThroneInheritance {\\n\\n    class Royal {\\n        String name = \"\";\\n        boolean isAlive = true;\\n        List<Royal> children = new ArrayList<>();\\n        public Royal(String name) {\\n            this.name = name;\\n        }\\n    }\\n\\n    Royal root;\\n    Map<String, Royal> royalFamily;\\n\\n    public ThroneInheritance(String kingName) {\\n        root = new Royal(kingName);\\n        royalFamily = new HashMap<>();\\n        royalFamily.put(kingName, root);\\n    }\\n    \\n    public void birth(String parentName, String childName) {\\n        Royal member = royalFamily.get(parentName);\\n        Royal child = new Royal(childName);\\n        member.children.add(child);\\n        royalFamily.put(childName, child);\\n    }\\n    \\n    public void death(String name) {\\n        Royal member = royalFamily.get(name);\\n        member.isAlive = false;\\n    }\\n    \\n    public List<String> getInheritanceOrder() {\\n        List<String> res = new LinkedList<String>();\\n        traverse(root, res);\\n        return res;\\n    }\\n\\n    private void traverse(Royal root, List<String> res) {\\n        if (root.isAlive) {\\n            res.add(root.name);\\n        }\\n        for (Royal child : root.children) {\\n            traverse(child, res);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3066270,
                "title": "modern-c",
                "content": "\\n\\n# Code\\n``` Cpp\\nclass ThroneInheritance {\\n    std::unordered_map<string,vector<string>> childrenOf{}; \\n    std::unordered_map<string,bool> isAlive{}; \\n    string m_king; \\npublic:\\n    ThroneInheritance(string kingName) {\\n        isAlive[kingName] = true;\\n        m_king = kingName;   \\n    }\\n    \\n    void birth(string parentName, string childName) {\\n        childrenOf[parentName].emplace_back(childName); \\n        isAlive[childName] = true; \\n    }\\n    \\n    void death(string name) {\\n        isAlive[name] = false; \\n        \\n    }\\n    \\n    vector<string> getInheritanceOrder() {\\n        vector<string> ans{}; \\n        getOrderRecursive(ans,m_king); \\n        return ans; \\n    }\\n\\n    void getOrderRecursive(vector<string>& ans, string cur){\\n        if(isAlive[cur]){\\n            ans.push_back(cur);\\n        } \\n        for(const auto& child : childrenOf[cur]){\\n            getOrderRecursive(ans,child); \\n        }\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "``` Cpp\\nclass ThroneInheritance {\\n    std::unordered_map<string,vector<string>> childrenOf{}; \\n    std::unordered_map<string,bool> isAlive{}; \\n    string m_king; \\npublic:\\n    ThroneInheritance(string kingName) {\\n        isAlive[kingName] = true;\\n        m_king = kingName;   \\n    }\\n    \\n    void birth(string parentName, string childName) {\\n        childrenOf[parentName].emplace_back(childName); \\n        isAlive[childName] = true; \\n    }\\n    \\n    void death(string name) {\\n        isAlive[name] = false; \\n        \\n    }\\n    \\n    vector<string> getInheritanceOrder() {\\n        vector<string> ans{}; \\n        getOrderRecursive(ans,m_king); \\n        return ans; \\n    }\\n\\n    void getOrderRecursive(vector<string>& ans, string cur){\\n        if(isAlive[cur]){\\n            ans.push_back(cur);\\n        } \\n        for(const auto& child : childrenOf[cur]){\\n            getOrderRecursive(ans,child); \\n        }\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3064703,
                "title": "easy-c-solution",
                "content": "\\n# Code\\n```\\nclass ThroneInheritance {\\npublic:\\n    unordered_map<string,vector<string>>mp;\\n    unordered_set<string>st;\\n    string king;\\n    ThroneInheritance(string kn) {\\n        king=kn;\\n    }\\n    \\n    void birth(string pn, string cn) {\\n        mp[pn].push_back(cn);\\n    }\\n    \\n    void death(string name) {\\n        st.insert(name);\\n    }\\n    \\n    vector<string> getInheritanceOrder() {\\n        vector<string>ans;\\n        dfs(king,ans);\\n        return ans;\\n    }\\n    void dfs(string &s,vector<string>&ans)\\n    {\\n        if(st.find(s)==st.end())\\n        {\\n            ans.push_back(s);\\n        }\\n        for(auto it=mp[s].begin();it!=mp[s].end();it++)\\n        {\\n            dfs(*it,ans);\\n        }\\n    }\\n};\\n\\n/**\\n * Your ThroneInheritance object will be instantiated and called as such:\\n * ThroneInheritance* obj = new ThroneInheritance(kingName);\\n * obj->birth(parentName,childName);\\n * obj->death(name);\\n * vector<string> param_3 = obj->getInheritanceOrder();\\n */\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Depth-First Search",
                    "Design"
                ],
                "code": "```\\nclass ThroneInheritance {\\npublic:\\n    unordered_map<string,vector<string>>mp;\\n    unordered_set<string>st;\\n    string king;\\n    ThroneInheritance(string kn) {\\n        king=kn;\\n    }\\n    \\n    void birth(string pn, string cn) {\\n        mp[pn].push_back(cn);\\n    }\\n    \\n    void death(string name) {\\n        st.insert(name);\\n    }\\n    \\n    vector<string> getInheritanceOrder() {\\n        vector<string>ans;\\n        dfs(king,ans);\\n        return ans;\\n    }\\n    void dfs(string &s,vector<string>&ans)\\n    {\\n        if(st.find(s)==st.end())\\n        {\\n            ans.push_back(s);\\n        }\\n        for(auto it=mp[s].begin();it!=mp[s].end();it++)\\n        {\\n            dfs(*it,ans);\\n        }\\n    }\\n};\\n\\n/**\\n * Your ThroneInheritance object will be instantiated and called as such:\\n * ThroneInheritance* obj = new ThroneInheritance(kingName);\\n * obj->birth(parentName,childName);\\n * obj->death(name);\\n * vector<string> param_3 = obj->getInheritanceOrder();\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3018589,
                "title": "simple-dfs-beats-98",
                "content": "```\\nclass ThroneInheritance:\\n\\n    def __init__(self, kingName: str):\\n        self.king = kingName\\n        self.map = {kingName: []}\\n        self.dead = set()\\n\\n    def birth(self, parentName: str, childName: str) -> None:\\n        if parentName in self.map:\\n            self.map[parentName].append(childName)\\n        else:\\n            self.map[parentName] = [childName]\\n\\n    def death(self, name: str) -> None:\\n        self.dead.add(name)\\n\\n    def getInheritanceOrder(self) -> List[str]:\\n        order = []\\n        def dfs(person=self.king):\\n            if person not in self.dead:\\n                order.append(person)\\n\\n            if person in self.map:\\n                for child in self.map[person]:\\n                    dfs(child)\\n        dfs()\\n        return order\\n```",
                "solutionTags": [
                    "Python3",
                    "Depth-First Search"
                ],
                "code": "```\\nclass ThroneInheritance:\\n\\n    def __init__(self, kingName: str):\\n        self.king = kingName\\n        self.map = {kingName: []}\\n        self.dead = set()\\n\\n    def birth(self, parentName: str, childName: str) -> None:\\n        if parentName in self.map:\\n            self.map[parentName].append(childName)\\n        else:\\n            self.map[parentName] = [childName]\\n\\n    def death(self, name: str) -> None:\\n        self.dead.add(name)\\n\\n    def getInheritanceOrder(self) -> List[str]:\\n        order = []\\n        def dfs(person=self.king):\\n            if person not in self.dead:\\n                order.append(person)\\n\\n            if person in self.map:\\n                for child in self.map[person]:\\n                    dfs(child)\\n        dfs()\\n        return order\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2959691,
                "title": "golang-dfs-map",
                "content": "# Code\\n```\\ntype ThroneInheritance struct {\\n    adjList map[string][]string\\n    source string\\n    dead map[string]bool\\n}\\n\\n\\nfunc Constructor(kingName string) ThroneInheritance {\\n    return ThroneInheritance {\\n        adjList: make(map[string][]string),\\n        source: kingName,\\n        dead: make(map[string]bool),\\n    }\\n}\\n\\n\\nfunc (this *ThroneInheritance) Birth(parentName string, childName string)  {\\n    this.adjList[parentName] = append(this.adjList[parentName], childName)\\n}\\n\\n\\nfunc (this *ThroneInheritance) Death(name string)  {\\n    this.dead[name] = true\\n}\\n\\nfunc (this *ThroneInheritance) dfs(curr string, visited map[string]bool, ans *[]string) {\\n    if visited[curr] {\\n        return\\n    } \\n    visited[curr] = true\\n    if this.dead[curr] == false {\\n        *ans = append(*ans, curr)\\n    }\\n    for _, next := range this.adjList[curr] {\\n        this.dfs(next, visited, ans)\\n    }\\n}\\n\\nfunc (this *ThroneInheritance) GetInheritanceOrder() []string {\\n    visited := make(map[string]bool)\\n    ans := []string{}\\n    this.dfs(this.source, visited, &ans)\\n    return ans\\n}\\n\\n\\n/**\\n * Your ThroneInheritance object will be instantiated and called as such:\\n * obj := Constructor(kingName);\\n * obj.Birth(parentName,childName);\\n * obj.Death(name);\\n * param_3 := obj.GetInheritanceOrder();\\n */\\n```",
                "solutionTags": [
                    "Go",
                    "Hash Table",
                    "Tree",
                    "Depth-First Search",
                    "Design"
                ],
                "code": "```\\ntype ThroneInheritance struct {\\n    adjList map[string][]string\\n    source string\\n    dead map[string]bool\\n}\\n\\n\\nfunc Constructor(kingName string) ThroneInheritance {\\n    return ThroneInheritance {\\n        adjList: make(map[string][]string),\\n        source: kingName,\\n        dead: make(map[string]bool),\\n    }\\n}\\n\\n\\nfunc (this *ThroneInheritance) Birth(parentName string, childName string)  {\\n    this.adjList[parentName] = append(this.adjList[parentName], childName)\\n}\\n\\n\\nfunc (this *ThroneInheritance) Death(name string)  {\\n    this.dead[name] = true\\n}\\n\\nfunc (this *ThroneInheritance) dfs(curr string, visited map[string]bool, ans *[]string) {\\n    if visited[curr] {\\n        return\\n    } \\n    visited[curr] = true\\n    if this.dead[curr] == false {\\n        *ans = append(*ans, curr)\\n    }\\n    for _, next := range this.adjList[curr] {\\n        this.dfs(next, visited, ans)\\n    }\\n}\\n\\nfunc (this *ThroneInheritance) GetInheritanceOrder() []string {\\n    visited := make(map[string]bool)\\n    ans := []string{}\\n    this.dfs(this.source, visited, &ans)\\n    return ans\\n}\\n\\n\\n/**\\n * Your ThroneInheritance object will be instantiated and called as such:\\n * obj := Constructor(kingName);\\n * obj.Birth(parentName,childName);\\n * obj.Death(name);\\n * param_3 := obj.GetInheritanceOrder();\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2959553,
                "title": "c-map-dfs",
                "content": "# Code\\n```\\nclass ThroneInheritance {\\n    unordered_map<string, vector<string>> adjList; \\n    string source;\\n    unordered_set<string> dead;\\npublic:\\n    ThroneInheritance(string kingName) {\\n        source = kingName;\\n    }\\n    \\n    void birth(string parentName, string childName) {\\n        adjList[parentName].push_back(childName);\\n    }\\n    \\n    void death(string name) {\\n        dead.insert(name);\\n    }\\n\\n    void dfs(string curr, unordered_set<string> &visited, vector<string> &ans) {\\n        if(visited.find(curr) != visited.end()) return;\\n        visited.insert(curr);\\n        if(dead.find(curr) == dead.end()) ans.push_back(curr);\\n        for(string next: adjList[curr]) {\\n            dfs(next, visited, ans);\\n        }\\n    }\\n    \\n    vector<string> getInheritanceOrder() {\\n        unordered_set<string> visited;\\n        vector<string> ans;\\n        dfs(source, visited, ans);\\n        return ans;\\n    }\\n};\\n\\n/**\\n * Your ThroneInheritance object will be instantiated and called as such:\\n * ThroneInheritance* obj = new ThroneInheritance(kingName);\\n * obj->birth(parentName,childName);\\n * obj->death(name);\\n * vector<string> param_3 = obj->getInheritanceOrder();\\n */\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Tree",
                    "Depth-First Search",
                    "Design"
                ],
                "code": "```\\nclass ThroneInheritance {\\n    unordered_map<string, vector<string>> adjList; \\n    string source;\\n    unordered_set<string> dead;\\npublic:\\n    ThroneInheritance(string kingName) {\\n        source = kingName;\\n    }\\n    \\n    void birth(string parentName, string childName) {\\n        adjList[parentName].push_back(childName);\\n    }\\n    \\n    void death(string name) {\\n        dead.insert(name);\\n    }\\n\\n    void dfs(string curr, unordered_set<string> &visited, vector<string> &ans) {\\n        if(visited.find(curr) != visited.end()) return;\\n        visited.insert(curr);\\n        if(dead.find(curr) == dead.end()) ans.push_back(curr);\\n        for(string next: adjList[curr]) {\\n            dfs(next, visited, ans);\\n        }\\n    }\\n    \\n    vector<string> getInheritanceOrder() {\\n        unordered_set<string> visited;\\n        vector<string> ans;\\n        dfs(source, visited, ans);\\n        return ans;\\n    }\\n};\\n\\n/**\\n * Your ThroneInheritance object will be instantiated and called as such:\\n * ThroneInheritance* obj = new ThroneInheritance(kingName);\\n * obj->birth(parentName,childName);\\n * obj->death(name);\\n * vector<string> param_3 = obj->getInheritanceOrder();\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2911153,
                "title": "java-oop-based-dfs-solution",
                "content": "\\nThis problem can be solved using DFS. We model kingdom\\'s inheritance hierarchy as a tree structure with King at root. Then we just do simple DFS to get the order of inheritance. I have used Hashmap for fast lookup of tree nodes and to perform required action on that node. \\n\\n```\\nclass ThroneInheritance {\\n\\n    private static class TreeNode {\\n        String parent;\\n        List<TreeNode> children;\\n        boolean isAlive;\\n        public TreeNode(String parent){\\n            this.parent = parent;\\n            this.children = new ArrayList<>();\\n            this.isAlive = true;\\n        }\\n\\n        public TreeNode addChild(String childName) {\\n            TreeNode node = new TreeNode(childName);\\n            this.children.add(node);\\n            return node;\\n        }\\n\\n        public void die(){\\n            this.isAlive = false;\\n        }\\n\\n        public void traverse(List<String> result){\\n            if(isAlive)\\n                result.add(parent);\\n            for(TreeNode child: children){\\n                child.traverse(result);\\n            }\\n        }\\n\\n    }\\n\\n    private Map<String, TreeNode> nodeMap;\\n    private String kingName;\\n\\n    public ThroneInheritance(String kingName) {\\n        this.kingName = kingName;\\n        nodeMap = new HashMap<>();\\n        TreeNode root = new TreeNode(kingName);\\n        nodeMap.put(kingName, root);\\n    }\\n    \\n    public void birth(String parentName, String childName) {\\n        TreeNode root = nodeMap.getOrDefault(parentName, null);\\n        if(root != null){\\n            TreeNode child = root.addChild(childName);\\n            nodeMap.putIfAbsent(childName, child);\\n        }\\n    }\\n    \\n    public void death(String name) {\\n        TreeNode node = nodeMap.getOrDefault(name, null);\\n        if(node != null){\\n            node.die();\\n        }\\n    }\\n    \\n    public List<String> getInheritanceOrder() {\\n        List<String> result = new ArrayList<>();\\n        TreeNode root = nodeMap.get(kingName);\\n        root.traverse(result);\\n        return result;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "\\nThis problem can be solved using DFS. We model kingdom\\'s inheritance hierarchy as a tree structure with King at root. Then we just do simple DFS to get the order of inheritance. I have used Hashmap for fast lookup of tree nodes and to perform required action on that node. \\n\\n```\\nclass ThroneInheritance {\\n\\n    private static class TreeNode {\\n        String parent;\\n        List<TreeNode> children;\\n        boolean isAlive;\\n        public TreeNode(String parent){\\n            this.parent = parent;\\n            this.children = new ArrayList<>();\\n            this.isAlive = true;\\n        }\\n\\n        public TreeNode addChild(String childName) {\\n            TreeNode node = new TreeNode(childName);\\n            this.children.add(node);\\n            return node;\\n        }\\n\\n        public void die(){\\n            this.isAlive = false;\\n        }\\n\\n        public void traverse(List<String> result){\\n            if(isAlive)\\n                result.add(parent);\\n            for(TreeNode child: children){\\n                child.traverse(result);\\n            }\\n        }\\n\\n    }\\n\\n    private Map<String, TreeNode> nodeMap;\\n    private String kingName;\\n\\n    public ThroneInheritance(String kingName) {\\n        this.kingName = kingName;\\n        nodeMap = new HashMap<>();\\n        TreeNode root = new TreeNode(kingName);\\n        nodeMap.put(kingName, root);\\n    }\\n    \\n    public void birth(String parentName, String childName) {\\n        TreeNode root = nodeMap.getOrDefault(parentName, null);\\n        if(root != null){\\n            TreeNode child = root.addChild(childName);\\n            nodeMap.putIfAbsent(childName, child);\\n        }\\n    }\\n    \\n    public void death(String name) {\\n        TreeNode node = nodeMap.getOrDefault(name, null);\\n        if(node != null){\\n            node.die();\\n        }\\n    }\\n    \\n    public List<String> getInheritanceOrder() {\\n        List<String> result = new ArrayList<>();\\n        TreeNode root = nodeMap.get(kingName);\\n        root.traverse(result);\\n        return result;\\n    }\\n}",
                "codeTag": "Java"
            },
            {
                "id": 2885934,
                "title": "create-a-tree-and-dfs-for-inheritance-order",
                "content": "```\\nfrom collections import defaultdict\\n\\nclass ThroneInheritance:\\n    def __init__(self, kingName: str):\\n        self.king = kingName\\n        self.graph = defaultdict(list)\\n        self.dead = set()\\n\\n    def birth(self, parentName: str, childName: str) -> None:\\n        self.graph[parentName].append(childName)\\n\\n    def death(self, name: str) -> None:\\n        self.dead.add(name)\\n\\n    def getInheritanceOrder(self) -> List[str]:\\n        res = []\\n        stack = [self.king]\\n        while len(stack) > 0:\\n            curr = stack.pop()\\n            if curr not in self.dead:\\n                res.append(curr)\\n            for j in self.graph[curr][::-1]:\\n                stack.append(j)\\n        return res\\n```\\n![image](https://assets.leetcode.com/users/images/8c96a7ea-5791-4d34-9759-c3f0921a613b_1670389011.8698938.png)",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nfrom collections import defaultdict\\n\\nclass ThroneInheritance:\\n    def __init__(self, kingName: str):\\n        self.king = kingName\\n        self.graph = defaultdict(list)\\n        self.dead = set()\\n\\n    def birth(self, parentName: str, childName: str) -> None:\\n        self.graph[parentName].append(childName)\\n\\n    def death(self, name: str) -> None:\\n        self.dead.add(name)\\n\\n    def getInheritanceOrder(self) -> List[str]:\\n        res = []\\n        stack = [self.king]\\n        while len(stack) > 0:\\n            curr = stack.pop()\\n            if curr not in self.dead:\\n                res.append(curr)\\n            for j in self.graph[curr][::-1]:\\n                stack.append(j)\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2830715,
                "title": "easy-dfs-solution",
                "content": "# Intuition\\ntreat all the members  as nodes and create relationship between them by creating a tree-like structure.\\n\\n# Approach\\nstart from the king in dfs call and store it in string ans.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass ThroneInheritance {\\npublic:\\nmap<string,vector<string>>mp;\\n     string k;\\n     map<string,int>isAlive;\\n    ThroneInheritance(string kingName) \\n    {\\n     k=kingName;\\n     isAlive[k]=1;\\n    }\\n    void dfs(string k,vector<string>&ans)\\n    {\\n        if (isAlive[k])\\n        {\\n            ans.push_back(k);\\n        }\\n        for(auto it: mp[k])\\n        {\\n            dfs(it,ans);\\n        }\\n    }\\n    \\n    \\n    void birth(string parentName, string childName)\\n     {\\n        mp[parentName].push_back(childName);\\n        isAlive[parentName]=1;\\n        isAlive[childName]=1;\\n    }\\n    \\n    void death(string name) {\\n        isAlive[name]=0;\\n        \\n        \\n    }\\n    \\n    vector<string> getInheritanceOrder() {\\n        vector<string>ans;\\n        dfs(k,ans);\\n        return ans;\\n    }\\n};\\n\\n/**\\n * Your ThroneInheritance object will be instantiated and called as such:\\n * ThroneInheritance* obj = new ThroneInheritance(kingName);\\n * obj->birth(parentName,childName);\\n * obj->death(name);\\n * vector<string> param_3 = obj->getInheritanceOrder();\\n */\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass ThroneInheritance {\\npublic:\\nmap<string,vector<string>>mp;\\n     string k;\\n     map<string,int>isAlive;\\n    ThroneInheritance(string kingName) \\n    {\\n     k=kingName;\\n     isAlive[k]=1;\\n    }\\n    void dfs(string k,vector<string>&ans)\\n    {\\n        if (isAlive[k])\\n        {\\n            ans.push_back(k);\\n        }\\n        for(auto it: mp[k])\\n        {\\n            dfs(it,ans);\\n        }\\n    }\\n    \\n    \\n    void birth(string parentName, string childName)\\n     {\\n        mp[parentName].push_back(childName);\\n        isAlive[parentName]=1;\\n        isAlive[childName]=1;\\n    }\\n    \\n    void death(string name) {\\n        isAlive[name]=0;\\n        \\n        \\n    }\\n    \\n    vector<string> getInheritanceOrder() {\\n        vector<string>ans;\\n        dfs(k,ans);\\n        return ans;\\n    }\\n};\\n\\n/**\\n * Your ThroneInheritance object will be instantiated and called as such:\\n * ThroneInheritance* obj = new ThroneInheritance(kingName);\\n * obj->birth(parentName,childName);\\n * obj->death(name);\\n * vector<string> param_3 = obj->getInheritanceOrder();\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2830714,
                "title": "simple-c-solution-easy-to-understand",
                "content": "# Intuition\\nTreat all the members of the kingdom as nodes. Create a graph. We simply have to do DFS.\\n# Code\\n```\\nclass ThroneInheritance \\n{\\npublic:\\n    int time;\\n    map<string,int> isAlive;\\n    map<string,vector<pair<int,string>>> parentChild;\\n    string k;\\n    ThroneInheritance(string kingName) \\n    {\\n        isAlive[kingName]=1;\\n        k=kingName;\\n        time=0;\\n    }\\n    \\n    void birth(string parentName, string childName) \\n    {\\n        time++;\\n        parentChild[parentName].push_back({time,childName});\\n        isAlive[childName]=1;\\n        isAlive[parentName]=1;\\n    }\\n    \\n    void death(string name) \\n    {\\n        isAlive[name]=0;\\n    }\\n    \\n    void dfs(string name, vector<string> &order)\\n    {\\n        if(isAlive[name]) order.push_back(name);\\n        for(auto it: parentChild[name])\\n        {\\n            dfs(it.second,order);\\n        }\\n    }\\n\\n    vector<string> getInheritanceOrder() \\n    {\\n        vector<string> order;\\n        dfs(k,order);\\n        return order;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search",
                    "Ordered Map"
                ],
                "code": "```\\nclass ThroneInheritance \\n{\\npublic:\\n    int time;\\n    map<string,int> isAlive;\\n    map<string,vector<pair<int,string>>> parentChild;\\n    string k;\\n    ThroneInheritance(string kingName) \\n    {\\n        isAlive[kingName]=1;\\n        k=kingName;\\n        time=0;\\n    }\\n    \\n    void birth(string parentName, string childName) \\n    {\\n        time++;\\n        parentChild[parentName].push_back({time,childName});\\n        isAlive[childName]=1;\\n        isAlive[parentName]=1;\\n    }\\n    \\n    void death(string name) \\n    {\\n        isAlive[name]=0;\\n    }\\n    \\n    void dfs(string name, vector<string> &order)\\n    {\\n        if(isAlive[name]) order.push_back(name);\\n        for(auto it: parentChild[name])\\n        {\\n            dfs(it.second,order);\\n        }\\n    }\\n\\n    vector<string> getInheritanceOrder() \\n    {\\n        vector<string> order;\\n        dfs(k,order);\\n        return order;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2822777,
                "title": "python-non-recursive-stack-solution-relatively-memory-efficient",
                "content": "Runtime: 1934 ms - beats 29.6%\\nMemory: 67.4 MB - beats 94.9%\\n\\n```python\\nclass ThroneInheritance:\\n    def __init__(self, monarch: str):\\n        self._deaths = set[str]()\\n        self._children = {monarch: list[str]()}\\n        self._monarch = monarch\\n    \\n    def birth(self, parent: str, child: str) -> None:\\n        self._children.setdefault(parent, []).append(child)\\n    \\n    def death(self, name: str) -> None:\\n        self._deaths.add(name)\\n    \\n    def getInheritanceOrder(self) -> list[str]:\\n        res = []\\n        stack = [self._monarch]\\n        while stack:\\n            name = stack.pop()\\n            if name not in self._deaths:\\n                res.append(name)\\n            stack += self._children.get(name, [])[::-1]\\n        return res\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Stack"
                ],
                "code": "```python\\nclass ThroneInheritance:\\n    def __init__(self, monarch: str):\\n        self._deaths = set[str]()\\n        self._children = {monarch: list[str]()}\\n        self._monarch = monarch\\n    \\n    def birth(self, parent: str, child: str) -> None:\\n        self._children.setdefault(parent, []).append(child)\\n    \\n    def death(self, name: str) -> None:\\n        self._deaths.add(name)\\n    \\n    def getInheritanceOrder(self) -> list[str]:\\n        res = []\\n        stack = [self._monarch]\\n        while stack:\\n            name = stack.pop()\\n            if name not in self._deaths:\\n                res.append(name)\\n            stack += self._children.get(name, [])[::-1]\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2695981,
                "title": "python-super-easy-dfs",
                "content": "```\\nclass ThroneInheritance:\\n\\n    def __init__(self, kingName: str):\\n        self.root = kingName\\n        self.graph = collections.defaultdict(list)\\n        self.dead = set()\\n    def birth(self, parentName: str, childName: str) -> None:\\n        self.graph[parentName].append(childName)\\n    def death(self, name: str) -> None:\\n        self.dead.add(name)\\n    def getInheritanceOrder(self) -> List[str]:\\n        ans = []\\n        def dfs(node):\\n            \\n            if node not in self.dead:\\n                ans.append(node)\\n            \\n            for v in self.graph[node]:\\n                dfs(v)\\n        \\n        \\n        dfs(self.root)\\n        return ans\\n```",
                "solutionTags": [],
                "code": "```\\nclass ThroneInheritance:\\n\\n    def __init__(self, kingName: str):\\n        self.root = kingName\\n        self.graph = collections.defaultdict(list)\\n        self.dead = set()\\n    def birth(self, parentName: str, childName: str) -> None:\\n        self.graph[parentName].append(childName)\\n    def death(self, name: str) -> None:\\n        self.dead.add(name)\\n    def getInheritanceOrder(self) -> List[str]:\\n        ans = []\\n        def dfs(node):\\n            \\n            if node not in self.dead:\\n                ans.append(node)\\n            \\n            for v in self.graph[node]:\\n                dfs(v)\\n        \\n        \\n        dfs(self.root)\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2683298,
                "title": "n-ary-tree-construction-insertion-birth-pre-order-traversal-getinheritanceorder",
                "content": "```\\n/*\\n    The main key idea to solve such type of questions is that\\n    to understand/able to draw the Tree Diagram.\\n    \\n    Once you\\'ve the Tree Diagram, rest of the task is Cakewalk for you.\\n*/\\n\\nclass ThroneInheritance {\\n\\n    // Tells, node corresponding to the given \\'name\\'. Used to make insertion fast in N-ary Tree.\\n    // It avoids performing DFS in N-ary Tree to find appropriate parent node to add a new child\\n    private Map<String, TreeNode> nodeAt;\\n    \\n    // Used to keep track of \\'dead\\' people\\n    private Set<String> deadContainer;\\n    \\n    // Root of the N-ary Tree : To hold the entire Throne Hierarchy\\n    private TreeNode root;\\n    \\n    public ThroneInheritance(String kingName) {\\n        nodeAt = new HashMap<>();\\n        deadContainer = new HashSet<>();\\n        root = new TreeNode(kingName);\\n        nodeAt.put(kingName, root);\\n    }\\n    \\n    // Nothing but insertion of a child for the parent node(node_at[parentName]) in N-ary Tree\\n    public void birth(String parentName, String childName) {\\n        TreeNode parent = nodeAt.get(parentName);\\n        TreeNode child = new TreeNode(childName);\\n        parent.children.add(child);\\n        // Making a new mapping for current child in our map\\n        nodeAt.put(childName, child);\\n    }\\n    \\n    public void death(String name) {\\n        deadContainer.add(name); //make person with name \\'name\\' as dead\\n    }\\n    \\n    // Throne Inheritance Order is nothing but data fetched in Pre-Order fashion in N-ary Tree\\n    //  By keeping in mind that \\'dead\\' people are excluded.\\n    public List<String> getInheritanceOrder() {\\n        List<String> thorneInheritance = new ArrayList<>();\\n        preorderTraversal(thorneInheritance, root);\\n        return thorneInheritance;\\n    }\\n    \\n    // Store the preorder traversal of current N-ary into the given list \\'thorneInheritance\\'\\n    // Exactly same as \\'Preorder Traversal\\' in Binary Tree.\\n    // Our this pre-order traversal will automatically takes care the ordering of Throne Inheritance defined\\n    // in \\'Successor(x, currOrder)\\'.\\n    public void preorderTraversal(List<String> thorneInheritance, TreeNode r) {\\n        // Reached to leaf node\\n        if(r.children.size() == 0) {\\n            if(!deadContainer.contains(r.name)) thorneInheritance.add(r.name);\\n            return;\\n        }\\n        \\n        if(!deadContainer.contains(r.name)) \\n            thorneInheritance.add(r.name);\\n        \\n        for(TreeNode child : r.children) {\\n            if(child != null) {\\n                preorderTraversal(thorneInheritance, child);\\n            }\\n        }\\n    }\\n    \\n    // N-ary Tree\\'s TreeNode strucutre\\n    private class TreeNode {\\n        String name; //name of the parent at current node\\n        List<TreeNode> children;\\n        \\n        TreeNode(String name) {\\n            this.name = name;\\n            this.children = new ArrayList<>();\\n        }\\n        \\n        TreeNode(String name, List<TreeNode> children) {\\n            this.name = name;\\n            this.children = children;\\n        }\\n    }\\n}\\n\\n```\\n\\n```\\nClean Code W/T Comments\\n```\\n\\n```\\n\\nclass ThroneInheritance {\\n\\n    private Map<String, TreeNode> nodeAt;\\n    private Set<String> deadContainer;\\n    private TreeNode root;\\n    \\n    public ThroneInheritance(String kingName) {\\n        nodeAt = new HashMap<>();\\n        deadContainer = new HashSet<>();\\n        root = new TreeNode(kingName);\\n        nodeAt.put(kingName, root);\\n    }\\n    \\n    public void birth(String parentName, String childName) {\\n        TreeNode parent = nodeAt.get(parentName);\\n        TreeNode child = new TreeNode(childName);\\n        parent.children.add(child);\\n        nodeAt.put(childName, child);\\n    }\\n    \\n    public void death(String name) {\\n        deadContainer.add(name);\\n    }\\n    \\n    public List<String> getInheritanceOrder() {\\n        List<String> thorneInheritance = new ArrayList<>();\\n        preorderTraversal(thorneInheritance, root);\\n        return thorneInheritance;\\n    }\\n    \\n    public void preorderTraversal(List<String> thorneInheritance, TreeNode r) {\\n        if(r == null) return;\\n        \\n        if(!deadContainer.contains(r.name)) \\n            thorneInheritance.add(r.name);\\n        \\n        for(TreeNode child : r.children) {\\n            preorderTraversal(thorneInheritance, child);\\n        }\\n    }\\n    \\n    private class TreeNode {\\n        String name;\\n        List<TreeNode> children;\\n        \\n        TreeNode(String name) {\\n            this.name = name;\\n            this.children = new ArrayList<>();\\n        }\\n        \\n        TreeNode(String name, List<TreeNode> children) {\\n            this.name = name;\\n            this.children = children;\\n        }\\n    }\\n}\\n```\\n\\n*If you found this post helpful then please do upvote my solution.*",
                "solutionTags": [
                    "Java",
                    "Hash Table"
                ],
                "code": "```\\n/*\\n    The main key idea to solve such type of questions is that\\n    to understand/able to draw the Tree Diagram.\\n    \\n    Once you\\'ve the Tree Diagram, rest of the task is Cakewalk for you.\\n*/\\n\\nclass ThroneInheritance {\\n\\n    // Tells, node corresponding to the given \\'name\\'. Used to make insertion fast in N-ary Tree.\\n    // It avoids performing DFS in N-ary Tree to find appropriate parent node to add a new child\\n    private Map<String, TreeNode> nodeAt;\\n    \\n    // Used to keep track of \\'dead\\' people\\n    private Set<String> deadContainer;\\n    \\n    // Root of the N-ary Tree : To hold the entire Throne Hierarchy\\n    private TreeNode root;\\n    \\n    public ThroneInheritance(String kingName) {\\n        nodeAt = new HashMap<>();\\n        deadContainer = new HashSet<>();\\n        root = new TreeNode(kingName);\\n        nodeAt.put(kingName, root);\\n    }\\n    \\n    // Nothing but insertion of a child for the parent node(node_at[parentName]) in N-ary Tree\\n    public void birth(String parentName, String childName) {\\n        TreeNode parent = nodeAt.get(parentName);\\n        TreeNode child = new TreeNode(childName);\\n        parent.children.add(child);\\n        // Making a new mapping for current child in our map\\n        nodeAt.put(childName, child);\\n    }\\n    \\n    public void death(String name) {\\n        deadContainer.add(name); //make person with name \\'name\\' as dead\\n    }\\n    \\n    // Throne Inheritance Order is nothing but data fetched in Pre-Order fashion in N-ary Tree\\n    //  By keeping in mind that \\'dead\\' people are excluded.\\n    public List<String> getInheritanceOrder() {\\n        List<String> thorneInheritance = new ArrayList<>();\\n        preorderTraversal(thorneInheritance, root);\\n        return thorneInheritance;\\n    }\\n    \\n    // Store the preorder traversal of current N-ary into the given list \\'thorneInheritance\\'\\n    // Exactly same as \\'Preorder Traversal\\' in Binary Tree.\\n    // Our this pre-order traversal will automatically takes care the ordering of Throne Inheritance defined\\n    // in \\'Successor(x, currOrder)\\'.\\n    public void preorderTraversal(List<String> thorneInheritance, TreeNode r) {\\n        // Reached to leaf node\\n        if(r.children.size() == 0) {\\n            if(!deadContainer.contains(r.name)) thorneInheritance.add(r.name);\\n            return;\\n        }\\n        \\n        if(!deadContainer.contains(r.name)) \\n            thorneInheritance.add(r.name);\\n        \\n        for(TreeNode child : r.children) {\\n            if(child != null) {\\n                preorderTraversal(thorneInheritance, child);\\n            }\\n        }\\n    }\\n    \\n    // N-ary Tree\\'s TreeNode strucutre\\n    private class TreeNode {\\n        String name; //name of the parent at current node\\n        List<TreeNode> children;\\n        \\n        TreeNode(String name) {\\n            this.name = name;\\n            this.children = new ArrayList<>();\\n        }\\n        \\n        TreeNode(String name, List<TreeNode> children) {\\n            this.name = name;\\n            this.children = children;\\n        }\\n    }\\n}\\n\\n```\n```\\nClean Code W/T Comments\\n```\n```\\n\\nclass ThroneInheritance {\\n\\n    private Map<String, TreeNode> nodeAt;\\n    private Set<String> deadContainer;\\n    private TreeNode root;\\n    \\n    public ThroneInheritance(String kingName) {\\n        nodeAt = new HashMap<>();\\n        deadContainer = new HashSet<>();\\n        root = new TreeNode(kingName);\\n        nodeAt.put(kingName, root);\\n    }\\n    \\n    public void birth(String parentName, String childName) {\\n        TreeNode parent = nodeAt.get(parentName);\\n        TreeNode child = new TreeNode(childName);\\n        parent.children.add(child);\\n        nodeAt.put(childName, child);\\n    }\\n    \\n    public void death(String name) {\\n        deadContainer.add(name);\\n    }\\n    \\n    public List<String> getInheritanceOrder() {\\n        List<String> thorneInheritance = new ArrayList<>();\\n        preorderTraversal(thorneInheritance, root);\\n        return thorneInheritance;\\n    }\\n    \\n    public void preorderTraversal(List<String> thorneInheritance, TreeNode r) {\\n        if(r == null) return;\\n        \\n        if(!deadContainer.contains(r.name)) \\n            thorneInheritance.add(r.name);\\n        \\n        for(TreeNode child : r.children) {\\n            preorderTraversal(thorneInheritance, child);\\n        }\\n    }\\n    \\n    private class TreeNode {\\n        String name;\\n        List<TreeNode> children;\\n        \\n        TreeNode(String name) {\\n            this.name = name;\\n            this.children = new ArrayList<>();\\n        }\\n        \\n        TreeNode(String name, List<TreeNode> children) {\\n            this.name = name;\\n            this.children = children;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2680498,
                "title": "python-a-standard-dfs-solution-with-visualisation",
                "content": "Perform a DFS starting from king\\nAdd the result only if its died already\\n\\n![image](https://assets.leetcode.com/users/images/92fa86e3-3033-4078-a568-9085936148c9_1665305868.510111.png)\\n\\n\\n\\n\\n```\\nclass ThroneInheritance:\\n\\n    def __init__(self, kingName: str):\\n        self.kingName = kingName\\n        self.successor = defaultdict(list)\\n        self.d = set()\\n\\n    def birth(self, parentName: str, childName: str) -> None:\\n        self.successor[parentName].append(childName)\\n        \\n    def death(self, name: str) -> None:\\n        self.d.add(name)\\n        \\n    def getInheritanceOrder(self) -> List[str]:\\n        self.res = []\\n        def dfs(name):\\n            if name not in self.d:\\n                self.res.append(name)\\n            for n in self.successor[name]:\\n                dfs(n)\\n            return\\n            \\n        dfs(self.kingName)\\n        return self.res\\n        \\n\\n\\n# Your ThroneInheritance object will be instantiated and called as such:\\n# obj = ThroneInheritance(kingName)\\n# obj.birth(parentName,childName)\\n# obj.death(name)\\n# param_3 = obj.getInheritanceOrder()\\n```",
                "solutionTags": [
                    "Python",
                    "Depth-First Search"
                ],
                "code": "```\\nclass ThroneInheritance:\\n\\n    def __init__(self, kingName: str):\\n        self.kingName = kingName\\n        self.successor = defaultdict(list)\\n        self.d = set()\\n\\n    def birth(self, parentName: str, childName: str) -> None:\\n        self.successor[parentName].append(childName)\\n        \\n    def death(self, name: str) -> None:\\n        self.d.add(name)\\n        \\n    def getInheritanceOrder(self) -> List[str]:\\n        self.res = []\\n        def dfs(name):\\n            if name not in self.d:\\n                self.res.append(name)\\n            for n in self.successor[name]:\\n                dfs(n)\\n            return\\n            \\n        dfs(self.kingName)\\n        return self.res\\n        \\n\\n\\n# Your ThroneInheritance object will be instantiated and called as such:\\n# obj = ThroneInheritance(kingName)\\n# obj.birth(parentName,childName)\\n# obj.death(name)\\n# param_3 = obj.getInheritanceOrder()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2650071,
                "title": "runtime-faster-than-93-33-memory-usage-less-than-73-33-of-javascript-online-submissions",
                "content": "```\\n/**\\n * @param {string} kingName\\n */\\nvar ThroneInheritance = function(kingName) {\\n    this.familyGraph = {\\n        [kingName]: {\\n            isAlive: true,\\n            children: [],\\n        },\\n    };\\n    \\n    this.king = kingName;\\n    this.firstKing = kingName;\\n};\\n\\n/** \\n * @param {string} parentName \\n * @param {string} childName\\n * @return {void}\\n */\\nThroneInheritance.prototype.birth = function(parentName, childName) {\\n    this.familyGraph[parentName].children.push(childName);\\n    this.familyGraph[childName] = {\\n        isAlive: true,\\n        children: [],\\n    };\\n};\\n\\n/** \\n * @param {string} name\\n * @return {void}\\n */\\nThroneInheritance.prototype.death = function(name) {\\n    \\n    if (name === this.king) {\\n        this.familyGraph[name].isAlive = false;\\n        const dfs = (person) => {\\n            const kin = this.familyGraph[person];\\n            if (kin.isAlive) {\\n                this.king = person;\\n                return true;\\n            }\\n            for (let child of kin.children) {\\n                if (dfs(child)) {\\n                    return true;\\n                }\\n            }\\n        };\\n        \\n        dfs(this.firstKing);\\n        \\n    } else {\\n        this.familyGraph[name].isAlive = false;\\n    }\\n};\\n\\n/**\\n * @return {string[]}\\n */\\nThroneInheritance.prototype.getInheritanceOrder = function() {\\n    const curOrder = [];\\n    const dfs = (person) => {\\n        const kin = this.familyGraph[person];\\n        if (kin.isAlive) {\\n            curOrder.push(person);\\n        }\\n        for (let child of kin.children) {\\n            dfs(child);\\n        }\\n    };\\n    \\n    dfs(this.firstKing);\\n    return curOrder;\\n};\\n\\n/** \\n * Your ThroneInheritance object will be instantiated and called as such:\\n * var obj = new ThroneInheritance(kingName)\\n * obj.birth(parentName,childName)\\n * obj.death(name)\\n * var param_3 = obj.getInheritanceOrder()\\n */\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * @param {string} kingName\\n */\\nvar ThroneInheritance = function(kingName) {\\n    this.familyGraph = {\\n        [kingName]: {\\n            isAlive: true,\\n            children: [],\\n        },\\n    };\\n    \\n    this.king = kingName;\\n    this.firstKing = kingName;\\n};\\n\\n/** \\n * @param {string} parentName \\n * @param {string} childName\\n * @return {void}\\n */\\nThroneInheritance.prototype.birth = function(parentName, childName) {\\n    this.familyGraph[parentName].children.push(childName);\\n    this.familyGraph[childName] = {\\n        isAlive: true,\\n        children: [],\\n    };\\n};\\n\\n/** \\n * @param {string} name\\n * @return {void}\\n */\\nThroneInheritance.prototype.death = function(name) {\\n    \\n    if (name === this.king) {\\n        this.familyGraph[name].isAlive = false;\\n        const dfs = (person) => {\\n            const kin = this.familyGraph[person];\\n            if (kin.isAlive) {\\n                this.king = person;\\n                return true;\\n            }\\n            for (let child of kin.children) {\\n                if (dfs(child)) {\\n                    return true;\\n                }\\n            }\\n        };\\n        \\n        dfs(this.firstKing);\\n        \\n    } else {\\n        this.familyGraph[name].isAlive = false;\\n    }\\n};\\n\\n/**\\n * @return {string[]}\\n */\\nThroneInheritance.prototype.getInheritanceOrder = function() {\\n    const curOrder = [];\\n    const dfs = (person) => {\\n        const kin = this.familyGraph[person];\\n        if (kin.isAlive) {\\n            curOrder.push(person);\\n        }\\n        for (let child of kin.children) {\\n            dfs(child);\\n        }\\n    };\\n    \\n    dfs(this.firstKing);\\n    return curOrder;\\n};\\n\\n/** \\n * Your ThroneInheritance object will be instantiated and called as such:\\n * var obj = new ThroneInheritance(kingName)\\n * obj.birth(parentName,childName)\\n * obj.death(name)\\n * var param_3 = obj.getInheritanceOrder()\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2591693,
                "title": "python-dfs-solution",
                "content": "```\\nclass ThroneInheritance:\\n\\n    def __init__(self, king: str):\\n        self.g = defaultdict(list)\\n        self.k = king\\n        self.d = set()\\n\\n    def birth(self, parent: str, child: str) -> None:\\n        self.g[parent].append(child)\\n\\n    def death(self, name: str) -> None:\\n        self.d.add(name)        \\n    \\n    def dfs(self, p):\\n        if p not in self.d:\\n            self.ans.append(p)\\n        for nxt in self.g[p]:\\n            self.dfs(nxt)\\n    \\n    def getInheritanceOrder(self) -> List[str]:\\n        self.ans = []\\n        self.dfs(self.k)\\n        return self.ans\\n```",
                "solutionTags": [],
                "code": "```\\nclass ThroneInheritance:\\n\\n    def __init__(self, king: str):\\n        self.g = defaultdict(list)\\n        self.k = king\\n        self.d = set()\\n\\n    def birth(self, parent: str, child: str) -> None:\\n        self.g[parent].append(child)\\n\\n    def death(self, name: str) -> None:\\n        self.d.add(name)        \\n    \\n    def dfs(self, p):\\n        if p not in self.d:\\n            self.ans.append(p)\\n        for nxt in self.g[p]:\\n            self.dfs(nxt)\\n    \\n    def getInheritanceOrder(self) -> List[str]:\\n        self.ans = []\\n        self.dfs(self.k)\\n        return self.ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2502291,
                "title": "simplest-c-with-dictionary-and-hashset",
                "content": "```\\npublic class ThroneInheritance {\\n\\n  private string kingName;\\n  private Dictionary<string, List<string>> kingdom = new();\\n  private HashSet<string> dead = new();\\n  private int c = 0;\\n  \\n  \\n  public ThroneInheritance(string kingName) {\\n    kingdom.Add(kingName, new List<string>());\\n    this.kingName = kingName;\\n  }\\n\\n  public void Birth(string parentName, string childName) {\\n    if(!kingdom.ContainsKey(parentName))\\n      kingdom.Add(parentName, new List<string>() { childName });\\n    else kingdom[parentName].Add(childName);\\n    \\n    c++;\\n  }\\n\\n  public void Death(string name) {\\n    dead.Add(name);\\n    c--;\\n  }\\n\\n  public IList<string> GetInheritanceOrder() {\\n    \\n    List<string> inh = new();\\n    \\n    void dfs(string parent)\\n    {\\n      \\n      if(!dead.Contains(parent)) inh.Add(parent);\\n      \\n      if(kingdom.ContainsKey(parent))\\n      {\\n        foreach(var child in kingdom[parent])\\n          dfs(child);\\n      }\\n    }\\n    \\n    dfs(kingName);\\n    \\n    return inh;\\n  }\\n  \\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\npublic class ThroneInheritance {\\n\\n  private string kingName;\\n  private Dictionary<string, List<string>> kingdom = new();\\n  private HashSet<string> dead = new();\\n  private int c = 0;\\n  \\n  \\n  public ThroneInheritance(string kingName) {\\n    kingdom.Add(kingName, new List<string>());\\n    this.kingName = kingName;\\n  }\\n\\n  public void Birth(string parentName, string childName) {\\n    if(!kingdom.ContainsKey(parentName))\\n      kingdom.Add(parentName, new List<string>() { childName });\\n    else kingdom[parentName].Add(childName);\\n    \\n    c++;\\n  }\\n\\n  public void Death(string name) {\\n    dead.Add(name);\\n    c--;\\n  }\\n\\n  public IList<string> GetInheritanceOrder() {\\n    \\n    List<string> inh = new();\\n    \\n    void dfs(string parent)\\n    {\\n      \\n      if(!dead.Contains(parent)) inh.Add(parent);\\n      \\n      if(kingdom.ContainsKey(parent))\\n      {\\n        foreach(var child in kingdom[parent])\\n          dfs(child);\\n      }\\n    }\\n    \\n    dfs(kingName);\\n    \\n    return inh;\\n  }\\n  \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2475825,
                "title": "readable-python-faster-than-90",
                "content": "```\\nclass Person:\\n    \\n    def __init__(self, name):\\n        self.name = name\\n        self.kids = []\\n        self.alive = True\\n\\nclass ThroneInheritance:\\n\\n    def __init__(self, kingName: str):\\n        king = Person(kingName)\\n        self.head = king\\n        self.d = {kingName: king}\\n        \\n\\n    def birth(self, parentName: str, childName: str) -> None:\\n        parent = self.d[parentName]\\n        child = Person(childName)\\n        self.d[childName] = child\\n        parent.kids.append(child)\\n\\n    def death(self, name: str) -> None:\\n        self.d[name].alive = False\\n\\n    def getInheritanceOrder(self) -> List[str]:\\n        stack = [self.head]\\n        res = []\\n        while stack:\\n            p = stack.pop()\\n            if p.alive: res.append(p.name)\\n            stack += p.kids[::-1]\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Person:\\n    \\n    def __init__(self, name):\\n        self.name = name\\n        self.kids = []\\n        self.alive = True\\n\\nclass ThroneInheritance:\\n\\n    def __init__(self, kingName: str):\\n        king = Person(kingName)\\n        self.head = king\\n        self.d = {kingName: king}\\n        \\n\\n    def birth(self, parentName: str, childName: str) -> None:\\n        parent = self.d[parentName]\\n        child = Person(childName)\\n        self.d[childName] = child\\n        parent.kids.append(child)\\n\\n    def death(self, name: str) -> None:\\n        self.d[name].alive = False\\n\\n    def getInheritanceOrder(self) -> List[str]:\\n        stack = [self.head]\\n        res = []\\n        while stack:\\n            p = stack.pop()\\n            if p.alive: res.append(p.name)\\n            stack += p.kids[::-1]\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2437524,
                "title": "simple-c-solution",
                "content": "```\\nstruct Node{\\n    string name;\\n    vector<Node*> children;\\n    \\n    Node(string &s)\\n    {\\n        name = s;\\n    }\\n};\\n\\nclass ThroneInheritance {\\n    struct Node* root;\\n    unordered_set<string> deaths;\\n    vector<string> ans;\\n    unordered_map<string,Node*> mp;\\npublic:\\n    \\n    void preorder(Node* root)\\n    {\\n        if(!root)return ;\\n        if(deaths.find(root->name)==deaths.end())\\n            ans.push_back(root->name);\\n        for(auto &it:root->children)\\n        {\\n            preorder(it);\\n        }\\n    }\\n    \\n    void traversal(Node* root)\\n    {\\n        if(!root)return;\\n        mp[root->name] = root;\\n        for(auto &it:root->children)\\n        {\\n            traversal(it);\\n        }\\n    }\\n    \\n    \\n    //gives tle\\n    \\n    // void add(Node* root,string &p,string &ch)\\n    // {\\n    //     if(!root)return ;\\n    //     if(root->name == p)\\n    //     {\\n    //         Node* temp = new Node(ch);\\n    //         root->children.push_back(temp);\\n    //         return;\\n    //     }\\n    //     for(auto &it:root->children)\\n    //     {\\n    //         if(deaths.find(root->name)==deaths.end())\\n    //             add(it,p,ch);\\n    //     }\\n    // }\\n    \\n    ThroneInheritance(string kingName) {\\n        root = new Node(kingName);\\n        traversal(root);\\n    }\\n    \\n    void birth(string parentName, string childName) {\\n        Node* temp = new Node(childName);\\n        mp[parentName]->children.push_back(temp);\\n        mp[childName] = temp;\\n        // add(root,parentName,childName);\\n    }\\n    \\n    void death(string name) {\\n        deaths.insert(name);\\n    }\\n    \\n    vector<string> getInheritanceOrder() {\\n        ans = {};\\n        preorder(root);\\n        return ans;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nstruct Node{\\n    string name;\\n    vector<Node*> children;\\n    \\n    Node(string &s)\\n    {\\n        name = s;\\n    }\\n};\\n\\nclass ThroneInheritance {\\n    struct Node* root;\\n    unordered_set<string> deaths;\\n    vector<string> ans;\\n    unordered_map<string,Node*> mp;\\npublic:\\n    \\n    void preorder(Node* root)\\n    {\\n        if(!root)return ;\\n        if(deaths.find(root->name)==deaths.end())\\n            ans.push_back(root->name);\\n        for(auto &it:root->children)\\n        {\\n            preorder(it);\\n        }\\n    }\\n    \\n    void traversal(Node* root)\\n    {\\n        if(!root)return;\\n        mp[root->name] = root;\\n        for(auto &it:root->children)\\n        {\\n            traversal(it);\\n        }\\n    }\\n    \\n    \\n    //gives tle\\n    \\n    // void add(Node* root,string &p,string &ch)\\n    // {\\n    //     if(!root)return ;\\n    //     if(root->name == p)\\n    //     {\\n    //         Node* temp = new Node(ch);\\n    //         root->children.push_back(temp);\\n    //         return;\\n    //     }\\n    //     for(auto &it:root->children)\\n    //     {\\n    //         if(deaths.find(root->name)==deaths.end())\\n    //             add(it,p,ch);\\n    //     }\\n    // }\\n    \\n    ThroneInheritance(string kingName) {\\n        root = new Node(kingName);\\n        traversal(root);\\n    }\\n    \\n    void birth(string parentName, string childName) {\\n        Node* temp = new Node(childName);\\n        mp[parentName]->children.push_back(temp);\\n        mp[childName] = temp;\\n        // add(root,parentName,childName);\\n    }\\n    \\n    void death(string name) {\\n        deaths.insert(name);\\n    }\\n    \\n    vector<string> getInheritanceOrder() {\\n        ans = {};\\n        preorder(root);\\n        return ans;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2420388,
                "title": "easy-using-n-ary-tree-and-hashmap-for-all-the-language-cpp",
                "content": "```\\nclass Tree {\\n    public:\\n    vector<Tree*> childs;\\n    string data;\\n    Tree(){\\n        data = \"\";\\n        childs = {};\\n    }\\n    Tree(string val){\\n        data = val;\\n    }\\n };\\n\\nclass ThroneInheritance {\\npublic:\\n    Tree* main = new Tree();\\n    unordered_map<string,Tree*> mapp;\\n    ThroneInheritance(string kingName) {\\n        main->data = kingName;\\n        mapp[kingName] = main;\\n    }\\n    \\n    void birth(string parentName, string childName) {\\n        mapp[parentName]->childs.push_back(new Tree(childName));\\n        mapp[childName] = mapp[parentName]->childs.back();\\n    }\\n    void death(string name) {\\n        Tree* curr = mapp[name];\\n        curr->data = \"#\";\\n    }\\n    void inorder(vector<string> &v,Tree* root){\\n        if(!root) return;\\n        if(root->data!=\"#\")\\n        v.push_back(root->data);\\n        for(Tree * c : root->childs){\\n            inorder(v,c);\\n        }\\n        \\n    }\\n    vector<string> getInheritanceOrder() {\\n        vector<string> v;\\n        inorder(v,main);\\n        return v;\\n    }\\n};\\n\\n ````",
                "solutionTags": [
                    "C++",
                    "Tree",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Tree {\\n    public:\\n    vector<Tree*> childs;\\n    string data;\\n    Tree(){\\n        data = \"\";\\n        childs = {};\\n    }\\n    Tree(string val){\\n        data = val;\\n    }\\n };\\n\\nclass ThroneInheritance {\\npublic:\\n    Tree* main = new Tree();\\n    unordered_map<string,Tree*> mapp;\\n    ThroneInheritance(string kingName) {\\n        main->data = kingName;\\n        mapp[kingName] = main;\\n    }\\n    \\n    void birth(string parentName, string childName) {\\n        mapp[parentName]->childs.push_back(new Tree(childName));\\n        mapp[childName] = mapp[parentName]->childs.back();\\n    }\\n    void death(string name) {\\n        Tree* curr = mapp[name];\\n        curr->data = \"#\";\\n    }\\n    void inorder(vector<string> &v,Tree* root){\\n        if(!root) return;\\n        if(root->data!=\"#\")\\n        v.push_back(root->data);\\n        for(Tree * c : root->childs){\\n            inorder(v,c);\\n        }\\n        \\n    }\\n    vector<string> getInheritanceOrder() {\\n        vector<string> v;\\n        inorder(v,main);\\n        return v;\\n    }\\n};\\n\\n ```",
                "codeTag": "Java"
            },
            {
                "id": 2311312,
                "title": "c-hashing-dfs-faster-than-95",
                "content": "```\\n   unordered_map<string,vector<string>>mp;         // to store relationship\\n    unordered_set<string>dead;                      // to store dead kings\\n    vector<string>order;                            // to store inheritance order\\n    string king;\\n    ThroneInheritance(string kingName) {\\n        mp.clear();\\n        king=kingName;\\n    }\\n    \\n    void birth(string parentName, string childName) {\\n        mp[parentName].push_back(childName);\\n    }\\n    \\n    void death(string name) {\\n        dead.insert(name);\\n    }\\n    \\n    vector<string> getInheritanceOrder() {\\n        order.clear();\\n        solve(king);\\n        return order;\\n    }\\n    void solve(string king){\\n        if(dead.find(king)==dead.end())\\n            order.push_back(king);\\n        for(auto it:mp[king])\\n            solve(it);\\n        return;\\n    }",
                "solutionTags": [
                    "Depth-First Search"
                ],
                "code": "```\\n   unordered_map<string,vector<string>>mp;         // to store relationship\\n    unordered_set<string>dead;                      // to store dead kings\\n    vector<string>order;                            // to store inheritance order\\n    string king;\\n    ThroneInheritance(string kingName) {\\n        mp.clear();\\n        king=kingName;\\n    }\\n    \\n    void birth(string parentName, string childName) {\\n        mp[parentName].push_back(childName);\\n    }\\n    \\n    void death(string name) {\\n        dead.insert(name);\\n    }\\n    \\n    vector<string> getInheritanceOrder() {\\n        order.clear();\\n        solve(king);\\n        return order;\\n    }\\n    void solve(string king){\\n        if(dead.find(king)==dead.end())\\n            order.push_back(king);\\n        for(auto it:mp[king])\\n            solve(it);\\n        return;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2254895,
                "title": "python-3-straightforward-dfs",
                "content": "\\tclass ThroneInheritance:\\n\\n\\t\\tdef __init__(self, kingName: str):\\n\\t\\t\\tself.king=kingName\\n\\t\\t\\tself.a=defaultdict(list)\\n\\t\\t\\tself.dead=set()\\n\\t\\t\\t\\n\\t\\tdef birth(self, parentName: str, childName: str) -> None:\\n\\t\\t\\tself.a[parentName].append(childName)\\n\\n\\t\\tdef death(self, name: str) -> None:\\n\\t\\t\\tself.dead.add(name)\\n\\n\\t\\tdef getInheritanceOrder(self) -> List[str]:\\n\\t\\t\\tres=[]\\n\\t\\t\\tdef dfs(node):\\n\\t\\t\\t\\tif not node in self.dead:\\n\\t\\t\\t\\t\\tres.append(node)\\n\\t\\t\\t\\tfor child in self.a[node]:\\n\\t\\t\\t\\t\\tdfs(child)\\n\\t\\t\\tdfs(self.king)\\n\\t\\t\\treturn res",
                "solutionTags": [
                    "Depth-First Search"
                ],
                "code": "\\tclass ThroneInheritance:\\n\\n\\t\\tdef __init__(self, kingName: str):\\n\\t\\t\\tself.king=kingName\\n\\t\\t\\tself.a=defaultdict(list)\\n\\t\\t\\tself.dead=set()\\n\\t\\t\\t\\n\\t\\tdef birth(self, parentName: str, childName: str) -> None:\\n\\t\\t\\tself.a[parentName].append(childName)\\n\\n\\t\\tdef death(self, name: str) -> None:\\n\\t\\t\\tself.dead.add(name)\\n\\n\\t\\tdef getInheritanceOrder(self) -> List[str]:\\n\\t\\t\\tres=[]\\n\\t\\t\\tdef dfs(node):\\n\\t\\t\\t\\tif not node in self.dead:\\n\\t\\t\\t\\t\\tres.append(node)\\n\\t\\t\\t\\tfor child in self.a[node]:\\n\\t\\t\\t\\t\\tdfs(child)\\n\\t\\t\\tdfs(self.king)\\n\\t\\t\\treturn res",
                "codeTag": "Java"
            },
            {
                "id": 2250383,
                "title": "c-using-hash-map-hash-set",
                "content": "```\\nclass ThroneInheritance {\\n    private: \\n    unordered_map<string,vector<string>> _inheritance;\\n    unordered_set<string> _death;\\n    \\n    string _king_name;\\n    size_t _all_time_family_size = 0;\\n    \\n    private: \\n    void get_children(vector<string>& inheritance_order, string& name)\\n    {\\n        if(_death.find(name) == _death.end())  \\n        { \\n            inheritance_order.push_back(name);     \\n        }\\n        for(auto&& child : _inheritance[name])\\n        { \\n            get_children(inheritance_order, child);\\n        }\\n    }\\n    \\npublic:\\n    ThroneInheritance(string kingName) {\\n        _king_name = kingName;\\n    }\\n   \\n    void birth(string&& parentName, string&& childName) {\\n        _inheritance[parentName].push_back(childName); \\n        _all_time_family_size++;\\n    }\\n    \\n    void death(string&& name) {\\n        _death.insert(name); //do not delete the people as their inheretence order matters\\n    }\\n     \\n    vector<string> getInheritanceOrder() {\\n         \\n        vector<string> inheritance_order;\\n        inheritance_order.reserve(_all_time_family_size - _death.size());\\n         \\n        get_children(inheritance_order, _king_name);\\n        \\n        return inheritance_order;\\n    }\\n};\\n  \\n```",
                "solutionTags": [],
                "code": "```\\nclass ThroneInheritance {\\n    private: \\n    unordered_map<string,vector<string>> _inheritance;\\n    unordered_set<string> _death;\\n    \\n    string _king_name;\\n    size_t _all_time_family_size = 0;\\n    \\n    private: \\n    void get_children(vector<string>& inheritance_order, string& name)\\n    {\\n        if(_death.find(name) == _death.end())  \\n        { \\n            inheritance_order.push_back(name);     \\n        }\\n        for(auto&& child : _inheritance[name])\\n        { \\n            get_children(inheritance_order, child);\\n        }\\n    }\\n    \\npublic:\\n    ThroneInheritance(string kingName) {\\n        _king_name = kingName;\\n    }\\n   \\n    void birth(string&& parentName, string&& childName) {\\n        _inheritance[parentName].push_back(childName); \\n        _all_time_family_size++;\\n    }\\n    \\n    void death(string&& name) {\\n        _death.insert(name); //do not delete the people as their inheretence order matters\\n    }\\n     \\n    vector<string> getInheritanceOrder() {\\n         \\n        vector<string> inheritance_order;\\n        inheritance_order.reserve(_all_time_family_size - _death.size());\\n         \\n        get_children(inheritance_order, _king_name);\\n        \\n        return inheritance_order;\\n    }\\n};\\n  \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2242825,
                "title": "depth-first-search-a-marvelous-approach-to-any-problem",
                "content": "```\\n map<string,vector<string>> children;  // parent= {child1,child2,child 3..}\\n    map<string,bool> deathOccured;\\n    string oldestKing;\\n    \\n    ThroneInheritance(string kingName) {\\n        \\n        oldestKing=kingName;  //node 0 yahi se family tree shuru horha hai\\n    }\\n    \\n    void birth(string parentName, string childName) {\\n        \\n        //New born added to vector of that king which denotes all children of that king\\n        children[parentName].push_back(childName);\\n    }\\n    \\n    void death(string name) {\\n        \\n        //Dead people\\n        deathOccured[name]=true;\\n        \\n    }\\n    \\n    void dfs(string src,vector<string> &ans)\\n    {\\n        //Step 1 Dead will not be pushed in the list but hteir children would\\n        if(deathOccured[src]!=true)  \\n            ans.push_back(src);\\n        \\n        for(auto i:children[src])\\n            dfs(i,ans);\\n            \\n    }\\n    vector<string> getInheritanceOrder() {\\n        \\n        vector<string> ans;\\n        dfs(oldestKing,ans);  //dfs chlado from the oldest king\\n        return ans;\\n        \\n    }",
                "solutionTags": [],
                "code": "```\\n map<string,vector<string>> children;  // parent= {child1,child2,child 3..}\\n    map<string,bool> deathOccured;\\n    string oldestKing;\\n    \\n    ThroneInheritance(string kingName) {\\n        \\n        oldestKing=kingName;  //node 0 yahi se family tree shuru horha hai\\n    }\\n    \\n    void birth(string parentName, string childName) {\\n        \\n        //New born added to vector of that king which denotes all children of that king\\n        children[parentName].push_back(childName);\\n    }\\n    \\n    void death(string name) {\\n        \\n        //Dead people\\n        deathOccured[name]=true;\\n        \\n    }\\n    \\n    void dfs(string src,vector<string> &ans)\\n    {\\n        //Step 1 Dead will not be pushed in the list but hteir children would\\n        if(deathOccured[src]!=true)  \\n            ans.push_back(src);\\n        \\n        for(auto i:children[src])\\n            dfs(i,ans);\\n            \\n    }\\n    vector<string> getInheritanceOrder() {\\n        \\n        vector<string> ans;\\n        dfs(oldestKing,ans);  //dfs chlado from the oldest king\\n        return ans;\\n        \\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2235568,
                "title": "javascript-with-dfs-faster-than-100",
                "content": "Intuition\\n\\n- Let\\'s maintain a tree (map from node to children)\\n- DFS is perfect for this problem because it goes deep on one node before moving onto the next\\n- Note that we need to push onto the stack in reverse order so that the \"firstborn child\" (and their children) can claim the throne earlier than later-born children\\n\\n```\\nclass ThroneInheritance {\\n  constructor(kingName) {\\n    this.root = kingName;\\n\\n    this.childMap = new Map();\\n    this.childMap.set(kingName, []);\\n\\n    this.deaths = new Set();\\n  }\\n\\n  birth(parentName, childName) {\\n    if (!this.childMap.has(parentName)) {\\n      this.childMap.set(parentName, []);\\n    }\\n    this.childMap.get(parentName).push(childName);\\n  }\\n\\n  death(name) {\\n    this.deaths.add(name);\\n  }\\n\\n  getInheritanceOrder() {\\n    const stack = [this.root];\\n    let result = [];\\n    while (true) {\\n      if (!stack.length) {\\n        break;\\n      }\\n\\n      const node = stack.pop();\\n      if (!this.deaths.has(node)) {\\n        result.push(node);\\n      }\\n\\n      // push onto stack in reverse order\\n      const children = this.childMap.get(node) || [];\\n      for (let i = 0; i < children.length; i++) {\\n        stack.push(children[children.length - 1 - i]);\\n      }\\n    }\\n    return result;\\n  }\\n}\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Depth-First Search"
                ],
                "code": "```\\nclass ThroneInheritance {\\n  constructor(kingName) {\\n    this.root = kingName;\\n\\n    this.childMap = new Map();\\n    this.childMap.set(kingName, []);\\n\\n    this.deaths = new Set();\\n  }\\n\\n  birth(parentName, childName) {\\n    if (!this.childMap.has(parentName)) {\\n      this.childMap.set(parentName, []);\\n    }\\n    this.childMap.get(parentName).push(childName);\\n  }\\n\\n  death(name) {\\n    this.deaths.add(name);\\n  }\\n\\n  getInheritanceOrder() {\\n    const stack = [this.root];\\n    let result = [];\\n    while (true) {\\n      if (!stack.length) {\\n        break;\\n      }\\n\\n      const node = stack.pop();\\n      if (!this.deaths.has(node)) {\\n        result.push(node);\\n      }\\n\\n      // push onto stack in reverse order\\n      const children = this.childMap.get(node) || [];\\n      for (let i = 0; i < children.length; i++) {\\n        stack.push(children[children.length - 1 - i]);\\n      }\\n    }\\n    return result;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2208594,
                "title": "hashmap-better-than-93-of-c-submissions",
                "content": "```\\nclass ThroneInheritance {\\npublic:\\n    unordered_map<string,vector<string>> hmap1;\\n    unordered_map<string,bool> hmap2;\\n    string king;\\n    ThroneInheritance(string kingName) {\\n        vector<string> v;\\n        hmap1[kingName]=v;\\n        hmap2[kingName]=true;\\n        king=kingName;\\n    }\\n    \\n    void birth(string parentName, string childName) {\\n        hmap1[parentName].push_back(childName);\\n        hmap2[childName]=true;\\n    }\\n    \\n    void death(string name) {\\n        hmap2[name]=false;\\n    }\\n    void func(string name,vector<string> &order){\\n        if(hmap2[name]){order.push_back(name);}\\n        for(string s:hmap1[name]){\\n            func(s,order);\\n        }\\n    }\\n    vector<string> getInheritanceOrder() {\\n        vector<string> v;\\n        func(king,v);\\n        return v;\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass ThroneInheritance {\\npublic:\\n    unordered_map<string,vector<string>> hmap1;\\n    unordered_map<string,bool> hmap2;\\n    string king;\\n    ThroneInheritance(string kingName) {\\n        vector<string> v;\\n        hmap1[kingName]=v;\\n        hmap2[kingName]=true;\\n        king=kingName;\\n    }\\n    \\n    void birth(string parentName, string childName) {\\n        hmap1[parentName].push_back(childName);\\n        hmap2[childName]=true;\\n    }\\n    \\n    void death(string name) {\\n        hmap2[name]=false;\\n    }\\n    void func(string name,vector<string> &order){\\n        if(hmap2[name]){order.push_back(name);}\\n        for(string s:hmap1[name]){\\n            func(s,order);\\n        }\\n    }\\n    vector<string> getInheritanceOrder() {\\n        vector<string> v;\\n        func(king,v);\\n        return v;\\n    }\\n};",
                "codeTag": "Java"
            },
            {
                "id": 2182978,
                "title": "javascript-ranking-scores",
                "content": "The constraints show there are 10000 times more writes than reads. It\\'s therefor more efficient to sort scores on reads instead of on writes.\\nThe constraints also show that `birth` and `death` will be called a maximum of 10^5 times. That means that using `utf-8` encoding for keeping scores will suffice.\\nThe idea here is save siblings with following `utf-8` character. Each generation will be scored as aother character.\\nWhen evaluating `a < b` when both `a` and `b` are strings, Javascript will do a character by character comparisson. \\nTo prevent redundant iterations on reads we cache the result and invalidate on writes.\\n```\\n/**\\n * @param {string} kingName\\n */\\nvar ThroneInheritance = function(kingName) {\\n    ThroneInheritance.prototype.change = true;\\n    ThroneInheritance.prototype.names = {\\n        [kingName]: { \\n            rank: String.fromCharCode(0),\\n            children: 0,\\n        }\\n    };\\n};\\n\\n/** \\n * @param {string} parentName \\n * @param {string} childName\\n * @return {void}\\n */\\nThroneInheritance.prototype.birth = function(parentName, childName) {\\n    ThroneInheritance.prototype.change = true;\\n    ThroneInheritance.prototype.names[childName] = { \\n        rank: `${ThroneInheritance.prototype.names[parentName].rank}${String.fromCharCode(ThroneInheritance.prototype.names[parentName].children)}`,\\n        children: 0,\\n    };\\n    ThroneInheritance.prototype.names[parentName].children += 1;\\n};\\n\\n/** \\n * @param {string} name\\n * @return {void}\\n */\\nThroneInheritance.prototype.death = function(name) {\\n    ThroneInheritance.prototype.change = true;\\n    delete ThroneInheritance.prototype.names[name];\\n};\\n\\n/**\\n * @return {string[]}\\n */\\nThroneInheritance.prototype.getInheritanceOrder = function() {\\n    if(ThroneInheritance.prototype.change) {\\n        ThroneInheritance.prototype.change = false;\\n        ThroneInheritance.prototype.order = Object\\n            .entries(ThroneInheritance.prototype.names)\\n            .sort((a, b) => a[1].rank < b[1].rank ? -1 : 1)\\n            .map((a) => a[0]);\\n    }\\n    return ThroneInheritance.prototype.order;\\n};\\n\\n/** \\n * Your ThroneInheritance object will be instantiated and called as such:\\n * var obj = new ThroneInheritance(kingName)\\n * obj.birth(parentName,childName)\\n * obj.death(name)\\n * var param_3 = obj.getInheritanceOrder()\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string} kingName\\n */\\nvar ThroneInheritance = function(kingName) {\\n    ThroneInheritance.prototype.change = true;\\n    ThroneInheritance.prototype.names = {\\n        [kingName]: { \\n            rank: String.fromCharCode(0),\\n            children: 0,\\n        }\\n    };\\n};\\n\\n/** \\n * @param {string} parentName \\n * @param {string} childName\\n * @return {void}\\n */\\nThroneInheritance.prototype.birth = function(parentName, childName) {\\n    ThroneInheritance.prototype.change = true;\\n    ThroneInheritance.prototype.names[childName] = { \\n        rank: `${ThroneInheritance.prototype.names[parentName].rank}${String.fromCharCode(ThroneInheritance.prototype.names[parentName].children)}`,\\n        children: 0,\\n    };\\n    ThroneInheritance.prototype.names[parentName].children += 1;\\n};\\n\\n/** \\n * @param {string} name\\n * @return {void}\\n */\\nThroneInheritance.prototype.death = function(name) {\\n    ThroneInheritance.prototype.change = true;\\n    delete ThroneInheritance.prototype.names[name];\\n};\\n\\n/**\\n * @return {string[]}\\n */\\nThroneInheritance.prototype.getInheritanceOrder = function() {\\n    if(ThroneInheritance.prototype.change) {\\n        ThroneInheritance.prototype.change = false;\\n        ThroneInheritance.prototype.order = Object\\n            .entries(ThroneInheritance.prototype.names)\\n            .sort((a, b) => a[1].rank < b[1].rank ? -1 : 1)\\n            .map((a) => a[0]);\\n    }\\n    return ThroneInheritance.prototype.order;\\n};\\n\\n/** \\n * Your ThroneInheritance object will be instantiated and called as such:\\n * var obj = new ThroneInheritance(kingName)\\n * obj.birth(parentName,childName)\\n * obj.death(name)\\n * var param_3 = obj.getInheritanceOrder()\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2128688,
                "title": "c-hashmap",
                "content": "```\\nclass ThroneInheritance {\\npublic:\\n    string k;\\n    unordered_map<string,pair<bool,vector<string>>>mp;\\n    ThroneInheritance(string kingName) {\\n        k=kingName;\\n    }\\n    \\n    void birth(string parentName, string childName) {\\n        mp[parentName].second.push_back(childName);\\n    }\\n    \\n    void death(string name) {\\n        mp[name].first=true;\\n    }\\n    void succ(string n,vector<string>&res){\\n        if(!mp[n].first)res.push_back(n);\\n        for(auto&i:mp[n].second)succ(i,res);\\n    }\\n    \\n    vector<string> getInheritanceOrder() {\\n        vector<string>res;\\n        succ(k,res);\\n        return res;\\n    }\\n};\\n\\n/**\\n * Your ThroneInheritance object will be instantiated and called as such:\\n * ThroneInheritance* obj = new ThroneInheritance(kingName);\\n * obj->birth(parentName,childName);\\n * obj->death(name);\\n * vector<string> param_3 = obj->getInheritanceOrder();\\n */\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass ThroneInheritance {\\npublic:\\n    string k;\\n    unordered_map<string,pair<bool,vector<string>>>mp;\\n    ThroneInheritance(string kingName) {\\n        k=kingName;\\n    }\\n    \\n    void birth(string parentName, string childName) {\\n        mp[parentName].second.push_back(childName);\\n    }\\n    \\n    void death(string name) {\\n        mp[name].first=true;\\n    }\\n    void succ(string n,vector<string>&res){\\n        if(!mp[n].first)res.push_back(n);\\n        for(auto&i:mp[n].second)succ(i,res);\\n    }\\n    \\n    vector<string> getInheritanceOrder() {\\n        vector<string>res;\\n        succ(k,res);\\n        return res;\\n    }\\n};\\n\\n/**\\n * Your ThroneInheritance object will be instantiated and called as such:\\n * ThroneInheritance* obj = new ThroneInheritance(kingName);\\n * obj->birth(parentName,childName);\\n * obj->death(name);\\n * vector<string> param_3 = obj->getInheritanceOrder();\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2111381,
                "title": "python-dfs-w-hashmap-hashset",
                "content": "```\\nclass ThroneInheritance:\\n\\n    def __init__(self, kingName: str):\\n        self.curr_king = kingName\\n        self.successors = defaultdict(list)\\n        self.parent = {}\\n        self.passed = set()\\n\\n    def birth(self, parentName: str, childName: str) -> None:\\n        self.successors[parentName].append(childName)\\n        self.parent[childName] = parentName\\n\\n    def death(self, name: str) -> None:\\n        self.passed.add(name)\\n\\n    def getInheritanceOrder(self) -> List[str]:\\n        ans = []\\n        def dfs(node):\\n            if node not in self.passed:\\n                ans.append(node)\\n                \\n            for succ in self.successors[node]:\\n                dfs(succ)\\n            \\n        dfs(self.curr_king)\\n        return ans \\n\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass ThroneInheritance:\\n\\n    def __init__(self, kingName: str):\\n        self.curr_king = kingName\\n        self.successors = defaultdict(list)\\n        self.parent = {}\\n        self.passed = set()\\n\\n    def birth(self, parentName: str, childName: str) -> None:\\n        self.successors[parentName].append(childName)\\n        self.parent[childName] = parentName\\n\\n    def death(self, name: str) -> None:\\n        self.passed.add(name)\\n\\n    def getInheritanceOrder(self) -> List[str]:\\n        ans = []\\n        def dfs(node):\\n            if node not in self.passed:\\n                ans.append(node)\\n                \\n            for succ in self.successors[node]:\\n                dfs(succ)\\n            \\n        dfs(self.curr_king)\\n        return ans \\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2107959,
                "title": "elixir-dfs",
                "content": "```elixir\\ndefmodule ThroneInheritance do\\n  use GenServer\\n\\n  @spec init_(king_name :: String.t()) :: any\\n  def init_(king_name) do\\n    GenServer.start_link(__MODULE__, [], name: __MODULE__)\\n    GenServer.call(__MODULE__, {:init, king_name})\\n  end\\n\\n  @spec birth(parent_name :: String.t(), child_name :: String.t()) :: any\\n  def birth(parent_name, child_name) do\\n    GenServer.call(__MODULE__, {:birth, parent_name, child_name})\\n  end\\n\\n  @spec death(name :: String.t()) :: any\\n  def death(name) do\\n    GenServer.call(__MODULE__, {:death, name})\\n  end\\n\\n  @spec get_inheritance_order() :: [String.t()]\\n  def get_inheritance_order() do\\n    GenServer.call(__MODULE__, :order)\\n  end\\n\\n  def init(state) do\\n    {:ok, state}\\n  end\\n\\n  def handle_call({:init, king_name}, _from, _state) do\\n    {:reply, true, {king_name, %{}, MapSet.new()}}\\n  end\\n\\n  def handle_call({:birth, parent_name, child_name}, _from, {king_name, children, death_note}) do\\n    children = Map.update(children, parent_name, [child_name], fn l -> [child_name | l] end)\\n    {:reply, true, {king_name, children, death_note}}\\n  end\\n\\n  def handle_call({:death, name}, _from, {king_name, children, death_note}) do\\n    {:reply, true, {king_name, children, MapSet.put(death_note, name)}}\\n  end\\n\\n  def handle_call(:order, _from, state) do\\n    {:reply, dfs(state), state}\\n  end\\n\\n  def dfs(state) do\\n    dfs(state, []) |> Enum.reverse()\\n  end\\n\\n  def dfs({name, children, death_note}, ans) do\\n    ans = if MapSet.member?(death_note, name), do: ans, else: [name | ans]\\n\\n    children\\n    |> Map.get(name, [])\\n    |> Enum.reverse()\\n    |> Enum.reduce(ans, fn child, ans ->\\n      dfs({child, children, death_note}, ans)\\n    end)\\n  end\\nend\\n\\n# Your functions will be called as such:\\n# ThroneInheritance.init_(king_name)\\n# ThroneInheritance.birth(parent_name, child_name)\\n# ThroneInheritance.death(name)\\n# param_3 = ThroneInheritance.get_inheritance_order()\\n\\n# ThroneInheritance.init_ will be called before every test case, in which you can do some necessary initializations\\n```",
                "solutionTags": [
                    "Elixir",
                    "Depth-First Search"
                ],
                "code": "```elixir\\ndefmodule ThroneInheritance do\\n  use GenServer\\n\\n  @spec init_(king_name :: String.t()) :: any\\n  def init_(king_name) do\\n    GenServer.start_link(__MODULE__, [], name: __MODULE__)\\n    GenServer.call(__MODULE__, {:init, king_name})\\n  end\\n\\n  @spec birth(parent_name :: String.t(), child_name :: String.t()) :: any\\n  def birth(parent_name, child_name) do\\n    GenServer.call(__MODULE__, {:birth, parent_name, child_name})\\n  end\\n\\n  @spec death(name :: String.t()) :: any\\n  def death(name) do\\n    GenServer.call(__MODULE__, {:death, name})\\n  end\\n\\n  @spec get_inheritance_order() :: [String.t()]\\n  def get_inheritance_order() do\\n    GenServer.call(__MODULE__, :order)\\n  end\\n\\n  def init(state) do\\n    {:ok, state}\\n  end\\n\\n  def handle_call({:init, king_name}, _from, _state) do\\n    {:reply, true, {king_name, %{}, MapSet.new()}}\\n  end\\n\\n  def handle_call({:birth, parent_name, child_name}, _from, {king_name, children, death_note}) do\\n    children = Map.update(children, parent_name, [child_name], fn l -> [child_name | l] end)\\n    {:reply, true, {king_name, children, death_note}}\\n  end\\n\\n  def handle_call({:death, name}, _from, {king_name, children, death_note}) do\\n    {:reply, true, {king_name, children, MapSet.put(death_note, name)}}\\n  end\\n\\n  def handle_call(:order, _from, state) do\\n    {:reply, dfs(state), state}\\n  end\\n\\n  def dfs(state) do\\n    dfs(state, []) |> Enum.reverse()\\n  end\\n\\n  def dfs({name, children, death_note}, ans) do\\n    ans = if MapSet.member?(death_note, name), do: ans, else: [name | ans]\\n\\n    children\\n    |> Map.get(name, [])\\n    |> Enum.reverse()\\n    |> Enum.reduce(ans, fn child, ans ->\\n      dfs({child, children, death_note}, ans)\\n    end)\\n  end\\nend\\n\\n# Your functions will be called as such:\\n# ThroneInheritance.init_(king_name)\\n# ThroneInheritance.birth(parent_name, child_name)\\n# ThroneInheritance.death(name)\\n# param_3 = ThroneInheritance.get_inheritance_order()\\n\\n# ThroneInheritance.init_ will be called before every test case, in which you can do some necessary initializations\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2020031,
                "title": "simplest-solution-easiest-to-understand",
                "content": "```\\nclass ThroneInheritance {\\n\\n    Map<String,List<String>> map;\\n    Set<String> deathSet;\\n    String root;\\n    \\n    public ThroneInheritance(String kingName) {\\n        map= new HashMap<>();\\n        deathSet= new HashSet<>();\\n        \\n        map.putIfAbsent(kingName,new ArrayList<>());\\n        root=kingName;\\n    }\\n    \\n    public void birth(String parentName, String childName) {\\n        map.get(parentName).add(childName);\\n        map.put(childName,new ArrayList<>());\\n    }\\n    \\n    public void death(String name) {\\n        deathSet.add(name);\\n    }\\n    \\n    public List<String> getInheritanceOrder() {\\n        \\n        List<String> res= new ArrayList<>();\\n        dfs(root,res);\\n        return res;\\n    }\\n    \\n    public void dfs(String root, List<String> res) {\\n    \\n        if(!deathSet.contains(root))\\n            res.add(root);\\n        for(String child:map.get(root))\\n        {\\n            dfs(child,res);\\n        }\\n    }\\n}\\n ```",
                "solutionTags": [],
                "code": "```\\nclass ThroneInheritance {\\n\\n    Map<String,List<String>> map;\\n    Set<String> deathSet;\\n    String root;\\n    \\n    public ThroneInheritance(String kingName) {\\n        map= new HashMap<>();\\n        deathSet= new HashSet<>();\\n        \\n        map.putIfAbsent(kingName,new ArrayList<>());\\n        root=kingName;\\n    }\\n    \\n    public void birth(String parentName, String childName) {\\n        map.get(parentName).add(childName);\\n        map.put(childName,new ArrayList<>());\\n    }\\n    \\n    public void death(String name) {\\n        deathSet.add(name);\\n    }\\n    \\n    public List<String> getInheritanceOrder() {\\n        \\n        List<String> res= new ArrayList<>();\\n        dfs(root,res);\\n        return res;\\n    }\\n    \\n    public void dfs(String root, List<String> res) {\\n    \\n        if(!deathSet.contains(root))\\n            res.add(root);\\n        for(String child:map.get(root))\\n        {\\n            dfs(child,res);\\n        }\\n    }\\n}\\n ```",
                "codeTag": "Java"
            },
            {
                "id": 2008154,
                "title": "simple-java-recursion",
                "content": "```\\nclass ThroneInheritance {\\n    String kingName;\\n    HashMap<String, List<String>> childrenMapping = new HashMap<>();\\n    HashMap<String, Boolean> isAlive = new HashMap<>();\\n\\n    public ThroneInheritance(String kingName) {\\n        this.kingName = kingName;\\n        childrenMapping.put(this.kingName, new ArrayList<>());\\n        isAlive.put(this.kingName, true);\\n    }\\n\\n    public void birth(String parentName, String childName) {\\n        childrenMapping.get(parentName).add(childName);\\n        childrenMapping.put(childName, new ArrayList<>());\\n        isAlive.put(childName, true);\\n    }\\n\\n    public void death(String name) {\\n        isAlive.put(name, false);\\n    }\\n\\n    public List<String> getInheritanceOrder() {\\n        List<String> inheritanceOrder = new ArrayList<>();\\n        if (isAlive.get(this.kingName)) {\\n            inheritanceOrder.add(this.kingName);\\n        }\\n        for (String child: childrenMapping.get(this.kingName)) {\\n            getInheritanceOrder(child, inheritanceOrder);\\n        }\\n        return inheritanceOrder;\\n    }\\n\\n    private void getInheritanceOrder(String name, List<String> order) {\\n        if (isAlive.get(name)) {\\n            order.add(name);\\n        }\\n        for (String child: childrenMapping.get(name)) {\\n            getInheritanceOrder(child, order);\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass ThroneInheritance {\\n    String kingName;\\n    HashMap<String, List<String>> childrenMapping = new HashMap<>();\\n    HashMap<String, Boolean> isAlive = new HashMap<>();\\n\\n    public ThroneInheritance(String kingName) {\\n        this.kingName = kingName;\\n        childrenMapping.put(this.kingName, new ArrayList<>());\\n        isAlive.put(this.kingName, true);\\n    }\\n\\n    public void birth(String parentName, String childName) {\\n        childrenMapping.get(parentName).add(childName);\\n        childrenMapping.put(childName, new ArrayList<>());\\n        isAlive.put(childName, true);\\n    }\\n\\n    public void death(String name) {\\n        isAlive.put(name, false);\\n    }\\n\\n    public List<String> getInheritanceOrder() {\\n        List<String> inheritanceOrder = new ArrayList<>();\\n        if (isAlive.get(this.kingName)) {\\n            inheritanceOrder.add(this.kingName);\\n        }\\n        for (String child: childrenMapping.get(this.kingName)) {\\n            getInheritanceOrder(child, inheritanceOrder);\\n        }\\n        return inheritanceOrder;\\n    }\\n\\n    private void getInheritanceOrder(String name, List<String> order) {\\n        if (isAlive.get(name)) {\\n            order.add(name);\\n        }\\n        for (String child: childrenMapping.get(name)) {\\n            getInheritanceOrder(child, order);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1891891,
                "title": "python",
                "content": "\\n    def __init__(self, kingName):\\n        self.king = kingName\\n        self.dict1 = defaultdict(list)\\n        self.deadkings = set()\\n        \\n    def birth(self, parentName, childName):\\n        self.dict1[parentName].append(childName)\\n\\n    def death(self, name):\\n        self.deadkings.add(name)\\n\\n    def getInheritanceOrder(self):\\n        res = []\\n        \\n        def dfs(node):\\n            if node not in self.deadkings:\\n                res.append(node)\\n                \\n            for child in self.dict1[node]:\\n                dfs(child)\\n                \\n        dfs(self.king)\\n        \\n        return res",
                "solutionTags": [],
                "code": "\\n    def __init__(self, kingName):\\n        self.king = kingName\\n        self.dict1 = defaultdict(list)\\n        self.deadkings = set()\\n        \\n    def birth(self, parentName, childName):\\n        self.dict1[parentName].append(childName)\\n\\n    def death(self, name):\\n        self.deadkings.add(name)\\n\\n    def getInheritanceOrder(self):\\n        res = []\\n        \\n        def dfs(node):\\n            if node not in self.deadkings:\\n                res.append(node)\\n                \\n            for child in self.dict1[node]:\\n                dfs(child)\\n                \\n        dfs(self.king)\\n        \\n        return res",
                "codeTag": "Python3"
            },
            {
                "id": 1807711,
                "title": "java-keeping-the-successor-function",
                "content": "\\nI tried to keep the same Sucessor-function signature because then it just turns into a DFS problem...\\n\\nIt uses a crappy global variable to keep track of the last child added just for optimization (which its just the \"visited\" hashMap in the DFS). It could be just added as a parameter into the Sucessor function (but that would break the signature :), you can discuss of nicer/concurrency-allowing solutions )\\nUses pointers to next/first/last child to avoid revisiting nodes.\\n\\nUses public variables for readiness\\n\\n```\\n\\nclass Person {\\n    \\n    public String name; \\n    public boolean alive=true;\\n    \\n    public Person parent;\\n        \\n    public Person firstChild;\\n    public Person lastChild;\\n    \\n    public Person nextBrother;\\n    \\n    public Person(String name) {\\n        this.name=name;\\n    }\\n}\\n\\nclass ThroneInheritance {\\n    \\n    private String kingName;\\n    private HashMap<String, Person> kingdom = new HashMap<String, Person>();\\n    \\n    public ThroneInheritance(String kingName) {\\n        this.kingName = kingName;\\n        kingdom.put(kingName, new Person(kingName));\\n    }\\n    \\n    public void birth(String parentName, String childName) {\\n        Person parent = kingdom.get(parentName);\\n        Person bornPerson = new Person(childName);\\n        bornPerson.parent=parent;\\n        if (parent.lastChild!=null) {\\n            parent.lastChild.nextBrother = bornPerson;\\n        }\\n        if (parent.firstChild == null) {\\n            parent.firstChild = bornPerson;\\n        }\\n        kingdom.put(childName, bornPerson);\\n        parent.lastChild = bornPerson;\\n    }\\n    \\n    public void death(String name) {\\n        Person person = kingdom.get(name);\\n        person.alive=false;\\n    }\\n    \\n    private HashMap<String,Person> lastChildPerPerson = new HashMap<String,Person>();\\n    \\n    public List<String> getInheritanceOrder() {\\n        lastChildPerPerson.clear();\\n        List<String> ret = new ArrayList<String>();\\n        String nextSuccessor = kingName;\\n        while (nextSuccessor!=null) {\\n            if (kingdom.get(nextSuccessor).alive) {\\n                ret.add(nextSuccessor);\\n            };\\n            nextSuccessor = Successor(nextSuccessor, ret);\\n        }\\n        return ret;\\n    }\\n    \\n    public String Successor(String name, List<String> curOrder) {\\n        Person person = kingdom.get(name);\\n        Person lastChild = lastChildPerPerson.get(name);\\n        if (person.firstChild==null || \\n            (lastChild != null &&  person.lastChild.name.equals(lastChild.name))\\n           ) {\\n            if (name.equals(kingName)) {\\n                return null;\\n            } else {\\n                return Successor(person.parent.name, curOrder);\\n            }\\n        } else {\\n            Person lastPerson = lastChildPerPerson.get(name);\\n            Person nextPerson;\\n            if (lastPerson != null) {\\n                nextPerson = lastPerson.nextBrother;\\n            } else {\\n                nextPerson = person.firstChild;\\n            }\\n\\n            if (nextPerson != null) {\\n                lastChildPerPerson.put(name, nextPerson);\\n                return nextPerson.name;\\n            } else {\\n                return null;\\n            }\\n        }\\n    }\\n}\\n\\n/**\\n * Your ThroneInheritance object will be instantiated and called as such:\\n * ThroneInheritance obj = new ThroneInheritance(kingName);\\n * obj.birth(parentName,childName);\\n * obj.death(name);\\n * List<String> param_3 = obj.getInheritanceOrder();\\n */\\n ```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n\\nclass Person {\\n    \\n    public String name; \\n    public boolean alive=true;\\n    \\n    public Person parent;\\n        \\n    public Person firstChild;\\n    public Person lastChild;\\n    \\n    public Person nextBrother;\\n    \\n    public Person(String name) {\\n        this.name=name;\\n    }\\n}\\n\\nclass ThroneInheritance {\\n    \\n    private String kingName;\\n    private HashMap<String, Person> kingdom = new HashMap<String, Person>();\\n    \\n    public ThroneInheritance(String kingName) {\\n        this.kingName = kingName;\\n        kingdom.put(kingName, new Person(kingName));\\n    }\\n    \\n    public void birth(String parentName, String childName) {\\n        Person parent = kingdom.get(parentName);\\n        Person bornPerson = new Person(childName);\\n        bornPerson.parent=parent;\\n        if (parent.lastChild!=null) {\\n            parent.lastChild.nextBrother = bornPerson;\\n        }\\n        if (parent.firstChild == null) {\\n            parent.firstChild = bornPerson;\\n        }\\n        kingdom.put(childName, bornPerson);\\n        parent.lastChild = bornPerson;\\n    }\\n    \\n    public void death(String name) {\\n        Person person = kingdom.get(name);\\n        person.alive=false;\\n    }\\n    \\n    private HashMap<String,Person> lastChildPerPerson = new HashMap<String,Person>();\\n    \\n    public List<String> getInheritanceOrder() {\\n        lastChildPerPerson.clear();\\n        List<String> ret = new ArrayList<String>();\\n        String nextSuccessor = kingName;\\n        while (nextSuccessor!=null) {\\n            if (kingdom.get(nextSuccessor).alive) {\\n                ret.add(nextSuccessor);\\n            };\\n            nextSuccessor = Successor(nextSuccessor, ret);\\n        }\\n        return ret;\\n    }\\n    \\n    public String Successor(String name, List<String> curOrder) {\\n        Person person = kingdom.get(name);\\n        Person lastChild = lastChildPerPerson.get(name);\\n        if (person.firstChild==null || \\n            (lastChild != null &&  person.lastChild.name.equals(lastChild.name))\\n           ) {\\n            if (name.equals(kingName)) {\\n                return null;\\n            } else {\\n                return Successor(person.parent.name, curOrder);\\n            }\\n        } else {\\n            Person lastPerson = lastChildPerPerson.get(name);\\n            Person nextPerson;\\n            if (lastPerson != null) {\\n                nextPerson = lastPerson.nextBrother;\\n            } else {\\n                nextPerson = person.firstChild;\\n            }\\n\\n            if (nextPerson != null) {\\n                lastChildPerPerson.put(name, nextPerson);\\n                return nextPerson.name;\\n            } else {\\n                return null;\\n            }\\n        }\\n    }\\n}\\n\\n/**\\n * Your ThroneInheritance object will be instantiated and called as such:\\n * ThroneInheritance obj = new ThroneInheritance(kingName);\\n * obj.birth(parentName,childName);\\n * obj.death(name);\\n * List<String> param_3 = obj.getInheritanceOrder();\\n */\\n ```",
                "codeTag": "Java"
            },
            {
                "id": 1805654,
                "title": "why-is-the-successor-thing-mentioned-unecessarily-confusing-did-anyone-get-that-in-interview",
                "content": "The mention of the successor function is unecessarily confusing.. they could have easily explained it with just the example and explained that the older kids inherit before the younger kids. After reading that, one can see that its a simple pre order traversal question. Did anyone have this question in an interview where they described the successor thing?",
                "solutionTags": [],
                "code": "",
                "codeTag": "Unknown"
            },
            {
                "id": 1764553,
                "title": "java-simple-solution-using-dfs",
                "content": "```\\nclass ThroneInheritance {\\n    String king;\\n    HashMap<String, LinkedHashSet<String>> graph;\\n    HashSet<String> isDead;\\n    \\n    public ThroneInheritance(String kingName) {\\n        king = kingName;\\n        \\n        graph = new HashMap<>();    \\n        \\n        isDead = new HashSet<>();\\n        \\n        graph.put(kingName, new LinkedHashSet<>());\\n    }\\n    \\n    public void birth(String parentName, String childName) {\\n        graph.putIfAbsent(parentName, new LinkedHashSet<>());\\n        \\n        graph.get(parentName).add(childName);\\n    }\\n    \\n    public void death(String name) {\\n        isDead.add(name);\\n    }\\n    \\n    public List<String> getInheritanceOrder() {\\n        List<String> inheritance = new ArrayList<>();\\n        \\n        HashSet<String> visited = new HashSet<>();\\n        \\n        dfs(graph, king, inheritance, visited);\\n        \\n        return inheritance;\\n    }\\n    \\n    public void dfs(HashMap<String, LinkedHashSet<String>> graph, String src, List<String> l, HashSet<String> visited){\\n        visited.add(src);\\n        \\n        if(!isDead.contains(src))\\n            l.add(src);\\n        \\n        if(!graph.containsKey(src))\\n            return;\\n        \\n        for(String s: graph.get(src)){\\n            if(!visited.contains(s))\\n                dfs(graph, s, l, visited);\\n        }\\n     }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search"
                ],
                "code": "```\\nclass ThroneInheritance {\\n    String king;\\n    HashMap<String, LinkedHashSet<String>> graph;\\n    HashSet<String> isDead;\\n    \\n    public ThroneInheritance(String kingName) {\\n        king = kingName;\\n        \\n        graph = new HashMap<>();    \\n        \\n        isDead = new HashSet<>();\\n        \\n        graph.put(kingName, new LinkedHashSet<>());\\n    }\\n    \\n    public void birth(String parentName, String childName) {\\n        graph.putIfAbsent(parentName, new LinkedHashSet<>());\\n        \\n        graph.get(parentName).add(childName);\\n    }\\n    \\n    public void death(String name) {\\n        isDead.add(name);\\n    }\\n    \\n    public List<String> getInheritanceOrder() {\\n        List<String> inheritance = new ArrayList<>();\\n        \\n        HashSet<String> visited = new HashSet<>();\\n        \\n        dfs(graph, king, inheritance, visited);\\n        \\n        return inheritance;\\n    }\\n    \\n    public void dfs(HashMap<String, LinkedHashSet<String>> graph, String src, List<String> l, HashSet<String> visited){\\n        visited.add(src);\\n        \\n        if(!isDead.contains(src))\\n            l.add(src);\\n        \\n        if(!graph.containsKey(src))\\n            return;\\n        \\n        for(String s: graph.get(src)){\\n            if(!visited.contains(s))\\n                dfs(graph, s, l, visited);\\n        }\\n     }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1685461,
                "title": "python-dfs-easy-to-understand-with-explanation",
                "content": "```\\nclass Member:\\n    def __init__(self,name):\\n        self.name=name\\n        self.children=[]\\n        self.isAlive = True\\nclass ThroneInheritance:\\n\\n    def __init__(self, kingName: str):\\n        self.king = Member(kingName)\\n        self.members={kingName:self.king} #lookup table to set/check isAlive Flag and give birth\\n\\n    def birth(self, parentName: str, childName: str) -> None:\\n        newMember = Member(childName) #create new member\\n        self.members[childName]=newMember #add member to lookup table\\n        self.members[parentName].children.append(newMember) #add new member as a child to its parent\\n\\n    def death(self, name: str) -> None:\\n        self.members[name].isAlive=False\\n\\n    def getInheritanceOrder(self) -> List[str]:\\n        def dfs(root): #dfs provides the order of successor, as the older child are at the begining of children list\\n            if not root:\\n                return []\\n            res=[root]\\n            for child in root.children:\\n                res.extend(dfs(child)) #look for children of child in the order of their birthing (implicitly provided by the order they were inserted in the list)\\n            return res\\n        return [member.name for member in dfs(self.king) if member.isAlive] #filter and remove dead members before returning\\n\\n\\n# Your ThroneInheritance object will be instantiated and called as such:\\n# obj = ThroneInheritance(kingName)\\n# obj.birth(parentName,childName)\\n# obj.death(name)\\n# param_3 = obj.getInheritanceOrder()\\n```",
                "solutionTags": [],
                "code": "```\\nclass Member:\\n    def __init__(self,name):\\n        self.name=name\\n        self.children=[]\\n        self.isAlive = True\\nclass ThroneInheritance:\\n\\n    def __init__(self, kingName: str):\\n        self.king = Member(kingName)\\n        self.members={kingName:self.king} #lookup table to set/check isAlive Flag and give birth\\n\\n    def birth(self, parentName: str, childName: str) -> None:\\n        newMember = Member(childName) #create new member\\n        self.members[childName]=newMember #add member to lookup table\\n        self.members[parentName].children.append(newMember) #add new member as a child to its parent\\n\\n    def death(self, name: str) -> None:\\n        self.members[name].isAlive=False\\n\\n    def getInheritanceOrder(self) -> List[str]:\\n        def dfs(root): #dfs provides the order of successor, as the older child are at the begining of children list\\n            if not root:\\n                return []\\n            res=[root]\\n            for child in root.children:\\n                res.extend(dfs(child)) #look for children of child in the order of their birthing (implicitly provided by the order they were inserted in the list)\\n            return res\\n        return [member.name for member in dfs(self.king) if member.isAlive] #filter and remove dead members before returning\\n\\n\\n# Your ThroneInheritance object will be instantiated and called as such:\\n# obj = ThroneInheritance(kingName)\\n# obj.birth(parentName,childName)\\n# obj.death(name)\\n# param_3 = obj.getInheritanceOrder()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1684841,
                "title": "m-nary-tree-preorder-traversal-simple-java-solution-easy-understanding",
                "content": "```java\\n// AC: Runtime: 262 ms, faster than 62.61% of Java online submissions for Throne Inheritance.\\n// Memory Usage: 104.9 MB, less than 60.87% of Java online submissions for Throne Inheritance.\\n// M-nary tree pre-order traversal.\\n// T:birth, death:O(1), getInheritanceOrder:O(n), S:O(n)\\n// \\nclass MTreeNode {\\n    String val;\\n    List<MTreeNode> children;\\n    MTreeNode(String val) {\\n        this.val = val;\\n    }\\n    public MTreeNode addChild(String val) {\\n        if (children == null) {\\n            children = new LinkedList<>();\\n        }\\n        MTreeNode childNode = new MTreeNode(val);\\n        children.add(childNode);\\n        return childNode;\\n    }\\n}\\n\\nclass ThroneInheritance {\\n    MTreeNode root;\\n    HashMap<String, MTreeNode> nodes;\\n    HashSet<String> deadList;\\n    List<String> inheritanceOrder;\\n\\n    public ThroneInheritance(String kingName) {\\n        root = new MTreeNode(kingName);\\n        nodes = new HashMap<>();\\n        nodes.put(kingName, root);\\n        deadList = new HashSet<>();\\n        inheritanceOrder = new ArrayList<>();\\n    }\\n\\n    public void birth(String parentName, String childName) {\\n        MTreeNode pNode = nodes.get(parentName);\\n        MTreeNode childNode = pNode.addChild(childName);\\n        nodes.put(childName, childNode);\\n    }\\n\\n    public void death(String name) {\\n        deadList.add(name);\\n    }\\n\\n    public List<String> getInheritanceOrder() {\\n        inheritanceOrder.clear();\\n        travel(root);\\n        return inheritanceOrder;\\n    }\\n\\n    private void travel(MTreeNode root) {\\n        if (root == null) {\\n            return;\\n        }\\n        if (!deadList.contains(root.val)) {\\n            inheritanceOrder.add(root.val);\\n        }\\n        if (root.children != null) {\\n            for (MTreeNode child: root.children) {\\n                travel(child);\\n            }\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Tree"
                ],
                "code": "```java\\n// AC: Runtime: 262 ms, faster than 62.61% of Java online submissions for Throne Inheritance.\\n// Memory Usage: 104.9 MB, less than 60.87% of Java online submissions for Throne Inheritance.\\n// M-nary tree pre-order traversal.\\n// T:birth, death:O(1), getInheritanceOrder:O(n), S:O(n)\\n// \\nclass MTreeNode {\\n    String val;\\n    List<MTreeNode> children;\\n    MTreeNode(String val) {\\n        this.val = val;\\n    }\\n    public MTreeNode addChild(String val) {\\n        if (children == null) {\\n            children = new LinkedList<>();\\n        }\\n        MTreeNode childNode = new MTreeNode(val);\\n        children.add(childNode);\\n        return childNode;\\n    }\\n}\\n\\nclass ThroneInheritance {\\n    MTreeNode root;\\n    HashMap<String, MTreeNode> nodes;\\n    HashSet<String> deadList;\\n    List<String> inheritanceOrder;\\n\\n    public ThroneInheritance(String kingName) {\\n        root = new MTreeNode(kingName);\\n        nodes = new HashMap<>();\\n        nodes.put(kingName, root);\\n        deadList = new HashSet<>();\\n        inheritanceOrder = new ArrayList<>();\\n    }\\n\\n    public void birth(String parentName, String childName) {\\n        MTreeNode pNode = nodes.get(parentName);\\n        MTreeNode childNode = pNode.addChild(childName);\\n        nodes.put(childName, childNode);\\n    }\\n\\n    public void death(String name) {\\n        deadList.add(name);\\n    }\\n\\n    public List<String> getInheritanceOrder() {\\n        inheritanceOrder.clear();\\n        travel(root);\\n        return inheritanceOrder;\\n    }\\n\\n    private void travel(MTreeNode root) {\\n        if (root == null) {\\n            return;\\n        }\\n        if (!deadList.contains(root.val)) {\\n            inheritanceOrder.add(root.val);\\n        }\\n        if (root.children != null) {\\n            for (MTreeNode child: root.children) {\\n                travel(child);\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1628950,
                "title": "easy-python-3-solution",
                "content": "```\\ndef __init__(self, kingName: str):\\n\\tself.king = kingName\\n\\tself.child = {}\\n\\tself.deads = set()\\n\\ndef birth(self, parentName: str, childName: str) -> None:\\n\\tif parentName not in self.child:\\n\\t\\tself.child[parentName] = []\\n\\tself.child[parentName].append(childName)\\n\\t#print(self.child)\\ndef death(self, name: str) -> None:\\n\\tself.deads.add(name)\\n\\ndef getInheritanceOrder(self) -> List[str]:\\n\\tstack = [self.king]\\n\\torder = []\\n\\n\\twhile stack:\\n\\t\\tnow = stack.pop()\\n\\t\\t#print(now)\\n\\t\\tif now not in self.deads:\\n\\t\\t\\torder.append(now)\\n\\t\\tif now in self.child:\\n\\t\\t\\tstack+=self.child[now][::-1]\\n\\treturn order\\n```",
                "solutionTags": [
                    "Python3",
                    "Depth-First Search"
                ],
                "code": "```\\ndef __init__(self, kingName: str):\\n\\tself.king = kingName\\n\\tself.child = {}\\n\\tself.deads = set()\\n\\ndef birth(self, parentName: str, childName: str) -> None:\\n\\tif parentName not in self.child:\\n\\t\\tself.child[parentName] = []\\n\\tself.child[parentName].append(childName)\\n\\t#print(self.child)\\ndef death(self, name: str) -> None:\\n\\tself.deads.add(name)\\n\\ndef getInheritanceOrder(self) -> List[str]:\\n\\tstack = [self.king]\\n\\torder = []\\n\\n\\twhile stack:\\n\\t\\tnow = stack.pop()\\n\\t\\t#print(now)\\n\\t\\tif now not in self.deads:\\n\\t\\t\\torder.append(now)\\n\\t\\tif now in self.child:\\n\\t\\t\\tstack+=self.child[now][::-1]\\n\\treturn order\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1606727,
                "title": "c-dfs-solution",
                "content": "```\\n// N-Ary Tree implementation from LeetCode Question 589\\nclass Node {\\npublic:\\n    string val;\\n    vector<Node*> children;\\n    bool isDead = false;\\n\\n    Node() {}\\n\\n    Node(string _val) {\\n        val = _val;\\n    }\\n\\n    Node(string _val, vector<Node*> _children) {\\n        val = _val;\\n        children = _children;\\n    }\\n};\\n\\nclass ThroneInheritance {\\n    stack<Node*>Q;\\n    unordered_map<string, Node*> nodeMap; // hashmap to store nodes address by names\\n    Node* root;\\npublic:\\n    ThroneInheritance(string kingName) {\\n        root = new Node(kingName);\\n        nodeMap[kingName] = root;\\n    }\\n    \\n    void birth(string parentName, string childName) {\\n\\t\\t// create a new node \\n\\t\\t// add this node to parents\\' children\\n\\t\\t// store node\\'s address in hashmap\\n        Node* newChild = new Node(childName);\\n        nodeMap[parentName]->children.push_back(newChild);\\n        nodeMap[childName] = newChild;\\n    }\\n    \\n    void death(string name) {\\n\\t\\t// just assign isDead property to true\\n        nodeMap[name]->isDead = true;\\n    }\\n    \\n    vector<string> getInheritanceOrder() {\\n\\t\\t// use pre-order traversal with stack\\n        vector<string> ans;\\n        Q.push(root);\\n        while(!Q.empty()){\\n            auto node = Q.top(); Q.pop();\\n\\t\\t\\t// if node is not dead push back to vector of ans\\n            if(!nodeMap[node->val]->isDead) ans.push_back(node->val);\\n            for(int i=node->children.size()-1; i >= 0; i--) \\n                Q.push(node->children[i]);\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n// N-Ary Tree implementation from LeetCode Question 589\\nclass Node {\\npublic:\\n    string val;\\n    vector<Node*> children;\\n    bool isDead = false;\\n\\n    Node() {}\\n\\n    Node(string _val) {\\n        val = _val;\\n    }\\n\\n    Node(string _val, vector<Node*> _children) {\\n        val = _val;\\n        children = _children;\\n    }\\n};\\n\\nclass ThroneInheritance {\\n    stack<Node*>Q;\\n    unordered_map<string, Node*> nodeMap; // hashmap to store nodes address by names\\n    Node* root;\\npublic:\\n    ThroneInheritance(string kingName) {\\n        root = new Node(kingName);\\n        nodeMap[kingName] = root;\\n    }\\n    \\n    void birth(string parentName, string childName) {\\n\\t\\t// create a new node \\n\\t\\t// add this node to parents\\' children\\n\\t\\t// store node\\'s address in hashmap\\n        Node* newChild = new Node(childName);\\n        nodeMap[parentName]->children.push_back(newChild);\\n        nodeMap[childName] = newChild;\\n    }\\n    \\n    void death(string name) {\\n\\t\\t// just assign isDead property to true\\n        nodeMap[name]->isDead = true;\\n    }\\n    \\n    vector<string> getInheritanceOrder() {\\n\\t\\t// use pre-order traversal with stack\\n        vector<string> ans;\\n        Q.push(root);\\n        while(!Q.empty()){\\n            auto node = Q.top(); Q.pop();\\n\\t\\t\\t// if node is not dead push back to vector of ans\\n            if(!nodeMap[node->val]->isDead) ans.push_back(node->val);\\n            for(int i=node->children.size()-1; i >= 0; i--) \\n                Q.push(node->children[i]);\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1579777,
                "title": "go-tree",
                "content": "```\\ntype ThroneInheritance struct {\\n    dict map[string]*node\\n    tree *node\\n}\\n\\ntype node struct {\\n    name string\\n    isAlive bool\\n    children []*node\\n}\\n\\nfunc Constructor(kingName string) ThroneInheritance {\\n    dict := make(map[string]*node)\\n    node := &node{\\n        name: kingName,\\n        isAlive: true,\\n        children: []*node{},\\n    }\\n    dict[kingName] = node\\n    return ThroneInheritance{\\n        dict: dict,\\n        tree: node,\\n    }\\n}\\n\\n\\nfunc (this *ThroneInheritance) Birth(parentName string, childName string)  {\\n    parent := this.dict[parentName]\\n    child := &node{\\n        name: childName,\\n        isAlive: true,\\n        children: []*node{},\\n    }\\n    this.dict[childName] = child\\n    parent.children = append(parent.children, child)\\n}\\n\\n\\nfunc (this *ThroneInheritance) Death(name string)  {\\n    node := this.dict[name]\\n    node.isAlive = false\\n}\\n\\n\\nfunc (this *ThroneInheritance) GetInheritanceOrder() []string {\\n    var res []string\\n    dfs(this.tree, &res)\\n    return res\\n}\\n\\nfunc dfs(node *node, res *[]string) {\\n    if node.isAlive {\\n        *res = append(*res, node.name)\\n    }\\n    for _, v := range node.children {\\n        dfs(v, res)\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\ntype ThroneInheritance struct {\\n    dict map[string]*node\\n    tree *node\\n}\\n\\ntype node struct {\\n    name string\\n    isAlive bool\\n    children []*node\\n}\\n\\nfunc Constructor(kingName string) ThroneInheritance {\\n    dict := make(map[string]*node)\\n    node := &node{\\n        name: kingName,\\n        isAlive: true,\\n        children: []*node{},\\n    }\\n    dict[kingName] = node\\n    return ThroneInheritance{\\n        dict: dict,\\n        tree: node,\\n    }\\n}\\n\\n\\nfunc (this *ThroneInheritance) Birth(parentName string, childName string)  {\\n    parent := this.dict[parentName]\\n    child := &node{\\n        name: childName,\\n        isAlive: true,\\n        children: []*node{},\\n    }\\n    this.dict[childName] = child\\n    parent.children = append(parent.children, child)\\n}\\n\\n\\nfunc (this *ThroneInheritance) Death(name string)  {\\n    node := this.dict[name]\\n    node.isAlive = false\\n}\\n\\n\\nfunc (this *ThroneInheritance) GetInheritanceOrder() []string {\\n    var res []string\\n    dfs(this.tree, &res)\\n    return res\\n}\\n\\nfunc dfs(node *node, res *[]string) {\\n    if node.isAlive {\\n        *res = append(*res, node.name)\\n    }\\n    for _, v := range node.children {\\n        dfs(v, res)\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1561154,
                "title": "java",
                "content": "```\\nclass Person {\\n    public String name;\\n    public List<Person> children;\\n    public boolean isDead;\\n    \\n    public Person(String name) {\\n        this.name = name;\\n        this.children = new ArrayList<>();\\n        this.isDead = false;\\n    }\\n    \\n    public Person addChild(String name) {\\n        Person child = new Person(name);\\n        this.children.add(child);\\n        return child;\\n    }\\n    \\n    public void setDead() {\\n        this.isDead = true;\\n    }\\n    public boolean getDead() {\\n        return this.isDead;\\n    }\\n    \\n    public List<String> getInheritance(List<String> result) {\\n        if (!this.getDead()) {\\n            result.add(this.name);\\n        }\\n        for (Person p: this.children) {\\n            p.getInheritance(result);\\n        }\\n        return result;\\n    }\\n}\\n\\nclass ThroneInheritance {\\n\\n    Person king;\\n    Map<String, Person> nameToPerson;\\n    \\n    public ThroneInheritance(String kingName) {\\n        this.king = new Person(kingName);\\n        this.nameToPerson = new HashMap<>();\\n        this.nameToPerson.put(kingName, this.king);\\n    }\\n    \\n    public void birth(String parentName, String childName) {\\n        Person person = nameToPerson.get(parentName);\\n        Person child = person.addChild(childName);\\n        nameToPerson.put(childName, child);\\n    }\\n    \\n    public void death(String name) {\\n        Person person = nameToPerson.get(name);\\n        person.setDead();\\n    }\\n    \\n    public List<String> getInheritanceOrder() {\\n        List<String> result = new ArrayList<>();\\n        king.getInheritance(result);\\n        return result;\\n    }\\n}\\n\\n/**\\n * Your ThroneInheritance object will be instantiated and called as such:\\n * ThroneInheritance obj = new ThroneInheritance(kingName);\\n * obj.birth(parentName,childName);\\n * obj.death(name);\\n * List<String> param_3 = obj.getInheritanceOrder();\\n */\\n```",
                "solutionTags": [],
                "code": "```\\nclass Person {\\n    public String name;\\n    public List<Person> children;\\n    public boolean isDead;\\n    \\n    public Person(String name) {\\n        this.name = name;\\n        this.children = new ArrayList<>();\\n        this.isDead = false;\\n    }\\n    \\n    public Person addChild(String name) {\\n        Person child = new Person(name);\\n        this.children.add(child);\\n        return child;\\n    }\\n    \\n    public void setDead() {\\n        this.isDead = true;\\n    }\\n    public boolean getDead() {\\n        return this.isDead;\\n    }\\n    \\n    public List<String> getInheritance(List<String> result) {\\n        if (!this.getDead()) {\\n            result.add(this.name);\\n        }\\n        for (Person p: this.children) {\\n            p.getInheritance(result);\\n        }\\n        return result;\\n    }\\n}\\n\\nclass ThroneInheritance {\\n\\n    Person king;\\n    Map<String, Person> nameToPerson;\\n    \\n    public ThroneInheritance(String kingName) {\\n        this.king = new Person(kingName);\\n        this.nameToPerson = new HashMap<>();\\n        this.nameToPerson.put(kingName, this.king);\\n    }\\n    \\n    public void birth(String parentName, String childName) {\\n        Person person = nameToPerson.get(parentName);\\n        Person child = person.addChild(childName);\\n        nameToPerson.put(childName, child);\\n    }\\n    \\n    public void death(String name) {\\n        Person person = nameToPerson.get(name);\\n        person.setDead();\\n    }\\n    \\n    public List<String> getInheritanceOrder() {\\n        List<String> result = new ArrayList<>();\\n        king.getInheritance(result);\\n        return result;\\n    }\\n}\\n\\n/**\\n * Your ThroneInheritance object will be instantiated and called as such:\\n * ThroneInheritance obj = new ThroneInheritance(kingName);\\n * obj.birth(parentName,childName);\\n * obj.death(name);\\n * List<String> param_3 = obj.getInheritanceOrder();\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1546256,
                "title": "c-solution-easy",
                "content": "\\tpublic class ThroneInheritance {\\n    private string kingName;\\n    private HashSet<string> deads;\\n    private Dictionary<string, List<string>> hm;\\n    private List<string> inheritanceOrder;\\n    public ThroneInheritance(string kingName) {\\n        this.kingName = kingName;\\n        deads = new HashSet<string>();\\n        \\n        hm = new Dictionary<string,List<string>>();\\n    }\\n    \\n    public void Birth(string parentName, string childName) {\\n       if (!hm.ContainsKey(parentName)) \\n        {\\n           List<string> list = new List<string>();\\n           list.Add(childName);\\n           hm.Add(parentName, list);\\n        }\\n       else {\\n           var l = hm[parentName];\\n           l.Add(childName);\\n       }\\n    }\\n    \\n    public void Death(string name) {\\n        deads.Add(name);\\n    }\\n    \\n    public void successor(string s) {\\n        if(!deads.Contains(s)) inheritanceOrder.Add(s);\\n        if (!hm.ContainsKey(s)) return;\\n        foreach(string c in hm[s]) {\\n            successor(c);\\n        }\\n    }\\n    \\n    public IList<string> GetInheritanceOrder() {\\n        inheritanceOrder = new List<string>();\\n        successor(kingName);\\n        return inheritanceOrder;\\n    }\\n}\\n\\n\\n/**\\n * Your ThroneInheritance object will be instantiated and called as such:\\n * ThroneInheritance obj = new ThroneInheritance(kingName);\\n * obj.Birth(parentName,childName);\\n * obj.Death(name);\\n * IList<string> param_3 = obj.GetInheritanceOrder();\\n */",
                "solutionTags": [],
                "code": "\\tpublic class ThroneInheritance {\\n    private string kingName;\\n    private HashSet<string> deads;\\n    private Dictionary<string, List<string>> hm;\\n    private List<string> inheritanceOrder;\\n    public ThroneInheritance(string kingName) {\\n        this.kingName = kingName;\\n        deads = new HashSet<string>();\\n        \\n        hm = new Dictionary<string,List<string>>();\\n    }\\n    \\n    public void Birth(string parentName, string childName) {\\n       if (!hm.ContainsKey(parentName)) \\n        {\\n           List<string> list = new List<string>();\\n           list.Add(childName);\\n           hm.Add(parentName, list);\\n        }\\n       else {\\n           var l = hm[parentName];\\n           l.Add(childName);\\n       }\\n    }\\n    \\n    public void Death(string name) {\\n        deads.Add(name);\\n    }\\n    \\n    public void successor(string s) {\\n        if(!deads.Contains(s)) inheritanceOrder.Add(s);\\n        if (!hm.ContainsKey(s)) return;\\n        foreach(string c in hm[s]) {\\n            successor(c);\\n        }\\n    }\\n    \\n    public IList<string> GetInheritanceOrder() {\\n        inheritanceOrder = new List<string>();\\n        successor(kingName);\\n        return inheritanceOrder;\\n    }\\n}\\n\\n\\n/**\\n * Your ThroneInheritance object will be instantiated and called as such:\\n * ThroneInheritance obj = new ThroneInheritance(kingName);\\n * obj.Birth(parentName,childName);\\n * obj.Death(name);\\n * IList<string> param_3 = obj.GetInheritanceOrder();\\n */",
                "codeTag": "Java"
            },
            {
                "id": 1510340,
                "title": "c-384ms-99-simple-easy-small-dag-dfs",
                "content": "Runtime: 384 ms, faster than 98.82% of C++ online submissions for Throne Inheritance.\\nMemory Usage: 167.2 MB, less than 87.06% of C++ online submissions for Throne Inheritance.\\n```\\nclass ThroneInheritance {\\npublic:\\n  struct Node{\\n    string name;\\n    bool is_live;\\n    vector<Node*> inher;\\n    Node(string n){name = n, is_live = true;}\\n  };\\n  Node* root;\\n  unordered_map <string, Node*> table;\\n  \\n  ThroneInheritance(string kingName) {\\n    table[kingName] = root = new Node(kingName);      \\n  }\\n    \\n  void birth(string parentName, string childName) {\\n    table[parentName]->inher.push_back(table[childName] = new Node (childName));\\n  }\\n    \\n  void death(string name) {\\n    table[name]->is_live = false;\\n  }\\n    \\n  vector<string> getInheritanceOrder() {\\n    vector<string> ans;\\n    dfs(ans, root);\\n    return ans;\\n  }\\n  \\n  void dfs(vector<string> &ans, Node *node){\\n    if(node->is_live) ans.push_back(node->name);\\n    \\n    for(auto &n: node->inher) dfs(ans, n);\\n  }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass ThroneInheritance {\\npublic:\\n  struct Node{\\n    string name;\\n    bool is_live;\\n    vector<Node*> inher;\\n    Node(string n){name = n, is_live = true;}\\n  };\\n  Node* root;\\n  unordered_map <string, Node*> table;\\n  \\n  ThroneInheritance(string kingName) {\\n    table[kingName] = root = new Node(kingName);      \\n  }\\n    \\n  void birth(string parentName, string childName) {\\n    table[parentName]->inher.push_back(table[childName] = new Node (childName));\\n  }\\n    \\n  void death(string name) {\\n    table[name]->is_live = false;\\n  }\\n    \\n  vector<string> getInheritanceOrder() {\\n    vector<string> ans;\\n    dfs(ans, root);\\n    return ans;\\n  }\\n  \\n  void dfs(vector<string> &ans, Node *node){\\n    if(node->is_live) ans.push_back(node->name);\\n    \\n    for(auto &n: node->inher) dfs(ans, n);\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1465282,
                "title": "java-solution",
                "content": "\\tclass ThroneInheritance {\\n    Map<String, LinkedList<String>> graph = null;\\n    Set<String> deaths = new HashSet<>();\\n    String king = null;\\n    public ThroneInheritance(String kingName) {\\n        this.king = kingName;\\n        this.graph = new HashMap<>();\\n        this.graph.put(kingName, new LinkedList<>());\\n    }\\n    \\n    public void birth(String parentName, String childName) {\\n        this.graph.putIfAbsent(parentName, new LinkedList<>());\\n        this.graph.get(parentName).add(childName);\\n    }\\n    \\n    public void death(String name) {\\n        deaths.add(name);\\n    }\\n    \\n    public List<String> getInheritanceOrder() {\\n        List<String> inheritance = new ArrayList<>();\\n        dfs(king, inheritance);\\n        return inheritance;\\n    }\\n    \\n    void dfs(String src, List<String> inheritance)\\n    {\\n        if(!deaths.contains(src))\\n        {\\n            inheritance.add(src);    \\n        }\\n        \\n        LinkedList<String> destinations = this.graph.get(src);\\n        if(destinations == null) return;\\n        for(String destination : destinations)\\n        {\\n            dfs(destination, inheritance);\\n        }\\n    }\\n\\t}",
                "solutionTags": [],
                "code": "\\tclass ThroneInheritance {\\n    Map<String, LinkedList<String>> graph = null;\\n    Set<String> deaths = new HashSet<>();\\n    String king = null;\\n    public ThroneInheritance(String kingName) {\\n        this.king = kingName;\\n        this.graph = new HashMap<>();\\n        this.graph.put(kingName, new LinkedList<>());\\n    }\\n    \\n    public void birth(String parentName, String childName) {\\n        this.graph.putIfAbsent(parentName, new LinkedList<>());\\n        this.graph.get(parentName).add(childName);\\n    }\\n    \\n    public void death(String name) {\\n        deaths.add(name);\\n    }\\n    \\n    public List<String> getInheritanceOrder() {\\n        List<String> inheritance = new ArrayList<>();\\n        dfs(king, inheritance);\\n        return inheritance;\\n    }\\n    \\n    void dfs(String src, List<String> inheritance)\\n    {\\n        if(!deaths.contains(src))\\n        {\\n            inheritance.add(src);    \\n        }\\n        \\n        LinkedList<String> destinations = this.graph.get(src);\\n        if(destinations == null) return;\\n        for(String destination : destinations)\\n        {\\n            dfs(destination, inheritance);\\n        }\\n    }\\n\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1462824,
                "title": "simple-python-solution-using-dfs",
                "content": "```\\n\\'\\'\\'\\n    The familyTree is updated when there is a birth and when there is a death,\\n    the self.dead is updated. On the call of the function getInheritanceOrder a dfs is carried out and those kings who are dead are not included in the order\\n    \\n\\'\\'\\'\\nclass ThroneInheritance:\\n\\n    #just do a simple dfs here, build the graph of the relations every single time there is a birth or death now\\n    def __init__(self, kingName: str):\\n       \\n        self.king = kingName\\n        self.familyTree = dict()\\n        self.familyTree[kingName] = []\\n        self.dead = set()\\n        \\n    def birth(self, parentName: str, childName: str) -> None:\\n        if parentName not in self.familyTree:\\n            self.familyTree = []\\n        self.familyTree[parentName].append(childName)\\n        self.familyTree[childName] = []\\n        \\n\\n    def death(self, name: str) -> None:\\n        self.dead.add(name)\\n\\n    def dfs(self, currentKing):\\n        self.seen.add(currentKing)\\n        if currentKing not in self.dead:\\n            self.order.append(currentKing)\\n        if currentKing in self.familyTree:\\n            for successor in self.familyTree[currentKing]:\\n                if successor not in self.seen:\\n                    self.dfs(successor)\\n        \\n        \\n    def getInheritanceOrder(self) -> List[str]:\\n        self.seen = set()\\n        self.order = []\\n        self.dfs(self.king)\\n        return self.order\\n# Your ThroneInheritance object will be instantiated and called as such:\\n# obj = ThroneInheritance(kingName)\\n# obj.birth(parentName,childName)\\n# obj.death(name)\\n# param_3 = obj.getInheritanceOrder()\\n\\n```",
                "solutionTags": [],
                "code": "```\\n\\'\\'\\'\\n    The familyTree is updated when there is a birth and when there is a death,\\n    the self.dead is updated. On the call of the function getInheritanceOrder a dfs is carried out and those kings who are dead are not included in the order\\n    \\n\\'\\'\\'\\nclass ThroneInheritance:\\n\\n    #just do a simple dfs here, build the graph of the relations every single time there is a birth or death now\\n    def __init__(self, kingName: str):\\n       \\n        self.king = kingName\\n        self.familyTree = dict()\\n        self.familyTree[kingName] = []\\n        self.dead = set()\\n        \\n    def birth(self, parentName: str, childName: str) -> None:\\n        if parentName not in self.familyTree:\\n            self.familyTree = []\\n        self.familyTree[parentName].append(childName)\\n        self.familyTree[childName] = []\\n        \\n\\n    def death(self, name: str) -> None:\\n        self.dead.add(name)\\n\\n    def dfs(self, currentKing):\\n        self.seen.add(currentKing)\\n        if currentKing not in self.dead:\\n            self.order.append(currentKing)\\n        if currentKing in self.familyTree:\\n            for successor in self.familyTree[currentKing]:\\n                if successor not in self.seen:\\n                    self.dfs(successor)\\n        \\n        \\n    def getInheritanceOrder(self) -> List[str]:\\n        self.seen = set()\\n        self.order = []\\n        self.dfs(self.king)\\n        return self.order\\n# Your ThroneInheritance object will be instantiated and called as such:\\n# obj = ThroneInheritance(kingName)\\n# obj.birth(parentName,childName)\\n# obj.death(name)\\n# param_3 = obj.getInheritanceOrder()\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1460242,
                "title": "scala-this-is-a-very-good-practical-question-that-resembles-the-real-work-tasks",
                "content": "```scala\\n\\n  class ThroneInheritance(king: String) {\\n\\n    import scala.collection.mutable.{HashSet, HashMap, TreeSet, LinkedHashSet}\\n    var time = 0\\n    case class People(name: String, age: Int)\\n    val graph = new HashMap[String, TreeSet[People]]\\n    val parts = new HashMap[String, String]\\n    val dies  = new HashSet[String]\\n\\n    graph.put(king, new TreeSet[People]()((a, b) => Integer.compare(a.age, b.age)))\\n\\n    def birth(parentName: String, childName: String) {\\n      time += 1\\n      graph(parentName) += People(childName, time)\\n      graph.put(childName, new TreeSet[People]()((a, b) => Integer.compare(a.age, b.age)))\\n      parts.put(childName, parentName)\\n    }\\n\\n    def death(name: String) = dies += name\\n\\n    def getInheritanceOrder(): List[String] = {\\n      val gp = new HashMap[String, TreeSet[People]]\\n      graph.foreach {\\n        case (k, v) => {\\n          gp.put(k, new TreeSet[People]()((a, b) => Integer.compare(a.age, b.age)))\\n          v.foreach(p => gp(k) += p)\\n        }\\n      }\\n      val res = new LinkedHashSet[String]\\n      var x   = king\\n\\n      def scs(x: String): String = {\\n        if (gp(x).isEmpty) return if (x == king) null else scs(parts(x))\\n        val oldest = gp(x).firstKey\\n        gp(x) -= oldest\\n        oldest.name\\n      }\\n\\n      while (x != null) {\\n        res += x\\n        x = scs(x)\\n      }\\n      dies.foreach(x => res -= x)\\n      res.toList\\n    }\\n\\n  }\\n```",
                "solutionTags": [],
                "code": "```scala\\n\\n  class ThroneInheritance(king: String) {\\n\\n    import scala.collection.mutable.{HashSet, HashMap, TreeSet, LinkedHashSet}\\n    var time = 0\\n    case class People(name: String, age: Int)\\n    val graph = new HashMap[String, TreeSet[People]]\\n    val parts = new HashMap[String, String]\\n    val dies  = new HashSet[String]\\n\\n    graph.put(king, new TreeSet[People]()((a, b) => Integer.compare(a.age, b.age)))\\n\\n    def birth(parentName: String, childName: String) {\\n      time += 1\\n      graph(parentName) += People(childName, time)\\n      graph.put(childName, new TreeSet[People]()((a, b) => Integer.compare(a.age, b.age)))\\n      parts.put(childName, parentName)\\n    }\\n\\n    def death(name: String) = dies += name\\n\\n    def getInheritanceOrder(): List[String] = {\\n      val gp = new HashMap[String, TreeSet[People]]\\n      graph.foreach {\\n        case (k, v) => {\\n          gp.put(k, new TreeSet[People]()((a, b) => Integer.compare(a.age, b.age)))\\n          v.foreach(p => gp(k) += p)\\n        }\\n      }\\n      val res = new LinkedHashSet[String]\\n      var x   = king\\n\\n      def scs(x: String): String = {\\n        if (gp(x).isEmpty) return if (x == king) null else scs(parts(x))\\n        val oldest = gp(x).firstKey\\n        gp(x) -= oldest\\n        oldest.name\\n      }\\n\\n      while (x != null) {\\n        res += x\\n        x = scs(x)\\n      }\\n      dies.foreach(x => res -= x)\\n      res.toList\\n    }\\n\\n  }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1448652,
                "title": "python3-python-using-defaultdict-and-dfs-w-commets",
                "content": "```\\nfrom collections import defaultdict\\n\\n# Make a data structure to hold the data\\nclass InheritanceNode():\\n    def __init__(self, name):\\n        self.name = name\\n        self.alive = True\\n        self.children = []\\n        return\\n    \\nclass ThroneInheritance:\\n\\n    def __init__(self, kingName: str):\\n        # A map to hold all family members\\n        self.family = defaultdict(lambda: None)\\n        # One must start searching from root, king is root here\\n        self.king = kingName\\n        # Add king to family\\n        self.family[self.king] = InheritanceNode(self.king)\\n        return\\n\\n    def birth(self, parentName: str, childName: str) -> None:\\n        \\n        # First add child to family (*L*)\\n        if not self.family[childName]:\\n            self.family[childName] = InheritanceNode(childName)\\n        \\n        # Then join parent with child (*b*)   \\n        parent = self.family[parentName]\\n        parent.children.append(self.family[childName])\\n        \\n        return\\n        \\n\\n    def death(self, name: str) -> None:\\n        # Make that person dead (*I*)\\n        if self.family[name]:\\n            self.family[name].alive = False\\n        return\\n        \\n\\n    def getInheritanceOrder(self) -> List[str]:\\n        \\n        order = []\\n        \\n        # This function is DFS in disguised, modified DFS\\n        def setOrder(stack: List, is_visited: Set):\\n            nonlocal order\\n            if stack:\\n                node = stack.pop()\\n                if node not in is_visited:\\n                    is_visited.add(node)\\n                    if node.alive: # add to order\\n                        order.append(node.name)\\n                    for adj_node in node.children[::-1]: # maintaines order\\n                        stack.append(adj_node)\\n                setOrder(stack, is_visited)\\n            return\\n        \\n        # Start from root\\n        setOrder([self.family[self.king]], set())\\n        \\n        return order\\n        \\n\\n\\n# Your ThroneInheritance object will be instantiated and called as such:\\n# obj = ThroneInheritance(kingName)\\n# obj.birth(parentName,childName)\\n# obj.death(name)\\n# param_3 = obj.getInheritanceOrder()\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Depth-First Search"
                ],
                "code": "```\\nfrom collections import defaultdict\\n\\n# Make a data structure to hold the data\\nclass InheritanceNode():\\n    def __init__(self, name):\\n        self.name = name\\n        self.alive = True\\n        self.children = []\\n        return\\n    \\nclass ThroneInheritance:\\n\\n    def __init__(self, kingName: str):\\n        # A map to hold all family members\\n        self.family = defaultdict(lambda: None)\\n        # One must start searching from root, king is root here\\n        self.king = kingName\\n        # Add king to family\\n        self.family[self.king] = InheritanceNode(self.king)\\n        return\\n\\n    def birth(self, parentName: str, childName: str) -> None:\\n        \\n        # First add child to family (*L*)\\n        if not self.family[childName]:\\n            self.family[childName] = InheritanceNode(childName)\\n        \\n        # Then join parent with child (*b*)   \\n        parent = self.family[parentName]\\n        parent.children.append(self.family[childName])\\n        \\n        return\\n        \\n\\n    def death(self, name: str) -> None:\\n        # Make that person dead (*I*)\\n        if self.family[name]:\\n            self.family[name].alive = False\\n        return\\n        \\n\\n    def getInheritanceOrder(self) -> List[str]:\\n        \\n        order = []\\n        \\n        # This function is DFS in disguised, modified DFS\\n        def setOrder(stack: List, is_visited: Set):\\n            nonlocal order\\n            if stack:\\n                node = stack.pop()\\n                if node not in is_visited:\\n                    is_visited.add(node)\\n                    if node.alive: # add to order\\n                        order.append(node.name)\\n                    for adj_node in node.children[::-1]: # maintaines order\\n                        stack.append(adj_node)\\n                setOrder(stack, is_visited)\\n            return\\n        \\n        # Start from root\\n        setOrder([self.family[self.king]], set())\\n        \\n        return order\\n        \\n\\n\\n# Your ThroneInheritance object will be instantiated and called as such:\\n# obj = ThroneInheritance(kingName)\\n# obj.birth(parentName,childName)\\n# obj.death(name)\\n# param_3 = obj.getInheritanceOrder()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1387974,
                "title": "python-family-tree-dfs",
                "content": "```\\nclass TreeNode():\\n    def __init__(self, name):\\n        self.name = name\\n        self.children = []\\n        self.dead = False\\n        \\nclass ThroneInheritance(object):\\n    def __init__(self, kingName):\\n        \"\"\"\\n        :type kingName: str\\n        \"\"\"\\n        self.kingName = kingName\\n        self.familyTree = {kingName: TreeNode(kingName)}\\n        \\n\\n    def birth(self, parentName, childName):\\n        \"\"\"\\n        :type parentName: str\\n        :type childName: str\\n        :rtype: None\\n        \"\"\"\\n        if childName not in self.familyTree:\\n            self.familyTree[childName] = TreeNode(childName)\\n        self.familyTree[parentName].children.append(self.familyTree[childName])\\n\\n    def death(self, name):\\n        \"\"\"\\n        :type name: str\\n        :rtype: None\\n        \"\"\"\\n        self.familyTree[name].dead = True\\n\\n    def getInheritanceOrder(self):\\n        \"\"\"\\n        :rtype: List[str]\\n        \"\"\"\\n        order = []\\n        stack = [self.familyTree[self.kingName]]\\n        while stack:\\n            cur_node = stack.pop()\\n            if not cur_node.dead:\\n                order.append(cur_node.name)\\n            for child_node in cur_node.children[::-1]:\\n                stack.append(child_node)\\n        return order\\n\\n\\n# Your ThroneInheritance object will be instantiated and called as such:\\n# obj = ThroneInheritance(kingName)\\n# obj.birth(parentName,childName)\\n# obj.death(name)\\n# param_3 = obj.getInheritanceOrder()\\n```",
                "solutionTags": [
                    "Python",
                    "Depth-First Search"
                ],
                "code": "```\\nclass TreeNode():\\n    def __init__(self, name):\\n        self.name = name\\n        self.children = []\\n        self.dead = False\\n        \\nclass ThroneInheritance(object):\\n    def __init__(self, kingName):\\n        \"\"\"\\n        :type kingName: str\\n        \"\"\"\\n        self.kingName = kingName\\n        self.familyTree = {kingName: TreeNode(kingName)}\\n        \\n\\n    def birth(self, parentName, childName):\\n        \"\"\"\\n        :type parentName: str\\n        :type childName: str\\n        :rtype: None\\n        \"\"\"\\n        if childName not in self.familyTree:\\n            self.familyTree[childName] = TreeNode(childName)\\n        self.familyTree[parentName].children.append(self.familyTree[childName])\\n\\n    def death(self, name):\\n        \"\"\"\\n        :type name: str\\n        :rtype: None\\n        \"\"\"\\n        self.familyTree[name].dead = True\\n\\n    def getInheritanceOrder(self):\\n        \"\"\"\\n        :rtype: List[str]\\n        \"\"\"\\n        order = []\\n        stack = [self.familyTree[self.kingName]]\\n        while stack:\\n            cur_node = stack.pop()\\n            if not cur_node.dead:\\n                order.append(cur_node.name)\\n            for child_node in cur_node.children[::-1]:\\n                stack.append(child_node)\\n        return order\\n\\n\\n# Your ThroneInheritance object will be instantiated and called as such:\\n# obj = ThroneInheritance(kingName)\\n# obj.birth(parentName,childName)\\n# obj.death(name)\\n# param_3 = obj.getInheritanceOrder()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1354843,
                "title": "c-concise",
                "content": "```\\nstruct TrieNode {\\n    string name;\\n    vector<TrieNode*> kids;\\n    TrieNode(string name) {\\n        this->name = name;\\n    }\\n};\\n\\nclass ThroneInheritance {\\nprivate:\\n    TrieNode *root = NULL;\\n    unordered_map<string, TrieNode*> nodesMap;\\n    \\npublic:\\n    ThroneInheritance(string kingName) {\\n        root = new TrieNode(kingName);\\n        nodesMap[kingName] = root;\\n    }\\n    \\n    void birth(string parentName, string childName) {\\n        TrieNode* newChild = new TrieNode(childName);\\n        // cout << \"parentName: \" << parentName << \" childName: \" << childName << endl;\\n        nodesMap[parentName]->kids.push_back(newChild);\\n        nodesMap[childName] = newChild;\\n    }\\n    \\n    void death(string deadName) {\\n        // Mark the person as dead by \"-\"\\n        nodesMap[deadName]->name = \"-\";\\n    }\\n    \\n    vector<string> getInheritanceOrder() {\\n        vector<string> inheritanceOrder;\\n        dfs(root, inheritanceOrder);\\n        return inheritanceOrder;\\n    }\\n    \\n    void dfs(TrieNode *cur, vector<string> &order) {\\n        if (cur == NULL) {\\n            return;\\n        }\\n        if (cur->name != \"-\") {\\n            order.push_back(cur->name);\\n        }\\n        for (TrieNode* &kid : cur->kids) {\\n            dfs(kid, order);\\n        } \\n    }\\n};\\n\\n/**\\n * Your ThroneInheritance object will be instantiated and called as such:\\n * ThroneInheritance* obj = new ThroneInheritance(kingName);\\n * obj->birth(parentName,childName);\\n * obj->death(name);\\n * vector<string> param_3 = obj->getInheritanceOrder();\\n */\\n```",
                "solutionTags": [
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\nstruct TrieNode {\\n    string name;\\n    vector<TrieNode*> kids;\\n    TrieNode(string name) {\\n        this->name = name;\\n    }\\n};\\n\\nclass ThroneInheritance {\\nprivate:\\n    TrieNode *root = NULL;\\n    unordered_map<string, TrieNode*> nodesMap;\\n    \\npublic:\\n    ThroneInheritance(string kingName) {\\n        root = new TrieNode(kingName);\\n        nodesMap[kingName] = root;\\n    }\\n    \\n    void birth(string parentName, string childName) {\\n        TrieNode* newChild = new TrieNode(childName);\\n        // cout << \"parentName: \" << parentName << \" childName: \" << childName << endl;\\n        nodesMap[parentName]->kids.push_back(newChild);\\n        nodesMap[childName] = newChild;\\n    }\\n    \\n    void death(string deadName) {\\n        // Mark the person as dead by \"-\"\\n        nodesMap[deadName]->name = \"-\";\\n    }\\n    \\n    vector<string> getInheritanceOrder() {\\n        vector<string> inheritanceOrder;\\n        dfs(root, inheritanceOrder);\\n        return inheritanceOrder;\\n    }\\n    \\n    void dfs(TrieNode *cur, vector<string> &order) {\\n        if (cur == NULL) {\\n            return;\\n        }\\n        if (cur->name != \"-\") {\\n            order.push_back(cur->name);\\n        }\\n        for (TrieNode* &kid : cur->kids) {\\n            dfs(kid, order);\\n        } \\n    }\\n};\\n\\n/**\\n * Your ThroneInheritance object will be instantiated and called as such:\\n * ThroneInheritance* obj = new ThroneInheritance(kingName);\\n * obj->birth(parentName,childName);\\n * obj->death(name);\\n * vector<string> param_3 = obj->getInheritanceOrder();\\n */\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1326858,
                "title": "simple-c-solution-this-is-just-preorder-traversal-of-tree",
                "content": "```\\nclass ThroneInheritance {\\n    unordered_set<string> dead;\\n    unordered_map<string, vector<string>> children;\\n    string king;\\npublic:\\n    ThroneInheritance(string kingName) {\\n        king = kingName;\\n    }\\n    \\n    void birth(string parentName, string childName) {\\n        children[parentName].push_back(childName); \\n    }\\n    \\n    void death(string name) {\\n       dead.insert(name);\\n    }\\n    \\n    void dfs(string& s, vector<string>& v) {\\n        if(dead.find(s) == dead.end()) v.push_back(s);\\n        for(auto c : children[s]) dfs(c, v);\\n    }\\n    \\n    vector<string> getInheritanceOrder() {\\n       vector<string> v; \\n       dfs(king, v);\\n       return v;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass ThroneInheritance {\\n    unordered_set<string> dead;\\n    unordered_map<string, vector<string>> children;\\n    string king;\\npublic:\\n    ThroneInheritance(string kingName) {\\n        king = kingName;\\n    }\\n    \\n    void birth(string parentName, string childName) {\\n        children[parentName].push_back(childName); \\n    }\\n    \\n    void death(string name) {\\n       dead.insert(name);\\n    }\\n    \\n    void dfs(string& s, vector<string>& v) {\\n        if(dead.find(s) == dead.end()) v.push_back(s);\\n        for(auto c : children[s]) dfs(c, v);\\n    }\\n    \\n    vector<string> getInheritanceOrder() {\\n       vector<string> v; \\n       dfs(king, v);\\n       return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1271037,
                "title": "c-runtime-and-memory-beats-100-unordered-map-tree-and-unordered-map",
                "content": "class Node{\\npublic:\\n\\n    string val;\\n    Node*left,*right;\\n    Node(string val){\\n        this->val=val;\\n        left=right=nullptr;\\n    }\\n};\\n\\n\\nclass ThroneInheritance {\\npublic:\\n\\n    unordered_map<string,Node*> mapping;\\n    Node*root;\\n    string king;\\n    ThroneInheritance(string kingName) {\\n        root=new Node(kingName);\\n        mapping[kingName]=root;\\n        king=kingName;\\n    }\\n\\n    void birth(string parentName, string childName) {\\n        Node*n=new Node(childName);\\n        mapping[childName]=n;\\n        //if its the first born child of the parent then insert that child\\n        // on the left of that parent\\n        if(!mapping[parentName]->left){\\n            mapping[parentName]->left=n;\\n        }\\n        //if its not the first born child of the parent then insert that child\\n        //at the right most of the first child of that parent\\n        else{\\n            Node*temp=mapping[parentName]->left;\\n            while(temp->right){\\n                temp=temp->right;\\n            }\\n            temp->right=n;\\n        }\\n    }\\n    \\n    void death(string name) {\\n        mapping.erase(name);\\n    }\\n\\n    void preorder(Node*root,vector<string>&ans){\\n        if(!root) return;\\n        if(mapping[root->val]){\\n            ans.push_back(root->val);\\n        }\\n        preorder(root->left,ans);\\n        preorder(root->right,ans);\\n    }\\n\\n\\n    vector<string> getInheritanceOrder() {\\n        vector<string> ans;\\n        preorder(root,ans);\\n        return ans;\\n    }\\n};\\n",
                "solutionTags": [],
                "code": "class Node{\\npublic:\\n\\n    string val;\\n    Node*left,*right;\\n    Node(string val){\\n        this->val=val;\\n        left=right=nullptr;\\n    }\\n};\\n\\n\\nclass ThroneInheritance {\\npublic:\\n\\n    unordered_map<string,Node*> mapping;\\n    Node*root;\\n    string king;\\n    ThroneInheritance(string kingName) {\\n        root=new Node(kingName);\\n        mapping[kingName]=root;\\n        king=kingName;\\n    }\\n\\n    void birth(string parentName, string childName) {\\n        Node*n=new Node(childName);\\n        mapping[childName]=n;\\n        //if its the first born child of the parent then insert that child\\n        // on the left of that parent\\n        if(!mapping[parentName]->left){\\n            mapping[parentName]->left=n;\\n        }\\n        //if its not the first born child of the parent then insert that child\\n        //at the right most of the first child of that parent\\n        else{\\n            Node*temp=mapping[parentName]->left;\\n            while(temp->right){\\n                temp=temp->right;\\n            }\\n            temp->right=n;\\n        }\\n    }\\n    \\n    void death(string name) {\\n        mapping.erase(name);\\n    }\\n\\n    void preorder(Node*root,vector<string>&ans){\\n        if(!root) return;\\n        if(mapping[root->val]){\\n            ans.push_back(root->val);\\n        }\\n        preorder(root->left,ans);\\n        preorder(root->right,ans);\\n    }\\n\\n\\n    vector<string> getInheritanceOrder() {\\n        vector<string> ans;\\n        preorder(root,ans);\\n        return ans;\\n    }\\n};\\n",
                "codeTag": "Java"
            },
            {
                "id": 1238192,
                "title": "simple-solution-using-c",
                "content": "```\\nclass Person {\\npublic:\\n    string name;\\n    bool isAlive;\\n    vector <Person*> children;\\n    vector <Person*> successors;\\n    \\n    Person(string name): name(name), isAlive(true) {}\\n    \\n    void findSuccessors(Person *p) {\\n        if(p->isAlive)\\n            successors.push_back(p);\\n        \\n        for(Person *child : p->children) {\\n            findSuccessors(child);\\n        }\\n    }\\n};\\n\\nclass ThroneInheritance {\\nprivate:\\n    Person *king = NULL;\\n    map <string, Person*> familyMap;\\npublic:\\n    ThroneInheritance(string kingName) {\\n        king = new Person(kingName);\\n        \\n        familyMap[kingName] = king;\\n    }\\n    \\n    void birth(string parentName, string childName) {\\n        Person *child = new Person(childName);\\n        \\n        familyMap[childName] = child;\\n        familyMap[parentName]->children.push_back(child);\\n    }\\n    \\n    void death(string name) {\\n        familyMap[name]->isAlive = false;\\n    }\\n    \\n    vector<string> getInheritanceOrder() {\\n        vector <string> inheritanceOrder;\\n        king->successors = {};\\n        king->findSuccessors(king);\\n        \\n        for(Person *p : king->successors) {\\n            inheritanceOrder.push_back(p->name);\\n        }\\n        \\n        return inheritanceOrder;\\n    }\\n};\\n\\n/**\\n * Your ThroneInheritance object will be instantiated and called as such:\\n * ThroneInheritance* obj = new ThroneInheritance(kingName);\\n * obj->birth(parentName,childName);\\n * obj->death(name);\\n * vector<string> param_3 = obj->getInheritanceOrder();\\n */\\n ```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Person {\\npublic:\\n    string name;\\n    bool isAlive;\\n    vector <Person*> children;\\n    vector <Person*> successors;\\n    \\n    Person(string name): name(name), isAlive(true) {}\\n    \\n    void findSuccessors(Person *p) {\\n        if(p->isAlive)\\n            successors.push_back(p);\\n        \\n        for(Person *child : p->children) {\\n            findSuccessors(child);\\n        }\\n    }\\n};\\n\\nclass ThroneInheritance {\\nprivate:\\n    Person *king = NULL;\\n    map <string, Person*> familyMap;\\npublic:\\n    ThroneInheritance(string kingName) {\\n        king = new Person(kingName);\\n        \\n        familyMap[kingName] = king;\\n    }\\n    \\n    void birth(string parentName, string childName) {\\n        Person *child = new Person(childName);\\n        \\n        familyMap[childName] = child;\\n        familyMap[parentName]->children.push_back(child);\\n    }\\n    \\n    void death(string name) {\\n        familyMap[name]->isAlive = false;\\n    }\\n    \\n    vector<string> getInheritanceOrder() {\\n        vector <string> inheritanceOrder;\\n        king->successors = {};\\n        king->findSuccessors(king);\\n        \\n        for(Person *p : king->successors) {\\n            inheritanceOrder.push_back(p->name);\\n        }\\n        \\n        return inheritanceOrder;\\n    }\\n};\\n\\n/**\\n * Your ThroneInheritance object will be instantiated and called as such:\\n * ThroneInheritance* obj = new ThroneInheritance(kingName);\\n * obj->birth(parentName,childName);\\n * obj->death(name);\\n * vector<string> param_3 = obj->getInheritanceOrder();\\n */\\n ```",
                "codeTag": "Java"
            },
            {
                "id": 1221546,
                "title": "java-based-on-hints",
                "content": "```\\nclass ThroneInheritance {\\n    // node structure\\n    class TreeNode{\\n        String name;\\n        List<TreeNode> children;\\n        boolean isAlive;\\n        \\n        public TreeNode(String name){\\n            this.name = name;\\n            this.children = new ArrayList<TreeNode>();\\n            this.isAlive = true;\\n        }\\n        \\n        public void die(){\\n            this.isAlive = false;\\n        }\\n        \\n        public boolean isLiving(){\\n            return this.isAlive;\\n        }\\n        \\n        public List<TreeNode> getChildren(){\\n            return this.children;\\n        }\\n        \\n        public String getName(){\\n            return this.name;\\n        }\\n    }\\n    \\n    private TreeNode root;\\n    private HashMap<String, TreeNode> map;\\n    \\n    public ThroneInheritance(String kingName) {\\n        root = new TreeNode(kingName);\\n        map = new HashMap<String, TreeNode>();\\n        map.put(kingName, root);\\n    }\\n    \\n    public void birth(String parentName, String childName) {\\n        TreeNode node = map.get(parentName);\\n        TreeNode child = new TreeNode(childName);\\n        node.children.add(child);\\n        map.put(childName, child);\\n    }\\n    \\n    public void death(String name) {\\n        TreeNode node = map.get(name);\\n        node.die();\\n    }\\n    \\n    public List<String> getInheritanceOrder() {\\n        List<String> list = new ArrayList<String>();\\n        preorder(root, list);\\n        return list;\\n    }\\n    \\n    private void preorder(TreeNode node, List<String> list){\\n        if(node != null){\\n            if(node.isLiving()){\\n                list.add(node.getName());\\n            }\\n        \\n            for(TreeNode child : node.getChildren()){\\n                preorder(child, list);\\n            }    \\n        }\\n    }\\n}\\n\\n/**\\n * Your ThroneInheritance object will be instantiated and called as such:\\n * ThroneInheritance obj = new ThroneInheritance(kingName);\\n * obj.birth(parentName,childName);\\n * obj.death(name);\\n * List<String> param_3 = obj.getInheritanceOrder();\\n */\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass ThroneInheritance {\\n    // node structure\\n    class TreeNode{\\n        String name;\\n        List<TreeNode> children;\\n        boolean isAlive;\\n        \\n        public TreeNode(String name){\\n            this.name = name;\\n            this.children = new ArrayList<TreeNode>();\\n            this.isAlive = true;\\n        }\\n        \\n        public void die(){\\n            this.isAlive = false;\\n        }\\n        \\n        public boolean isLiving(){\\n            return this.isAlive;\\n        }\\n        \\n        public List<TreeNode> getChildren(){\\n            return this.children;\\n        }\\n        \\n        public String getName(){\\n            return this.name;\\n        }\\n    }\\n    \\n    private TreeNode root;\\n    private HashMap<String, TreeNode> map;\\n    \\n    public ThroneInheritance(String kingName) {\\n        root = new TreeNode(kingName);\\n        map = new HashMap<String, TreeNode>();\\n        map.put(kingName, root);\\n    }\\n    \\n    public void birth(String parentName, String childName) {\\n        TreeNode node = map.get(parentName);\\n        TreeNode child = new TreeNode(childName);\\n        node.children.add(child);\\n        map.put(childName, child);\\n    }\\n    \\n    public void death(String name) {\\n        TreeNode node = map.get(name);\\n        node.die();\\n    }\\n    \\n    public List<String> getInheritanceOrder() {\\n        List<String> list = new ArrayList<String>();\\n        preorder(root, list);\\n        return list;\\n    }\\n    \\n    private void preorder(TreeNode node, List<String> list){\\n        if(node != null){\\n            if(node.isLiving()){\\n                list.add(node.getName());\\n            }\\n        \\n            for(TreeNode child : node.getChildren()){\\n                preorder(child, list);\\n            }    \\n        }\\n    }\\n}\\n\\n/**\\n * Your ThroneInheritance object will be instantiated and called as such:\\n * ThroneInheritance obj = new ThroneInheritance(kingName);\\n * obj.birth(parentName,childName);\\n * obj.death(name);\\n * List<String> param_3 = obj.getInheritanceOrder();\\n */\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1217293,
                "title": "swift-solution-tree-pre-order-traversal",
                "content": "Swift solution (tree pre-order traversal)\\n```\\nclass Person {\\n    let name: String\\n    var children: [Person]\\n    var alive: Bool\\n    init (_ name: String) {\\n        self.name = name\\n        self.children = [Person]()\\n        self.alive = true\\n    }\\n}\\n\\nclass ThroneInheritance {\\n\\n    let king: Person\\n    var kingdom: [String: Person]\\n\\n    init(_ kingName: String) {\\n        self.king = Person(kingName)\\n        self.kingdom = [String: Person]()\\n        self.kingdom[kingName] = self.king\\n    }\\n    \\n    func birth(_ parentName: String, _ childName: String) {\\n        if let parentPerson = kingdom[parentName] {\\n            let childPerson = Person(childName)\\n            parentPerson.children.append(childPerson)\\n            kingdom[childName] = childPerson\\n        }\\n    }\\n    \\n    func death(_ name: String) {\\n        if let person = kingdom[name] { person.alive = false }\\n    }\\n    \\n    func getInheritanceOrder() -> [String] {\\n        var result = [String]()\\n        func getOrder(_ person: Person) {\\n            if person.alive { result.append(person.name) }\\n            for child in person.children { getOrder(child) }\\n        }\\n        getOrder(king)\\n        return result\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Person {\\n    let name: String\\n    var children: [Person]\\n    var alive: Bool\\n    init (_ name: String) {\\n        self.name = name\\n        self.children = [Person]()\\n        self.alive = true\\n    }\\n}\\n\\nclass ThroneInheritance {\\n\\n    let king: Person\\n    var kingdom: [String: Person]\\n\\n    init(_ kingName: String) {\\n        self.king = Person(kingName)\\n        self.kingdom = [String: Person]()\\n        self.kingdom[kingName] = self.king\\n    }\\n    \\n    func birth(_ parentName: String, _ childName: String) {\\n        if let parentPerson = kingdom[parentName] {\\n            let childPerson = Person(childName)\\n            parentPerson.children.append(childPerson)\\n            kingdom[childName] = childPerson\\n        }\\n    }\\n    \\n    func death(_ name: String) {\\n        if let person = kingdom[name] { person.alive = false }\\n    }\\n    \\n    func getInheritanceOrder() -> [String] {\\n        var result = [String]()\\n        func getOrder(_ person: Person) {\\n            if person.alive { result.append(person.name) }\\n            for child in person.children { getOrder(child) }\\n        }\\n        getOrder(king)\\n        return result\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1211583,
                "title": "simple-ruby-solution",
                "content": "```\\nclass ThroneInheritance\\n\\n=begin\\n    :type king_name: String\\n=end\\n    def initialize(king_name)\\n      @root = TreeNode.new(king_name)\\n      @persons = Hash.new\\n      @persons[king_name] = @root\\n    end\\n\\n\\n=begin\\n    :type parent_name: String\\n    :type child_name: String\\n    :rtype: Void\\n=end\\n    def birth(parent_name, child_name)\\n      @persons[child_name] = TreeNode.new(child_name)\\n      @persons[parent_name].children << @persons[child_name]\\n    end\\n\\n\\n=begin\\n    :type name: String\\n    :rtype: Void\\n=end\\n    def death(name)\\n      @persons[name].is_dead = true\\n    end\\n\\n\\n=begin\\n    :rtype: String[]\\n=end\\n    def get_inheritance_order()\\n      @result = []\\n      get_list(@root)\\n      @result\\n    end\\n\\n    def get_list(root)\\n      @result << root.val if !root.is_dead\\n      root.children.each do |c|\\n        get_list(c)\\n      end\\n      @result\\n    end\\nend\\n\\nclass TreeNode\\n  attr_accessor :val, :children, :is_dead \\n  def initialize(name)\\n    @val = name\\n    @children = []\\n    @is_dead = false\\n  end\\nend\\n\\n# Your ThroneInheritance object will be instantiated and called as such:\\n# obj = ThroneInheritance.new(king_name)\\n# obj.birth(parent_name, child_name)\\n# obj.death(name)\\n# param_3 = obj.get_inheritance_order()\\n```",
                "solutionTags": [],
                "code": "```\\nclass ThroneInheritance\\n\\n=begin\\n    :type king_name: String\\n=end\\n    def initialize(king_name)\\n      @root = TreeNode.new(king_name)\\n      @persons = Hash.new\\n      @persons[king_name] = @root\\n    end\\n\\n\\n=begin\\n    :type parent_name: String\\n    :type child_name: String\\n    :rtype: Void\\n=end\\n    def birth(parent_name, child_name)\\n      @persons[child_name] = TreeNode.new(child_name)\\n      @persons[parent_name].children << @persons[child_name]\\n    end\\n\\n\\n=begin\\n    :type name: String\\n    :rtype: Void\\n=end\\n    def death(name)\\n      @persons[name].is_dead = true\\n    end\\n\\n\\n=begin\\n    :rtype: String[]\\n=end\\n    def get_inheritance_order()\\n      @result = []\\n      get_list(@root)\\n      @result\\n    end\\n\\n    def get_list(root)\\n      @result << root.val if !root.is_dead\\n      root.children.each do |c|\\n        get_list(c)\\n      end\\n      @result\\n    end\\nend\\n\\nclass TreeNode\\n  attr_accessor :val, :children, :is_dead \\n  def initialize(name)\\n    @val = name\\n    @children = []\\n    @is_dead = false\\n  end\\nend\\n\\n# Your ThroneInheritance object will be instantiated and called as such:\\n# obj = ThroneInheritance.new(king_name)\\n# obj.birth(parent_name, child_name)\\n# obj.death(name)\\n# param_3 = obj.get_inheritance_order()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1172064,
                "title": "java-hashmap-m-ary-tree",
                "content": "```\\nclass ThroneInheritance {\\n\\n    Node root = null;\\n    HashMap<String, Node> map;\\n    public ThroneInheritance(String kingName) {\\n        root = new Node(kingName);\\n        map = new HashMap<>();\\n        map.put(kingName, root);\\n    }\\n    \\n    public void birth(String parentName, String childName) {\\n        Node parent = map.get(parentName);\\n        Node child = new Node(childName);\\n        map.put(childName, child);\\n        parent.children.add(child);\\n    }\\n    \\n    public void death(String name) {\\n        map.get(name).alive = false;\\n    }\\n    \\n    public List<String> getInheritanceOrder() {\\n        List<String> ans = new ArrayList<>();\\n        preorder(root, ans);\\n        return ans;\\n    }\\n\\n    private void preorder(Node node, List<String> list) {\\n        if(node.alive) list.add(node.name);\\n        for(Node child: node.children) preorder(child, list);\\n    }\\n\\n    private class Node {\\n        String name;\\n        boolean alive = true;\\n        List<Node> children = new ArrayList<>();\\n        Node(String _name) {name = _name;}\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass ThroneInheritance {\\n\\n    Node root = null;\\n    HashMap<String, Node> map;\\n    public ThroneInheritance(String kingName) {\\n        root = new Node(kingName);\\n        map = new HashMap<>();\\n        map.put(kingName, root);\\n    }\\n    \\n    public void birth(String parentName, String childName) {\\n        Node parent = map.get(parentName);\\n        Node child = new Node(childName);\\n        map.put(childName, child);\\n        parent.children.add(child);\\n    }\\n    \\n    public void death(String name) {\\n        map.get(name).alive = false;\\n    }\\n    \\n    public List<String> getInheritanceOrder() {\\n        List<String> ans = new ArrayList<>();\\n        preorder(root, ans);\\n        return ans;\\n    }\\n\\n    private void preorder(Node node, List<String> list) {\\n        if(node.alive) list.add(node.name);\\n        for(Node child: node.children) preorder(child, list);\\n    }\\n\\n    private class Node {\\n        String name;\\n        boolean alive = true;\\n        List<Node> children = new ArrayList<>();\\n        Node(String _name) {name = _name;}\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1171730,
                "title": "java-solution-tree-map",
                "content": "```\\nclass TreeNode {\\n    String val;\\n    List<TreeNode> children;\\n    \\n    TreeNode(String val){\\n        this.val = val;\\n        children = new ArrayList<>();\\n    }\\n}\\n\\nclass ThroneInheritance {\\n    TreeNode family;\\n    Map<String, TreeNode> map;\\n    Set<String> death;\\n    \\n    public ThroneInheritance(String kingName) {\\n        family = new TreeNode(kingName);\\n        map = new HashMap<>();\\n        death = new HashSet<>();\\n        map.put(kingName, family);\\n    }\\n    \\n    public void birth(String parentName, String childName) {\\n        TreeNode parent = map.get(parentName);\\n        TreeNode child = new TreeNode(childName);\\n        parent.children.add(child);\\n        map.put(childName, child);\\n    }\\n    \\n    public void death(String name) {\\n        death.add(name);\\n    }\\n    \\n    public List<String> getInheritanceOrder() {\\n        List<String> res = new ArrayList<String>();\\n        TreeNode root = family;\\n        helper(res, root);\\n        return res;\\n    }\\n    \\n    public void helper(List<String> res, TreeNode root){\\n        if(root == null){\\n            return;\\n        }\\n        if(!death.contains(root.val)){\\n            res.add(root.val);\\n        }\\n        for(TreeNode node : root.children){\\n            helper(res, node);\\n        }\\n    }\\n}\\n\\n/**\\n * Your ThroneInheritance object will be instantiated and called as such:\\n * ThroneInheritance obj = new ThroneInheritance(kingName);\\n * obj.birth(parentName,childName);\\n * obj.death(name);\\n * List<String> param_3 = obj.getInheritanceOrder();\\n */\\n\\n\\n//               king\\n//     andy      bob      catherine\\n// mattew    alex, asha",
                "solutionTags": [],
                "code": "```\\nclass TreeNode {\\n    String val;\\n    List<TreeNode> children;\\n    \\n    TreeNode(String val){\\n        this.val = val;\\n        children = new ArrayList<>();\\n    }\\n}\\n\\nclass ThroneInheritance {\\n    TreeNode family;\\n    Map<String, TreeNode> map;\\n    Set<String> death;\\n    \\n    public ThroneInheritance(String kingName) {\\n        family = new TreeNode(kingName);\\n        map = new HashMap<>();\\n        death = new HashSet<>();\\n        map.put(kingName, family);\\n    }\\n    \\n    public void birth(String parentName, String childName) {\\n        TreeNode parent = map.get(parentName);\\n        TreeNode child = new TreeNode(childName);\\n        parent.children.add(child);\\n        map.put(childName, child);\\n    }\\n    \\n    public void death(String name) {\\n        death.add(name);\\n    }\\n    \\n    public List<String> getInheritanceOrder() {\\n        List<String> res = new ArrayList<String>();\\n        TreeNode root = family;\\n        helper(res, root);\\n        return res;\\n    }\\n    \\n    public void helper(List<String> res, TreeNode root){\\n        if(root == null){\\n            return;\\n        }\\n        if(!death.contains(root.val)){\\n            res.add(root.val);\\n        }\\n        for(TreeNode node : root.children){\\n            helper(res, node);\\n        }\\n    }\\n}\\n\\n/**\\n * Your ThroneInheritance object will be instantiated and called as such:\\n * ThroneInheritance obj = new ThroneInheritance(kingName);\\n * obj.birth(parentName,childName);\\n * obj.death(name);\\n * List<String> param_3 = obj.getInheritanceOrder();\\n */\\n\\n\\n//               king\\n//     andy      bob      catherine\\n// mattew    alex, asha",
                "codeTag": "Java"
            },
            {
                "id": 1168254,
                "title": "c-solution-with-n-ary-tree",
                "content": "```\\n// Runtime: 436 ms, faster than 65.11% of C++ online submissions for Throne Inheritance.\\n// Memory Usage: 167.4 MB, less than 71.92% of C++ online submissions for Throne Inheritance.\\nstruct Successor {\\n    string name;\\n    vector<Successor*> children;\\n    Successor(string n) : name(n) {}\\n    Successor(string n, vector<Successor*> _children) : name(n) {\\n        children = _children;\\n    }\\n};\\n\\nclass ThroneInheritance {\\npublic:\\n    ThroneInheritance(string kingName) {\\n        king = new Successor(kingName);\\n        mSuccessor[kingName] = king;\\n    }\\n    \\n    void birth(string parentName, string childName) {\\n        Successor* child = new Successor(childName);\\n        mSuccessor[childName] = child;\\n        mSuccessor[parentName]->children.push_back(child);\\n    }\\n    \\n    void death(string name) {\\n        mSuccessor[name] = nullptr;\\n    }\\n    \\n    vector<string> getInheritanceOrder() {\\n        vector<string> res {};\\n        stack<Successor*> st;\\n        if (king) {\\n            st.push(king);\\n            while (!st.empty()) {\\n                auto cur = st.top();\\n                if (mSuccessor[cur->name])\\n                    res.push_back(cur->name);\\n                st.pop();\\n                for (int i = cur->children.size() - 1; i >= 0; i--) {\\n                    st.push(cur->children[i]);\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n\\nprivate:\\n    Successor* king;\\n    unordered_map<string, Successor*> mSuccessor;\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n// Runtime: 436 ms, faster than 65.11% of C++ online submissions for Throne Inheritance.\\n// Memory Usage: 167.4 MB, less than 71.92% of C++ online submissions for Throne Inheritance.\\nstruct Successor {\\n    string name;\\n    vector<Successor*> children;\\n    Successor(string n) : name(n) {}\\n    Successor(string n, vector<Successor*> _children) : name(n) {\\n        children = _children;\\n    }\\n};\\n\\nclass ThroneInheritance {\\npublic:\\n    ThroneInheritance(string kingName) {\\n        king = new Successor(kingName);\\n        mSuccessor[kingName] = king;\\n    }\\n    \\n    void birth(string parentName, string childName) {\\n        Successor* child = new Successor(childName);\\n        mSuccessor[childName] = child;\\n        mSuccessor[parentName]->children.push_back(child);\\n    }\\n    \\n    void death(string name) {\\n        mSuccessor[name] = nullptr;\\n    }\\n    \\n    vector<string> getInheritanceOrder() {\\n        vector<string> res {};\\n        stack<Successor*> st;\\n        if (king) {\\n            st.push(king);\\n            while (!st.empty()) {\\n                auto cur = st.top();\\n                if (mSuccessor[cur->name])\\n                    res.push_back(cur->name);\\n                st.pop();\\n                for (int i = cur->children.size() - 1; i >= 0; i--) {\\n                    st.push(cur->children[i]);\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n\\nprivate:\\n    Successor* king;\\n    unordered_map<string, Successor*> mSuccessor;\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1153956,
                "title": "easy-to-understand-c-solution",
                "content": "```\\nclass ThroneInheritance {\\nprivate:\\n    struct Node {\\n        string name;\\n        list<Node*> children;\\n        bool is_alive;\\n    };\\n    \\n    Node *king = NULL;\\n    unordered_map<string, Node*> mymap;\\n    \\n    void dfs (Node *node, vector<string>& res) {\\n        if (node->is_alive) {\\n            res.push_back(node->name);\\n        }\\n        \\n        auto l = node->children;\\n        \\n        for (auto iter = l.begin(); iter != l.end(); iter++) {\\n            dfs(*iter, res);\\n        }\\n    }\\n\\npublic:\\n    ThroneInheritance(string kingName) {\\n        king = new Node;\\n        king->name = kingName;\\n        king->is_alive =  true;\\n        mymap[kingName] = king;\\n    }\\n    \\n    void birth(string parentName, string childName) {\\n        Node* parent = mymap[parentName];\\n        Node* child = new Node;\\n        child->name = childName;\\n        child->is_alive = true;\\n        parent->children.push_back(child);\\n        mymap[childName] = child;\\n    }\\n    \\n    void death(string name) {\\n        Node *dead = mymap[name];\\n        dead->is_alive = false;\\n    }\\n    \\n    vector<string> getInheritanceOrder() {\\n        vector<string> res;\\n        dfs(king, res);\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass ThroneInheritance {\\nprivate:\\n    struct Node {\\n        string name;\\n        list<Node*> children;\\n        bool is_alive;\\n    };\\n    \\n    Node *king = NULL;\\n    unordered_map<string, Node*> mymap;\\n    \\n    void dfs (Node *node, vector<string>& res) {\\n        if (node->is_alive) {\\n            res.push_back(node->name);\\n        }\\n        \\n        auto l = node->children;\\n        \\n        for (auto iter = l.begin(); iter != l.end(); iter++) {\\n            dfs(*iter, res);\\n        }\\n    }\\n\\npublic:\\n    ThroneInheritance(string kingName) {\\n        king = new Node;\\n        king->name = kingName;\\n        king->is_alive =  true;\\n        mymap[kingName] = king;\\n    }\\n    \\n    void birth(string parentName, string childName) {\\n        Node* parent = mymap[parentName];\\n        Node* child = new Node;\\n        child->name = childName;\\n        child->is_alive = true;\\n        parent->children.push_back(child);\\n        mymap[childName] = child;\\n    }\\n    \\n    void death(string name) {\\n        Node *dead = mymap[name];\\n        dead->is_alive = false;\\n    }\\n    \\n    vector<string> getInheritanceOrder() {\\n        vector<string> res;\\n        dfs(king, res);\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1134151,
                "title": "very-easy-to-understand-simple-tree-like-apporach-tle-to-map",
                "content": "idea \\n1. create person class that has propery of \\n  1) dead\\n  2) children of List<Person>\\n2. recursive call until find person then add / remove \\n\\nBUT TLE , because everytime traverse tree-like data\\n\\nthought process to find optimal solution from hint in question\\n1. All arguments childName and kingName are distinct.\\n2. At most 10^5 calls will be made to birth and death.\\n\\nfinal thought\\nusing map store <NAME,PERSON> pair and update whenever operation called\\n\\n\\nfirst version of TLE\\n```\\n\\nclass Person{\\n        boolean dead;\\n        String name;\\n        List<Person> childs;\\n        public Person(String name){\\n            this.name=name;\\n            dead=false;\\n            childs=new ArrayList<>();\\n        }\\n    }\\n    \\n    Person root;\\n    \\n    public ThroneInheritance(String kingName) {\\n        root=new Person(kingName);\\n        \\n    }\\n    \\n    private Person find(Person p,String name){\\n        if(p.name.equals(name))\\n            return p;\\n        \\n        for(Person c:p.childs){\\n            if(c.name.equals(name))\\n                return c;\\n            \\n            Person f=find(c,name);\\n            if(f!=null)\\n                return f;\\n        }\\n        \\n        return null;\\n    }\\n    \\n    public void birth(String parentName, String childName) {\\n        Person p = find(root,parentName);\\n        if(p!=null)\\n            p.childs.add(new Person(childName));    \\n    }\\n    \\n    public void death(String name) {\\n        Person p = find(root,name);\\n        if(p!=null)\\n            p.dead=true;;        \\n    }\\n    \\n    public List<String> getInheritanceOrder() {        \\n        List<String> list=new ArrayList<>();       \\n        dfs(root,list);\\n        return list;   \\n    }\\n    \\n    private void dfs(Person curr,List<String> list){        \\n        if(!curr.dead)\\n            list.add(curr.name);\\n        \\n        for(Person c:curr.childs)\\n            dfs(c,list);\\n        \\n    }\\n\\t\\n```\\n\\n\\nfinal version using MAP\\n\\n```\\n\\nclass Person{\\n        boolean dead;\\n        String name;\\n        List<Person> childs;\\n        public Person(String name){\\n            this.name=name;\\n            dead=false;\\n            childs=new ArrayList<>();\\n        }\\n    }\\n    \\n    Person root;\\n    Map<String,Person> map = new HashMap<>();\\n    public ThroneInheritance(String kingName) {\\n        root=new Person(kingName);\\n        map.put(kingName,root);\\n    }\\n        \\n    public void birth(String parentName, String childName) {\\n        Person p = map.get(parentName);\\n        if(p!=null){\\n            Person c =new Person(childName);\\n            p.childs.add(c);    \\n            map.put(childName,c);\\n        }\\n    }\\n    \\n    public void death(String name) {\\n        Person p = map.get(name);\\n        if(p!=null)\\n            p.dead=true;     \\n    }\\n    \\n    public List<String> getInheritanceOrder() {        \\n        List<String> list=new ArrayList<>();       \\n        dfs(root,list);\\n        return list;   \\n    }\\n    \\n    private void dfs(Person curr,List<String> list){        \\n        if(!curr.dead)\\n            list.add(curr.name);\\n        \\n        for(Person c:curr.childs)\\n            dfs(c,list);\\n        \\n    }\\n\\t\\n\\n\\n```",
                "solutionTags": [],
                "code": "```\\n\\nclass Person{\\n        boolean dead;\\n        String name;\\n        List<Person> childs;\\n        public Person(String name){\\n            this.name=name;\\n            dead=false;\\n            childs=new ArrayList<>();\\n        }\\n    }\\n    \\n    Person root;\\n    \\n    public ThroneInheritance(String kingName) {\\n        root=new Person(kingName);\\n        \\n    }\\n    \\n    private Person find(Person p,String name){\\n        if(p.name.equals(name))\\n            return p;\\n        \\n        for(Person c:p.childs){\\n            if(c.name.equals(name))\\n                return c;\\n            \\n            Person f=find(c,name);\\n            if(f!=null)\\n                return f;\\n        }\\n        \\n        return null;\\n    }\\n    \\n    public void birth(String parentName, String childName) {\\n        Person p = find(root,parentName);\\n        if(p!=null)\\n            p.childs.add(new Person(childName));    \\n    }\\n    \\n    public void death(String name) {\\n        Person p = find(root,name);\\n        if(p!=null)\\n            p.dead=true;;        \\n    }\\n    \\n    public List<String> getInheritanceOrder() {        \\n        List<String> list=new ArrayList<>();       \\n        dfs(root,list);\\n        return list;   \\n    }\\n    \\n    private void dfs(Person curr,List<String> list){        \\n        if(!curr.dead)\\n            list.add(curr.name);\\n        \\n        for(Person c:curr.childs)\\n            dfs(c,list);\\n        \\n    }\\n\\t\\n```\n```\\n\\nclass Person{\\n        boolean dead;\\n        String name;\\n        List<Person> childs;\\n        public Person(String name){\\n            this.name=name;\\n            dead=false;\\n            childs=new ArrayList<>();\\n        }\\n    }\\n    \\n    Person root;\\n    Map<String,Person> map = new HashMap<>();\\n    public ThroneInheritance(String kingName) {\\n        root=new Person(kingName);\\n        map.put(kingName,root);\\n    }\\n        \\n    public void birth(String parentName, String childName) {\\n        Person p = map.get(parentName);\\n        if(p!=null){\\n            Person c =new Person(childName);\\n            p.childs.add(c);    \\n            map.put(childName,c);\\n        }\\n    }\\n    \\n    public void death(String name) {\\n        Person p = map.get(name);\\n        if(p!=null)\\n            p.dead=true;     \\n    }\\n    \\n    public List<String> getInheritanceOrder() {        \\n        List<String> list=new ArrayList<>();       \\n        dfs(root,list);\\n        return list;   \\n    }\\n    \\n    private void dfs(Person curr,List<String> list){        \\n        if(!curr.dead)\\n            list.add(curr.name);\\n        \\n        for(Person c:curr.childs)\\n            dfs(c,list);\\n        \\n    }\\n\\t\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1129510,
                "title": "intuitive-approach-by-use-dict-to-keep-family-tree-and-dict-to-keep-is-alive-status",
                "content": "```\\nfrom collections import defaultdict\\n\\nclass ThroneInheritance:\\n\\n    def __init__(self, kingName: str):\\n        self.kingName = kingName\\n        self.ft_dict = defaultdict(list) # Key as name; value as list of children\\n        self.is_alive = {kingName:True} # Key as name; value as is alive or not\\n\\n    def birth(self, parentName: str, childName: str) -> None:\\n        self.ft_dict[parentName].append(childName)\\n        self.is_alive[parentName] = self.is_alive[childName] = True\\n\\n    def death(self, name: str) -> None:\\n        self.is_alive[name] = False\\n\\n    def getInheritanceOrder(self) -> List[str]:\\n        inheritance_order = []\\n        inheritance_stack = [self.kingName]\\n        while inheritance_stack:\\n            name = inheritance_stack.pop()\\n            if self.is_alive[name]:\\n                inheritance_order.append(name)\\n                \\n            inheritance_stack.extend(self.ft_dict[name][::-1])\\n            \\n        return inheritance_order\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nfrom collections import defaultdict\\n\\nclass ThroneInheritance:\\n\\n    def __init__(self, kingName: str):\\n        self.kingName = kingName\\n        self.ft_dict = defaultdict(list) # Key as name; value as list of children\\n        self.is_alive = {kingName:True} # Key as name; value as is alive or not\\n\\n    def birth(self, parentName: str, childName: str) -> None:\\n        self.ft_dict[parentName].append(childName)\\n        self.is_alive[parentName] = self.is_alive[childName] = True\\n\\n    def death(self, name: str) -> None:\\n        self.is_alive[name] = False\\n\\n    def getInheritanceOrder(self) -> List[str]:\\n        inheritance_order = []\\n        inheritance_stack = [self.kingName]\\n        while inheritance_stack:\\n            name = inheritance_stack.pop()\\n            if self.is_alive[name]:\\n                inheritance_order.append(name)\\n                \\n            inheritance_stack.extend(self.ft_dict[name][::-1])\\n            \\n        return inheritance_order\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1129292,
                "title": "c-created-tree-m-ary-tree-used-hashmap-for-faster-retrieval-of-parent",
                "content": "```\\nclass ThroneInheritance {\\n    struct MemberNode\\n    {\\n        string name;\\n        bool isAlive;\\n        vector<MemberNode*> children;\\n        \\n        MemberNode(string nm)\\n        {\\n            name = nm;\\n            isAlive = true;\\n        }\\n    };\\n    \\n    MemberNode *root;\\n    \\npublic:\\n    unordered_map<string,MemberNode*> parent;\\n    \\n    ThroneInheritance(string kingName) {\\n        root = new MemberNode(kingName);\\n        parent.insert({kingName,root});\\n    }\\n    \\n    void birth(string parentName, string childName) {\\n       MemberNode* par= parent[parentName];\\n        MemberNode* child = new MemberNode(childName);\\n       par->children.push_back(child);\\n        parent.insert({childName,child});\\n    }\\n    \\n    void death(string name) {\\n        MemberNode* pr= parent[name];\\n        pr->isAlive = false;\\n    }\\n    \\n    void preOrder(MemberNode* root, vector<string> &out)\\n    {\\n        if(!root)\\n            return;\\n        if(root->isAlive)\\n            out.push_back(root->name);\\n        \\n        for(auto child:root->children)\\n        {\\n            preOrder(child, out);\\n        }\\n    }\\n    \\n    vector<string> getInheritanceOrder() {\\n        vector<string> output;\\n        preOrder(root,output);\\n        return output;\\n    }\\n};\\n\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass ThroneInheritance {\\n    struct MemberNode\\n    {\\n        string name;\\n        bool isAlive;\\n        vector<MemberNode*> children;\\n        \\n        MemberNode(string nm)\\n        {\\n            name = nm;\\n            isAlive = true;\\n        }\\n    };\\n    \\n    MemberNode *root;\\n    \\npublic:\\n    unordered_map<string,MemberNode*> parent;\\n    \\n    ThroneInheritance(string kingName) {\\n        root = new MemberNode(kingName);\\n        parent.insert({kingName,root});\\n    }\\n    \\n    void birth(string parentName, string childName) {\\n       MemberNode* par= parent[parentName];\\n        MemberNode* child = new MemberNode(childName);\\n       par->children.push_back(child);\\n        parent.insert({childName,child});\\n    }\\n    \\n    void death(string name) {\\n        MemberNode* pr= parent[name];\\n        pr->isAlive = false;\\n    }\\n    \\n    void preOrder(MemberNode* root, vector<string> &out)\\n    {\\n        if(!root)\\n            return;\\n        if(root->isAlive)\\n            out.push_back(root->name);\\n        \\n        for(auto child:root->children)\\n        {\\n            preOrder(child, out);\\n        }\\n    }\\n    \\n    vector<string> getInheritanceOrder() {\\n        vector<string> output;\\n        preOrder(root,output);\\n        return output;\\n    }\\n};\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1127586,
                "title": "c-inheritance-tree-and-unordered-map-solution-runtime-99-memory-100",
                "content": "```\\nclass ThroneInheritance {\\npublic:\\n    // Construct a family tree and populate on each birth.\\n    // Maintain a name->node index for faster lookup on birth/death.\\n    // On death, mark node as dead, but don\\'t remove them.\\n    // Return pre-order traversal of names to get inheritance order.\\n    \\n    // This method optimizes birth/death to be const time operations.\\n    struct Node {\\n        Node(string name): name(move(name)) {}\\n        Node() = default;\\n    \\n        string name;\\n        // Head and tail of children\\n        struct Node* chead = nullptr;\\n        struct Node* ctail = nullptr;\\n        \\n        // Next sibling.\\n        struct Node* snext = nullptr;\\n\\n        bool is_dead = false;\\n    };\\n    unordered_map<string, Node*> index_;\\n    Node* root_ = nullptr;\\n    \\n    // Number of live nodes. To reserve space for inheritance order vector.\\n    int live_nodes_ = 0;\\n\\n    ThroneInheritance(string kingName) {\\n        root_ = new Node(kingName);\\n        index_.emplace(move(kingName), root_);\\n        live_nodes_ = 1;\\n    }\\n    \\n    void birth(string parentName, string childName) {\\n        auto it = index_.find(parentName);\\n        assert(it != index_.end());\\n        auto parent = it->second;\\n        \\n        auto child = new Node(childName);\\n        index_.emplace(move(childName), child);\\n        live_nodes_++;\\n        \\n        if (parent->chead == nullptr) {\\n            parent->chead = parent->ctail = child;\\n        } else {\\n            parent->ctail->snext = child;\\n            parent->ctail = child;\\n        }\\n    }\\n    \\n    void death(string name) {\\n        auto it = index_.find(name);\\n        assert(it != index_.end());\\n        auto node = it->second;\\n        node->is_dead = true;\\n        live_nodes_--;\\n    }\\n    \\n    vector<string> getInheritanceOrder() {\\n        vector<string> res;\\n        if (!root_ || live_nodes_ == 0) return res;\\n\\n        res.reserve(live_nodes_);\\n        dfs(root_, res);\\n        return res;\\n    }\\n    \\n    void dfs(Node* root, vector<string>& res) {\\n        if (!root->is_dead) {\\n            res.push_back(root->name);\\n        }\\n        \\n        for (auto child = root->chead; child; child = child->snext) {\\n            dfs(child, res);\\n        }\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass ThroneInheritance {\\npublic:\\n    // Construct a family tree and populate on each birth.\\n    // Maintain a name->node index for faster lookup on birth/death.\\n    // On death, mark node as dead, but don\\'t remove them.\\n    // Return pre-order traversal of names to get inheritance order.\\n    \\n    // This method optimizes birth/death to be const time operations.\\n    struct Node {\\n        Node(string name): name(move(name)) {}\\n        Node() = default;\\n    \\n        string name;\\n        // Head and tail of children\\n        struct Node* chead = nullptr;\\n        struct Node* ctail = nullptr;\\n        \\n        // Next sibling.\\n        struct Node* snext = nullptr;\\n\\n        bool is_dead = false;\\n    };\\n    unordered_map<string, Node*> index_;\\n    Node* root_ = nullptr;\\n    \\n    // Number of live nodes. To reserve space for inheritance order vector.\\n    int live_nodes_ = 0;\\n\\n    ThroneInheritance(string kingName) {\\n        root_ = new Node(kingName);\\n        index_.emplace(move(kingName), root_);\\n        live_nodes_ = 1;\\n    }\\n    \\n    void birth(string parentName, string childName) {\\n        auto it = index_.find(parentName);\\n        assert(it != index_.end());\\n        auto parent = it->second;\\n        \\n        auto child = new Node(childName);\\n        index_.emplace(move(childName), child);\\n        live_nodes_++;\\n        \\n        if (parent->chead == nullptr) {\\n            parent->chead = parent->ctail = child;\\n        } else {\\n            parent->ctail->snext = child;\\n            parent->ctail = child;\\n        }\\n    }\\n    \\n    void death(string name) {\\n        auto it = index_.find(name);\\n        assert(it != index_.end());\\n        auto node = it->second;\\n        node->is_dead = true;\\n        live_nodes_--;\\n    }\\n    \\n    vector<string> getInheritanceOrder() {\\n        vector<string> res;\\n        if (!root_ || live_nodes_ == 0) return res;\\n\\n        res.reserve(live_nodes_);\\n        dfs(root_, res);\\n        return res;\\n    }\\n    \\n    void dfs(Node* root, vector<string>& res) {\\n        if (!root->is_dead) {\\n            res.push_back(root->name);\\n        }\\n        \\n        for (auto child = root->chead; child; child = child->snext) {\\n            dfs(child, res);\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1124249,
                "title": "c-map-dfs",
                "content": "```\\nclass ThroneInheritance {\\npublic:\\n    ThroneInheritance(string kingName) {\\n        king_name = kingName;\\n        succession[kingName] = {};\\n    }\\n    \\n    void birth(string parentName, string childName) {\\n        succession[parentName].push_back(childName);\\n    }\\n    \\n    void death(string name) {\\n        dead_people.insert(name);\\n    }\\n    \\n    vector<string> getInheritanceOrder() {\\n        vector<string> order;\\n        \\n        dfs(order, succession, king_name);\\n        \\n        return order;\\n    }\\n    \\n    void dfs(vector<string>& order, unordered_map<string, vector<string>>& succession, string curr_name) {\\n        if (dead_people.find(curr_name) == dead_people.end()) order.push_back(curr_name);\\n        \\n        for (string children : succession[curr_name]) {\\n            dfs(order, succession, children);\\n        }        \\n    }\\n    \\nprivate:\\n    string king_name;\\n    unordered_set<string> dead_people;\\n    unordered_map<string, vector<string>> succession;    \\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass ThroneInheritance {\\npublic:\\n    ThroneInheritance(string kingName) {\\n        king_name = kingName;\\n        succession[kingName] = {};\\n    }\\n    \\n    void birth(string parentName, string childName) {\\n        succession[parentName].push_back(childName);\\n    }\\n    \\n    void death(string name) {\\n        dead_people.insert(name);\\n    }\\n    \\n    vector<string> getInheritanceOrder() {\\n        vector<string> order;\\n        \\n        dfs(order, succession, king_name);\\n        \\n        return order;\\n    }\\n    \\n    void dfs(vector<string>& order, unordered_map<string, vector<string>>& succession, string curr_name) {\\n        if (dead_people.find(curr_name) == dead_people.end()) order.push_back(curr_name);\\n        \\n        for (string children : succession[curr_name]) {\\n            dfs(order, succession, children);\\n        }        \\n    }\\n    \\nprivate:\\n    string king_name;\\n    unordered_set<string> dead_people;\\n    unordered_map<string, vector<string>> succession;    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1112562,
                "title": "could-you-please-identify-the-errors-in-my-codes",
                "content": "When I run in vscode , it\\'s perfectly fine (I think) but when I run in leetcode, it return wrong answer compared to running on vscode\\n\\n```\\nimport java.util.ArrayList;\\nimport java.util.List;\\n\\nclass Person {\\n\\n    String name = \"\";\\n    String status = \"alive\";\\n    List<Person> children = new ArrayList<Person>();\\n\\n    public Person(String name) {\\n        this.name = name;\\n    }\\n\\n}\\n\\nclass ThroneInheritance {\\n\\n    Person daKing;\\n\\n    public ThroneInheritance(String kingName) {\\n        daKing = new Person(kingName);\\n    }\\n\\n    public Person findName(Person order, String find) {\\n        // base case\\n        if (order.name == find) {\\n            return order;\\n        }\\n\\n        for (Person child : order.children) {\\n            Person result = findName(child, find);\\n            if (result != null) {\\n                return result;\\n            }\\n        }\\n\\n        return null;\\n    }\\n\\n    public List<String> Successor(List<String> family, Person order) {\\n\\n        if (order.status == \"alive\") {\\n            family.add(order.name);\\n        }\\n\\n        for (Person child : order.children) {\\n            Successor(family, child);\\n        }\\n\\n        return family;\\n    }\\n\\n    public void birth(String parentName, String childName) {\\n        // recur until found his name\\n        // add childname into children\\n        Person parent = findName(daKing, parentName);\\n        Person child = new Person(childName);\\n        if (parent != null) {\\n            parent.children.add(child);\\n        }\\n    }\\n\\n    public void death(String name) {\\n        Person unLucky = findName(daKing, name);\\n        unLucky.status = \"deadth\";\\n    }\\n\\n    public List<String> getInheritanceOrder() {\\n        List<String> result = new ArrayList<String>();\\n        result = Successor(result, this.daKing);\\n        return result;\\n    }\\n}\\n\\nclass Tester2 {\\n\\n    public static void main(String[] args) {\\n\\n        ThroneInheritance t = new ThroneInheritance(\"king\"); // order: king\\n        t.birth(\"king\", \"andy\"); // order: king > andy\\n        t.birth(\"king\", \"bob\"); // order: king > andy > bob\\n        t.birth(\"king\", \"catherine\"); // order: king > andy > bob > catherine\\n        t.birth(\"andy\", \"matthew\"); // order: king > andy > matthew > bob > catherine\\n        t.birth(\"bob\", \"alex\"); // order: king > andy > matthew > bob > alex > catherine\\n        t.birth(\"bob\", \"asha\"); // order: king > andy > matthew > bob > alex > asha > catherine\\n        System.out.println(t.getInheritanceOrder()); // return [\"king\", \"andy\", \"matthew\", \"bob\", \"alex\", \"asha\",\\n                                                     // \"catherine\"]\\n        t.death(\"bob\"); // order: king > andy > matthew > bob > alex > asha > catherine\\n        System.out.println(t.getInheritanceOrder()); // return [\"king\", \"andy\", \"matthew\", \"alex\", \"asha\", \"catherine\"]\\n    }\\n}\\n\\n/**\\n * Your ThroneInheritance object will be instantiated and called as such:\\n * ThroneInheritance obj = new ThroneInheritance(kingName);\\n * obj.birth(parentName,childName); obj.death(name); List<String> param_3 =\\n * obj.getInheritanceOrder();\\n */\\n```",
                "solutionTags": [],
                "code": "```\\nimport java.util.ArrayList;\\nimport java.util.List;\\n\\nclass Person {\\n\\n    String name = \"\";\\n    String status = \"alive\";\\n    List<Person> children = new ArrayList<Person>();\\n\\n    public Person(String name) {\\n        this.name = name;\\n    }\\n\\n}\\n\\nclass ThroneInheritance {\\n\\n    Person daKing;\\n\\n    public ThroneInheritance(String kingName) {\\n        daKing = new Person(kingName);\\n    }\\n\\n    public Person findName(Person order, String find) {\\n        // base case\\n        if (order.name == find) {\\n            return order;\\n        }\\n\\n        for (Person child : order.children) {\\n            Person result = findName(child, find);\\n            if (result != null) {\\n                return result;\\n            }\\n        }\\n\\n        return null;\\n    }\\n\\n    public List<String> Successor(List<String> family, Person order) {\\n\\n        if (order.status == \"alive\") {\\n            family.add(order.name);\\n        }\\n\\n        for (Person child : order.children) {\\n            Successor(family, child);\\n        }\\n\\n        return family;\\n    }\\n\\n    public void birth(String parentName, String childName) {\\n        // recur until found his name\\n        // add childname into children\\n        Person parent = findName(daKing, parentName);\\n        Person child = new Person(childName);\\n        if (parent != null) {\\n            parent.children.add(child);\\n        }\\n    }\\n\\n    public void death(String name) {\\n        Person unLucky = findName(daKing, name);\\n        unLucky.status = \"deadth\";\\n    }\\n\\n    public List<String> getInheritanceOrder() {\\n        List<String> result = new ArrayList<String>();\\n        result = Successor(result, this.daKing);\\n        return result;\\n    }\\n}\\n\\nclass Tester2 {\\n\\n    public static void main(String[] args) {\\n\\n        ThroneInheritance t = new ThroneInheritance(\"king\"); // order: king\\n        t.birth(\"king\", \"andy\"); // order: king > andy\\n        t.birth(\"king\", \"bob\"); // order: king > andy > bob\\n        t.birth(\"king\", \"catherine\"); // order: king > andy > bob > catherine\\n        t.birth(\"andy\", \"matthew\"); // order: king > andy > matthew > bob > catherine\\n        t.birth(\"bob\", \"alex\"); // order: king > andy > matthew > bob > alex > catherine\\n        t.birth(\"bob\", \"asha\"); // order: king > andy > matthew > bob > alex > asha > catherine\\n        System.out.println(t.getInheritanceOrder()); // return [\"king\", \"andy\", \"matthew\", \"bob\", \"alex\", \"asha\",\\n                                                     // \"catherine\"]\\n        t.death(\"bob\"); // order: king > andy > matthew > bob > alex > asha > catherine\\n        System.out.println(t.getInheritanceOrder()); // return [\"king\", \"andy\", \"matthew\", \"alex\", \"asha\", \"catherine\"]\\n    }\\n}\\n\\n/**\\n * Your ThroneInheritance object will be instantiated and called as such:\\n * ThroneInheritance obj = new ThroneInheritance(kingName);\\n * obj.birth(parentName,childName); obj.death(name); List<String> param_3 =\\n * obj.getInheritanceOrder();\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1088917,
                "title": "c-dfs",
                "content": "The fact that getInheritanceOrder is invoked much less than birth and death makes me think about this data structure.\\nbirth & death are O(1)\\n\\n```\\nclass ThroneInheritance {\\n    string _king;\\n    unordered_map<string, vector<string>> mp; // parent -> children\\n    unordered_map<string, bool> alive; \\npublic:\\n    ThroneInheritance(string kingName) {\\n        _king = kingName;\\n        alive[kingName] = true;\\n    }\\n    \\n    void birth(string parentName, string childName) {\\n        mp[parentName].push_back(childName);\\n        alive[childName] = true;\\n    }\\n    \\n    void death(string name) {\\n        alive[name] = false;\\n    }\\n    \\n    vector<string> getInheritanceOrder() {\\n        vector<string> ans;\\n        \\n        stack<string> st;\\n        st.push(_king);\\n        \\n        while(!st.empty()) {\\n            auto parent = st.top();\\n            st.pop();\\n            if(alive[parent]) ans.push_back(parent);\\n            for(auto it = mp[parent].rbegin(); it != mp[parent].rend(); ++it) {\\n                st.push(*it);\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n\\n/**\\n * Your ThroneInheritance object will be instantiated and called as such:\\n * ThroneInheritance* obj = new ThroneInheritance(kingName);\\n * obj->birth(parentName,childName);\\n * obj->death(name);\\n * vector<string> param_3 = obj->getInheritanceOrder();\\n */\\n```",
                "solutionTags": [],
                "code": "```\\nclass ThroneInheritance {\\n    string _king;\\n    unordered_map<string, vector<string>> mp; // parent -> children\\n    unordered_map<string, bool> alive; \\npublic:\\n    ThroneInheritance(string kingName) {\\n        _king = kingName;\\n        alive[kingName] = true;\\n    }\\n    \\n    void birth(string parentName, string childName) {\\n        mp[parentName].push_back(childName);\\n        alive[childName] = true;\\n    }\\n    \\n    void death(string name) {\\n        alive[name] = false;\\n    }\\n    \\n    vector<string> getInheritanceOrder() {\\n        vector<string> ans;\\n        \\n        stack<string> st;\\n        st.push(_king);\\n        \\n        while(!st.empty()) {\\n            auto parent = st.top();\\n            st.pop();\\n            if(alive[parent]) ans.push_back(parent);\\n            for(auto it = mp[parent].rbegin(); it != mp[parent].rend(); ++it) {\\n                st.push(*it);\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n\\n/**\\n * Your ThroneInheritance object will be instantiated and called as such:\\n * ThroneInheritance* obj = new ThroneInheritance(kingName);\\n * obj->birth(parentName,childName);\\n * obj->death(name);\\n * vector<string> param_3 = obj->getInheritanceOrder();\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1078251,
                "title": "java-o-n-dfs-99-faster",
                "content": "The solution is pretty simple. we need HashMap to store children for each father. and HashSet to store dead people.\\nalso ArrayList will keep it sorted for us ;)\\n\\n```java\\nclass ThroneInheritance {\\n\\n    HashMap<String, List<String>> map;\\n    Set<String> death;\\n    String King;\\n    \\n    public ThroneInheritance(String kingName) {\\n        map = new HashMap<>();\\n        death = new HashSet<>();\\n        \\n        map.put(kingName, new ArrayList());\\n        \\n        King = kingName;\\n    }\\n    \\n    public void birth(String parentName, String childName) {\\n        List<String> list = map.getOrDefault(parentName, new ArrayList());\\n        list.add(childName);\\n        \\n        map.put(parentName, list);\\n    }\\n    \\n    public void death(String name) {\\n        death.add(name);\\n    }\\n    \\n    public List<String> getInheritanceOrder() {\\n        List<String> ans = new ArrayList();\\n        getFor(King, ans);\\n        \\n        return ans;\\n    }\\n    \\n    private void getFor(String n, List<String> ans) {\\n\\t\\t// if dead. then let\\'s not insert his name in the list\\n\\t\\tif(!death.contains(n)) {\\n            ans.add(n);\\n        }\\n        \\n        if(!map.containsKey(n)) return;\\n\\n\\t\\t// get children names and insert them too\\n        for(String child: map.get(n))\\n            getFor(child, ans);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```java\\nclass ThroneInheritance {\\n\\n    HashMap<String, List<String>> map;\\n    Set<String> death;\\n    String King;\\n    \\n    public ThroneInheritance(String kingName) {\\n        map = new HashMap<>();\\n        death = new HashSet<>();\\n        \\n        map.put(kingName, new ArrayList());\\n        \\n        King = kingName;\\n    }\\n    \\n    public void birth(String parentName, String childName) {\\n        List<String> list = map.getOrDefault(parentName, new ArrayList());\\n        list.add(childName);\\n        \\n        map.put(parentName, list);\\n    }\\n    \\n    public void death(String name) {\\n        death.add(name);\\n    }\\n    \\n    public List<String> getInheritanceOrder() {\\n        List<String> ans = new ArrayList();\\n        getFor(King, ans);\\n        \\n        return ans;\\n    }\\n    \\n    private void getFor(String n, List<String> ans) {\\n\\t\\t// if dead. then let\\'s not insert his name in the list\\n\\t\\tif(!death.contains(n)) {\\n            ans.add(n);\\n        }\\n        \\n        if(!map.containsKey(n)) return;\\n\\n\\t\\t// get children names and insert them too\\n        for(String child: map.get(n))\\n            getFor(child, ans);\\n    }\\n}\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1565302,
                "content": [
                    {
                        "username": "kaiwensun",
                        "content": "I first thought the **title of king is inherited** along with the throne. Once a king dies, the next alive successor **becomes the new king**. Since the `Successor` function includes a logic `if x is the king return null`, only the current king or its offsprings may have oppornutity to become the king in the future.\\n\\nIn other words, I thought the tree root could die, and the new king will be the new root of its offsprings, and we can ignore other nodes out of this subtree in the future.\\n\\nI did realize a medium level question could be as simple as pre-order traversal.\\n(of course, the pre-order traversal can be optimized by triming deads, eg. cut off subtrees containing all dead people. In extreme optimization, it would become insertion to and removal from a linked list with the help from a name-to-node hashmap.)"
                    },
                    {
                        "username": "fuckleeetcode",
                        "content": "Why is Alice a King? Her Majesty is the Queen!"
                    },
                    {
                        "username": "wangchenmeng09",
                        "content": "I was about to give it my best and test my metal against it until I realized it was just a fancy way to say pre-order traversal of a tree."
                    },
                    {
                        "username": "H4CE",
                        "content": "Why dislikes more than like?? Imho it is a great question."
                    }
                ]
            },
            {
                "id": 1566363,
                "content": [
                    {
                        "username": "kaiwensun",
                        "content": "I first thought the **title of king is inherited** along with the throne. Once a king dies, the next alive successor **becomes the new king**. Since the `Successor` function includes a logic `if x is the king return null`, only the current king or its offsprings may have oppornutity to become the king in the future.\\n\\nIn other words, I thought the tree root could die, and the new king will be the new root of its offsprings, and we can ignore other nodes out of this subtree in the future.\\n\\nI did realize a medium level question could be as simple as pre-order traversal.\\n(of course, the pre-order traversal can be optimized by triming deads, eg. cut off subtrees containing all dead people. In extreme optimization, it would become insertion to and removal from a linked list with the help from a name-to-node hashmap.)"
                    },
                    {
                        "username": "fuckleeetcode",
                        "content": "Why is Alice a King? Her Majesty is the Queen!"
                    },
                    {
                        "username": "wangchenmeng09",
                        "content": "I was about to give it my best and test my metal against it until I realized it was just a fancy way to say pre-order traversal of a tree."
                    },
                    {
                        "username": "H4CE",
                        "content": "Why dislikes more than like?? Imho it is a great question."
                    }
                ]
            },
            {
                "id": 2036720,
                "content": [
                    {
                        "username": "kaiwensun",
                        "content": "I first thought the **title of king is inherited** along with the throne. Once a king dies, the next alive successor **becomes the new king**. Since the `Successor` function includes a logic `if x is the king return null`, only the current king or its offsprings may have oppornutity to become the king in the future.\\n\\nIn other words, I thought the tree root could die, and the new king will be the new root of its offsprings, and we can ignore other nodes out of this subtree in the future.\\n\\nI did realize a medium level question could be as simple as pre-order traversal.\\n(of course, the pre-order traversal can be optimized by triming deads, eg. cut off subtrees containing all dead people. In extreme optimization, it would become insertion to and removal from a linked list with the help from a name-to-node hashmap.)"
                    },
                    {
                        "username": "fuckleeetcode",
                        "content": "Why is Alice a King? Her Majesty is the Queen!"
                    },
                    {
                        "username": "wangchenmeng09",
                        "content": "I was about to give it my best and test my metal against it until I realized it was just a fancy way to say pre-order traversal of a tree."
                    },
                    {
                        "username": "H4CE",
                        "content": "Why dislikes more than like?? Imho it is a great question."
                    }
                ]
            },
            {
                "id": 2033599,
                "content": [
                    {
                        "username": "kaiwensun",
                        "content": "I first thought the **title of king is inherited** along with the throne. Once a king dies, the next alive successor **becomes the new king**. Since the `Successor` function includes a logic `if x is the king return null`, only the current king or its offsprings may have oppornutity to become the king in the future.\\n\\nIn other words, I thought the tree root could die, and the new king will be the new root of its offsprings, and we can ignore other nodes out of this subtree in the future.\\n\\nI did realize a medium level question could be as simple as pre-order traversal.\\n(of course, the pre-order traversal can be optimized by triming deads, eg. cut off subtrees containing all dead people. In extreme optimization, it would become insertion to and removal from a linked list with the help from a name-to-node hashmap.)"
                    },
                    {
                        "username": "fuckleeetcode",
                        "content": "Why is Alice a King? Her Majesty is the Queen!"
                    },
                    {
                        "username": "wangchenmeng09",
                        "content": "I was about to give it my best and test my metal against it until I realized it was just a fancy way to say pre-order traversal of a tree."
                    },
                    {
                        "username": "H4CE",
                        "content": "Why dislikes more than like?? Imho it is a great question."
                    }
                ]
            }
        ]
    },
    {
        "title": "Maximum Number of Achievable Transfer Requests",
        "question_content": "<p>We have <code>n</code> buildings numbered from <code>0</code> to <code>n - 1</code>. Each building has a number of employees. It&#39;s transfer season, and some employees want to change the building they reside in.</p>\n\n<p>You are given an array <code>requests</code> where <code>requests[i] = [from<sub>i</sub>, to<sub>i</sub>]</code> represents an employee&#39;s request to transfer from building <code>from<sub>i</sub></code> to building <code>to<sub>i</sub></code>.</p>\n\n<p><strong>All buildings are full</strong>, so a list of requests is achievable only if for each building, the <strong>net change in employee transfers is zero</strong>. This means the number of employees <strong>leaving</strong> is <strong>equal</strong> to the number of employees <strong>moving in</strong>. For example if <code>n = 3</code> and two employees are leaving building <code>0</code>, one is leaving building <code>1</code>, and one is leaving building <code>2</code>, there should be two employees moving to building <code>0</code>, one employee moving to building <code>1</code>, and one employee moving to building <code>2</code>.</p>\n\n<p>Return <em>the maximum number of achievable requests</em>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/09/10/move1.jpg\" style=\"width: 600px; height: 406px;\" />\n<pre>\n<strong>Input:</strong> n = 5, requests = [[0,1],[1,0],[0,1],[1,2],[2,0],[3,4]]\n<strong>Output:</strong> 5\n<strong>Explantion:</strong> Let&#39;s see the requests:\nFrom building 0 we have employees x and y and both want to move to building 1.\nFrom building 1 we have employees a and b and they want to move to buildings 2 and 0 respectively.\nFrom building 2 we have employee z and they want to move to building 0.\nFrom building 3 we have employee c and they want to move to building 4.\nFrom building 4 we don&#39;t have any requests.\nWe can achieve the requests of users x and b by swapping their places.\nWe can achieve the requests of users y, a and z by swapping the places in the 3 buildings.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/09/10/move2.jpg\" style=\"width: 450px; height: 327px;\" />\n<pre>\n<strong>Input:</strong> n = 3, requests = [[0,0],[1,2],[2,1]]\n<strong>Output:</strong> 3\n<strong>Explantion:</strong> Let&#39;s see the requests:\nFrom building 0 we have employee x and they want to stay in the same building 0.\nFrom building 1 we have employee y and they want to move to building 2.\nFrom building 2 we have employee z and they want to move to building 1.\nWe can achieve all the requests. </pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> n = 4, requests = [[0,3],[3,1],[1,2],[2,0]]\n<strong>Output:</strong> 4\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 20</code></li>\n\t<li><code>1 &lt;= requests.length &lt;= 16</code></li>\n\t<li><code>requests[i].length == 2</code></li>\n\t<li><code>0 &lt;= from<sub>i</sub>, to<sub>i</sub> &lt; n</code></li>\n</ul>\n",
        "solutions": [
            {
                "id": 3706092,
                "title": "back-track-c-java-python-beginner-friendly",
                "content": "# Intuition:\\n\\nThe Intuition is to use backtracking approach to explore all possible combinations of taking or not taking transfer requests. It maintains a count of transfer requests and checks if the requests are balanced for each building. The maximum count of transfer requests that satisfies the balanced request condition is returned as the result.\\n\\n# Explanation:\\n\\n1. The `maximumRequests` function takes an integer `n` representing the number of buildings and a 2D vector `requests` containing the transfer requests.\\n2. The function initializes a vector `indegree` of size `n` to keep track of the difference between incoming and outgoing requests for each building. Initially, all values are set to 0.\\n3. The function then calls the `helper` function with the starting index as 0, the `requests` vector, the `indegree` vector, `n`, and a count variable set to 0.\\n4. The `helper` function is the main backtracking function. It takes the current `start` index, the `requests` vector, the `indegree` vector, `n`, and the current `count` of transfer requests.\\n5. If the `start` index is equal to the size of the `requests` vector, it means we have processed all transfer requests. In this case, the function checks if all buildings have balanced requests (i.e., `indegree` values are all 0). If so, it updates the `ans` variable with the maximum count of transfer requests.\\n6. If the `start` index is not equal to the size of the `requests` vector, the function has two choices: take or not take the current transfer request.\\n7. If we take the current transfer request, we reduce the `indegree` value of the source building (`requests[start][0]`) by 1 and increase the `indegree` value of the destination building (`requests[start][1]`) by 1. Then, we recursively call the `helper` function with the updated `start` index, `requests`, `indegree`, `n`, and the incremented `count` by 1.\\n8. After the recursive call, we revert the changes made in step 7 by increasing the `indegree` value of the source building and decreasing the `indegree` value of the destination building. This step represents the \"not-take\" choice. We then recursively call the `helper` function with the updated `start` index, `requests`, `indegree`, `n`, and the same `count` value.\\n9. The `helper` function explores all possible combinations of taking or not taking transfer requests, tracking the maximum count of transfer requests (`ans`) that satisfies the balanced request condition.\\n10. Finally, the `maximumRequests` function returns the maximum count of transfer requests stored in the `ans` variable.\\n\\n# Complexity:\\n**Time complexity:** $$ O(2^M * N) $$\\n**Space complexity:** $$ O(N + M) $$\\nN is the number of buildings, and M is the number of requests.\\n\\n# Code\\n```C++ []\\nclass Solution {\\npublic:\\n    int ans = 0;\\n\\n    void helper(int start, vector<vector<int>>& requests, vector<int>& indegree, int n, int count) {\\n        if (start == requests.size()) {\\n            for (int i = 0; i < n; i++) {\\n                if (indegree[i] != 0) {\\n                    return;\\n                }\\n            }\\n            ans = max(ans, count);\\n            return;\\n        }\\n\\n        // Take \\n        indegree[requests[start][0]]--;\\n        indegree[requests[start][1]]++;\\n        helper(start + 1,requests, indegree, n, count + 1);\\n\\n        // Not-take\\n        indegree[requests[start][0]]++;\\n        indegree[requests[start][1]]--;\\n        helper(start + 1,requests, indegree, n, count);\\n    }\\n    \\n    int maximumRequests(int n, vector<vector<int>>& requests) {\\n        vector<int> indegree(n, 0);\\n        helper(0, requests, indegree, n, 0);\\n        return ans;\\n    }\\n};\\n```\\n```Java []\\nclass Solution {\\n    public int maximumRequests(int n, int[][] requests) {\\n        int[] indegree = new int[n];\\n        return helper(0, requests, indegree, n, 0);\\n    }\\n\\n    public int helper(int start, int[][] requests, int[] indegree, int n, int count) {\\n        if (start == requests.length) {\\n            for (int i = 0; i < n; i++) {\\n                if (indegree[i] != 0) {\\n                    return 0;\\n                }\\n            }\\n            return count;\\n        }\\n\\n        // Take \\n        indegree[requests[start][0]]--;\\n        indegree[requests[start][1]]++;\\n        int take = helper(start + 1, requests, indegree, n, count + 1);\\n\\n        // Not-take\\n        indegree[requests[start][0]]++;\\n        indegree[requests[start][1]]--;\\n        int notTake = helper(start + 1, requests, indegree, n, count);\\n\\n        return Math.max(take, notTake);\\n    }\\n}\\n```\\n```Python []\\nclass Solution:\\n    def __init__(self):\\n        self.ans = 0\\n\\n    def helper(self, start, requests, indegree, n, count):\\n        if start == len(requests):\\n            for i in range(n):\\n                if indegree[i] != 0:\\n                    return\\n            self.ans = max(self.ans, count)\\n            return\\n\\n        # Take \\n        indegree[requests[start][0]] -= 1\\n        indegree[requests[start][1]] += 1\\n        self.helper(start + 1, requests, indegree, n, count + 1)\\n\\n        # Not-take\\n        indegree[requests[start][0]] += 1\\n        indegree[requests[start][1]] -= 1\\n        self.helper(start + 1, requests, indegree, n, count)\\n\\n    def maximumRequests(self, n, requests):\\n        indegree = [0] * n\\n        self.helper(0, requests, indegree, n, 0)\\n        return self.ans\\n```\\n\\n![CUTE_CAT.png](https://assets.leetcode.com/users/images/08f772be-c314-40e3-955a-b29845257985_1688259472.2231731.png)\\n\\n\\n**If you found my solution helpful, I would greatly appreciate your upvote, as it would motivate me to continue sharing more solutions.**",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "Backtracking"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    int ans = 0;\\n\\n    void helper(int start, vector<vector<int>>& requests, vector<int>& indegree, int n, int count) {\\n        if (start == requests.size()) {\\n            for (int i = 0; i < n; i++) {\\n                if (indegree[i] != 0) {\\n                    return;\\n                }\\n            }\\n            ans = max(ans, count);\\n            return;\\n        }\\n\\n        // Take \\n        indegree[requests[start][0]]--;\\n        indegree[requests[start][1]]++;\\n        helper(start + 1,requests, indegree, n, count + 1);\\n\\n        // Not-take\\n        indegree[requests[start][0]]++;\\n        indegree[requests[start][1]]--;\\n        helper(start + 1,requests, indegree, n, count);\\n    }\\n    \\n    int maximumRequests(int n, vector<vector<int>>& requests) {\\n        vector<int> indegree(n, 0);\\n        helper(0, requests, indegree, n, 0);\\n        return ans;\\n    }\\n};\\n```\n```Java []\\nclass Solution {\\n    public int maximumRequests(int n, int[][] requests) {\\n        int[] indegree = new int[n];\\n        return helper(0, requests, indegree, n, 0);\\n    }\\n\\n    public int helper(int start, int[][] requests, int[] indegree, int n, int count) {\\n        if (start == requests.length) {\\n            for (int i = 0; i < n; i++) {\\n                if (indegree[i] != 0) {\\n                    return 0;\\n                }\\n            }\\n            return count;\\n        }\\n\\n        // Take \\n        indegree[requests[start][0]]--;\\n        indegree[requests[start][1]]++;\\n        int take = helper(start + 1, requests, indegree, n, count + 1);\\n\\n        // Not-take\\n        indegree[requests[start][0]]++;\\n        indegree[requests[start][1]]--;\\n        int notTake = helper(start + 1, requests, indegree, n, count);\\n\\n        return Math.max(take, notTake);\\n    }\\n}\\n```\n```Python []\\nclass Solution:\\n    def __init__(self):\\n        self.ans = 0\\n\\n    def helper(self, start, requests, indegree, n, count):\\n        if start == len(requests):\\n            for i in range(n):\\n                if indegree[i] != 0:\\n                    return\\n            self.ans = max(self.ans, count)\\n            return\\n\\n        # Take \\n        indegree[requests[start][0]] -= 1\\n        indegree[requests[start][1]] += 1\\n        self.helper(start + 1, requests, indegree, n, count + 1)\\n\\n        # Not-take\\n        indegree[requests[start][0]] += 1\\n        indegree[requests[start][1]] -= 1\\n        self.helper(start + 1, requests, indegree, n, count)\\n\\n    def maximumRequests(self, n, requests):\\n        indegree = [0] * n\\n        self.helper(0, requests, indegree, n, 0)\\n        return self.ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 866387,
                "title": "java-backtracking-straightforward-no-bit-masking",
                "content": "Iterating all possibilisties by backtracking. (Choose or Not Choose)\\nCount the incoming and outgoing paths for each building\\nCheck if all the buildings have the count of 0 (means incoming and outgoing paths are balanced according to the question description)\\n\\nTime Complexity: ```O(N   * 2 ^ R)```\\n```\\nclass Solution {\\n    int max = 0;\\n    public int maximumRequests(int n, int[][] requests) {\\n        helper(requests, 0, new int[n], 0);\\n        return max;\\n    }\\n    \\n    private void helper(int[][] requests, int index, int[] count, int num) {\\n        // Traverse all n buildings to see if they are all 0. (means balanced)\\n        if (index == requests.length) {\\n            for (int i : count) {\\n                if (0 != i) {\\n                    return;\\n                }\\n            }\\n            max = Math.max(max, num);\\n            return;\\n        }\\n\\t\\t// Choose this request\\n        count[requests[index][0]]++;\\n        count[requests[index][1]]--;\\n        helper(requests, index + 1, count, num + 1);\\n        count[requests[index][0]]--;\\n        count[requests[index][1]]++;\\n        \\n\\t\\t// Not Choose the request\\n        helper(requests, index + 1, count, num);\\n    }\\n}",
                "solutionTags": [],
                "code": "```O(N   * 2 ^ R)```",
                "codeTag": "Unknown"
            },
            {
                "id": 866456,
                "title": "python-check-all-combinations",
                "content": "\\n# **Intuition**\\nWe can brute forces all combinations of requests,\\nand then check if it\\'s achievable.\\n<br>\\n\\n# **Explanation**\\nFor each combination, use a `mask` to present the picks.\\nThe `k`th bits means we need to satisfy the `k`th request.\\n\\nIf for all buildings, in degrees == out degrees,\\nit\\'s achievable.\\n<br>\\n\\n# **Complexity**\\nTime `O((N + R) * 2^R)`\\nSpace `O(N)`\\n<br>\\n\\n# Solution 1\\n```py\\n    def maximumRequests(self, n, requests):\\n        nr = len(requests)\\n        res = 0\\n\\n        def test(mask):\\n            outd = [0] * n\\n            ind = [0] * n\\n            for k in xrange(nr):\\n                if (1 << k) & mask:\\n                    outd[requests[k][0]] += 1\\n                    ind[requests[k][1]] += 1\\n            return sum(outd) if outd == ind else 0\\n\\n        for i in xrange(1 << nr):\\n            res = max(res, test(i))\\n        return res\\n```\\n<br>\\n\\n# Solution 2: Using Combination\\nBased on solution from @uds5501\\n```py\\n    def maximumRequests(self, n, req):\\n        for k in range(len(req), 0, -1):\\n            for c in itertools.combinations(range(len(req)), k):\\n                degree = [0] * n\\n                for i in c:\\n                    degree[req[i][0]] -= 1\\n                    degree[req[i][1]] += 1\\n                if not any(degree):\\n                    return k\\n        return 0\\n```\\n\\n# Solution 3: Using Counter\\nbased on solution2, by @leihao1313\\n```py\\n    def maximumRequests(self, n: int, requests: List[List[int]]) -> int:\\n        for k in range(len(requests), 0, -1):\\n            for c in combinations(requests, k):\\n                if Counter(a for a, b in c) == Counter(b for a, b in c):\\n                    return k\\n        return 0\\n```",
                "solutionTags": [],
                "code": "```py\\n    def maximumRequests(self, n, requests):\\n        nr = len(requests)\\n        res = 0\\n\\n        def test(mask):\\n            outd = [0] * n\\n            ind = [0] * n\\n            for k in xrange(nr):\\n                if (1 << k) & mask:\\n                    outd[requests[k][0]] += 1\\n                    ind[requests[k][1]] += 1\\n            return sum(outd) if outd == ind else 0\\n\\n        for i in xrange(1 << nr):\\n            res = max(res, test(i))\\n        return res\\n```\n```py\\n    def maximumRequests(self, n, req):\\n        for k in range(len(req), 0, -1):\\n            for c in itertools.combinations(range(len(req)), k):\\n                degree = [0] * n\\n                for i in c:\\n                    degree[req[i][0]] -= 1\\n                    degree[req[i][1]] += 1\\n                if not any(degree):\\n                    return k\\n        return 0\\n```\n```py\\n    def maximumRequests(self, n: int, requests: List[List[int]]) -> int:\\n        for k in range(len(requests), 0, -1):\\n            for c in combinations(requests, k):\\n                if Counter(a for a, b in c) == Counter(b for a, b in c):\\n                    return k\\n        return 0\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 868403,
                "title": "c-python-knapsack-0-1",
                "content": "The only challenge here is to recognize that this is a search problem, and the constraints are small enough.\\n\\nAs in knapsack 0/1, we maximize over two choices - ether consider `requests[i]` or not. In the end, we check if all considered requests can be fulfilled. To do that, we check that the headcount balance `bal` in all buildings is zero.\\n\\nWithout memoisation, the time complexity is O(2 ^ m), where m is the number of requests. Luckily, `m` is limited to 16, so this solution is accepted without memoisation.\\n\\nIf we do have to use memoisation, we would do it based on the building balance. It\\'s easier to try it out in Python - thanks to `@lru_cache` and hashable tuples. In the solution below, the memoisation improved the runtime from 2,200 ms down to 700 ms.\\n\\n**C++**\\n```cpp\\nint bal[21] = {};\\nint maximumRequests(int n, vector<vector<int>>& requests, int i = 0) {\\n    if (i == requests.size())\\n        return count(begin(bal), begin(bal) + n, 0) == n ? 0 : INT_MIN;\\n    --bal[requests[i][0]];\\n    ++bal[requests[i][1]];\\n    auto take = 1 + maximumRequests(n, requests, i + 1);\\n    ++bal[requests[i][0]];\\n    --bal[requests[i][1]];\\n    return max(take, maximumRequests(n, requests, i + 1));\\n}\\n```\\n**Python**\\n```python\\ndef maximumRequests(self, n: int, requests: List[List[int]]) -> int:\\n    @lru_cache(None)\\n    def dfs(i : int, balance: Tuple[int]) -> int:\\n        if i == len(requests):\\n            return 0 if all(b == 0 for b in balance) else float(\\'-inf\\') \\n        bal = list(balance)\\n        bal[requests[i][0]] -= 1\\n        bal[requests[i][1]] += 1\\n        return max(1 + dfs(i + 1, tuple(bal)), dfs(i + 1, balance))\\n    return dfs(0, tuple([0] * n))\\n```",
                "solutionTags": [],
                "code": "```cpp\\nint bal[21] = {};\\nint maximumRequests(int n, vector<vector<int>>& requests, int i = 0) {\\n    if (i == requests.size())\\n        return count(begin(bal), begin(bal) + n, 0) == n ? 0 : INT_MIN;\\n    --bal[requests[i][0]];\\n    ++bal[requests[i][1]];\\n    auto take = 1 + maximumRequests(n, requests, i + 1);\\n    ++bal[requests[i][0]];\\n    --bal[requests[i][1]];\\n    return max(take, maximumRequests(n, requests, i + 1));\\n}\\n```\n```python\\ndef maximumRequests(self, n: int, requests: List[List[int]]) -> int:\\n    @lru_cache(None)\\n    def dfs(i : int, balance: Tuple[int]) -> int:\\n        if i == len(requests):\\n            return 0 if all(b == 0 for b in balance) else float(\\'-inf\\') \\n        bal = list(balance)\\n        bal[requests[i][0]] -= 1\\n        bal[requests[i][1]] += 1\\n        return max(1 + dfs(i + 1, tuple(bal)), dfs(i + 1, balance))\\n    return dfs(0, tuple([0] * n))\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 866843,
                "title": "c-simple-solution-with-comments-100-100",
                "content": "```\\n    void recur(vector<vector<int>>& requests, vector<int>& capacity, int reqId, int reqProcessed, int& maxRequests)\\n    {\\n    \\t//Base case: Processed all the requests, wind up.\\n        if(reqId == requests.size())\\n        {\\n        \\t//Check if all the buildings are balanced ( 0 incoming-0 outgoing)\\n            for(auto c: capacity)\\n            {\\n                if(c != 0)\\n                    return;\\n            }            \\n            //All the building are balanced, check and update max Req.\\n\\t\\t\\tmaxRequests = max(maxRequests, reqProcessed);                \\n            return;\\n        }\\n        \\n        //Check without processing this request.\\n        recur(requests, capacity, reqId+1, reqProcessed, maxRequests);\\n        \\n        //Check with processing this request.\\n        //Update incoming and outgoing building requests.\\n        capacity[requests[reqId][0]]--; capacity[requests[reqId][1]]++;\\n\\t\\t\\n       \\trecur(requests, capacity, reqId+1, reqProcessed+1, maxRequests);\\n        \\n        //Rollback the changes.\\n        capacity[requests[reqId][0]]++;   capacity[requests[reqId][1]]--;\\n    }\\n    \\n    int maximumRequests(int n, vector<vector<int>>& requests) {        \\n        vector<int> capacity(n, 0);\\n        int maxRequests;\\n        //Recur and process the requests.\\n        recur(requests, capacity, 0, 0, maxRequests);\\n        return maxRequests;        \\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    void recur(vector<vector<int>>& requests, vector<int>& capacity, int reqId, int reqProcessed, int& maxRequests)\\n    {\\n    \\t//Base case: Processed all the requests, wind up.\\n        if(reqId == requests.size())\\n        {\\n        \\t//Check if all the buildings are balanced ( 0 incoming-0 outgoing)\\n            for(auto c: capacity)\\n            {\\n                if(c != 0)\\n                    return;\\n            }            \\n            //All the building are balanced, check and update max Req.\\n\\t\\t\\tmaxRequests = max(maxRequests, reqProcessed);                \\n            return;\\n        }\\n        \\n        //Check without processing this request.\\n        recur(requests, capacity, reqId+1, reqProcessed, maxRequests);\\n        \\n        //Check with processing this request.\\n        //Update incoming and outgoing building requests.\\n        capacity[requests[reqId][0]]--; capacity[requests[reqId][1]]++;\\n\\t\\t\\n       \\trecur(requests, capacity, reqId+1, reqProcessed+1, maxRequests);\\n        \\n        //Rollback the changes.\\n        capacity[requests[reqId][0]]++;   capacity[requests[reqId][1]]--;\\n    }\\n    \\n    int maximumRequests(int n, vector<vector<int>>& requests) {        \\n        vector<int> capacity(n, 0);\\n        int maxRequests;\\n        //Recur and process the requests.\\n        recur(requests, capacity, 0, 0, maxRequests);\\n        return maxRequests;        \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 867597,
                "title": "c-o-ve-2-time-solution-8ms",
                "content": "We construct a directed graph G(V, E) with V = {0, 1, ..., n-1} and E being the requests. Initially the weight of every edge is set to 1. The algorithm is given by\\n\\n* set the answer to 0\\n* while there is a positive-weighted cycle C in G do\\n\\t* add the weight of C to the answer\\n\\t* **reverse** all edges in C and **negate** the weights\\n\\nFor example, if n = 3, requests = [[0, 1], [1, 0], [1, 2], [2, 0]], and in the first iteration we pick C = [[0, 1], [1, 0]], then E (the edge set of G) becomes {[1, 0, -1], [0, 1, -1], [1, 2, 1], [2, 0, 1]}, where [u, v, w] denotes the edge from u to v with weight w. Now that [[0, 1], [1, 2], [2, 0]] is a cycle with weight (-1)+1+1=1 in G, in the second iteration we obtain the answer 2+1=3.\\n\\nTo prove the correctness of the algorithm, let\\'s consider an optimal achievable set S of requests. Note that S corresponds to a subset of initial E(G) and that the in-degree and the out-degree of each vertex is equal on S. Now we reverse and negate all edges in S to obtain a new graph G\\'. Then G\\' doesn\\'t admit a positive-weighted cycle C; otherwise, S+C still satisfies the rule \"in-degree = out-degree\", but S+C contains more edges in the initial G, a contradiction. On the other hand, for a non-optimal achievable set T of requests, reverse and negate all edges in T to obtain another graph G\\'\\'. Now that S-T also satisfies the rule \"in-degree = out-degree\" and is a subgraph of G\\'\\', we can always find a positive-weighted cycle in G\\'\\'. This establish the correctness of the algorithm.\\n\\nFinding a positive-weighted cycle can be done in O(VE)-time with Bellman-Ford algorithm. The answer is incremented by at least 1 in each iteration and doesn\\'t exceed E in the end. Therefore the time complexity is O(VE^2).\\n\\nMy implementation of the algorithm is given below. To enable reversing some edges of G, all possible edges are added initially, with the field `sw` of `struct Edge` indicating whether the edge is activated or not.\\n```\\nclass Solution{\\n   struct Edge{\\n      int v, w, sw, rev;\\n      constexpr Edge(int v, int w, int sw, int rev) noexcept: v(v), w(w), sw(sw), rev(rev){}\\n   };\\npublic:\\n   int maximumRequests(int n, vector<vector<int>> &req) const{\\n      vector<vector<Edge>> g(n);\\n      int ans = 0;\\n      for(auto const &e: req){\\n         int u = e[0], v = e[1];\\n         if(u == v){\\n            ++ans; continue;\\n         }\\n         g[u].emplace_back(v, 1, 1, g[v].size());\\n         g[v].emplace_back(u, -1, 0, g[u].size()-1);\\n      }\\n      while(1){\\n         vector<int> d(n), pv(n), pe(n), cnt(n);\\n         queue<int> bf;\\n         for(int i=0; i<n; ++i){\\n            bf.push(i);\\n         }\\n         vector<bool> inq(n, true);\\n         int ncv = -1;\\n         while(!bf.empty()){\\n            int u = bf.front(); bf.pop(); inq[u] = false;\\n            for(size_t i=0; i<g[u].size(); ++i){\\n               auto [v, w, sw, _] = g[u][i];\\n               if(!sw || d[v]>=d[u]+w) continue;\\n               d[v] = d[u]+w;\\n               pv[v] = u; pe[v] = i;\\n               if(!inq[v]){\\n                  if(++cnt[v] == n){\\n                     ncv = v;\\n                     goto after_bf;\\n                  }\\n                  bf.push(v); inq[v] = true;\\n               }\\n            }\\n         }\\n         after_bf:\\n         if(ncv == -1) break;\\n         vector<bool> vis(n);\\n         for(; !vis[ncv]; ncv=pv[ncv]){\\n            vis[ncv] = true;\\n         }\\n         int u = ncv;\\n         do{\\n            int p = pv[u], i = pe[u];\\n            ans += g[p][i].w;\\n            g[p][i].sw = 0;\\n            g[u][g[p][i].rev].sw = 1;\\n            u = p;\\n         }while(u != ncv);\\n      }\\n      return ans;\\n   }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution{\\n   struct Edge{\\n      int v, w, sw, rev;\\n      constexpr Edge(int v, int w, int sw, int rev) noexcept: v(v), w(w), sw(sw), rev(rev){}\\n   };\\npublic:\\n   int maximumRequests(int n, vector<vector<int>> &req) const{\\n      vector<vector<Edge>> g(n);\\n      int ans = 0;\\n      for(auto const &e: req){\\n         int u = e[0], v = e[1];\\n         if(u == v){\\n            ++ans; continue;\\n         }\\n         g[u].emplace_back(v, 1, 1, g[v].size());\\n         g[v].emplace_back(u, -1, 0, g[u].size()-1);\\n      }\\n      while(1){\\n         vector<int> d(n), pv(n), pe(n), cnt(n);\\n         queue<int> bf;\\n         for(int i=0; i<n; ++i){\\n            bf.push(i);\\n         }\\n         vector<bool> inq(n, true);\\n         int ncv = -1;\\n         while(!bf.empty()){\\n            int u = bf.front(); bf.pop(); inq[u] = false;\\n            for(size_t i=0; i<g[u].size(); ++i){\\n               auto [v, w, sw, _] = g[u][i];\\n               if(!sw || d[v]>=d[u]+w) continue;\\n               d[v] = d[u]+w;\\n               pv[v] = u; pe[v] = i;\\n               if(!inq[v]){\\n                  if(++cnt[v] == n){\\n                     ncv = v;\\n                     goto after_bf;\\n                  }\\n                  bf.push(v); inq[v] = true;\\n               }\\n            }\\n         }\\n         after_bf:\\n         if(ncv == -1) break;\\n         vector<bool> vis(n);\\n         for(; !vis[ncv]; ncv=pv[ncv]){\\n            vis[ncv] = true;\\n         }\\n         int u = ncv;\\n         do{\\n            int p = pv[u], i = pe[u];\\n            ans += g[p][i].w;\\n            g[p][i].sw = 0;\\n            g[u][g[p][i].rev].sw = 1;\\n            u = p;\\n         }while(u != ncv);\\n      }\\n      return ans;\\n   }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3706689,
                "title": "c-bit-manipulation",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int maximumRequests(int n, vector<vector<int>>& r) {\\n        int mx=0;\\n        for(int i=0;i<(1<<r.size());i++){\\n            vector<int>a(n,0);\\n            int t=0;\\n            for(int j=0;j<r.size();j++){\\n                if(i & (1<<j)){\\n                    t++;\\n                    a[r[j][0]]--;\\n                    a[r[j][1]]++;\\n                }\\n            }\\n            bool f=true;\\n            for(int j=0;j<n;j++){\\n                if(a[j]!=0){\\n                    f=false;\\n                    break;\\n                }\\n            }\\n            if(f)mx=max(mx,t);\\n        }\\n        return mx;\\n    }\\n};\\n```\\n![upvote (2).jpg](https://assets.leetcode.com/users/images/b646f533-6c5d-4f28-b307-381d8730e389_1688274455.2291353.jpeg)\\n",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Bit Manipulation",
                    "Enumeration"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumRequests(int n, vector<vector<int>>& r) {\\n        int mx=0;\\n        for(int i=0;i<(1<<r.size());i++){\\n            vector<int>a(n,0);\\n            int t=0;\\n            for(int j=0;j<r.size();j++){\\n                if(i & (1<<j)){\\n                    t++;\\n                    a[r[j][0]]--;\\n                    a[r[j][1]]++;\\n                }\\n            }\\n            bool f=true;\\n            for(int j=0;j<n;j++){\\n                if(a[j]!=0){\\n                    f=false;\\n                    break;\\n                }\\n            }\\n            if(f)mx=max(mx,t);\\n        }\\n        return mx;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3707786,
                "title": "fully-explained-c-graph-outdegree-indegreee-bit-manipulation",
                "content": "> $$**********\\u091C\\u092F\\u0936\\u094D\\u0930\\u0940 \\u0930\\u093E\\u092E**********$$\\n# Intuition\\n\\nGiven a list of buildings and transfer details in the form of \"from\" and \"to\" buildings, we can model them as vertices and directed edges in a graph, respectively. Our goal is to determine the maximum number of edges (represented by \\'mmm\\') that satisfy the condition of equal incoming and outgoing edges for every vertex.\\n\\n# Approach\\n\\n1. Calculate the total number of possible ways to accept requests using $$2^(TotalNumberOfRequests)$$.\\n2. For each possible way, utilize bit manipulation to store the indices of the requests to be accepted.\\n3. Create a vector for each vertex to track the count of outgoing and incoming edges, initializing all values to 0.\\n4. Iterate through the accepted requests and increment the outgoing edge count for the \"from\" vertex while decrementing the incoming edge count for the \"to\" vertex.\\n5. Verify if the net resultant of the indegree and outdegree is zero for all vertices.\\n5. If the net resultant is zero, update the maximum number of requests (denoted as $$maxi$$) as the larger value between the current number of requests and $$maxi$$.\\n6. Upon considering all possible ways, return the value of $$maxi$$.\\n\\n# Code\\n```\\nclass Solution {\\n\\npublic:\\n    int maximumRequests(int n, vector<vector<int>>& requests) {\\n        int len = requests.size();\\n        int total = pow(2,len);\\n        int maxi = 0;\\n        vector<int> res;\\n        for(int i =0;i<=total;i++){\\n            vector<int> req;\\n            for(int j = 0;j<len;j++){\\n                if((i>>j)&1) req.push_back(j);\\n            }\\n            vector<int> degree(n,0);\\n            for(auto j:req){\\n                degree[requests[j][0]]++;\\n                degree[requests[j][1]]--;\\n            }\\n            for(auto j:degree) {\\n                if(j!=0) {\\n                    req.clear();\\n                    break;\\n                }\\n            }\\n            maxi = max(maxi,(int)req.size());\\n        }\\n        return maxi;\\n    }\\n};\\n```\\n\\nupvote if you liked the solution.\\n\\n> $$**********\\u091C\\u092F\\u0936\\u094D\\u0930\\u0940 \\u0930\\u093E\\u092E**********$$",
                "solutionTags": [
                    "C++",
                    "Bit Manipulation",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\n\\npublic:\\n    int maximumRequests(int n, vector<vector<int>>& requests) {\\n        int len = requests.size();\\n        int total = pow(2,len);\\n        int maxi = 0;\\n        vector<int> res;\\n        for(int i =0;i<=total;i++){\\n            vector<int> req;\\n            for(int j = 0;j<len;j++){\\n                if((i>>j)&1) req.push_back(j);\\n            }\\n            vector<int> degree(n,0);\\n            for(auto j:req){\\n                degree[requests[j][0]]++;\\n                degree[requests[j][1]]--;\\n            }\\n            for(auto j:degree) {\\n                if(j!=0) {\\n                    req.clear();\\n                    break;\\n                }\\n            }\\n            maxi = max(maxi,(int)req.size());\\n        }\\n        return maxi;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 866369,
                "title": "python3-10-lines-bitmasking-combinations-easy-explanation",
                "content": "\\nTL: DR - **Use Bitmasking on the requests which you would like to perform.**\\n\\nExplanation : \\nLet there be `tot` requests. Now start from taking `x`(`x in [1, tot]`) requests which you perform and chose any `x` indices out of `tot` from the requests array.\\nMaintain a `net` change among the hostels after the requests are done and check if the net array is still `[0,0,0,0....(n elements)]` after the requests.\\nIf it\\'s true, print this x, else do `x = x-1`\\n\\nNOTE : you cannot perform only one request unless it\\'s of type [a,a]\\n\\n```\\nclass Solution:\\n    def maximumRequests(self, n: int, req: List[List[int]]) -> int:\\n        tot = len(req)\\n        for i in range(tot, 0, -1):\\n            comb = list(itertools.combinations([j for j in range(tot)], i))\\n            for c in comb:\\n                net = [0 for j in range(n)]\\n                for idx in c:\\n                    net[req[idx][0]] -= 1\\n                    net[req[idx][1]] += 1\\n                if net == [0 for j in range(n)]:\\n                    return i\\n        return 0\\n```",
                "solutionTags": [
                    "Python3",
                    "Bitmask"
                ],
                "code": "```\\nclass Solution:\\n    def maximumRequests(self, n: int, req: List[List[int]]) -> int:\\n        tot = len(req)\\n        for i in range(tot, 0, -1):\\n            comb = list(itertools.combinations([j for j in range(tot)], i))\\n            for c in comb:\\n                net = [0 for j in range(n)]\\n                for idx in c:\\n                    net[req[idx][0]] -= 1\\n                    net[req[idx][1]] += 1\\n                if net == [0 for j in range(n)]:\\n                    return i\\n        return 0\\n```",
                "codeTag": "Java"
            },
            {
                "id": 866363,
                "title": "java-simple-iterating-through-all-subsets",
                "content": "The solution is quite straitforward:\\n\\t- iterate over all subsets of ```requests``` (using bitmasks: 1 at position ```i``` means that the ```i```-th request is in the subset);\\n\\t- check whether the subset is achievable (iterate throught the subset and find the total number of outgoing and incoming requests for each building,\\n\\t then check whether the net requests for every building are 0);\\n\\t- if achievable, update the current maximum with the number of elements in the subset (which is the bitcount of the mask).\\n\\nTime complexity: ```O((2 ^ r) * (n + r))```, where ```r = requests.length```.\\nSpace complexity: ```O(n)```.\\n\\n```\\n    public int maximumRequests(int n, int[][] requests) {\\n        int max = 0;\\n        for (int mask = 0; mask < (1 << requests.length); mask++){ \\n\\t\\t\\n            // if the subset is smaller than the current candidate, no need to check\\n            int bitCount = Integer.bitCount(mask);            \\n            if (bitCount <= max) continue;\\n            \\n            // find net number of requests for each building\\n            int[] counts = new int[n];\\n\\t\\t\\tint pos = 0;\\n            for (int cur = mask; cur > 0; cur >>= 1, pos++){\\n                if ((cur & 1) == 1){\\n                    counts[requests[pos][0]]++;\\n                    counts[requests[pos][1]]--;\\n                }\\n            }\\n            \\n            // check whether each building has 0 net requests\\n            boolean valid = true;\\n            for (int k : counts){\\n                if (k != 0){\\n                    valid = false;\\n                    break;\\n                }\\n            }\\n            \\n            if (valid) max = bitCount;\\n        }\\n        return max;\\n    }",
                "solutionTags": [
                    "Java",
                    "Iterator",
                    "Bitmask"
                ],
                "code": "```requests```\n```i```\n```i```\n```O((2 ^ r) * (n + r))```\n```r = requests.length```\n```O(n)```",
                "codeTag": "Unknown"
            },
            {
                "id": 3706593,
                "title": "c-backtracking",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->my initial thoughts on how to solve this problem are as follows:\\n\\n1. We need to find the maximum number of balanced requests that can be made among the given set of requests.\\n2. A balanced request means that for each building, the number of resources taken (outgoing requests) is equal to the number of resources received (incoming requests).\\n3. We can try to explore all possible combinations of requests to determine the maximum count of balanced requests.\\n4. One approach could be to use backtracking to generate all possible combinations and keep track of the maximum count found so far.\\n5. During backtracking, we can process each request and update the count of resources for each building accordingly.\\n6. We should keep track of the current count of balanced requests and update the maximum count whenever a higher count is found.\\n7. We\\'ll need to undo the changes made during backtracking to explore other possibilities.\\n8. Finally, we can return the maximum count as the result.\\n\\nOverall, the solution will involve a recursive backtracking algorithm that explores all possible combinations of requests and keeps track of the maximum count of balanced requests.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->To solve the problem, my approach would be to use a recursive backtracking algorithm. Here is a step-by-step breakdown of the approach:\\n\\n1. Define a recursive function, let\\'s call it `backtrack`, that takes the following parameters:\\n   - `requests`: The list of requests.\\n   - `index`: The current index in the requests list.\\n   - `count`: An array representing the count of resources in each building.\\n   - `currCount`: The current count of balanced requests.\\n   - `maxCount`: A reference to a variable that keeps track of the maximum count found so far.\\n\\n2. Inside the `backtrack` function, we will have a base case to check if we have processed all the requests. If the `index` is equal to the size of the `requests` list, it means we have processed all requests.\\n\\n3. In the base case, we need to check if all buildings have a balanced count. Iterate through the `count` array and if any count value is non-zero, it means the buildings are not balanced. In that case, we can simply return from the function without updating the maximum count.\\n\\n4. If we have processed all the requests and all buildings have a balanced count, we compare the current count (`currCount`) with the maximum count (`maxCount`) and update `maxCount` if `currCount` is greater.\\n\\n5. If the base case is not satisfied, we need to process the current request at the `index` position. Get the \"from\" and \"to\" buildings from the `requests` list at the given index.\\n\\n6. Decrease the count of the \"from\" building by 1 and increase the count of the \"to\" building by 1. These updates reflect the resources being taken from one building and delivered to another.\\n\\n7. Recursively call the `backtrack` function with the updated count, incremented `currCount` by 1, and move to the next request by increasing the `index` by 1. This represents processing the current request.\\n\\n8. After the recursive call, we need to undo the changes made in step 6 to explore the other possibility. Increase the count of the \"from\" building by 1 and decrease the count of the \"to\" building by 1. This step is crucial for backtracking.\\n\\n9. Again, recursively call the `backtrack` function with the current count, the same `currCount`, and move to the next request by increasing the `index` by 1. This represents skipping the current request.\\n\\n10. Finally, in the `maximumRequests` function, initialize the `count` array with all zeros, as we start with no resources in any building. Initialize `maxCount` as 0.\\n\\n11. Call the `backtrack` function from `maximumRequests` with the initial parameters: `requests`, `index = 0`, `count`, `currCount = 0`, and `maxCount` as a reference.\\n\\n12. After the backtracking process is complete, return the value of `maxCount` as the maximum count of balanced requests.\\n\\nBy recursively exploring all possible combinations of requests and backtracking when necessary, this approach will find the maximum count of balanced requests among the given set of requests.\\n\\n# Complexity\\n- Time complexity:  O(2^m)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(m + n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void backtrack(vector<vector<int>>& requests, int index, vector<int>& count, int currCount, int& maxCount) {\\n        // Base case: If all requests have been processed\\n        if (index == requests.size()) {\\n            // Check if all buildings have a balanced count\\n            for (int i = 0; i < count.size(); i++) {\\n                if (count[i] != 0) return; // Some building is unbalanced, return\\n            }\\n            // Update the maximum count if the current count is greater\\n            maxCount = max(maxCount, currCount);\\n            return;\\n        }\\n\\n        // Process the current request\\n        int from = requests[index][0];\\n        int to = requests[index][1];\\n        count[from]--; // Decrease count of \"from\" building\\n        count[to]++;   // Increase count of \"to\" building\\n\\n        // Recursively process the next request with the current count incremented\\n        backtrack(requests, index + 1, count, currCount + 1, maxCount);\\n\\n        // Undo the previous changes (backtracking)\\n        count[from]++; // Undo count change for \"from\" building\\n        count[to]--;   // Undo count change for \"to\" building\\n\\n        // Recursively process the next request with the current count\\n        backtrack(requests, index + 1, count, currCount, maxCount);\\n    }\\n\\n    int maximumRequests(int n, vector<vector<int>>& requests) {\\n        vector<int> count(n); // Initialize count of buildings to 0\\n        int maxCount = 0;     // Maximum count of balanced requests\\n        backtrack(requests, 0, count, 0, maxCount); // Start backtracking from index 0\\n        return maxCount;     // Return the maximum count\\n    }\\n};\\n\\n```\\n![Leetcode.jpeg](https://assets.leetcode.com/users/images/abbb2b82-466e-4770-a64f-20facb1eba34_1688273269.7159283.jpeg)\\n",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Backtracking",
                    "Bit Manipulation",
                    "Enumeration"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void backtrack(vector<vector<int>>& requests, int index, vector<int>& count, int currCount, int& maxCount) {\\n        // Base case: If all requests have been processed\\n        if (index == requests.size()) {\\n            // Check if all buildings have a balanced count\\n            for (int i = 0; i < count.size(); i++) {\\n                if (count[i] != 0) return; // Some building is unbalanced, return\\n            }\\n            // Update the maximum count if the current count is greater\\n            maxCount = max(maxCount, currCount);\\n            return;\\n        }\\n\\n        // Process the current request\\n        int from = requests[index][0];\\n        int to = requests[index][1];\\n        count[from]--; // Decrease count of \"from\" building\\n        count[to]++;   // Increase count of \"to\" building\\n\\n        // Recursively process the next request with the current count incremented\\n        backtrack(requests, index + 1, count, currCount + 1, maxCount);\\n\\n        // Undo the previous changes (backtracking)\\n        count[from]++; // Undo count change for \"from\" building\\n        count[to]--;   // Undo count change for \"to\" building\\n\\n        // Recursively process the next request with the current count\\n        backtrack(requests, index + 1, count, currCount, maxCount);\\n    }\\n\\n    int maximumRequests(int n, vector<vector<int>>& requests) {\\n        vector<int> count(n); // Initialize count of buildings to 0\\n        int maxCount = 0;     // Maximum count of balanced requests\\n        backtrack(requests, 0, count, 0, maxCount); // Start backtracking from index 0\\n        return maxCount;     // Return the maximum count\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 866959,
                "title": "c-gosper-s-hack-iterate-the-bit-masks-of-k-1-bits",
                "content": "An optimal way to solve this problem is to down loop k and iterate the bit masks where there are just k 1-bits. Once such a bit mask passes the check, we can terminate the loop and return k.\\n\\nThere is an elegant trick to do that: \\n```\\n// Iterate all the m-bit masks where there are k 1-bits.\\n\\nint state = (1 << k) - 1;            \\nwhile (state < (1 << m))\\n{\\n    doSomething(state);\\n\\n    int c = state & - state;\\n    int r = state + c;\\n    state = (((r ^ state) >> 2) / c) | r;\\n}\\n```\\n\\nThe whole code (90ms): \\n```\\nclass Solution {\\npublic:\\n    bool check(int s, int n, vector<vector<int>>& requests)\\n    {\\n        int building[20];\\n        for (int i=0; i<n; i++)\\n            building[i] = 0;\\n        \\n        int m = requests.size();\\n        for (int i=0; i<m; i++)\\n        {\\n            if (((s>>i)&1)==1)\\n            {\\n                building[requests[i][0]]--;\\n                building[requests[i][1]]++;\\n            }\\n        }\\n        \\n        for (int i=0; i<n; i++)\\n        {\\n            if (building[i]!=0)\\n                return false;\\n        }\\n        return true;\\n    }       \\n    \\n    int maximumRequests(int n, vector<vector<int>>& requests) \\n    {\\n        int m = requests.size();\\n        int ret = 0;\\n        \\n        for (int k=m; k>=1; k--)\\n        {\\n            int state = (1 << k) - 1;            \\n            \\n            while (state < (1 << m))\\n            {\\n                if (check(state, n, requests))\\n                    return k;\\n\\n                int c = state & - state;\\n                int r = state + c;\\n                state = (((r ^ state) >> 2) / c) | r;\\n            }            \\n        }\\n        \\n        return 0;        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n// Iterate all the m-bit masks where there are k 1-bits.\\n\\nint state = (1 << k) - 1;            \\nwhile (state < (1 << m))\\n{\\n    doSomething(state);\\n\\n    int c = state & - state;\\n    int r = state + c;\\n    state = (((r ^ state) >> 2) / c) | r;\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    bool check(int s, int n, vector<vector<int>>& requests)\\n    {\\n        int building[20];\\n        for (int i=0; i<n; i++)\\n            building[i] = 0;\\n        \\n        int m = requests.size();\\n        for (int i=0; i<m; i++)\\n        {\\n            if (((s>>i)&1)==1)\\n            {\\n                building[requests[i][0]]--;\\n                building[requests[i][1]]++;\\n            }\\n        }\\n        \\n        for (int i=0; i<n; i++)\\n        {\\n            if (building[i]!=0)\\n                return false;\\n        }\\n        return true;\\n    }       \\n    \\n    int maximumRequests(int n, vector<vector<int>>& requests) \\n    {\\n        int m = requests.size();\\n        int ret = 0;\\n        \\n        for (int k=m; k>=1; k--)\\n        {\\n            int state = (1 << k) - 1;            \\n            \\n            while (state < (1 << m))\\n            {\\n                if (check(state, n, requests))\\n                    return k;\\n\\n                int c = state & - state;\\n                int r = state + c;\\n                state = (((r ^ state) >> 2) / c) | r;\\n            }            \\n        }\\n        \\n        return 0;        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 866366,
                "title": "c-bitmasking-checking-euler-tour-easy-to-understand",
                "content": "Main Observation :\\n1. As far as the approach, solution boils down to answering the question: given certain number of edges in a graph. Can you detect whether there will exist an Euler tour ? (In this questions think of taking subsets of requests(ie edges) and forming the graph with those edges and checking for euler tour.\\n\\n```\\nclass Solution {\\npublic:\\n    int maximumRequests(int n, vector<vector<int>>& req) {\\n        int ans = 0;  int m = req.size(); int limit = (1<<m);\\n\\n        for (int state = 1; state<limit; state++) {\\n            vector<int> outdeg(n, 0), indeg(n, 0);  // indegree and outdegre of nodes formed by requests in state\\n\\t\\t\\tint tr = 0; // Total Requests in our current state (ie no of 1\\'s in binary representation of state)\\n            for (int i = 0; i<m; i++) {\\n                if ((state&(1<<i)) != 0) {\\n                    int u(req[i].front()), v(req[i].back());\\n                     outdeg[u]++; indeg[v]++; tr++;\\n                }\\n            }\\n\\n            int evenn = 0; // total number of even degree nodes, formed by requests in our current state\\n\\t\\t\\tint tn = 0; // total nodes covered by requests in our current state\\n            for(int i = 0; i<n; i++) {\\n                if (indeg[i] > 0) tn++; \\n                if (indeg[i]>0 && indeg[i] == outdeg[i]) evenn++;\\n            }\\n\\n\\t\\t\\t// hack to check whether all the nodes covered by the requests in our state are even degree\\n\\t\\t\\t// Because for euler tour(starting and ending at same node) to exists all the nodes must have even degree(ie indeg == outdeg)\\n            if (evenn == tn) ans = max(ans, tr);\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumRequests(int n, vector<vector<int>>& req) {\\n        int ans = 0;  int m = req.size(); int limit = (1<<m);\\n\\n        for (int state = 1; state<limit; state++) {\\n            vector<int> outdeg(n, 0), indeg(n, 0);  // indegree and outdegre of nodes formed by requests in state\\n\\t\\t\\tint tr = 0; // Total Requests in our current state (ie no of 1\\'s in binary representation of state)\\n            for (int i = 0; i<m; i++) {\\n                if ((state&(1<<i)) != 0) {\\n                    int u(req[i].front()), v(req[i].back());\\n                     outdeg[u]++; indeg[v]++; tr++;\\n                }\\n            }\\n\\n            int evenn = 0; // total number of even degree nodes, formed by requests in our current state\\n\\t\\t\\tint tn = 0; // total nodes covered by requests in our current state\\n            for(int i = 0; i<n; i++) {\\n                if (indeg[i] > 0) tn++; \\n                if (indeg[i]>0 && indeg[i] == outdeg[i]) evenn++;\\n            }\\n\\n\\t\\t\\t// hack to check whether all the nodes covered by the requests in our state are even degree\\n\\t\\t\\t// Because for euler tour(starting and ending at same node) to exists all the nodes must have even degree(ie indeg == outdeg)\\n            if (evenn == tn) ans = max(ans, tr);\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 866354,
                "title": "backtracking-python-very-simple",
                "content": "For Each Request you have two options, whether to accept it on not, so try both and try to choose the best out of these two decision.\\nBase Case : When you have gone through all buildings and delta incoming - outgoing is 0 for all buildings you return 0, else its invalid movements and you return a big negative number.\\n\\n**min(buildings) == 0 and max(buildings) == 0 means that all numbers are zero.**\\n```\\nclass Solution:\\n    def maximumRequestsUtil(self, requests, buildings , currentIndex):\\n        if currentIndex == len(requests):\\n            return 0 if min(buildings) == 0 and max(buildings) == 0  else -999999\\n        \\n        source,destination = requests[currentIndex]\\n        buildings[source] -= 1\\n        buildings[destination] += 1\\n        result = 1 + self.maximumRequestsUtil(requests,buildings,currentIndex+1)\\n\\n        buildings[source] += 1\\n        buildings[destination] -= 1\\n        \\n        result = max(result,self.maximumRequestsUtil(requests,buildings,currentIndex+1))\\n        return result\\n        \\n        \\n        \\n    def maximumRequests(self, n: int, requests: List[List[int]]) -> int:\\n        buildings = [0 for _ in range(n)]\\n        return self.maximumRequestsUtil(requests,buildings,0)\\n        \\n        \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def maximumRequestsUtil(self, requests, buildings , currentIndex):\\n        if currentIndex == len(requests):\\n            return 0 if min(buildings) == 0 and max(buildings) == 0  else -999999\\n        \\n        source,destination = requests[currentIndex]\\n        buildings[source] -= 1\\n        buildings[destination] += 1\\n        result = 1 + self.maximumRequestsUtil(requests,buildings,currentIndex+1)\\n\\n        buildings[source] += 1\\n        buildings[destination] -= 1\\n        \\n        result = max(result,self.maximumRequestsUtil(requests,buildings,currentIndex+1))\\n        return result\\n        \\n        \\n        \\n    def maximumRequests(self, n: int, requests: List[List[int]]) -> int:\\n        buildings = [0 for _ in range(n)]\\n        return self.maximumRequestsUtil(requests,buildings,0)\\n        \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3706150,
                "title": "backtrack-video-solution-java-c-python",
                "content": "<iframe width=\"560\" height=\"315\" src=\"https://www.youtube.com/embed/VvDtzvqOIao\" title=\"YouTube video player\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share\" allowfullscreen></iframe>\\n\\n```\\nclass Solution {\\n    int ans = 0;\\n    int [][] requests;\\n    \\n    public int maximumRequests(int n, int[][] requests) {\\n        this.requests = requests;\\n        int [] transfers = new int[n];\\n        backTrack(0, 0,transfers);\\n        return ans;\\n    }\\n    \\n    public void backTrack(int index, int count, int [] transfers){\\n        if(index == requests.length){\\n            for(int i : transfers){\\n                if(i!=0) return;\\n            }\\n            ans = Math.max(ans,count);\\n            return;\\n        }\\n        \\n        \\n        transfers[requests[index][0]]--;\\n        transfers[requests[index][1]]++;\\n        backTrack(index+1, count+1,transfers);\\n            \\n        transfers[requests[index][0]]++;\\n        transfers[requests[index][1]]--;\\n        backTrack(index+1, count,transfers);\\n        \\n        \\n    }\\n}\\n```\\n\\n```\\nclass Solution {\\npublic:\\n    int ans = 0;\\n    std::vector<std::vector<int>> requests;\\n    \\n    int maximumRequests(int n, std::vector<std::vector<int>>& requests) {\\n        this->requests = requests;\\n        std::vector<int> transfers(n, 0);\\n        backTrack(0, 0, transfers);\\n        return ans;\\n    }\\n    \\n    void backTrack(int index, int count, std::vector<int>& transfers) {\\n        if (index == requests.size()) {\\n            for (int i : transfers) {\\n                if (i != 0)\\n                    return;\\n            }\\n            ans = std::max(ans, count);\\n            return;\\n        }\\n        \\n        transfers[requests[index][0]]--;\\n        transfers[requests[index][1]]++;\\n        backTrack(index + 1, count + 1, transfers);\\n        \\n        transfers[requests[index][0]]++;\\n        transfers[requests[index][1]]--;\\n        backTrack(index + 1, count, transfers);\\n    }\\n};\\n\\n```\\n\\n```\\nclass Solution:\\n    def __init__(self):\\n        self.ans = 0\\n        self.requests = []\\n\\n    def maximumRequests(self, n, requests):\\n        self.requests = requests\\n        transfers = [0] * n\\n        self.backTrack(0, 0, transfers)\\n        return self.ans\\n\\n    def backTrack(self, index, count, transfers):\\n        if index == len(self.requests):\\n            if all(i == 0 for i in transfers):\\n                self.ans = max(self.ans, count)\\n            return\\n        \\n        transfers[self.requests[index][0]] -= 1\\n        transfers[self.requests[index][1]] += 1\\n        self.backTrack(index + 1, count + 1, transfers)\\n        \\n        transfers[self.requests[index][0]] += 1\\n        transfers[self.requests[index][1]] -= 1\\n        self.backTrack(index + 1, count, transfers)\\n\\n        \\n```",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C"
                ],
                "code": "```\\nclass Solution {\\n    int ans = 0;\\n    int [][] requests;\\n    \\n    public int maximumRequests(int n, int[][] requests) {\\n        this.requests = requests;\\n        int [] transfers = new int[n];\\n        backTrack(0, 0,transfers);\\n        return ans;\\n    }\\n    \\n    public void backTrack(int index, int count, int [] transfers){\\n        if(index == requests.length){\\n            for(int i : transfers){\\n                if(i!=0) return;\\n            }\\n            ans = Math.max(ans,count);\\n            return;\\n        }\\n        \\n        \\n        transfers[requests[index][0]]--;\\n        transfers[requests[index][1]]++;\\n        backTrack(index+1, count+1,transfers);\\n            \\n        transfers[requests[index][0]]++;\\n        transfers[requests[index][1]]--;\\n        backTrack(index+1, count,transfers);\\n        \\n        \\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    int ans = 0;\\n    std::vector<std::vector<int>> requests;\\n    \\n    int maximumRequests(int n, std::vector<std::vector<int>>& requests) {\\n        this->requests = requests;\\n        std::vector<int> transfers(n, 0);\\n        backTrack(0, 0, transfers);\\n        return ans;\\n    }\\n    \\n    void backTrack(int index, int count, std::vector<int>& transfers) {\\n        if (index == requests.size()) {\\n            for (int i : transfers) {\\n                if (i != 0)\\n                    return;\\n            }\\n            ans = std::max(ans, count);\\n            return;\\n        }\\n        \\n        transfers[requests[index][0]]--;\\n        transfers[requests[index][1]]++;\\n        backTrack(index + 1, count + 1, transfers);\\n        \\n        transfers[requests[index][0]]++;\\n        transfers[requests[index][1]]--;\\n        backTrack(index + 1, count, transfers);\\n    }\\n};\\n\\n```\n```\\nclass Solution:\\n    def __init__(self):\\n        self.ans = 0\\n        self.requests = []\\n\\n    def maximumRequests(self, n, requests):\\n        self.requests = requests\\n        transfers = [0] * n\\n        self.backTrack(0, 0, transfers)\\n        return self.ans\\n\\n    def backTrack(self, index, count, transfers):\\n        if index == len(self.requests):\\n            if all(i == 0 for i in transfers):\\n                self.ans = max(self.ans, count)\\n            return\\n        \\n        transfers[self.requests[index][0]] -= 1\\n        transfers[self.requests[index][1]] += 1\\n        self.backTrack(index + 1, count + 1, transfers)\\n        \\n        transfers[self.requests[index][0]] += 1\\n        transfers[self.requests[index][1]] -= 1\\n        self.backTrack(index + 1, count, transfers)\\n\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3706111,
                "title": "backtracking-python-js-solution",
                "content": "Hello **Tenno Leetcoders**, \\n\\nFor this problem, we are given `n` buildings numbered from `0` to `n-1`, and each building has a certain number of employees. With a list of employees transfer requests, where each request is represented as an employee\\'s request to transfer from building `from i` to building `to i`. Since, all building are already full, the `net change` in employee transfers should be `0` for each building to make this request achieveable. Thus, we need to `find the maximum number of achieveable requests`\\n\\n### Explanation\\n\\nTo solve this problem, we will need to consider all possible combinations of requests and explore the difference choices as we keep track of the net change in transfer for each building. Therefore, we can use `backtracking` to help us explore all possibilities. \\n\\nUsing backtracking approach, we are able to explore all possible combinations of requests as we include or exclude each request for each backtracking step. By backtracking and keep track of the net change being made in the transfers, we ensure that we only consider combinations that have a `0` net change transferring to each building. \\n\\n#### steps\\n\\n- Define backtracking method that takes in three parameters:\\n\\n    1) curr: represents the index of the current request being made\\n    \\n    2) count: keep track of the number of requests included in the current combinations\\n    \\n    3) transfers: a list which stores the net changes transferring from building\\n    \\n### backtrack()\\n\\n- This method base case is all requests has been processed:\\n\\n    - If the net change in transfer is 0 for all buildings, we return the count. \\n    \\n    - Otherwise, return 0\\n\\n- For each building transfer, we need to worry from and to transfers as we include or exclude the current requests:\\n\\n    1) To include the transfer being made from the current building can be denoted as `requests[curr][0]`\\n    \\n        - Since, we are transfering from one building to the next, we need to decrement the transfer count for this current building. This will be denoted as `transfers[requests[curr][0]] -= 1`\\n     \\n    2)  To include, the transfer being made to the current building can be denoted as `requests[curr][1]`\\n    \\n        - Since, we are transfering to a building, we need to increment the transfer count for this current building destinations. This will be denoted as `transfers[requests[curr][1]] += 1`\\n    \\n    3) To process the next included requests, we make a recursvie call to our `backtrack` method and increment current index and count by `1` \\n    \\n    4) After we tried the included combinations, we undo the previous transfers by restoring the transfers count\\n    \\n    5) To exclude, we will only need to make another recursive call using `backtrack` method to process the next requests without the need to modify the transfer counts\\n    \\n    \\n    6) Once we found our included and excluded values, we return the maximum cout obtained from our recursives calls for our current requests\\n    \\nTo start the backtracking process we call `backtrack(0,0, transfers)` \\n\\n\\n# Code\\n\\n**Python**\\n\\n```\\nclass Solution:\\n    def maximumRequests(self, n: int, requests: List[List[int]]) -> int:\\n        transfers = [0] * n\\n        def backtrack(curr, count, transfers):\\n            if curr == len(requests):\\n                if all(t == 0 for t in transfers): return count\\n                else: return 0\\n                \\n            transfers[requests[curr][0]] -= 1\\n            transfers[requests[curr][1]] += 1\\n            \\n            count_included = backtrack(curr + 1, count + 1, transfers)\\n\\n            transfers[requests[curr][0]] += 1\\n            transfers[requests[curr][1]] -= 1\\n\\n            count_excluded = backtrack(curr + 1, count, transfers)\\n\\n            return max(count_included, count_excluded)\\n        \\n        return backtrack(0,0, transfers)\\n```\\n\\n**JavaScript**\\n```\\n/**\\n * @param {number} n\\n * @param {number[][]} requests\\n * @return {number}\\n */\\nvar maximumRequests = function(n, requests) {\\n    const transfers = Array(n).fill(0)\\n\\n    const backtrack = (curr, count, transfers) => {\\n        if(curr === requests.length){\\n            if(transfers.every(t => t === 0)) return count\\n            else return 0\\n        }\\n\\n        transfers[requests[curr][0]] -= 1\\n        transfers[requests[curr][1]] += 1\\n\\n        const countIncluded = backtrack(curr + 1, count + 1, transfers)\\n\\n        transfers[requests[curr][0]] += 1\\n        transfers[requests[curr][1]] -= 1\\n\\n        const countExcluded = backtrack(curr + 1, count , transfers)\\n\\n        return Math.max(countIncluded, countExcluded)         \\n    }\\n    return backtrack(0,0, transfers)\\n};\\n```\\n\\n### Time Complexity: O(2*n)\\n### Space Complexity: O(n+m)\\n\\n \\n***Warframe\\'s Darvo wants you to upvote this post  \\uD83D\\uDE4F\\uD83C\\uDFFB \\u2764\\uFE0F\\u200D\\uD83D\\uDD25***\\n\\n![image](https://assets.leetcode.com/users/images/814f5668-c966-46d7-ba42-e5435c4c1761_1675302761.3081913.gif)",
                "solutionTags": [
                    "Python3",
                    "JavaScript",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution:\\n    def maximumRequests(self, n: int, requests: List[List[int]]) -> int:\\n        transfers = [0] * n\\n        def backtrack(curr, count, transfers):\\n            if curr == len(requests):\\n                if all(t == 0 for t in transfers): return count\\n                else: return 0\\n                \\n            transfers[requests[curr][0]] -= 1\\n            transfers[requests[curr][1]] += 1\\n            \\n            count_included = backtrack(curr + 1, count + 1, transfers)\\n\\n            transfers[requests[curr][0]] += 1\\n            transfers[requests[curr][1]] -= 1\\n\\n            count_excluded = backtrack(curr + 1, count, transfers)\\n\\n            return max(count_included, count_excluded)\\n        \\n        return backtrack(0,0, transfers)\\n```\n```\\n/**\\n * @param {number} n\\n * @param {number[][]} requests\\n * @return {number}\\n */\\nvar maximumRequests = function(n, requests) {\\n    const transfers = Array(n).fill(0)\\n\\n    const backtrack = (curr, count, transfers) => {\\n        if(curr === requests.length){\\n            if(transfers.every(t => t === 0)) return count\\n            else return 0\\n        }\\n\\n        transfers[requests[curr][0]] -= 1\\n        transfers[requests[curr][1]] += 1\\n\\n        const countIncluded = backtrack(curr + 1, count + 1, transfers)\\n\\n        transfers[requests[curr][0]] += 1\\n        transfers[requests[curr][1]] -= 1\\n\\n        const countExcluded = backtrack(curr + 1, count , transfers)\\n\\n        return Math.max(countIncluded, countExcluded)         \\n    }\\n    return backtrack(0,0, transfers)\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 866530,
                "title": "python-linear-programming-beats-100",
                "content": "\\nLet `x_i` be 0 or 1 depending on whether `requests[i]` is used. Then the [integer program](https://en.wikipedia.org/wiki/Integer_programming) for this problem is:\\n\\n![image](https://assets.leetcode.com/users/images/f8b2b7b9-de7a-4076-8811-50cf580ee44b_1601214365.1695964.png)\\n\\n\\nWe can relax this into to a linear program (so `0<=x_i<=1` instead of integers) which can be efficiently solved. Note: scipy\\'s linprog does min instead of max which why the coefficients are negative instead: \\n\\n```\\nfrom scipy.optimize import linprog\\n\\nclass Solution:\\n    def maximumRequests(self, n: int, requests: List[List[int]]) -> int:\\n        m = len(requests)\\n            \\n        cost = [-1] * m\\n        A = [[0 for i in range(m)] for j in range(n)]\\n        b = [0] * n\\n        for i, (u, v) in enumerate(requests):\\n            A[u][i] -= 1\\n            A[v][i] += 1\\n            \\n        res = linprog(cost, A_eq=A, b_eq=b, bounds=(0, 1))\\n\\n        return round(-res.fun)\\n```\\n\\nIf the linear program happens to have integer solutions, it is also optimal for the integer program. See notes like http://theory.stanford.edu/~trevisan/cs261/lecture07.pdf for reference.\\n\\nI didn\\'t prove that the LP solution will always be integral but it got accepted so it is probably true. Someone can provide a more rigorous proof in comments (or disprove!).",
                "solutionTags": [],
                "code": "```\\nfrom scipy.optimize import linprog\\n\\nclass Solution:\\n    def maximumRequests(self, n: int, requests: List[List[int]]) -> int:\\n        m = len(requests)\\n            \\n        cost = [-1] * m\\n        A = [[0 for i in range(m)] for j in range(n)]\\n        b = [0] * n\\n        for i, (u, v) in enumerate(requests):\\n            A[u][i] -= 1\\n            A[v][i] += 1\\n            \\n        res = linprog(cost, A_eq=A, b_eq=b, bounds=(0, 1))\\n\\n        return round(-res.fun)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 867592,
                "title": "python3-dfs-backtracking-faster-than-100",
                "content": "Solution:\\nBuild requests graph, that way any cycle there is employee that can be moved around and fit places of each other.\\nThen find set of cycles that will use the most of requests.\\n\\n```\\nclass Solution:\\n    def maximumRequests(self, n: int, requests: List[List[int]]) -> int:\\n        graph = defaultdict(set)\\n        result = 0\\n        request_index = 0\\n        # BUILD GRAPH AND ADD ALL REUQSTS [X, X] right to result\\n        for from_, to in requests:\\n            if from_ == to:\\n                result += 1\\n            else:\\n                graph[from_].add((request_index, to))\\n                request_index += 1\\n\\n        in_progres = set()\\n        cycles = set()\\n        \\n        # FIND ALL CYCLES\\n        def dfs(from_, request_path, building_path):\\n            for request_index, to in graph[from_]:\\n                if to in building_path:\\n                    cycles.add(tuple(sorted(request_path[building_path.index(to):] + [request_index])))\\n                else:\\n                    dfs(to, request_path + [request_index], building_path + [to])\\n        \\n        for i in range(n):\\n            dfs(i, [], [i])\\n        \\n        cycles = [set(x) for x in cycles]\\n        \\n        # FIND SET OF CYCLES THAT USES MAXIMUM REQUESTS\\n        def backtrack(j, current):\\n            max_requests = len(current)\\n            for k in range(j, len(cycles)):\\n                joined = current | cycles[k]\\n                if len(joined) == len(current) + len(cycles[k]):\\n                    max_requests = max(backtrack(k + 1, joined), max_requests)\\n            return max_requests\\n\\n        return result + backtrack(0, set())\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def maximumRequests(self, n: int, requests: List[List[int]]) -> int:\\n        graph = defaultdict(set)\\n        result = 0\\n        request_index = 0\\n        # BUILD GRAPH AND ADD ALL REUQSTS [X, X] right to result\\n        for from_, to in requests:\\n            if from_ == to:\\n                result += 1\\n            else:\\n                graph[from_].add((request_index, to))\\n                request_index += 1\\n\\n        in_progres = set()\\n        cycles = set()\\n        \\n        # FIND ALL CYCLES\\n        def dfs(from_, request_path, building_path):\\n            for request_index, to in graph[from_]:\\n                if to in building_path:\\n                    cycles.add(tuple(sorted(request_path[building_path.index(to):] + [request_index])))\\n                else:\\n                    dfs(to, request_path + [request_index], building_path + [to])\\n        \\n        for i in range(n):\\n            dfs(i, [], [i])\\n        \\n        cycles = [set(x) for x in cycles]\\n        \\n        # FIND SET OF CYCLES THAT USES MAXIMUM REQUESTS\\n        def backtrack(j, current):\\n            max_requests = len(current)\\n            for k in range(j, len(cycles)):\\n                joined = current | cycles[k]\\n                if len(joined) == len(current) + len(cycles[k]):\\n                    max_requests = max(backtrack(k + 1, joined), max_requests)\\n            return max_requests\\n\\n        return result + backtrack(0, set())\\n```",
                "codeTag": "Java"
            },
            {
                "id": 867123,
                "title": "simple-explanation-c",
                "content": "So, basically what we would be doing is try out all the combination of requests and for each combination check wheter the *indegree* and *outdegree* are same.\\n\\nSuppose there are **k** requests so total `2^k ` combinations are possible,\\n\\nSo we iterate from *i = 1 to 2^k* ,(As min answer would be granting 0 requests so we set the ans = 0 and start i from 1) and check the set bits in i which represents the index of requests granted and we update the indegree and out degree  accordingly .\\n\\nTo iterate over all of the set bits we use `if( (i>>r) & 1 )`  where `r` ranges over all the indices of requests\\n\\nTo check indegree and outdegree we use  - \\n`A[n] = {0};`\\nand for each `r` satisfying `if( (i>>r) & 1 )`  we update - \\n\\n```\\nA[requests[r][0]]++; // Indicating out degree\\nA[requests[r][1]]--; // Indicating in degree\\ncur_ans++; // To update the current number of granted requests\\n```\\n\\nAfter that we check if` A[i] = 0; for all i ` if Yes then we update \\n`ans = max(ans,cur_ans)`\\n\\nCODE - \\n```\\n    int maximumRequests(int n, vector<vector<int>>& requests) {\\n        int ans = 0 , k = requests.size() , R = 1<<k;\\n\\n        for(int i=1;i<R;i++){\\n            int *A = (int*) calloc(n,sizeof(int));\\n            int cur_ans = 0;\\n            for(int r=0;r<k;r++){\\n                if( int(i>>r) & 1 ){ // Checking if r`th bit of i is set \\n                    A[requests[r][0]]++;\\n                    A[requests[r][1]]--;\\n                    cur_ans++;\\n                }\\n            }\\n            int x;\\n            for(x=0;x<n;x++)\\n                if(A[x]!=0) // Voilation of indegree and outdegree\\n                    break;\\n            if(x==n) // For all indegree and outdegree is cancel each other\\n                ans = max(ans,cur_ans);\\n        }\\n        return ans;\\n    }\\n\\n```\\n\\nk - number of requests \\nn - number of buildings\\n**Time Complexity** - The outer loop will run 2^k times and for each outer loop we have two loops running \\n* 1st Loop - k times (for updating building combination)\\n* 2nd Loop- n times (for checking whether the combination is feasible or not)\\n\\nSo Finally it is **O( (n+k) * 2^k  )**.\\n\\n\\n**Space Complexity** - **O(n)** (For storing the indegree and outdegree in A[n])\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nA[requests[r][0]]++; // Indicating out degree\\nA[requests[r][1]]--; // Indicating in degree\\ncur_ans++; // To update the current number of granted requests\\n```\n```\\n    int maximumRequests(int n, vector<vector<int>>& requests) {\\n        int ans = 0 , k = requests.size() , R = 1<<k;\\n\\n        for(int i=1;i<R;i++){\\n            int *A = (int*) calloc(n,sizeof(int));\\n            int cur_ans = 0;\\n            for(int r=0;r<k;r++){\\n                if( int(i>>r) & 1 ){ // Checking if r`th bit of i is set \\n                    A[requests[r][0]]++;\\n                    A[requests[r][1]]--;\\n                    cur_ans++;\\n                }\\n            }\\n            int x;\\n            for(x=0;x<n;x++)\\n                if(A[x]!=0) // Voilation of indegree and outdegree\\n                    break;\\n            if(x==n) // For all indegree and outdegree is cancel each other\\n                ans = max(ans,cur_ans);\\n        }\\n        return ans;\\n    }\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3709298,
                "title": "image-solution-using-backtracking-java-c",
                "content": "# Intuition\\nBruteforce thinking. Take or Not take a request. We have two options for each request shown in figure below. Each node represents one request.\\n\\n![1601.png](https://assets.leetcode.com/users/images/2c810248-8840-408a-9b0e-dd92631e359e_1688314470.4731557.png)\\n\\nThe above figure shows how our algorithm should work.\\n# Complexity\\n- Time complexity: $$O(2^M*N)$$\\nFor each request, we have two conditions, we either take the request or not take it. So, there will be a total of $$2^M$$ requests. After $$2^M$$ requests, we will iterate the `inDegrees[]` array of $$N$$ buildings to check if this is a potential answer. This will require $$O(N)$$ time. So, totally $$O(2^M*N)$$ time will be required.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(N+M)$$\\nWe declared an array `inDegrees[]` of length $$N$$ to store the in degrees. So, this will require $$O(N)$$ space. But we are also performing recursion call on the **backtrack()** method. The maximum number of active stack calls to the method would equal $$M$$ (when all the requests call would be active). Hence, the total space complexity would be $$O(N+M)$$.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```Java []\\nclass Solution {\\n    int permits;\\n    public int maximumRequests(int n, int[][] requests) {\\n        permits = 0;\\n        backtrack(0, 0, requests, new int[n]);\\n        return permits;\\n    }\\n\\n    void backtrack(int cur, int noOfPermitsGiven, int[][] requests, int[] inDegrees) {\\n        if(cur == requests.length) {\\n            for(int inDegree : inDegrees) {\\n                if(inDegree != 0) {\\n                    // we must have all the inDegrees equal 0\\n                    return;\\n                }\\n            }\\n            permits = Math.max(permits, noOfPermitsGiven);\\n            return;\\n        }\\n\\n        // give permission for this request\\n        // update the degrees\\n        inDegrees[requests[cur][0]]--;\\n        inDegrees[requests[cur][1]]++;\\n        backtrack(cur+1, noOfPermitsGiven+1, requests, inDegrees);\\n\\n        // do not give permission for this request\\n        // reset the degrees\\n        inDegrees[requests[cur][0]]++;\\n        inDegrees[requests[cur][1]]--;\\n        backtrack(cur+1, noOfPermitsGiven, requests, inDegrees);\\n    }\\n}\\n```\\n``` C++ []\\nclass Solution {\\npublic:\\n    int permits;\\n    int maximumRequests(int n, vector<vector<int>>& requests) {\\n        permits = 0;\\n        vector<int> inDegrees(n, 0);\\n        backtrack(0, 0, requests, inDegrees);\\n        return permits;\\n    }\\n    void backtrack(int cur, int noOfPermitsGiven, vector<vector<int>>& requests, vector<int>& inDegrees) {\\n        if(cur == requests.size()) {\\n            for(int inDegree : inDegrees) {\\n                if(inDegree != 0) {\\n                    // we must have all the inDegrees equal 0\\n                    return;\\n                }\\n            }\\n            permits = max(permits, noOfPermitsGiven);\\n            return;\\n        }\\n\\n        // give permission for this request\\n        // update the degrees\\n        inDegrees[requests[cur][0]]--;\\n        inDegrees[requests[cur][1]]++;\\n        backtrack(cur+1, noOfPermitsGiven+1, requests, inDegrees);\\n\\n        // do not give permission for this request\\n        // reset the degrees\\n        inDegrees[requests[cur][0]]++;\\n        inDegrees[requests[cur][1]]--;\\n        backtrack(cur+1, noOfPermitsGiven, requests, inDegrees);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```Java []\\nclass Solution {\\n    int permits;\\n    public int maximumRequests(int n, int[][] requests) {\\n        permits = 0;\\n        backtrack(0, 0, requests, new int[n]);\\n        return permits;\\n    }\\n\\n    void backtrack(int cur, int noOfPermitsGiven, int[][] requests, int[] inDegrees) {\\n        if(cur == requests.length) {\\n            for(int inDegree : inDegrees) {\\n                if(inDegree != 0) {\\n                    // we must have all the inDegrees equal 0\\n                    return;\\n                }\\n            }\\n            permits = Math.max(permits, noOfPermitsGiven);\\n            return;\\n        }\\n\\n        // give permission for this request\\n        // update the degrees\\n        inDegrees[requests[cur][0]]--;\\n        inDegrees[requests[cur][1]]++;\\n        backtrack(cur+1, noOfPermitsGiven+1, requests, inDegrees);\\n\\n        // do not give permission for this request\\n        // reset the degrees\\n        inDegrees[requests[cur][0]]++;\\n        inDegrees[requests[cur][1]]--;\\n        backtrack(cur+1, noOfPermitsGiven, requests, inDegrees);\\n    }\\n}\\n```\n``` C++ []\\nclass Solution {\\npublic:\\n    int permits;\\n    int maximumRequests(int n, vector<vector<int>>& requests) {\\n        permits = 0;\\n        vector<int> inDegrees(n, 0);\\n        backtrack(0, 0, requests, inDegrees);\\n        return permits;\\n    }\\n    void backtrack(int cur, int noOfPermitsGiven, vector<vector<int>>& requests, vector<int>& inDegrees) {\\n        if(cur == requests.size()) {\\n            for(int inDegree : inDegrees) {\\n                if(inDegree != 0) {\\n                    // we must have all the inDegrees equal 0\\n                    return;\\n                }\\n            }\\n            permits = max(permits, noOfPermitsGiven);\\n            return;\\n        }\\n\\n        // give permission for this request\\n        // update the degrees\\n        inDegrees[requests[cur][0]]--;\\n        inDegrees[requests[cur][1]]++;\\n        backtrack(cur+1, noOfPermitsGiven+1, requests, inDegrees);\\n\\n        // do not give permission for this request\\n        // reset the degrees\\n        inDegrees[requests[cur][0]]++;\\n        inDegrees[requests[cur][1]]--;\\n        backtrack(cur+1, noOfPermitsGiven, requests, inDegrees);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3709274,
                "title": "python-3-easy-solution-with-explanation",
                "content": "# Algorithm : \\n* Check for maximum number of achievable request (k = 6)\\n* Check for all the combinations ()\\n* create a bulding status array\\n* update bulding status for all the transactions\\n* if net change is 0 then return k\\n# Time Complexity\\n`n` is the number of bulding and `r` is the number of requests `O((n+r)*2^r)`\\n# Space Complexity\\n`n` for `building_status` array `O(n)`\\n# Video Explanation\\nhttps://youtu.be/nMn-_BVkPeM\\n\\n# Code\\n```\\nclass Solution:\\n    def maximumRequests(self, n: int, requests: List[List[int]]) -> int:\\n        \"\"\"\\n        Algorithm : \\n        * Check for maximum number of achievable request (k = 6)\\n        * Check for all the combinations ()\\n        * create a bulding status array\\n        * update bulding status for all the transactions\\n        * if net change is 0 then return k\\n        \"\"\"\\n        \\n        for k in range(len(requests),0,-1):\\n            for c in itertools.combinations(range(len(requests)),k):\\n                building_status = [0]*n\\n                for i in c:\\n                    building_status[requests[i][0]] -= 1\\n                    building_status[requests[i][1]] += 1\\n                if not any(building_status):\\n                    return k\\n        return 0\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Backtracking",
                    "Bit Manipulation",
                    "Bitmask"
                ],
                "code": "```\\nclass Solution:\\n    def maximumRequests(self, n: int, requests: List[List[int]]) -> int:\\n        \"\"\"\\n        Algorithm : \\n        * Check for maximum number of achievable request (k = 6)\\n        * Check for all the combinations ()\\n        * create a bulding status array\\n        * update bulding status for all the transactions\\n        * if net change is 0 then return k\\n        \"\"\"\\n        \\n        for k in range(len(requests),0,-1):\\n            for c in itertools.combinations(range(len(requests)),k):\\n                building_status = [0]*n\\n                for i in c:\\n                    building_status[requests[i][0]] -= 1\\n                    building_status[requests[i][1]] += 1\\n                if not any(building_status):\\n                    return k\\n        return 0\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3706323,
                "title": "simple-c-0-1-knapsack-like-backtrack",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    \\n    void solve(int i, vector<vector<int>>& requests,vector<int> &degree,int count,int &ans){\\n        if(i==requests.size())\\n        {\\n            for(auto i:degree){\\n                if(i!=0) return;\\n            }\\n            ans=max(ans,count);\\n            return ;\\n        }\\n        //take\\n        degree[requests[i][0]]++;\\n        degree[requests[i][1]]--;\\n        solve(i+1,requests,degree,count+1,ans);\\n        degree[requests[i][0]]--;\\n        degree[requests[i][1]]++;\\n        //not take\\n         solve(i+1,requests,degree,count,ans);\\n\\n    }\\n    int maximumRequests(int n, vector<vector<int>>& requests) {\\n        vector<int> degree(n);\\n        int ans=0;\\n        solve(0,requests,degree,0,ans);\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    void solve(int i, vector<vector<int>>& requests,vector<int> &degree,int count,int &ans){\\n        if(i==requests.size())\\n        {\\n            for(auto i:degree){\\n                if(i!=0) return;\\n            }\\n            ans=max(ans,count);\\n            return ;\\n        }\\n        //take\\n        degree[requests[i][0]]++;\\n        degree[requests[i][1]]--;\\n        solve(i+1,requests,degree,count+1,ans);\\n        degree[requests[i][0]]--;\\n        degree[requests[i][1]]++;\\n        //not take\\n         solve(i+1,requests,degree,count,ans);\\n\\n    }\\n    int maximumRequests(int n, vector<vector<int>>& requests) {\\n        vector<int> degree(n);\\n        int ans=0;\\n        solve(0,requests,degree,0,ans);\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3706122,
                "title": "java-backtracking",
                "content": "# If You like the solution please upvote.\\n**Java Backtracking**\\n```\\n\\nclass Solution {\\n    private int maxRequests;\\n\\n    public int maximumRequests(int n, int[][] requests) {\\n        maxRequests = 0;\\n        int[] employees = new int[n];\\n        backtrack(requests, employees, 0, 0);\\n        return maxRequests;\\n    }\\n\\n    private void backtrack(int[][] requests, int[] employees, int index, int count) {\\n        if (index == requests.length) {\\n            if (isAchievable(employees)) {\\n                maxRequests = Math.max(maxRequests, count);\\n            }\\n            return;\\n        }\\n\\n        int from = requests[index][0];\\n        int to = requests[index][1];\\n\\n        employees[from]--;\\n        employees[to]++;\\n\\n        backtrack(requests, employees, index + 1, count + 1);\\n\\n        employees[from]++;\\n        employees[to]--;\\n\\n        backtrack(requests, employees, index + 1, count);\\n    }\\n\\n    private boolean isAchievable(int[] employees) {\\n        for (int count : employees) {\\n            if (count != 0) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Backtracking"
                ],
                "code": "```\\n\\nclass Solution {\\n    private int maxRequests;\\n\\n    public int maximumRequests(int n, int[][] requests) {\\n        maxRequests = 0;\\n        int[] employees = new int[n];\\n        backtrack(requests, employees, 0, 0);\\n        return maxRequests;\\n    }\\n\\n    private void backtrack(int[][] requests, int[] employees, int index, int count) {\\n        if (index == requests.length) {\\n            if (isAchievable(employees)) {\\n                maxRequests = Math.max(maxRequests, count);\\n            }\\n            return;\\n        }\\n\\n        int from = requests[index][0];\\n        int to = requests[index][1];\\n\\n        employees[from]--;\\n        employees[to]++;\\n\\n        backtrack(requests, employees, index + 1, count + 1);\\n\\n        employees[from]++;\\n        employees[to]--;\\n\\n        backtrack(requests, employees, index + 1, count);\\n    }\\n\\n    private boolean isAchievable(int[] employees) {\\n        for (int count : employees) {\\n            if (count != 0) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 877447,
                "title": "python-divide-and-conquer-98-82",
                "content": "# Dividing The Problem\\nThe problem is divided along an unintuitive dimension - the number of edges in a path. (similar to Bellman-Ford, Floyd-Warshall etc.). This allows us to construct bigger paths from smaller ones, eliminating the need for enumerating all subsets of edges.\\n\\n# Combining the Solutions\\nWhenever we detect a cycle, we *merge* the cycle to the existing solution cycles by adding the new cycle and removing the existing overlapping cycles. If the new cycle leads to more edges being added, we add it to the solution otherwise we ignore it. Because every new cycle found is at least as big as the existing ones, we can combine the cycles in linear time.\\n\\n# Complexity\\nGuess it\\'s around O(P) where P is the total number of edges in all paths. (I\\'m not good at finding complexity). I think O(P) is the best we can do for this problem as we have to enumerate all the paths to even understand the input.\\n\\n```\\nclass Solution:\\n    def maximumRequests(self, n: int, requests: List[List[int]]) -> int:\\n            def cyclic(path): return requests[path[0]][0]==requests[path[-1]][1]\\n            def joins(path, e): return requests[e][0] == requests[path[-1]][1]\\n            def overlapping(c1, c2): return any([True for e in c1 if e in c2])\\n            def include(cycle, cycles): return [c for c in cycles if not overlapping(c, cycle)] + [cycle]\\n            def value(c): return len(sum(c,[]))\\n\\n            cycles = [[e] for e in range(len(requests)) if requests[e][0]==requests[e][1]]\\n            paths = [[e] for e in range(len(requests))]\\n            new_paths = []\\n            for i in range(2, n+1):                \\n                for path in paths:                    \\n                    for e in [ e for e in range(len(requests)) if e not in path and joins(path,e) ]:                        \\n                        if cyclic(path+[e]):                            \\n                            new_res = include(path+[e], cycles)                            \\n                            if value(new_res) > value(cycles):\\n                                cycles = new_res\\n                        else:\\n                            new_paths.append(path+[e])                    \\n                paths = new_paths\\n                new_paths = []        \\n            return value(cycles)\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Divide and Conquer"
                ],
                "code": "```\\nclass Solution:\\n    def maximumRequests(self, n: int, requests: List[List[int]]) -> int:\\n            def cyclic(path): return requests[path[0]][0]==requests[path[-1]][1]\\n            def joins(path, e): return requests[e][0] == requests[path[-1]][1]\\n            def overlapping(c1, c2): return any([True for e in c1 if e in c2])\\n            def include(cycle, cycles): return [c for c in cycles if not overlapping(c, cycle)] + [cycle]\\n            def value(c): return len(sum(c,[]))\\n\\n            cycles = [[e] for e in range(len(requests)) if requests[e][0]==requests[e][1]]\\n            paths = [[e] for e in range(len(requests))]\\n            new_paths = []\\n            for i in range(2, n+1):                \\n                for path in paths:                    \\n                    for e in [ e for e in range(len(requests)) if e not in path and joins(path,e) ]:                        \\n                        if cyclic(path+[e]):                            \\n                            new_res = include(path+[e], cycles)                            \\n                            if value(new_res) > value(cycles):\\n                                cycles = new_res\\n                        else:\\n                            new_paths.append(path+[e])                    \\n                paths = new_paths\\n                new_paths = []        \\n            return value(cycles)\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3706095,
                "title": "w-explanation-c-bitmask-sorting-masks-w-r-t-hamming-weight",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe given code calculates the maximum number of requests that can be fulfilled. It iterates over all combinations of requests using bit manipulation. For each combination, it checks if the incoming and outgoing requests are balanced. If so, it counts the number of requests and returns the maximum count found.\\n\\nOther approach uses sorting masks w.r.t Hamming Weight in descending order. No need for brute force!!!!!!\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nOne example for sorting partial masks w.r.t. Hamming weight in descending order!\\n```\\n8191,8190,8189,8187,8183,8175,8159,8127,8063,7935,7679,7167,6143,4095,8188,8186,8185,8182,8181,8179,8174,8173,8171,8167,8158,8157,8155,8151,8143,8126,8125,8123,8119,8111,8095,8062,8061,8059,8055,8047,8031,7999,7934,7933,7931,7927,7919,7903,7871,7807,7678,7677,7675,7671,7663,7647,7615,7551,7423,7166,7165,7163,7159,7151,7135,7103,7039,6911,6655,6142,6141,6139,6135,6127,6111,6079,6015,5887,5631,5119,4094,4093,4091,4087,4079,4063,4031,3967,3839,3583,3071,2047,8184,8180,8178,8177,8172,8170,8169,8166,8165,8163,8156,8154,8153,8150,8149,8147,8142,8141,8139,8135,8124,8122,8121,8118,8117,8115,8110,8109,8107,8103,8094,8093,8091,8087,8079,8060,8058,8057,8054,8053,8051,8046,8045,8043,8039,8030,8029,8027,8023,8015,7998,7997,7995,7991,7983,7967,7932,7930,7929,7926,7925,7923,7918,7917,7915,7911,7902,7901,7899,7895,7887,7870,7869,7867,7863,7855,7839,7806,7805,7803,7799,7791,7775,7743,7676,7674,7673,7670,7669,7667,7662,7661,7659,7655,7646,7645,7643,7639,7631,7614,7613,7611,7607,7599,7583,7550,7549,7547,7543,7535,7519,7487,7422,7421,7419,7415,7407,7391,7359,7295,7164,7162,7161,7158,7157,7155,7150,7149,7147,7143,7134,7133,7131,7127,7119,7102,7101,7099,7095,7087,7071,7038,7037,7035,7031,7023,7007,6975,6910,6909,6907,6903,6895,6879,6847,6783,6654,6653,6651,6647,6639,6623,6591,6527,6399,6140,6138,6137,6134,6133,6131,6126,6125,6123,6119,6110,6109,6107,6103,6095,6078,6077,6075,6071,6063,6047,6014,6013,6011,6007,5999,5983,5951,5886,5885,5883,5879,5871,5855,5823,5759,5630,5629,5627,5623,5615,5599,5567,5503,5375,5118,5117,5115,5111,5103,5087,5055,4991,4863,4607,4092,4090,4089,4086,4085,4083,4078,4077,4075,4071,4062,4061,4059,4055,4047,4030,4029,4027,4023,4015,3999,3966,3965,3963,3959,3951,3935,3903,3838,3837,3835,3831,3823,3807,3775,3711,\\n```\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$O(2^r*n)$\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$O(n)$\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int reqSubset(int mask, int r, int n, vector<vector<int>>& requests){\\n        vector<int> indeg(n ,0), outdeg(n, 0);\\n        bitset<16> bmask(mask);\\n        for(int i=0; i<r; i++)\\n            if(bmask[i]){\\n                indeg[requests[i][1]]++;\\n                outdeg[requests[i][0]]++;\\n            }     \\n        if (indeg==outdeg)\\n            return bmask.count();   \\n        else \\n            return 0;\\n    }\\n    int maximumRequests(int n, vector<vector<int>>& requests) {\\n        int r=requests.size();\\n        int ans=0;\\n        \\n        int reqMask=(1<<r)-1;//all combination bits are set 1\\n        for (int mask=1; mask<=reqMask; mask++){\\n            ans=max(ans, reqSubset(mask, r, n, requests));\\n        }   \\n        return ans;\\n    }\\n};\\n```\\n# Code with Explanation in comments\\n```\\nclass Solution {\\npublic:\\n    int reqSubset(int mask, int r, int n, vector<vector<int>>& requests) {\\n        // Create vectors to track the incoming and outgoing requests for each node\\n        vector<int> indeg(n, 0), outdeg(n, 0);\\n\\n        // Convert the mask into a bitset to iterate over the bits\\n        bitset<16> bmask(mask);\\n\\n        // Iterate over the requests\\n        for (int i = 0; i < r; i++) {\\n            // Check if the corresponding bit in the mask is set\\n            if (bmask[i]) {\\n                // Increment the incoming and outgoing request counts for the nodes\\n                indeg[requests[i][1]]++;\\n                outdeg[requests[i][0]]++;\\n            }\\n        }\\n\\n        // Check if the incoming and outgoing request counts are equal\\n        if (indeg == outdeg) {\\n            // Return the number of set bits in the bitset (number of requests)\\n            return bmask.count();\\n        } else {\\n            // Return 0 if the requests are not balanced\\n            return 0;\\n        }\\n    }\\n\\n    int maximumRequests(int n, vector<vector<int>>& requests) {\\n        int r = requests.size();\\n        int ans = 0;\\n\\n        // Calculate the maximum mask value for all combinations of requests\\n        int reqMask = (1 << r) - 1; // all combination bits are set to 1\\n\\n        // Iterate over all possible mask values\\n        for (int mask = 1; mask <= reqMask; mask++) {\\n            // Find the maximum number of requests that can be fulfilled\\n            ans = max(ans, reqSubset(mask, r, n, requests));\\n        }\\n\\n        // Return the maximum number of requests that can be fulfilled\\n        return ans;\\n    }\\n};\\n\\n```\\n# Solution using sorting Masks w.r.t Hamming Weight in descending order. No need for brute force\\n```\\nclass Solution {\\npublic:\\n    int reqSubset(int mask, int r, int n, vector<vector<int>>& requests){\\n        vector<int> indeg(n ,0), outdeg(n, 0);\\n        for(int i=0; i<r; i++)\\n            if(mask& (1<<i)){\\n                indeg[requests[i][1]]++;\\n                outdeg[requests[i][0]]++;\\n            }     \\n        if (indeg==outdeg)\\n            return __builtin_popcount(mask);   \\n        else \\n            return 0;\\n    }\\n\\n    int maximumRequests(int n, vector<vector<int>>& requests) {\\n        int r=requests.size();\\n        int ans=0;\\n        \\n        int reqMask=(1<<r)-1;//all combination bits are set to 1\\n        //Sort the masks according Hamming weight in descending order\\n        vector<int> masks(1<<r);\\n        iota(masks.begin(), masks.end(), 0);\\n        sort(masks.begin(), masks.end(), [&](auto &a, auto &b) {\\n            auto aa = __builtin_popcount(a);\\n            auto bb = __builtin_popcount(b);\\n            return (aa > bb) || (aa == bb) && (a > b);\\n        });\\n\\n        for (int mask: masks){\\n        //    cout<<mask<<endl;\\n            ans=max(ans, reqSubset(mask, r, n, requests));\\n            if (ans>0) break; //It\\'s fine! just O(1) tries\\n        }   \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Bit Manipulation",
                    "Graph"
                ],
                "code": "```\\n8191,8190,8189,8187,8183,8175,8159,8127,8063,7935,7679,7167,6143,4095,8188,8186,8185,8182,8181,8179,8174,8173,8171,8167,8158,8157,8155,8151,8143,8126,8125,8123,8119,8111,8095,8062,8061,8059,8055,8047,8031,7999,7934,7933,7931,7927,7919,7903,7871,7807,7678,7677,7675,7671,7663,7647,7615,7551,7423,7166,7165,7163,7159,7151,7135,7103,7039,6911,6655,6142,6141,6139,6135,6127,6111,6079,6015,5887,5631,5119,4094,4093,4091,4087,4079,4063,4031,3967,3839,3583,3071,2047,8184,8180,8178,8177,8172,8170,8169,8166,8165,8163,8156,8154,8153,8150,8149,8147,8142,8141,8139,8135,8124,8122,8121,8118,8117,8115,8110,8109,8107,8103,8094,8093,8091,8087,8079,8060,8058,8057,8054,8053,8051,8046,8045,8043,8039,8030,8029,8027,8023,8015,7998,7997,7995,7991,7983,7967,7932,7930,7929,7926,7925,7923,7918,7917,7915,7911,7902,7901,7899,7895,7887,7870,7869,7867,7863,7855,7839,7806,7805,7803,7799,7791,7775,7743,7676,7674,7673,7670,7669,7667,7662,7661,7659,7655,7646,7645,7643,7639,7631,7614,7613,7611,7607,7599,7583,7550,7549,7547,7543,7535,7519,7487,7422,7421,7419,7415,7407,7391,7359,7295,7164,7162,7161,7158,7157,7155,7150,7149,7147,7143,7134,7133,7131,7127,7119,7102,7101,7099,7095,7087,7071,7038,7037,7035,7031,7023,7007,6975,6910,6909,6907,6903,6895,6879,6847,6783,6654,6653,6651,6647,6639,6623,6591,6527,6399,6140,6138,6137,6134,6133,6131,6126,6125,6123,6119,6110,6109,6107,6103,6095,6078,6077,6075,6071,6063,6047,6014,6013,6011,6007,5999,5983,5951,5886,5885,5883,5879,5871,5855,5823,5759,5630,5629,5627,5623,5615,5599,5567,5503,5375,5118,5117,5115,5111,5103,5087,5055,4991,4863,4607,4092,4090,4089,4086,4085,4083,4078,4077,4075,4071,4062,4061,4059,4055,4047,4030,4029,4027,4023,4015,3999,3966,3965,3963,3959,3951,3935,3903,3838,3837,3835,3831,3823,3807,3775,3711,\\n```\n```\\nclass Solution {\\npublic:\\n    int reqSubset(int mask, int r, int n, vector<vector<int>>& requests){\\n        vector<int> indeg(n ,0), outdeg(n, 0);\\n        bitset<16> bmask(mask);\\n        for(int i=0; i<r; i++)\\n            if(bmask[i]){\\n                indeg[requests[i][1]]++;\\n                outdeg[requests[i][0]]++;\\n            }     \\n        if (indeg==outdeg)\\n            return bmask.count();   \\n        else \\n            return 0;\\n    }\\n    int maximumRequests(int n, vector<vector<int>>& requests) {\\n        int r=requests.size();\\n        int ans=0;\\n        \\n        int reqMask=(1<<r)-1;//all combination bits are set 1\\n        for (int mask=1; mask<=reqMask; mask++){\\n            ans=max(ans, reqSubset(mask, r, n, requests));\\n        }   \\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int reqSubset(int mask, int r, int n, vector<vector<int>>& requests) {\\n        // Create vectors to track the incoming and outgoing requests for each node\\n        vector<int> indeg(n, 0), outdeg(n, 0);\\n\\n        // Convert the mask into a bitset to iterate over the bits\\n        bitset<16> bmask(mask);\\n\\n        // Iterate over the requests\\n        for (int i = 0; i < r; i++) {\\n            // Check if the corresponding bit in the mask is set\\n            if (bmask[i]) {\\n                // Increment the incoming and outgoing request counts for the nodes\\n                indeg[requests[i][1]]++;\\n                outdeg[requests[i][0]]++;\\n            }\\n        }\\n\\n        // Check if the incoming and outgoing request counts are equal\\n        if (indeg == outdeg) {\\n            // Return the number of set bits in the bitset (number of requests)\\n            return bmask.count();\\n        } else {\\n            // Return 0 if the requests are not balanced\\n            return 0;\\n        }\\n    }\\n\\n    int maximumRequests(int n, vector<vector<int>>& requests) {\\n        int r = requests.size();\\n        int ans = 0;\\n\\n        // Calculate the maximum mask value for all combinations of requests\\n        int reqMask = (1 << r) - 1; // all combination bits are set to 1\\n\\n        // Iterate over all possible mask values\\n        for (int mask = 1; mask <= reqMask; mask++) {\\n            // Find the maximum number of requests that can be fulfilled\\n            ans = max(ans, reqSubset(mask, r, n, requests));\\n        }\\n\\n        // Return the maximum number of requests that can be fulfilled\\n        return ans;\\n    }\\n};\\n\\n```\n```\\nclass Solution {\\npublic:\\n    int reqSubset(int mask, int r, int n, vector<vector<int>>& requests){\\n        vector<int> indeg(n ,0), outdeg(n, 0);\\n        for(int i=0; i<r; i++)\\n            if(mask& (1<<i)){\\n                indeg[requests[i][1]]++;\\n                outdeg[requests[i][0]]++;\\n            }     \\n        if (indeg==outdeg)\\n            return __builtin_popcount(mask);   \\n        else \\n            return 0;\\n    }\\n\\n    int maximumRequests(int n, vector<vector<int>>& requests) {\\n        int r=requests.size();\\n        int ans=0;\\n        \\n        int reqMask=(1<<r)-1;//all combination bits are set to 1\\n        //Sort the masks according Hamming weight in descending order\\n        vector<int> masks(1<<r);\\n        iota(masks.begin(), masks.end(), 0);\\n        sort(masks.begin(), masks.end(), [&](auto &a, auto &b) {\\n            auto aa = __builtin_popcount(a);\\n            auto bb = __builtin_popcount(b);\\n            return (aa > bb) || (aa == bb) && (a > b);\\n        });\\n\\n        for (int mask: masks){\\n        //    cout<<mask<<endl;\\n            ans=max(ans, reqSubset(mask, r, n, requests));\\n            if (ans>0) break; //It\\'s fine! just O(1) tries\\n        }   \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 866407,
                "title": "python-bitmasks-time-complexity-2-number-of-requests",
                "content": "```\\nclass Solution:\\n    def maximumRequests(self, n: int, requests: List[List[int]]) -> int:\\n        # ans will hold max number of transfers such that net value(indegree-outdegree) = 0\\n        ans = 0\\n        \\n        # total number of request (Each request represent one transfer)\\n        m = len(requests)\\n        \\n        # Generating all bitmasks where 1 in each bitmask means we will consider this request.\\n        for mask in range(1,(2**m)+1):\\n            \\n            # indeg will hold net value (indegree-outdegree) of each office\\n            indeg = [0 for i in range(n)]\\n            \\n            # number of on bits in the mask\\n            onbit = 0\\n            \\n            for j in range(m):\\n                # checking which bit is on.\\n                if ((mask>>j)&1)==1:\\n                    # for outdegree -1 and for indegree +1 respective nodes\\n                    cur = requests[j]\\n                    indeg[cur[0]]-=1\\n                    indeg[cur[1]]+=1\\n                    onbit+=1\\n                    \\n            # if all the nodes in the indegree have 0 net value then we will take max ans\\n            f = 0\\n            for j in indeg:\\n                if j!=0:\\n                    f = 1\\n            if f==0:\\n                ans = max(ans,onbit)\\n        return ans\\n                \\n                \\n        \\n```",
                "solutionTags": [
                    "Python3",
                    "Bitmask"
                ],
                "code": "```\\nclass Solution:\\n    def maximumRequests(self, n: int, requests: List[List[int]]) -> int:\\n        # ans will hold max number of transfers such that net value(indegree-outdegree) = 0\\n        ans = 0\\n        \\n        # total number of request (Each request represent one transfer)\\n        m = len(requests)\\n        \\n        # Generating all bitmasks where 1 in each bitmask means we will consider this request.\\n        for mask in range(1,(2**m)+1):\\n            \\n            # indeg will hold net value (indegree-outdegree) of each office\\n            indeg = [0 for i in range(n)]\\n            \\n            # number of on bits in the mask\\n            onbit = 0\\n            \\n            for j in range(m):\\n                # checking which bit is on.\\n                if ((mask>>j)&1)==1:\\n                    # for outdegree -1 and for indegree +1 respective nodes\\n                    cur = requests[j]\\n                    indeg[cur[0]]-=1\\n                    indeg[cur[1]]+=1\\n                    onbit+=1\\n                    \\n            # if all the nodes in the indegree have 0 net value then we will take max ans\\n            f = 0\\n            for j in indeg:\\n                if j!=0:\\n                    f = 1\\n            if f==0:\\n                ans = max(ans,onbit)\\n        return ans\\n                \\n                \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3733391,
                "title": "python-3-5-lines-combinations-w-explanation-t-m-91-98",
                "content": "Here\\'s how the code works:\\n\\n1. We use a brute-force approach to find the maximum number of achievable requests (`cnt`). It starts by considering the maximum possible number of requests (`len(requests)`), and decrementing `cnt` until either a solution is found or we exhaust all possibilities.\\n\\n1. We iterate in reverse order over the range from 1 to `len(requests)`. For each iteration, we consider all combinations of requests with the given count. \\n\\n1. For each combination, we unzip combinations to lists of`to`and`frm`. If`to`and`frm` have the same elements for some combination (which we check with `sorted(to) == sorted(frm)`) then we return`cnt`as the solution. If no such combination exists, we return 0.\\n```\\nclass Solution:\\n    def maximumRequests(self, n: int, requests: List[List[int]]) -> int:\\n\\n        for cnt in reversed(range(1, len(requests)+1)):\\n        \\n            for com in combinations(requests,cnt):\\n                to, frm = map(sorted,zip(*com))\\n                if sorted(to) == sorted(frm): return cnt\\n\\n        return 0\\n```\\n[https://leetcode.com/problems/maximum-number-of-achievable-transfer-requests/submissions/988756024/](http://)\\n\\nPython 3   ||   5 lines,  combinations, w/ explanation   ||   T/M: 91% / 98%\\n\\nI could be wrong, but I think that time complexity (worst case) is *O*(2^*M* * *MN*log*N*) and space complexity is *O*(*M*), in which *M* ~ `len(requests)` and  *N* ~ `n`.",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maximumRequests(self, n: int, requests: List[List[int]]) -> int:\\n\\n        for cnt in reversed(range(1, len(requests)+1)):\\n        \\n            for com in combinations(requests,cnt):\\n                to, frm = map(sorted,zip(*com))\\n                if sorted(to) == sorted(frm): return cnt\\n\\n        return 0\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3709615,
                "title": "c-simplest-explanation-why-backtracking-codestorywithmik",
                "content": "My YouTube Video Link - [Maximum Number of Achievable Transfer Requests](https://www.youtube.com/watch?v=eY4PHr1DPp0)\\nMy Github Treasure       - [Maximum Number of Achievable Transfer Requests](https://github.com/MAZHARMIK/Interview_DS_Algo/blob/master/Backtracking/Maximum%20Number%20of%20Achievable%20Transfer%20Requests.cpp)\\n\\n```\\n/*\\nTime complexity: O((2^m) * N)\\n\\nWe iterate over every two possibilities for each of the M requests \\nThis is equal to 2^M possibilities. \\nAt the end we will iterate over N buildings to check if the employee change is zero which takes O(N)\\n*/\\n\\nclass Solution {\\npublic:\\n    int m;\\n    int result = INT_MIN;\\n    \\n    void solve(int idx, int count, int n, vector<int>& resultant, vector<vector<int>>& requests) {\\n        if(idx == m) {\\n            \\n            int allZero = true;\\n            for(int &x : resultant) {\\n                if(x != 0) {\\n                    allZero = false;\\n                    break;\\n                }\\n            }\\n            \\n            if(allZero) {\\n                result = max(result, count);\\n            }\\n            return;\\n        }\\n        \\n        \\n        int from = requests[idx][0];\\n        int to   = requests[idx][1];\\n        \\n        resultant[from]--;\\n        resultant[to]++;\\n        solve(idx+1, count+1, n, resultant, requests);\\n        \\n        resultant[from]++;\\n        resultant[to]--;\\n        solve(idx+1, count, n, resultant, requests);\\n    }\\n    \\n    int maximumRequests(int n, vector<vector<int>>& requests) {\\n        m = requests.size();\\n        \\n        vector<int> resultant(n, 0);\\n        \\n        solve(0, 0, n, resultant, requests);\\n        \\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/*\\nTime complexity: O((2^m) * N)\\n\\nWe iterate over every two possibilities for each of the M requests \\nThis is equal to 2^M possibilities. \\nAt the end we will iterate over N buildings to check if the employee change is zero which takes O(N)\\n*/\\n\\nclass Solution {\\npublic:\\n    int m;\\n    int result = INT_MIN;\\n    \\n    void solve(int idx, int count, int n, vector<int>& resultant, vector<vector<int>>& requests) {\\n        if(idx == m) {\\n            \\n            int allZero = true;\\n            for(int &x : resultant) {\\n                if(x != 0) {\\n                    allZero = false;\\n                    break;\\n                }\\n            }\\n            \\n            if(allZero) {\\n                result = max(result, count);\\n            }\\n            return;\\n        }\\n        \\n        \\n        int from = requests[idx][0];\\n        int to   = requests[idx][1];\\n        \\n        resultant[from]--;\\n        resultant[to]++;\\n        solve(idx+1, count+1, n, resultant, requests);\\n        \\n        resultant[from]++;\\n        resultant[to]--;\\n        solve(idx+1, count, n, resultant, requests);\\n    }\\n    \\n    int maximumRequests(int n, vector<vector<int>>& requests) {\\n        m = requests.size();\\n        \\n        vector<int> resultant(n, 0);\\n        \\n        solve(0, 0, n, resultant, requests);\\n        \\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3708919,
                "title": "backtracking-cpp",
                "content": "\\n\\n# Code\\n```\\nclass Solution \\n{\\npublic:\\n    int ans = 0;\\n    void check(vector<int>& indegree , vector<vector<int>>& req , int n , int currind , int cnt)\\n    {\\n        //when we accept or reject all req\\n        if(currind == req.size())\\n        {\\n            for(int i=0;i<n;i++)\\n            {\\n                if(indegree[i]!=0) //when net indegree of building is not zero\\n                {\\n                    return;\\n                }\\n            }\\n            ans = max(ans,cnt);\\n            return;\\n        }\\n\\n\\n        //when we accept req\\n        indegree[req[currind][0]]--;\\n        indegree[req[currind][1]]++;\\n        check(indegree , req , n , currind+1 , cnt+1);\\n\\n        //whenn we reject req\\n        indegree[req[currind][0]]++;\\n        indegree[req[currind][1]]--;\\n        check(indegree , req , n , currind+1 , cnt);\\n        \\n    }\\n    int maximumRequests(int n, vector<vector<int>>& req) \\n    {\\n        vector<int> indegree(n,0);  //net indegeree of all building should be zero\\n        check(indegree,req,n,0,0);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution \\n{\\npublic:\\n    int ans = 0;\\n    void check(vector<int>& indegree , vector<vector<int>>& req , int n , int currind , int cnt)\\n    {\\n        //when we accept or reject all req\\n        if(currind == req.size())\\n        {\\n            for(int i=0;i<n;i++)\\n            {\\n                if(indegree[i]!=0) //when net indegree of building is not zero\\n                {\\n                    return;\\n                }\\n            }\\n            ans = max(ans,cnt);\\n            return;\\n        }\\n\\n\\n        //when we accept req\\n        indegree[req[currind][0]]--;\\n        indegree[req[currind][1]]++;\\n        check(indegree , req , n , currind+1 , cnt+1);\\n\\n        //whenn we reject req\\n        indegree[req[currind][0]]++;\\n        indegree[req[currind][1]]--;\\n        check(indegree , req , n , currind+1 , cnt);\\n        \\n    }\\n    int maximumRequests(int n, vector<vector<int>>& req) \\n    {\\n        vector<int> indegree(n,0);  //net indegeree of all building should be zero\\n        check(indegree,req,n,0,0);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3708337,
                "title": "c-solution-for-maximum-number-of-achievable-transfer-requests-problem",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe intuition behind the solution is to use bitmasking to generate all possible combinations of requests and check if each combination results in a valid distribution of employees among the buildings.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- Iterate through all possible combinations of requests using bitmasking.\\n- For each combination, calculate the net change in employee transfers for each building by decrementing the employee count for the \"from\" building and incrementing it for the \"to\" building.\\n- Check if the net change is zero for all buildings, indicating a valid distribution of employees.\\n- If the distribution is valid, count the number of requests in the current combination and update the maximum achievable requests if necessary.\\n- Finally, return the maximum achievable requests.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nThe time complexity of the solution is O(2^m * n), where m is the number of requests and n is the number of buildings. This is because the solution involves iterating through all possible combinations of requests, which is 2^m, and for each combination, calculating the net change in employee transfers for each building, which takes O(n) time.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nThe space complexity of the solution is O(n), where n is the number of buildings. This is because the solution uses an array of size n to track the net change in employee transfers for each building.\\n\\n# Code\\n```\\npublic class Solution {\\n    public int MaximumRequests(int n, int[][] requests) {\\n        int m = requests.Length; // Number of requests\\n        int maxAchievable = 0; // Maximum achievable requests\\n\\n        // Iterate through all possible combinations of requests using bitmasking\\n        for (int mask = 0; mask < (1 << m); mask++) {\\n            int[] buildings = new int[n]; // Array to track the net change in employee transfers for each building\\n\\n            // Calculate the net change for each request based on the bitmask\\n            for (int i = 0; i < m; i++) {\\n                if ((mask & (1 << i)) != 0) {\\n                    int from = requests[i][0];\\n                    int to = requests[i][1];\\n                    buildings[from]--;\\n                    buildings[to]++;\\n                }\\n            }\\n\\n            // Check if the net change is zero for all buildings\\n            bool isValid = true;\\n            for (int j = 0; j < n; j++) {\\n                if (buildings[j] != 0) {\\n                    isValid = false;\\n                    break;\\n                }\\n            }\\n\\n            // Update the maximum achievable requests if the current combination is valid\\n            if (isValid) {\\n                int count = CountSetBits(mask);\\n                maxAchievable = Math.Max(maxAchievable, count);\\n            }\\n        }\\n\\n        return maxAchievable;\\n    }\\n    private int CountSetBits(int num) {\\n        int count = 0;\\n        while (num > 0) {\\n            count += num & 1;\\n            num >>= 1;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int MaximumRequests(int n, int[][] requests) {\\n        int m = requests.Length; // Number of requests\\n        int maxAchievable = 0; // Maximum achievable requests\\n\\n        // Iterate through all possible combinations of requests using bitmasking\\n        for (int mask = 0; mask < (1 << m); mask++) {\\n            int[] buildings = new int[n]; // Array to track the net change in employee transfers for each building\\n\\n            // Calculate the net change for each request based on the bitmask\\n            for (int i = 0; i < m; i++) {\\n                if ((mask & (1 << i)) != 0) {\\n                    int from = requests[i][0];\\n                    int to = requests[i][1];\\n                    buildings[from]--;\\n                    buildings[to]++;\\n                }\\n            }\\n\\n            // Check if the net change is zero for all buildings\\n            bool isValid = true;\\n            for (int j = 0; j < n; j++) {\\n                if (buildings[j] != 0) {\\n                    isValid = false;\\n                    break;\\n                }\\n            }\\n\\n            // Update the maximum achievable requests if the current combination is valid\\n            if (isValid) {\\n                int count = CountSetBits(mask);\\n                maxAchievable = Math.Max(maxAchievable, count);\\n            }\\n        }\\n\\n        return maxAchievable;\\n    }\\n    private int CountSetBits(int num) {\\n        int count = 0;\\n        while (num > 0) {\\n            count += num & 1;\\n            num >>= 1;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3707594,
                "title": "backtracking-c-python-golang",
                "content": "# Code\\n```C++ []\\nclass Solution {\\npublic:\\n    int maximumRequests(int n, vector<vector<int>>& requests) {\\n        int answer = 0;\\n        vector<int> indegree(n, 0);\\n\\n        function<void(int, int)> maxRequest = [&](int index, int count) {\\n            if (index == requests.size()) {\\n                for (int i = 0; i < n; i++) {\\n                    if (indegree[i]) {\\n                        return;\\n                    }\\n                }\\n                answer = max(answer, count);\\n                return;\\n            }\\n\\n            indegree[requests[index][0]]--;\\n            indegree[requests[index][1]]++;\\n\\n            maxRequest(index + 1, count + 1);\\n\\n            indegree[requests[index][0]]++;\\n            indegree[requests[index][1]]--;\\n\\n            maxRequest(index + 1, count);\\n        };\\n\\n        maxRequest(0, 0);\\n\\n        return answer;\\n    }\\n};\\n```\\n```Python []\\nclass Solution:\\n    def maximumRequests(self, n: int, requests: List[List[int]]) -> int:\\n        answer = 0\\n        indegree = [0 for _ in range(n)]\\n\\n        def maxRequest(index, count):\\n            if(index == len(requests)):\\n                for i in range(n):\\n                    if(indegree[i]):\\n                        return\\n                nonlocal answer\\n                answer = max(answer, count)\\n                return\\n\\n            indegree[requests[index][0]] -= 1\\n            indegree[requests[index][1]] += 1\\n\\n            maxRequest(index + 1, count + 1)\\n\\n            indegree[requests[index][0]] += 1\\n            indegree[requests[index][1]] -= 1\\n\\n            maxRequest(index + 1, count)\\n\\n        maxRequest(0, 0)\\n\\n        return answer\\n```\\n```Go []\\nfunc maximumRequests(n int, requests [][]int) int {\\n    answer := 0\\n    indegree := make([]int, n)\\n\\n    var maxRequest func(int, int)\\n\\n    maxRequest = func (index, count int) {\\n        if(index == len(requests)) {\\n            for i := 0; i < n; i++ {\\n                if(indegree[i] != 0) {\\n                    return;\\n                }\\n            }\\n\\n            if(count > answer) {\\n                answer = count\\n            }\\n            return\\n        }\\n\\n        indegree[requests[index][0]] --;\\n        indegree[requests[index][1]] ++;\\n\\n        maxRequest(index + 1, count + 1)\\n\\n        indegree[requests[index][0]] ++;\\n        indegree[requests[index][1]] --;\\n\\n        maxRequest(index + 1, count)\\n    }\\n\\n    maxRequest(0, 0)\\n\\n    return answer\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "Python3",
                    "Go",
                    "Backtracking"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    int maximumRequests(int n, vector<vector<int>>& requests) {\\n        int answer = 0;\\n        vector<int> indegree(n, 0);\\n\\n        function<void(int, int)> maxRequest = [&](int index, int count) {\\n            if (index == requests.size()) {\\n                for (int i = 0; i < n; i++) {\\n                    if (indegree[i]) {\\n                        return;\\n                    }\\n                }\\n                answer = max(answer, count);\\n                return;\\n            }\\n\\n            indegree[requests[index][0]]--;\\n            indegree[requests[index][1]]++;\\n\\n            maxRequest(index + 1, count + 1);\\n\\n            indegree[requests[index][0]]++;\\n            indegree[requests[index][1]]--;\\n\\n            maxRequest(index + 1, count);\\n        };\\n\\n        maxRequest(0, 0);\\n\\n        return answer;\\n    }\\n};\\n```\n```Python []\\nclass Solution:\\n    def maximumRequests(self, n: int, requests: List[List[int]]) -> int:\\n        answer = 0\\n        indegree = [0 for _ in range(n)]\\n\\n        def maxRequest(index, count):\\n            if(index == len(requests)):\\n                for i in range(n):\\n                    if(indegree[i]):\\n                        return\\n                nonlocal answer\\n                answer = max(answer, count)\\n                return\\n\\n            indegree[requests[index][0]] -= 1\\n            indegree[requests[index][1]] += 1\\n\\n            maxRequest(index + 1, count + 1)\\n\\n            indegree[requests[index][0]] += 1\\n            indegree[requests[index][1]] -= 1\\n\\n            maxRequest(index + 1, count)\\n\\n        maxRequest(0, 0)\\n\\n        return answer\\n```\n```Go []\\nfunc maximumRequests(n int, requests [][]int) int {\\n    answer := 0\\n    indegree := make([]int, n)\\n\\n    var maxRequest func(int, int)\\n\\n    maxRequest = func (index, count int) {\\n        if(index == len(requests)) {\\n            for i := 0; i < n; i++ {\\n                if(indegree[i] != 0) {\\n                    return;\\n                }\\n            }\\n\\n            if(count > answer) {\\n                answer = count\\n            }\\n            return\\n        }\\n\\n        indegree[requests[index][0]] --;\\n        indegree[requests[index][1]] ++;\\n\\n        maxRequest(index + 1, count + 1)\\n\\n        indegree[requests[index][0]] ++;\\n        indegree[requests[index][1]] --;\\n\\n        maxRequest(index + 1, count)\\n    }\\n\\n    maxRequest(0, 0)\\n\\n    return answer\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3706750,
                "title": "easy-python-solution-backtracking-dp",
                "content": "# Code\\n```\\nclass Solution:\\n    def dp(self,i,lst,requests,n,dct):\\n        if i<0:\\n            if lst[:]==[0]*n:\\n                return 0\\n            return float(\"-infinity\")\\n        if (i,tuple(lst)) in dct:\\n            return dct[(i,tuple(lst))]\\n        frm=requests[i][0]\\n        to=requests[i][1]\\n        lst[frm]-=1\\n        lst[to]+=1\\n        x=self.dp(i-1,lst,requests,n,dct)+1\\n        lst[frm]+=1\\n        lst[to]-=1\\n        y=self.dp(i-1,lst,requests,n,dct)\\n        dct[(i,tuple(lst))]=max(x,y)\\n        return max(x,y)\\n\\n\\n    def maximumRequests(self, n: int, requests: List[List[int]]) -> int:\\n        lst=[0]*n\\n        m=len(requests)\\n        ans=self.dp(m-1,lst,requests,n,{})\\n        if ans==float(\"-infinity\"):\\n            return -1\\n        return ans\\n```",
                "solutionTags": [
                    "Python3",
                    "Dynamic Programming",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution:\\n    def dp(self,i,lst,requests,n,dct):\\n        if i<0:\\n            if lst[:]==[0]*n:\\n                return 0\\n            return float(\"-infinity\")\\n        if (i,tuple(lst)) in dct:\\n            return dct[(i,tuple(lst))]\\n        frm=requests[i][0]\\n        to=requests[i][1]\\n        lst[frm]-=1\\n        lst[to]+=1\\n        x=self.dp(i-1,lst,requests,n,dct)+1\\n        lst[frm]+=1\\n        lst[to]-=1\\n        y=self.dp(i-1,lst,requests,n,dct)\\n        dct[(i,tuple(lst))]=max(x,y)\\n        return max(x,y)\\n\\n\\n    def maximumRequests(self, n: int, requests: List[List[int]]) -> int:\\n        lst=[0]*n\\n        m=len(requests)\\n        ans=self.dp(m-1,lst,requests,n,{})\\n        if ans==float(\"-infinity\"):\\n            return -1\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3706083,
                "title": "c-subset-generation-using-bitmasking-clean-code",
                "content": "We can generate all the subsets , as the number of requests is <= 16.\\nCheck if the subset satisfies the condition.\\nReturn the maximum possible size of subset which satisfies the conditions.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximumRequests(int n, vector<vector<int>>&a) {\\n        int N = (int)a.size();\\n        int ans = 0;\\n        for(int i = 0 ; i < (1 << N) ; i++) {\\n            int setbits = 0;\\n            vector<int>cnt(n,0);\\n            for(int j = 0 ; j < N ; j++) {\\n                if(((1 << j) & (i))) {\\n                    ++setbits;\\n                    cnt[a[j][0]]--;\\n                    cnt[a[j][1]]++;\\n                }\\n            }\\n            bool ok = 1;\\n            for(int j = 0 ; j < n ; j++) {\\n                if(cnt[j] != 0) ok = 0;\\n            }\\n            if(ok) {\\n                ans = max(ans,setbits);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumRequests(int n, vector<vector<int>>&a) {\\n        int N = (int)a.size();\\n        int ans = 0;\\n        for(int i = 0 ; i < (1 << N) ; i++) {\\n            int setbits = 0;\\n            vector<int>cnt(n,0);\\n            for(int j = 0 ; j < N ; j++) {\\n                if(((1 << j) & (i))) {\\n                    ++setbits;\\n                    cnt[a[j][0]]--;\\n                    cnt[a[j][1]]++;\\n                }\\n            }\\n            bool ok = 1;\\n            for(int j = 0 ; j < n ; j++) {\\n                if(cnt[j] != 0) ok = 0;\\n            }\\n            if(ok) {\\n                ans = max(ans,setbits);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2439728,
                "title": "c-simple-code-memorization-use-less-88-time",
                "content": "\\n# **If you like the implementation then Please help me by increasing my reputation. By clicking the up arrow on the left of my image.**\\n```\\nclass Solution {\\n    int m;\\n    int dfs(int idx, vector<vector<int>>& requests, vector<int> &building, int n)\\n    {\\n        if(idx == m)\\n        {\\n            for(int i = 0; i < n; i++)\\n            {\\n                if(building[i] != 0)\\n                    return INT_MIN;\\n            }\\n            return 0;\\n        }\\n        int val1 = dfs(idx+1, requests, building, n);\\n        building[requests[idx][0]]--;\\n        building[requests[idx][1]]++;\\n        int val2 = 1 + dfs(idx+1, requests, building, n);\\n        building[requests[idx][0]]++;\\n        building[requests[idx][1]]--;\\n        return max(val1, val2);\\n    }\\npublic:\\n    int maximumRequests(int n, vector<vector<int>>& requests) {\\n        vector<int> building(n+1,0);\\n        m = requests.size();\\n        return dfs(0, requests, building, n);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\n    int m;\\n    int dfs(int idx, vector<vector<int>>& requests, vector<int> &building, int n)\\n    {\\n        if(idx == m)\\n        {\\n            for(int i = 0; i < n; i++)\\n            {\\n                if(building[i] != 0)\\n                    return INT_MIN;\\n            }\\n            return 0;\\n        }\\n        int val1 = dfs(idx+1, requests, building, n);\\n        building[requests[idx][0]]--;\\n        building[requests[idx][1]]++;\\n        int val2 = 1 + dfs(idx+1, requests, building, n);\\n        building[requests[idx][0]]++;\\n        building[requests[idx][1]]--;\\n        return max(val1, val2);\\n    }\\npublic:\\n    int maximumRequests(int n, vector<vector<int>>& requests) {\\n        vector<int> building(n+1,0);\\n        m = requests.size();\\n        return dfs(0, requests, building, n);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 866508,
                "title": "java-easy-bitmask",
                "content": "```\\nclass Solution {\\n    \\n    public int maximumRequests(int n, int[][] A) {\\n        int res=0;\\n        int total=(1<<(A.length))-1;\\n        for(int i=1;i<=total;i++){\\n            int cur=i;\\n            int net[]=new int[n];\\n            for(int j=0;j<=A.length;j++){\\n                int b=cur&1;cur>>=1;\\n                if(b==1){\\n                    net[A[j][0]]--;\\n                    net[A[j][1]]++;\\n                }\\n            }\\n            boolean flag=true;\\n            for(int x:net){\\n                if(x!=0)flag=false;\\n            }\\n            if(flag){\\n                res=Math.max(res,Integer.bitCount(i));\\n            }\\n        }\\n        return res;\\n    }\\n    \\n    \\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    \\n    public int maximumRequests(int n, int[][] A) {\\n        int res=0;\\n        int total=(1<<(A.length))-1;\\n        for(int i=1;i<=total;i++){\\n            int cur=i;\\n            int net[]=new int[n];\\n            for(int j=0;j<=A.length;j++){\\n                int b=cur&1;cur>>=1;\\n                if(b==1){\\n                    net[A[j][0]]--;\\n                    net[A[j][1]]++;\\n                }\\n            }\\n            boolean flag=true;\\n            for(int x:net){\\n                if(x!=0)flag=false;\\n            }\\n            if(flag){\\n                res=Math.max(res,Integer.bitCount(i));\\n            }\\n        }\\n        return res;\\n    }\\n    \\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3797934,
                "title": "java-back-track-beginner-friendly",
                "content": "# Explanation:\\nThe maximumRequests function takes an integer n representing the number of buildings and a 2D vector requests containing the transfer requests.\\n- The function initializes a vector indegree of size n to keep track of the difference between incoming and outgoing requests for each building. Initially, all values are set to 0.\\n- The function then calls the helper function with the starting index as 0, the requests vector, the indegree vector, n, and a count variable set to 0.\\n- The helper function is the main backtracking function. It takes the current start index, the requests vector, the indegree vector, n, and the current count of transfer requests.\\n- If the start index is equal to the size of the requests vector, it means we have processed all transfer requests. In this case, the function checks if all buildings have balanced requests (i.e., indegree values are all 0). If so, it updates the ans variable with the maximum count of transfer requests.\\n- If the start index is not equal to the size of the requests vector, the function has two choices: take or not take the current transfer request.\\n- If we take the current transfer request, we reduce the indegree value of the source building (requests[start][0]) by 1 and increase the indegree value of the destination building (requests[start][1]) by 1. Then, we recursively call the helper function with the updated start index, requests, indegree, n, and the incremented count by 1.\\n- After the recursive call, we revert the changes made in step 7 by increasing the indegree value of the source building and decreasing the indegree value of the destination building. This step represents the \"not-take\" choice. We then recursively call the helper function with the updated start index, requests, indegree, n, and the same count value.\\n- The helper function explores all possible combinations of taking or not taking transfer requests, tracking the maximum count of transfer requests (ans) that satisfies the balanced request condition.\\n- Finally, the maximumRequests function returns the maximum count of transfer requests stored in the ans variable.\\n# Code\\n```\\nclass Solution {\\n    public int maximumRequests(int n, int[][] requests) {\\n        int[] indegree = new int[n];\\n        return helper(0, requests, indegree, n, 0);\\n    }\\n\\n    public int helper(int start, int[][] requests, int[] indegree, int n, int count) {\\n        if (start == requests.length) {\\n            for (int i = 0; i < n; i++) {\\n                if (indegree[i] != 0) {\\n                    return 0;\\n                }\\n            }\\n            return count;\\n        }\\n\\n        // Take \\n        indegree[requests[start][0]]--;\\n        indegree[requests[start][1]]++;\\n        int take = helper(start + 1, requests, indegree, n, count + 1);\\n\\n        // Not-take\\n        indegree[requests[start][0]]++;\\n        indegree[requests[start][1]]--;\\n        int notTake = helper(start + 1, requests, indegree, n, count);\\n\\n        return Math.max(take, notTake);\\n    }\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "C",
                    "JavaScript",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\n    public int maximumRequests(int n, int[][] requests) {\\n        int[] indegree = new int[n];\\n        return helper(0, requests, indegree, n, 0);\\n    }\\n\\n    public int helper(int start, int[][] requests, int[] indegree, int n, int count) {\\n        if (start == requests.length) {\\n            for (int i = 0; i < n; i++) {\\n                if (indegree[i] != 0) {\\n                    return 0;\\n                }\\n            }\\n            return count;\\n        }\\n\\n        // Take \\n        indegree[requests[start][0]]--;\\n        indegree[requests[start][1]]++;\\n        int take = helper(start + 1, requests, indegree, n, count + 1);\\n\\n        // Not-take\\n        indegree[requests[start][0]]++;\\n        indegree[requests[start][1]]--;\\n        int notTake = helper(start + 1, requests, indegree, n, count);\\n\\n        return Math.max(take, notTake);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3725571,
                "title": "cpp-backtracking-no-bitmasking",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n```\\nvoid solve(vector<vector<int>>& nums, int ind, int accept, vector<int>& cnt)\\n{\\n    // Check if all the requests have been processed\\n    if(ind==nums.size())\\n    {\\n        // Check if all the counters in \\'cnt\\' are zero, indicating a valid solution\\n        for(auto x: cnt) if(x!=0) return;\\n        \\n        // Update the maximum number of requests accepted if \\'accept\\' is greater\\n        ans = max(ans,accept);\\n        \\n        // Exit the current recursive call\\n        return;\\n    }\\n    \\n    // Decrease the counter for the source vertex of the current request\\n    cnt[nums[ind][0]]--;\\n    \\n    // Increase the counter for the destination vertex of the current request\\n    cnt[nums[ind][1]]++;\\n    \\n    // Recursively call the solve function with the next request, incrementing \\'accept\\'\\n    solve(nums,ind+1,accept+1,cnt);\\n    \\n    // Restore the counters to their original state\\n    cnt[nums[ind][0]]++;\\n    cnt[nums[ind][1]]--;\\n    \\n    // Recursively call the solve function with the next request, without incrementing \\'accept\\'\\n    solve(nums,ind+1,accept,cnt);\\n    \\n    // Exit the current recursive call\\n    return;\\n}\\n\\n```\\n\\n```\\nint maximumRequests(int n, vector<vector<int>>& nums) {\\n    // Create a vector \\'cnt\\' with \\'n\\' elements initialized to 0\\n    vector<int> cnt(n,0);\\n    \\n    // Initialize \\'accept\\' and \\'ans\\' to 0\\n    int accept = 0;\\n    ans = 0;\\n    \\n    // Call the \\'solve\\' function to find the maximum number of requests accepted\\n    solve(nums,0,accept,cnt);\\n    \\n    // Return the maximum number of requests accepted\\n    return ans;\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nvoid solve(vector<vector<int>>& nums, int ind, int accept, vector<int>& cnt)\\n{\\n    // Check if all the requests have been processed\\n    if(ind==nums.size())\\n    {\\n        // Check if all the counters in \\'cnt\\' are zero, indicating a valid solution\\n        for(auto x: cnt) if(x!=0) return;\\n        \\n        // Update the maximum number of requests accepted if \\'accept\\' is greater\\n        ans = max(ans,accept);\\n        \\n        // Exit the current recursive call\\n        return;\\n    }\\n    \\n    // Decrease the counter for the source vertex of the current request\\n    cnt[nums[ind][0]]--;\\n    \\n    // Increase the counter for the destination vertex of the current request\\n    cnt[nums[ind][1]]++;\\n    \\n    // Recursively call the solve function with the next request, incrementing \\'accept\\'\\n    solve(nums,ind+1,accept+1,cnt);\\n    \\n    // Restore the counters to their original state\\n    cnt[nums[ind][0]]++;\\n    cnt[nums[ind][1]]--;\\n    \\n    // Recursively call the solve function with the next request, without incrementing \\'accept\\'\\n    solve(nums,ind+1,accept,cnt);\\n    \\n    // Exit the current recursive call\\n    return;\\n}\\n\\n```\n```\\nint maximumRequests(int n, vector<vector<int>>& nums) {\\n    // Create a vector \\'cnt\\' with \\'n\\' elements initialized to 0\\n    vector<int> cnt(n,0);\\n    \\n    // Initialize \\'accept\\' and \\'ans\\' to 0\\n    int accept = 0;\\n    ans = 0;\\n    \\n    // Call the \\'solve\\' function to find the maximum number of requests accepted\\n    solve(nums,0,accept,cnt);\\n    \\n    // Return the maximum number of requests accepted\\n    return ans;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3710207,
                "title": "python-short-and-clean-also-a-1-liner-functional-programming",
                "content": "# Approach\\n1. Define a function `is_achievable` which returns `True` if the net change in employees transfer is zero after processing the given `reqs`.\\nThis can be computed by, checking if the difference between the counts of `from(u)` and counts of `to(v)` is all zero.\\n\\n2. Generate the `powerset` of the `requests` list excluding the empty subset. Make sure to generate it in the order of decreasing set size. This gurantees the first `subset` with `is_achievable` is the one with max requests.\\n\\n3. Select(`filter`) the subsets which `is_achievable` and return the `len` of the first such subset.\\n\\n# Complexity\\n- Time complexity: $$O(n \\\\cdot 2^m)$$\\n\\n- Space complexity: $$O(m)$$\\n\\nwhere, `m is number of requests`.\\n\\n# Code\\nSplit into 3 lines for readability. Variables can be easily substituted to make it a 1-liner, albeit a really long one.\\n```python\\nclass Solution:\\n    def maximumRequests(self, n: int, requests: list[list[int]]) -> int:\\n        is_achievable = lambda reqs: not any((Counter(u for u, _ in reqs) - Counter(v for _, v in reqs)).values())\\n        powerset_reqs = chain.from_iterable(combinations(requests, k) for k in range(len(requests), 0, -1))\\n        return next(map(len, filter(is_achievable, powerset_reqs)), 0)\\n\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Backtracking",
                    "Bit Manipulation",
                    "Enumeration"
                ],
                "code": "```python\\nclass Solution:\\n    def maximumRequests(self, n: int, requests: list[list[int]]) -> int:\\n        is_achievable = lambda reqs: not any((Counter(u for u, _ in reqs) - Counter(v for _, v in reqs)).values())\\n        powerset_reqs = chain.from_iterable(combinations(requests, k) for k in range(len(requests), 0, -1))\\n        return next(map(len, filter(is_achievable, powerset_reqs)), 0)\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3709017,
                "title": "combinations-py-python-is-op",
                "content": "<h1>DO UPVOTE\\uD83D\\uDD25\\n\\n# Approach\\nTrying Every Combination\\n\\n# Complexity\\n- Time complexity:\\n$$O(2^n)$$ \\n\\n\\n![](https://media.makeameme.org/created/leetcode-contests-these.jpg)\\n\\n\\n# Code\\n```\\nclass Solution:\\n    def maximumRequests(self, n: int, r: List[List[int]]) -> int:\\n        same=0\\n        req=[]\\n        #if both moving to same building\\n        for i in r:\\n            if i[0]==i[1]:same+=1\\n            else:req.append(i)\\n        ans=0\\n        for i in range(len(req)+1):\\n            for combs in list(itertools.combinations(req,i)):\\n                if combs:\\n                    temp=[0]*n\\n                    for at in combs:\\n                        temp[at[0]]+=1\\n                        temp[at[1]]-=1\\n                    if set(temp)=={0}:\\n                        print(combs)\\n                        ans=max(ans,len(combs))\\n        return ans+same\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maximumRequests(self, n: int, r: List[List[int]]) -> int:\\n        same=0\\n        req=[]\\n        #if both moving to same building\\n        for i in r:\\n            if i[0]==i[1]:same+=1\\n            else:req.append(i)\\n        ans=0\\n        for i in range(len(req)+1):\\n            for combs in list(itertools.combinations(req,i)):\\n                if combs:\\n                    temp=[0]*n\\n                    for at in combs:\\n                        temp[at[0]]+=1\\n                        temp[at[1]]-=1\\n                    if set(temp)=={0}:\\n                        print(combs)\\n                        ans=max(ans,len(combs))\\n        return ans+same\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3708486,
                "title": "easy-recursive-solution-with-comments-for-each-logic",
                "content": "# Intuition\\nThe given code is a recursive solution to find the maximum number of successful requests that can be accommodated based on the available spaces in different buildings.\\n\\n# Approach\\n1. The `maximumRequests` function initializes an array called `spaces` with `n` elements, representing the number of buildings. Each element is initially set to 0, indicating no available space.\\n\\n2. It calls the `getMaxReq` function, passing the initial parameters: `ind` (starting index), `requests` (the input array of requests), `spaces` array, and `countOfSuccessfulReq` (the count of successful requests).\\n\\n3. The `getMaxReq` function is a recursive function that uses Backtracking to explore different combinations of accepting or rejecting requests.\\n\\n4. The base case is when `ind` equals the length of the `requests` array, indicating that all requests have been processed.\\n\\n5. Inside the base case, it checks if all elements in the `spaces` array are `0`. If they are, it means all requests have been successfully accommodated, so it returns `countOfSuccessfulReq`.\\n\\n6. The recursive part begins by taking the current request from the `requests` array and updating the `spaces` array accordingly.\\n\\n7. It then recursively calls `getMaxReq` for the next index (`ind + 1`) while incrementing `countOfSuccessfulReq` by 1 to simulate accepting the request.\\n\\n8. After the recursive call, it reverts the changes made to the `spaces` array to simulate not accepting the request.\\n\\n9. It recursively calls `getMaxReq` again for the next index (`ind + 1`) while keeping `countOfSuccessfulReq` unchanged to simulate not accepting the request.\\n\\n10. Finally, it returns the maximum value between the results of accepting the request (`taken`) and not accepting the request (`notTaken`).\\n\\n# Complexity\\n- Exponential Time complexity: $$O(2^N)$$\\n\\n- Space complexity: $$O(N)$$\\n\\n\\n# Javascript Code\\n```\\nfunction maximumRequests(n, requests){\\n\\n    // Initially for all buildings we will have 0 space\\n    const spaces = new Array(n).fill(0);\\n    return getMaxReq(0, requests, spaces, 0);\\n};\\n\\nfunction getMaxReq(ind, req, spaces, countOfSuccessfulReq){\\n    if (ind === req.length) {\\n        // if any building have no extra spaces\\n        // means we can accept the request count\\n        // otherwise not accepting at all\\n        for(let space of spaces){\\n            if(space !== 0) return 0\\n        }\\n        return countOfSuccessfulReq;\\n    }\\n\\n    const [from, to] = req[ind];\\n    spaces[from]--;\\n    spaces[to]++;\\n    // try by accepting the request\\n    const taken = getMaxReq(ind + 1, req, spaces, countOfSuccessfulReq + 1);\\n    spaces[from]++;\\n    spaces[to]--;\\n    // try by not accepting the request\\n    const notTaken = getMaxReq(ind + 1, req, spaces, countOfSuccessfulReq);\\n    return Math.max(notTaken, taken);\\n}\\n```\\n\\n---\\n\\n# Typescript Code\\n```\\nfunction maximumRequests(n: number, requests: number[][]): number {\\n\\n    // Initially for all buildings we will have 0 space\\n    const spaces: number[] = new Array(n).fill(0);\\n    return getMaxReq(0, requests, spaces, 0);\\n};\\n\\nfunction getMaxReq(ind: number, req: number[][], spaces: number[], countOfSuccessfulReq: number): number {\\n    if (ind === req.length) {\\n        // if any building have no extra spaces\\n        // means we can accept the request count\\n        // otherwise not accepting at all\\n        for(let space of spaces){\\n            if(space !== 0) return 0\\n        }\\n        return countOfSuccessfulReq;\\n    }\\n\\n    const [from, to] = req[ind];\\n    spaces[from]--;\\n    spaces[to]++;\\n    // try by accepting the request\\n    const taken = getMaxReq(ind + 1, req, spaces, countOfSuccessfulReq + 1);\\n    spaces[from]++;\\n    spaces[to]--;\\n    // try by not accepting the request\\n    const notTaken = getMaxReq(ind + 1, req, spaces, countOfSuccessfulReq);\\n    return Math.max(notTaken, taken);\\n}\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript",
                    "Recursion"
                ],
                "code": "```\\nfunction maximumRequests(n, requests){\\n\\n    // Initially for all buildings we will have 0 space\\n    const spaces = new Array(n).fill(0);\\n    return getMaxReq(0, requests, spaces, 0);\\n};\\n\\nfunction getMaxReq(ind, req, spaces, countOfSuccessfulReq){\\n    if (ind === req.length) {\\n        // if any building have no extra spaces\\n        // means we can accept the request count\\n        // otherwise not accepting at all\\n        for(let space of spaces){\\n            if(space !== 0) return 0\\n        }\\n        return countOfSuccessfulReq;\\n    }\\n\\n    const [from, to] = req[ind];\\n    spaces[from]--;\\n    spaces[to]++;\\n    // try by accepting the request\\n    const taken = getMaxReq(ind + 1, req, spaces, countOfSuccessfulReq + 1);\\n    spaces[from]++;\\n    spaces[to]--;\\n    // try by not accepting the request\\n    const notTaken = getMaxReq(ind + 1, req, spaces, countOfSuccessfulReq);\\n    return Math.max(notTaken, taken);\\n}\\n```\n```\\nfunction maximumRequests(n: number, requests: number[][]): number {\\n\\n    // Initially for all buildings we will have 0 space\\n    const spaces: number[] = new Array(n).fill(0);\\n    return getMaxReq(0, requests, spaces, 0);\\n};\\n\\nfunction getMaxReq(ind: number, req: number[][], spaces: number[], countOfSuccessfulReq: number): number {\\n    if (ind === req.length) {\\n        // if any building have no extra spaces\\n        // means we can accept the request count\\n        // otherwise not accepting at all\\n        for(let space of spaces){\\n            if(space !== 0) return 0\\n        }\\n        return countOfSuccessfulReq;\\n    }\\n\\n    const [from, to] = req[ind];\\n    spaces[from]--;\\n    spaces[to]++;\\n    // try by accepting the request\\n    const taken = getMaxReq(ind + 1, req, spaces, countOfSuccessfulReq + 1);\\n    spaces[from]++;\\n    spaces[to]--;\\n    // try by not accepting the request\\n    const notTaken = getMaxReq(ind + 1, req, spaces, countOfSuccessfulReq);\\n    return Math.max(notTaken, taken);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3708477,
                "title": "c-solution-backtracking-easy-explanation",
                "content": "\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. The base case is checked at the beginning of the function. If `index` reaches the size of `requests`, it means we have processed all requests. \\n2. It checks if all buildings have zero employees. If not, it returns without updating the maximum requests. Otherwise, it updates the maximum requests `res` if the current number of requests `currReq` is higher.\\n\\n3. Next, it chooses not to process the current request and makes a recursive call to backtrack with the index incremented by 1.\\n\\n4. Then, it processes the current request by updating the number of `employees` in the from and to buildings accordingly. After that, it makes another recursive call to backtrack with index incremented by 1 and currReq incremented by 1.\\n\\n5. Finally, it performs the backtrack step by undoing the changes made to the employees vector.\\n\\n6. The `maximumRequests` function is the entry point of the algorithm. It initializes the maxiReq variable to store the maximum achievable requests. It also initializes the employees vector with zeros.\\n\\n7. Then, it calls the `backtrack `function to perform the backtracking process with the initial values.\\n\\n8. Finally, it returns the `maxiReq`, which holds the maximum number of achievable requests.\\n\\n# Complexity\\n $$N$$ is the number of buildings, and $$M$$ is the number of requests.\\n- Time complexity:$$O(2^ \\nM\\n \\u2217N). $$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(N+M)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void backtrack(int n,vector<vector<int>>& requests,vector<int>&employees,int &res,int index,int currReq){\\n     //base case\\n     if(index==requests.size()){\\n        \\n        for(int i=0;i<n;i++){\\n            if(employees[i]){\\n                return;\\n            }\\n        }\\n\\n         res=max(res,currReq);\\n         return;\\n     }\\n      // Choose not to process the current request\\n      backtrack(n,requests,employees,res,index+1,currReq);\\n\\n      //process the current request\\n      int from=requests[index][0];\\n      int to=requests[index][1];\\n\\n      employees[from]--;//employess leaving \\'from\\' building \\n      employees[to]++;  //employees moving \\'to\\' building\\n\\n  \\n        backtrack(n,requests,employees,res,index+1,currReq+1);\\n  \\n\\n      //backtrack\\n      employees[from]++;\\n      employees[to]--;\\n      \\n    }\\n    int maximumRequests(int n, vector<vector<int>>& requests) {\\n        \\n        int maxiReq=0;\\n\\n        vector<int>employees(n,0);\\n\\n        backtrack(n,requests,employees,maxiReq,0,0);\\n\\n        return maxiReq;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void backtrack(int n,vector<vector<int>>& requests,vector<int>&employees,int &res,int index,int currReq){\\n     //base case\\n     if(index==requests.size()){\\n        \\n        for(int i=0;i<n;i++){\\n            if(employees[i]){\\n                return;\\n            }\\n        }\\n\\n         res=max(res,currReq);\\n         return;\\n     }\\n      // Choose not to process the current request\\n      backtrack(n,requests,employees,res,index+1,currReq);\\n\\n      //process the current request\\n      int from=requests[index][0];\\n      int to=requests[index][1];\\n\\n      employees[from]--;//employess leaving \\'from\\' building \\n      employees[to]++;  //employees moving \\'to\\' building\\n\\n  \\n        backtrack(n,requests,employees,res,index+1,currReq+1);\\n  \\n\\n      //backtrack\\n      employees[from]++;\\n      employees[to]--;\\n      \\n    }\\n    int maximumRequests(int n, vector<vector<int>>& requests) {\\n        \\n        int maxiReq=0;\\n\\n        vector<int>employees(n,0);\\n\\n        backtrack(n,requests,employees,maxiReq,0,0);\\n\\n        return maxiReq;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3707631,
                "title": "beats-90-knapsack-backtracking-c-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSimilar to knapsack problem\\nFor each request we choose to fulfil it or ignore it\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(2 ^ N)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(N)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n- Where $$N$$ is $$request.length$$\\n\\n# Code\\n```C++ []\\nclass Solution {\\npublic:\\n    int f(int i, vector<vector<int>>& requests, vector<int> &freq, int count = 0) {\\n        if(i == requests.size()) {\\n            for(int j: freq) if(j != 0) return 0; // net transfer != 0\\n            return count; // net tranasfer == 0\\n        }\\n\\n        int notTake = f(i + 1, requests, freq, count);\\n\\n        freq[requests[i][0]]--, freq[requests[i][1]]++; // Update the freq\\n        int take = f(i + 1, requests, freq, count + 1);\\n        freq[requests[i][0]]++, freq[requests[i][1]]--; // Backtracking\\n        \\n        return max(take, notTake);\\n    }\\n    int maximumRequests(int n, vector<vector<int>>& requests) {\\n        vector<int> freq(n, 0);\\n        return f(0, requests, freq);\\n    }\\n};\\n```\\n```Java []\\nclass Solution {\\n    public int f(int i, int[][] requests, int[] freq, int count) {\\n        if(i == requests.length) {\\n            for(int j: freq) if(j != 0) return 0; // net transfer != 0\\n            return count; // net tranasfer == 0\\n        }\\n\\n        int notTake = f(i + 1, requests, freq, count);\\n\\n        freq[requests[i][0]]--; freq[requests[i][1]]++; // Update the freq\\n        int take = f(i + 1, requests, freq, count + 1);\\n        freq[requests[i][0]]++; freq[requests[i][1]]--; // Backtracking\\n        \\n        return Math.max(take, notTake);\\n    }\\n    public int maximumRequests(int n, int[][] requests) {\\n        int[] freq = new int[n];\\n        Arrays.fill(freq, 0);\\n        return f(0, requests, freq, 0);\\n    }\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Backtracking",
                    "Graph",
                    "Recursion"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    int f(int i, vector<vector<int>>& requests, vector<int> &freq, int count = 0) {\\n        if(i == requests.size()) {\\n            for(int j: freq) if(j != 0) return 0; // net transfer != 0\\n            return count; // net tranasfer == 0\\n        }\\n\\n        int notTake = f(i + 1, requests, freq, count);\\n\\n        freq[requests[i][0]]--, freq[requests[i][1]]++; // Update the freq\\n        int take = f(i + 1, requests, freq, count + 1);\\n        freq[requests[i][0]]++, freq[requests[i][1]]--; // Backtracking\\n        \\n        return max(take, notTake);\\n    }\\n    int maximumRequests(int n, vector<vector<int>>& requests) {\\n        vector<int> freq(n, 0);\\n        return f(0, requests, freq);\\n    }\\n};\\n```\n```Java []\\nclass Solution {\\n    public int f(int i, int[][] requests, int[] freq, int count) {\\n        if(i == requests.length) {\\n            for(int j: freq) if(j != 0) return 0; // net transfer != 0\\n            return count; // net tranasfer == 0\\n        }\\n\\n        int notTake = f(i + 1, requests, freq, count);\\n\\n        freq[requests[i][0]]--; freq[requests[i][1]]++; // Update the freq\\n        int take = f(i + 1, requests, freq, count + 1);\\n        freq[requests[i][0]]++; freq[requests[i][1]]--; // Backtracking\\n        \\n        return Math.max(take, notTake);\\n    }\\n    public int maximumRequests(int n, int[][] requests) {\\n        int[] freq = new int[n];\\n        Arrays.fill(freq, 0);\\n        return f(0, requests, freq, 0);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3707316,
                "title": "beats-100-solution-using-backtracking",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    int ans = 0;\\n    public int maximumRequests(int n, int[][] requests) {\\n        int[] degree = new int[n];\\n        permitReq(requests, 0, degree, 0);\\n        return ans;\\n    }\\n    \\n    void permitReq(int[][] req, int ind, int[] degree, int temp){\\n        if(ind == req.length){\\n            for(int i = 0 ; i < degree.length ; i++){\\n                if(degree[i] != 0)\\n                    return;\\n            }\\n            ans = Math.max(ans, temp);\\n            return;\\n        }\\n            \\n        int i = req[ind][0];\\n        int j = req[ind][1];\\n        \\n//         Permit the request at index ind\\n        degree[i] = degree[i]-1;\\n        degree[j] = degree[j]+1;\\n        permitReq(req, ind+1, degree, temp+1);\\n        \\n//         Reject the request at index ind\\n        degree[i] = degree[i]+1;\\n        degree[j] = degree[j]-1;\\n        permitReq(req, ind+1, degree, temp);\\n    }\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Array",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\n    int ans = 0;\\n    public int maximumRequests(int n, int[][] requests) {\\n        int[] degree = new int[n];\\n        permitReq(requests, 0, degree, 0);\\n        return ans;\\n    }\\n    \\n    void permitReq(int[][] req, int ind, int[] degree, int temp){\\n        if(ind == req.length){\\n            for(int i = 0 ; i < degree.length ; i++){\\n                if(degree[i] != 0)\\n                    return;\\n            }\\n            ans = Math.max(ans, temp);\\n            return;\\n        }\\n            \\n        int i = req[ind][0];\\n        int j = req[ind][1];\\n        \\n//         Permit the request at index ind\\n        degree[i] = degree[i]-1;\\n        degree[j] = degree[j]+1;\\n        permitReq(req, ind+1, degree, temp+1);\\n        \\n//         Reject the request at index ind\\n        degree[i] = degree[i]+1;\\n        degree[j] = degree[j]-1;\\n        permitReq(req, ind+1, degree, temp);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3707308,
                "title": "bitmasking",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximumRequests(int n, vector<vector<int>>& requests) {\\n        int maxRequests = 0;\\n        int numRequests = requests.size();\\n        \\n        // Generate all possible combinations of requests\\n        for (int mask = 0; mask < (1 << numRequests); mask++) {\\n            vector<int> buildings(n, 0);  // Tracks net change for each building\\n            \\n            // Count the number of requests in this combination\\n            int count = 0;\\n            \\n            for (int i = 0; i < numRequests; i++) {\\n                if (mask & (1 << i)) {\\n                    // Include this request in the combination\\n                    count++;\\n                    int from = requests[i][0];\\n                    int to = requests[i][1];\\n                    buildings[from]--;\\n                    buildings[to]++;\\n                }\\n            }\\n            \\n            // Check if the combination results in a net change of zero for all buildings\\n            bool isValid = true;\\n            for (int b : buildings) {\\n                if (b != 0) {\\n                    isValid = false;\\n                    break;\\n                }\\n            }\\n            \\n            // Update the maximum number of achievable requests\\n            if (isValid) {\\n                maxRequests = std::max(maxRequests, count);\\n            }\\n        }\\n        \\n        return maxRequests;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Backtracking",
                    "Bit Manipulation",
                    "Enumeration"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumRequests(int n, vector<vector<int>>& requests) {\\n        int maxRequests = 0;\\n        int numRequests = requests.size();\\n        \\n        // Generate all possible combinations of requests\\n        for (int mask = 0; mask < (1 << numRequests); mask++) {\\n            vector<int> buildings(n, 0);  // Tracks net change for each building\\n            \\n            // Count the number of requests in this combination\\n            int count = 0;\\n            \\n            for (int i = 0; i < numRequests; i++) {\\n                if (mask & (1 << i)) {\\n                    // Include this request in the combination\\n                    count++;\\n                    int from = requests[i][0];\\n                    int to = requests[i][1];\\n                    buildings[from]--;\\n                    buildings[to]++;\\n                }\\n            }\\n            \\n            // Check if the combination results in a net change of zero for all buildings\\n            bool isValid = true;\\n            for (int b : buildings) {\\n                if (b != 0) {\\n                    isValid = false;\\n                    break;\\n                }\\n            }\\n            \\n            // Update the maximum number of achievable requests\\n            if (isValid) {\\n                maxRequests = std::max(maxRequests, count);\\n            }\\n        }\\n        \\n        return maxRequests;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3707018,
                "title": "python-by-dfs-backtracking-pruning-w-demo-visualization",
                "content": "[\\u4E2D\\u6587\\u8A73\\u89E3\\u5F71\\u7247 Tutorial video in Chinese](https://www.youtube.com/watch?v=duTuyd_Z3j0)\\n\\n\\n# Demo & Visualization\\n\\n![image.png](https://assets.leetcode.com/users/images/5138965a-c142-493e-b9b2-41ba5d6c36f1_1688296543.4428358.png)\\n\\n\\n# Intuition & Approach\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\nOnly two options for each request:\\n```\\nOption_1: Skip request, not to transfer\\n\\nOption_2: Satisfy request, make transfer\\n\\n```\\n\\nHere, we use DFS + backtracking to enumerate all possible selections.\\nIn addition, we use pruning technique to early stop thoses branches which cannot yield better result\\n\\n```\\nA set of requests is valid if and only if all building\\'s \"count of moving in\" = \"count of moving out\". \\n```\\n\\n<=>\\n\\n```\\nA set of requests is valid if and only if all building\\'s \"in_degree\" = \"out_degree\".\\n```\\n\\n<=>\\n\\n```\\nA set of requests is valid if and only if all building\\'s \"net degree change\" = 0\\n\\n```\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(B * 2^R )\\nO( B ) on checking degree of each Building is balanced ( in_degree = out_degree )\\nO( 2^R ) on enumerating all possible selections\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO( B + R )\\nO( B ) on the memory space of degree table to Building\\nO( R ) on max recursion call depth of DFS function: check( ... )\\n\\n# Code\\n\\n```python []\\nclass Solution:\\n    def maximumRequests(self, n: int, requests: List[List[int]]) -> int:\\n        \\n        # total number of request\\n        total_request = len(requests)\\n\\n        ## Degree table\\n        # key: building as a node in graph\\n        # value: degree of specific building, each in_degree as +1, each out_degree as -1\\n        degree = defaultdict(int)\\n\\n        # helper function to update in_degree as well as out_degree of building\\n        def make_selection(src, dest, roll_back):\\n\\n            if not roll_back:\\n                # Make a selection = Make a transfer\\n                degree[src] -= 1\\n                degree[dest] += 1\\n            else:\\n                # Undo a selection = Roll back a transfer\\n                degree[src] += 1\\n                degree[dest] -= 1\\n            return\\n\\n\\n        # Use DFS + backtracking + pruning technique to check each transfer request\\n        def check(req_ID, count):\\n            \\n            # Pruning, also known as early stop, terminate those branches which cannot yield better result\\n            if total_request - req_ID + count <= check.max_transfer:\\n                return\\n            \\n            # Base case\\n            # We\\'ve checked all requests\\n            if req_ID == total_request:\\n                if all(degree[i] == 0 for i in range(n)) and count > check.max_transfer:\\n                    # All degree are balanced (in_degree = out_degree for each building)\\n                    check.max_transfer = count\\n                return\\n\\n\\n            ## Only two options for current request with req_ID\\n\\n            # Option_#1: skip this request, not to transfer\\n            check(req_ID + 1, count)\\n\\n            # Option_#2: satisfy this request, transfer\\n            src, dest = requests[req_ID][0], requests[req_ID][1]\\n\\n            make_selection(src, dest, roll_back = False)\\n            check(req_ID + 1, count + 1)\\n            make_selection(src, dest, roll_back = True)\\n\\n            return\\n\\n        # ===================================\\n\\n        # Our goal is to maximize transfer count\\n        # So initialization is zero\\n        check.max_transfer = 0\\n\\n        # Start checking from first request, try to maximize transfer count\\n        check(req_ID = 0, count = 0)\\n\\n        return check.max_transfer\\n```\\n\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Backtracking",
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "```\\nOption_1: Skip request, not to transfer\\n\\nOption_2: Satisfy request, make transfer\\n\\n```\n```\\nA set of requests is valid if and only if all building\\'s \"count of moving in\" = \"count of moving out\". \\n```\n```\\nA set of requests is valid if and only if all building\\'s \"in_degree\" = \"out_degree\".\\n```\n```\\nA set of requests is valid if and only if all building\\'s \"net degree change\" = 0\\n\\n```\n```python []\\nclass Solution:\\n    def maximumRequests(self, n: int, requests: List[List[int]]) -> int:\\n        \\n        # total number of request\\n        total_request = len(requests)\\n\\n        ## Degree table\\n        # key: building as a node in graph\\n        # value: degree of specific building, each in_degree as +1, each out_degree as -1\\n        degree = defaultdict(int)\\n\\n        # helper function to update in_degree as well as out_degree of building\\n        def make_selection(src, dest, roll_back):\\n\\n            if not roll_back:\\n                # Make a selection = Make a transfer\\n                degree[src] -= 1\\n                degree[dest] += 1\\n            else:\\n                # Undo a selection = Roll back a transfer\\n                degree[src] += 1\\n                degree[dest] -= 1\\n            return\\n\\n\\n        # Use DFS + backtracking + pruning technique to check each transfer request\\n        def check(req_ID, count):\\n            \\n            # Pruning, also known as early stop, terminate those branches which cannot yield better result\\n            if total_request - req_ID + count <= check.max_transfer:\\n                return\\n            \\n            # Base case\\n            # We\\'ve checked all requests\\n            if req_ID == total_request:\\n                if all(degree[i] == 0 for i in range(n)) and count > check.max_transfer:\\n                    # All degree are balanced (in_degree = out_degree for each building)\\n                    check.max_transfer = count\\n                return\\n\\n\\n            ## Only two options for current request with req_ID\\n\\n            # Option_#1: skip this request, not to transfer\\n            check(req_ID + 1, count)\\n\\n            # Option_#2: satisfy this request, transfer\\n            src, dest = requests[req_ID][0], requests[req_ID][1]\\n\\n            make_selection(src, dest, roll_back = False)\\n            check(req_ID + 1, count + 1)\\n            make_selection(src, dest, roll_back = True)\\n\\n            return\\n\\n        # ===================================\\n\\n        # Our goal is to maximize transfer count\\n        # So initialization is zero\\n        check.max_transfer = 0\\n\\n        # Start checking from first request, try to maximize transfer count\\n        check(req_ID = 0, count = 0)\\n\\n        return check.max_transfer\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3706327,
                "title": "easy-python-solution-similar-to-78-subsets",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nSimilar approach as Subset, Subset ii\\n\\nFor each request, we can choose to pick it or not. Once both indegree and outdegree for each building are balanced, we record it and update the maximum request.\\n\\nI don\\'t want to use combination() function during an interview. \\n\\n# Code for 78. Subset\\n```\\nclass Solution(object):\\n    def subsetsWithDup(self, nums):\\n        \\n        res = []\\n        nums.sort()\\n\\n        def recur(index,curPath):\\n            res.append(curPath[:])\\n            if index == len(nums):\\n                return\\n            \\n            for i in range(index,len(nums)):\\n                if i > index and nums[i]==nums[i-1]:\\n                    continue\\n                curPath.append(nums[i])\\n                recur(i+1,curPath)\\n                curPath.pop()\\n        \\n        recur(0,[])\\n        return res\\n```\\n# Code\\n```\\nclass Solution(object):\\n    def maximumRequests(self, n, requests):\\n        \"\"\"\\n        :type n: int\\n        :type requests: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n        l = len(requests)\\n        buildings = [0 for i in range(n)]\\n        self.res = 0\\n\\n        def recur(index,cur,buildings):\\n            if all(e==0 for e in buildings):\\n                self.res = max(self.res,cur)\\n            if index == len(requests):\\n                return\\n            \\n            for i in range(index,l):\\n                src,dest = requests[i]\\n                buildings[src] -= 1\\n                buildings[dest] += 1\\n\\n                recur(i+1,cur+1,buildings)\\n\\n                buildings[src] += 1\\n                buildings[dest] -= 1\\n        \\n        recur(0,0,buildings)\\n        return self.res\\n\\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution(object):\\n    def subsetsWithDup(self, nums):\\n        \\n        res = []\\n        nums.sort()\\n\\n        def recur(index,curPath):\\n            res.append(curPath[:])\\n            if index == len(nums):\\n                return\\n            \\n            for i in range(index,len(nums)):\\n                if i > index and nums[i]==nums[i-1]:\\n                    continue\\n                curPath.append(nums[i])\\n                recur(i+1,curPath)\\n                curPath.pop()\\n        \\n        recur(0,[])\\n        return res\\n```\n```\\nclass Solution(object):\\n    def maximumRequests(self, n, requests):\\n        \"\"\"\\n        :type n: int\\n        :type requests: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n        l = len(requests)\\n        buildings = [0 for i in range(n)]\\n        self.res = 0\\n\\n        def recur(index,cur,buildings):\\n            if all(e==0 for e in buildings):\\n                self.res = max(self.res,cur)\\n            if index == len(requests):\\n                return\\n            \\n            for i in range(index,l):\\n                src,dest = requests[i]\\n                buildings[src] -= 1\\n                buildings[dest] += 1\\n\\n                recur(i+1,cur+1,buildings)\\n\\n                buildings[src] += 1\\n                buildings[dest] -= 1\\n        \\n        recur(0,0,buildings)\\n        return self.res\\n\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3706255,
                "title": "c-recursion",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int ans = 0;\\n    vector<int> transfer;\\n    void helper(int curr, int n, vector<vector<int>>& requests, int cnt) {\\n        if (curr == requests.size()) {\\n            if (all_of(transfer.begin(), transfer.end(), [](int element) { return element == 0; }))\\n                ans = max(ans, cnt);\\n            return;\\n        }\\n\\n        int res = 0;\\n        helper(curr + 1, n, requests, cnt);\\n        \\n        transfer[requests[curr][0]]++;\\n        transfer[requests[curr][1]]--;\\n        helper(curr + 1, n, requests, cnt + 1);\\n        transfer[requests[curr][0]]--;\\n        transfer[requests[curr][1]]++;\\n    }\\n\\n    int maximumRequests(int n, vector<vector<int>>& requests) {\\n        transfer.resize(n);\\n        helper(0, n, requests, 0); \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int ans = 0;\\n    vector<int> transfer;\\n    void helper(int curr, int n, vector<vector<int>>& requests, int cnt) {\\n        if (curr == requests.size()) {\\n            if (all_of(transfer.begin(), transfer.end(), [](int element) { return element == 0; }))\\n                ans = max(ans, cnt);\\n            return;\\n        }\\n\\n        int res = 0;\\n        helper(curr + 1, n, requests, cnt);\\n        \\n        transfer[requests[curr][0]]++;\\n        transfer[requests[curr][1]]--;\\n        helper(curr + 1, n, requests, cnt + 1);\\n        transfer[requests[curr][0]]--;\\n        transfer[requests[curr][1]]++;\\n    }\\n\\n    int maximumRequests(int n, vector<vector<int>>& requests) {\\n        transfer.resize(n);\\n        helper(0, n, requests, 0); \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3706115,
                "title": "python3-solution",
                "content": "\\n```\\nclass Solution:\\n    def maximumRequests(self, n: int, requests: List[List[int]]) -> int:\\n        l=len(requests)\\n        for i in range(l,0,-1):\\n            for j in combinations(requests,i):\\n                if Counter(x for x ,y in j)==Counter(y for x,y in j):\\n                    return i\\n\\n        return 0            \\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maximumRequests(self, n: int, requests: List[List[int]]) -> int:\\n        l=len(requests)\\n        for i in range(l,0,-1):\\n            for j in combinations(requests,i):\\n                if Counter(x for x ,y in j)==Counter(y for x,y in j):\\n                    return i\\n\\n        return 0            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3706073,
                "title": "daily-leetcode-solution-easy-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isValid(vector<int>& res){\\n        int n = res.size();\\n        for(int i = 0; i < n; i++){\\n            if(res[i]) return false;\\n        }\\n        return true;\\n    }\\n    \\n    int maximumRequests(int n, vector<vector<int>>& requests) {\\n        int k = requests.size();\\n        int N = 1 << k, ans = 0;\\n        for(int mask = N - 1 ; mask >= 0; mask--){\\n            vector<int> res(n, 0);\\n            for(int pos = 0; pos < 16; pos++){\\n                if(mask & (1 << pos)){\\n                    int u = requests[pos][0], v = requests[pos][1];\\n                    res[u]--, res[v]++;\\n                }\\n            }\\n            if(isValid(res)) ans = max(ans, __builtin_popcount(mask));\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Array",
                    "Bit Manipulation",
                    "Bitmask"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isValid(vector<int>& res){\\n        int n = res.size();\\n        for(int i = 0; i < n; i++){\\n            if(res[i]) return false;\\n        }\\n        return true;\\n    }\\n    \\n    int maximumRequests(int n, vector<vector<int>>& requests) {\\n        int k = requests.size();\\n        int N = 1 << k, ans = 0;\\n        for(int mask = N - 1 ; mask >= 0; mask--){\\n            vector<int> res(n, 0);\\n            for(int pos = 0; pos < 16; pos++){\\n                if(mask & (1 << pos)){\\n                    int u = requests[pos][0], v = requests[pos][1];\\n                    res[u]--, res[v]++;\\n                }\\n            }\\n            if(isValid(res)) ans = max(ans, __builtin_popcount(mask));\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3706046,
                "title": "daily-leetcoding-challenge-july-day-2",
                "content": "This problem is the Daily LeetCoding Challenge for July, Day 2.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/maximum-number-of-achievable-transfer-requests/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Backtracking\n\n  \n**Approach 2:** Bitmasking\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>",
                "solutionTags": [],
                "code": "  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/maximum-number-of-achievable-transfer-requests/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />",
                "codeTag": "Unknown"
            },
            {
                "id": 3398630,
                "title": "741-ms",
                "content": "```ruby\\ndef maximum_requests n, r\\n    b = [nil] * n\\n    for c in (0..r.size).reverse_each\\n        r.combination(c).each do | v |\\n            b.fill 0\\n            v.each do | i, j |\\n                b[i] -= 1\\n                b[j] += 1\\n            end\\n            return c if b.all?(&:zero?)\\n        end\\n    end\\nend\\n```",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```ruby\\ndef maximum_requests n, r\\n    b = [nil] * n\\n    for c in (0..r.size).reverse_each\\n        r.combination(c).each do | v |\\n            b.fill 0\\n            v.each do | i, j |\\n                b[i] -= 1\\n                b[j] += 1\\n            end\\n            return c if b.all?(&:zero?)\\n        end\\n    end\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1648570,
                "title": "python-76ms-beats-100-bitmask-meet-in-the-middle",
                "content": "The problem is to find a biggest subset which satisfies a constraint. If number of requests is `m`, then number of subsets is `2^m`. Meet in the middle idea is to split the task into two subtasks, solve both of them and merge results. So here we could split requests array into two halves and find subsets of each half. Each subset produces some change in the buildings and our task is to find two such subsets which cancel their change. So for example, if our left subset is [(0,1)], then its change of employees is [-1, 1, 0, .... 0], because it removes one person from building 0 and adds a person to a building 1. So then we seek to find right subset which produces the change [1, -1, 0, ..., 0]. We can do search in constant time if we put those changes in the dictionary.\\n\\nIf we use bitmasks without this trick we will need to generate `2^m` subsets, so about `2^16 = 65K`, for each subset we need to go through requests and buildings. With this trick we generate only  `2*2^8=512` subsets, and spend the same amount of computations for each subset.\\n\\n```\\nclass Solution:\\n    def maximumRequests(self, n: int, requests: List[List[int]]) -> int:\\n        m = len(requests)\\n        \\n        def __generate_all_subsets(R):\\n            if len(R) == 0:\\n                yield (0, [0] * n)\\n                \\n            else:\\n                for mask in range(1 << len(R)):\\n                    cnt_bits = 0\\n                    shift = [0] * n\\n                    for bi in range(len(R)):\\n                        if ((1 << bi) & mask) != 0:\\n                            cnt_bits += 1\\n                            x, y = R[bi]\\n                            shift[x] -= 1\\n                            shift[y] += 1\\n                    yield (cnt_bits, shift)\\n                    \\n        L = dict()\\n        for cnt_bits, shift in __generate_all_subsets(requests[:m // 2]):\\n            key = tuple(shift)\\n            if key in L:\\n                L[key] = max(L[key], cnt_bits)\\n            else:\\n                L[key] = cnt_bits\\n                \\n        ans = 0\\n        for cnt_bits, shift in __generate_all_subsets(requests[m // 2:]):\\n            for i in range(n):\\n                shift[i] *= -1\\n            key = tuple(shift)\\n            if key in L:\\n                ans = max(ans, cnt_bits + L[key])\\n                \\n        return ans\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def maximumRequests(self, n: int, requests: List[List[int]]) -> int:\\n        m = len(requests)\\n        \\n        def __generate_all_subsets(R):\\n            if len(R) == 0:\\n                yield (0, [0] * n)\\n                \\n            else:\\n                for mask in range(1 << len(R)):\\n                    cnt_bits = 0\\n                    shift = [0] * n\\n                    for bi in range(len(R)):\\n                        if ((1 << bi) & mask) != 0:\\n                            cnt_bits += 1\\n                            x, y = R[bi]\\n                            shift[x] -= 1\\n                            shift[y] += 1\\n                    yield (cnt_bits, shift)\\n                    \\n        L = dict()\\n        for cnt_bits, shift in __generate_all_subsets(requests[:m // 2]):\\n            key = tuple(shift)\\n            if key in L:\\n                L[key] = max(L[key], cnt_bits)\\n            else:\\n                L[key] = cnt_bits\\n                \\n        ans = 0\\n        for cnt_bits, shift in __generate_all_subsets(requests[m // 2:]):\\n            for i in range(n):\\n                shift[i] *= -1\\n            key = tuple(shift)\\n            if key in L:\\n                ans = max(ans, cnt_bits + L[key])\\n                \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1263023,
                "title": "c-soln-backtracking",
                "content": "```\\nclass Solution {\\npublic:\\n    int vis[21];\\n    int sol(vector<vector<int>>& req, int i, int c){\\n        if(i==req.size()){\\n            for(auto &x:vis){\\n                if(x!=0)return 0;\\n            }\\n            return c;\\n        }\\n        int ans=0;\\n        vis[req[i][0]]--;\\n        vis[req[i][1]]++;\\n        ans=max(ans,sol(req,i+1,c+1));\\n        vis[req[i][0]]++;\\n        vis[req[i][1]]--;\\n        ans=max(ans,sol(req,i+1,c));\\n        return ans;\\n    }\\n    int maximumRequests(int n, vector<vector<int>>& req) {\\n        memset(vis,0,sizeof vis);\\n        return sol(req,0,0);\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int vis[21];\\n    int sol(vector<vector<int>>& req, int i, int c){\\n        if(i==req.size()){\\n            for(auto &x:vis){\\n                if(x!=0)return 0;\\n            }\\n            return c;\\n        }\\n        int ans=0;\\n        vis[req[i][0]]--;\\n        vis[req[i][1]]++;\\n        ans=max(ans,sol(req,i+1,c+1));\\n        vis[req[i][0]]++;\\n        vis[req[i][1]]--;\\n        ans=max(ans,sol(req,i+1,c));\\n        return ans;\\n    }\\n    int maximumRequests(int n, vector<vector<int>>& req) {\\n        memset(vis,0,sizeof vis);\\n        return sol(req,0,0);\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1195290,
                "title": "c-recursion",
                "content": "```\\nclass Solution {\\npublic:\\n    int ans = 0;\\n    void solve(int n , int m,vector<vector<int>>&requests , vector<int>&temp,int i,int achievable)\\n    {\\n        //  base case\\n        if(i > m)return ;\\n        // if you reach the end of the requests then check eather all net transactions are  \\n        // 0 or not \\n        // if the net is 0 take max of ans and achievable requests\\n        if(i == m)\\n        {    \\n            for(int j = 0 ; j < temp.size();j++){\\n                if(temp[j]!= 0)\\n                return ;}\\n             ans = max(ans , achievable);\\n         return;\\n        }\\n        // either you do not process the current request\\n        solve(n,m,requests,temp,i+1,achievable);\\n        // you process the current request and increase achievable request by 1\\n        temp[requests[i][0]]--;\\n        temp[requests[i][1]]++;\\n        solve(n,m,requests,temp,i+1,achievable + 1);\\n        // make sure after taking that request in account update the temp \\n        temp[requests[i][0]]++;\\n        temp[requests[i][1]]--;             \\n    }\\n    int maximumRequests(int n, vector<vector<int>>& requests) {\\n        int m = requests.size();\\n        vector<int>temp(n , 0);\\n        solve(n,m,requests,temp,0,0);\\n        return ans;\\n        \\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int ans = 0;\\n    void solve(int n , int m,vector<vector<int>>&requests , vector<int>&temp,int i,int achievable)\\n    {\\n        //  base case\\n        if(i > m)return ;\\n        // if you reach the end of the requests then check eather all net transactions are  \\n        // 0 or not \\n        // if the net is 0 take max of ans and achievable requests\\n        if(i == m)\\n        {    \\n            for(int j = 0 ; j < temp.size();j++){\\n                if(temp[j]!= 0)\\n                return ;}",
                "codeTag": "Java"
            },
            {
                "id": 874494,
                "title": "python-think-brute-force",
                "content": "1. create all the possible **combinations** of requests\\n2. for each combination, check if the combination is possible, i.e. assume that all the transfers are made; the final **inflow** should be equal to the final **outflow** of each building\\n```\\nclass Solution:\\n    @staticmethod\\n    def combination_possible(n, combination) -> bool:\\n        in_degree = [0] * n\\n        out_degree = [0] * n\\n        for node in combination: # node: (from, to)\\n            out_degree[node[0]] += 1\\n            in_degree[node[1]] += 1\\n        return in_degree == out_degree\\n    \\n    def maximumRequests(self, n: int, requests: List[List[int]]) -> int:\\n        maximum_requests = 0\\n        for requestsIncluded in range(1, len(requests) + 1):\\n            for combination in list(combinations(requests, requestsIncluded)):\\n                if Solution.combination_possible(n, combination):\\n                    maximum_requests = requestsIncluded\\n                    continue\\n        return maximum_requests\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    @staticmethod\\n    def combination_possible(n, combination) -> bool:\\n        in_degree = [0] * n\\n        out_degree = [0] * n\\n        for node in combination: # node: (from, to)\\n            out_degree[node[0]] += 1\\n            in_degree[node[1]] += 1\\n        return in_degree == out_degree\\n    \\n    def maximumRequests(self, n: int, requests: List[List[int]]) -> int:\\n        maximum_requests = 0\\n        for requestsIncluded in range(1, len(requests) + 1):\\n            for combination in list(combinations(requests, requestsIncluded)):\\n                if Solution.combination_possible(n, combination):\\n                    maximum_requests = requestsIncluded\\n                    continue\\n        return maximum_requests\\n```",
                "codeTag": "Java"
            },
            {
                "id": 868279,
                "title": "java-using-bitmask-my-first-attempt-at-bitmasking",
                "content": "``` \\n\\nclass Solution {\\n    \\n    public int maximumRequests(int n, int[][] requests) {\\n        \\n        // Use bitmasking\\n        int ans = 0;\\n\\n        // Total possible combinations of requests 2^N\\n\\t\\t\\n\\t\\t// 1 << N ) -- Multiply 1 by  2 N times \\n        for(int i = 0; i < (1 << requests.length) ; i++)\\n        {\\n            ans = Math.max(ans,helper(i,requests,n));\\n        }\\n        \\n        return ans;\\n        \\n    }\\n    \\n    public int helper(int mask, int[][] requests,int n)\\n    {\\n        int count = 0;\\n        int inDegrees [] = new int [n];\\n        for(int i = 0; i < requests.length ; i++)\\n        {\\n            // Check if the ith bit / ith request is set in the mask\\n            if(((1 << i) & (mask)) != 0)\\n            {\\n                \\n               count += 1;\\n               int from = requests[i][0];\\n               int to = requests[i][1]; \\n               inDegrees[from] -= 1;\\n               inDegrees[to] += 1; \\n    \\n                \\n            }\\n        }\\n        \\n        for(int key = 0 ; key < n ; key ++)\\n        {\\n            if(inDegrees[key] != 0)\\n            {\\n                return 0;\\n            }\\n        }\\n\\n        return count ;\\n    }\\n}\\n\\n\\n```",
                "solutionTags": [],
                "code": "``` \\n\\nclass Solution {\\n    \\n    public int maximumRequests(int n, int[][] requests) {\\n        \\n        // Use bitmasking\\n        int ans = 0;\\n\\n        // Total possible combinations of requests 2^N\\n\\t\\t\\n\\t\\t// 1 << N ) -- Multiply 1 by  2 N times \\n        for(int i = 0; i < (1 << requests.length) ; i++)\\n        {\\n            ans = Math.max(ans,helper(i,requests,n));\\n        }\\n        \\n        return ans;\\n        \\n    }\\n    \\n    public int helper(int mask, int[][] requests,int n)\\n    {\\n        int count = 0;\\n        int inDegrees [] = new int [n];\\n        for(int i = 0; i < requests.length ; i++)\\n        {\\n            // Check if the ith bit / ith request is set in the mask\\n            if(((1 << i) & (mask)) != 0)\\n            {\\n                \\n               count += 1;\\n               int from = requests[i][0];\\n               int to = requests[i][1]; \\n               inDegrees[from] -= 1;\\n               inDegrees[to] += 1; \\n    \\n                \\n            }\\n        }\\n        \\n        for(int key = 0 ; key < n ; key ++)\\n        {\\n            if(inDegrees[key] != 0)\\n            {\\n                return 0;\\n            }\\n        }\\n\\n        return count ;\\n    }\\n}\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 867689,
                "title": "one-failure-thought-always-choose-the-largest-circle",
                "content": "Again, this fails, but might be a good lesson.\\n```\\nclass Solution {\\npublic:\\n    int maximumRequests(int n, vector<vector<int>>& requests) {\\n        vector<unordered_map<int, int>> building(n, unordered_map<int, int>());\\n        for (auto& request : requests) {\\n            int from = request[0];\\n            int to = request[1];\\n\\n            ++building[from][to];\\n        }\\n\\n        int ans = 0;\\n        for (int i = 0; i < n; ++i) {\\n            bool isInLoop = true;\\n            do {\\n                vector<int> buffer;\\n                unordered_set<int> visited;\\n                vector<int> longestStack;\\n                dfs(building, i, buffer, visited, longestStack);\\n                if (longestStack.empty()) {\\n                    isInLoop = false;\\n                } else {\\n                    ans += longestStack.size();\\n                    for (int i = 1; i <= longestStack.size(); ++i) {\\n                        --building[longestStack[i - 1]][longestStack[i % longestStack.size()]];\\n                    }\\n                }\\n            } while (isInLoop);\\n        }\\n\\n        return ans;\\n    }\\n\\nprivate:\\n    void dfs(vector<unordered_map<int, int>>& building, int i, vector<int>& buffer,\\n             unordered_set<int>& visited, vector<int>& longest) {\\n        if (visited.count(i)) {\\n            vector<int> circle;\\n            bool head = false;\\n            for (int j = 0; j < buffer.size(); ++j) {\\n                if (buffer[j] == i) {\\n                    head = true;\\n                }\\n                if (head == true) {\\n                    circle.emplace_back(buffer[j]);\\n                }\\n            }\\n            if (circle.size() > longest.size()) {\\n                longest = move(circle);\\n            }\\n            return;\\n        }\\n\\n        visited.emplace(i);\\n        buffer.emplace_back(i);\\n        for (auto [neighbor, num] : building[i]) {\\n            if (num > 0) {\\n                dfs(building, neighbor, buffer, visited, longest);\\n            }\\n        }\\n        buffer.pop_back();\\n        visited.erase(i);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumRequests(int n, vector<vector<int>>& requests) {\\n        vector<unordered_map<int, int>> building(n, unordered_map<int, int>());\\n        for (auto& request : requests) {\\n            int from = request[0];\\n            int to = request[1];\\n\\n            ++building[from][to];\\n        }\\n\\n        int ans = 0;\\n        for (int i = 0; i < n; ++i) {\\n            bool isInLoop = true;\\n            do {\\n                vector<int> buffer;\\n                unordered_set<int> visited;\\n                vector<int> longestStack;\\n                dfs(building, i, buffer, visited, longestStack);\\n                if (longestStack.empty()) {\\n                    isInLoop = false;\\n                } else {\\n                    ans += longestStack.size();\\n                    for (int i = 1; i <= longestStack.size(); ++i) {\\n                        --building[longestStack[i - 1]][longestStack[i % longestStack.size()]];\\n                    }\\n                }\\n            } while (isInLoop);\\n        }\\n\\n        return ans;\\n    }\\n\\nprivate:\\n    void dfs(vector<unordered_map<int, int>>& building, int i, vector<int>& buffer,\\n             unordered_set<int>& visited, vector<int>& longest) {\\n        if (visited.count(i)) {\\n            vector<int> circle;\\n            bool head = false;\\n            for (int j = 0; j < buffer.size(); ++j) {\\n                if (buffer[j] == i) {\\n                    head = true;\\n                }\\n                if (head == true) {\\n                    circle.emplace_back(buffer[j]);\\n                }\\n            }\\n            if (circle.size() > longest.size()) {\\n                longest = move(circle);\\n            }\\n            return;\\n        }\\n\\n        visited.emplace(i);\\n        buffer.emplace_back(i);\\n        for (auto [neighbor, num] : building[i]) {\\n            if (num > 0) {\\n                dfs(building, neighbor, buffer, visited, longest);\\n            }\\n        }\\n        buffer.pop_back();\\n        visited.erase(i);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 866981,
                "title": "please-explain",
                "content": "Can anybody explain? How this testcase results into expected output of 5? In my understanding answer should be 6 as [2,0], [0,1], [0,1], [2,1] (No building can accomodate)\\n\\n3\\n[[0,0],[1,1],[0,0],[2,0],[2,2],[1,1],[2,1],[0,1],[0,1]]\\n\\nMycode according to understanding.\\n```\\nclass Solution {\\n    public int maximumRequests(int n, int[][] requests) {\\n        HashMap<Integer, Integer> map = new HashMap<>();\\n        \\n        int invalid = 0;\\n        \\n        for(int i = 0; i < n; i++){\\n            map.put(i, 0);\\n        }\\n        \\n        for(int[] request : requests){\\n            map.put(request[0], map.get(request[0])-1);\\n            map.put(request[1], map.get(request[1])+1);\\n        }\\n        \\n        System.out.println(map.values());\\n        for(int val : map.values()){\\n            invalid += Math.abs(val);   \\n        }\\n        System.out.println(invalid);\\n        return requests.length - (invalid/2);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int maximumRequests(int n, int[][] requests) {\\n        HashMap<Integer, Integer> map = new HashMap<>();\\n        \\n        int invalid = 0;\\n        \\n        for(int i = 0; i < n; i++){\\n            map.put(i, 0);\\n        }\\n        \\n        for(int[] request : requests){\\n            map.put(request[0], map.get(request[0])-1);\\n            map.put(request[1], map.get(request[1])+1);\\n        }\\n        \\n        System.out.println(map.values());\\n        for(int val : map.values()){\\n            invalid += Math.abs(val);   \\n        }\\n        System.out.println(invalid);\\n        return requests.length - (invalid/2);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 866582,
                "title": "python-check-all-subsets-by-bitmask",
                "content": "Since `len(requests) <= 16`, we can brute forcely check all possible subsets of the requests (smaller than `2^16` subsets) and find out the max number.\\n```\\ndef maximumRequests(n, requests):\\n\\t# s: one subset represented by a bitmask. e.g. len(requests) = 3 and s = 5 (0b101), that means 1st and 3rd request are picked.\\n\\tdef check(s):\\n\\t\\tctr = [0] * n\\n\\t\\tcnt = 0\\n\\t\\tfor i, req in enumerate(requests):\\n\\t\\t\\tif (s>>i) & 1:\\n\\t\\t\\t\\tcnt += 1\\n\\t\\t\\t\\tctr[req[0]] += 1\\n\\t\\t\\t\\tctr[req[1]] -= 1\\n\\t\\t\\treturn -1 if any(ctr) else cnt    # a valid subset should make net change be 0\\n\\treturn max(check(s) for s in range(1<<len(requests)))\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\ndef maximumRequests(n, requests):\\n\\t# s: one subset represented by a bitmask. e.g. len(requests) = 3 and s = 5 (0b101), that means 1st and 3rd request are picked.\\n\\tdef check(s):\\n\\t\\tctr = [0] * n\\n\\t\\tcnt = 0\\n\\t\\tfor i, req in enumerate(requests):\\n\\t\\t\\tif (s>>i) & 1:\\n\\t\\t\\t\\tcnt += 1\\n\\t\\t\\t\\tctr[req[0]] += 1\\n\\t\\t\\t\\tctr[req[1]] -= 1\\n\\t\\t\\treturn -1 if any(ctr) else cnt    # a valid subset should make net change be 0\\n\\treturn max(check(s) for s in range(1<<len(requests)))\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 866390,
                "title": "python3-dfs-w-bitmask",
                "content": "\\n```\\nclass Solution:\\n    def maximumRequests(self, n: int, requests: List[List[int]]) -> int:\\n        \\n        def fn(k, mask): \\n            \"\"\"Return maximum number of achievable transfer requests.\"\"\"\\n            if k == len(requests): \\n                net = [0]*n\\n                for i, (u, v) in enumerate(requests): \\n                    if mask & 1 << i: \\n                        net[u] -= 1\\n                        net[v] += 1\\n                return 0 if any(net) else bin(mask).count(\"1\")\\n            return max(fn(k+1, mask), fn(k+1, mask | 1 << k))\\n        \\n        return fn(0, 0)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maximumRequests(self, n: int, requests: List[List[int]]) -> int:\\n        \\n        def fn(k, mask): \\n            \"\"\"Return maximum number of achievable transfer requests.\"\"\"\\n            if k == len(requests): \\n                net = [0]*n\\n                for i, (u, v) in enumerate(requests): \\n                    if mask & 1 << i: \\n                        net[u] -= 1\\n                        net[v] += 1\\n                return 0 if any(net) else bin(mask).count(\"1\")\\n            return max(fn(k+1, mask), fn(k+1, mask | 1 << k))\\n        \\n        return fn(0, 0)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3757645,
                "title": "beat-100-meet-in-the-middle",
                "content": "# Approach\\nMeet in the middle and binary search(here using map)\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(2^(r/2)*(n/2))*log(2^(r/2))*(n/2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(2^(r/2)*(n/2))\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximumRequests(int n, vector<vector<int>>& requests) {\\n\\n        int len=requests.size();\\n        \\n        vector<vector<int>> a,b;\\n        for(int i=0; i<len/2; i++)a.push_back(requests[i]);\\n        for(int i=len/2; i<len; i++)b.push_back(requests[i]);\\n\\n        map<vector<int>,int> hsh;\\n\\n        int ans=0;\\n        bool flag;\\n\\n        len=a.size();\\n        for(int i=1; i<(1<<len); i++)\\n        {\\n            vector<int> net(n);\\n            for(int j=0; j<len; j++)\\n            {\\n                if((1<<j)&i)\\n                {\\n                    net[a[j][0]]--;\\n                    net[a[j][1]]++;\\n                }\\n            }\\n            flag=true;\\n            for(int j=0; j<n; j++)\\n            {\\n                if(net[j]!=0)flag=false;\\n            }\\n            if(flag)ans=max(ans,__builtin_popcount(i));\\n            hsh[net]=max(hsh[net],__builtin_popcount(i));\\n        }\\n\\n        len=b.size();\\n        for(int i=1; i<(1<<len); i++)\\n        {\\n            vector<int> net(n);\\n            for(int j=0; j<len; j++)\\n            {\\n                if((1<<j)&i)\\n                {\\n                    net[b[j][0]]++;\\n                    net[b[j][1]]--;\\n                }\\n            }\\n            flag=true;\\n            for(int j=0; j<n; j++)\\n            {\\n                if(net[j]!=0)flag=false;\\n            }\\n            if(flag)ans=max(ans,__builtin_popcount(i));\\n            if(hsh.count(net))ans=max(ans,__builtin_popcount(i)+hsh[net]);\\n        }   \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search",
                    "Bit Manipulation",
                    "Bitmask"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumRequests(int n, vector<vector<int>>& requests) {\\n\\n        int len=requests.size();\\n        \\n        vector<vector<int>> a,b;\\n        for(int i=0; i<len/2; i++)a.push_back(requests[i]);\\n        for(int i=len/2; i<len; i++)b.push_back(requests[i]);\\n\\n        map<vector<int>,int> hsh;\\n\\n        int ans=0;\\n        bool flag;\\n\\n        len=a.size();\\n        for(int i=1; i<(1<<len); i++)\\n        {\\n            vector<int> net(n);\\n            for(int j=0; j<len; j++)\\n            {\\n                if((1<<j)&i)\\n                {\\n                    net[a[j][0]]--;\\n                    net[a[j][1]]++;\\n                }\\n            }\\n            flag=true;\\n            for(int j=0; j<n; j++)\\n            {\\n                if(net[j]!=0)flag=false;\\n            }\\n            if(flag)ans=max(ans,__builtin_popcount(i));\\n            hsh[net]=max(hsh[net],__builtin_popcount(i));\\n        }\\n\\n        len=b.size();\\n        for(int i=1; i<(1<<len); i++)\\n        {\\n            vector<int> net(n);\\n            for(int j=0; j<len; j++)\\n            {\\n                if((1<<j)&i)\\n                {\\n                    net[b[j][0]]++;\\n                    net[b[j][1]]--;\\n                }\\n            }\\n            flag=true;\\n            for(int j=0; j<n; j++)\\n            {\\n                if(net[j]!=0)flag=false;\\n            }\\n            if(flag)ans=max(ans,__builtin_popcount(i));\\n            if(hsh.count(net))ans=max(ans,__builtin_popcount(i)+hsh[net]);\\n        }   \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3714780,
                "title": "find-the-biggest-loops-bellman-ford",
                "content": "# Intuition\\n\\nDisclaimer: This is just a Java implementation of the following code. It took me some time to understand the ideas so I wanted to hopefully help people struggling as me. If you liked this tex PLEASE consider upvoting the original article! https://leetcode.com/problems/maximum-number-of-achievable-transfer-requests/solutions/867597/c-o-ve-2-time-solution-8ms/\\n\\nNote: There are some enhancements and alternatives that can be done in the code (as dfs to identify loops). I chose to keep as close to the original as possible to keep this article as an explanation to the original.\\n\\nThe main idea of the algorithm:\\n1. Find a loop positive.\\n2. Invert the direction of the vertices in the loop and transform the vertices weights into negative values.\\n3. Go to step 1.\\n\\nWhy does it work?\\n\\nImagine that some vertices of a path X are part of multiple loops, so we have a path A of vertices that is smaller or equal to another path B. Arbitrarily we can create a draw with representing it:\\n\\n \\n![image.png](https://assets.leetcode.com/users/images/afff76d7-ef84-4ff7-b826-3b2da322ae05_1688423825.643032.png)\\n\\nImagine that we are searching for positive loops and you find the one with path $$X+A$$. Lets do step 2.\\n\\nThis leaves us with a path of weight: $$TOTAL_1=ABS(X)+ABS(A)$$\\n\\n![image.png](https://assets.leetcode.com/users/images/56ae71b0-2057-4d4c-aae5-f73021039208_1688424456.367311.png)\\n\\nNow notice that $$\\\\tilde{A}+B$$ now form a loop, and as mentioned in the begining path B is greater than A, so the loop is positive (notice that if the path were otherwise smaller or equal we would ignore the loop as it is not positive). Then lets repeat step 2.\\n\\nThis leaves us with a path of weight: $$TOTAL_2=ABS(X)+ABS(B)=ABS(X)+ABS(A)+ABS(\\\\tilde{A})+ABS(B)=TOTAL_1+ABS(\\\\tilde{A})+ABS(B)$$\\n\\n![image.png](https://assets.leetcode.com/users/images/de2e35b6-3edf-4199-8aab-54c606f85f7d_1688424609.3795946.png)\\n\\nOnce again we end up with a loop $$A+\\\\tilde{B}$$, but as A is smaller than B this loop is negative, so we can stop. This is also the graph we would have ended if we had found the loop $$X+B$$ instead of $$X+A$$\\n\\nNote: the is an IF verification `d[v] >= d[u] + w` in the middle of the code that prevents us from mistaking situations as below with positive loops. Notice that at the moment the first repeated node/vertice appears the path decreased the value below or equal to the original, and the if prevents us from continuing.\\n\\nThe situation such as when we begin in the higest node.\\n\\n![image.png](https://assets.leetcode.com/users/images/19b8590f-67da-475b-aa91-0a78dbb5e1e0_1688427291.1960318.png)\\n\\n\\n# Approach\\n- Graph Theory\\n- Bellman Ford\\n\\n# Complexity\\n- Time complexity:\\n$$O(VE^2)$$ <- Bellman-Ford is O(VE), and you can have at most E loops, because at every outer loop you remove at least one vertice from the pool.\\n  - Note: Now, suppose the edges have different positive weights. In the worst-case scenario, every time we find a cycle, we reduce the total positive weight by at least 1. This is because finding a cycle and reversing it reduces the total weight in the graph: the cycle\\'s weight is added to the answer and then subtracted from the graph.\\nSometimes a path on the cycle was already negative, so this part becomes positive. I mention this in case you think that the actual min value subtracted is the min weight instead of 1, as it can be the diference of edges.\\nTherefore, with different weights the outer loop will run at most W times, where W is the total weight of all positive-weighted edges in the graph. If the weights are all positive and the smallest weight is 1, then W is at least equal to E. Therefore the time complexity becomes O(VEW).\\n\\n- Space complexity:\\n$$O(V+E)$$\\n\\n# Code\\n![image.png](https://assets.leetcode.com/users/images/f1896ee1-0857-4419-b825-1cf270ea83e5_1688424984.3026135.png)\\n\\n```java\\nclass Solution {\\n\\n    // Define the Edge class with four attributes\\n    class Edge {\\n        int v, w, sw, rev;\\n        public Edge(int v, int w, int sw, int rev) {\\n            this.v = v;  // destination vertex\\n            this.w = w;  // weight of the edge\\n            this.sw = sw;  // switch to control if the edge is being considered (1 = yes, 0 = no)\\n            this.rev = rev;  // the reverse edge index in the adjacency list of v\\n        }\\n    }\\n\\n    public int maximumRequests(int n, int[][] requests) {\\n        // Create the adjacency list for graph representation\\n        ArrayList<ArrayList<Edge>> g = new ArrayList<>();\\n        for (int i = 0; i < n; i++) {\\n            g.add(new ArrayList<>());\\n        }\\n\\n        int ans = 0; // Initialize the answer as 0\\n        // Build the graph from the request list\\n        for (int[] e : requests) {\\n            int u = e[0], v = e[1]; // u = start vertex, v = end vertex\\n            if (u == v) {\\n                ans++; // If a request is made to the same computer, increment ans\\n                continue;\\n            }\\n            // If request is made to a different computer, create edges in the graph\\n            g.get(u).add(new Edge(v, 1, 1, g.get(v).size()));\\n            g.get(v).add(new Edge(u, -1, 0, g.get(u).size()-1));\\n        }\\n\\n        // While loop to keep finding positive-weighted cycles\\n        while (true) {\\n            int[] d = new int[n], pv = new int[n], pe = new int[n], cnt = new int[n]; // Arrays to store shortest path value, previous vertex, previous edge, count of edges\\n            boolean[] inq = new boolean[n]; // Array to store if a vertex is in queue\\n            Queue<Integer> bf = new LinkedList<>(); // Queue to perform the Breadth-first search\\n\\n            // Add all vertices in the queue and mark them as in queue\\n            for(int i=0; i<n; ++i){\\n                bf.add(i);\\n                inq[i] = true;\\n            }\\n\\n            int ncv = -1; // Initialize the cycle vertex as -1 (indicating not found)\\n            // Perform the Breadth-first search to find a cycle (Bellman-Ford)\\n            while (!bf.isEmpty()) {\\n                int u = bf.poll();\\n                inq[u] = false;\\n                // For each edge from vertex u, relax the edge\\n                for (int i = 0; i < g.get(u).size(); ++i) {\\n                    Edge e = g.get(u).get(i);\\n                    int v = e.v, w = e.w, sw = e.sw;\\n                    // Skip if the edge is not switch on or doesn\\'t provide a bigger path\\n                    if (sw == 0 || d[v] >= d[u] + w) continue;\\n                    // If a bigger path is found, update the path\\n                    d[v] = d[u] + w;\\n                    pv[v] = u; pe[v] = i;\\n                    // If the vertex is not in queue, add it\\n                    if (!inq[v]) {\\n                        // If we have relaxed edges from the vertex n times, we have found a cycle\\n                        if (++cnt[v] == n) {\\n                            ncv = v; // Update the cycle vertex\\n                            break;\\n                        }\\n                        bf.add(v);\\n                        inq[v] = true;\\n                    }\\n                }\\n                //System.out.println(u+\" \"+Arrays.toString(d)+\" \"+Arrays.toString(pv));\\n                if(ncv != -1) break; // If a cycle is found, break the loop\\n            }\\n\\n            // If no cycle is found, break the loop\\n            if (ncv == -1) break;\\n            boolean[] vis = new boolean[n]; // Array to store if a vertex is visited\\n            // Find the cycle by going through the previous vertices\\n            for(; !vis[ncv]; ncv = pv[ncv]){\\n                vis[ncv] = true;\\n            }\\n\\n            int u = ncv; // Start from the vertex in the cycle\\n            // Go through the cycle to reverse the cycle and update the answer\\n            do {\\n                int p = pv[u], i = pe[u]; // Get the previous vertex and edge\\n                ans += g.get(p).get(i).w; // Add the weight to the answer\\n                g.get(p).get(i).sw = 0; // Switch off the edge\\n                g.get(u).get(g.get(p).get(i).rev).sw = 1; // Switch on the reverse edge\\n                u = p; // Move to the previous vertex\\n            } while(u != ncv);\\n        }\\n        return ans; // Return the maximum number of requests that can be achieved\\n    }\\n}\\n```\\n\\n# Code 2\\n\\nSame idea as before, the only difference is that I implemented the Bellman-Ford version of the algorithm that I prefer. I also used arrays intead of some Lists\\n\\n![image.png](https://assets.leetcode.com/users/images/c8202d6d-3395-46d1-af12-0e124dcb5cdd_1688506229.6998248.png)\\n\\n```java\\nclass Solution {\\n\\n    class Edge {\\n        int v, w, sw, rev;\\n        public Edge(int v, int w, int sw, int rev) {\\n            this.v = v;\\n            this.w = w;\\n            this.sw = sw;\\n            this.rev = rev;\\n        }\\n    }\\n\\n    public int maximumRequests(int n, int[][] requests) {\\n        ArrayList<Edge>[] g = new ArrayList[n];\\n        for (int i = 0; i < n; i++) g[i]=new ArrayList<>();\\n\\n        int ans = 0;\\n        for (int[] e : requests) {\\n            int u = e[0], v = e[1];\\n            if (u == v) {\\n                ans++;\\n                continue;\\n            }\\n            g[u].add(new Edge(v, 1, 1, g[v].size()));\\n            g[v].add(new Edge(u, -1, 0, g[u].size()-1));\\n        }\\n\\n        while (true) {\\n            int[] val=new int[n], pv=new int[n], pe=new int[n];\\n            int last=0;\\n            for(int c=0;c<=n&&last>=0;c++) {\\n                last=-1;\\n                for(int i=0;i<n;i++) {\\n                    int v=val[i];\\n                    for(int j=0;j<g[i].size();j++) {\\n                        Edge e=g[i].get(j);\\n                        if(e.sw==0||val[e.v]>=v+e.w) continue;\\n                        val[e.v]=v+e.w;\\n                        pv[e.v]=i;\\n                        pe[e.v]=j;\\n                        last=e.v;\\n                    }\\n                }\\n                if(last==-1) return ans;\\n            }\\n            boolean[] loop=new boolean[n];\\n            while(!loop[last]) {\\n                loop[last]=true;\\n                last=pv[last];\\n            }\\n\\n            int u = last;\\n            do {\\n                int p = pv[u], i = pe[u];\\n                ans += g[p].get(i).w;\\n                g[p].get(i).sw = 0;\\n                g[u].get(g[p].get(i).rev).sw = 1;\\n                u = p;\\n            } while(u != last);\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```java\\nclass Solution {\\n\\n    // Define the Edge class with four attributes\\n    class Edge {\\n        int v, w, sw, rev;\\n        public Edge(int v, int w, int sw, int rev) {\\n            this.v = v;  // destination vertex\\n            this.w = w;  // weight of the edge\\n            this.sw = sw;  // switch to control if the edge is being considered (1 = yes, 0 = no)\\n            this.rev = rev;  // the reverse edge index in the adjacency list of v\\n        }\\n    }\\n\\n    public int maximumRequests(int n, int[][] requests) {\\n        // Create the adjacency list for graph representation\\n        ArrayList<ArrayList<Edge>> g = new ArrayList<>();\\n        for (int i = 0; i < n; i++) {\\n            g.add(new ArrayList<>());\\n        }\\n\\n        int ans = 0; // Initialize the answer as 0\\n        // Build the graph from the request list\\n        for (int[] e : requests) {\\n            int u = e[0], v = e[1]; // u = start vertex, v = end vertex\\n            if (u == v) {\\n                ans++; // If a request is made to the same computer, increment ans\\n                continue;\\n            }\\n            // If request is made to a different computer, create edges in the graph\\n            g.get(u).add(new Edge(v, 1, 1, g.get(v).size()));\\n            g.get(v).add(new Edge(u, -1, 0, g.get(u).size()-1));\\n        }\\n\\n        // While loop to keep finding positive-weighted cycles\\n        while (true) {\\n            int[] d = new int[n], pv = new int[n], pe = new int[n], cnt = new int[n]; // Arrays to store shortest path value, previous vertex, previous edge, count of edges\\n            boolean[] inq = new boolean[n]; // Array to store if a vertex is in queue\\n            Queue<Integer> bf = new LinkedList<>(); // Queue to perform the Breadth-first search\\n\\n            // Add all vertices in the queue and mark them as in queue\\n            for(int i=0; i<n; ++i){\\n                bf.add(i);\\n                inq[i] = true;\\n            }\\n\\n            int ncv = -1; // Initialize the cycle vertex as -1 (indicating not found)\\n            // Perform the Breadth-first search to find a cycle (Bellman-Ford)\\n            while (!bf.isEmpty()) {\\n                int u = bf.poll();\\n                inq[u] = false;\\n                // For each edge from vertex u, relax the edge\\n                for (int i = 0; i < g.get(u).size(); ++i) {\\n                    Edge e = g.get(u).get(i);\\n                    int v = e.v, w = e.w, sw = e.sw;\\n                    // Skip if the edge is not switch on or doesn\\'t provide a bigger path\\n                    if (sw == 0 || d[v] >= d[u] + w) continue;\\n                    // If a bigger path is found, update the path\\n                    d[v] = d[u] + w;\\n                    pv[v] = u; pe[v] = i;\\n                    // If the vertex is not in queue, add it\\n                    if (!inq[v]) {\\n                        // If we have relaxed edges from the vertex n times, we have found a cycle\\n                        if (++cnt[v] == n) {\\n                            ncv = v; // Update the cycle vertex\\n                            break;\\n                        }\\n                        bf.add(v);\\n                        inq[v] = true;\\n                    }\\n                }\\n                //System.out.println(u+\" \"+Arrays.toString(d)+\" \"+Arrays.toString(pv));\\n                if(ncv != -1) break; // If a cycle is found, break the loop\\n            }\\n\\n            // If no cycle is found, break the loop\\n            if (ncv == -1) break;\\n            boolean[] vis = new boolean[n]; // Array to store if a vertex is visited\\n            // Find the cycle by going through the previous vertices\\n            for(; !vis[ncv]; ncv = pv[ncv]){\\n                vis[ncv] = true;\\n            }\\n\\n            int u = ncv; // Start from the vertex in the cycle\\n            // Go through the cycle to reverse the cycle and update the answer\\n            do {\\n                int p = pv[u], i = pe[u]; // Get the previous vertex and edge\\n                ans += g.get(p).get(i).w; // Add the weight to the answer\\n                g.get(p).get(i).sw = 0; // Switch off the edge\\n                g.get(u).get(g.get(p).get(i).rev).sw = 1; // Switch on the reverse edge\\n                u = p; // Move to the previous vertex\\n            } while(u != ncv);\\n        }\\n        return ans; // Return the maximum number of requests that can be achieved\\n    }\\n}\\n```\n```java\\nclass Solution {\\n\\n    class Edge {\\n        int v, w, sw, rev;\\n        public Edge(int v, int w, int sw, int rev) {\\n            this.v = v;\\n            this.w = w;\\n            this.sw = sw;\\n            this.rev = rev;\\n        }\\n    }\\n\\n    public int maximumRequests(int n, int[][] requests) {\\n        ArrayList<Edge>[] g = new ArrayList[n];\\n        for (int i = 0; i < n; i++) g[i]=new ArrayList<>();\\n\\n        int ans = 0;\\n        for (int[] e : requests) {\\n            int u = e[0], v = e[1];\\n            if (u == v) {\\n                ans++;\\n                continue;\\n            }\\n            g[u].add(new Edge(v, 1, 1, g[v].size()));\\n            g[v].add(new Edge(u, -1, 0, g[u].size()-1));\\n        }\\n\\n        while (true) {\\n            int[] val=new int[n], pv=new int[n], pe=new int[n];\\n            int last=0;\\n            for(int c=0;c<=n&&last>=0;c++) {\\n                last=-1;\\n                for(int i=0;i<n;i++) {\\n                    int v=val[i];\\n                    for(int j=0;j<g[i].size();j++) {\\n                        Edge e=g[i].get(j);\\n                        if(e.sw==0||val[e.v]>=v+e.w) continue;\\n                        val[e.v]=v+e.w;\\n                        pv[e.v]=i;\\n                        pe[e.v]=j;\\n                        last=e.v;\\n                    }\\n                }\\n                if(last==-1) return ans;\\n            }\\n            boolean[] loop=new boolean[n];\\n            while(!loop[last]) {\\n                loop[last]=true;\\n                last=pv[last];\\n            }\\n\\n            int u = last;\\n            do {\\n                int p = pv[u], i = pe[u];\\n                ans += g[p].get(i).w;\\n                g[p].get(i).sw = 0;\\n                g[u].get(g[p].get(i).rev).sw = 1;\\n                u = p;\\n            } while(u != last);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3714395,
                "title": "a-solution-based-on-min-cost-flow-golang",
                "content": "# Intuition\\nThis problem can be solved using min cost flow, potentially on larger graphs. For this particular problem size, it is an overkill. I am doing this just to practice.\\n\\n# Approach\\nConsider the graph induced by the request, mark all edges with cost -1.\\nAlso two extra nodes source and target that is not connected to anything else, we can find the minimum cost flow between source and target. Obviously the flow is going to be zero, but the minimum cost part can help us to drive to maximize request satisfaction as part of the cost minimization process.\\n\\n# Complexity\\n- Time complexity:\\n$$ O(n^2C) $$, where $$ C $$ is the number of requests that could be satisfied. I am not particularly happy with this time bound, but I also don\\'t bother to implement minimum mean cycle cancellation which is usually much more complex and also slower in practice. I would be very wrong here since I don\\'t have much experiences implementing min cost flow.\\n\\n- Space complexity:\\n$$ O(E) $$\\uFF0Cwhere $$ E $$ is the number of edges (i.e. requests)\\n\\n# Code\\n```\\nimport (\\n\\t\"fmt\"\\n)\\n\\nfunc maximumRequests(n int, requests [][]int) int {\\n\\tcost := make([]int, n+1)\\n\\tnext := make([]int, n+1)\\n\\tpred := make([]int, n+1)\\n\\tflip := make([]bool, len(requests))\\n\\tinfinite := 100\\n\\tcount := 0\\n\\n\\tfor {\\t// Keep trying to cancel cycles\\n\\t    // The plan is to use Bellman Ford to find a negative cycle, eliminate it, and the reverse to\\n\\t\\t// the residual graph, and repeat until we cannot find one.\\n\\n\\t\\t// The problem with Bellman Ford is that it can only find negative cycle reachable from a source\\n\\t\\t// and we don\\'t have a source, so I added this node n as a virtual source that connects to every node\\n\\n\\t\\t// Now we can initialize the cost vector, with the node reachable at cost 0 and every other unreachable\\t\\t\\n\\t\\tfor i := 0; i < n+1; i++ {\\n\\t\\t\\tcost[i] = infinite\\n\\t\\t}\\n\\t\\tcost[n] = 0 \\n\\n\\t\\tfor round := 0; round < n+1; round++ { // Bellman Ford iterations\\n\\t\\t\\t// Initialize the costs for the next round with the current values\\n\\t\\t\\tfor i := 0; i < n+1; i++ {\\n\\t\\t\\t\\tnext[i] = cost[i]\\n\\t\\t\\t}\\n\\t\\t\\t// Relax all the virtual edges from source to every node\\n\\t\\t\\tfor s := 0; s < n; s++ {\\n\\t\\t\\t\\tif cost[n] != infinite && cost[s] > cost[n] {\\n\\t\\t\\t\\t\\tnext[s] = cost[n]\\n\\t\\t\\t\\t\\tpred[s] = n\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\t// Relax all the given edges\\n\\t\\t\\tfor e := 0; e < len(requests); e++ {\\n\\t\\t\\t\\tsrc := requests[e][0]\\n\\t\\t\\t\\tdst := requests[e][1]\\n\\t\\t\\t\\tweight := -1\\n\\t\\t\\t\\t// Note that an edge could be flipped because of the negative cycle cancellation.\\n\\t\\t\\t\\tif flip[e] {\\n\\t\\t\\t\\t\\tsrc, dst, weight = dst, src, -weight\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif cost[src] != infinite && cost[dst] > cost[src]+weight {\\n\\t\\t\\t\\t\\tnext[dst] = cost[src] + weight\\n\\t\\t\\t\\t\\t// Here we are doing something slightly unconventional here. I am saving the edge\\n\\t\\t\\t\\t\\t// as the predecesor of the node for the cycle cancellation purpose. Obviously we can\\n\\t\\t\\t\\t\\t// easily get to the actual predecesor node given the edge but not vice versa.\\n\\t\\t\\t\\t\\tpred[dst] = e\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\t// Once we are done, swap the cost and next to beging the next iteration.\\n\\t\\t\\tcost, next = next, cost\\n\\t\\t}\\n\\n\\t\\t// Since the graph has only n+1 nodes (including the virtual source). Any path with n \\n\\t\\t// edges must have a cycle and therefore longer than the shortest path if the cycle is \\n\\t\\t// positive. If we find any cost changes during the n and n+1 round, that must be due to\\n\\t\\t// a negative cycle\\n\\t\\tfound := false\\n\\t\\tnode := 0\\n\\t\\tfor i := 0; i < n+1; i++ {\\n\\t\\t\\tif cost[i] < next[i] {\\n\\t\\t\\t\\tfound = true\\n\\t\\t\\t\\tnode = i\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tif found {\\n\\t\\t\\t// Now we have found some node that has a change in cost, back tracking the edges\\n\\t\\t\\t// to find the cycle. During the walk, mark node as seen and keep the edges in a stack\\n\\t\\t\\tcur := node\\n\\t\\t\\tseen := make([]int, n)\\n\\t\\t\\tedgeStack := []int{}\\n\\t\\t\\tfor {\\n\\t\\t\\t\\tseen[cur] = 1\\n\\t\\t\\t\\te := pred[cur]\\n\\t\\t\\t\\tsrc := requests[e][0]\\n\\t\\t\\t\\tdst := requests[e][1]\\n\\t\\t\\t\\tif flip[e] {\\n\\t\\t\\t\\t\\tsrc, dst = dst, src\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tedgeStack = append(edgeStack, e)\\n\\t\\t\\t\\tcur = src\\n\\t\\t\\t\\tif seen[cur] == 1 {\\n\\t\\t\\t\\t\\t// Now that we have found the cycle, pop the edges and flip them all\\n\\t\\t\\t\\t\\t// Count the number of edges that is flipped from the original configuration\\n\\t\\t\\t\\t\\t// These are the requests that could be satisfied from the problem definition\\n\\t\\t\\t\\t\\t//\\n\\t\\t\\t\\t\\t// Note that the virtual edges from the source can never be part of a cycle so \\n\\t\\t\\t\\t\\t// we won\\'t accidentally count those.\\n\\t\\t\\t\\t\\tfor i := len(edgeStack) - 1; i >= 0; i-- {\\n\\t\\t\\t\\t\\t\\te := edgeStack[i]\\n\\t\\t\\t\\t\\t\\tsrc := requests[e][0]\\n\\t\\t\\t\\t\\t\\tdst := requests[e][1]\\n\\t\\t\\t\\t\\t\\tif flip[e] {\\n\\t\\t\\t\\t\\t\\t\\tsrc, dst = dst, src\\n\\t\\t\\t\\t\\t\\t\\tcount = count - 1\\n\\t\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\t\\tcount = count + 1\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\tflip[e] = !flip[e]\\n\\n\\t\\t\\t\\t\\t\\tif dst == cur {\\n\\t\\t\\t\\t\\t\\t\\tbreak\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tbreak\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t} else {\\n\\t\\t\\t// In case we cannot find a negative cycle in the residual graph, we are done\\n\\t\\t\\t// the flow cannot be optimized further for cost\\n\\t\\t\\tbreak\\n\\t\\t}\\n\\t}\\n\\n\\treturn count\\n}\\n\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nimport (\\n\\t\"fmt\"\\n)\\n\\nfunc maximumRequests(n int, requests [][]int) int {\\n\\tcost := make([]int, n+1)\\n\\tnext := make([]int, n+1)\\n\\tpred := make([]int, n+1)\\n\\tflip := make([]bool, len(requests))\\n\\tinfinite := 100\\n\\tcount := 0\\n\\n\\tfor {\\t// Keep trying to cancel cycles\\n\\t    // The plan is to use Bellman Ford to find a negative cycle, eliminate it, and the reverse to\\n\\t\\t// the residual graph, and repeat until we cannot find one.\\n\\n\\t\\t// The problem with Bellman Ford is that it can only find negative cycle reachable from a source\\n\\t\\t// and we don\\'t have a source, so I added this node n as a virtual source that connects to every node\\n\\n\\t\\t// Now we can initialize the cost vector, with the node reachable at cost 0 and every other unreachable\\t\\t\\n\\t\\tfor i := 0; i < n+1; i++ {\\n\\t\\t\\tcost[i] = infinite\\n\\t\\t}\\n\\t\\tcost[n] = 0 \\n\\n\\t\\tfor round := 0; round < n+1; round++ { // Bellman Ford iterations\\n\\t\\t\\t// Initialize the costs for the next round with the current values\\n\\t\\t\\tfor i := 0; i < n+1; i++ {\\n\\t\\t\\t\\tnext[i] = cost[i]\\n\\t\\t\\t}\\n\\t\\t\\t// Relax all the virtual edges from source to every node\\n\\t\\t\\tfor s := 0; s < n; s++ {\\n\\t\\t\\t\\tif cost[n] != infinite && cost[s] > cost[n] {\\n\\t\\t\\t\\t\\tnext[s] = cost[n]\\n\\t\\t\\t\\t\\tpred[s] = n\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\t// Relax all the given edges\\n\\t\\t\\tfor e := 0; e < len(requests); e++ {\\n\\t\\t\\t\\tsrc := requests[e][0]\\n\\t\\t\\t\\tdst := requests[e][1]\\n\\t\\t\\t\\tweight := -1\\n\\t\\t\\t\\t// Note that an edge could be flipped because of the negative cycle cancellation.\\n\\t\\t\\t\\tif flip[e] {\\n\\t\\t\\t\\t\\tsrc, dst, weight = dst, src, -weight\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif cost[src] != infinite && cost[dst] > cost[src]+weight {\\n\\t\\t\\t\\t\\tnext[dst] = cost[src] + weight\\n\\t\\t\\t\\t\\t// Here we are doing something slightly unconventional here. I am saving the edge\\n\\t\\t\\t\\t\\t// as the predecesor of the node for the cycle cancellation purpose. Obviously we can\\n\\t\\t\\t\\t\\t// easily get to the actual predecesor node given the edge but not vice versa.\\n\\t\\t\\t\\t\\tpred[dst] = e\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\t// Once we are done, swap the cost and next to beging the next iteration.\\n\\t\\t\\tcost, next = next, cost\\n\\t\\t}\\n\\n\\t\\t// Since the graph has only n+1 nodes (including the virtual source). Any path with n \\n\\t\\t// edges must have a cycle and therefore longer than the shortest path if the cycle is \\n\\t\\t// positive. If we find any cost changes during the n and n+1 round, that must be due to\\n\\t\\t// a negative cycle\\n\\t\\tfound := false\\n\\t\\tnode := 0\\n\\t\\tfor i := 0; i < n+1; i++ {\\n\\t\\t\\tif cost[i] < next[i] {\\n\\t\\t\\t\\tfound = true\\n\\t\\t\\t\\tnode = i\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tif found {\\n\\t\\t\\t// Now we have found some node that has a change in cost, back tracking the edges\\n\\t\\t\\t// to find the cycle. During the walk, mark node as seen and keep the edges in a stack\\n\\t\\t\\tcur := node\\n\\t\\t\\tseen := make([]int, n)\\n\\t\\t\\tedgeStack := []int{}\\n\\t\\t\\tfor {\\n\\t\\t\\t\\tseen[cur] = 1\\n\\t\\t\\t\\te := pred[cur]\\n\\t\\t\\t\\tsrc := requests[e][0]\\n\\t\\t\\t\\tdst := requests[e][1]\\n\\t\\t\\t\\tif flip[e] {\\n\\t\\t\\t\\t\\tsrc, dst = dst, src\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tedgeStack = append(edgeStack, e)\\n\\t\\t\\t\\tcur = src\\n\\t\\t\\t\\tif seen[cur] == 1 {\\n\\t\\t\\t\\t\\t// Now that we have found the cycle, pop the edges and flip them all\\n\\t\\t\\t\\t\\t// Count the number of edges that is flipped from the original configuration\\n\\t\\t\\t\\t\\t// These are the requests that could be satisfied from the problem definition\\n\\t\\t\\t\\t\\t//\\n\\t\\t\\t\\t\\t// Note that the virtual edges from the source can never be part of a cycle so \\n\\t\\t\\t\\t\\t// we won\\'t accidentally count those.\\n\\t\\t\\t\\t\\tfor i := len(edgeStack) - 1; i >= 0; i-- {\\n\\t\\t\\t\\t\\t\\te := edgeStack[i]\\n\\t\\t\\t\\t\\t\\tsrc := requests[e][0]\\n\\t\\t\\t\\t\\t\\tdst := requests[e][1]\\n\\t\\t\\t\\t\\t\\tif flip[e] {\\n\\t\\t\\t\\t\\t\\t\\tsrc, dst = dst, src\\n\\t\\t\\t\\t\\t\\t\\tcount = count - 1\\n\\t\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\t\\tcount = count + 1\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\tflip[e] = !flip[e]\\n\\n\\t\\t\\t\\t\\t\\tif dst == cur {\\n\\t\\t\\t\\t\\t\\t\\tbreak\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tbreak\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t} else {\\n\\t\\t\\t// In case we cannot find a negative cycle in the residual graph, we are done\\n\\t\\t\\t// the flow cannot be optimized further for cost\\n\\t\\t\\tbreak\\n\\t\\t}\\n\\t}\\n\\n\\treturn count\\n}\\n\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3710313,
                "title": "polynomial-solution-via-minimum-cost-circulation-beats-99-7",
                "content": "# Intuition\\n\\nThe task can be easily represented as a special case of minimum-cost [circulation problem](https://en.wikipedia.org/wiki/Circulation_problem). Note: in case you are not familiar with what flows and circulations are, my explanation will probably be rather hard to understand, sorry.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nTechnically we compute maximum-cost circulation, but the approach does not change.\\n\\nFor every request `[a, b]` we create two edges:\\n- \"Forward\" edge - `a` to `b` of capacity 1 and weight 1.\\n- \"Backward\" edge - `b` to `a` of capacity 0 and weight -1.\\n\\nAt every step of the algorithm we try to find a cycle of positive weight using Bellman-Ford algorithm. In case a cycle is found, we perform augmentation similar to max-flow algorithms (moving capacity from used edges into the opposite direction edges).\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(n^3\\\\cdot |requests|)$$, but in reality somewhat faster. If we were to store edge list instead of adjacency matrix, the complexity would be improved to $$O(n \\\\cdot |requests|^2)$$.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n^2)$$, but theoretically could do $$O(n+|requests|)$$ using edge lists.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> capFwd, capBwd;\\n\\n    int maximumRequests(int n, vector<vector<int>>& requests) {\\n        int result = 0;\\n        capFwd.assign(n, vector<int>(n));\\n        capBwd = capFwd;\\n        for (auto& r: requests) {\\n            int from = r[0];\\n            int to = r[1];\\n            if (from == to) {\\n                result += 1;\\n            } else {\\n                capFwd[from][to] += 1;\\n            }\\n        }\\n\\n        vector<int> from;\\n        vector<int> dist;\\n        \\n        for (;;) {\\n            dist.assign(n, 0);\\n            from.assign(n, -1);\\n            int changedIdx = -1;\\n\\n            // n steps of Bellman-Ford algorithm\\n            // to detect if there are cycles of positive weight.\\n            for (int step = 0; step < n; ++step) {\\n                changedIdx = -1;\\n                for (int i = 0; i < n; ++i) {\\n                    for (int j = 0; j < n; ++j) {\\n                        if (capFwd[i][j] > 0 && dist[j] >= dist[i]) {\\n                            changedIdx = j;\\n                            dist[j] = dist[i] - 1;\\n                            from[j] = i;\\n                        }\\n                        if (capBwd[i][j] > 0 && dist[j] >= dist[i] + 2) {\\n                            changedIdx = j;\\n                            dist[j] = dist[i] + 1;\\n                            from[j] = i;\\n                        }\\n                    }\\n                }\\n                if (changedIdx == -1) {\\n                    return result;\\n                }\\n            }\\n\\n            // Tortoise and hare algorithm:\\n            // finds a point on the cycle.\\n            for (int i = from[changedIdx]; i != changedIdx; ) {\\n                i = from[from[i]];\\n                changedIdx = from[changedIdx];\\n            }\\n            \\n            // Path augmentation\\n            int cur = changedIdx;\\n            do {\\n                int next = from[cur];\\n                if (capFwd[next][cur] > 0) {\\n                    result += 1;\\n                    capFwd[next][cur] -= 1;\\n                    capBwd[cur][next] += 1;\\n                } else {\\n                    result -= 1;\\n                    capFwd[cur][next] += 1;\\n                    capBwd[next][cur] -= 1;\\n                }\\n                cur = next;\\n            } while (cur != changedIdx);\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Two Pointers",
                    "Graph",
                    "Shortest Path"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> capFwd, capBwd;\\n\\n    int maximumRequests(int n, vector<vector<int>>& requests) {\\n        int result = 0;\\n        capFwd.assign(n, vector<int>(n));\\n        capBwd = capFwd;\\n        for (auto& r: requests) {\\n            int from = r[0];\\n            int to = r[1];\\n            if (from == to) {\\n                result += 1;\\n            } else {\\n                capFwd[from][to] += 1;\\n            }\\n        }\\n\\n        vector<int> from;\\n        vector<int> dist;\\n        \\n        for (;;) {\\n            dist.assign(n, 0);\\n            from.assign(n, -1);\\n            int changedIdx = -1;\\n\\n            // n steps of Bellman-Ford algorithm\\n            // to detect if there are cycles of positive weight.\\n            for (int step = 0; step < n; ++step) {\\n                changedIdx = -1;\\n                for (int i = 0; i < n; ++i) {\\n                    for (int j = 0; j < n; ++j) {\\n                        if (capFwd[i][j] > 0 && dist[j] >= dist[i]) {\\n                            changedIdx = j;\\n                            dist[j] = dist[i] - 1;\\n                            from[j] = i;\\n                        }\\n                        if (capBwd[i][j] > 0 && dist[j] >= dist[i] + 2) {\\n                            changedIdx = j;\\n                            dist[j] = dist[i] + 1;\\n                            from[j] = i;\\n                        }\\n                    }\\n                }\\n                if (changedIdx == -1) {\\n                    return result;\\n                }\\n            }\\n\\n            // Tortoise and hare algorithm:\\n            // finds a point on the cycle.\\n            for (int i = from[changedIdx]; i != changedIdx; ) {\\n                i = from[from[i]];\\n                changedIdx = from[changedIdx];\\n            }\\n            \\n            // Path augmentation\\n            int cur = changedIdx;\\n            do {\\n                int next = from[cur];\\n                if (capFwd[next][cur] > 0) {\\n                    result += 1;\\n                    capFwd[next][cur] -= 1;\\n                    capBwd[cur][next] += 1;\\n                } else {\\n                    result -= 1;\\n                    capFwd[cur][next] += 1;\\n                    capBwd[next][cur] -= 1;\\n                }\\n                cur = next;\\n            } while (cur != changedIdx);\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3710028,
                "title": "backtracking-c",
                "content": "```\\nclass Solution {\\n    void dfs(int i, int m, int cnt, vector<int> &v, vector<vector<int>> &req, int &ans) {\\n        if(i == m) {\\n            int f = 0;\\n            for(int i : v) {\\n                if(i) {\\n                    f = 1;\\n                    break;\\n                }\\n            }\\n            if(!f) ans = max(ans, cnt);\\n            return;\\n        }\\n\\n        dfs(i + 1, m, cnt, v, req, ans);\\n\\n        v[req[i][0]]--;\\n        v[req[i][1]]++;\\n        dfs(i + 1, m, cnt + 1, v, req, ans);\\n        v[req[i][0]]++;\\n        v[req[i][1]]--;\\n    }\\npublic:\\n    int maximumRequests(int n, vector<vector<int>>& requests) {\\n        int ans = 0, m = requests.size();\\n        vector<int> v(n);\\n        dfs(0, m, 0, v, requests, ans);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\n    void dfs(int i, int m, int cnt, vector<int> &v, vector<vector<int>> &req, int &ans) {\\n        if(i == m) {\\n            int f = 0;\\n            for(int i : v) {\\n                if(i) {\\n                    f = 1;\\n                    break;\\n                }\\n            }\\n            if(!f) ans = max(ans, cnt);\\n            return;\\n        }\\n\\n        dfs(i + 1, m, cnt, v, req, ans);\\n\\n        v[req[i][0]]--;\\n        v[req[i][1]]++;\\n        dfs(i + 1, m, cnt + 1, v, req, ans);\\n        v[req[i][0]]++;\\n        v[req[i][1]]--;\\n    }\\npublic:\\n    int maximumRequests(int n, vector<vector<int>>& requests) {\\n        int ans = 0, m = requests.size();\\n        vector<int> v(n);\\n        dfs(0, m, 0, v, requests, ans);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3709978,
                "title": "meet-in-the-middle-with-iterative-backtracking",
                "content": "# Intuition\\nThis problem can be solved in $$O(2^n)$$ with backtracking. Sometimes these types of backtracking problems can be optimized with meet in the middle.\\n\\n# Approach\\nSplit the `requests` array in half. For each half, keep track of the possible states (where a state consists of the degrees of all buildings) and the maximum requests that can be used to reach that state.\\n\\nFor each state in the left half, check if the complementary state on the right half exists. If so, update the answer.\\n\\n# Complexity\\n- Time complexity: $$O(n\\\\cdot 2^{n/2})$$\\n\\n- Space complexity: $$O(n\\\\cdot 2^{n/2})$$\\n\\n# Code\\n```python\\nclass Solution:\\n    def possibleDegrees(self, n: int, requests: list[list[int]], multiplier: int):\\n        # useful constant(s)\\n        lenRequests = len(requests)\\n\\n        # keep running degrees of each building\\n        degrees = [0] * n\\n\\n        yield tuple(degrees), 0\\n\\n        for mask in range(1, 1 << lenRequests):\\n            leftmostAddedBitPosition = (mask ^ (mask - 1)).bit_count() - 1\\n\\n            # remove requests previously added\\n            for i in range(leftmostAddedBitPosition):\\n                request = requests[i]\\n                degrees[request[0]] += multiplier\\n                degrees[request[1]] -= multiplier\\n            \\n            # add request\\n            request = requests[leftmostAddedBitPosition]\\n            degrees[request[0]] -= multiplier\\n            degrees[request[1]] += multiplier\\n            \\n            yield tuple(degrees), mask.bit_count()\\n\\n    def maximumRequests(self, n: int, requests: List[List[int]]) -> int:\\n        # useful constant(s)\\n        mid = (len(requests) + 1) // 2\\n        \\n        # accumulate states from left half\\n        left = {}\\n        for k, v in self.possibleDegrees(n, requests[:mid], 1):\\n            left[k] = max(v, left.get(k, v))\\n\\n        return max(v + left.get(k, -inf) for k, v in self.possibleDegrees(n, requests[mid:], -1))\\n```",
                "solutionTags": [
                    "Python3",
                    "Backtracking",
                    "Bit Manipulation",
                    "Enumeration"
                ],
                "code": "```python\\nclass Solution:\\n    def possibleDegrees(self, n: int, requests: list[list[int]], multiplier: int):\\n        # useful constant(s)\\n        lenRequests = len(requests)\\n\\n        # keep running degrees of each building\\n        degrees = [0] * n\\n\\n        yield tuple(degrees), 0\\n\\n        for mask in range(1, 1 << lenRequests):\\n            leftmostAddedBitPosition = (mask ^ (mask - 1)).bit_count() - 1\\n\\n            # remove requests previously added\\n            for i in range(leftmostAddedBitPosition):\\n                request = requests[i]\\n                degrees[request[0]] += multiplier\\n                degrees[request[1]] -= multiplier\\n            \\n            # add request\\n            request = requests[leftmostAddedBitPosition]\\n            degrees[request[0]] -= multiplier\\n            degrees[request[1]] += multiplier\\n            \\n            yield tuple(degrees), mask.bit_count()\\n\\n    def maximumRequests(self, n: int, requests: List[List[int]]) -> int:\\n        # useful constant(s)\\n        mid = (len(requests) + 1) // 2\\n        \\n        # accumulate states from left half\\n        left = {}\\n        for k, v in self.possibleDegrees(n, requests[:mid], 1):\\n            left[k] = max(v, left.get(k, v))\\n\\n        return max(v + left.get(k, -inf) for k, v in self.possibleDegrees(n, requests[mid:], -1))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3709803,
                "title": "c-backtrack-simplified-with-approach-comments",
                "content": "# Intuition\\nIn the problem, if you notice the constraints, the max no. of requests is 16 (which is a small no ans that gives us an idea that we can apply brute recursion) i.e. trying all test cases!\\nas the different cases can be 2^16 at max, which is do-able!\\n\\n# Approach\\nThe question is solved by basic Pick-notPick strategy, i.e. if u consider(pick) a request then reflect its consequences in the \\'vec\\' vector according to the respective building.\\nThen u can backtrack that request and remove its effect on the \\'vec\\' vector accordingly!\\n\\nAny suggestions and comments are welcome! Thanks!\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int ans=0;\\n    void achievable(int i, int x, int r, vector<int>& vec, vector<vector<int>>& req){\\n\\n        if(i==r){ //base case\\n            for(int i=0; i<vec.size(); i++){\\n                if(vec[i]!=0){\\n                    return; // if some value of vector isn\\'t 0 => that particular request wont work so we just return\\n                }\\n            }\\n            ans=max(ans,x);\\n            return;\\n        }\\n\\n        vec[req[i][0]]--;  // pick the request\\n        vec[req[i][1]]++;\\n        achievable(i+1,x+1,r,vec,req);\\n        vec[req[i][0]]++;   // not-pick the request\\n        vec[req[i][1]]--;\\n        achievable(i+1,x,r,vec,req);\\n    }\\n\\n    int maximumRequests(int n, vector<vector<int>>& requests) {\\n        \\n        int r = requests.size();\\n        int x=0; //x represents the no. of requests u entertain\\n        int i=0; // index of \\'requests\\' vector\\n        vector<int> vec(n,0); //vec[i] represents the total change in building \\'i\\'\\n        achievable(i,x,r,vec,requests);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int ans=0;\\n    void achievable(int i, int x, int r, vector<int>& vec, vector<vector<int>>& req){\\n\\n        if(i==r){ //base case\\n            for(int i=0; i<vec.size(); i++){\\n                if(vec[i]!=0){\\n                    return; // if some value of vector isn\\'t 0 => that particular request wont work so we just return\\n                }\\n            }\\n            ans=max(ans,x);\\n            return;\\n        }\\n\\n        vec[req[i][0]]--;  // pick the request\\n        vec[req[i][1]]++;\\n        achievable(i+1,x+1,r,vec,req);\\n        vec[req[i][0]]++;   // not-pick the request\\n        vec[req[i][1]]--;\\n        achievable(i+1,x,r,vec,req);\\n    }\\n\\n    int maximumRequests(int n, vector<vector<int>>& requests) {\\n        \\n        int r = requests.size();\\n        int x=0; //x represents the no. of requests u entertain\\n        int i=0; // index of \\'requests\\' vector\\n        vector<int> vec(n,0); //vec[i] represents the total change in building \\'i\\'\\n        achievable(i,x,r,vec,requests);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3709657,
                "title": "c-easiest-back-tracking-intuition-solution-no-bitmasking",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThis problem can be deceiving at the first look because it talks about connections and indegree/outdegree concept. But it is a variation of \"Partition to K Equal Sum Subsets\" where the partitioning can be thought of as **making sure that equal number of residents participate to move into or out of the building**.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe will use a simple backtracking based approach. \\n\\nWe will cater each and every request and track the total net flow (total incomers and outgoers in each building) that happens with each of the request. At the end we see if net flow has remained constant for each building (0) and accordingly save the answers.\\n\\nTrackers used:\\n1. `buildingNetFlow` to keep track of the net inflow outflow of buildings\\n2. `acceptedRequests` to keep tally of the accepted request in the current stack space\\n3. `requestNo` to keep track of the current request being catered\\n4. `ans` stores the maximum possible applications that fit the criteria\\n\\nGo through every single application and make recursive calls on:\\n    \\n **Accepting the application-** We will increment \"`acceptedApplications`\" by 1, and increment \"`requestNo`\" by 1 (to move to next request), store the specific `incoming` and `outgoing` persons and set the `buildingNetFlow` accordingly.\\n    \\n    \\n**Rejecting the application-** We will increment \"`requestNo`\" by 1 (to move to next request)\\n\\nOur base case for each recursive call would be- Reaching the end of the `requests` list. We will check if the `buildingNetFlow` satisfies our condition that *\"net flow across all buildings is 0\".*\\n\\nIf it satisfies we store the max till that instance into `ans`. \\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(K*2^n), where K is the tree stack, n is the number of applications\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(N), where N is the number of buildings\\n\\n#### Further Optimization\\nThis solution can be further optimized by memoization (DP), storing the each individual combination of decisions to derive the answers for later recursion that merge to the same path.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    void processApplications( vector<vector<int>>&requests,\\n        vector<int> buildingNetFlow,\\n        int acceptedRequests,\\n        int totalRequests,\\n        int requestNo,\\n        int&ans\\n    ){\\n        if(requestNo == totalRequests){\\n            //check for the validity\\n            for(auto it: buildingNetFlow){\\n                if(it != 0) return;\\n            }\\n            //store the minimum \\n            ans = max(ans, acceptedRequests);\\n            return;\\n        }\\n\\n        //call the recursion\\n        processApplications(requests, buildingNetFlow, acceptedRequests, totalRequests, requestNo+1, ans);\\n\\n        // accept the request \\n        int outgoing = requests[requestNo][0];\\n        int incoming = requests[requestNo][1];\\n        buildingNetFlow[outgoing]--;\\n        buildingNetFlow[incoming]++;\\n\\n        // call the recursion\\n        processApplications(requests, buildingNetFlow, acceptedRequests+1, totalRequests, requestNo+1, ans);\\n\\n        return;\\n        \\n    }\\n\\n    int maximumRequests(int n, vector<vector<int>>& requests) {\\n        //currently all buildings are full and proportioned \\n        vector<int> buildingNetFlow(n, 0);\\n        int totalRequests = requests.size();\\n        int acceptedRequests = 0;\\n        int ans = INT_MIN;\\n        processApplications(requests, buildingNetFlow, acceptedRequests, totalRequests, 0, ans);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    void processApplications( vector<vector<int>>&requests,\\n        vector<int> buildingNetFlow,\\n        int acceptedRequests,\\n        int totalRequests,\\n        int requestNo,\\n        int&ans\\n    ){\\n        if(requestNo == totalRequests){\\n            //check for the validity\\n            for(auto it: buildingNetFlow){\\n                if(it != 0) return;\\n            }\\n            //store the minimum \\n            ans = max(ans, acceptedRequests);\\n            return;\\n        }\\n\\n        //call the recursion\\n        processApplications(requests, buildingNetFlow, acceptedRequests, totalRequests, requestNo+1, ans);\\n\\n        // accept the request \\n        int outgoing = requests[requestNo][0];\\n        int incoming = requests[requestNo][1];\\n        buildingNetFlow[outgoing]--;\\n        buildingNetFlow[incoming]++;\\n\\n        // call the recursion\\n        processApplications(requests, buildingNetFlow, acceptedRequests+1, totalRequests, requestNo+1, ans);\\n\\n        return;\\n        \\n    }\\n\\n    int maximumRequests(int n, vector<vector<int>>& requests) {\\n        //currently all buildings are full and proportioned \\n        vector<int> buildingNetFlow(n, 0);\\n        int totalRequests = requests.size();\\n        int acceptedRequests = 0;\\n        int ans = INT_MIN;\\n        processApplications(requests, buildingNetFlow, acceptedRequests, totalRequests, 0, ans);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3709422,
                "title": "c-java-python-solution-using-backtracking-faster-80-39-98-ms-memory-100-8-6-mb",
                "content": "\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n\\n\\nThe `maximumRequests` function initializes a vector `v` of size `n` with all elements initialized to 0. This vector represents the current state of the buildings. Each element in the vector represents the net change in the number of requests for a particular building. Positive values indicate that there are more requests for that building, while negative values indicate that there are more requests to leave that building.\\n\\nThe function then calls a helper function `helper` with the initial index set to 0. The `helper` function is a recursive function that tries to fulfill each request and computes the maximum number of requests that can be fulfilled.\\n\\nIn the `helper` function, if the index reaches the end of the requests vector (`index == requests.size()`), it checks if all buildings have zero net requests. If they do, it returns 0, indicating that all requests have been fulfilled. Otherwise, it returns a large negative value `INT_MIN`, indicating that this state is not valid.\\n\\nIf the index is not at the end of the requests vector, the function proceeds to handle the current request. It decreases the net request count for the building at `requests[index][0]` and increases the count for the building at `requests[index][1]`. It then recursively calls the `helper` function with the index incremented by 1.\\n\\nAfter the recursive call, the function restores the net request counts for the current request by increasing the count for the building at `requests[index][0]` and decreasing the count for the building at `requests[index][1]`. This is done to backtrack and consider other possible combinations of requests.\\n\\nThe function then calculates two values: `take` and `notTake`. `take` represents the maximum number of requests that can be fulfilled if the current request is taken into account. It adds 1 to the result of the recursive call (`1 + helper(index + 1, n, requests, v)`).\\n\\n`notTake` represents the maximum number of requests that can be fulfilled if the current request is not taken into account. It calls the recursive function without changing the net request counts (`helper(index + 1, n, requests, v)`).\\n\\nFinally, the function returns the maximum value between `take` and `notTake`, representing the maximum number of requests that can be fulfilled considering the current state.\\n\\n\\n\\n# Code\\n\\n# C++\\n```\\nclass Solution {\\n    \\n\\n    int helper(int index, int n,vector<vector<int>>& requests,vector<int> &v){\\n\\n        if(index==requests.size()){\\n            for(int i=0;i<n;i++){\\n                if(v[i]!=0) return INT_MIN;\\n            }\\n            return 0;\\n        }\\n\\n        v[requests[index][0]]-=1;\\n        v[requests[index][1]]+=1;\\n        int take=1+helper(index+1,n,requests,v);\\n        v[requests[index][0]]+=1;\\n        v[requests[index][1]]-=1;\\n        int notTake=helper(index+1,n,requests,v);\\n\\n\\n        return max(take,notTake);\\n    }\\n\\n\\npublic:\\n    int maximumRequests(int n, vector<vector<int>>& requests) {\\n        vector<int> v(n,0);\\n        return helper(0,n, requests,v);\\n    }\\n};\\n```\\n# Java\\n```\\nclass Solution {\\n    private int helper(int index, int n, List<List<Integer>> requests, List<Integer> v) {\\n        if (index == requests.size()) {\\n            for (int i = 0; i < n; i++) {\\n                if (v.get(i) != 0)\\n                    return Integer.MIN_VALUE;\\n            }\\n            return 0;\\n        }\\n        \\n        v.set(requests.get(index).get(0), v.get(requests.get(index).get(0)) - 1);\\n        v.set(requests.get(index).get(1), v.get(requests.get(index).get(1)) + 1);\\n        int take = 1 + helper(index + 1, n, requests, v);\\n        v.set(requests.get(index).get(0), v.get(requests.get(index).get(0)) + 1);\\n        v.set(requests.get(index).get(1), v.get(requests.get(index).get(1)) - 1);\\n        int notTake = helper(index + 1, n, requests, v);\\n        \\n        return Math.max(take, notTake);\\n    }\\n    \\n    public int maximumRequests(int n, List<List<Integer>> requests) {\\n        List<Integer> v = new ArrayList<>(n);\\n        for (int i = 0; i < n; i++) {\\n            v.add(0);\\n        }\\n        return helper(0, n, requests, v);\\n    }\\n}\\n\\n```\\n\\n# Python\\n\\n```\\nclass Solution:\\n    def helper(self, index, n, requests, v):\\n        if index == len(requests):\\n            for i in range(n):\\n                if v[i] != 0:\\n                    return float(\\'-inf\\')\\n            return 0\\n\\n        v[requests[index][0]] -= 1\\n        v[requests[index][1]] += 1\\n        take = 1 + self.helper(index + 1, n, requests, v)\\n        v[requests[index][0]] += 1\\n        v[requests[index][1]] -= 1\\n        notTake = self.helper(index + 1, n, requests, v)\\n\\n        return max(take, notTake)\\n\\n    def maximumRequests(self, n, requests):\\n        v = [0] * n\\n        return self.helper(0, n, requests, v)\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "Hash Table",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\n    \\n\\n    int helper(int index, int n,vector<vector<int>>& requests,vector<int> &v){\\n\\n        if(index==requests.size()){\\n            for(int i=0;i<n;i++){\\n                if(v[i]!=0) return INT_MIN;\\n            }\\n            return 0;\\n        }\\n\\n        v[requests[index][0]]-=1;\\n        v[requests[index][1]]+=1;\\n        int take=1+helper(index+1,n,requests,v);\\n        v[requests[index][0]]+=1;\\n        v[requests[index][1]]-=1;\\n        int notTake=helper(index+1,n,requests,v);\\n\\n\\n        return max(take,notTake);\\n    }\\n\\n\\npublic:\\n    int maximumRequests(int n, vector<vector<int>>& requests) {\\n        vector<int> v(n,0);\\n        return helper(0,n, requests,v);\\n    }\\n};\\n```\n```\\nclass Solution {\\n    private int helper(int index, int n, List<List<Integer>> requests, List<Integer> v) {\\n        if (index == requests.size()) {\\n            for (int i = 0; i < n; i++) {\\n                if (v.get(i) != 0)\\n                    return Integer.MIN_VALUE;\\n            }\\n            return 0;\\n        }\\n        \\n        v.set(requests.get(index).get(0), v.get(requests.get(index).get(0)) - 1);\\n        v.set(requests.get(index).get(1), v.get(requests.get(index).get(1)) + 1);\\n        int take = 1 + helper(index + 1, n, requests, v);\\n        v.set(requests.get(index).get(0), v.get(requests.get(index).get(0)) + 1);\\n        v.set(requests.get(index).get(1), v.get(requests.get(index).get(1)) - 1);\\n        int notTake = helper(index + 1, n, requests, v);\\n        \\n        return Math.max(take, notTake);\\n    }\\n    \\n    public int maximumRequests(int n, List<List<Integer>> requests) {\\n        List<Integer> v = new ArrayList<>(n);\\n        for (int i = 0; i < n; i++) {\\n            v.add(0);\\n        }\\n        return helper(0, n, requests, v);\\n    }\\n}\\n\\n```\n```\\nclass Solution:\\n    def helper(self, index, n, requests, v):\\n        if index == len(requests):\\n            for i in range(n):\\n                if v[i] != 0:\\n                    return float(\\'-inf\\')\\n            return 0\\n\\n        v[requests[index][0]] -= 1\\n        v[requests[index][1]] += 1\\n        take = 1 + self.helper(index + 1, n, requests, v)\\n        v[requests[index][0]] += 1\\n        v[requests[index][1]] -= 1\\n        notTake = self.helper(index + 1, n, requests, v)\\n\\n        return max(take, notTake)\\n\\n    def maximumRequests(self, n, requests):\\n        v = [0] * n\\n        return self.helper(0, n, requests, v)\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3709336,
                "title": "backtracking-solution-java-python-c",
                "content": "**Java**\\n```\\nclass Solution {\\n    int answer = 0;\\n    public int maximumRequests(int n, int[][] requests) {\\n        int[] inDegree = new int[n];\\n        helper(0,0,inDegree,requests);\\n        return answer;\\n    }\\n    private void helper(int index,int count, int[] indegree,int[][] requests) {\\n        if(index == requests.length) {\\n            \\n            for(int i: indegree) {\\n                if(i != 0) return;    \\n            }\\n            answer = Math.max(answer, count);\\n            return;\\n        }\\n        \\n        \\n        indegree[requests[index][0]]--;\\n        indegree[requests[index][1]]++;\\n        helper(index + 1, count + 1, indegree,requests);\\n        indegree[requests[index][0]]++;\\n        indegree[requests[index][1]]--;\\n        helper(index + 1, count, indegree, requests);\\n    }\\n}\\n```\\n\\n**C++**\\n\\n```\\nclass Solution {\\npublic:\\n    int answer = 0;\\n    int maximumRequests(int n, vector<vector<int>>& requests) {\\n        answer = 0;\\n        vector<int> inDegree(n, 0);\\n        helper(0, 0, inDegree, requests);\\n        return answer;\\n    }\\n    void helper(int index, int count, vector<int>& inDegree, vector<vector<int>>& requests) {\\n        if (index == requests.size()) {\\n            for (int i : inDegree) {\\n                if (i != 0)\\n                    return;\\n            }\\n            answer = max(answer, count);\\n            return;\\n        }\\n        inDegree[requests[index][0]]++;\\n        inDegree[requests[index][1]]--;\\n        helper(index + 1, count + 1, inDegree, requests);\\n        inDegree[requests[index][0]]--;\\n        inDegree[requests[index][1]]++;\\n        helper(index + 1, count, inDegree, requests);\\n    }\\n};\\n```\\n\\n**Python3**\\n\\n\\n```\\nclass Solution:\\n    def maximumRequests(self, n: int, requests: List[List[int]]) -> int:\\n        self.answer = 0\\n        in_degree = [0] * n\\n        self.helper(0, 0, in_degree, requests)\\n        return self.answer\\n    \\n    def helper(self, index, count, in_degree, requests):\\n        if index == len(requests):\\n            for i in in_degree:\\n                if i != 0:\\n                    return\\n            self.answer = max(self.answer, count)\\n            return\\n\\n        in_degree[requests[index][0]] += 1\\n        in_degree[requests[index][1]] -= 1\\n        self.helper(index + 1, count + 1, in_degree, requests)\\n        in_degree[requests[index][0]] -= 1\\n        in_degree[requests[index][1]] += 1\\n        self.helper(index + 1, count, in_degree, requests)\\n```\\n",
                "solutionTags": [
                    "Java",
                    "Python",
                    "Python3",
                    "C",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\n    int answer = 0;\\n    public int maximumRequests(int n, int[][] requests) {\\n        int[] inDegree = new int[n];\\n        helper(0,0,inDegree,requests);\\n        return answer;\\n    }\\n    private void helper(int index,int count, int[] indegree,int[][] requests) {\\n        if(index == requests.length) {\\n            \\n            for(int i: indegree) {\\n                if(i != 0) return;    \\n            }\\n            answer = Math.max(answer, count);\\n            return;\\n        }\\n        \\n        \\n        indegree[requests[index][0]]--;\\n        indegree[requests[index][1]]++;\\n        helper(index + 1, count + 1, indegree,requests);\\n        indegree[requests[index][0]]++;\\n        indegree[requests[index][1]]--;\\n        helper(index + 1, count, indegree, requests);\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    int answer = 0;\\n    int maximumRequests(int n, vector<vector<int>>& requests) {\\n        answer = 0;\\n        vector<int> inDegree(n, 0);\\n        helper(0, 0, inDegree, requests);\\n        return answer;\\n    }\\n    void helper(int index, int count, vector<int>& inDegree, vector<vector<int>>& requests) {\\n        if (index == requests.size()) {\\n            for (int i : inDegree) {\\n                if (i != 0)\\n                    return;\\n            }\\n            answer = max(answer, count);\\n            return;\\n        }\\n        inDegree[requests[index][0]]++;\\n        inDegree[requests[index][1]]--;\\n        helper(index + 1, count + 1, inDegree, requests);\\n        inDegree[requests[index][0]]--;\\n        inDegree[requests[index][1]]++;\\n        helper(index + 1, count, inDegree, requests);\\n    }\\n};\\n```\n```\\nclass Solution:\\n    def maximumRequests(self, n: int, requests: List[List[int]]) -> int:\\n        self.answer = 0\\n        in_degree = [0] * n\\n        self.helper(0, 0, in_degree, requests)\\n        return self.answer\\n    \\n    def helper(self, index, count, in_degree, requests):\\n        if index == len(requests):\\n            for i in in_degree:\\n                if i != 0:\\n                    return\\n            self.answer = max(self.answer, count)\\n            return\\n\\n        in_degree[requests[index][0]] += 1\\n        in_degree[requests[index][1]] -= 1\\n        self.helper(index + 1, count + 1, in_degree, requests)\\n        in_degree[requests[index][0]] -= 1\\n        in_degree[requests[index][1]] += 1\\n        self.helper(index + 1, count, in_degree, requests)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3709176,
                "title": "backtracking-little-optimisation-pruning",
                "content": "```\\npublic int maximumRequests(int n, int[][] requests) {\\n        int[] opt = new int[n];\\n        for(int i=0; i<requests.length; i++){\\n            opt[requests[i][0]]++; //build the leaving count\\n        }\\n        return helper(0,new int[n],requests,n,opt);\\n    }\\n    public int helper(int i,int[] hash,int[][] requests,int n,int[] opt){\\n        if(i==requests.length){\\n            for(int x:hash){\\n                if(x!=0) return -100;\\n            }\\n            return 0;\\n        }\\n        int take = -100;\\n        int u = requests[i][0];\\n        int v = requests[i][1];\\n        **if(opt[v]>0){ // check if someone is goint out from there or not**\\n            hash[u]--;\\n            hash[v]++;\\n            opt[v]--;\\n            take = 1+helper(i+1,hash,requests,n,opt);\\n            opt[v]++;\\n            hash[u]++;\\n            hash[v]--;\\n        }\\n        int notTake = helper(i+1,hash,requests,n,opt);\\n        return Math.max(take,notTake);\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Backtracking"
                ],
                "code": "```\\npublic int maximumRequests(int n, int[][] requests) {\\n        int[] opt = new int[n];\\n        for(int i=0; i<requests.length; i++){\\n            opt[requests[i][0]]++; //build the leaving count\\n        }\\n        return helper(0,new int[n],requests,n,opt);\\n    }\\n    public int helper(int i,int[] hash,int[][] requests,int n,int[] opt){\\n        if(i==requests.length){\\n            for(int x:hash){\\n                if(x!=0) return -100;\\n            }\\n            return 0;\\n        }\\n        int take = -100;\\n        int u = requests[i][0];\\n        int v = requests[i][1];\\n        **if(opt[v]>0){ // check if someone is goint out from there or not**\\n            hash[u]--;\\n            hash[v]++;\\n            opt[v]--;\\n            take = 1+helper(i+1,hash,requests,n,opt);\\n            opt[v]++;\\n            hash[u]++;\\n            hash[v]--;\\n        }\\n        int notTake = helper(i+1,hash,requests,n,opt);\\n        return Math.max(take,notTake);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3708755,
                "title": "q1601-accepted-c-used-rec-backtracking-easiest",
                "content": "CRUX\\n1) Counting the number of viable requests possible.\\n2) If the resultant movement of employee\\u2019s is 0 then they are considered accepted.\\n3) Base Case : Move till the last idx and check for the vector \\'v\\' if all v[i] = 0, this implies that net movement in zero. Thus Accepted.\\n4) Backtracking is used to move along all request whether to take or not-take.\\n\\n\\n```\\nclass Solution {\\npublic:\\n    int ans = 0;\\n    int temp = 0;\\n    void solve(int idx,int n,vector<int> &v,vector<vector<int>> &requests){\\n        if(idx == requests.size()){\\n            for(auto i:v){ // Check that all transfers result to net-zero. \\n                if(i != 0){\\n                    return;\\n                }\\n            }\\n            ans = max(ans,temp);\\n            return;\\n        }\\n        solve(idx+1,n,v,requests);\\n        temp++;\\n        v[requests[idx][0]]--;\\n        v[requests[idx][1]]++;\\n        solve(idx+1,n,v,requests);\\n        temp--;\\n        v[requests[idx][0]]++; // Backtracking \\n        v[requests[idx][1]]--;\\n    }\\n    int maximumRequests(int n, vector<vector<int>>& requests) {\\n        vector<int> v(n,0); \\n        solve(0,n,v,requests);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int ans = 0;\\n    int temp = 0;\\n    void solve(int idx,int n,vector<int> &v,vector<vector<int>> &requests){\\n        if(idx == requests.size()){\\n            for(auto i:v){ // Check that all transfers result to net-zero. \\n                if(i != 0){\\n                    return;\\n                }\\n            }\\n            ans = max(ans,temp);\\n            return;\\n        }\\n        solve(idx+1,n,v,requests);\\n        temp++;\\n        v[requests[idx][0]]--;\\n        v[requests[idx][1]]++;\\n        solve(idx+1,n,v,requests);\\n        temp--;\\n        v[requests[idx][0]]++; // Backtracking \\n        v[requests[idx][1]]--;\\n    }\\n    int maximumRequests(int n, vector<vector<int>>& requests) {\\n        vector<int> v(n,0); \\n        solve(0,n,v,requests);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3708725,
                "title": "c-made-simple-easy-solution",
                "content": "# Complexity\\n- Time complexity: $$O(2^n)$$\\n\\n- Space complexity: $$O(2^n)$$\\n\\n# Code\\n```\\npublic class Solution {\\n\\n    int MaxCount;\\n\\n    public bool IsValid(int[] transfers){\\n        return (transfers.Min() >= 0);\\n    }\\n\\n    public void Traverse(int index, int count, int[] transfers, int[][] requests){\\n\\n        if (IsValid(transfers)){\\n            this.MaxCount = Math.Max(count, MaxCount);\\n        }\\n\\n        if (index == requests.Length){\\n            return;\\n        }\\n\\n        int from = requests[index][0];\\n        int to = requests[index][1];\\n\\n        transfers[from]--;\\n        transfers[to]++;\\n\\n        Traverse(index + 1, count + 1, (int[]) transfers.Clone(), requests);\\n\\n        transfers[from]++;\\n        transfers[to]--;\\n\\n        Traverse(index + 1, count, (int[]) transfers.Clone(), requests);\\n    }\\n\\n\\n    public int MaximumRequests(int n, int[][] requests) {\\n        int[] transfers = new int[n];\\n        this.MaxCount = 0;\\n        Traverse(0, 0, transfers, requests);\\n        return this.MaxCount;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n\\n    int MaxCount;\\n\\n    public bool IsValid(int[] transfers){\\n        return (transfers.Min() >= 0);\\n    }\\n\\n    public void Traverse(int index, int count, int[] transfers, int[][] requests){\\n\\n        if (IsValid(transfers)){\\n            this.MaxCount = Math.Max(count, MaxCount);\\n        }\\n\\n        if (index == requests.Length){\\n            return;\\n        }\\n\\n        int from = requests[index][0];\\n        int to = requests[index][1];\\n\\n        transfers[from]--;\\n        transfers[to]++;\\n\\n        Traverse(index + 1, count + 1, (int[]) transfers.Clone(), requests);\\n\\n        transfers[from]++;\\n        transfers[to]--;\\n\\n        Traverse(index + 1, count, (int[]) transfers.Clone(), requests);\\n    }\\n\\n\\n    public int MaximumRequests(int n, int[][] requests) {\\n        int[] transfers = new int[n];\\n        this.MaxCount = 0;\\n        Traverse(0, 0, transfers, requests);\\n        return this.MaxCount;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3708572,
                "title": "simple-recursion-select-not-select-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIt\\'s a simple pick, notPick recursion. We need to select maximum number of requests..\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Keep an array to track the number  of changes, in base condition if all the elements of array are 0 return 0, else INT_MIN, so that it can\\'t be selected.\\n2. The index of building represents the changes, if we pick then build[from]-- , build[to]++;\\n3. Then before not picking build[from]++ , build[to]--; \\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(2^n * n) \\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n+logn) including the recursion call stack.\\n\\n# Code\\n```\\nclass Solution {\\n    vector<int>build;\\n    int solve(int i , vector<vector<int>>& requests){\\n        if(i==requests.size()){\\n            for(auto it : build) if(it) return -1e8;\\n            return 0;\\n        }\\n        // pick\\n        int x = requests[i][0];\\n        int y = requests[i][1];\\n\\n        build[x]--;\\n        build[y]++;\\n        int pick  = 1 + solve(i+1 , requests);\\n        build[x]++;\\n        build[y]--;\\n        // not pick\\n        int notpick = solve(i+1 , requests);\\n\\n        return max(pick , notpick);\\n\\n    }\\npublic:\\n    int maximumRequests(int n, vector<vector<int>>& requests) {\\n        build.resize(n);\\n        return solve(0, requests);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n    vector<int>build;\\n    int solve(int i , vector<vector<int>>& requests){\\n        if(i==requests.size()){\\n            for(auto it : build) if(it) return -1e8;\\n            return 0;\\n        }\\n        // pick\\n        int x = requests[i][0];\\n        int y = requests[i][1];\\n\\n        build[x]--;\\n        build[y]++;\\n        int pick  = 1 + solve(i+1 , requests);\\n        build[x]++;\\n        build[y]--;\\n        // not pick\\n        int notpick = solve(i+1 , requests);\\n\\n        return max(pick , notpick);\\n\\n    }\\npublic:\\n    int maximumRequests(int n, vector<vector<int>>& requests) {\\n        build.resize(n);\\n        return solve(0, requests);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3708466,
                "title": "easy-solution-comments-for-each-logic",
                "content": "# Intuition\\nThe given code is a recursive solution to find the maximum number of successful requests that can be accommodated based on the available spaces in different buildings.\\n\\n# Approach\\n1. The `maximumRequests` function initializes an array called `spaces` with `n` elements, representing the number of buildings. Each element is initially set to 0, indicating no available space.\\n\\n2. It calls the `getMaxReq` function, passing the initial parameters: `ind` (starting index), `requests` (the input array of requests), `spaces` array, and `countOfSuccessfulReq` (the count of successful requests).\\n\\n3. The `getMaxReq` function is a recursive function that uses Backtracking to explore different combinations of accepting or rejecting requests.\\n\\n4. The base case is when `ind` equals the length of the `requests` array, indicating that all requests have been processed.\\n\\n5. Inside the base case, it checks if all elements in the `spaces` array are `0`. If they are, it means all requests have been successfully accommodated, so it returns `countOfSuccessfulReq`.\\n\\n6. The recursive part begins by taking the current request from the `requests` array and updating the `spaces` array accordingly.\\n\\n7. It then recursively calls `getMaxReq` for the next index (`ind + 1`) while incrementing `countOfSuccessfulReq` by 1 to simulate accepting the request.\\n\\n8. After the recursive call, it reverts the changes made to the `spaces` array to simulate not accepting the request.\\n\\n9. It recursively calls `getMaxReq` again for the next index (`ind + 1`) while keeping `countOfSuccessfulReq` unchanged to simulate not accepting the request.\\n\\n10. Finally, it returns the maximum value between the results of accepting the request (`taken`) and not accepting the request (`notTaken`).\\n\\n# Complexity\\n- Exponential Time complexity: $$O(2^N)$$\\n\\n- Space complexity: $$O(N)$$\\n\\n\\n# Javascript Code\\n```\\nfunction maximumRequests(n, requests){\\n\\n    // Initially for all buildings we will have 0 space\\n    const spaces = new Array(n).fill(0);\\n    return getMaxReq(0, requests, spaces, 0);\\n};\\n\\nfunction getMaxReq(ind, req, spaces, countOfSuccessfulReq){\\n    if (ind === req.length) {\\n        // if any building have no extra spaces\\n        // means we can accept the request count\\n        // otherwise not accepting at all\\n        for(let space of spaces){\\n            if(space !== 0) return 0\\n        }\\n        return countOfSuccessfulReq;\\n    }\\n\\n    const [from, to] = req[ind];\\n    spaces[from]--;\\n    spaces[to]++;\\n    // try by accepting the request\\n    const taken = getMaxReq(ind + 1, req, spaces, countOfSuccessfulReq + 1);\\n    spaces[from]++;\\n    spaces[to]--;\\n    // try by not accepting the request\\n    const notTaken = getMaxReq(ind + 1, req, spaces, countOfSuccessfulReq);\\n    return Math.max(notTaken, taken);\\n}\\n```\\n\\n---\\n\\n# Typescript Code\\n```\\nfunction maximumRequests(n: number, requests: number[][]): number {\\n\\n    // Initially for all buildings we will have 0 space\\n    const spaces: number[] = new Array(n).fill(0);\\n    return getMaxReq(0, requests, spaces, 0);\\n};\\n\\nfunction getMaxReq(ind: number, req: number[][], spaces: number[], countOfSuccessfulReq: number): number {\\n    if (ind === req.length) {\\n        // if any building have no extra spaces\\n        // means we can accept the request count\\n        // otherwise not accepting at all\\n        for(let space of spaces){\\n            if(space !== 0) return 0\\n        }\\n        return countOfSuccessfulReq;\\n    }\\n\\n    const [from, to] = req[ind];\\n    spaces[from]--;\\n    spaces[to]++;\\n    // try by accepting the request\\n    const taken = getMaxReq(ind + 1, req, spaces, countOfSuccessfulReq + 1);\\n    spaces[from]++;\\n    spaces[to]--;\\n    // try by not accepting the request\\n    const notTaken = getMaxReq(ind + 1, req, spaces, countOfSuccessfulReq);\\n    return Math.max(notTaken, taken);\\n}\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript",
                    "Recursion"
                ],
                "code": "```\\nfunction maximumRequests(n, requests){\\n\\n    // Initially for all buildings we will have 0 space\\n    const spaces = new Array(n).fill(0);\\n    return getMaxReq(0, requests, spaces, 0);\\n};\\n\\nfunction getMaxReq(ind, req, spaces, countOfSuccessfulReq){\\n    if (ind === req.length) {\\n        // if any building have no extra spaces\\n        // means we can accept the request count\\n        // otherwise not accepting at all\\n        for(let space of spaces){\\n            if(space !== 0) return 0\\n        }\\n        return countOfSuccessfulReq;\\n    }\\n\\n    const [from, to] = req[ind];\\n    spaces[from]--;\\n    spaces[to]++;\\n    // try by accepting the request\\n    const taken = getMaxReq(ind + 1, req, spaces, countOfSuccessfulReq + 1);\\n    spaces[from]++;\\n    spaces[to]--;\\n    // try by not accepting the request\\n    const notTaken = getMaxReq(ind + 1, req, spaces, countOfSuccessfulReq);\\n    return Math.max(notTaken, taken);\\n}\\n```\n```\\nfunction maximumRequests(n: number, requests: number[][]): number {\\n\\n    // Initially for all buildings we will have 0 space\\n    const spaces: number[] = new Array(n).fill(0);\\n    return getMaxReq(0, requests, spaces, 0);\\n};\\n\\nfunction getMaxReq(ind: number, req: number[][], spaces: number[], countOfSuccessfulReq: number): number {\\n    if (ind === req.length) {\\n        // if any building have no extra spaces\\n        // means we can accept the request count\\n        // otherwise not accepting at all\\n        for(let space of spaces){\\n            if(space !== 0) return 0\\n        }\\n        return countOfSuccessfulReq;\\n    }\\n\\n    const [from, to] = req[ind];\\n    spaces[from]--;\\n    spaces[to]++;\\n    // try by accepting the request\\n    const taken = getMaxReq(ind + 1, req, spaces, countOfSuccessfulReq + 1);\\n    spaces[from]++;\\n    spaces[to]--;\\n    // try by not accepting the request\\n    const notTaken = getMaxReq(ind + 1, req, spaces, countOfSuccessfulReq);\\n    return Math.max(notTaken, taken);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3708463,
                "title": "easy-recursive-solution-with-comments-for-each-logic",
                "content": "# Intuition\\nThe given code is a recursive solution to find the maximum number of successful requests that can be accommodated based on the available spaces in different buildings.\\n\\n# Approach\\n1. The `maximumRequests` function initializes an array called `spaces` with `n` elements, representing the number of buildings. Each element is initially set to 0, indicating no available space.\\n\\n2. It calls the `getMaxReq` function, passing the initial parameters: `ind` (starting index), `requests` (the input array of requests), `spaces` array, and `countOfSuccessfulReq` (the count of successful requests).\\n\\n3. The `getMaxReq` function is a recursive function that uses Backtracking to explore different combinations of accepting or rejecting requests.\\n\\n4. The base case is when `ind` equals the length of the `requests` array, indicating that all requests have been processed.\\n\\n5. Inside the base case, it checks if all elements in the `spaces` array are `0`. If they are, it means all requests have been successfully accommodated, so it returns `countOfSuccessfulReq`.\\n\\n6. The recursive part begins by taking the current request from the `requests` array and updating the `spaces` array accordingly.\\n\\n7. It then recursively calls `getMaxReq` for the next index (`ind + 1`) while incrementing `countOfSuccessfulReq` by 1 to simulate accepting the request.\\n\\n8. After the recursive call, it reverts the changes made to the `spaces` array to simulate not accepting the request.\\n\\n9. It recursively calls `getMaxReq` again for the next index (`ind + 1`) while keeping `countOfSuccessfulReq` unchanged to simulate not accepting the request.\\n\\n10. Finally, it returns the maximum value between the results of accepting the request (`taken`) and not accepting the request (`notTaken`).\\n\\n# Complexity\\n- Exponential Time complexity: $$O(2^N)$$\\n\\n- Space complexity: $$O(N)$$\\n\\n\\n# Javascript Code\\n```\\nfunction maximumRequests(n, requests){\\n\\n    // Initially for all buildings we will have 0 space\\n    const spaces = new Array(n).fill(0);\\n    return getMaxReq(0, requests, spaces, 0);\\n};\\n\\nfunction getMaxReq(ind, req, spaces, countOfSuccessfulReq){\\n    if (ind === req.length) {\\n        // if any building have no extra spaces\\n        // means we can accept the request count\\n        // otherwise not accepting at all\\n        for(let space of spaces){\\n            if(space !== 0) return 0\\n        }\\n        return countOfSuccessfulReq;\\n    }\\n\\n    const [from, to] = req[ind];\\n    spaces[from]--;\\n    spaces[to]++;\\n    // try by accepting the request\\n    const taken = getMaxReq(ind + 1, req, spaces, countOfSuccessfulReq + 1);\\n    spaces[from]++;\\n    spaces[to]--;\\n    // try by not accepting the request\\n    const notTaken = getMaxReq(ind + 1, req, spaces, countOfSuccessfulReq);\\n    return Math.max(notTaken, taken);\\n}\\n```\\n\\n---\\n\\n# Typescript Code\\n```\\nfunction maximumRequests(n: number, requests: number[][]): number {\\n\\n    // Initially for all buildings we will have 0 space\\n    const spaces: number[] = new Array(n).fill(0);\\n    return getMaxReq(0, requests, spaces, 0);\\n};\\n\\nfunction getMaxReq(ind: number, req: number[][], spaces: number[], countOfSuccessfulReq: number): number {\\n    if (ind === req.length) {\\n        // if any building have no extra spaces\\n        // means we can accept the request count\\n        // otherwise not accepting at all\\n        for(let space of spaces){\\n            if(space !== 0) return 0\\n        }\\n        return countOfSuccessfulReq;\\n    }\\n\\n    const [from, to] = req[ind];\\n    spaces[from]--;\\n    spaces[to]++;\\n    // try by accepting the request\\n    const taken = getMaxReq(ind + 1, req, spaces, countOfSuccessfulReq + 1);\\n    spaces[from]++;\\n    spaces[to]--;\\n    // try by not accepting the request\\n    const notTaken = getMaxReq(ind + 1, req, spaces, countOfSuccessfulReq);\\n    return Math.max(notTaken, taken);\\n}\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript",
                    "Recursion"
                ],
                "code": "```\\nfunction maximumRequests(n, requests){\\n\\n    // Initially for all buildings we will have 0 space\\n    const spaces = new Array(n).fill(0);\\n    return getMaxReq(0, requests, spaces, 0);\\n};\\n\\nfunction getMaxReq(ind, req, spaces, countOfSuccessfulReq){\\n    if (ind === req.length) {\\n        // if any building have no extra spaces\\n        // means we can accept the request count\\n        // otherwise not accepting at all\\n        for(let space of spaces){\\n            if(space !== 0) return 0\\n        }\\n        return countOfSuccessfulReq;\\n    }\\n\\n    const [from, to] = req[ind];\\n    spaces[from]--;\\n    spaces[to]++;\\n    // try by accepting the request\\n    const taken = getMaxReq(ind + 1, req, spaces, countOfSuccessfulReq + 1);\\n    spaces[from]++;\\n    spaces[to]--;\\n    // try by not accepting the request\\n    const notTaken = getMaxReq(ind + 1, req, spaces, countOfSuccessfulReq);\\n    return Math.max(notTaken, taken);\\n}\\n```\n```\\nfunction maximumRequests(n: number, requests: number[][]): number {\\n\\n    // Initially for all buildings we will have 0 space\\n    const spaces: number[] = new Array(n).fill(0);\\n    return getMaxReq(0, requests, spaces, 0);\\n};\\n\\nfunction getMaxReq(ind: number, req: number[][], spaces: number[], countOfSuccessfulReq: number): number {\\n    if (ind === req.length) {\\n        // if any building have no extra spaces\\n        // means we can accept the request count\\n        // otherwise not accepting at all\\n        for(let space of spaces){\\n            if(space !== 0) return 0\\n        }\\n        return countOfSuccessfulReq;\\n    }\\n\\n    const [from, to] = req[ind];\\n    spaces[from]--;\\n    spaces[to]++;\\n    // try by accepting the request\\n    const taken = getMaxReq(ind + 1, req, spaces, countOfSuccessfulReq + 1);\\n    spaces[from]++;\\n    spaces[to]--;\\n    // try by not accepting the request\\n    const notTaken = getMaxReq(ind + 1, req, spaces, countOfSuccessfulReq);\\n    return Math.max(notTaken, taken);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3708374,
                "title": "choose-or-not-to-choose-to-serve-the-requests",
                "content": "```\\nclass Solution {\\npublic:\\n    int ans = 0;\\n    void solve(vector<int> &in,int ind,vector<vector<int>>& r,int cnt)\\n    {\\n        if(ind == r.size())\\n        {\\n            for(auto i: in)\\n            {\\n                if(i!=0)\\n                    return;\\n                    \\n            }\\n            \\n            ans = max(ans,cnt);\\n            return;\\n        }\\n        \\n        \\n        // serve the request\\n        in[r[ind][0]]--;\\n        in[r[ind][1]]++;\\n        \\n        solve(in,ind+1,r,cnt+1);\\n        \\n        in[r[ind][0]]++;\\n        in[r[ind][1]]--;\\n        \\n        // dont serve the request\\n        solve(in,ind+1,r,cnt);\\n        \\n        \\n    }\\n    int maximumRequests(int n, vector<vector<int>>& r) {\\n        vector<int> in(n,0);\\n        solve(in,0,r,0);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int ans = 0;\\n    void solve(vector<int> &in,int ind,vector<vector<int>>& r,int cnt)\\n    {\\n        if(ind == r.size())\\n        {\\n            for(auto i: in)\\n            {\\n                if(i!=0)\\n                    return;\\n                    \\n            }\\n            \\n            ans = max(ans,cnt);\\n            return;\\n        }\\n        \\n        \\n        // serve the request\\n        in[r[ind][0]]--;\\n        in[r[ind][1]]++;\\n        \\n        solve(in,ind+1,r,cnt+1);\\n        \\n        in[r[ind][0]]++;\\n        in[r[ind][1]]--;\\n        \\n        // dont serve the request\\n        solve(in,ind+1,r,cnt);\\n        \\n        \\n    }\\n    int maximumRequests(int n, vector<vector<int>>& r) {\\n        vector<int> in(n,0);\\n        solve(in,0,r,0);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3708357,
                "title": "golang-bitmask-solution",
                "content": "# Code\\n```\\nfunc maximumRequests(n int, requests [][]int) int {\\n\\tpopCount := func(num int) int {\\n\\t\\tres := 0\\n\\t\\tfor ; num > 0; num >>= 1 {\\n\\t\\t\\tres += num & 1\\n\\t\\t}\\n\\t\\treturn res\\n\\t}\\n\\n\\tanswer := 0\\nlabel:\\n\\tfor mask := 0; mask < 1<<len(requests); mask++ {\\n\\t\\t// fmt.Printf(\"%08b\\\\n\", mask)\\n\\t\\tindegree := make([]int, n)\\n\\n\\t\\tbitCount := popCount(mask)\\n\\t\\tif bitCount <= answer {\\n\\t\\t\\tcontinue label\\n\\t\\t}\\n\\n\\t\\tfor curr, pos := mask, len(requests)-1; curr > 0; curr = curr >> 1 {\\n\\t\\t\\tif curr&1 == 1 {\\n\\t\\t\\t\\tindegree[requests[pos][0]]--\\n\\t\\t\\t\\tindegree[requests[pos][1]]++\\n\\t\\t\\t}\\n\\t\\t\\tpos--\\n\\t\\t}\\n\\n\\t\\tfor _, d := range indegree {\\n\\t\\t\\tif d != 0 {\\n\\t\\t\\t\\tcontinue label\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tif bitCount > answer {\\n\\t\\t\\tanswer = bitCount\\n\\t\\t}\\n\\t}\\n\\treturn answer\\n}\\n\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc maximumRequests(n int, requests [][]int) int {\\n\\tpopCount := func(num int) int {\\n\\t\\tres := 0\\n\\t\\tfor ; num > 0; num >>= 1 {\\n\\t\\t\\tres += num & 1\\n\\t\\t}\\n\\t\\treturn res\\n\\t}\\n\\n\\tanswer := 0\\nlabel:\\n\\tfor mask := 0; mask < 1<<len(requests); mask++ {\\n\\t\\t// fmt.Printf(\"%08b\\\\n\", mask)\\n\\t\\tindegree := make([]int, n)\\n\\n\\t\\tbitCount := popCount(mask)\\n\\t\\tif bitCount <= answer {\\n\\t\\t\\tcontinue label\\n\\t\\t}\\n\\n\\t\\tfor curr, pos := mask, len(requests)-1; curr > 0; curr = curr >> 1 {\\n\\t\\t\\tif curr&1 == 1 {\\n\\t\\t\\t\\tindegree[requests[pos][0]]--\\n\\t\\t\\t\\tindegree[requests[pos][1]]++\\n\\t\\t\\t}\\n\\t\\t\\tpos--\\n\\t\\t}\\n\\n\\t\\tfor _, d := range indegree {\\n\\t\\t\\tif d != 0 {\\n\\t\\t\\t\\tcontinue label\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tif bitCount > answer {\\n\\t\\t\\tanswer = bitCount\\n\\t\\t}\\n\\t}\\n\\treturn answer\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3708204,
                "title": "c-backtracking-easy-indegree-concept",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\nint ans=0;\\n    void solve(int idx,vector<vector<int>>&requests,int l,vector<int>&temp){\\n        if(idx==requests.size()){\\n            for(auto i:temp)if(i!=0)return;\\n            ans=max(ans,l);\\n            return;\\n        }\\n        solve(idx+1,requests,l,temp);\\n        temp[requests[idx][0]]--;\\n        temp[requests[idx][1]]++;\\n        solve(idx+1,requests,l+1,temp);\\n        temp[requests[idx][0]]++;\\n        temp[requests[idx][1]]--;\\n    }\\n\\n    int maximumRequests(int n, vector<vector<int>>& requests) {\\n     vector<int>temp(n,0);\\n     solve(0,requests,0,temp);\\n     return ans;   \\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nint ans=0;\\n    void solve(int idx,vector<vector<int>>&requests,int l,vector<int>&temp){\\n        if(idx==requests.size()){\\n            for(auto i:temp)if(i!=0)return;\\n            ans=max(ans,l);\\n            return;\\n        }\\n        solve(idx+1,requests,l,temp);\\n        temp[requests[idx][0]]--;\\n        temp[requests[idx][1]]++;\\n        solve(idx+1,requests,l+1,temp);\\n        temp[requests[idx][0]]++;\\n        temp[requests[idx][1]]--;\\n    }\\n\\n    int maximumRequests(int n, vector<vector<int>>& requests) {\\n     vector<int>temp(n,0);\\n     solve(0,requests,0,temp);\\n     return ans;   \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3708200,
                "title": "why-indegree-outdegree-not-working-well-explained-comments-simple-backtracking-beginner-friendly",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe first approach which come to my mind was to use indegree and outdegree concept but after getting wrong answer on some test case ,, i realise \\nin this approach i am not taking net change of each building into consideration.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nto get right answer we have to use backtracking which will try to find all possible combinations like allow or not allow and then check net change of each building \\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(2^n),n number of requests\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n+m), m is number of buildings here\\n# Code\\n```\\nclass Solution {\\npublic:\\n                    //** first approach**//\\n // is giving wrong answer because we have to allow request in such order that net change should be zero but it can\\'t be possible with this approach \\n        // unordered_map<int,int>enter,leave;\\n        //  int c=0;\\n        // for(auto i:requests){\\n        //   if(i[0]==i[1]){\\n        //     c++;\\n        //     continue;\\n        //   }\\n        // enter[i[1]]++;\\n        // leave[i[0]]++;}\\n       \\n        // for(auto i:enter){\\n        //   c+=min(enter[i.first],leave[i.first]);\\n        // }\\n        // return c;\\n\\n\\n//** right approach***//\\nint c=0;\\nvoid solve(int n, vector<vector<int>>& requests,int i,unordered_map<int,int>&m,int k){\\n  if(i==n){\\n    //check if all buildings have net change 0 or not\\nfor(auto i:m){\\nif(i.second!=0)\\nreturn;}\\nc=max(c,k);\\nreturn;\\n  }\\n  m[requests[i][0]]--;//allow a request\\n  m[requests[i][1]]++;\\n  solve(n,requests,i+1,m,k+1);\\n//don\\'t allow\\n   m[requests[i][0]]++;\\n    m[requests[i][1]]--;\\n    solve(n,requests,i+1,m,k);\\n}\\n    int maximumRequests(int n, vector<vector<int>>& requests) {\\n     \\n// to get right answer we have to use backtracking which will try to find all possible combinations like allow or not allow and then check net change of each building \\nunordered_map<int,int>m;\\nsolve(requests.size(),requests,0,m,0);\\nreturn c;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n                    //** first approach**//\\n // is giving wrong answer because we have to allow request in such order that net change should be zero but it can\\'t be possible with this approach \\n        // unordered_map<int,int>enter,leave;\\n        //  int c=0;\\n        // for(auto i:requests){\\n        //   if(i[0]==i[1]){\\n        //     c++;\\n        //     continue;\\n        //   }\\n        // enter[i[1]]++;\\n        // leave[i[0]]++;}\\n       \\n        // for(auto i:enter){\\n        //   c+=min(enter[i.first],leave[i.first]);\\n        // }\\n        // return c;\\n\\n\\n//** right approach***//\\nint c=0;\\nvoid solve(int n, vector<vector<int>>& requests,int i,unordered_map<int,int>&m,int k){\\n  if(i==n){\\n    //check if all buildings have net change 0 or not\\nfor(auto i:m){\\nif(i.second!=0)\\nreturn;}\\nc=max(c,k);\\nreturn;\\n  }\\n  m[requests[i][0]]--;//allow a request\\n  m[requests[i][1]]++;\\n  solve(n,requests,i+1,m,k+1);\\n//don\\'t allow\\n   m[requests[i][0]]++;\\n    m[requests[i][1]]--;\\n    solve(n,requests,i+1,m,k);\\n}\\n    int maximumRequests(int n, vector<vector<int>>& requests) {\\n     \\n// to get right answer we have to use backtracking which will try to find all possible combinations like allow or not allow and then check net change of each building \\nunordered_map<int,int>m;\\nsolve(requests.size(),requests,0,m,0);\\nreturn c;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3708198,
                "title": "c-backtracking",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nFor every request, we have 2 options. Either, we can include it or reject it. So, there will be 2 recursion calls & we will find max. once we process all the requests.\\n\\nThis is backtracking approach but I was wondering that we can solve it using graphs as well. I guess the required answer will be the no. of edges involved in all possible cycles in a directed graph where no. of vertices = n & edges will be directed from(i) to to(i).\\nBut, i am unable to code it. Any type of help will be appreciated :)\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nFor every request, there are 2 choices: include or reject. Since, at max. 16 requests can be made, so time complexity = O(2^16) as we are trying all possible cases for each request.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void maxReq(vector<vector<int>> &r, int i, int l, vector<int> &temp, int &ans){\\n        if(i==r.size()){\\n            for(int x: temp){\\n                if(x!=0)\\n                return;\\n            }\\n            ans=max(ans,l);\\n            return;\\n        }\\n\\n        maxReq(r,i+1,l,temp,ans);\\n\\n        temp[r[i][0]]--;\\n        temp[r[i][1]]++;\\n        maxReq(r,i+1,l+1,temp,ans);\\n        temp[r[i][0]]++;\\n        temp[r[i][1]]--;\\n    }\\n    int maximumRequests(int n, vector<vector<int>>& requests) {\\n        vector<int> temp(n,0);\\n        int i=0;\\n        int ans=0, l=0;\\n\\n        maxReq(requests,i,l,temp,ans);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void maxReq(vector<vector<int>> &r, int i, int l, vector<int> &temp, int &ans){\\n        if(i==r.size()){\\n            for(int x: temp){\\n                if(x!=0)\\n                return;\\n            }\\n            ans=max(ans,l);\\n            return;\\n        }\\n\\n        maxReq(r,i+1,l,temp,ans);\\n\\n        temp[r[i][0]]--;\\n        temp[r[i][1]]++;\\n        maxReq(r,i+1,l+1,temp,ans);\\n        temp[r[i][0]]++;\\n        temp[r[i][1]]--;\\n    }\\n    int maximumRequests(int n, vector<vector<int>>& requests) {\\n        vector<int> temp(n,0);\\n        int i=0;\\n        int ans=0, l=0;\\n\\n        maxReq(requests,i,l,temp,ans);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3708152,
                "title": "beginner-friendly-easy-c-solution-bitmasking",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe just have to process all combinations of requests and look for those combinations which have net employee transfer as zero.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nDifferent combinations are equivalent to different subsequences which can be formed using 2 methods:\\n1). Backtracking (take and not take method), \\n2). Bitmasking\\nWe will go with second one.\\n# Complexity\\n- Time complexity:O(2^n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximumRequests(int n, vector<vector<int>>& requests) {\\n        int s=requests.size();\\n        int res=0;\\n        int count=0;\\n        for(int i=0;i<(1<<s);i++){\\n            vector<int>in(n,0);\\n            vector<int>out(n,0);\\n            for(int j=0;j<s;j++){\\n                if(i & (1<<j)){\\n                    out[requests[j][0]]++;\\n                    in[requests[j][1]]++;\\n                    count++;\\n                }\\n            }\\n            if(in==out) res=max(res,count);\\n            count=0;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Bit Manipulation",
                    "Bitmask"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumRequests(int n, vector<vector<int>>& requests) {\\n        int s=requests.size();\\n        int res=0;\\n        int count=0;\\n        for(int i=0;i<(1<<s);i++){\\n            vector<int>in(n,0);\\n            vector<int>out(n,0);\\n            for(int j=0;j<s;j++){\\n                if(i & (1<<j)){\\n                    out[requests[j][0]]++;\\n                    in[requests[j][1]]++;\\n                    count++;\\n                }\\n            }\\n            if(in==out) res=max(res,count);\\n            count=0;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3707934,
                "title": "recursion",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    void solve(int ind, vector<int> &change, int n, vector<vector<int>> &requests, int count, int &ans)\\n{\\n    if (ind == requests.size())\\n    {\\n        for (int i = 0; i < n; i++)\\n        {\\n            if (change[i])\\n            {\\n                return;\\n            }\\n        }\\n        ans = max(ans, count);\\n        return;\\n    }\\n\\n    change[requests[ind][0]]--;\\n    change[requests[ind][1]]++;\\n    solve(ind + 1, change, n, requests, count + 1, ans);\\n\\n    change[requests[ind][0]]++;\\n    change[requests[ind][1]]--;\\n    solve(ind + 1, change, n, requests, count, ans);\\n}\\n\\nint maximumRequests(int n, vector<vector<int>> &requests)\\n{\\n    vector<int> change(n, 0);\\n    int ans = 0;\\n    solve(0, change, n, requests, 0, ans);\\n    return ans;\\n}\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void solve(int ind, vector<int> &change, int n, vector<vector<int>> &requests, int count, int &ans)\\n{\\n    if (ind == requests.size())\\n    {\\n        for (int i = 0; i < n; i++)\\n        {\\n            if (change[i])\\n            {\\n                return;\\n            }\\n        }\\n        ans = max(ans, count);\\n        return;\\n    }\\n\\n    change[requests[ind][0]]--;\\n    change[requests[ind][1]]++;\\n    solve(ind + 1, change, n, requests, count + 1, ans);\\n\\n    change[requests[ind][0]]++;\\n    change[requests[ind][1]]--;\\n    solve(ind + 1, change, n, requests, count, ans);\\n}\\n\\nint maximumRequests(int n, vector<vector<int>> &requests)\\n{\\n    vector<int> change(n, 0);\\n    int ans = 0;\\n    solve(0, change, n, requests, 0, ans);\\n    return ans;\\n}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3707850,
                "title": "easy-to-understand-backtracking-indegree-outdegree",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nFirst approach that come to mind is calculating indegree and outdegree for the requests, but only that will not work.\\nYou have to also keep track all the combinations, for every request, either you can take the request or skip that.\\nAnd for all combinations, apply your indegree outdegree approach.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int res=0;\\n    void backTrack(int i,int count,vector<vector<int>>&req,vector<int>&indeg){\\n        //count will keep currrent count of requests that can be processed;\\n        //If traversed entire requests array, then check whether you are in valid state or not \\n        //by checking all incoming requests = outgoing requests for the same\\n        if(i==req.size()){\\n            bool isValid=true;\\n            for(auto it:indeg){\\n                if(it!=0)isValid=false;\\n            }\\n            if(isValid)res=max(res,count);\\n            return;\\n        }\\n\\n        //Take current request\\n        indeg[req[i][0]]-=1;\\n        indeg[req[i][1]]+=1;\\n        backTrack(i+1,count+1,req,indeg);\\n        //Not Consider\\n        indeg[req[i][0]]+=1;\\n        indeg[req[i][1]]-=1;\\n        backTrack(i+1,count,req,indeg);\\n        \\n    }\\n    int maximumRequests(int n, vector<vector<int>>& requests) {\\n        vector<int>indeg(n,0);\\n        backTrack(0,0,requests,indeg);\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int res=0;\\n    void backTrack(int i,int count,vector<vector<int>>&req,vector<int>&indeg){\\n        //count will keep currrent count of requests that can be processed;\\n        //If traversed entire requests array, then check whether you are in valid state or not \\n        //by checking all incoming requests = outgoing requests for the same\\n        if(i==req.size()){\\n            bool isValid=true;\\n            for(auto it:indeg){\\n                if(it!=0)isValid=false;\\n            }\\n            if(isValid)res=max(res,count);\\n            return;\\n        }\\n\\n        //Take current request\\n        indeg[req[i][0]]-=1;\\n        indeg[req[i][1]]+=1;\\n        backTrack(i+1,count+1,req,indeg);\\n        //Not Consider\\n        indeg[req[i][0]]+=1;\\n        indeg[req[i][1]]-=1;\\n        backTrack(i+1,count,req,indeg);\\n        \\n    }\\n    int maximumRequests(int n, vector<vector<int>>& requests) {\\n        vector<int>indeg(n,0);\\n        backTrack(0,0,requests,indeg);\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3707801,
                "title": "c-solution-simple-brute-force-recursive-solution-faster-and-easy",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int helper(vector<vector<int>>& requests,vector<int>&exchange,int i){\\n        if(i == requests.size()){\\n            for(int i : exchange){\\n                if(i!=0) return INT_MIN;\\n            }\\n            return 0;\\n        }\\n\\n        exchange[requests[i][0]]++;\\n        exchange[requests[i][1]]--;\\n        int take = 1 + helper(requests,exchange,i+1);\\n        exchange[requests[i][0]]--;\\n        exchange[requests[i][1]]++;\\n\\n        int notTake = helper(requests,exchange,i+1);\\n\\n        return max(take,notTake);\\n    }\\n    int maximumRequests(int n, vector<vector<int>>& requests) {\\n        vector<int> exchange(n,0);\\n        return helper(requests,exchange,0);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int helper(vector<vector<int>>& requests,vector<int>&exchange,int i){\\n        if(i == requests.size()){\\n            for(int i : exchange){\\n                if(i!=0) return INT_MIN;\\n            }\\n            return 0;\\n        }\\n\\n        exchange[requests[i][0]]++;\\n        exchange[requests[i][1]]--;\\n        int take = 1 + helper(requests,exchange,i+1);\\n        exchange[requests[i][0]]--;\\n        exchange[requests[i][1]]++;\\n\\n        int notTake = helper(requests,exchange,i+1);\\n\\n        return max(take,notTake);\\n    }\\n    int maximumRequests(int n, vector<vector<int>>& requests) {\\n        vector<int> exchange(n,0);\\n        return helper(requests,exchange,0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3707799,
                "title": "python-dfs",
                "content": "# Code\\n```\\nclass Solution:\\n    def maximumRequests(self, n: int, requests: List[List[int]]) -> int:\\n\\n        buildings = [0] * n\\n        res = req_filled = 0\\n\\n        def dfs(i):\\n            nonlocal res, req_filled\\n\\n            if i == len(requests):\\n                if all(b == 0 for b in buildings):\\n                    res = max(res, req_filled)\\n                return\\n\\n            u, v = requests[i]\\n            \\n            buildings[u] -= 1\\n            buildings[v] += 1\\n            req_filled += 1\\n\\n            dfs(i + 1)\\n\\n            buildings[u] += 1\\n            buildings[v] -= 1\\n            req_filled -= 1\\n\\n            dfs(i + 1)\\n        \\n        dfs(0)\\n\\n        return res\\n\\n```",
                "solutionTags": [
                    "Python3",
                    "Backtracking",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def maximumRequests(self, n: int, requests: List[List[int]]) -> int:\\n\\n        buildings = [0] * n\\n        res = req_filled = 0\\n\\n        def dfs(i):\\n            nonlocal res, req_filled\\n\\n            if i == len(requests):\\n                if all(b == 0 for b in buildings):\\n                    res = max(res, req_filled)\\n                return\\n\\n            u, v = requests[i]\\n            \\n            buildings[u] -= 1\\n            buildings[v] += 1\\n            req_filled += 1\\n\\n            dfs(i + 1)\\n\\n            buildings[u] += 1\\n            buildings[v] -= 1\\n            req_filled -= 1\\n\\n            dfs(i + 1)\\n        \\n        dfs(0)\\n\\n        return res\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3707776,
                "title": "java-solution-using-pick-non-pick-strategy-0-1-knapsack",
                "content": "```\\nclass Solution {\\n    public int maximumRequests(int n, int[][] requests) {\\n        int len = requests.length;\\n        HashSet<Integer>set = new HashSet<>();\\n        int ans = answer(n,len,requests,set,0);\\n        return ans;\\n    }\\n    public int answer(int n,int len,int[][] requests,HashSet<Integer>set,int i){\\n        if(i==len){\\n            if(isFeasible(n,len,requests,set)){\\n                return set.size();\\n            }\\n            else{\\n                return 0;\\n            }\\n        }\\n        set.add(i);\\n        int ans1 = answer(n,len,requests,set,i+1);\\n        set.remove(i);\\n        int ans2 = answer(n,len,requests,set,i+1);\\n        return Math.max(ans1,ans2);\\n    }\\n    public boolean isFeasible(int n,int len,int requests[][],HashSet<Integer>set){\\n        int indegree[] = new int[n];\\n        for(int i = 0;i < len;i++){\\n            if(set.contains(i)){\\n                indegree[requests[i][1]]++;\\n                indegree[requests[i][0]]--;\\n            }\\n        }\\n        for(int i = 0;i < n;i++){\\n            if(indegree[i]!=0){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```\\n\\nTime Complexity : Exponential order\\nSpace Complexity: Auxiliary stack space + HashSet\\n\\nSo, the simple approach here is to use a pick- non pick of requests simply we have two options for each request either to entertain it or to discard it. And to keep a track that which requests we have entertained we have maintained a HashSet storing the indexes of that requests.\\nNow, at the base case finally we can iterate over the requests and can simply check that our condition is getting fulfilled or not. The condition simply is that the indegree should be equal to the outdegree of the nodes. So, we have made a isFeasible function determining that and if it is possible to satisfy that requests our answer will be set.size() else it will be 0.",
                "solutionTags": [
                    "Graph",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public int maximumRequests(int n, int[][] requests) {\\n        int len = requests.length;\\n        HashSet<Integer>set = new HashSet<>();\\n        int ans = answer(n,len,requests,set,0);\\n        return ans;\\n    }\\n    public int answer(int n,int len,int[][] requests,HashSet<Integer>set,int i){\\n        if(i==len){\\n            if(isFeasible(n,len,requests,set)){\\n                return set.size();\\n            }\\n            else{\\n                return 0;\\n            }\\n        }\\n        set.add(i);\\n        int ans1 = answer(n,len,requests,set,i+1);\\n        set.remove(i);\\n        int ans2 = answer(n,len,requests,set,i+1);\\n        return Math.max(ans1,ans2);\\n    }\\n    public boolean isFeasible(int n,int len,int requests[][],HashSet<Integer>set){\\n        int indegree[] = new int[n];\\n        for(int i = 0;i < len;i++){\\n            if(set.contains(i)){\\n                indegree[requests[i][1]]++;\\n                indegree[requests[i][0]]--;\\n            }\\n        }\\n        for(int i = 0;i < n;i++){\\n            if(indegree[i]!=0){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3707772,
                "title": "c-bit-masking-easy-to-understand",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nGenerate all subsets of the given requests array, for each subset check if the net change in employee transfers is zero.\\n\\n<!-- # Complexity -->\\n<!-- - Time complexity: -->\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n<!-- - Space complexity: -->\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximumRequests(int n, vector<vector<int>>& requests) {\\n        int sz = requests.size();\\n        int ans = 0;\\n        for(int i = 0; i < (1 << sz); i++)\\n        {\\n            vector<int> cnt(n, 0);\\n            int set_bits = 0;\\n            for(int j = 0; j < sz; j++)\\n            {\\n                if((i & (1 << j)))\\n                {\\n                    cnt[requests[j][0]]--;\\n                    cnt[requests[j][1]]++;\\n                    set_bits++;\\n                }\\n            }\\n            bool flag = 1;\\n            for(int j = 0; j < n; j++)\\n            {\\n                if(cnt[j] != 0)\\n                {\\n                    flag = 0;\\n                }\\n            }\\n\\n            if(flag) ans = max(ans, set_bits);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumRequests(int n, vector<vector<int>>& requests) {\\n        int sz = requests.size();\\n        int ans = 0;\\n        for(int i = 0; i < (1 << sz); i++)\\n        {\\n            vector<int> cnt(n, 0);\\n            int set_bits = 0;\\n            for(int j = 0; j < sz; j++)\\n            {\\n                if((i & (1 << j)))\\n                {\\n                    cnt[requests[j][0]]--;\\n                    cnt[requests[j][1]]++;\\n                    set_bits++;\\n                }\\n            }\\n            bool flag = 1;\\n            for(int j = 0; j < n; j++)\\n            {\\n                if(cnt[j] != 0)\\n                {\\n                    flag = 0;\\n                }\\n            }\\n\\n            if(flag) ans = max(ans, set_bits);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3707530,
                "title": "very-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int ans = 0;\\n    void help(int i,vector<vector<int>>& v,int l,vector<int>&temp){\\n        if(i == v.size()){\\n            for(auto a: temp){\\n                if(a!=0){\\n                    return;\\n                }\\n            }\\n            ans = max(ans,l);\\n            return;\\n        }\\n\\n        help(i+1,v,l,temp);\\n        temp[v[i][0]]--;\\n        temp[v[i][1]]++;\\n        help(i+1,v,l+1,temp);\\n        temp[v[i][0]]++;\\n        temp[v[i][1]]--;\\n\\n    }\\n    int maximumRequests(int n, vector<vector<int>>& requests) {\\n        vector<int>temp(n,0);\\n        help(0,requests,0,temp);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int ans = 0;\\n    void help(int i,vector<vector<int>>& v,int l,vector<int>&temp){\\n        if(i == v.size()){\\n            for(auto a: temp){\\n                if(a!=0){\\n                    return;\\n                }\\n            }\\n            ans = max(ans,l);\\n            return;\\n        }\\n\\n        help(i+1,v,l,temp);\\n        temp[v[i][0]]--;\\n        temp[v[i][1]]++;\\n        help(i+1,v,l+1,temp);\\n        temp[v[i][0]]++;\\n        temp[v[i][1]]--;\\n\\n    }\\n    int maximumRequests(int n, vector<vector<int>>& requests) {\\n        vector<int>temp(n,0);\\n        help(0,requests,0,temp);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3707412,
                "title": "simple-beginner-solution-iterative-approach",
                "content": "# Approach\\nTry all combinations of Requests and then perform the operation of leaving or joining. Check if the resultant array is 0.\\n<!-- Describe your approach to solving the problem. -->\\n\\n- Time complexity: $$O(2^n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    boolean isValid(int[] b) {\\n        boolean ret=true;\\n        for(int i=0; i<b.length; i++) if(b[i]!=0){ \\n            ret = false;\\n            b[i]=0;\\n        }\\n        return ret;\\n    }\\n    public int maximumRequests(int n, int[][] requests) {\\n        int[] b = new int[n];\\n        int res = 0;\\n        for(int i=0, mbit=(1<<requests.length); i<mbit && mbit-i>(1<<res); i++) {\\n            int ops=0;\\n            for(int j=0; j<requests.length; j++) {\\n                if(((1<<j)&i) == 0) {\\n                    b[requests[j][0]]--;\\n                    b[requests[j][1]]++;\\n                    ops++;\\n                }\\n            }\\n            if(isValid(b)) res = Math.max(res, ops);\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    boolean isValid(int[] b) {\\n        boolean ret=true;\\n        for(int i=0; i<b.length; i++) if(b[i]!=0){ \\n            ret = false;\\n            b[i]=0;\\n        }\\n        return ret;\\n    }\\n    public int maximumRequests(int n, int[][] requests) {\\n        int[] b = new int[n];\\n        int res = 0;\\n        for(int i=0, mbit=(1<<requests.length); i<mbit && mbit-i>(1<<res); i++) {\\n            int ops=0;\\n            for(int j=0; j<requests.length; j++) {\\n                if(((1<<j)&i) == 0) {\\n                    b[requests[j][0]]--;\\n                    b[requests[j][1]]++;\\n                    ops++;\\n                }\\n            }\\n            if(isValid(b)) res = Math.max(res, ops);\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3707400,
                "title": "java-faster-than-100-easy-to-understand",
                "content": "\\n# Code\\n```\\nclass Solution {\\n\\n    int maxCount = 0;\\n    public int maximumRequests(int n, int[][] requests) {\\n\\n        int[] freq = new int[n];\\n        backtrack(requests, freq, 0, 0);\\n        return maxCount;\\n\\n    }\\n\\n\\n    public void backtrack(int[][] reqs, int[] freq, int index, int count){\\n\\n        if(index == reqs.length){\\n            for(int f: freq) if(f != 0) return;\\n            maxCount = Math.max(maxCount, count);\\n            return;\\n        }\\n\\n        int[] currReq = reqs[index];\\n        --freq[currReq[0]]; ++freq[currReq[1]];\\n        backtrack(reqs, freq, index + 1, count + 1);\\n        ++freq[currReq[0]]; --freq[currReq[1]];\\n        backtrack(reqs, freq, index + 1, count);\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\n\\n    int maxCount = 0;\\n    public int maximumRequests(int n, int[][] requests) {\\n\\n        int[] freq = new int[n];\\n        backtrack(requests, freq, 0, 0);\\n        return maxCount;\\n\\n    }\\n\\n\\n    public void backtrack(int[][] reqs, int[] freq, int index, int count){\\n\\n        if(index == reqs.length){\\n            for(int f: freq) if(f != 0) return;\\n            maxCount = Math.max(maxCount, count);\\n            return;\\n        }\\n\\n        int[] currReq = reqs[index];\\n        --freq[currReq[0]]; ++freq[currReq[1]];\\n        backtrack(reqs, freq, index + 1, count + 1);\\n        ++freq[currReq[0]]; --freq[currReq[1]];\\n        backtrack(reqs, freq, index + 1, count);\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3707352,
                "title": "c-backtracking-commented-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nBasic Recusrion + Backtracking.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nJust use simple recusrive function with passing values in reference rather than by copy. This will require backtracking, that is commented and explained in code.\\n\\n# Complexity\\n- Time complexity   :   O(2^k)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity  :   O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n![download (2).jfif](https://assets.leetcode.com/users/images/ffdd0e89-9b33-45b0-a233-a631b30d123f_1688283269.8296683.jpeg)\\n\\n\\n# Code\\n```\\nclass Solution {\\n    int res = 0;\\npublic:\\n    void fun(int idx, int used, vector<vector<int>> &r, vector<int> &v)    {\\n        if(idx==r.size())   {\\n            //checking if current recurrence result is useful or not, by cheecking the constraint of in == out for all buildings\\n            bool can_take = true;\\n            for(auto it : v)    {\\n                if(it!=0)   {   can_take = false;   }\\n            }\\n            //updating res if possible\\n            if(can_take)    \\n                res = max(res,used);\\n            return ;\\n        }\\n\\n        //i->from building & j->to building\\n        int i=r[idx][0];\\n        int j=r[idx][1];\\n\\n        //considering current request\\n        v[i] -= 1;\\n        v[j] += 1;\\n        fun(idx+1, used+1,r,v);\\n\\n        //BACKTRACKING : not considering current request\\n        v[i] += 1;\\n        v[j] -= 1;\\n        fun(idx+1, used,r,v);\\n    }\\n\\n    int maximumRequests(int n, vector<vector<int>>& requests) {\\n        vector<int> v(n,0);\\n        fun(0,0,requests,v);\\n\\n        return res;\\n    }\\n};\\n```\\n\\n![images.jfif](https://assets.leetcode.com/users/images/2db9ee1e-5161-470f-9fd8-7cc09808f05c_1688283282.7084713.jpeg)\\n",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Backtracking",
                    "Recursion",
                    "Enumeration"
                ],
                "code": "```\\nclass Solution {\\n    int res = 0;\\npublic:\\n    void fun(int idx, int used, vector<vector<int>> &r, vector<int> &v)    {\\n        if(idx==r.size())   {\\n            //checking if current recurrence result is useful or not, by cheecking the constraint of in == out for all buildings\\n            bool can_take = true;\\n            for(auto it : v)    {\\n                if(it!=0)   {   can_take = false;   }\\n            }\\n            //updating res if possible\\n            if(can_take)    \\n                res = max(res,used);\\n            return ;\\n        }\\n\\n        //i->from building & j->to building\\n        int i=r[idx][0];\\n        int j=r[idx][1];\\n\\n        //considering current request\\n        v[i] -= 1;\\n        v[j] += 1;\\n        fun(idx+1, used+1,r,v);\\n\\n        //BACKTRACKING : not considering current request\\n        v[i] += 1;\\n        v[j] -= 1;\\n        fun(idx+1, used,r,v);\\n    }\\n\\n    int maximumRequests(int n, vector<vector<int>>& requests) {\\n        vector<int> v(n,0);\\n        fun(0,0,requests,v);\\n\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3707310,
                "title": "js-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number} n\\n * @param {number[][]} requests\\n * @return {number}\\n */\\nfunction solve(idx,req,store,n){\\n    if(idx>=req.length){\\n        let cnt= Array(n).fill(0);\\n        let t=0;\\n        for(let i=0;i<idx;i++){\\n            if((store & (1<<i))!==0){\\n                cnt[req[i][0]]--;\\n                cnt[req[i][1]]++;\\n                t++;\\n            }\\n        }\\n        for(let ele of cnt) if(ele!==0) return 0;\\n        return t;\\n    }\\n    let ans=0;\\n    let temp = store | (1<<idx);\\n    ans= Math.max(solve(idx+1,req,temp,n),ans); \\n    ans =Math.max(solve(idx+1,req,store,n),ans);\\n    return ans;\\n}\\nvar maximumRequests = function(n, req) {\\n    \\n    return solve(0,req,0,n);\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} n\\n * @param {number[][]} requests\\n * @return {number}\\n */\\nfunction solve(idx,req,store,n){\\n    if(idx>=req.length){\\n        let cnt= Array(n).fill(0);\\n        let t=0;\\n        for(let i=0;i<idx;i++){\\n            if((store & (1<<i))!==0){\\n                cnt[req[i][0]]--;\\n                cnt[req[i][1]]++;\\n                t++;\\n            }\\n        }\\n        for(let ele of cnt) if(ele!==0) return 0;\\n        return t;\\n    }\\n    let ans=0;\\n    let temp = store | (1<<idx);\\n    ans= Math.max(solve(idx+1,req,temp,n),ans); \\n    ans =Math.max(solve(idx+1,req,store,n),ans);\\n    return ans;\\n}\\nvar maximumRequests = function(n, req) {\\n    \\n    return solve(0,req,0,n);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3707268,
                "title": "simple-backtracking-kotlin-java",
                "content": "**Approach: Backtracking with Building Counts**\\n\\n**Intuition:**\\n   - The problem requires finding the maximum number of achievable requests, ensuring that the net change in employee transfers for each building is zero.\\n   - We can use a backtracking approach to explore all possible combinations of requests and track the count of included requests to find the maximum achievable count.\\n\\n**Algorithm:**\\n   - Initialize a variable `maxAchievableRequests` to store the maximum achievable count of requests.\\n   - Call the `backtrack` function with the given `requests`, starting index `0`, initial count `0`, and an array `buildings` to track the net change in employee transfers for each building.\\n   - In the `backtrack` function:\\n     - **Base Case:** If the `index` reaches the size of `requests`, check if the net change in employee transfers for each building is zero using the `isNetChangeZero` function. If true, update `maxAchievableRequests` with the maximum value between `maxAchievableRequests` and the current `count`. Return.\\n     - Exclude the current request:\\n       - Recursively call the `backtrack` function with the next index, the same `count`, and the unchanged `buildings`.\\n     - Include the current request:\\n       - Decrement the count of employees in the \"fromBuilding\" and increment the count in the \"toBuilding\" in the `buildings` array.\\n       - Recursively call the `backtrack` function with the next index, `count + 1`, and the updated `buildings`.\\n       - Restore the `buildings` array by incrementing the count of employees in the \"fromBuilding\" and decrementing the count in the \"toBuilding\".\\n   - Return the `maxAchievableRequests` as the result.\\n\\n3. **Helper Function:**\\n   - `isNetChangeZero(buildings: IntArray): Boolean`:\\n     - Iterate through the `buildings` array and check if the count of employees for each building is zero.\\n     - Return `true` if all counts are zero; otherwise, return `false`.\\n\\n4. **Complexity Analysis:**\\n   - **Time Complexity:** The backtracking algorithm explores all possible combinations of requests. In the worst case, each request can be included or excluded, resulting in a total of $$2^m$$ combinations, where m is the number of requests. For each combination, we check the net change in employee transfers, which takes $$O(n)$$ time. Therefore, the overall time complexity is $$O(n * 2^m)$$.\\n   - **Space Complexity:** The space complexity is $$O(m+n)$$ as $$O(n)$$ to store the `buildings` array and $$O(m)$$ for the recursive stack space, where `n` is the number of buildings and `m` is the number of requests.\\n\\n**Code Implementation:** Below is the Kotlin & Java implementation of the approach:\\n\\n```kotlin []\\nclass Solution {\\n    private var maxAchievableRequests = 0\\n    \\n    fun maximumRequests(n: Int, requests: Array<IntArray>): Int {\\n        backtrack(requests, 0, 0, IntArray(n))\\n        return maxAchievableRequests\\n    }\\n    \\n    private fun backtrack(requests: Array<IntArray>, index: Int, count: Int, buildings: IntArray) {\\n        if (index == requests.size) {\\n            if (isNetChangeZero(buildings)) {\\n                maxAchievableRequests = maxOf(maxAchievableRequests, count)\\n            }\\n            return\\n        }\\n        \\n        // Exclude the current request\\n        backtrack(requests, index + 1, count, buildings)\\n        \\n        val fromBuilding = requests[index][0]\\n        val toBuilding = requests[index][1]\\n        \\n        // Include the current request\\n        buildings[fromBuilding]--\\n        buildings[toBuilding]++\\n        backtrack(requests, index + 1, count + 1, buildings)\\n        buildings[fromBuilding]++\\n        buildings[toBuilding]--\\n    }\\n    \\n    private fun isNetChangeZero(buildings: IntArray): Boolean {\\n        for (count in buildings) {\\n            if (count != 0) {\\n                return false\\n            }\\n        }\\n        return true\\n    }\\n}\\n```\\n```java []\\nclass Solution {\\n    private int maxAchievableRequests = 0;\\n    \\n    public int maximumRequests(int n, int[][] requests) {\\n        backtrack(requests, 0, 0, new int[n]);\\n        return maxAchievableRequests;\\n    }\\n    \\n    private void backtrack(int[][] requests, int index, int count, int[] buildings) {\\n        if (index == requests.length) {\\n            if (isNetChangeZero(buildings)) {\\n                maxAchievableRequests = Math.max(maxAchievableRequests, count);\\n            }\\n            return;\\n        }\\n        \\n        // Exclude the current request\\n        backtrack(requests, index + 1, count, buildings);\\n        \\n        int fromBuilding = requests[index][0];\\n        int toBuilding = requests[index][1];\\n        \\n        // Include the current request\\n        buildings[fromBuilding]--;\\n        buildings[toBuilding]++;\\n        backtrack(requests, index + 1, count + 1, buildings);\\n        buildings[fromBuilding]++;\\n        buildings[toBuilding]--;\\n    }\\n    \\n    private boolean isNetChangeZero(int[] buildings) {\\n        for (int count : buildings) {\\n            if (count != 0) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```\\n\\n**Conclusion:**\\n   - The backtracking approach explores all possible combinations of requests to find the maximum number of achievable requests.\\n   - By maintaining counts of employee transfers for each building and checking the net change, we can determine the valid combinations.\\n   - The provided solution has a time complexity of $$O(n * 2^m)$$ and a space complexity of $$O(n + m)$$, where n is the number of buildings and m is the number of requests.\\n\\n\\n### If you found the provided information useful, an upvote would be appreciated. \\uD83D\\uDE0A\\uD83D\\uDC4D",
                "solutionTags": [
                    "Java",
                    "Kotlin",
                    "Backtracking"
                ],
                "code": "```kotlin []\\nclass Solution {\\n    private var maxAchievableRequests = 0\\n    \\n    fun maximumRequests(n: Int, requests: Array<IntArray>): Int {\\n        backtrack(requests, 0, 0, IntArray(n))\\n        return maxAchievableRequests\\n    }\\n    \\n    private fun backtrack(requests: Array<IntArray>, index: Int, count: Int, buildings: IntArray) {\\n        if (index == requests.size) {\\n            if (isNetChangeZero(buildings)) {\\n                maxAchievableRequests = maxOf(maxAchievableRequests, count)\\n            }\\n            return\\n        }\\n        \\n        // Exclude the current request\\n        backtrack(requests, index + 1, count, buildings)\\n        \\n        val fromBuilding = requests[index][0]\\n        val toBuilding = requests[index][1]\\n        \\n        // Include the current request\\n        buildings[fromBuilding]--\\n        buildings[toBuilding]++\\n        backtrack(requests, index + 1, count + 1, buildings)\\n        buildings[fromBuilding]++\\n        buildings[toBuilding]--\\n    }\\n    \\n    private fun isNetChangeZero(buildings: IntArray): Boolean {\\n        for (count in buildings) {\\n            if (count != 0) {\\n                return false\\n            }\\n        }\\n        return true\\n    }\\n}\\n```\n```java []\\nclass Solution {\\n    private int maxAchievableRequests = 0;\\n    \\n    public int maximumRequests(int n, int[][] requests) {\\n        backtrack(requests, 0, 0, new int[n]);\\n        return maxAchievableRequests;\\n    }\\n    \\n    private void backtrack(int[][] requests, int index, int count, int[] buildings) {\\n        if (index == requests.length) {\\n            if (isNetChangeZero(buildings)) {\\n                maxAchievableRequests = Math.max(maxAchievableRequests, count);\\n            }\\n            return;\\n        }\\n        \\n        // Exclude the current request\\n        backtrack(requests, index + 1, count, buildings);\\n        \\n        int fromBuilding = requests[index][0];\\n        int toBuilding = requests[index][1];\\n        \\n        // Include the current request\\n        buildings[fromBuilding]--;\\n        buildings[toBuilding]++;\\n        backtrack(requests, index + 1, count + 1, buildings);\\n        buildings[fromBuilding]++;\\n        buildings[toBuilding]--;\\n    }\\n    \\n    private boolean isNetChangeZero(int[] buildings) {\\n        for (int count : buildings) {\\n            if (count != 0) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3707154,
                "title": "backtracking-with-intuition",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nYou can take a request or cannot take a request. After processing all the requests you need to check if the indegree and outdegree of all the buildings is 0. By checking at the constraints I figured out that backtracking can do the job.\\n\\n\\n```\\nclass Solution {\\n    public int maximumRequests(int n, int[][] requests) {\\n        int temp[]=new int[n];\\n        return solve(0,n,requests,temp);\\n    }\\n    public int solve(int ind,int n,int requests[][],int temp[]){\\n        if(ind==requests.length){\\n            for(int i=0;i<temp.length;i++)\\n            {\\n                if(temp[i]!=0)\\n                  return Integer.MIN_VALUE;\\n            }\\n            return 0;\\n        }\\n        int take=0,notTake=0;\\n        int u=requests[ind][0],v=requests[ind][1];\\n        temp[u]-=1;\\n        temp[v]+=1;\\n        take=1+solve(ind+1,n,requests,temp);\\n        temp[u]+=1;\\n        temp[v]-=1;\\n        notTake=solve(ind+1,n,requests,temp);\\n        return Math.max(take,notTake);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\n    public int maximumRequests(int n, int[][] requests) {\\n        int temp[]=new int[n];\\n        return solve(0,n,requests,temp);\\n    }\\n    public int solve(int ind,int n,int requests[][],int temp[]){\\n        if(ind==requests.length){\\n            for(int i=0;i<temp.length;i++)\\n            {\\n                if(temp[i]!=0)\\n                  return Integer.MIN_VALUE;\\n            }\\n            return 0;\\n        }\\n        int take=0,notTake=0;\\n        int u=requests[ind][0],v=requests[ind][1];\\n        temp[u]-=1;\\n        temp[v]+=1;\\n        take=1+solve(ind+1,n,requests,temp);\\n        temp[u]+=1;\\n        temp[v]-=1;\\n        notTake=solve(ind+1,n,requests,temp);\\n        return Math.max(take,notTake);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3707016,
                "title": "best-c-easy-backtracking-solution-faster-than-100-no-1-leetcode-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\nm = requests.size()\\n- Time complexity: O(2^m)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int solve(vector<int> &temp,int i,vector<vector<int>> &req){\\n        // If all requests are over then check net change\\n        if(i == req.size()){\\n            // If net change of all building not equal to zero then return INT_MIN\\n            for(auto no:temp) if(no!=0) return INT_MIN;\\n            // If it is equal to zero then return 0\\n            return 0;\\n        }\\n        // Checking all the possiblities\\n        // Update all the changes in temp for ith request\\n        temp[req[i][0]]--;\\n        temp[req[i][1]]++;\\n        // case 1: If we include the request \\n        int ans1 = 1 + solve(temp,i+1,req);\\n        temp[req[i][0]]++;\\n        temp[req[i][1]]--;\\n        // case 2: If we reject the request\\n        int ans2 = solve(temp,i+1,req);\\n        return max(ans1,ans2);\\n    }\\n    int maximumRequests(int n, vector<vector<int>>& requests) {\\n        // this vector denotes net change of all buildings\\n        vector<int> temp(n,0);\\n        return solve(temp,0,requests);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int solve(vector<int> &temp,int i,vector<vector<int>> &req){\\n        // If all requests are over then check net change\\n        if(i == req.size()){\\n            // If net change of all building not equal to zero then return INT_MIN\\n            for(auto no:temp) if(no!=0) return INT_MIN;\\n            // If it is equal to zero then return 0\\n            return 0;\\n        }\\n        // Checking all the possiblities\\n        // Update all the changes in temp for ith request\\n        temp[req[i][0]]--;\\n        temp[req[i][1]]++;\\n        // case 1: If we include the request \\n        int ans1 = 1 + solve(temp,i+1,req);\\n        temp[req[i][0]]++;\\n        temp[req[i][1]]--;\\n        // case 2: If we reject the request\\n        int ans2 = solve(temp,i+1,req);\\n        return max(ans1,ans2);\\n    }\\n    int maximumRequests(int n, vector<vector<int>>& requests) {\\n        // this vector denotes net change of all buildings\\n        vector<int> temp(n,0);\\n        return solve(temp,0,requests);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3706998,
                "title": "bit-masking-editorial-c",
                "content": "# Intuition & Approach\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n***Following the editorial - Bitmasking section:***\\nhttps://leetcode.com/problems/maximum-number-of-achievable-transfer-requests/editorial/\\n\\n\\n# Code\\n```\\npublic class Solution {\\n    public int MaximumRequests(int n, int[][] requests) {\\n        int result = 0;\\n        int len = requests.Length;\\n\\n        for (int i = 0; i < (1 << len); i++)\\n        {\\n            int[] inDegree = new int[n];\\n            int pos = len - 1;\\n            int bitCount = BitOperations.PopCount((uint)i);\\n\\n            if (bitCount > result)\\n            {\\n                for (int cur = i; cur > 0; pos--)\\n                {\\n                    if ((cur & 1) > 0)\\n                    {\\n                        inDegree[requests[pos][0]]--;\\n                        inDegree[requests[pos][1]]++;\\n                    }\\n\\n                    cur = cur >> 1;\\n                }\\n\\n                bool flag = true;\\n                for (int j = 0; j < n; j++)\\n                {\\n                    if (inDegree[j] > 0)\\n                    {\\n                        flag = false;\\n                        break;\\n                    }\\n                }\\n\\n                if (flag)\\n                {\\n                    result = bitCount;\\n                }\\n            }\\n        }\\n\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#",
                    "Array",
                    "Backtracking",
                    "Bit Manipulation"
                ],
                "code": "```\\npublic class Solution {\\n    public int MaximumRequests(int n, int[][] requests) {\\n        int result = 0;\\n        int len = requests.Length;\\n\\n        for (int i = 0; i < (1 << len); i++)\\n        {\\n            int[] inDegree = new int[n];\\n            int pos = len - 1;\\n            int bitCount = BitOperations.PopCount((uint)i);\\n\\n            if (bitCount > result)\\n            {\\n                for (int cur = i; cur > 0; pos--)\\n                {\\n                    if ((cur & 1) > 0)\\n                    {\\n                        inDegree[requests[pos][0]]--;\\n                        inDegree[requests[pos][1]]++;\\n                    }\\n\\n                    cur = cur >> 1;\\n                }\\n\\n                bool flag = true;\\n                for (int j = 0; j < n; j++)\\n                {\\n                    if (inDegree[j] > 0)\\n                    {\\n                        flag = false;\\n                        break;\\n                    }\\n                }\\n\\n                if (flag)\\n                {\\n                    result = bitCount;\\n                }\\n            }\\n        }\\n\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3706911,
                "title": "c-backtracking-easy-to-understand-recursion-100ms",
                "content": "# C++ | Backtracking | Easy to Understand | Recursion | 100ms | 1601. Maximum Number of Achievable Transfer Requests\\n```\\nclass Solution {\\npublic:\\n    void func(int idx , vector<vector<int>>& nums , vector<int> &indegree ,int n , int &ans , int curr){\\n        if(idx == nums.size()){\\n            int f = 1;\\n            for(int i = 0; i < n; i++){\\n                if(indegree[i] != 0){\\n                    f = 0;\\n                    break;\\n                }\\n            }\\n            if(f){\\n                ans = max(ans , curr);\\n            }\\n            return;\\n        }\\n        func(idx + 1 , nums , indegree , n , ans , curr);\\n        int u = nums[idx][0] , v = nums[idx][1];\\n        indegree[u]--;\\n        indegree[v]++;\\n        func(idx + 1 , nums , indegree , n , ans , curr + 1);\\n        indegree[u]++;\\n        indegree[v]--;\\n    }\\n    int maximumRequests(int n, vector<vector<int>>& nums) {\\n        vector<int> indegree(n , 0);\\n        int ans = 0;\\n        func(0 , nums , indegree , n , ans , 0);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void func(int idx , vector<vector<int>>& nums , vector<int> &indegree ,int n , int &ans , int curr){\\n        if(idx == nums.size()){\\n            int f = 1;\\n            for(int i = 0; i < n; i++){\\n                if(indegree[i] != 0){\\n                    f = 0;\\n                    break;\\n                }\\n            }\\n            if(f){\\n                ans = max(ans , curr);\\n            }\\n            return;\\n        }\\n        func(idx + 1 , nums , indegree , n , ans , curr);\\n        int u = nums[idx][0] , v = nums[idx][1];\\n        indegree[u]--;\\n        indegree[v]++;\\n        func(idx + 1 , nums , indegree , n , ans , curr + 1);\\n        indegree[u]++;\\n        indegree[v]--;\\n    }\\n    int maximumRequests(int n, vector<vector<int>>& nums) {\\n        vector<int> indegree(n , 0);\\n        int ans = 0;\\n        func(0 , nums , indegree , n , ans , 0);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3706901,
                "title": "cpp-solution-beats-90",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int ans = 0;\\n\\n    void helper(int start, vector<vector<int>>& requests, vector<int>& indegree, int n, int count) {\\n        if (start == requests.size()) {\\n            for (int i = 0; i < n; i++) {\\n                if (indegree[i] != 0) {\\n                    return;\\n                }\\n            }\\n            ans = max(ans, count);\\n            return;\\n        }\\n\\n        // Take \\n        indegree[requests[start][0]]--;\\n        indegree[requests[start][1]]++;\\n        helper(start + 1,requests, indegree, n, count + 1);\\n\\n        // Not-take\\n        indegree[requests[start][0]]++;\\n        indegree[requests[start][1]]--;\\n        helper(start + 1,requests, indegree, n, count);\\n    }\\n    \\n    int maximumRequests(int n, vector<vector<int>>& requests) {\\n        vector<int> indegree(n, 0);\\n        helper(0, requests, indegree, n, 0);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int ans = 0;\\n\\n    void helper(int start, vector<vector<int>>& requests, vector<int>& indegree, int n, int count) {\\n        if (start == requests.size()) {\\n            for (int i = 0; i < n; i++) {\\n                if (indegree[i] != 0) {\\n                    return;\\n                }\\n            }\\n            ans = max(ans, count);\\n            return;\\n        }\\n\\n        // Take \\n        indegree[requests[start][0]]--;\\n        indegree[requests[start][1]]++;\\n        helper(start + 1,requests, indegree, n, count + 1);\\n\\n        // Not-take\\n        indegree[requests[start][0]]++;\\n        indegree[requests[start][1]]--;\\n        helper(start + 1,requests, indegree, n, count);\\n    }\\n    \\n    int maximumRequests(int n, vector<vector<int>>& requests) {\\n        vector<int> indegree(n, 0);\\n        helper(0, requests, indegree, n, 0);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3706893,
                "title": "java-easy-to-understand",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    public int maximumRequests(int n, int[][] requests) {\\n        \\n        int[] indegree = new int[n];\\n        return helper(0, requests, indegree, n, 0);\\n    }\\n\\n     public int helper(int start, int[][] requests, int[] indegree, int n, int count) {\\n        if (start == requests.length) {\\n            for (int i = 0; i < n; i++) {\\n                if (indegree[i] != 0) {\\n                    return 0;\\n                }\\n            }\\n            return count;\\n        }\\n        // Take \\n        indegree[requests[start][0]]--;\\n        indegree[requests[start][1]]++;\\n        int take = helper(start + 1, requests, indegree, n, count + 1);\\n\\n        // Not-take\\n        indegree[requests[start][0]]++;\\n        indegree[requests[start][1]]--;\\n        int notTake = helper(start + 1, requests, indegree, n, count);\\n\\n        return Math.max(take, notTake);\\n     }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maximumRequests(int n, int[][] requests) {\\n        \\n        int[] indegree = new int[n];\\n        return helper(0, requests, indegree, n, 0);\\n    }\\n\\n     public int helper(int start, int[][] requests, int[] indegree, int n, int count) {\\n        if (start == requests.length) {\\n            for (int i = 0; i < n; i++) {\\n                if (indegree[i] != 0) {\\n                    return 0;\\n                }\\n            }\\n            return count;\\n        }\\n        // Take \\n        indegree[requests[start][0]]--;\\n        indegree[requests[start][1]]++;\\n        int take = helper(start + 1, requests, indegree, n, count + 1);\\n\\n        // Not-take\\n        indegree[requests[start][0]]++;\\n        indegree[requests[start][1]]--;\\n        int notTake = helper(start + 1, requests, indegree, n, count);\\n\\n        return Math.max(take, notTake);\\n     }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3706703,
                "title": "simple-c-solution-easy-to-understand-bitmasking-with-video-solution",
                "content": "[https://youtu.be/9c0-RnyRVd4](https://youtu.be/9c0-RnyRVd4)\\n\\n# Intuition\\nThis question can be solved by checking all the possible choices of requests and maximizing the number of requests choosed.\\n\\n# Approach\\n1. In order to get all the possible choices, we will use bitmasking.\\n2. We know that the total number of possible choices is ```(1<<n1)```, so we will make a bit string for each number in ```0-(1<<n1)-1``` and if any index is ```1``` then we will pass the request corresponding to it. Here ```n1==requests.size()```\\n3. For the given constraints, the size of bitstring is set to 20 here.\\n4. ```bit``` is the string as bit string.\\n5. But we don\\'t want all 20 bits we just want last ```n1``` bits.\\n6. So we will take another string ```p``` as a sub string of last ```n1``` bits of the ```bit```.\\n7. Also we will take a vector build of size ```n``` and initialize it with 0. Also take a variable ```int ans=0;``` which will count number of requests passed.\\n8. Now we will iterate in this new string ```p``` and if ```p[i]==\\'1\\'``` then we will pass the request. Also we will increase the value of ```ans``` by one.\\n9. Passing the request means we will decrease the value of ```build[a]``` and increase the value of ```build[b]``` by ```1```.\\n10. After this we will check if all the elements of build is 0 or not. Because we don\\'t want overall changes in each builiding.\\n11. If the above condition is cleared, then we will maximize the number of requests passed. \\n12. After iterating over all choices we will return the maximum value.\\n\\n# Complexity\\n- Time complexity:\\n$$O(n*2^n)$$\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n        \\n    **Please upvote if you liked!!!**\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximumRequests(int n, vector<vector<int>>& requests ) {\\n        int n1=requests.size();\\n        int m=1<<n1;\\n        int maxi=0;\\n        for(int i=0;i<m;i++){\\n            string bit=bitset<20>(i).to_string();\\n            string p=bit.substr(20-n1);\\n            vector<int>build(n,0);\\n            int ans=0;\\n            for(int i=0;i<n1;i++){\\n                if(p[i]==\\'1\\'){\\n                    ans++;\\n                    build[requests[i][0]]--;\\n                    build[requests[i][1]]++;\\n                }\\n            }\\n            bool ok=1;\\n            for(auto ele:build){\\n                if(ele!=0){\\n                    ok=0;\\n                    break;\\n                }\\n            }\\n            if(ok){\\n                maxi=max(maxi,ans);\\n            }\\n        }\\n        return maxi;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Bitmask"
                ],
                "code": "```(1<<n1)```\n```0-(1<<n1)-1```\n```1```\n```n1==requests.size()```\n```bit```\n```n1```\n```p```\n```n1```\n```bit```\n```n```\n```int ans=0;```\n```p```\n```p[i]==\\'1\\'```\n```ans```\n```build[a]```\n```build[b]```\n```1```\n```\\nclass Solution {\\npublic:\\n    int maximumRequests(int n, vector<vector<int>>& requests ) {\\n        int n1=requests.size();\\n        int m=1<<n1;\\n        int maxi=0;\\n        for(int i=0;i<m;i++){\\n            string bit=bitset<20>(i).to_string();\\n            string p=bit.substr(20-n1);\\n            vector<int>build(n,0);\\n            int ans=0;\\n            for(int i=0;i<n1;i++){\\n                if(p[i]==\\'1\\'){\\n                    ans++;\\n                    build[requests[i][0]]--;\\n                    build[requests[i][1]]++;\\n                }\\n            }\\n            bool ok=1;\\n            for(auto ele:build){\\n                if(ele!=0){\\n                    ok=0;\\n                    break;\\n                }\\n            }\\n            if(ok){\\n                maxi=max(maxi,ans);\\n            }\\n        }\\n        return maxi;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3706555,
                "title": "python-solution-backtracking",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe will maintain a list **out_in_degree** of length n.\\nWhile traversing requests[i] = [fromi, toi], we will subtract -1 from out_in_degree[fromi] and add +1 to out_in_degree[toi] and when we reach to the end of requests then we will check if out_in_degree[] is balenced or not(all elements =0). If it is balenced then we will take our ans otherwise will backtrack\\n\\n\\n# Code\\n```\\nclass Solution:\\n    def maximumRequests(self, n: int, requests: List[List[int]]) -> int:\\n        global ans\\n        ans = 0\\n        out_in_degree = [0]*n\\n        def backtrack(index, requests,out_in_degree,count):\\n            global ans    \\n            if index == len(requests):\\n                for item in out_in_degree:\\n                    if item != 0: # not zero means unbalenced out_in_degree\\n                        return\\n                ans = max(ans, count)\\n                return\\n        \\n            #consider current requests[index]\\n            out_in_degree[requests[index][0]]-=1\\n            out_in_degree[requests[index][1]]+=1\\n            backtrack(index+1, requests, out_in_degree,count+1)\\n\\n            #do not consider current requests[index]\\n            out_in_degree[requests[index][0]]+=1\\n            out_in_degree[requests[index][1]]-=1\\n            backtrack(index+1, requests, out_in_degree,count)\\n\\n        backtrack(0,requests,out_in_degree,0)\\n        return ans\\n        \\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution:\\n    def maximumRequests(self, n: int, requests: List[List[int]]) -> int:\\n        global ans\\n        ans = 0\\n        out_in_degree = [0]*n\\n        def backtrack(index, requests,out_in_degree,count):\\n            global ans    \\n            if index == len(requests):\\n                for item in out_in_degree:\\n                    if item != 0: # not zero means unbalenced out_in_degree\\n                        return\\n                ans = max(ans, count)\\n                return\\n        \\n            #consider current requests[index]\\n            out_in_degree[requests[index][0]]-=1\\n            out_in_degree[requests[index][1]]+=1\\n            backtrack(index+1, requests, out_in_degree,count+1)\\n\\n            #do not consider current requests[index]\\n            out_in_degree[requests[index][0]]+=1\\n            out_in_degree[requests[index][1]]-=1\\n            backtrack(index+1, requests, out_in_degree,count)\\n\\n        backtrack(0,requests,out_in_degree,0)\\n        return ans\\n        \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3706508,
                "title": "day-2-solution-with-easy-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nTo determine the maximum number of achievable requests, we need to find a combination of requests where the net change in employee transfers is zero for each building. This means that for each building, the number of employees leaving must be equal to the number of employees moving in. We can solve this problem by trying all possible combinations of requests and counting the maximum number of achievable requests.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Define a helper function, helper, which takes the following parameters: start (current request index), req (requests array), indegree (array to track the net change in employee transfers for each building), n (number of buildings), and count (the current count of achievable requests).\\n2. In the helper function:\\n    - Base case: If start is equal to the length of req, we have processed all requests. We need to check if the net change in employee transfers for each building is zero. Iterate through indegree and if any element is not equal to zero, return 0 (as it means the requests combination is not valid). Otherwise, return count as the maximum number of achievable requests.\\n    - Take the current request: Decrement the indegree of the source building (req[start][0]) and increment the indegree of the destination building (req[start][1]).\\n    - Recursively call the helper function with the next request (start + 1), updated indegree, and incremented count.\\n    - Undo the changes made in the previous step: Increment the indegree of the source building and decrement the indegree of the destination building.\\n    - Recursively call the helper function without taking the current request (start + 1), using the original indegree and the same count.\\n    - Return the maximum value between the results obtained from taking and not taking the current request (Math.max(take, notTake)).\\n\\n3. In the maximumRequests function, initialize the indegree array with zeros and call the helper function with initial parameters.\\n4. Return the maximum number of achievable requests obtained from the helper function.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nThe time complexity of this algorithm is O(2^R * N), where R is the number of requests and N is the number of buildings. Since we try all possible combinations of requests, there are 2^R combinations, and for each combination, we iterate through N buildings to check the net change in employee transfers.\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nThe space complexity is O(N) for the indegree array.\\n\\n# Code\\n## Dart\\n```\\nclass Solution {\\n  int maximumRequests(int n, List<List<int>> requests) {\\n    var indegree = List<int>.filled(n,0);\\n    return helper(0, requests, indegree, n, 0);\\n  }\\n\\n  int helper(int start,List<List<int>> req,List<int> indegree,int n, int count){\\n    if(start == req.length){\\n      for(int i=0;i<n;i++){\\n        if(indegree[i] != 0){\\n          return 0;\\n        }\\n      }\\n      return count;\\n    }\\n\\n    indegree[req[start][0]]--;\\n    indegree[req[start][1]]++;\\n    int take = helper(start + 1, req, indegree, n, count + 1);\\n\\n    indegree[req[start][0]]++;\\n    indegree[req[start][1]]--;\\n    int notTake = helper(start + 1, req, indegree, n, count);\\n\\n    return take > notTake ? take : notTake;\\n\\n  }\\n\\n}\\n```\\n## TypeScript\\n```\\nfunction maximumRequests(n: number, requests: number[][]): number {\\n      const indegree = new Array(n).fill(0);\\n    return helper(0, requests, indegree, n, 0);\\n};\\n\\nfunction helper(start, req, indegree, n, count) {\\n    if (start === req.length) {\\n       for (let i = 0; i < n; i++) {\\n         if (indegree[i] !== 0) {\\n           return 0;\\n         }\\n       }\\n    return count;\\n    }\\n\\n    indegree[req[start][0]]--;\\n    indegree[req[start][1]]++;\\n    const take = helper(start + 1, req, indegree, n, count + 1);\\n  \\n    indegree[req[start][0]]++;\\n    indegree[req[start][1]]--;\\n    const notTake = helper(start + 1, req, indegree, n, count);\\n  \\n    return Math.max(take, notTake);\\n}\\n```\\n\\n![Bill Murray Upvote](https://th.bing.com/th/id/R.f048f12b76dcfa8335633f17d472281a?rik=jWgu54fRJr3QGw&riu=http%3a%2f%2fwww.reactiongifs.com%2fr%2f2013%2f02%2fmurray_upvote.gif&ehk=Qe7MtFmTQXVAHWoIuDgOlA4AyT6k7nm%2f%2fr6nmKwavns%3d&risl=&pid=ImgRaw&r=0)\\n\\n",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript",
                    "Dart",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n  int maximumRequests(int n, List<List<int>> requests) {\\n    var indegree = List<int>.filled(n,0);\\n    return helper(0, requests, indegree, n, 0);\\n  }\\n\\n  int helper(int start,List<List<int>> req,List<int> indegree,int n, int count){\\n    if(start == req.length){\\n      for(int i=0;i<n;i++){\\n        if(indegree[i] != 0){\\n          return 0;\\n        }\\n      }\\n      return count;\\n    }\\n\\n    indegree[req[start][0]]--;\\n    indegree[req[start][1]]++;\\n    int take = helper(start + 1, req, indegree, n, count + 1);\\n\\n    indegree[req[start][0]]++;\\n    indegree[req[start][1]]--;\\n    int notTake = helper(start + 1, req, indegree, n, count);\\n\\n    return take > notTake ? take : notTake;\\n\\n  }\\n\\n}\\n```\n```\\nfunction maximumRequests(n: number, requests: number[][]): number {\\n      const indegree = new Array(n).fill(0);\\n    return helper(0, requests, indegree, n, 0);\\n};\\n\\nfunction helper(start, req, indegree, n, count) {\\n    if (start === req.length) {\\n       for (let i = 0; i < n; i++) {\\n         if (indegree[i] !== 0) {\\n           return 0;\\n         }\\n       }\\n    return count;\\n    }\\n\\n    indegree[req[start][0]]--;\\n    indegree[req[start][1]]++;\\n    const take = helper(start + 1, req, indegree, n, count + 1);\\n  \\n    indegree[req[start][0]]++;\\n    indegree[req[start][1]]--;\\n    const notTake = helper(start + 1, req, indegree, n, count);\\n  \\n    return Math.max(take, notTake);\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3706485,
                "title": "c-backtracking-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    int f(int ind, vector<int> &indegree, vector<vector<int>> &requests, int count){\\n\\n        if(ind==requests.size()){\\n            for(int i: indegree){\\n                if(i!=0)  return 0;\\n            }\\n            return count;\\n        }\\n\\n        indegree[requests[ind][0]]--;\\n        indegree[requests[ind][1]]++;\\n        \\n        int take = f(ind+1, indegree, requests, count+1);\\n\\n        indegree[requests[ind][0]]++;\\n        indegree[requests[ind][1]]--;\\n\\n        int notTake = f(ind+1, indegree, requests,count);\\n        return max(take,notTake);\\n    }\\n\\n    int maximumRequests(int n, vector<vector<int>>& requests) {\\n        \\n        vector<int> indegree(n,0);\\n        return f(0,indegree,requests,0);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    int f(int ind, vector<int> &indegree, vector<vector<int>> &requests, int count){\\n\\n        if(ind==requests.size()){\\n            for(int i: indegree){\\n                if(i!=0)  return 0;\\n            }\\n            return count;\\n        }\\n\\n        indegree[requests[ind][0]]--;\\n        indegree[requests[ind][1]]++;\\n        \\n        int take = f(ind+1, indegree, requests, count+1);\\n\\n        indegree[requests[ind][0]]++;\\n        indegree[requests[ind][1]]--;\\n\\n        int notTake = f(ind+1, indegree, requests,count);\\n        return max(take,notTake);\\n    }\\n\\n    int maximumRequests(int n, vector<vector<int>>& requests) {\\n        \\n        vector<int> indegree(n,0);\\n        return f(0,indegree,requests,0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3706273,
                "title": "daily-coding-challenge-java-using-backtracking-and-dfs-with-explanation",
                "content": "# Intuition\\nBacktracking & DFS\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nSkip requests[i]:\\nThe algorithm starts by skipping the current request, requests[i], and makes a recursive call to dfs(i + 1, processedReqs, requests, degree). This recursive call allows the algorithm to move on to the next request without making any changes to the degree array.\\n\\nProcess requests[i]:\\nAfter skipping the current request, the algorithm then proceeds to process it. This involves updating the degree array to reflect the movement of employees between buildings:\\n\\nDecrement the degree of the building the employee is moving from (--degree[requests[i][0]]).\\nIncrement the degree of the building the employee is moving to (++degree[requests[i][1]]).\\nThe algorithm then makes a recursive call to dfs(i + 1, processedReqs + 1, requests, degree). This recursive call explores the remaining requests with the updated degree array, considering the effect of processing the current request.\\n\\nAfter the recursive call, the algorithm reverts the changes made to the degree array by incrementing the degree of the building the employee is moving from and decrementing the degree of the building the employee is moving to:\\n\\nIncrement the degree of the building the employee is moving from (++degree[requests[i][0]]).\\nDecrement the degree of the building the employee is moving to (--degree[requests[i][1]]).\\nThis step is necessary to restore the degree array to its original state before exploring other possibilities.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(2^N).\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n\\n# Code\\n```\\nclass Solution {\\n    public int maximumRequests(int n, int[][] requests) {\\n        backtrack(0,0,requests,new int[n]);\\n        return ans;\\n    }\\n    int ans=0;\\n    private void backtrack(int index,int p,int[][] requests,int[] degree){\\n       if(requests.length==index){\\n           if(Arrays.stream(degree).allMatch(d -> d == 0)){\\n               ans=Math.max(ans,p);\\n           }\\n           return;\\n       }\\n     backtrack(index+1,p,requests,degree);\\n     --degree[requests[index][0]];\\n     ++degree[requests[index][1]];\\n     backtrack(index+1,p+1,requests,degree);\\n     ++degree[requests[index][0]];\\n     --degree[requests[index][1]];\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Backtracking",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    public int maximumRequests(int n, int[][] requests) {\\n        backtrack(0,0,requests,new int[n]);\\n        return ans;\\n    }\\n    int ans=0;\\n    private void backtrack(int index,int p,int[][] requests,int[] degree){\\n       if(requests.length==index){\\n           if(Arrays.stream(degree).allMatch(d -> d == 0)){\\n               ans=Math.max(ans,p);\\n           }\\n           return;\\n       }\\n     backtrack(index+1,p,requests,degree);\\n     --degree[requests[index][0]];\\n     ++degree[requests[index][1]];\\n     backtrack(index+1,p+1,requests,degree);\\n     ++degree[requests[index][0]];\\n     --degree[requests[index][1]];\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3706237,
                "title": "c-solution",
                "content": "\\n\\n# Approach\\nThis solution uses a backtracking approach to try all possible combinations of fulfilling the requests.\\n It keeps track of the net change in employee transfers for each building in the count vector. For each request, it tries two possibilities: fulfilling the request or not fulfilling the request.\\n If the request is fulfilled, it updates the count vector accordingly and calls the backtrack function recursively with the next index and an incremented currCount value.\\n If the request is not fulfilled, it simply calls the backtrack function recursively with the next index without updating the count vector and without incrementing currCount.\\n\\nWhen all requests have been processed (i.e., when index == requests.size()), it checks if the net change in employee transfers for all buildings is zero.\\n If it is, then it means that the current combination of fulfilled requests is achievable and it updates maxCount accordingly.\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void backtrack(vector<vector<int>>& requests, int index, vector<int>& count, int currCount, int& maxCount) {\\n        if (index == requests.size()) {\\n            for (int i = 0; i < count.size(); i++) {\\n                if (count[i] != 0) return;\\n            }\\n            maxCount = max(maxCount, currCount);\\n            return;\\n        }\\n        int from = requests[index][0];\\n        int to = requests[index][1];\\n        count[from]--;\\n        count[to]++;\\n        backtrack(requests, index + 1, count, currCount + 1, maxCount);\\n        count[from]++;\\n        count[to]--;\\n        backtrack(requests, index + 1, count, currCount, maxCount);\\n    }\\n\\n    int maximumRequests(int n, vector<vector<int>>& requests) {\\n        vector<int> count(n);\\n        int maxCount = 0;\\n        backtrack(requests, 0, count, 0, maxCount);\\n        return maxCount;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void backtrack(vector<vector<int>>& requests, int index, vector<int>& count, int currCount, int& maxCount) {\\n        if (index == requests.size()) {\\n            for (int i = 0; i < count.size(); i++) {\\n                if (count[i] != 0) return;\\n            }\\n            maxCount = max(maxCount, currCount);\\n            return;\\n        }\\n        int from = requests[index][0];\\n        int to = requests[index][1];\\n        count[from]--;\\n        count[to]++;\\n        backtrack(requests, index + 1, count, currCount + 1, maxCount);\\n        count[from]++;\\n        count[to]--;\\n        backtrack(requests, index + 1, count, currCount, maxCount);\\n    }\\n\\n    int maximumRequests(int n, vector<vector<int>>& requests) {\\n        vector<int> count(n);\\n        int maxCount = 0;\\n        backtrack(requests, 0, count, 0, maxCount);\\n        return maxCount;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3706185,
                "title": "c-brute-force-with-optimisation",
                "content": "# Approach\\n We have to **go through each subset of the requests array**\\n- because we have to ignore some of the requests and accept some so that all the accepted ones can be performed\\n    We want the subset that has max size and all the requests in it are possible\\n-  **How do we check if the subset has all requests that can be performed ?**\\n- We have to ensure that in the inAndOut array the net remains 0 for each building\\n- Because \"*All buildings are full, so a list of requests is achievable only if for each building, the net change in employee transfers is zero.*\"\\n\\n- If all the building dont have net headCount = 0 then that sbuset is not possible else if all the elem are 0 in inAndOut we simply update the ans and return\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int ans = 0;\\n    void solve(int currReq , vector<vector<int>>& requests, \\n    vector<int>& inAndOut , int reqTaken)\\n    {\\n        //base case\\n        if(currReq == requests.size())\\n        {\\n            for(auto it : inAndOut)\\n            {\\n                if(it!=0) return;\\n            }\\n            ans=max(ans,reqTaken);\\n            return;\\n        }\\n\\n        //The line below is just an OPTIMISATION , code can work without it\\n        if (reqTaken + (requests.size() - currReq) < ans) {\\n            return;\\n        }\\n\\n        //We dont take the request OR we leave it\\n        solve(currReq + 1 , requests , inAndOut , reqTaken);\\n\\n\\n        //Now when we pick the request\\n        inAndOut[requests[currReq][1]]++;\\n        inAndOut[requests[currReq][0]]--;\\n\\n        solve(currReq + 1 , requests , inAndOut , reqTaken+1);\\n\\n        //While backtracking reverse these changes\\n        inAndOut[requests[currReq][1]]--;\\n        inAndOut[requests[currReq][0]]++;\\n\\n\\n    }\\n    int maximumRequests(int n, vector<vector<int>>& requests) {\\n        vector<int> inAndOut(n);\\n        solve(0,requests,inAndOut,0);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int ans = 0;\\n    void solve(int currReq , vector<vector<int>>& requests, \\n    vector<int>& inAndOut , int reqTaken)\\n    {\\n        //base case\\n        if(currReq == requests.size())\\n        {\\n            for(auto it : inAndOut)\\n            {\\n                if(it!=0) return;\\n            }\\n            ans=max(ans,reqTaken);\\n            return;\\n        }\\n\\n        //The line below is just an OPTIMISATION , code can work without it\\n        if (reqTaken + (requests.size() - currReq) < ans) {\\n            return;\\n        }\\n\\n        //We dont take the request OR we leave it\\n        solve(currReq + 1 , requests , inAndOut , reqTaken);\\n\\n\\n        //Now when we pick the request\\n        inAndOut[requests[currReq][1]]++;\\n        inAndOut[requests[currReq][0]]--;\\n\\n        solve(currReq + 1 , requests , inAndOut , reqTaken+1);\\n\\n        //While backtracking reverse these changes\\n        inAndOut[requests[currReq][1]]--;\\n        inAndOut[requests[currReq][0]]++;\\n\\n\\n    }\\n    int maximumRequests(int n, vector<vector<int>>& requests) {\\n        vector<int> inAndOut(n);\\n        solve(0,requests,inAndOut,0);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3706155,
                "title": "accepted-java-backtrack-solution-beats-90",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    private int ans=0;\\n    void backtrack(int[][] requests, int[]building, int i, int c){\\n        if(i==requests.length){\\n            for(int x:building) {\\n                if(x!=0) return;\\n            }\\n            ans=Math.max(ans,c);\\n            return;\\n        }\\n        building[requests[i][0]]--;\\n        building[requests[i][1]]++;\\n        backtrack(requests,building,i+1,c+1);\\n        building[requests[i][0]]++;\\n        building[requests[i][1]]--;\\n        backtrack(requests,building,i+1,c+0);\\n    }\\n    public int maximumRequests(int n, int[][] requests) {\\n        backtrack(requests,new int[n],0,0);\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    private int ans=0;\\n    void backtrack(int[][] requests, int[]building, int i, int c){\\n        if(i==requests.length){\\n            for(int x:building) {\\n                if(x!=0) return;\\n            }\\n            ans=Math.max(ans,c);\\n            return;\\n        }\\n        building[requests[i][0]]--;\\n        building[requests[i][1]]++;\\n        backtrack(requests,building,i+1,c+1);\\n        building[requests[i][0]]++;\\n        building[requests[i][1]]--;\\n        backtrack(requests,building,i+1,c+0);\\n    }\\n    public int maximumRequests(int n, int[][] requests) {\\n        backtrack(requests,new int[n],0,0);\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3706143,
                "title": "c-simple-and-begineer-friendly-solution-using-recursion-backtracking",
                "content": "# Intuition & Approach\\nSince `requests` size maximum can be just `16`. Hence we can pick each and every subset of `requests` array and check whether subset is valid or not. \\n\\nOur answer would be the maximum size of valid subset.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Video Explanation\\nwatch my video for better understanding of intuition, approach and solution. I have also dry run and created **recursion tree** for one test case to make every thing crystal clear.\\n\\n[https://youtu.be/Tw4rs0RXunM]()\\n\\n# Complexity\\n- Time complexity: $$O(2^m)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(m)$$\\n\\nhere, m represents size of requests.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isValidRequests(vector<int> &shifting)\\n    {\\n        for(int i=0;i<shifting.size();i++)\\n        {\\n            if(shifting[i] != 0)\\n            {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n    void solve(int idx,int reqctr, vector<vector<int>> &requests, vector<int> &shifting, int &ans)\\n    {\\n        if(idx == requests.size())\\n        {\\n            if(isValidRequests(shifting))\\n            {\\n                ans = max(ans, reqctr);\\n            }\\n            return;\\n        }\\n\\n        solve(idx+1, reqctr, requests, shifting, ans);\\n\\n        shifting[requests[idx][0]]--;\\n        shifting[requests[idx][1]]++;\\n        solve(idx+1, reqctr+1, requests, shifting, ans);\\n        shifting[requests[idx][0]]++;\\n        shifting[requests[idx][1]]--;\\n    }\\n    int maximumRequests(int n, vector<vector<int>>& requests) {\\n        vector<int> shifting(n, 0);\\n        int ans = 0;\\n        solve(0, 0, requests, shifting, ans);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isValidRequests(vector<int> &shifting)\\n    {\\n        for(int i=0;i<shifting.size();i++)\\n        {\\n            if(shifting[i] != 0)\\n            {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n    void solve(int idx,int reqctr, vector<vector<int>> &requests, vector<int> &shifting, int &ans)\\n    {\\n        if(idx == requests.size())\\n        {\\n            if(isValidRequests(shifting))\\n            {\\n                ans = max(ans, reqctr);\\n            }\\n            return;\\n        }\\n\\n        solve(idx+1, reqctr, requests, shifting, ans);\\n\\n        shifting[requests[idx][0]]--;\\n        shifting[requests[idx][1]]++;\\n        solve(idx+1, reqctr+1, requests, shifting, ans);\\n        shifting[requests[idx][0]]++;\\n        shifting[requests[idx][1]]--;\\n    }\\n    int maximumRequests(int n, vector<vector<int>>& requests) {\\n        vector<int> shifting(n, 0);\\n        int ans = 0;\\n        solve(0, 0, requests, shifting, ans);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3706116,
                "title": "java-backtracking-helpful-comments-clean-code-better-performance-than-official",
                "content": "**M** = Number of requests, **N** = Number of buildings\\n\\n**Runtime**: O(2^M)  **This is better than official solution because we do not need to process the array to see if all buildings are at 0 indegrees thanks to the `netDifference` variable**\\n\\n**Space**: O(N + M), need N array and M recursive stack\\n\\n``` java\\nclass Solution {\\n    public int maximumRequests(int n, int[][] requests) {\\n        return maximumRequestsRecursive(n, 0, requests, 0, new int[n], 0);\\n    }\\n    \\n    private int maximumRequestsRecursive(int n, int requestNum, int[][] requests, int netDifference, int[] changeFromOrigin, int processedRequests) {\\n        // Base case: if all requests have been processed\\n        if(requestNum > requests.length - 1) {\\n            if(netDifference != 0) return -1;\\n            return processedRequests;\\n        }\\n        \\n        // Option 1: Ignore current request\\n        int ignore = maximumRequestsRecursive(n, requestNum + 1, requests, netDifference, changeFromOrigin, processedRequests);\\n        \\n        // Process current request\\n        int from = requests[requestNum][0];\\n        int to = requests[requestNum][1];\\n        \\n        changeFromOrigin[from]--;\\n        changeFromOrigin[to]++;\\n        \\n        // If the \"from\" and \"to\" are different\\n        if(from != to) {\\n            // Case where the loss in a person got us closer to 0\\n            if(changeFromOrigin[from] >= 0) {\\n                netDifference--;\\n            } else {\\n                netDifference++; \\n            }\\n        \\n            // Case where the increase in capacity got us closer to 0\\n            if(changeFromOrigin[to] <= 0) {\\n                netDifference--;\\n            } else {\\n                netDifference++;\\n            }\\n        }\\n\\n        // Option 2: Include current request\\n        int include = maximumRequestsRecursive(n, requestNum + 1, requests, netDifference, changeFromOrigin, processedRequests + 1);\\n        \\n        // Undo the changes made to changeFromOrigin array\\n        changeFromOrigin[from]++;\\n        changeFromOrigin[to]--;\\n        \\n        // Return the maximum between ignoring and including the current request\\n        return Math.max(ignore, include);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Backtracking"
                ],
                "code": "``` java\\nclass Solution {\\n    public int maximumRequests(int n, int[][] requests) {\\n        return maximumRequestsRecursive(n, 0, requests, 0, new int[n], 0);\\n    }\\n    \\n    private int maximumRequestsRecursive(int n, int requestNum, int[][] requests, int netDifference, int[] changeFromOrigin, int processedRequests) {\\n        // Base case: if all requests have been processed\\n        if(requestNum > requests.length - 1) {\\n            if(netDifference != 0) return -1;\\n            return processedRequests;\\n        }\\n        \\n        // Option 1: Ignore current request\\n        int ignore = maximumRequestsRecursive(n, requestNum + 1, requests, netDifference, changeFromOrigin, processedRequests);\\n        \\n        // Process current request\\n        int from = requests[requestNum][0];\\n        int to = requests[requestNum][1];\\n        \\n        changeFromOrigin[from]--;\\n        changeFromOrigin[to]++;\\n        \\n        // If the \"from\" and \"to\" are different\\n        if(from != to) {\\n            // Case where the loss in a person got us closer to 0\\n            if(changeFromOrigin[from] >= 0) {\\n                netDifference--;\\n            } else {\\n                netDifference++; \\n            }\\n        \\n            // Case where the increase in capacity got us closer to 0\\n            if(changeFromOrigin[to] <= 0) {\\n                netDifference--;\\n            } else {\\n                netDifference++;\\n            }\\n        }\\n\\n        // Option 2: Include current request\\n        int include = maximumRequestsRecursive(n, requestNum + 1, requests, netDifference, changeFromOrigin, processedRequests + 1);\\n        \\n        // Undo the changes made to changeFromOrigin array\\n        changeFromOrigin[from]++;\\n        changeFromOrigin[to]--;\\n        \\n        // Return the maximum between ignoring and including the current request\\n        return Math.max(ignore, include);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3706104,
                "title": "c-using-bfs-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution{\\n   struct Edge{\\n      int v, w, sw, rev;\\n      constexpr Edge(int v, int w, int sw, int rev) noexcept: v(v), w(w), sw(sw), rev(rev){}\\n   };\\npublic:\\n   int maximumRequests(int n, vector<vector<int>> &req) const{\\n      vector<vector<Edge>> g(n);\\n      int ans = 0;\\n      for(auto const &e: req){\\n         int u = e[0], v = e[1];\\n         if(u == v){\\n            ++ans; continue;\\n         }\\n         g[u].emplace_back(v, 1, 1, g[v].size());\\n         g[v].emplace_back(u, -1, 0, g[u].size()-1);\\n      }\\n      while(1){\\n         vector<int> d(n), pv(n), pe(n), cnt(n);\\n         queue<int> bf;\\n         for(int i=0; i<n; ++i){\\n            bf.push(i);\\n         }\\n         vector<bool> inq(n, true);\\n         int ncv = -1;\\n         while(!bf.empty()){\\n            int u = bf.front(); bf.pop(); inq[u] = false;\\n            for(size_t i=0; i<g[u].size(); ++i){\\n               auto [v, w, sw, _] = g[u][i];\\n               if(!sw || d[v]>=d[u]+w) continue;\\n               d[v] = d[u]+w;\\n               pv[v] = u; pe[v] = i;\\n               if(!inq[v]){\\n                  if(++cnt[v] == n){\\n                     ncv = v;\\n                     goto after_bf;\\n                  }\\n                  bf.push(v); inq[v] = true;\\n               }\\n            }\\n         }\\n         after_bf:\\n         if(ncv == -1) break;\\n         vector<bool> vis(n);\\n         for(; !vis[ncv]; ncv=pv[ncv]){\\n            vis[ncv] = true;\\n         }\\n         int u = ncv;\\n         do{\\n            int p = pv[u], i = pe[u];\\n            ans += g[p][i].w;\\n            g[p][i].sw = 0;\\n            g[u][g[p][i].rev].sw = 1;\\n            u = p;\\n         }while(u != ncv);\\n      }\\n      return ans;\\n   }\\n};\\n\\n//please upvote\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution{\\n   struct Edge{\\n      int v, w, sw, rev;\\n      constexpr Edge(int v, int w, int sw, int rev) noexcept: v(v), w(w), sw(sw), rev(rev){}\\n   };\\npublic:\\n   int maximumRequests(int n, vector<vector<int>> &req) const{\\n      vector<vector<Edge>> g(n);\\n      int ans = 0;\\n      for(auto const &e: req){\\n         int u = e[0], v = e[1];\\n         if(u == v){\\n            ++ans; continue;\\n         }\\n         g[u].emplace_back(v, 1, 1, g[v].size());\\n         g[v].emplace_back(u, -1, 0, g[u].size()-1);\\n      }\\n      while(1){\\n         vector<int> d(n), pv(n), pe(n), cnt(n);\\n         queue<int> bf;\\n         for(int i=0; i<n; ++i){\\n            bf.push(i);\\n         }\\n         vector<bool> inq(n, true);\\n         int ncv = -1;\\n         while(!bf.empty()){\\n            int u = bf.front(); bf.pop(); inq[u] = false;\\n            for(size_t i=0; i<g[u].size(); ++i){\\n               auto [v, w, sw, _] = g[u][i];\\n               if(!sw || d[v]>=d[u]+w) continue;\\n               d[v] = d[u]+w;\\n               pv[v] = u; pe[v] = i;\\n               if(!inq[v]){\\n                  if(++cnt[v] == n){\\n                     ncv = v;\\n                     goto after_bf;\\n                  }\\n                  bf.push(v); inq[v] = true;\\n               }\\n            }\\n         }\\n         after_bf:\\n         if(ncv == -1) break;\\n         vector<bool> vis(n);\\n         for(; !vis[ncv]; ncv=pv[ncv]){\\n            vis[ncv] = true;\\n         }\\n         int u = ncv;\\n         do{\\n            int p = pv[u], i = pe[u];\\n            ans += g[p][i].w;\\n            g[p][i].sw = 0;\\n            g[u][g[p][i].rev].sw = 1;\\n            u = p;\\n         }while(u != ncv);\\n      }\\n      return ans;\\n   }\\n};\\n\\n//please upvote\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2976654,
                "title": "c-convert-to-minimum-cost-flow-problem-7ms-100-lines",
                "content": "finding maximum number of achievable requests\\n=> finding maximum \"balanced\" graph where every vertex in_degree == out_degree\\n=> finding minimum edges to remove to make graph \"balanced\"\\n=> edges removed form a path from out_vertex (out_deg>in_deg) to in_vertex (out_deg<in_deg)\\n=> use a vertex S to represent all out_vertex, a vertex T to represent all in_vertex\\n=> problem become to find minimum edges from S to T to remove\\n=> let edges cost in original graph is 1, the problem is the same as find minimum cost of sending K flows from S to T, where K is the number of out_vertex\\n\\n# Code\\n```\\nstruct SSP {\\n  struct Edge {\\n    int a,b,cap,cost;\\n  };\\n  int n,s,t;\\n  vector<Edge> es;\\n  vector<vector<int>> g;\\n  vector<int> parent;\\n  vector<int> ptr;\\n  vector<int> dist;\\n  vector<int> inq;\\n  SSP(int n=0, int s=0, int t=0):\\n    n(n),s(s),t(t),g(n),parent(n),ptr(n),dist(n),inq(n) {}\\n  void add_edge(int a, int b, int cap, int cost) {\\n    Edge e1{a,b,cap,cost};\\n    Edge e2{b,a,0,-cost};\\n    g[a].push_back(es.size());\\n    es.push_back(e1);\\n    g[b].push_back(es.size());\\n    es.push_back(e2);\\n  }\\n  void bf() {\\n    fill(dist.begin(), dist.end(), INT_MAX);\\n    fill(inq.begin(), inq.end(), false);\\n    queue<int> q;\\n    dist[s] = 0;\\n    inq[s] = true;\\n    q.push(s);\\n    while (!q.empty()) {\\n      int u = q.front();\\n      q.pop();\\n      inq[u] = false;\\n      for (auto& id: g[u]) {\\n        int v = es[id].b;\\n        int alt = dist[u]+es[id].cost;\\n        if (es[id].cap > 0 && alt < dist[v]) {\\n          dist[v] = alt;\\n          parent[v] = u;\\n          ptr[v] = id;\\n          if (!inq[v]) {\\n            q.push(v);\\n            inq[v] = true;\\n          }\\n        }\\n      }\\n    }\\n  }\\n  int mcf(int k) {\\n    int flow = 0, cost = 0;\\n    while (flow < k) {\\n      bf();\\n      if (dist[t] == INT_MAX) { break; }\\n      int f = k-flow;\\n      int cur = t;\\n      while (cur != s) {\\n        f = min(f, es[ptr[cur]].cap);\\n        cur = parent[cur];\\n      }\\n      flow += f;\\n      cost += f*dist[t];\\n      cur = t;\\n      while (cur != s) {\\n        es[ptr[cur]].cap -= f;\\n        es[ptr[cur]^1].cap += f;\\n        cur = parent[cur];\\n      }\\n    }\\n    return flow<k? -1: cost;\\n  }\\n};\\nclass Solution {\\npublic:\\n    int maximumRequests(int n, vector<vector<int>>& requests) {\\n      int s = n, t = n+1;\\n      SSP ssp(n+2,s,t);\\n      vector<int> deg(n);\\n      for (auto& req: requests) {\\n        int u = req[0], v = req[1];\\n        ssp.add_edge(u,v,1,1);\\n        deg[u] += 1; deg[v] -= 1;\\n      }\\n      int k = 0;\\n      for (int i = 0; i < n; ++i) {\\n        if (deg[i] > 0) {\\n          ssp.add_edge(s,i,deg[i],0);\\n          k += deg[i];\\n        } else if (deg[i] < 0) {\\n          ssp.add_edge(i,t,-deg[i],0);\\n        }\\n      }\\n      int f = ssp.mcf(k);\\n      return requests.size()-f;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nstruct SSP {\\n  struct Edge {\\n    int a,b,cap,cost;\\n  };\\n  int n,s,t;\\n  vector<Edge> es;\\n  vector<vector<int>> g;\\n  vector<int> parent;\\n  vector<int> ptr;\\n  vector<int> dist;\\n  vector<int> inq;\\n  SSP(int n=0, int s=0, int t=0):\\n    n(n),s(s),t(t),g(n),parent(n),ptr(n),dist(n),inq(n) {}\\n  void add_edge(int a, int b, int cap, int cost) {\\n    Edge e1{a,b,cap,cost};\\n    Edge e2{b,a,0,-cost};\\n    g[a].push_back(es.size());\\n    es.push_back(e1);\\n    g[b].push_back(es.size());\\n    es.push_back(e2);\\n  }\\n  void bf() {\\n    fill(dist.begin(), dist.end(), INT_MAX);\\n    fill(inq.begin(), inq.end(), false);\\n    queue<int> q;\\n    dist[s] = 0;\\n    inq[s] = true;\\n    q.push(s);\\n    while (!q.empty()) {\\n      int u = q.front();\\n      q.pop();\\n      inq[u] = false;\\n      for (auto& id: g[u]) {\\n        int v = es[id].b;\\n        int alt = dist[u]+es[id].cost;\\n        if (es[id].cap > 0 && alt < dist[v]) {\\n          dist[v] = alt;\\n          parent[v] = u;\\n          ptr[v] = id;\\n          if (!inq[v]) {\\n            q.push(v);\\n            inq[v] = true;\\n          }\\n        }\\n      }\\n    }\\n  }\\n  int mcf(int k) {\\n    int flow = 0, cost = 0;\\n    while (flow < k) {\\n      bf();\\n      if (dist[t] == INT_MAX) { break; }\\n      int f = k-flow;\\n      int cur = t;\\n      while (cur != s) {\\n        f = min(f, es[ptr[cur]].cap);\\n        cur = parent[cur];\\n      }\\n      flow += f;\\n      cost += f*dist[t];\\n      cur = t;\\n      while (cur != s) {\\n        es[ptr[cur]].cap -= f;\\n        es[ptr[cur]^1].cap += f;\\n        cur = parent[cur];\\n      }\\n    }\\n    return flow<k? -1: cost;\\n  }\\n};\\nclass Solution {\\npublic:\\n    int maximumRequests(int n, vector<vector<int>>& requests) {\\n      int s = n, t = n+1;\\n      SSP ssp(n+2,s,t);\\n      vector<int> deg(n);\\n      for (auto& req: requests) {\\n        int u = req[0], v = req[1];\\n        ssp.add_edge(u,v,1,1);\\n        deg[u] += 1; deg[v] -= 1;\\n      }\\n      int k = 0;\\n      for (int i = 0; i < n; ++i) {\\n        if (deg[i] > 0) {\\n          ssp.add_edge(s,i,deg[i],0);\\n          k += deg[i];\\n        } else if (deg[i] < 0) {\\n          ssp.add_edge(i,t,-deg[i],0);\\n        }\\n      }\\n      int f = ssp.mcf(k);\\n      return requests.size()-f;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2556660,
                "title": "java-solution-100-faster-backtracking",
                "content": "```\\nclass Solution {\\n    int ans = 0;\\n    public int maximumRequests(int n, int[][] requests) {\\n        int[] degree = new int[n];\\n        permitReq(requests, 0, degree, 0);\\n        return ans;\\n    }\\n    \\n    void permitReq(int[][] req, int ind, int[] degree, int temp){\\n        if(ind == req.length){\\n            for(int i = 0 ; i < degree.length ; i++){\\n                if(degree[i] != 0)\\n                    return;\\n            }\\n            ans = Math.max(ans, temp);\\n            return;\\n        }\\n            \\n        int i = req[ind][0];\\n        int j = req[ind][1];\\n        \\n//         Permit the request at index ind\\n        degree[i] = degree[i]-1;\\n        degree[j] = degree[j]+1;\\n        permitReq(req, ind+1, degree, temp+1);\\n        \\n//         Reject the request at index ind\\n        degree[i] = degree[i]+1;\\n        degree[j] = degree[j]-1;\\n        permitReq(req, ind+1, degree, temp);\\n    }\\n}\\n```\\n\\nIf you like the solution, please UPVOTE :)",
                "solutionTags": [
                    "Java",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\n    int ans = 0;\\n    public int maximumRequests(int n, int[][] requests) {\\n        int[] degree = new int[n];\\n        permitReq(requests, 0, degree, 0);\\n        return ans;\\n    }\\n    \\n    void permitReq(int[][] req, int ind, int[] degree, int temp){\\n        if(ind == req.length){\\n            for(int i = 0 ; i < degree.length ; i++){\\n                if(degree[i] != 0)\\n                    return;\\n            }\\n            ans = Math.max(ans, temp);\\n            return;\\n        }\\n            \\n        int i = req[ind][0];\\n        int j = req[ind][1];\\n        \\n//         Permit the request at index ind\\n        degree[i] = degree[i]-1;\\n        degree[j] = degree[j]+1;\\n        permitReq(req, ind+1, degree, temp+1);\\n        \\n//         Reject the request at index ind\\n        degree[i] = degree[i]+1;\\n        degree[j] = degree[j]-1;\\n        permitReq(req, ind+1, degree, temp);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2282560,
                "title": "c-easy-backtracking-commented-solution-easy-to-understand",
                "content": "Just check invard and outward movement by taking all possible combinations of requests.\\n```\\nclass Solution {\\npublic:\\n    \\n    void fun(vector < vector < int > > & rq , vector < int > & cap , int ind , int req , int& maxRequests){ \\n    \\n        if(ind >= rq.size()){ \\n           \\n            for(auto a : cap){ \\n              if( a != 0) return; // the capacity of each building should be zero if it is not then it will be unbalanced request\\n\\t\\t\\t  //hence answer cant be find and we will return \\n            }\\n            maxRequests = max(maxRequests , req); \\n            return; \\n        }\\n        \\n        \\n        fun(rq , cap , ind+1 , req , maxRequests);  // if we are not considering current requests\\n        \\n        cap[rq[ind][0]]--; cap[rq[ind][1]]++;   // if any request enter in a building then the capacity increase by 1 and if leave from the building then capacity decrease by 1\\n        \\n      fun(rq , cap , ind+1 , req+1 , maxRequests);  // if we are considering the current request\\n        \\n         cap[rq[ind][0]]++; cap[rq[ind][1]]--;   // backtrack the requests\\n    \\n    }\\n    \\n    int maximumRequests(int n, vector<vector<int>>& requests) {\\n       int maxRequests = 0 ; \\n        vector < int > capacity(n , 0);  //number of requests each buildings holds\\n        fun(requests , capacity , 0 , 0 , maxRequests); \\n        return maxRequests; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Backtracking",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    void fun(vector < vector < int > > & rq , vector < int > & cap , int ind , int req , int& maxRequests){ \\n    \\n        if(ind >= rq.size()){ \\n           \\n            for(auto a : cap){ \\n              if( a != 0) return; // the capacity of each building should be zero if it is not then it will be unbalanced request\\n\\t\\t\\t  //hence answer cant be find and we will return \\n            }\\n            maxRequests = max(maxRequests , req); \\n            return; \\n        }\\n        \\n        \\n        fun(rq , cap , ind+1 , req , maxRequests);  // if we are not considering current requests\\n        \\n        cap[rq[ind][0]]--; cap[rq[ind][1]]++;   // if any request enter in a building then the capacity increase by 1 and if leave from the building then capacity decrease by 1\\n        \\n      fun(rq , cap , ind+1 , req+1 , maxRequests);  // if we are considering the current request\\n        \\n         cap[rq[ind][0]]++; cap[rq[ind][1]]--;   // backtrack the requests\\n    \\n    }\\n    \\n    int maximumRequests(int n, vector<vector<int>>& requests) {\\n       int maxRequests = 0 ; \\n        vector < int > capacity(n , 0);  //number of requests each buildings holds\\n        fun(requests , capacity , 0 , 0 , maxRequests); \\n        return maxRequests; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2015509,
                "title": "java-check-for-all-possible-combinations-of-requests-elegant-and-concise-solution",
                "content": "```\\nclass Solution {\\n    public int maximumRequests(int n, int[][] requests) {\\n      \\n        int ans = 0;\\n        int totalComb = (1 << requests.length);\\n        for(int i=0; i<totalComb; i++){\\n            int[] totalInOut = new int[n];\\n            \\n            for(int j=0; j<16; j++){\\n                if((i & (1<<j)) == 0) continue;\\n                \\n                totalInOut[requests[j][0]]--;\\n                totalInOut[requests[j][1]]++;\\n            }\\n            \\n            boolean requestsPossible = true;\\n            for(int buildingNum=0; buildingNum < n; buildingNum++){\\n                if(totalInOut[buildingNum] != 0){\\n                    requestsPossible = false;\\n                    break;\\n                }\\n            }\\n            \\n            /*\\n                If the requests in the current combination are possible, find the total number of requests serviced in the current combination\\n                (i.e. the number of 1 bits)\\n            */\\n            if(requestsPossible){\\n                ans = Math.max(ans, Integer.bitCount(i));\\n            }\\n        }\\n        \\n        \\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int maximumRequests(int n, int[][] requests) {\\n      \\n        int ans = 0;\\n        int totalComb = (1 << requests.length);\\n        for(int i=0; i<totalComb; i++){\\n            int[] totalInOut = new int[n];\\n            \\n            for(int j=0; j<16; j++){\\n                if((i & (1<<j)) == 0) continue;\\n                \\n                totalInOut[requests[j][0]]--;\\n                totalInOut[requests[j][1]]++;\\n            }\\n            \\n            boolean requestsPossible = true;\\n            for(int buildingNum=0; buildingNum < n; buildingNum++){\\n                if(totalInOut[buildingNum] != 0){\\n                    requestsPossible = false;\\n                    break;\\n                }\\n            }\\n            \\n            /*\\n                If the requests in the current combination are possible, find the total number of requests serviced in the current combination\\n                (i.e. the number of 1 bits)\\n            */\\n            if(requestsPossible){\\n                ans = Math.max(ans, Integer.bitCount(i));\\n            }\\n        }\\n        \\n        \\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1556217,
                "title": "python-dp",
                "content": "```\\nfrom functools import lru_cache\\n\\nclass Solution:\\n    def maximumRequests(self, n: int, requests: List[List[int]]) -> int:\\n        m = len(requests)\\n        @lru_cache(None)\\n        def dp(i, degree):\\n            if i == m: return 0 if all(k == 0 for k in degree) else float(\\'-inf\\')\\n            if requests[i][0] == requests[i][1]: return 1 + dp(i + 1, degree)\\n            ret = dp(i + 1, degree)\\n            nxt_degree = list(degree)\\n            nxt_degree[requests[i][0]] -= 1\\n            nxt_degree[requests[i][1]] += 1\\n            ret = max(ret, 1 + dp(i + 1, tuple(nxt_degree)))\\n            return ret\\n        return max(0, dp(0, tuple([0] * n)))\\n\\t```",
                "solutionTags": [],
                "code": "```\\nfrom functools import lru_cache\\n\\nclass Solution:\\n    def maximumRequests(self, n: int, requests: List[List[int]]) -> int:\\n        m = len(requests)\\n        @lru_cache(None)\\n        def dp(i, degree):\\n            if i == m: return 0 if all(k == 0 for k in degree) else float(\\'-inf\\')\\n            if requests[i][0] == requests[i][1]: return 1 + dp(i + 1, degree)\\n            ret = dp(i + 1, degree)\\n            nxt_degree = list(degree)\\n            nxt_degree[requests[i][0]] -= 1\\n            nxt_degree[requests[i][1]] += 1\\n            ret = max(ret, 1 + dp(i + 1, tuple(nxt_degree)))\\n            return ret\\n        return max(0, dp(0, tuple([0] * n)))\\n\\t```",
                "codeTag": "Java"
            },
            {
                "id": 1133458,
                "title": "python-44ms-100-speed-with-smart-brute-force",
                "content": "The time complexity for this approach is (probably) still O(2^m), where m is the number of requests, which is worse than the more complex cycle-finding algorithms. However, by iterating over all combinations, we get access to one extra optimization, which is upper-bounding the maximal request size, bringing the speed down to 44 ms from around 350 ms.\\n\\nAll of the work is done in the last 10 lines; the rest is pre-processing using some optimizations:\\n\\n1. We can remove all loops (1-cycles) immediately, as these are always satisfied\\n\\n2. Any vertex which has only outgoing or only incoming edges can be ignored: no requests with this vertex can be satisfied. Use the symmetric difference operator to find these quickly.\\n3. Use provable bounds to limit the maximum number of remaining requests we can consider. This is based only on the values of (outdegree(v) - indegree(v)) for each vertex v, which I call the \\'excess\\' degree for that vertex. If vertex v has 5 outgoing edges and 2 incoming edges, its excess is 5-2 = 3, and we know that only min(5,2)= 2 edge-requests with v can ever be satisfied.\\n4. A stronger bound than 3 for limiting maximum requests: Consider a subset of vertices, say (a, b, c), which each have more outgoing edges than incoming edges. If a has 1 extra outgoing edge, b has 3 extra outgoing edges, and c has 7 extra outgoing edges, we can reason that any balanced set of requests over all vertices is missing at least 1 outgoing edge from a, 3 outgoing edges from b, and 7 extra outgoing edges from c, so we only need to consider subsets of requests of size <= len(requests) - (3+7+1). Since we\\'re only counting outgoing edges (or only counting incoming edges), there\\'s no double counting. These are the sum_pos (extra incoming edges) and sum_neg (extra outgoing edges).\\n5. Take the max \\'excess\\' unsatisfiable requests from 3 or 4, and iterate over all combinations of requests missing at least that \\'excess\\' number of requests.\\n\\n\\n```python\\ndef maximumRequests(self, n: int, requests: List[List[int]]) -> int:\\n\\tloop_count = 0\\n\\tto_remove = []\\n\\t# Remove any loops, and any edges a->b where a has no incoming or b has no outgoing edges\\n\\thas_outgoing_edges = set()\\n\\thas_incoming_edges = set()\\n\\tfor i in range(len(requests)):\\n\\t\\tif requests[i][0] == requests[i][1]:\\n\\t\\t\\tloop_count += 1\\n\\t\\t\\tto_remove.append(i)\\n\\t\\telse:\\n\\t\\t\\thas_outgoing_edges.add(requests[i][0])\\n\\t\\t\\thas_incoming_edges.add(requests[i][1])\\n\\tfor j in reversed(to_remove):\\n\\t\\tdel requests[j]\\n\\n\\t# Find which vertices have outgoing or incoming edges but not both\\n\\thas_incoming_edges.symmetric_difference_update(has_outgoing_edges)\\n\\tif has_incoming_edges:\\n\\t\\tto_remove = []\\n\\t\\tfor i in range(len(requests)):\\n\\t\\t\\tif requests[i][0] in has_incoming_edges or requests[i][1] in has_incoming_edges:\\n\\t\\t\\t\\tto_remove.append(i)\\n\\t\\tfor j in reversed(to_remove):\\n\\t\\t\\tdel requests[j]\\n\\n\\tif not requests:\\n\\t\\treturn loop_count\\n\\n\\t# Bound the maximum number of feasible requests\\n\\tcounts_of = [0] * n\\n\\tfor a, b in requests:\\n\\t\\tcounts_of[a] -= 1\\n\\t\\tcounts_of[b] += 1\\n\\texcess = max(abs(j) for j in counts_of)\\n\\tif excess:\\n\\t\\tsum_pos, sum_neg = 0, 0\\n\\t\\tfor x in counts_of:\\n\\t\\t\\tif x > 0:\\n\\t\\t\\t\\tsum_pos += x\\n\\t\\t\\telse:\\n\\t\\t\\t\\tsum_neg += x\\n\\t\\texcess = max(excess, sum_pos, -sum_neg)\\n\\n\\t# Iterate over all combinations of requests of feasible size\\n\\tnum_req = len(requests)\\n\\tfor num_allowed in range(num_req-excess,1,-1):\\n\\t\\tfor comb in itertools.combinations(requests, num_allowed):\\n\\t\\t\\tcounts_of = [0] * n\\n\\t\\t\\tfor a, b in comb:\\n\\t\\t\\t\\tcounts_of[a] -= 1\\n\\t\\t\\t\\tcounts_of[b] += 1\\n\\t\\t\\t# Check if this combination is perfectly balanced\\n\\t\\t\\tif not any(counts_of):\\n\\t\\t\\t\\treturn loop_count + num_allowed\\n\\treturn loop_count\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```python\\ndef maximumRequests(self, n: int, requests: List[List[int]]) -> int:\\n\\tloop_count = 0\\n\\tto_remove = []\\n\\t# Remove any loops, and any edges a->b where a has no incoming or b has no outgoing edges\\n\\thas_outgoing_edges = set()\\n\\thas_incoming_edges = set()\\n\\tfor i in range(len(requests)):\\n\\t\\tif requests[i][0] == requests[i][1]:\\n\\t\\t\\tloop_count += 1\\n\\t\\t\\tto_remove.append(i)\\n\\t\\telse:\\n\\t\\t\\thas_outgoing_edges.add(requests[i][0])\\n\\t\\t\\thas_incoming_edges.add(requests[i][1])\\n\\tfor j in reversed(to_remove):\\n\\t\\tdel requests[j]\\n\\n\\t# Find which vertices have outgoing or incoming edges but not both\\n\\thas_incoming_edges.symmetric_difference_update(has_outgoing_edges)\\n\\tif has_incoming_edges:\\n\\t\\tto_remove = []\\n\\t\\tfor i in range(len(requests)):\\n\\t\\t\\tif requests[i][0] in has_incoming_edges or requests[i][1] in has_incoming_edges:\\n\\t\\t\\t\\tto_remove.append(i)\\n\\t\\tfor j in reversed(to_remove):\\n\\t\\t\\tdel requests[j]\\n\\n\\tif not requests:\\n\\t\\treturn loop_count\\n\\n\\t# Bound the maximum number of feasible requests\\n\\tcounts_of = [0] * n\\n\\tfor a, b in requests:\\n\\t\\tcounts_of[a] -= 1\\n\\t\\tcounts_of[b] += 1\\n\\texcess = max(abs(j) for j in counts_of)\\n\\tif excess:\\n\\t\\tsum_pos, sum_neg = 0, 0\\n\\t\\tfor x in counts_of:\\n\\t\\t\\tif x > 0:\\n\\t\\t\\t\\tsum_pos += x\\n\\t\\t\\telse:\\n\\t\\t\\t\\tsum_neg += x\\n\\t\\texcess = max(excess, sum_pos, -sum_neg)\\n\\n\\t# Iterate over all combinations of requests of feasible size\\n\\tnum_req = len(requests)\\n\\tfor num_allowed in range(num_req-excess,1,-1):\\n\\t\\tfor comb in itertools.combinations(requests, num_allowed):\\n\\t\\t\\tcounts_of = [0] * n\\n\\t\\t\\tfor a, b in comb:\\n\\t\\t\\t\\tcounts_of[a] -= 1\\n\\t\\t\\t\\tcounts_of[b] += 1\\n\\t\\t\\t# Check if this combination is perfectly balanced\\n\\t\\t\\tif not any(counts_of):\\n\\t\\t\\t\\treturn loop_count + num_allowed\\n\\treturn loop_count\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1125208,
                "title": "pure-java-solution",
                "content": "public int maximumRequests(int n, int[][] requests) {\\n        int res = 0;\\n        outer_loop: for(int m = 0; m < (1 << requests.length); m++) {\\n            int[] balance = new int[n];\\n            for(int i = 0; i < requests.length; i++) {\\n                if(((m >> i)&1) == 1) {\\n                    balance[requests[i][0]]--;\\n                    balance[requests[i][1]]++;\\n                }\\n            }\\n            for(int i = 0; i < n; i++) if(balance[i] != 0) continue outer_loop;\\n            res = Math.max(res, Integer.bitCount(m));\\n        }\\n        return res;\\n    }",
                "solutionTags": [],
                "code": "public int maximumRequests(int n, int[][] requests) {\\n        int res = 0;\\n        outer_loop: for(int m = 0; m < (1 << requests.length); m++) {\\n            int[] balance = new int[n];\\n            for(int i = 0; i < requests.length; i++) {\\n                if(((m >> i)&1) == 1) {\\n                    balance[requests[i][0]]--;\\n                    balance[requests[i][1]]++;\\n                }\\n            }\\n            for(int i = 0; i < n; i++) if(balance[i] != 0) continue outer_loop;\\n            res = Math.max(res, Integer.bitCount(m));\\n        }\\n        return res;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1069503,
                "title": "java-super-short-solution",
                "content": "```\\n    public int maximumRequests(int n, int[][] requests) {\\n        int res = 0;\\n        outer_loop: for(int m = 0; m < (1 << requests.length); m++) {\\n            int[] balance = new int[n];\\n            for(int i = 0; i < requests.length; i++) {\\n                if(((m >> i)&1) == 1) {\\n                    balance[requests[i][0]]--;\\n                    balance[requests[i][1]]++;\\n                }\\n            }\\n            for(int i = 0; i < n; i++) if(balance[i] != 0) continue outer_loop;\\n            res = Math.max(res, Integer.bitCount(m));\\n        }\\n        return res;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public int maximumRequests(int n, int[][] requests) {\\n        int res = 0;\\n        outer_loop: for(int m = 0; m < (1 << requests.length); m++) {\\n            int[] balance = new int[n];\\n            for(int i = 0; i < requests.length; i++) {\\n                if(((m >> i)&1) == 1) {\\n                    balance[requests[i][0]]--;\\n                    balance[requests[i][1]]++;\\n                }\\n            }\\n            for(int i = 0; i < n; i++) if(balance[i] != 0) continue outer_loop;\\n            res = Math.max(res, Integer.bitCount(m));\\n        }\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 920150,
                "title": "java-dfs-29-ms-faster-than-53-86-36-2-mb-less-than-7-72",
                "content": "```\\nclass Solution {\\n    public int maximumRequests(int n, int[][] requests) {\\n        return dfs(new int[n], 0, 0, requests, 0);\\n    }\\n\\n    private int dfs(int[] cnts, int unbalanced, int cur, int[][] requests, int cnt) {\\n        if (cur >= requests.length) {\\n            return unbalanced == 0 ? cnt : 0;\\n        }\\n        int max = 0;\\n        max = Math.max(max, dfs(cnts, unbalanced, cur + 1, requests, cnt));\\n        int[] r = requests[cur];\\n        --cnts[r[0]];\\n        unbalanced += cnts[r[0]] == -1 ? 1 : (cnts[r[0]] == 0 ? -1 : 0);\\n        ++cnts[r[1]];\\n        unbalanced += cnts[r[1]] == 1 ? 1 : (cnts[r[1]] == 0 ? -1 : 0);\\n        max = Math.max(max, dfs(cnts, unbalanced, cur + 1, requests, cnt + 1));\\n        --cnts[r[1]];\\n        ++cnts[r[0]];\\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int maximumRequests(int n, int[][] requests) {\\n        return dfs(new int[n], 0, 0, requests, 0);\\n    }\\n\\n    private int dfs(int[] cnts, int unbalanced, int cur, int[][] requests, int cnt) {\\n        if (cur >= requests.length) {\\n            return unbalanced == 0 ? cnt : 0;\\n        }\\n        int max = 0;\\n        max = Math.max(max, dfs(cnts, unbalanced, cur + 1, requests, cnt));\\n        int[] r = requests[cur];\\n        --cnts[r[0]];\\n        unbalanced += cnts[r[0]] == -1 ? 1 : (cnts[r[0]] == 0 ? -1 : 0);\\n        ++cnts[r[1]];\\n        unbalanced += cnts[r[1]] == 1 ? 1 : (cnts[r[1]] == 0 ? -1 : 0);\\n        max = Math.max(max, dfs(cnts, unbalanced, cur + 1, requests, cnt + 1));\\n        --cnts[r[1]];\\n        ++cnts[r[0]];\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 874662,
                "title": "straight-brute-force-with-help-of-bit-masks-c-should-be-under-medium-category",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    int maximumRequests(int n, vector<vector<int>>& requests) {\\n        int alpha = requests.size();\\n        int ans = 0;\\n        for(int i = 1; i < (1 << alpha); ++i) {\\n            vector<int> move(n);\\n            for(int j = 0; j <= 15; ++j) {\\n                if((1 << j) & i) {\\n                    move[requests[j][0]]++;\\n                    move[requests[j][1]]--;\\n                }\\n            }\\n            int f = 1;\\n            for(int x : move) {\\n               if(x != 0 ){\\n                  f = 0;\\n                  break;\\n               }\\n            }\\n            if(f) {\\n                ans = max(ans, __builtin_popcount(i));\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int maximumRequests(int n, vector<vector<int>>& requests) {\\n        int alpha = requests.size();\\n        int ans = 0;\\n        for(int i = 1; i < (1 << alpha); ++i) {\\n            vector<int> move(n);\\n            for(int j = 0; j <= 15; ++j) {\\n                if((1 << j) & i) {\\n                    move[requests[j][0]]++;\\n                    move[requests[j][1]]--;\\n                }\\n            }\\n            int f = 1;\\n            for(int x : move) {\\n               if(x != 0 ){\\n                  f = 0;\\n                  break;\\n               }\\n            }\\n            if(f) {\\n                ans = max(ans, __builtin_popcount(i));\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 868947,
                "title": "javascript-bitmasking-backtracking-solutions",
                "content": "Listed from most to least performant\\n\\nBacktracking w/ array:\\n```\\nconst maximumRequests = ( n, requests ) => {\\n    const transfers = Array(n).fill(0)\\n    let max = 0\\n    \\n    const search = ( i, count ) => {\\n        if ( i === requests.length ) {\\n            if ( count > max && ! transfers.some( x => x ) )\\n                max = count\\n            return\\n        }\\n\\n        transfers[ requests[i][0] ]--\\n        transfers[ requests[i][1] ]++\\n        search( i + 1, count + 1 )\\n        transfers[ requests[i][0] ]++\\n        transfers[ requests[i][1] ]--\\n        \\n        search( i + 1, count )\\n        \\n    }\\n    \\n    search( 0, 0 )\\n    \\n    return max\\n}\\n```\\n\\nBacktracking without array. Though there were so many companies I had to use BigInt, which impacts performance\\n```\\nconst maximumRequests = ( n, req ) => search( req, 0, BigInt(0), 0 )\\n\\nconst search = ( req, i, t, count ) => \\n    i === req.length\\n    ? 0 == t ? count : 0\\n    : Math.max(\\n        search( req, i + 1, t, count ),\\n        search( req, i + 1, t + c( req[i][0] ) - c( req[i][1] ), count + 1 )\\n    )\\n\\nconst c = x => BigInt( 16 ** x )\\n```\\n\\nBitmask DP:\\n```\\nconst maximumRequests = ( n, requests ) => {\\n    let max = 0\\n    let prev = new Map([[ 0, Array(n).fill(0) ]])\\n\\n    // count represents the number of requests considered\\n    for ( let count = 1; count <= requests.length; count++ ) {\\n        let next = new Map()\\n\\n        for ( let i = 0; i < requests.length; i++ ) {\\n            prev.forEach( ( transfers, mask ) => {\\n\\t\\t\\t\\n                // dont count a request twice\\n                if ( mask & ( 1 << i ) ) return\\n                \\n                // dont redo work which we\\'ve already solved\\n                if ( next.has( mask |= 1 << i ) ) return\\n                \\n                // clone transfers so as to not invalidate other queries with this `count`\\n                transfers = [...transfers]\\n                transfers[requests[ i ][0]]--\\n                transfers[requests[ i ][1]]++\\n\\n                // if all buildings have net transfer of 0, this is valid\\n                if ( ! transfers.some( x => x ) )\\n                    max = count\\n                \\n                next.set( mask, transfers )\\n\\t\\t\\t\\t\\n            })\\n        }\\n    \\n        prev = next\\n    }\\n\\n    return max\\n}\\n```\\n",
                "solutionTags": [
                    "JavaScript",
                    "Dynamic Programming",
                    "Backtracking",
                    "Bitmask"
                ],
                "code": "```\\nconst maximumRequests = ( n, requests ) => {\\n    const transfers = Array(n).fill(0)\\n    let max = 0\\n    \\n    const search = ( i, count ) => {\\n        if ( i === requests.length ) {\\n            if ( count > max && ! transfers.some( x => x ) )\\n                max = count\\n            return\\n        }\\n\\n        transfers[ requests[i][0] ]--\\n        transfers[ requests[i][1] ]++\\n        search( i + 1, count + 1 )\\n        transfers[ requests[i][0] ]++\\n        transfers[ requests[i][1] ]--\\n        \\n        search( i + 1, count )\\n        \\n    }\\n    \\n    search( 0, 0 )\\n    \\n    return max\\n}\\n```\n```\\nconst maximumRequests = ( n, req ) => search( req, 0, BigInt(0), 0 )\\n\\nconst search = ( req, i, t, count ) => \\n    i === req.length\\n    ? 0 == t ? count : 0\\n    : Math.max(\\n        search( req, i + 1, t, count ),\\n        search( req, i + 1, t + c( req[i][0] ) - c( req[i][1] ), count + 1 )\\n    )\\n\\nconst c = x => BigInt( 16 ** x )\\n```\n```\\nconst maximumRequests = ( n, requests ) => {\\n    let max = 0\\n    let prev = new Map([[ 0, Array(n).fill(0) ]])\\n\\n    // count represents the number of requests considered\\n    for ( let count = 1; count <= requests.length; count++ ) {\\n        let next = new Map()\\n\\n        for ( let i = 0; i < requests.length; i++ ) {\\n            prev.forEach( ( transfers, mask ) => {\\n\\t\\t\\t\\n                // dont count a request twice\\n                if ( mask & ( 1 << i ) ) return\\n                \\n                // dont redo work which we\\'ve already solved\\n                if ( next.has( mask |= 1 << i ) ) return\\n                \\n                // clone transfers so as to not invalidate other queries with this `count`\\n                transfers = [...transfers]\\n                transfers[requests[ i ][0]]--\\n                transfers[requests[ i ][1]]++\\n\\n                // if all buildings have net transfer of 0, this is valid\\n                if ( ! transfers.some( x => x ) )\\n                    max = count\\n                \\n                next.set( mask, transfers )\\n\\t\\t\\t\\t\\n            })\\n        }\\n    \\n        prev = next\\n    }\\n\\n    return max\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 867975,
                "title": "c-dfs-88ms-9mb-beats-100-100",
                "content": "Many solutions were using masking. Although the idea of masking seems more exquisite, using dfs is easier to understand and even more efficient here. We simply traverse all combination of requests and return the maximum possible answer. The only thing we need to make clear is the criterion of an eligible solution: employees moving in/out each building are equal.\\n```\\nclass Solution {\\npublic:\\n    int ans = 0;\\n    int sz,n;\\n    \\n    int maximumRequests(int n, vector<vector<int>>& req) {\\n        this->sz = req.size();\\n        this->n = n;\\n        int degs[n];  // use vector could be easier, but it introduces extra overhead\\n        memset(degs,0,sizeof(degs));\\n        \\n        // try the permutation of fulfilling each request with brute force\\n        dfs(req,degs,0,0);\\n        return ans;\\n    }\\n    \\n    void dfs(vector<vector<int>>& req, int* degs, int idx, int cnt) {\\n        // when reach end of requests, exit recursion\\n        if (sz == idx) {\\n            for (int i=0; i<n; ++i)\\n                if (degs[i]!=0)\\n                    return;\\n            ans = max(ans,cnt);\\n            return;\\n        }\\n        \\n        // try to fulfill current request\\n        --degs[req[idx][0]];\\n        ++degs[req[idx][1]];\\n        dfs(req,degs,idx+1,cnt+1);\\n        ++degs[req[idx][0]];\\n        --degs[req[idx][1]];\\n        \\n        // ignore current request\\n        dfs(req,degs,idx+1,cnt);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int ans = 0;\\n    int sz,n;\\n    \\n    int maximumRequests(int n, vector<vector<int>>& req) {\\n        this->sz = req.size();\\n        this->n = n;\\n        int degs[n];  // use vector could be easier, but it introduces extra overhead\\n        memset(degs,0,sizeof(degs));\\n        \\n        // try the permutation of fulfilling each request with brute force\\n        dfs(req,degs,0,0);\\n        return ans;\\n    }\\n    \\n    void dfs(vector<vector<int>>& req, int* degs, int idx, int cnt) {\\n        // when reach end of requests, exit recursion\\n        if (sz == idx) {\\n            for (int i=0; i<n; ++i)\\n                if (degs[i]!=0)\\n                    return;\\n            ans = max(ans,cnt);\\n            return;\\n        }\\n        \\n        // try to fulfill current request\\n        --degs[req[idx][0]];\\n        ++degs[req[idx][1]];\\n        dfs(req,degs,idx+1,cnt+1);\\n        ++degs[req[idx][0]];\\n        --degs[req[idx][1]];\\n        \\n        // ignore current request\\n        dfs(req,degs,idx+1,cnt);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 867528,
                "title": "python-dp-bit-mask",
                "content": "Use bit mask to represent which requests are used.\\n\\nDefinition of dp:\\ndp[k]: The status of buildings with bitMask k\\n\\nExplanation:\\nAs we know we can get the lowest bit by using `lowest_bit = n&(n-1)` (Same concept in BIT) \\nWe can also know which request contributes this bit by `log2(lowest_bit)`\\nTherefore, we can update the status with the request we derive from the lowest_bit.\\n\\nTime complexity: O((n+m)* 2^m)\\nSpace complexity: O(n* 2^m)\\nFrom the time complexity, we can see that dp doesn\\'t help too much with time complexity for this question, but it still intestesting to do in this way.\\n\\nSimilar idea comes from 338. Counting-bits(https://leetcode.com/problems/counting-bits/).\\n\\n```\\n    def maximumRequests(self, n: int, requests: List[List[int]]) -> int:\\n        m = len(requests)\\n        dp = [[] for _ in range(1<<m)]\\n        dp[0] = [0]*n\\n        ans = 0\\n        for k in range(1, 1<<m):\\n            lowest_bit = k&-k\\n            index = int(math.log(lowest, 2))\\n            newMask = list(dp[k-lowest_bit])\\n            newMask[requests[index][0]] -= 1\\n            newMask[requests[index][1]] += 1\\n            dp[k] = newMask\\n            if min(dp[k]) == max(dp[k]) == 0:\\n                ans = max(ans, bin(k).count(\\'1\\'))\\n        return ans\\n```",
                "solutionTags": [],
                "code": "```\\n    def maximumRequests(self, n: int, requests: List[List[int]]) -> int:\\n        m = len(requests)\\n        dp = [[] for _ in range(1<<m)]\\n        dp[0] = [0]*n\\n        ans = 0\\n        for k in range(1, 1<<m):\\n            lowest_bit = k&-k\\n            index = int(math.log(lowest, 2))\\n            newMask = list(dp[k-lowest_bit])\\n            newMask[requests[index][0]] -= 1\\n            newMask[requests[index][1]] += 1\\n            dp[k] = newMask\\n            if min(dp[k]) == max(dp[k]) == 0:\\n                ans = max(ans, bin(k).count(\\'1\\'))\\n        return ans\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 866951,
                "title": "java-easy-bit-mask",
                "content": "1. Simple dfs backtrack approach would be to iterate over all the requests and perform the following two operations for each of the requests:\\n\\t1. Consider this request.\\n\\t2. Do not consider this request.\\n2. If we cosider a request, we have to decrease employee count by 1 in source building and increase it by 1 in destination building.\\n3. When we are done with all the iterations we can check if all builidings have 0 employee count (no extra employee and no less number of employees than before), If so, count all the requests that we considered and update the answer.\\n4. Now, it may happen that we are repeatedly operating at a state where all the previously considered requests are same and curr Request  (we are iterating at) is same too.\\n5. So, it\\'s better to store these 2 parameters in dp.\\n6. to store previous requests, use bitmask as : \\n\\tIf we are considering curr request (i.e., index in requests array is *curr*)  \\n\\t```mask = mask | (1 << curr) ```\\n7. at the end, when we have traversed all the requests, check if building population condition satisfies, if so, count the number of 1 bits in our mask.\\n```\\nclass Solution {\\n    int[] buildingPopulation;\\n    Integer[][] dp;\\n    public int maximumRequests(int n, int[][] requests) {\\n        buildingPopulation = new int[n];\\n        dp = new Integer[1 << requests.length][requests.length+1];\\n        return helper(0, 0, requests);\\n    }\\n    public int helper(int mask, int curr, int[][] requests) {\\n        if(dp[mask][curr] != null)  return dp[mask][curr];\\n        if(curr == requests.length) {\\n            for(int x : buildingPopulation) {\\n                if(x != 0)  return dp[mask][curr] = 0;\\n            }\\n            return dp[mask][curr] = count(mask);\\n        }\\n        int max = 0;\\n        buildingPopulation[requests[curr][0]]--;\\n        buildingPopulation[requests[curr][1]]++;\\n        max = Math.max(max, helper(mask | (1<<curr), curr+1, requests) );\\n        buildingPopulation[requests[curr][0]]++;\\n        buildingPopulation[requests[curr][1]]--;\\n        max = Math.max(max, helper(mask, curr+1, requests));\\n        return dp[mask][curr] = max;\\n    }\\n    public int count(int mask) {\\n        int res = 0;\\n        while(mask != 0) {\\n            if((mask & 1) != 0)   res++;\\n            mask /= 2;\\n        }\\n        return res;\\n    }\\n}\\n```\\nfor M = requests.length\\nTime Complexity : O( M * 2^M  )\\nSpace Complexity : O( M * 2^M )",
                "solutionTags": [
                    "Java",
                    "Bitmask"
                ],
                "code": "```mask = mask | (1 << curr) ```\n```\\nclass Solution {\\n    int[] buildingPopulation;\\n    Integer[][] dp;\\n    public int maximumRequests(int n, int[][] requests) {\\n        buildingPopulation = new int[n];\\n        dp = new Integer[1 << requests.length][requests.length+1];\\n        return helper(0, 0, requests);\\n    }\\n    public int helper(int mask, int curr, int[][] requests) {\\n        if(dp[mask][curr] != null)  return dp[mask][curr];\\n        if(curr == requests.length) {\\n            for(int x : buildingPopulation) {\\n                if(x != 0)  return dp[mask][curr] = 0;\\n            }\\n            return dp[mask][curr] = count(mask);\\n        }\\n        int max = 0;\\n        buildingPopulation[requests[curr][0]]--;\\n        buildingPopulation[requests[curr][1]]++;\\n        max = Math.max(max, helper(mask | (1<<curr), curr+1, requests) );\\n        buildingPopulation[requests[curr][0]]++;\\n        buildingPopulation[requests[curr][1]]--;\\n        max = Math.max(max, helper(mask, curr+1, requests));\\n        return dp[mask][curr] = max;\\n    }\\n    public int count(int mask) {\\n        int res = 0;\\n        while(mask != 0) {\\n            if((mask & 1) != 0)   res++;\\n            mask /= 2;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 866679,
                "title": "python-dfs-brute-force-100-ms",
                "content": "Bruete force: pick or ignore for every request \\n\\nTwo conditions to make it faster\\n1. if requests[i][0] == request[i][1] : always pick\\n2. if we can\\'t make count[ request[i][0] ] , count[ request[i][1] ] go back to  0 , stop DFS\\n```\\ndef maximumRequests(self, n: int, requests: List[List[int]]) -> int:\\n        count = [0] * n\\n        Requests = []\\n        trivial = 0\\n        for a,b in requests:\\n            if a == b:\\n                trivial += 1\\n            else:\\n                Requests.append([a,b])\\n        m = len(Requests)\\n        self.res = 0\\n        \\n        def DFS(i,r):\\n            if i == m:\\n                if all(count[i] == 0 for i in range(n)):\\n                    self.res = max(self.res,r)\\n            else:\\n                DFS(i+1,r)\\n                \\n                valid = 1\\n                \\n                count[Requests[i][0]]+= 1\\n                count[Requests[i][1]]-= 1\\n                if count[Requests[i][0]] > 0 :\\n                    if sum( 1 * (Requests[i][0]==Requests[j][1]) for j in range(i+1,m)) < count[Requests[i][0]] :\\n                        valid = 0\\n                    \\n                if valid and count[Requests[i][1]] < 0 :\\n                    if sum( 1 * (Requests[i][1]==Requests[j][0]) for j in range(i+1,m)) < -count[Requests[i][1]] :\\n                        valid = 0\\n                if valid:\\n                    DFS(i+1,r+1)\\n                count[Requests[i][0]]-= 1\\n                count[Requests[i][1]]+= 1\\n                \\n        DFS(0,trivial)\\n        return self.res\\n",
                "solutionTags": [],
                "code": "Bruete force: pick or ignore for every request \\n\\nTwo conditions to make it faster\\n1. if requests[i][0] == request[i][1] : always pick\\n2. if we can\\'t make count[ request[i][0] ] , count[ request[i][1] ] go back to  0 , stop DFS\\n```\\ndef maximumRequests(self, n: int, requests: List[List[int]]) -> int:\\n        count = [0] * n\\n        Requests = []\\n        trivial = 0\\n        for a,b in requests:\\n            if a == b:\\n                trivial += 1\\n            else:\\n                Requests.append([a,b])\\n        m = len(Requests)\\n        self.res = 0\\n        \\n        def DFS(i,r):\\n            if i == m:\\n                if all(count[i] == 0 for i in range(n)):\\n                    self.res = max(self.res,r)\\n            else:\\n                DFS(i+1,r)\\n                \\n                valid = 1\\n                \\n                count[Requests[i][0]]+= 1\\n                count[Requests[i][1]]-= 1\\n                if count[Requests[i][0]] > 0 :\\n                    if sum( 1 * (Requests[i][0]==Requests[j][1]) for j in range(i+1,m)) < count[Requests[i][0]] :\\n                        valid = 0\\n                    \\n                if valid and count[Requests[i][1]] < 0 :\\n                    if sum( 1 * (Requests[i][1]==Requests[j][0]) for j in range(i+1,m)) < -count[Requests[i][1]] :\\n                        valid = 0\\n                if valid:\\n                    DFS(i+1,r+1)\\n                count[Requests[i][0]]-= 1\\n                count[Requests[i][1]]+= 1\\n                \\n        DFS(0,trivial)\\n        return self.res\\n",
                "codeTag": "Python3"
            },
            {
                "id": 866627,
                "title": "java-clean-dfs-bitmask",
                "content": "We can use two way to solve this problem, one way is similar to 78. Subsets. Another way is using bitmask.\\n\\n```\\n    //bitMask\\n\\t//ith bit of the interger value of \"remove\" will represent whether we want to pick the edge[i].\\nafter we pick some edges, we check if there is a circle.\\n\\n    public int maximumRequests(int n, int[][] requests) {\\n        int res = 0;\\n        for (int remove = 0; remove < (1 << requests.length); remove++)\\n            if (findCircle(remove, n, requests))\\n                res = Math.max(res, Integer.bitCount(remove));\\n        return res;\\n    }\\n    \\n    private boolean findCircle(int remove, int n, int[][] requests) {\\n        int[] indegree = new int[n];\\n        for (int i = 0; i < requests.length; i++)\\n            if (((remove >> i) & 1) == 1) {\\n                indegree[requests[i][0]]--;\\n                indegree[requests[i][1]]++;\\n            }\\n        for (int value : indegree) if (value != 0) return false;\\n        return true;\\n    }\\n    \\n    //backtracking dfs\\n    int res;\\n    public int maximumRequests(int n, int[][] requests) {\\n        dfs(0, requests, new int[n], 0);\\n        return res;\\n    }\\n    \\n    private void dfs(int index, int[][] requests, int[] indegree, int count) {\\n        if (findCircle(indegree)) res = Math.max(res, count);\\n        for (int i = index; i < requests.length; i++) {\\n            indegree[requests[i][0]]--;\\n            indegree[requests[i][1]]++;\\n            dfs(i + 1, requests, indegree, count + 1);\\n            indegree[requests[i][0]]++;\\n            indegree[requests[i][1]]--;\\n        }\\n    }\\n    \\n    private boolean findCircle(int[] indegree) {\\n        for (int value : indegree) if (value != 0) return false;\\n        return true;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    //bitMask\\n\\t//ith bit of the interger value of \"remove\" will represent whether we want to pick the edge[i].\\nafter we pick some edges, we check if there is a circle.\\n\\n    public int maximumRequests(int n, int[][] requests) {\\n        int res = 0;\\n        for (int remove = 0; remove < (1 << requests.length); remove++)\\n            if (findCircle(remove, n, requests))\\n                res = Math.max(res, Integer.bitCount(remove));\\n        return res;\\n    }\\n    \\n    private boolean findCircle(int remove, int n, int[][] requests) {\\n        int[] indegree = new int[n];\\n        for (int i = 0; i < requests.length; i++)\\n            if (((remove >> i) & 1) == 1) {\\n                indegree[requests[i][0]]--;\\n                indegree[requests[i][1]]++;\\n            }\\n        for (int value : indegree) if (value != 0) return false;\\n        return true;\\n    }\\n    \\n    //backtracking dfs\\n    int res;\\n    public int maximumRequests(int n, int[][] requests) {\\n        dfs(0, requests, new int[n], 0);\\n        return res;\\n    }\\n    \\n    private void dfs(int index, int[][] requests, int[] indegree, int count) {\\n        if (findCircle(indegree)) res = Math.max(res, count);\\n        for (int i = index; i < requests.length; i++) {\\n            indegree[requests[i][0]]--;\\n            indegree[requests[i][1]]++;\\n            dfs(i + 1, requests, indegree, count + 1);\\n            indegree[requests[i][0]]++;\\n            indegree[requests[i][1]]--;\\n        }\\n    }\\n    \\n    private boolean findCircle(int[] indegree) {\\n        for (int value : indegree) if (value != 0) return false;\\n        return true;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 866553,
                "title": "python-3-solution-simple-backtracking",
                "content": "\\'\\'\\'\\nclass Solution:\\n    def maximumRequests(self, n: int, requests: List[List[int]]) -> int:\\n        \\n        def rec(index,arr,cnt):\\n            ans=0\\n            if all([ele==0 for ele in arr]):\\n                ans=max(ans,cnt)\\n            if index<len(requests):\\n                q=[ele for ele in arr]\\n                q[requests[index][0]]-=1\\n                q[requests[index][1]]+=1\\n                ans=max(ans,rec(index+1,q,cnt+1),rec(index+1,arr,cnt))            \\n            return ans\\n                \\n        return rec(0,[0]*n,0)\\n\\n\\'\\'\\'",
                "solutionTags": [],
                "code": "\\'\\'\\'\\nclass Solution:\\n    def maximumRequests(self, n: int, requests: List[List[int]]) -> int:\\n        \\n        def rec(index,arr,cnt):\\n            ans=0\\n            if all([ele==0 for ele in arr]):\\n                ans=max(ans,cnt)\\n            if index<len(requests):\\n                q=[ele for ele in arr]\\n                q[requests[index][0]]-=1\\n                q[requests[index][1]]+=1\\n                ans=max(ans,rec(index+1,q,cnt+1),rec(index+1,arr,cnt))            \\n            return ans\\n                \\n        return rec(0,[0]*n,0)\\n\\n\\'\\'\\'",
                "codeTag": "Java"
            },
            {
                "id": 866546,
                "title": "java-brute-force-check-all-combinations-o-n-r-2-r",
                "content": "Intuition:\\n    Each building needs to have the same amount of incoming and leaving people.\\n    Some buildings may not qualify, we need to exclude some of the requests.\\n    \\nAlgorithm:\\n* Try every subset(every combination),\\n  * if all buildings qualify\\n    * count max people who can relocate\\n\\n```java\\npublic int maximumRequests(int n, int[][] requests) {\\n\\t// number of all combinations or the requests\\n\\tint lim = 1 << requests.length;\\n\\tint max = 0;\\n\\tfor (int i = 0; i < lim; i++) {\\n\\t\\tmax = Math.max(max, check(n, requests, i));\\n\\t}\\n\\n\\treturn max;\\n}\\n\\nprivate int check(int n, int[][] requests, int banned) {\\n\\t// 0 - in, 1 - out\\n\\tint[][] count = new int[n][2];\\n\\n\\tfor (int i = 0; i < requests.length; i++) {\\n\\t\\tif ((banned & (1 << i)) == 0) {\\n\\t\\t\\t// number of incoming number of people\\n\\t\\t\\tcount[requests[i][0]][1]++;\\n\\t\\t\\t// number of leaving number of people\\n\\t\\t\\tcount[requests[i][1]][0]++;\\n\\t\\t}\\n\\t}\\n\\n\\tint sum = 0;\\n\\tfor (int i = 0; i < count.length; i++) {\\n\\t\\tif (count[i][0] != count[i][1]) {\\n\\t\\t\\t// building does not qualify\\n\\t\\t\\treturn 0;\\n\\t\\t}\\n\\t\\tsum += count[i][0];\\n\\t}\\n\\treturn sum;\\n}\\n```",
                "solutionTags": [],
                "code": "```java\\npublic int maximumRequests(int n, int[][] requests) {\\n\\t// number of all combinations or the requests\\n\\tint lim = 1 << requests.length;\\n\\tint max = 0;\\n\\tfor (int i = 0; i < lim; i++) {\\n\\t\\tmax = Math.max(max, check(n, requests, i));\\n\\t}\\n\\n\\treturn max;\\n}\\n\\nprivate int check(int n, int[][] requests, int banned) {\\n\\t// 0 - in, 1 - out\\n\\tint[][] count = new int[n][2];\\n\\n\\tfor (int i = 0; i < requests.length; i++) {\\n\\t\\tif ((banned & (1 << i)) == 0) {\\n\\t\\t\\t// number of incoming number of people\\n\\t\\t\\tcount[requests[i][0]][1]++;\\n\\t\\t\\t// number of leaving number of people\\n\\t\\t\\tcount[requests[i][1]][0]++;\\n\\t\\t}\\n\\t}\\n\\n\\tint sum = 0;\\n\\tfor (int i = 0; i < count.length; i++) {\\n\\t\\tif (count[i][0] != count[i][1]) {\\n\\t\\t\\t// building does not qualify\\n\\t\\t\\treturn 0;\\n\\t\\t}\\n\\t\\tsum += count[i][0];\\n\\t}\\n\\treturn sum;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 866481,
                "title": "java-simple-dfs",
                "content": "Try all combinations.\\nThere will be at most 2^16 situation\\n\\n```java\\nclass Solution {\\n    int[] cnt;\\n    int res = 0;\\n    public int maximumRequests(int n, int[][] requests) {\\n        cnt = new int[n];\\n        dfs(0, requests, 0);\\n        return res;\\n    }\\n    private void dfs(int curIdx, int[][] requests, int handled) {\\n        if(curIdx == requests.length) {\\n\\t\\t\\tif(res > handled) return ;\\n            for(int i = 0; i < cnt.length; i++) if(cnt[i] != 0) return ;\\n            \\n            res = Math.max(res, handled);\\n            return ;\\n        }\\n        \\n        // handle\\n        cnt[requests[curIdx][0]]--;\\n        cnt[requests[curIdx][1]]++;\\n        dfs(curIdx + 1, requests, handled + 1);\\n        cnt[requests[curIdx][0]]++;\\n        cnt[requests[curIdx][1]]--;\\n\\n        dfs(curIdx + 1, requests, handled);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```java\\nclass Solution {\\n    int[] cnt;\\n    int res = 0;\\n    public int maximumRequests(int n, int[][] requests) {\\n        cnt = new int[n];\\n        dfs(0, requests, 0);\\n        return res;\\n    }\\n    private void dfs(int curIdx, int[][] requests, int handled) {\\n        if(curIdx == requests.length) {\\n\\t\\t\\tif(res > handled) return ;\\n            for(int i = 0; i < cnt.length; i++) if(cnt[i] != 0) return ;\\n            \\n            res = Math.max(res, handled);\\n            return ;\\n        }\\n        \\n        // handle\\n        cnt[requests[curIdx][0]]--;\\n        cnt[requests[curIdx][1]]++;\\n        dfs(curIdx + 1, requests, handled + 1);\\n        cnt[requests[curIdx][0]]++;\\n        cnt[requests[curIdx][1]]--;\\n\\n        dfs(curIdx + 1, requests, handled);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 866451,
                "title": "why-my-code-is-giving-tle-i-used-simple-brute-force",
                "content": "```\\nclass Solution {\\npublic:\\n    int maximumRequests(int n, vector<vector<int>>& requests) {\\n        \\n        int req=requests.size();\\n        int ans=0;\\n        for(int i=0;i<(1<<req);i++){\\n            vector<vector<int>> vec;\\n            for(int j=0;j<req;j++){\\n                if((1<<j)&i){\\n                    vec.push_back(requests[j]);\\n                }\\n            }\\n            \\n            vector<int> mp1(n);\\n            vector<int> mp2(n);\\n            for(int i=0;i<vec.size();i++){\\n                mp1[vec[i][0]]++;\\n                mp2[vec[i][1]]++;\\n            }\\n            bool t=1;\\n            for(int i=0;i<mp1.size();i++){\\n                if(mp1[i]!=mp2[i]) {t=0;break;}\\n            }\\n            if(t==1) ans=max(ans,(int)vec.size());\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumRequests(int n, vector<vector<int>>& requests) {\\n        \\n        int req=requests.size();\\n        int ans=0;\\n        for(int i=0;i<(1<<req);i++){\\n            vector<vector<int>> vec;\\n            for(int j=0;j<req;j++){\\n                if((1<<j)&i){\\n                    vec.push_back(requests[j]);\\n                }\\n            }\\n            \\n            vector<int> mp1(n);\\n            vector<int> mp2(n);\\n            for(int i=0;i<vec.size();i++){\\n                mp1[vec[i][0]]++;\\n                mp2[vec[i][1]]++;\\n            }\\n            bool t=1;\\n            for(int i=0;i<mp1.size();i++){\\n                if(mp1[i]!=mp2[i]) {t=0;break;}\\n            }\\n            if(t==1) ans=max(ans,(int)vec.size());\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 866392,
                "title": "backtracking-and-degrees-java",
                "content": "```\\nclass Solution {\\n    int ans = 0;\\n    public int maximumRequests(int n, int[][] req) {\\n        bt(n, 0, req, new ArrayList<>());\\n        return ans;\\n    }\\n    \\n    void bt(int n, int idx, int[][] req, List<int[]> cur) {\\n        if (idx == req.length) {\\n            int[] deg = new int[n];\\n            for (int[] r : cur) {\\n                deg[r[0]]--;\\n                deg[r[1]]++;\\n            }\\n            for (int i = 0; i < n; i++) {\\n                if (deg[i] != 0) {\\n                    return;\\n                }\\n            }\\n            ans = Math.max(ans, cur.size());\\n            return;\\n        }\\n        cur.add(req[idx]);\\n        bt(n, idx + 1, req, cur);\\n        cur.remove(cur.size() - 1);\\n        bt(n, idx + 1, req, cur);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    int ans = 0;\\n    public int maximumRequests(int n, int[][] req) {\\n        bt(n, 0, req, new ArrayList<>());\\n        return ans;\\n    }\\n    \\n    void bt(int n, int idx, int[][] req, List<int[]> cur) {\\n        if (idx == req.length) {\\n            int[] deg = new int[n];\\n            for (int[] r : cur) {\\n                deg[r[0]]--;\\n                deg[r[1]]++;\\n            }\\n            for (int i = 0; i < n; i++) {\\n                if (deg[i] != 0) {\\n                    return;\\n                }\\n            }\\n            ans = Math.max(ans, cur.size());\\n            return;\\n        }\\n        cur.add(req[idx]);\\n        bt(n, idx + 1, req, cur);\\n        cur.remove(cur.size() - 1);\\n        bt(n, idx + 1, req, cur);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 866389,
                "title": "python-simple-queue-annotated",
                "content": "```python\\ndef maximumRequests(self, n: int, requests: List[List[int]]) -> int:\\n\\t\\n\\t# Optimization: Remove all same building requests ([0, 0], [1, 1], ...), these requests are always granted\\n\\ttransfers = 0\\n\\ttemp = []\\n\\tfor a,b in requests:\\n\\t\\tif a == b:\\n\\t\\t\\ttransfers += 1\\n\\t\\telse:\\n\\t\\t\\ttemp.append((a,b))\\n\\trequests = temp\\n\\t\\n\\t\\n\\t# (i) current request, (status) list of buildings and their +/- status, (granted) how many requests were granted\\n\\tq = collections.deque([(0, [0]*n, 0)])\\n\\tvisited = set()\\n\\tbest = 0\\n\\t\\n\\twhile q:\\n\\t\\t\\n\\t\\ti, status, granted = q.popleft()\\n\\t\\t\\n\\t\\tif i == len(requests):\\n\\t\\t\\tif all(building == 0 for building in status): # status[i] = 0 means an equal number of people left and entered building i\\n\\t\\t\\t\\tbest = max(best, granted)\\n\\t\\t\\tcontinue\\n\\t\\t\\n\\t\\t# deny request\\n\\t\\tq.append((i+1, status, granted))\\n\\t\\n\\t\\t# accept request\\n\\t\\ta,b = requests[i]\\n\\t\\tnew_status = status[:]\\n\\t\\tnew_status[a] -= 1 # denotes 1 person left building a\\n\\t\\tnew_status[b] += 1 # denotes 1 person entered building b\\n\\t\\tq.append((i+1, new_status, granted + 1))\\n\\t\\n\\treturn transfers + best   \\n```",
                "solutionTags": [],
                "code": "```python\\ndef maximumRequests(self, n: int, requests: List[List[int]]) -> int:\\n\\t\\n\\t# Optimization: Remove all same building requests ([0, 0], [1, 1], ...), these requests are always granted\\n\\ttransfers = 0\\n\\ttemp = []\\n\\tfor a,b in requests:\\n\\t\\tif a == b:\\n\\t\\t\\ttransfers += 1\\n\\t\\telse:\\n\\t\\t\\ttemp.append((a,b))\\n\\trequests = temp\\n\\t\\n\\t\\n\\t# (i) current request, (status) list of buildings and their +/- status, (granted) how many requests were granted\\n\\tq = collections.deque([(0, [0]*n, 0)])\\n\\tvisited = set()\\n\\tbest = 0\\n\\t\\n\\twhile q:\\n\\t\\t\\n\\t\\ti, status, granted = q.popleft()\\n\\t\\t\\n\\t\\tif i == len(requests):\\n\\t\\t\\tif all(building == 0 for building in status): # status[i] = 0 means an equal number of people left and entered building i\\n\\t\\t\\t\\tbest = max(best, granted)\\n\\t\\t\\tcontinue\\n\\t\\t\\n\\t\\t# deny request\\n\\t\\tq.append((i+1, status, granted))\\n\\t\\n\\t\\t# accept request\\n\\t\\ta,b = requests[i]\\n\\t\\tnew_status = status[:]\\n\\t\\tnew_status[a] -= 1 # denotes 1 person left building a\\n\\t\\tnew_status[b] += 1 # denotes 1 person entered building b\\n\\t\\tq.append((i+1, new_status, granted + 1))\\n\\t\\n\\treturn transfers + best   \\n```",
                "codeTag": "Python3"
            },
            {
                "id": 866380,
                "title": "c-check-all-combination-of-requests",
                "content": "```csharp\\npublic int MaximumRequests(int n, int[][] requests)\\n{\\n\\tint length = 1 << requests.Length;\\n\\tint maxRequests = 0;\\n\\n\\tfor (int i = 1; i <= length; i++)\\n\\t{\\n\\t\\tint[] vacancy = new int[n];\\n\\t\\tint count = 0;\\n\\n\\t\\tfor (int j = 0; j < requests.Length; j++)\\n\\t\\t{\\n\\t\\t\\tif ((i & (1 << j)) != 0)\\n\\t\\t\\t{\\n\\t\\t\\t\\tvacancy[requests[j][0]]++;\\n\\t\\t\\t\\tvacancy[requests[j][1]]--;\\n\\t\\t\\t\\tcount++;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tbool isValid = true;\\n\\t\\tfor (int j = 0; j < vacancy.Length; j++)\\n\\t\\t{\\n\\t\\t\\tif (vacancy[j] != 0)\\n\\t\\t\\t{\\n\\t\\t\\t\\tisValid = false;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tif (isValid)\\n\\t\\t{\\n\\t\\t\\tmaxRequests = Math.Max(maxRequests, count);\\n\\t\\t}\\n\\t}\\n\\n\\treturn maxRequests;\\n}\\n```",
                "solutionTags": [],
                "code": "```csharp\\npublic int MaximumRequests(int n, int[][] requests)\\n{\\n\\tint length = 1 << requests.Length;\\n\\tint maxRequests = 0;\\n\\n\\tfor (int i = 1; i <= length; i++)\\n\\t{\\n\\t\\tint[] vacancy = new int[n];\\n\\t\\tint count = 0;\\n\\n\\t\\tfor (int j = 0; j < requests.Length; j++)\\n\\t\\t{\\n\\t\\t\\tif ((i & (1 << j)) != 0)\\n\\t\\t\\t{\\n\\t\\t\\t\\tvacancy[requests[j][0]]++;\\n\\t\\t\\t\\tvacancy[requests[j][1]]--;\\n\\t\\t\\t\\tcount++;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tbool isValid = true;\\n\\t\\tfor (int j = 0; j < vacancy.Length; j++)\\n\\t\\t{\\n\\t\\t\\tif (vacancy[j] != 0)\\n\\t\\t\\t{\\n\\t\\t\\t\\tisValid = false;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tif (isValid)\\n\\t\\t{\\n\\t\\t\\tmaxRequests = Math.Max(maxRequests, count);\\n\\t\\t}\\n\\t}\\n\\n\\treturn maxRequests;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4016643,
                "title": "the-fastest-in-dart",
                "content": "\\n# Complexity\\n- Time complexity:\\nO(2^n)\\n- Space complexity:\\nO(n)\\n# Code\\n```\\nclass Solution {\\n  int ans = 0;\\n\\n  void helper(int start, List<List<int>> requests, List<int> indegree, int n, int count) {\\n    if (start == requests.length) {\\n      for (int i = 0; i < n; i++) {\\n        if (indegree[i] != 0) {\\n          return;\\n        }\\n      }\\n      ans = ans > count ? ans : count;\\n      return;\\n    }\\n\\n    // Take\\n    indegree[requests[start][0]]--;\\n    indegree[requests[start][1]]++;\\n    helper(start + 1, requests, indegree, n, count + 1);\\n\\n    // Not-take\\n    indegree[requests[start][0]]++;\\n    indegree[requests[start][1]]--;\\n    helper(start + 1, requests, indegree, n, count);\\n  }\\n\\n  int maximumRequests(int n, List<List<int>> requests) {\\n    List<int> indegree = List.generate(n, (index) => 0);\\n    helper(0, requests, indegree, n, 0);\\n    return ans;\\n  }\\n}\\n\\n```",
                "solutionTags": [
                    "Dart"
                ],
                "code": "```\\nclass Solution {\\n  int ans = 0;\\n\\n  void helper(int start, List<List<int>> requests, List<int> indegree, int n, int count) {\\n    if (start == requests.length) {\\n      for (int i = 0; i < n; i++) {\\n        if (indegree[i] != 0) {\\n          return;\\n        }\\n      }\\n      ans = ans > count ? ans : count;\\n      return;\\n    }\\n\\n    // Take\\n    indegree[requests[start][0]]--;\\n    indegree[requests[start][1]]++;\\n    helper(start + 1, requests, indegree, n, count + 1);\\n\\n    // Not-take\\n    indegree[requests[start][0]]++;\\n    indegree[requests[start][1]]--;\\n    helper(start + 1, requests, indegree, n, count);\\n  }\\n\\n  int maximumRequests(int n, List<List<int>> requests) {\\n    List<int> indegree = List.generate(n, (index) => 0);\\n    helper(0, requests, indegree, n, 0);\\n    return ans;\\n  }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4016503,
                "title": "c-back-track-beginner-friendly",
                "content": "\\n\\n# Intuition:\\n- At each index we have 2 options either to take in consideration or to not take it.\\n\\n# Approach:\\n- The code uses a recursive approach to explore all possible combinations of executing and not executing each request.\\n- It maintains a `result` variable to keep track of the maximum number of requests executed while keeping the resources balanced.\\n\\n**Steps:**\\n1. The `maximumRequests` function initializes the `result` variable to `INT_MIN`, which will keep track of the maximum number of executed requests.\\n\\n2. It initializes a `resultant` vector of size `n`, initially set to all zeros. This vector represents the current state of resources.\\n\\n3. It calls the `solve` function, which is a recursive helper function. The `solve` function takes the following parameters:\\n   - `idx`: The index of the current request being considered.\\n   - `count`: The count of requests executed so far.\\n   - `n`: The number of resources.\\n   - `resultant`: The vector representing the current state of resources.\\n   - `requests`: The vector of request pairs.\\n\\n4. Inside the `solve` function, it checks if `idx` has reached the total number of requests `m`. If all requests have been considered, it checks whether the `resultant` vector contains all zeros. If it does, it updates the `result` variable with the maximum of the current `count` and the existing `result`.\\n\\n5. If `idx` is not equal to `m`, the function proceeds to consider the current request. It temporarily transfers resources from one resource to another by decrementing the resource at the \\'from\\' index and incrementing the resource at the \\'to\\' index. Then, it recursively calls `solve` with the updated parameters to explore the possibility of executing this request.\\n\\n6. After exploring the case where the current request is executed, it reverses the resource transfer (incrementing \\'from\\' and decrementing \\'to\\') and recursively calls `solve` again to explore the case where the current request is not executed.\\n\\n7. Finally, the `maximumRequests` function returns the value stored in the `result` variable, which represents the maximum number of requests that can be executed while keeping the resources balanced.\\n\\nIn summary, this code uses a recursive approach to explore all possible combinations of request execution and keeps track of the maximum number of requests that can be executed while ensuring that the resources remain balanced (sum of resources is zero).\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(2^m * n)\\nFor every index we have 2 possibilities to take or not take\\nso 2^m\\nand every time we are checking that all element are zero \\nso n. \\n- Space complexity:\\n.\\n\\n1. **Recursive Call Stack:** The depth of the recursive call stack depends on the number of requests (`m`) because the `solve` function is called recursively for each request. In the worst case, the depth of the call stack can be `m`. Therefore, the space complexity due to the call stack is O(m).\\n\\n2. **Additional Data Structures:** The code uses additional data structures such as the `resultant` vector, which has a size of `n` (the number of resources). The space complexity for this vector is O(n).\\n\\nCombining both components, the overall space complexity of the code is O(m + n).\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int m;\\n    int result = INT_MIN;\\n    \\n    void solve(int idx, int count, int n, vector<int>& resultant, vector<vector<int>>& requests) {\\n        if(idx == m) {\\n            \\n            int allZero = true;\\n            for(int &x : resultant) {\\n                if(x != 0) {\\n                    allZero = false;\\n                    break;\\n                }\\n            }\\n            \\n            if(allZero) {\\n                result = max(result, count);\\n            }\\n            return;\\n        }\\n        \\n        \\n        int from = requests[idx][0];\\n        int to   = requests[idx][1];\\n        \\n        resultant[from]--;\\n        resultant[to]++;\\n        solve(idx+1, count+1, n, resultant, requests);\\n        \\n        resultant[from]++;\\n        resultant[to]--;\\n        solve(idx+1, count, n, resultant, requests);\\n    }\\n    \\n    int maximumRequests(int n, vector<vector<int>>& requests) {\\n        m = requests.size();\\n        \\n        vector<int> resultant(n, 0);\\n        \\n        solve(0, 0, n, resultant, requests);\\n        \\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int m;\\n    int result = INT_MIN;\\n    \\n    void solve(int idx, int count, int n, vector<int>& resultant, vector<vector<int>>& requests) {\\n        if(idx == m) {\\n            \\n            int allZero = true;\\n            for(int &x : resultant) {\\n                if(x != 0) {\\n                    allZero = false;\\n                    break;\\n                }\\n            }\\n            \\n            if(allZero) {\\n                result = max(result, count);\\n            }\\n            return;\\n        }\\n        \\n        \\n        int from = requests[idx][0];\\n        int to   = requests[idx][1];\\n        \\n        resultant[from]--;\\n        resultant[to]++;\\n        solve(idx+1, count+1, n, resultant, requests);\\n        \\n        resultant[from]++;\\n        resultant[to]--;\\n        solve(idx+1, count, n, resultant, requests);\\n    }\\n    \\n    int maximumRequests(int n, vector<vector<int>>& requests) {\\n        m = requests.size();\\n        \\n        vector<int> resultant(n, 0);\\n        \\n        solve(0, 0, n, resultant, requests);\\n        \\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3920433,
                "title": "python-o-2-m-not-o-n-2-m",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\nThe idea is the same as the others, but $O(2^m)$ instead of $O(n * 2^m)$.\\n\\nNow, given the constrains of the poblem, it doesn\\'t really affect the runtime.\\n\\nNevertheless, this is a good example of how backtracking can be faster than the brute force solution, even without pruning. \\n\\nThe idea behind brute force is to generate all possible solutions, and check them to see if they are a solution: $O(#solutions * timetocheckone)$.\\n\\nBacktracking is a way to generate all the solutions by incremental changes. Occasionally, it is possible to keep track of when you have a solution in constant time during the changes, so you can skip the checking part, which in our case saves us a factor of $n$.\\n\\n# Code\\n```\\nclass Solution:\\n    def maximumRequests(self, n: int, requests: List[List[int]]) -> int:\\n        # backtracking: O(2^m), O(1)\\n    \\n        m = len(requests)\\n\\n        def backtrack(i, r, diff, z):\\n            # invariant:\\n            # z = sum(1 for x in range(n) if diff[x] == 0)\\n            if i == m:\\n                if z == n:\\n                    self.out = max(self.out, r)\\n                return\\n\\n            # exclude request i\\n            backtrack(i+1, r, diff, z)\\n\\n            # include request i\\n            f, t = requests[i]\\n\\n            if diff[f] == 1:\\n                z += 1\\n            elif diff[f] == 0:\\n                z -= 1\\n            diff[f] -= 1\\n\\n            if diff[t] == -1:\\n                z += 1\\n            elif diff[t] == 0:\\n                z -= 1\\n            diff[t] += 1\\n            \\n            backtrack(i+1, r+1, diff, z)\\n\\n            diff[f] += 1\\n            diff[t] -= 1\\n\\n            # don\\'t neet to set z back because z is an int so it is passed by value\\n        \\n        diff = collections.defaultdict(int)\\n        num_zero = n\\n        self.out = 0\\n        backtrack(0, 0, diff, n)\\n        return self.out\\n\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution:\\n    def maximumRequests(self, n: int, requests: List[List[int]]) -> int:\\n        # backtracking: O(2^m), O(1)\\n    \\n        m = len(requests)\\n\\n        def backtrack(i, r, diff, z):\\n            # invariant:\\n            # z = sum(1 for x in range(n) if diff[x] == 0)\\n            if i == m:\\n                if z == n:\\n                    self.out = max(self.out, r)\\n                return\\n\\n            # exclude request i\\n            backtrack(i+1, r, diff, z)\\n\\n            # include request i\\n            f, t = requests[i]\\n\\n            if diff[f] == 1:\\n                z += 1\\n            elif diff[f] == 0:\\n                z -= 1\\n            diff[f] -= 1\\n\\n            if diff[t] == -1:\\n                z += 1\\n            elif diff[t] == 0:\\n                z -= 1\\n            diff[t] += 1\\n            \\n            backtrack(i+1, r+1, diff, z)\\n\\n            diff[f] += 1\\n            diff[t] -= 1\\n\\n            # don\\'t neet to set z back because z is an int so it is passed by value\\n        \\n        diff = collections.defaultdict(int)\\n        num_zero = n\\n        self.out = 0\\n        backtrack(0, 0, diff, n)\\n        return self.out\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3896074,
                "title": "python-bitmasking-solution",
                "content": "```\\nclass Solution:\\n    def maximumRequests(self, n: int, requests: List[List[int]]) -> int:\\n        m = len(requests)\\n        ans = 0\\n        inc_out = [0] * n\\n        for i in range(1, 1 << m):\\n            res = 0\\n            for j in range(0, m):\\n                if i & (1 << j):\\n                    res += 1\\n                    from_ = requests[j][0]\\n                    to_ = requests[j][1]\\n                    inc_out[from_] -= 1\\n                    inc_out[to_] += 1\\n            #print(inc_out)\\n            if inc_out == [0] * n:\\n                ans = max(ans, res)\\n            inc_out = [0] * n\\n        return ans\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def maximumRequests(self, n: int, requests: List[List[int]]) -> int:\\n        m = len(requests)\\n        ans = 0\\n        inc_out = [0] * n\\n        for i in range(1, 1 << m):\\n            res = 0\\n            for j in range(0, m):\\n                if i & (1 << j):\\n                    res += 1\\n                    from_ = requests[j][0]\\n                    to_ = requests[j][1]\\n                    inc_out[from_] -= 1\\n                    inc_out[to_] += 1\\n            #print(inc_out)\\n            if inc_out == [0] * n:\\n                ans = max(ans, res)\\n            inc_out = [0] * n\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3838804,
                "title": "maximum-number-of-achievable-transfer-requests-using-java",
                "content": "# Approach\\nThe problem can be solved using recursion and backtracking. We need to consider all possible combinations of fulfilling or not fulfilling the requests and check if the resulting net change of employees in each building is zero. The goal is to find the maximum number of requests that can be achieved while maintaining this balance.\\n# Complexity\\n- Time complexity:O(2^r) r- number of requests\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n+r)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int maximumRequests(int n, int[][] requests) {\\n        int[] change = new int[n];\\n        return dfs(0, 0, n, requests, change);\\n    }\\n\\n    private int dfs(int pos, int count, int n, int[][] requests, int[] change) {\\n        if (pos == requests.length) {\\n            return checkValid(change) ? count : 0;\\n        }\\n\\n        int[] req = requests[pos];\\n        int result = dfs(pos + 1, count, n, requests, change);\\n        change[req[0]]--;\\n        change[req[1]]++;\\n        result = Math.max(result, dfs(pos + 1, count + 1, n, requests, change));\\n        change[req[0]]++;\\n        change[req[1]]--;\\n        return result;\\n    }\\n    private boolean checkValid(int[] change) {\\n        for (int changes : change) {\\n            if (changes != 0) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Backtracking",
                    "Bit Manipulation",
                    "Enumeration"
                ],
                "code": "```\\nclass Solution {\\n    public int maximumRequests(int n, int[][] requests) {\\n        int[] change = new int[n];\\n        return dfs(0, 0, n, requests, change);\\n    }\\n\\n    private int dfs(int pos, int count, int n, int[][] requests, int[] change) {\\n        if (pos == requests.length) {\\n            return checkValid(change) ? count : 0;\\n        }\\n\\n        int[] req = requests[pos];\\n        int result = dfs(pos + 1, count, n, requests, change);\\n        change[req[0]]--;\\n        change[req[1]]++;\\n        result = Math.max(result, dfs(pos + 1, count + 1, n, requests, change));\\n        change[req[0]]++;\\n        change[req[1]]--;\\n        return result;\\n    }\\n    private boolean checkValid(int[] change) {\\n        for (int changes : change) {\\n            if (changes != 0) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3835657,
                "title": "easy-java-solution-dfs",
                "content": "# Code\\n```\\nclass Solution {\\n    int res = 0;\\n\\n    public int maximumRequests(int n, int[][] requests) {\\n        // b stores people in each building\\n        int[] b = new int[n];\\n        // all buildings are balanced at start\\n        Arrays.fill(b, 0);\\n        dfs(requests, 0, b, 0);\\n        return res;\\n    }\\n\\n    public void dfs(int[][] requests, int index, int[] b, int count){\\n        // all requests processed, check for imbalance\\n        if (index == requests.length){\\n            for (int i : b){\\n                if (i != 0){\\n                    // if imbalance exists, do nothing and return\\n                    return;\\n                }\\n            }\\n            // all buildings are balanced, update maximum requests\\n            res = Math.max(res, count);\\n            return;\\n        }\\n\\n        // for each request we have two options: process or skip\\n\\n        // skip request\\n        dfs(requests, index+1, b, count);\\n\\n        // process request\\n        b[requests[index][0]]--;\\n        b[requests[index][1]]++;\\n        dfs(requests, index+1, b, count+1);\\n        b[requests[index][0]]++;\\n        b[requests[index][1]]--;\\n    }\\n}\\n```\\n# Another\\n```\\nclass Solution {\\n    public int maximumRequests(int n, int[][] requests) {\\n        int[] b = new int[n];\\n        return dfs(requests, 0, b, 0)-1;\\n    }\\n\\n    public int dfs(int[][] requests, int i, int[] b, int c){\\n        if (i == requests.length){\\n            for (int cur : b){\\n                if (cur != 0){return 0;}\\n            }\\n            return 1;\\n        }\\n        b[requests[i][0]]--;\\n        b[requests[i][1]]++;\\n        int select = dfs(requests, i+1, b, c+1);\\n        if (select != 0){\\n            select++;\\n        }\\n        b[requests[i][0]]++;\\n        b[requests[i][1]]--;\\n        int notselect = dfs(requests, i+1, b, c);\\n        return Math.max(select, notselect);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Backtracking",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    int res = 0;\\n\\n    public int maximumRequests(int n, int[][] requests) {\\n        // b stores people in each building\\n        int[] b = new int[n];\\n        // all buildings are balanced at start\\n        Arrays.fill(b, 0);\\n        dfs(requests, 0, b, 0);\\n        return res;\\n    }\\n\\n    public void dfs(int[][] requests, int index, int[] b, int count){\\n        // all requests processed, check for imbalance\\n        if (index == requests.length){\\n            for (int i : b){\\n                if (i != 0){\\n                    // if imbalance exists, do nothing and return\\n                    return;\\n                }\\n            }\\n            // all buildings are balanced, update maximum requests\\n            res = Math.max(res, count);\\n            return;\\n        }\\n\\n        // for each request we have two options: process or skip\\n\\n        // skip request\\n        dfs(requests, index+1, b, count);\\n\\n        // process request\\n        b[requests[index][0]]--;\\n        b[requests[index][1]]++;\\n        dfs(requests, index+1, b, count+1);\\n        b[requests[index][0]]++;\\n        b[requests[index][1]]--;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int maximumRequests(int n, int[][] requests) {\\n        int[] b = new int[n];\\n        return dfs(requests, 0, b, 0)-1;\\n    }\\n\\n    public int dfs(int[][] requests, int i, int[] b, int c){\\n        if (i == requests.length){\\n            for (int cur : b){\\n                if (cur != 0){return 0;}\\n            }\\n            return 1;\\n        }\\n        b[requests[i][0]]--;\\n        b[requests[i][1]]++;\\n        int select = dfs(requests, i+1, b, c+1);\\n        if (select != 0){\\n            select++;\\n        }\\n        b[requests[i][0]]++;\\n        b[requests[i][1]]--;\\n        int notselect = dfs(requests, i+1, b, c);\\n        return Math.max(select, notselect);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3805459,
                "title": "c-solution-recursion-beats-85-51",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nTry all possibilities with recursion\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nFor each transfer request, either accept or don\\'t accept the transfer\\nKeep an array of size n for net transfer from each building\\nInitalize all elements in this array with 0\\nFor every accepted transfer, decrement the value at the index of the outgoing building no. (from<sub>i</sub>) by 1 and the increment the value at the index of the incoming building no. (to<sub>i</sub>) by 1 in the net transfer array\\nAfter we consider all the requests, if the net transfer array is all zeroes, then it is acceptable.Else no\\nIf acceptable, update the maxTransfer variable if the no of acceptable transfers is greater than the maxTransfer\\n\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    \\n    int maxTransfer = 0;\\n\\n    void tryTransfers(int current, int num, int n, vector<vector<int>>& requests, vector<int>& netTransfer) {\\n        int no = requests.size();\\n        if(current >= no) {\\n            for(int i=0;i<n;i++) {\\n                if(netTransfer[i] != 0) {\\n                    return;\\n                }\\n            }\\n            maxTransfer = max(maxTransfer, num);\\n        }\\n\\n        else {\\n            tryTransfers(current+1, num, n, requests, netTransfer);\\n            netTransfer[requests[current][0]]--;\\n            netTransfer[requests[current][1]]++;\\n            tryTransfers(current+1, num+1, n, requests, netTransfer);\\n            netTransfer[requests[current][0]]++;\\n            netTransfer[requests[current][1]]--;\\n        }\\n\\n    }\\n\\n    int maximumRequests(int n, vector<vector<int>>& requests) {\\n        vector<int> netTransfer(n, 0);\\n\\n        tryTransfers(0, 0, n, requests, netTransfer);\\n\\n        return maxTransfer;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int maxTransfer = 0;\\n\\n    void tryTransfers(int current, int num, int n, vector<vector<int>>& requests, vector<int>& netTransfer) {\\n        int no = requests.size();\\n        if(current >= no) {\\n            for(int i=0;i<n;i++) {\\n                if(netTransfer[i] != 0) {\\n                    return;\\n                }\\n            }\\n            maxTransfer = max(maxTransfer, num);\\n        }\\n\\n        else {\\n            tryTransfers(current+1, num, n, requests, netTransfer);\\n            netTransfer[requests[current][0]]--;\\n            netTransfer[requests[current][1]]++;\\n            tryTransfers(current+1, num+1, n, requests, netTransfer);\\n            netTransfer[requests[current][0]]++;\\n            netTransfer[requests[current][1]]--;\\n        }\\n\\n    }\\n\\n    int maximumRequests(int n, vector<vector<int>>& requests) {\\n        vector<int> netTransfer(n, 0);\\n\\n        tryTransfers(0, 0, n, requests, netTransfer);\\n\\n        return maxTransfer;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3804595,
                "title": "eay-c-code-for-beginners",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void backtrack(vector<vector<int>>& requests, int index, vector<int>& count, int currCount, int& maxCount) {\\n        // Base case: If all requests have been processed\\n        if (index == requests.size()) {\\n            // Check if all buildings have a balanced count\\n            for (int i = 0; i < count.size(); i++) {\\n                if (count[i] != 0) return; // Some building is unbalanced, return\\n            }\\n            // Update the maximum count if the current count is greater\\n            maxCount = max(maxCount, currCount);\\n            return;\\n        }\\n\\n        // Process the current request\\n        int from = requests[index][0];\\n        int to = requests[index][1];\\n        count[from]--; // Decrease count of \"from\" building\\n        count[to]++;   // Increase count of \"to\" building\\n\\n        // Recursively process the next request with the current count incremented\\n        backtrack(requests, index + 1, count, currCount + 1, maxCount);\\n\\n        // Undo the previous changes (backtracking)\\n        count[from]++; // Undo count change for \"from\" building\\n        count[to]--;   // Undo count change for \"to\" building\\n\\n        // Recursively process the next request with the current count\\n        backtrack(requests, index + 1, count, currCount, maxCount);\\n    }\\n\\n    int maximumRequests(int n, vector<vector<int>>& requests) {\\n        vector<int> count(n); // Initialize count of buildings to 0\\n        int maxCount = 0;     // Maximum count of balanced requests\\n        backtrack(requests, 0, count, 0, maxCount); // Start backtracking from index 0\\n        return maxCount;     // Return the maximum count\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void backtrack(vector<vector<int>>& requests, int index, vector<int>& count, int currCount, int& maxCount) {\\n        // Base case: If all requests have been processed\\n        if (index == requests.size()) {\\n            // Check if all buildings have a balanced count\\n            for (int i = 0; i < count.size(); i++) {\\n                if (count[i] != 0) return; // Some building is unbalanced, return\\n            }\\n            // Update the maximum count if the current count is greater\\n            maxCount = max(maxCount, currCount);\\n            return;\\n        }\\n\\n        // Process the current request\\n        int from = requests[index][0];\\n        int to = requests[index][1];\\n        count[from]--; // Decrease count of \"from\" building\\n        count[to]++;   // Increase count of \"to\" building\\n\\n        // Recursively process the next request with the current count incremented\\n        backtrack(requests, index + 1, count, currCount + 1, maxCount);\\n\\n        // Undo the previous changes (backtracking)\\n        count[from]++; // Undo count change for \"from\" building\\n        count[to]--;   // Undo count change for \"to\" building\\n\\n        // Recursively process the next request with the current count\\n        backtrack(requests, index + 1, count, currCount, maxCount);\\n    }\\n\\n    int maximumRequests(int n, vector<vector<int>>& requests) {\\n        vector<int> count(n); // Initialize count of buildings to 0\\n        int maxCount = 0;     // Maximum count of balanced requests\\n        backtrack(requests, 0, count, 0, maxCount); // Start backtracking from index 0\\n        return maxCount;     // Return the maximum count\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3787088,
                "title": "easy-solution-java",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    // Define a constant for the modulo\\n    final int MOD = 1000000007;\\n    // Define a variable to store the maximum number of requests\\n    int maxRequests = 0;\\n\\n    public int maximumRequests(int n, int[][] requests) {\\n        // Call a helper method to find the maximum number of requests using backtracking\\n        backtrack(requests, 0, new int[n], 0);\\n        // Return the maximum number of requests\\n        return maxRequests;\\n    }\\n\\n    // Helper method to find the maximum number of requests using backtracking\\n    private void backtrack(int[][] requests, int index, int[] balance, int count) {\\n        // If we have reached the end of the requests array, check if the balance is zero for all buildings\\n        if (index == requests.length) {\\n            for (int b : balance) {\\n                if (b != 0) return; // If not, return without updating the maximum\\n            }\\n            // Update the maximum number of requests with the current count\\n            maxRequests = Math.max(maxRequests, count);\\n            return;\\n        }\\n        // Get the from and to buildings of the current request\\n        int from = requests[index][0];\\n        int to = requests[index][1];\\n        // Option 1: Choose the current request and update the balance and count accordingly\\n        balance[from]--;\\n        balance[to]++;\\n        backtrack(requests, index + 1, balance, count + 1);\\n        balance[from]++; // Backtrack\\n        balance[to]--;\\n        // Option 2: Skip the current request and keep the balance and count unchanged\\n        backtrack(requests, index + 1, balance, count);\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    // Define a constant for the modulo\\n    final int MOD = 1000000007;\\n    // Define a variable to store the maximum number of requests\\n    int maxRequests = 0;\\n\\n    public int maximumRequests(int n, int[][] requests) {\\n        // Call a helper method to find the maximum number of requests using backtracking\\n        backtrack(requests, 0, new int[n], 0);\\n        // Return the maximum number of requests\\n        return maxRequests;\\n    }\\n\\n    // Helper method to find the maximum number of requests using backtracking\\n    private void backtrack(int[][] requests, int index, int[] balance, int count) {\\n        // If we have reached the end of the requests array, check if the balance is zero for all buildings\\n        if (index == requests.length) {\\n            for (int b : balance) {\\n                if (b != 0) return; // If not, return without updating the maximum\\n            }\\n            // Update the maximum number of requests with the current count\\n            maxRequests = Math.max(maxRequests, count);\\n            return;\\n        }\\n        // Get the from and to buildings of the current request\\n        int from = requests[index][0];\\n        int to = requests[index][1];\\n        // Option 1: Choose the current request and update the balance and count accordingly\\n        balance[from]--;\\n        balance[to]++;\\n        backtrack(requests, index + 1, balance, count + 1);\\n        balance[from]++; // Backtrack\\n        balance[to]--;\\n        // Option 2: Skip the current request and keep the balance and count unchanged\\n        backtrack(requests, index + 1, balance, count);\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3783215,
                "title": "backtracking-solution-c",
                "content": "# Approach\\nTry all available combination of transfers and see which one satisfies the criteria.\\n\\n# Complexity\\n- Time complexity:\\nO(2^n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\npublic class Solution {\\n    public int MaximumRequests(int n, int[][] requests) {\\n        \\n        int[] inbound = new int[n];\\n        return MaximumRequestsUtil(n,requests,0,inbound,0);\\n    }\\n\\n    int MaximumRequestsUtil(int n, int[][] requests,int curr,int[] inbound,int transfers)\\n    {\\n        if(curr==requests.Length)\\n        {\\n            for(int i=0;i<n;i++)\\n            {\\n                if(inbound[i]!=0)\\n                {\\n                    return 0;\\n                }\\n            }\\n\\n            return transfers;\\n        }\\n\\n        inbound[requests[curr][0]]--;\\n        inbound[requests[curr][1]]++;\\n        int incl = MaximumRequestsUtil(n,requests,curr+1,inbound,transfers+1);\\n\\n        //This is use to reset the changes in inbound array in last statements for backtracking.\\n        inbound[requests[curr][0]]++;\\n        inbound[requests[curr][1]]--;\\n        int excl = MaximumRequestsUtil(n,requests,curr+1,inbound,transfers);\\n        \\n        return Math.Max(incl,excl);\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int MaximumRequests(int n, int[][] requests) {\\n        \\n        int[] inbound = new int[n];\\n        return MaximumRequestsUtil(n,requests,0,inbound,0);\\n    }\\n\\n    int MaximumRequestsUtil(int n, int[][] requests,int curr,int[] inbound,int transfers)\\n    {\\n        if(curr==requests.Length)\\n        {\\n            for(int i=0;i<n;i++)\\n            {\\n                if(inbound[i]!=0)\\n                {\\n                    return 0;\\n                }\\n            }\\n\\n            return transfers;\\n        }\\n\\n        inbound[requests[curr][0]]--;\\n        inbound[requests[curr][1]]++;\\n        int incl = MaximumRequestsUtil(n,requests,curr+1,inbound,transfers+1);\\n\\n        //This is use to reset the changes in inbound array in last statements for backtracking.\\n        inbound[requests[curr][0]]++;\\n        inbound[requests[curr][1]]--;\\n        int excl = MaximumRequestsUtil(n,requests,curr+1,inbound,transfers);\\n        \\n        return Math.Max(incl,excl);\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3780831,
                "title": "scala-backtracking-fp-template-memory-and-time-beats-100",
                "content": "# Intuition\\nFor each request, we can either take that request or skip that request and move onto next trequest. When we have finished all the requests, we need to check if the condition that the net movement across all buildings hsould be 0 is satisfied or not.\\n\\n# Approach\\nThis reminds me of backtracking and the constraints that requests are less than 16 further cements the notion that it should be solved using backtrack.\\n\\n# Complexity\\n- Time complexity: Since we. are exploring every option and are not memozing the previous values, the time complexity should be $$0(2^m) * n. $$ *n factor comes because for each request once the number iof req finishes , we are checking whether the net movement across all buildings is 0 or not. \\n\\n- Space complexity: For each stack frame that we use, it contibutes n and therefore the space complexity is $$0(m)$$ \\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nobject Solution {\\n  def backtrack( requests: Array[Array[Int]],buildingsNetMovement:Array[Int], currCount:Int, maxCount:Int,i:Int ):Int={\\n  if(i >= requests.length){\\n    if(buildingsNetMovement.forall(_==0)) maxCount max currCount\\n    else maxCount\\n  }\\n  else{\\n    val currReq = requests(i)\\n    buildingsNetMovement(currReq(0)) = buildingsNetMovement(currReq(0))-1\\n    buildingsNetMovement(currReq(1)) = buildingsNetMovement(currReq(1))+1\\n\\n    val take = backtrack(requests, buildingsNetMovement,currCount+1,maxCount ,i+1)\\n\\n    buildingsNetMovement(currReq(0)) = buildingsNetMovement(currReq(0))+1\\n    buildingsNetMovement(currReq(1)) = buildingsNetMovement(currReq(1))-1\\n    val skip =backtrack(requests, buildingsNetMovement, currCount,maxCount,i+1)\\n    \\n    take max skip\\n  }\\n}\\n    def maximumRequests(n: Int, requests: Array[Array[Int]]): Int = {\\n        val buildingsNetMovement = Array.fill(n)(0)\\n        backtrack(requests, buildingsNetMovement,0,Int.MinValue,0)\\n    }\\n}\\n```",
                "solutionTags": [
                    "Scala",
                    "Backtracking"
                ],
                "code": "```\\nobject Solution {\\n  def backtrack( requests: Array[Array[Int]],buildingsNetMovement:Array[Int], currCount:Int, maxCount:Int,i:Int ):Int={\\n  if(i >= requests.length){\\n    if(buildingsNetMovement.forall(_==0)) maxCount max currCount\\n    else maxCount\\n  }\\n  else{\\n    val currReq = requests(i)\\n    buildingsNetMovement(currReq(0)) = buildingsNetMovement(currReq(0))-1\\n    buildingsNetMovement(currReq(1)) = buildingsNetMovement(currReq(1))+1\\n\\n    val take = backtrack(requests, buildingsNetMovement,currCount+1,maxCount ,i+1)\\n\\n    buildingsNetMovement(currReq(0)) = buildingsNetMovement(currReq(0))+1\\n    buildingsNetMovement(currReq(1)) = buildingsNetMovement(currReq(1))-1\\n    val skip =backtrack(requests, buildingsNetMovement, currCount,maxCount,i+1)\\n    \\n    take max skip\\n  }\\n}\\n    def maximumRequests(n: Int, requests: Array[Array[Int]]): Int = {\\n        val buildingsNetMovement = Array.fill(n)(0)\\n        backtrack(requests, buildingsNetMovement,0,Int.MinValue,0)\\n    }\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3754873,
                "title": "maximum-number-of-achievable-transfer-requests",
                "content": "# Code\\n```\\nclass Solution:\\n    def maximumRequests(self, n: int, requests: List[List[int]]) -> int:\\n        def backtrack(index: int, count: int, buildings: List[int]) -> int:\\n            nonlocal max_requests\\n            if index == len(requests):\\n                if all(building == 0 for building in buildings):\\n                    max_requests = max(max_requests, count)\\n                return\\n            \\n            from_building, to_building = requests[index]\\n            \\n            # Choose to fulfill the request\\n            buildings[from_building] -= 1\\n            buildings[to_building] += 1\\n            backtrack(index + 1, count + 1, buildings)\\n            \\n            # Choose not to fulfill the request\\n            buildings[from_building] += 1\\n            buildings[to_building] -= 1\\n            backtrack(index + 1, count, buildings)\\n        \\n        max_requests = 0\\n        buildings = [0] * n\\n        backtrack(0, 0, buildings)\\n        return max_requests\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maximumRequests(self, n: int, requests: List[List[int]]) -> int:\\n        def backtrack(index: int, count: int, buildings: List[int]) -> int:\\n            nonlocal max_requests\\n            if index == len(requests):\\n                if all(building == 0 for building in buildings):\\n                    max_requests = max(max_requests, count)\\n                return\\n            \\n            from_building, to_building = requests[index]\\n            \\n            # Choose to fulfill the request\\n            buildings[from_building] -= 1\\n            buildings[to_building] += 1\\n            backtrack(index + 1, count + 1, buildings)\\n            \\n            # Choose not to fulfill the request\\n            buildings[from_building] += 1\\n            buildings[to_building] -= 1\\n            backtrack(index + 1, count, buildings)\\n        \\n        max_requests = 0\\n        buildings = [0] * n\\n        backtrack(0, 0, buildings)\\n        return max_requests\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3752191,
                "title": "backtrack",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(2^m*n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n+m)\\n\\n# Code\\n```\\n# @param {Integer} n\\n# @param {Integer[][]} requests\\n# @return {Integer}\\ndef maximum_requests(n, requests)\\n    # at each step we can accept a request or reject\\n    # when accpeting we can increase the count\\n    # when rejecting we need to decrease the count\\n    # follow the same till we reach requests.length\\n    # if all are 0 then we can calculate the maximum\\n    # Else we need to backtrack \\n   in_degree = Array.new(n,0)\\n   @answer = 0 \\n\\n   helper(n, requests, 0,0, in_degree) \\n\\n   @answer\\nend\\n\\ndef helper(n, requests, index,count, in_degree)     \\n\\n    if index == requests.length\\n        for i in (0...n) do \\n            if in_degree[i] != 0\\n                return \\n            end \\n        end \\n\\n        @answer = [@answer, count].max \\n        \\n        return \\n    end \\n    \\n    in_degree[requests[index][0]] -= 1\\n    in_degree[requests[index][1]] += 1\\n\\n    helper(n, requests, index+1,count+1, in_degree) \\n\\n    in_degree[requests[index][0]] += 1\\n    in_degree[requests[index][1]] -= 1\\n\\n    helper(n, requests, index+1,count, in_degree) \\nend \\n```",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```\\n# @param {Integer} n\\n# @param {Integer[][]} requests\\n# @return {Integer}\\ndef maximum_requests(n, requests)\\n    # at each step we can accept a request or reject\\n    # when accpeting we can increase the count\\n    # when rejecting we need to decrease the count\\n    # follow the same till we reach requests.length\\n    # if all are 0 then we can calculate the maximum\\n    # Else we need to backtrack \\n   in_degree = Array.new(n,0)\\n   @answer = 0 \\n\\n   helper(n, requests, 0,0, in_degree) \\n\\n   @answer\\nend\\n\\ndef helper(n, requests, index,count, in_degree)     \\n\\n    if index == requests.length\\n        for i in (0...n) do \\n            if in_degree[i] != 0\\n                return \\n            end \\n        end \\n\\n        @answer = [@answer, count].max \\n        \\n        return \\n    end \\n    \\n    in_degree[requests[index][0]] -= 1\\n    in_degree[requests[index][1]] += 1\\n\\n    helper(n, requests, index+1,count+1, in_degree) \\n\\n    in_degree[requests[index][0]] += 1\\n    in_degree[requests[index][1]] -= 1\\n\\n    helper(n, requests, index+1,count, in_degree) \\nend \\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3748294,
                "title": "simple-brute-force-easy-to-understand",
                "content": "```\\nclass Solution {\\n    int max=0;\\n    public void help(int [][] req,int idx,int arr[],int count)\\n    {\\n        if(idx==req.length)\\n        {\\n            //check\\n            for(int i=0;i<arr.length;i++)\\n            {\\n                if(arr[i]!=0)\\n                    return;\\n            }\\n            max=Math.max(max,count);\\n            \\n            return;\\n        }\\n        // take\\n        arr[req[idx][0]]--;\\n        arr[req[idx][1]]++;\\n        help(req,idx+1,arr,count+1);\\n        // not take\\n        arr[req[idx][0]]++;\\n        arr[req[idx][1]]--;\\n        help(req,idx+1,arr,count);\\n        \\n        \\n    }\\n    public int maximumRequests(int n, int[][] req) \\n    {\\n     int arr[]=new int[n];\\n     help(req,0,arr,0);\\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    int max=0;\\n    public void help(int [][] req,int idx,int arr[],int count)\\n    {\\n        if(idx==req.length)\\n        {\\n            //check\\n            for(int i=0;i<arr.length;i++)\\n            {\\n                if(arr[i]!=0)\\n                    return;\\n            }\\n            max=Math.max(max,count);\\n            \\n            return;\\n        }\\n        // take\\n        arr[req[idx][0]]--;\\n        arr[req[idx][1]]++;\\n        help(req,idx+1,arr,count+1);\\n        // not take\\n        arr[req[idx][0]]++;\\n        arr[req[idx][1]]--;\\n        help(req,idx+1,arr,count);\\n        \\n        \\n    }\\n    public int maximumRequests(int n, int[][] req) \\n    {\\n     int arr[]=new int[n];\\n     help(req,0,arr,0);\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3745771,
                "title": "python-compact-brute-force-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nfrom itertools import combinations\\nfrom collections import Counter\\nclass Solution:\\n    def maximumRequests(self, n: int, requests: List[List[int]]) -> int:\\n        for i in range(len(requests), 0, -1):\\n            for sub_requests in combinations(requests, i):\\n                incoming = Counter(b for _, b in sub_requests)\\n                outgoing = Counter(a for a, _ in sub_requests)\\n                if incoming - outgoing == Counter():\\n                    return i\\n        return 0\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nfrom itertools import combinations\\nfrom collections import Counter\\nclass Solution:\\n    def maximumRequests(self, n: int, requests: List[List[int]]) -> int:\\n        for i in range(len(requests), 0, -1):\\n            for sub_requests in combinations(requests, i):\\n                incoming = Counter(b for _, b in sub_requests)\\n                outgoing = Counter(a for a, _ in sub_requests)\\n                if incoming - outgoing == Counter():\\n                    return i\\n        return 0\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3743512,
                "title": "easy-solution-java-backtracking",
                "content": "\\n\\n# Approach\\nuse backtracking\\n\\n\\n# Code\\n```\\nclass Solution {\\n    public int ma=0;\\n    public void solve(int req[][],int arr[],int n,int idx,int accepted){\\n        if(idx==req.length){\\n            if(isValid(arr))\\n                ma=Math.max(ma,accepted);\\n            return;\\n        }\\n        arr[req[idx][0]]--;\\n        arr[req[idx][1]]++;\\n        solve(req,arr,n,idx+1,accepted+1);\\n        arr[req[idx][0]]++;\\n        arr[req[idx][1]]--;\\n        solve(req,arr,n,idx+1,accepted);\\n    }\\n    public int maximumRequests(int n, int[][] requests) {\\n        int arr[]=new int[n];\\n        solve(requests,arr,n,0,0);\\n        return ma;\\n    }\\n    public boolean isValid(int arr[]){\\n        for(int i=0;i<arr.length;i++){\\n            if(arr[i]!=0){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\n    public int ma=0;\\n    public void solve(int req[][],int arr[],int n,int idx,int accepted){\\n        if(idx==req.length){\\n            if(isValid(arr))\\n                ma=Math.max(ma,accepted);\\n            return;\\n        }\\n        arr[req[idx][0]]--;\\n        arr[req[idx][1]]++;\\n        solve(req,arr,n,idx+1,accepted+1);\\n        arr[req[idx][0]]++;\\n        arr[req[idx][1]]--;\\n        solve(req,arr,n,idx+1,accepted);\\n    }\\n    public int maximumRequests(int n, int[][] requests) {\\n        int arr[]=new int[n];\\n        solve(requests,arr,n,0,0);\\n        return ma;\\n    }\\n    public boolean isValid(int arr[]){\\n        for(int i=0;i<arr.length;i++){\\n            if(arr[i]!=0){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1952228,
                "content": [
                    {
                        "username": "yabyer1",
                        "content": "So many transfers, office looks like Chelsea"
                    },
                    {
                        "username": "oshok",
                        "content": "\\uD83D\\uDE02"
                    },
                    {
                        "username": "fenil3357",
                        "content": "still finished 12th."
                    },
                    {
                        "username": "mihirrawool1907",
                        "content": "[@subhamsadhukhan95](/subhamsadhukhan95) good pun\\n"
                    },
                    {
                        "username": "subhamsadhukhan95",
                        "content": "good one "
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "I thought the month will start with easy problems."
                    },
                    {
                        "username": "sarthakr10",
                        "content": "ha yr \\n"
                    },
                    {
                        "username": "eduard92",
                        "content": "Its also weekend. So Its O(n^n) psychological damage"
                    },
                    {
                        "username": "suren-yeager",
                        "content": "Just like yesterday\\'s daily challenge, constraints clearly tell us that this problem can be solved by brute force and this doesn\\'t deserve to be hard"
                    },
                    {
                        "username": "amitbansal13",
                        "content": "Leetcode is playing with our emotions now"
                    },
                    {
                        "username": "sanket54",
                        "content": "Why can\\'t we do it using minimum of in-degree and out-degree of the node?"
                    },
                    {
                        "username": "w7089",
                        "content": "have a look at the example `[[0,1],[2,1],[2,0]]` n=3"
                    },
                    {
                        "username": "w7089",
                        "content": "[@bparanj](/bparanj) again, the method by [@sanket54](/sanket54) works and returnsthe correct answer - 3, order doesn\\'t matter here"
                    },
                    {
                        "username": "w7089",
                        "content": "[@bparanj](/bparanj) try to run the below code on [[1,1],[1,1]], n=2:\\n\\n```\\nclass Solution:\\n    def maximumRequests(self, n: int, requests: List[List[int]]) -> int:\\n        from_c = Counter()\\n        to_c = Counter()\\n        for f_t in requests:\\n            f,t = f_t\\n            from_c[f] += 1\\n            to_c[t] += 1\\n        return sum([min(from_c[i], to_c[i]) for i in range(n)])\\n```\\n\\nand you\\'ll see that the solution is 2 and the method by [@sanket54](/sanket54) works\\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "[@himanshupanwar123](/himanshupanwar123) The key point is that a request `[a, b]` means an employee moves from building `a` to building `b`. To fulfill a request, the building `a` must have at least one employee.\\n\\nConsider your example `[1,1],[1,1]`, these two requests mean two employees leave building `1` and re-enter building `1`. Initially, we must have at least two employees in building `1` to fulfill both requests.\\n\\nSuppose building `1` starts with only one employee. We can fulfill the first request `[1,1]` because there\\'s an employee in building `1` who can leave and re-enter. But after this request, there\\'s still only one employee in building `1`. Now if we try to fulfill the second request `[1,1]`, we can\\'t, because we don\\'t have a second employee in building `1` to leave and re-enter. Therefore, in this situation, we can only fulfill one request, not two.\\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "That\\'s a good question, and this approach of using the minimum of in-degree and out-degree of a node seems to make sense at first glance because intuitively, you could fulfill as many requests as the minimum of in-degree and out-degree.\\n\\nHowever, this approach won\\'t work in all cases because the order of the requests matter. Let\\'s take an example to illustrate this:\\n\\nSuppose we have 3 buildings (0, 1, 2) and 4 requests: \\n```\\n[0, 1]\\n[1, 2]\\n[0, 1]\\n[2, 0]\\n```\\nIf you look at the minimum of in-degree and out-degree, all buildings have 2 incoming and 2 outgoing requests. So, you might think we can fulfill all 4 requests. But if you try to fulfill the requests in the order they\\'re given, after the first 3 requests, building 0 will have no employees left, so the last request can\\'t be fulfilled.\\n\\nOn the other hand, if you rearrange the requests like this:\\n```\\n[0, 1]\\n[0, 1]\\n[1, 2]\\n[2, 0]\\n```\\nNow, you can fulfill all 4 requests. \\n\\nSo, the problem is more complex than just looking at the minimum of in-degree and out-degree for each node, because the order of the requests matter. Therefore, we need to consider all possible arrangements of the requests, which is why we use a DFS with bit manipulation to generate all subsets of requests, and then check which subset can fulfill the maximum number of requests."
                    },
                    {
                        "username": "jain_06_07",
                        "content": "[@himanshupanwar123](/himanshupanwar123) Sure...\\n3\\n[[0,0], [1,1], [0,0], [2,0], [2,2], [1,1], [2,1], [0,1], [0,1]]\\n\\n[0,0], [1,1], [0,0], [2,2], [1,1] --> ignore these cases as it will not affect anything. worker leaves company and joins again but its request is full filled. Right so ans = 5 till now\\n\\nNow, for remaining requests [2,0], [2,1], [0,1], [0,1]. \\nif you\\'ll draw graph now then you will see\\nfor company 0 you\\'ve one incoming worker from company 2 and two worker leaving for company 1\\nand for company 1 there is only three workers that are coming but no one is leaving So company 1 cannot accept any worker from company 0. \\n\\nSo, it cannot fulfill the request even company 0 has sufficient indegree and outdegree. "
                    },
                    {
                        "username": "himanshupanwar123",
                        "content": "[@jain_06_07](/jain_06_07)  can you elaborate this example a bit i am also stuck at this since [1,1],[1,1] means two employes leaves and again they enter that means 2 request fullfilled."
                    },
                    {
                        "username": "Swastik_Gorai",
                        "content": "[@jain_06_07](/jain_06_07) please explain\\n"
                    },
                    {
                        "username": "jain_06_07",
                        "content": "[@amin_aziz](/amin_aziz) 6 ach/request ? Can you explain"
                    },
                    {
                        "username": "amin_aziz",
                        "content": "[@jain_06_07](/jain_06_07)\\nthere is 6 ach/request, but expected 5?"
                    },
                    {
                        "username": "jain_06_07",
                        "content": "see this case\\n3\\n[[0,0],[1,1],[0,0],[2,0],[2,2],[1,1],[2,1],[0,1],[0,1]]\\nIn this case , Indegree(0) = 1 and outdegree(0) = 2 \\nbut for node 1, there is no outdegree so It we can not take worker from node 0 and hence node 0 can\\'t send a worker also"
                    },
                    {
                        "username": "Rubiya1090",
                        "content": "It\\'s exhausting to see continuous medium & hard problems. Solving the leet code problem is fun when there is a right balance b/w difficulty level."
                    },
                    {
                        "username": "joseph261059",
                        "content": "It is a standard backtracking problem, it is not hard at all"
                    },
                    {
                        "username": "void_8t",
                        "content": "its not that hard, try it you can :)"
                    },
                    {
                        "username": "shubhampr10",
                        "content": "\\nWe\\'ve got other work to do.\\uD83D\\uDE2D"
                    },
                    {
                        "username": "mochy",
                        "content": "Why does brute force work lol"
                    },
                    {
                        "username": "charonme",
                        "content": "constraints are quite low, only 2^20 = 1048576 permutations at worst"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "Because of its \\uD83D\\uDCAA brutal force \\uD83D\\uDCAA, of course."
                    },
                    {
                        "username": "crosslives",
                        "content": "I think this is a Minimum Cost Maximum Flow problem. \\n\\nFirstly, we should calculate # of redundant requests and # of absent requests.\\n\\nThen we can construct a graph, G = <V, E>\\n\\nV = {S, T, Factory_1, Factory_2, ..., Factory_n}\\nE = { (S -> Factories that have redundant requests),\\n         (Facotries that need requests -> T,\\n\\t\\t All other edges provided by function\\n\\t\\t}\\nThe cost of each unit is 1. \\nThen we can calculate  Minimum Cost Maximum Flow of G. \\n\\\\# of requests - minimum cost is answer.\\n\\nI didn\\'t implement it but think it may be a possible solution.\\n\\nIs there more efficient solution for this problem?"
                    },
                    {
                        "username": "cecilia5",
                        "content": "[@f20201214](/f20201214) I posted it on the solutions."
                    },
                    {
                        "username": "f20201214",
                        "content": "[@cecilia5](/cecilia5) Could you share your solution?\\n"
                    },
                    {
                        "username": "VMAtm",
                        "content": "Yeah, thought about it too and was expecting to see this in editorial ("
                    },
                    {
                        "username": "cecilia5",
                        "content": "Minimum cost flow worked, you don\\'t need to add any nodes - just model the cost of a request is -1 and keep canceling negative cycles on the residual graph. "
                    },
                    {
                        "username": "autf",
                        "content": "I nominate this as an easiest `Hard` problem candidate."
                    },
                    {
                        "username": "IamVaibhave53",
                        "content": "Just curious to why this problem has been marked hard, when there are mediums which require more thinking than this one..."
                    }
                ]
            },
            {
                "id": 1952220,
                "content": [
                    {
                        "username": "yabyer1",
                        "content": "So many transfers, office looks like Chelsea"
                    },
                    {
                        "username": "oshok",
                        "content": "\\uD83D\\uDE02"
                    },
                    {
                        "username": "fenil3357",
                        "content": "still finished 12th."
                    },
                    {
                        "username": "mihirrawool1907",
                        "content": "[@subhamsadhukhan95](/subhamsadhukhan95) good pun\\n"
                    },
                    {
                        "username": "subhamsadhukhan95",
                        "content": "good one "
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "I thought the month will start with easy problems."
                    },
                    {
                        "username": "sarthakr10",
                        "content": "ha yr \\n"
                    },
                    {
                        "username": "eduard92",
                        "content": "Its also weekend. So Its O(n^n) psychological damage"
                    },
                    {
                        "username": "suren-yeager",
                        "content": "Just like yesterday\\'s daily challenge, constraints clearly tell us that this problem can be solved by brute force and this doesn\\'t deserve to be hard"
                    },
                    {
                        "username": "amitbansal13",
                        "content": "Leetcode is playing with our emotions now"
                    },
                    {
                        "username": "sanket54",
                        "content": "Why can\\'t we do it using minimum of in-degree and out-degree of the node?"
                    },
                    {
                        "username": "w7089",
                        "content": "have a look at the example `[[0,1],[2,1],[2,0]]` n=3"
                    },
                    {
                        "username": "w7089",
                        "content": "[@bparanj](/bparanj) again, the method by [@sanket54](/sanket54) works and returnsthe correct answer - 3, order doesn\\'t matter here"
                    },
                    {
                        "username": "w7089",
                        "content": "[@bparanj](/bparanj) try to run the below code on [[1,1],[1,1]], n=2:\\n\\n```\\nclass Solution:\\n    def maximumRequests(self, n: int, requests: List[List[int]]) -> int:\\n        from_c = Counter()\\n        to_c = Counter()\\n        for f_t in requests:\\n            f,t = f_t\\n            from_c[f] += 1\\n            to_c[t] += 1\\n        return sum([min(from_c[i], to_c[i]) for i in range(n)])\\n```\\n\\nand you\\'ll see that the solution is 2 and the method by [@sanket54](/sanket54) works\\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "[@himanshupanwar123](/himanshupanwar123) The key point is that a request `[a, b]` means an employee moves from building `a` to building `b`. To fulfill a request, the building `a` must have at least one employee.\\n\\nConsider your example `[1,1],[1,1]`, these two requests mean two employees leave building `1` and re-enter building `1`. Initially, we must have at least two employees in building `1` to fulfill both requests.\\n\\nSuppose building `1` starts with only one employee. We can fulfill the first request `[1,1]` because there\\'s an employee in building `1` who can leave and re-enter. But after this request, there\\'s still only one employee in building `1`. Now if we try to fulfill the second request `[1,1]`, we can\\'t, because we don\\'t have a second employee in building `1` to leave and re-enter. Therefore, in this situation, we can only fulfill one request, not two.\\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "That\\'s a good question, and this approach of using the minimum of in-degree and out-degree of a node seems to make sense at first glance because intuitively, you could fulfill as many requests as the minimum of in-degree and out-degree.\\n\\nHowever, this approach won\\'t work in all cases because the order of the requests matter. Let\\'s take an example to illustrate this:\\n\\nSuppose we have 3 buildings (0, 1, 2) and 4 requests: \\n```\\n[0, 1]\\n[1, 2]\\n[0, 1]\\n[2, 0]\\n```\\nIf you look at the minimum of in-degree and out-degree, all buildings have 2 incoming and 2 outgoing requests. So, you might think we can fulfill all 4 requests. But if you try to fulfill the requests in the order they\\'re given, after the first 3 requests, building 0 will have no employees left, so the last request can\\'t be fulfilled.\\n\\nOn the other hand, if you rearrange the requests like this:\\n```\\n[0, 1]\\n[0, 1]\\n[1, 2]\\n[2, 0]\\n```\\nNow, you can fulfill all 4 requests. \\n\\nSo, the problem is more complex than just looking at the minimum of in-degree and out-degree for each node, because the order of the requests matter. Therefore, we need to consider all possible arrangements of the requests, which is why we use a DFS with bit manipulation to generate all subsets of requests, and then check which subset can fulfill the maximum number of requests."
                    },
                    {
                        "username": "jain_06_07",
                        "content": "[@himanshupanwar123](/himanshupanwar123) Sure...\\n3\\n[[0,0], [1,1], [0,0], [2,0], [2,2], [1,1], [2,1], [0,1], [0,1]]\\n\\n[0,0], [1,1], [0,0], [2,2], [1,1] --> ignore these cases as it will not affect anything. worker leaves company and joins again but its request is full filled. Right so ans = 5 till now\\n\\nNow, for remaining requests [2,0], [2,1], [0,1], [0,1]. \\nif you\\'ll draw graph now then you will see\\nfor company 0 you\\'ve one incoming worker from company 2 and two worker leaving for company 1\\nand for company 1 there is only three workers that are coming but no one is leaving So company 1 cannot accept any worker from company 0. \\n\\nSo, it cannot fulfill the request even company 0 has sufficient indegree and outdegree. "
                    },
                    {
                        "username": "himanshupanwar123",
                        "content": "[@jain_06_07](/jain_06_07)  can you elaborate this example a bit i am also stuck at this since [1,1],[1,1] means two employes leaves and again they enter that means 2 request fullfilled."
                    },
                    {
                        "username": "Swastik_Gorai",
                        "content": "[@jain_06_07](/jain_06_07) please explain\\n"
                    },
                    {
                        "username": "jain_06_07",
                        "content": "[@amin_aziz](/amin_aziz) 6 ach/request ? Can you explain"
                    },
                    {
                        "username": "amin_aziz",
                        "content": "[@jain_06_07](/jain_06_07)\\nthere is 6 ach/request, but expected 5?"
                    },
                    {
                        "username": "jain_06_07",
                        "content": "see this case\\n3\\n[[0,0],[1,1],[0,0],[2,0],[2,2],[1,1],[2,1],[0,1],[0,1]]\\nIn this case , Indegree(0) = 1 and outdegree(0) = 2 \\nbut for node 1, there is no outdegree so It we can not take worker from node 0 and hence node 0 can\\'t send a worker also"
                    },
                    {
                        "username": "Rubiya1090",
                        "content": "It\\'s exhausting to see continuous medium & hard problems. Solving the leet code problem is fun when there is a right balance b/w difficulty level."
                    },
                    {
                        "username": "joseph261059",
                        "content": "It is a standard backtracking problem, it is not hard at all"
                    },
                    {
                        "username": "void_8t",
                        "content": "its not that hard, try it you can :)"
                    },
                    {
                        "username": "shubhampr10",
                        "content": "\\nWe\\'ve got other work to do.\\uD83D\\uDE2D"
                    },
                    {
                        "username": "mochy",
                        "content": "Why does brute force work lol"
                    },
                    {
                        "username": "charonme",
                        "content": "constraints are quite low, only 2^20 = 1048576 permutations at worst"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "Because of its \\uD83D\\uDCAA brutal force \\uD83D\\uDCAA, of course."
                    },
                    {
                        "username": "crosslives",
                        "content": "I think this is a Minimum Cost Maximum Flow problem. \\n\\nFirstly, we should calculate # of redundant requests and # of absent requests.\\n\\nThen we can construct a graph, G = <V, E>\\n\\nV = {S, T, Factory_1, Factory_2, ..., Factory_n}\\nE = { (S -> Factories that have redundant requests),\\n         (Facotries that need requests -> T,\\n\\t\\t All other edges provided by function\\n\\t\\t}\\nThe cost of each unit is 1. \\nThen we can calculate  Minimum Cost Maximum Flow of G. \\n\\\\# of requests - minimum cost is answer.\\n\\nI didn\\'t implement it but think it may be a possible solution.\\n\\nIs there more efficient solution for this problem?"
                    },
                    {
                        "username": "cecilia5",
                        "content": "[@f20201214](/f20201214) I posted it on the solutions."
                    },
                    {
                        "username": "f20201214",
                        "content": "[@cecilia5](/cecilia5) Could you share your solution?\\n"
                    },
                    {
                        "username": "VMAtm",
                        "content": "Yeah, thought about it too and was expecting to see this in editorial ("
                    },
                    {
                        "username": "cecilia5",
                        "content": "Minimum cost flow worked, you don\\'t need to add any nodes - just model the cost of a request is -1 and keep canceling negative cycles on the residual graph. "
                    },
                    {
                        "username": "autf",
                        "content": "I nominate this as an easiest `Hard` problem candidate."
                    },
                    {
                        "username": "IamVaibhave53",
                        "content": "Just curious to why this problem has been marked hard, when there are mediums which require more thinking than this one..."
                    }
                ]
            },
            {
                "id": 1952679,
                "content": [
                    {
                        "username": "yabyer1",
                        "content": "So many transfers, office looks like Chelsea"
                    },
                    {
                        "username": "oshok",
                        "content": "\\uD83D\\uDE02"
                    },
                    {
                        "username": "fenil3357",
                        "content": "still finished 12th."
                    },
                    {
                        "username": "mihirrawool1907",
                        "content": "[@subhamsadhukhan95](/subhamsadhukhan95) good pun\\n"
                    },
                    {
                        "username": "subhamsadhukhan95",
                        "content": "good one "
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "I thought the month will start with easy problems."
                    },
                    {
                        "username": "sarthakr10",
                        "content": "ha yr \\n"
                    },
                    {
                        "username": "eduard92",
                        "content": "Its also weekend. So Its O(n^n) psychological damage"
                    },
                    {
                        "username": "suren-yeager",
                        "content": "Just like yesterday\\'s daily challenge, constraints clearly tell us that this problem can be solved by brute force and this doesn\\'t deserve to be hard"
                    },
                    {
                        "username": "amitbansal13",
                        "content": "Leetcode is playing with our emotions now"
                    },
                    {
                        "username": "sanket54",
                        "content": "Why can\\'t we do it using minimum of in-degree and out-degree of the node?"
                    },
                    {
                        "username": "w7089",
                        "content": "have a look at the example `[[0,1],[2,1],[2,0]]` n=3"
                    },
                    {
                        "username": "w7089",
                        "content": "[@bparanj](/bparanj) again, the method by [@sanket54](/sanket54) works and returnsthe correct answer - 3, order doesn\\'t matter here"
                    },
                    {
                        "username": "w7089",
                        "content": "[@bparanj](/bparanj) try to run the below code on [[1,1],[1,1]], n=2:\\n\\n```\\nclass Solution:\\n    def maximumRequests(self, n: int, requests: List[List[int]]) -> int:\\n        from_c = Counter()\\n        to_c = Counter()\\n        for f_t in requests:\\n            f,t = f_t\\n            from_c[f] += 1\\n            to_c[t] += 1\\n        return sum([min(from_c[i], to_c[i]) for i in range(n)])\\n```\\n\\nand you\\'ll see that the solution is 2 and the method by [@sanket54](/sanket54) works\\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "[@himanshupanwar123](/himanshupanwar123) The key point is that a request `[a, b]` means an employee moves from building `a` to building `b`. To fulfill a request, the building `a` must have at least one employee.\\n\\nConsider your example `[1,1],[1,1]`, these two requests mean two employees leave building `1` and re-enter building `1`. Initially, we must have at least two employees in building `1` to fulfill both requests.\\n\\nSuppose building `1` starts with only one employee. We can fulfill the first request `[1,1]` because there\\'s an employee in building `1` who can leave and re-enter. But after this request, there\\'s still only one employee in building `1`. Now if we try to fulfill the second request `[1,1]`, we can\\'t, because we don\\'t have a second employee in building `1` to leave and re-enter. Therefore, in this situation, we can only fulfill one request, not two.\\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "That\\'s a good question, and this approach of using the minimum of in-degree and out-degree of a node seems to make sense at first glance because intuitively, you could fulfill as many requests as the minimum of in-degree and out-degree.\\n\\nHowever, this approach won\\'t work in all cases because the order of the requests matter. Let\\'s take an example to illustrate this:\\n\\nSuppose we have 3 buildings (0, 1, 2) and 4 requests: \\n```\\n[0, 1]\\n[1, 2]\\n[0, 1]\\n[2, 0]\\n```\\nIf you look at the minimum of in-degree and out-degree, all buildings have 2 incoming and 2 outgoing requests. So, you might think we can fulfill all 4 requests. But if you try to fulfill the requests in the order they\\'re given, after the first 3 requests, building 0 will have no employees left, so the last request can\\'t be fulfilled.\\n\\nOn the other hand, if you rearrange the requests like this:\\n```\\n[0, 1]\\n[0, 1]\\n[1, 2]\\n[2, 0]\\n```\\nNow, you can fulfill all 4 requests. \\n\\nSo, the problem is more complex than just looking at the minimum of in-degree and out-degree for each node, because the order of the requests matter. Therefore, we need to consider all possible arrangements of the requests, which is why we use a DFS with bit manipulation to generate all subsets of requests, and then check which subset can fulfill the maximum number of requests."
                    },
                    {
                        "username": "jain_06_07",
                        "content": "[@himanshupanwar123](/himanshupanwar123) Sure...\\n3\\n[[0,0], [1,1], [0,0], [2,0], [2,2], [1,1], [2,1], [0,1], [0,1]]\\n\\n[0,0], [1,1], [0,0], [2,2], [1,1] --> ignore these cases as it will not affect anything. worker leaves company and joins again but its request is full filled. Right so ans = 5 till now\\n\\nNow, for remaining requests [2,0], [2,1], [0,1], [0,1]. \\nif you\\'ll draw graph now then you will see\\nfor company 0 you\\'ve one incoming worker from company 2 and two worker leaving for company 1\\nand for company 1 there is only three workers that are coming but no one is leaving So company 1 cannot accept any worker from company 0. \\n\\nSo, it cannot fulfill the request even company 0 has sufficient indegree and outdegree. "
                    },
                    {
                        "username": "himanshupanwar123",
                        "content": "[@jain_06_07](/jain_06_07)  can you elaborate this example a bit i am also stuck at this since [1,1],[1,1] means two employes leaves and again they enter that means 2 request fullfilled."
                    },
                    {
                        "username": "Swastik_Gorai",
                        "content": "[@jain_06_07](/jain_06_07) please explain\\n"
                    },
                    {
                        "username": "jain_06_07",
                        "content": "[@amin_aziz](/amin_aziz) 6 ach/request ? Can you explain"
                    },
                    {
                        "username": "amin_aziz",
                        "content": "[@jain_06_07](/jain_06_07)\\nthere is 6 ach/request, but expected 5?"
                    },
                    {
                        "username": "jain_06_07",
                        "content": "see this case\\n3\\n[[0,0],[1,1],[0,0],[2,0],[2,2],[1,1],[2,1],[0,1],[0,1]]\\nIn this case , Indegree(0) = 1 and outdegree(0) = 2 \\nbut for node 1, there is no outdegree so It we can not take worker from node 0 and hence node 0 can\\'t send a worker also"
                    },
                    {
                        "username": "Rubiya1090",
                        "content": "It\\'s exhausting to see continuous medium & hard problems. Solving the leet code problem is fun when there is a right balance b/w difficulty level."
                    },
                    {
                        "username": "joseph261059",
                        "content": "It is a standard backtracking problem, it is not hard at all"
                    },
                    {
                        "username": "void_8t",
                        "content": "its not that hard, try it you can :)"
                    },
                    {
                        "username": "shubhampr10",
                        "content": "\\nWe\\'ve got other work to do.\\uD83D\\uDE2D"
                    },
                    {
                        "username": "mochy",
                        "content": "Why does brute force work lol"
                    },
                    {
                        "username": "charonme",
                        "content": "constraints are quite low, only 2^20 = 1048576 permutations at worst"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "Because of its \\uD83D\\uDCAA brutal force \\uD83D\\uDCAA, of course."
                    },
                    {
                        "username": "crosslives",
                        "content": "I think this is a Minimum Cost Maximum Flow problem. \\n\\nFirstly, we should calculate # of redundant requests and # of absent requests.\\n\\nThen we can construct a graph, G = <V, E>\\n\\nV = {S, T, Factory_1, Factory_2, ..., Factory_n}\\nE = { (S -> Factories that have redundant requests),\\n         (Facotries that need requests -> T,\\n\\t\\t All other edges provided by function\\n\\t\\t}\\nThe cost of each unit is 1. \\nThen we can calculate  Minimum Cost Maximum Flow of G. \\n\\\\# of requests - minimum cost is answer.\\n\\nI didn\\'t implement it but think it may be a possible solution.\\n\\nIs there more efficient solution for this problem?"
                    },
                    {
                        "username": "cecilia5",
                        "content": "[@f20201214](/f20201214) I posted it on the solutions."
                    },
                    {
                        "username": "f20201214",
                        "content": "[@cecilia5](/cecilia5) Could you share your solution?\\n"
                    },
                    {
                        "username": "VMAtm",
                        "content": "Yeah, thought about it too and was expecting to see this in editorial ("
                    },
                    {
                        "username": "cecilia5",
                        "content": "Minimum cost flow worked, you don\\'t need to add any nodes - just model the cost of a request is -1 and keep canceling negative cycles on the residual graph. "
                    },
                    {
                        "username": "autf",
                        "content": "I nominate this as an easiest `Hard` problem candidate."
                    },
                    {
                        "username": "IamVaibhave53",
                        "content": "Just curious to why this problem has been marked hard, when there are mediums which require more thinking than this one..."
                    }
                ]
            },
            {
                "id": 1952273,
                "content": [
                    {
                        "username": "yabyer1",
                        "content": "So many transfers, office looks like Chelsea"
                    },
                    {
                        "username": "oshok",
                        "content": "\\uD83D\\uDE02"
                    },
                    {
                        "username": "fenil3357",
                        "content": "still finished 12th."
                    },
                    {
                        "username": "mihirrawool1907",
                        "content": "[@subhamsadhukhan95](/subhamsadhukhan95) good pun\\n"
                    },
                    {
                        "username": "subhamsadhukhan95",
                        "content": "good one "
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "I thought the month will start with easy problems."
                    },
                    {
                        "username": "sarthakr10",
                        "content": "ha yr \\n"
                    },
                    {
                        "username": "eduard92",
                        "content": "Its also weekend. So Its O(n^n) psychological damage"
                    },
                    {
                        "username": "suren-yeager",
                        "content": "Just like yesterday\\'s daily challenge, constraints clearly tell us that this problem can be solved by brute force and this doesn\\'t deserve to be hard"
                    },
                    {
                        "username": "amitbansal13",
                        "content": "Leetcode is playing with our emotions now"
                    },
                    {
                        "username": "sanket54",
                        "content": "Why can\\'t we do it using minimum of in-degree and out-degree of the node?"
                    },
                    {
                        "username": "w7089",
                        "content": "have a look at the example `[[0,1],[2,1],[2,0]]` n=3"
                    },
                    {
                        "username": "w7089",
                        "content": "[@bparanj](/bparanj) again, the method by [@sanket54](/sanket54) works and returnsthe correct answer - 3, order doesn\\'t matter here"
                    },
                    {
                        "username": "w7089",
                        "content": "[@bparanj](/bparanj) try to run the below code on [[1,1],[1,1]], n=2:\\n\\n```\\nclass Solution:\\n    def maximumRequests(self, n: int, requests: List[List[int]]) -> int:\\n        from_c = Counter()\\n        to_c = Counter()\\n        for f_t in requests:\\n            f,t = f_t\\n            from_c[f] += 1\\n            to_c[t] += 1\\n        return sum([min(from_c[i], to_c[i]) for i in range(n)])\\n```\\n\\nand you\\'ll see that the solution is 2 and the method by [@sanket54](/sanket54) works\\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "[@himanshupanwar123](/himanshupanwar123) The key point is that a request `[a, b]` means an employee moves from building `a` to building `b`. To fulfill a request, the building `a` must have at least one employee.\\n\\nConsider your example `[1,1],[1,1]`, these two requests mean two employees leave building `1` and re-enter building `1`. Initially, we must have at least two employees in building `1` to fulfill both requests.\\n\\nSuppose building `1` starts with only one employee. We can fulfill the first request `[1,1]` because there\\'s an employee in building `1` who can leave and re-enter. But after this request, there\\'s still only one employee in building `1`. Now if we try to fulfill the second request `[1,1]`, we can\\'t, because we don\\'t have a second employee in building `1` to leave and re-enter. Therefore, in this situation, we can only fulfill one request, not two.\\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "That\\'s a good question, and this approach of using the minimum of in-degree and out-degree of a node seems to make sense at first glance because intuitively, you could fulfill as many requests as the minimum of in-degree and out-degree.\\n\\nHowever, this approach won\\'t work in all cases because the order of the requests matter. Let\\'s take an example to illustrate this:\\n\\nSuppose we have 3 buildings (0, 1, 2) and 4 requests: \\n```\\n[0, 1]\\n[1, 2]\\n[0, 1]\\n[2, 0]\\n```\\nIf you look at the minimum of in-degree and out-degree, all buildings have 2 incoming and 2 outgoing requests. So, you might think we can fulfill all 4 requests. But if you try to fulfill the requests in the order they\\'re given, after the first 3 requests, building 0 will have no employees left, so the last request can\\'t be fulfilled.\\n\\nOn the other hand, if you rearrange the requests like this:\\n```\\n[0, 1]\\n[0, 1]\\n[1, 2]\\n[2, 0]\\n```\\nNow, you can fulfill all 4 requests. \\n\\nSo, the problem is more complex than just looking at the minimum of in-degree and out-degree for each node, because the order of the requests matter. Therefore, we need to consider all possible arrangements of the requests, which is why we use a DFS with bit manipulation to generate all subsets of requests, and then check which subset can fulfill the maximum number of requests."
                    },
                    {
                        "username": "jain_06_07",
                        "content": "[@himanshupanwar123](/himanshupanwar123) Sure...\\n3\\n[[0,0], [1,1], [0,0], [2,0], [2,2], [1,1], [2,1], [0,1], [0,1]]\\n\\n[0,0], [1,1], [0,0], [2,2], [1,1] --> ignore these cases as it will not affect anything. worker leaves company and joins again but its request is full filled. Right so ans = 5 till now\\n\\nNow, for remaining requests [2,0], [2,1], [0,1], [0,1]. \\nif you\\'ll draw graph now then you will see\\nfor company 0 you\\'ve one incoming worker from company 2 and two worker leaving for company 1\\nand for company 1 there is only three workers that are coming but no one is leaving So company 1 cannot accept any worker from company 0. \\n\\nSo, it cannot fulfill the request even company 0 has sufficient indegree and outdegree. "
                    },
                    {
                        "username": "himanshupanwar123",
                        "content": "[@jain_06_07](/jain_06_07)  can you elaborate this example a bit i am also stuck at this since [1,1],[1,1] means two employes leaves and again they enter that means 2 request fullfilled."
                    },
                    {
                        "username": "Swastik_Gorai",
                        "content": "[@jain_06_07](/jain_06_07) please explain\\n"
                    },
                    {
                        "username": "jain_06_07",
                        "content": "[@amin_aziz](/amin_aziz) 6 ach/request ? Can you explain"
                    },
                    {
                        "username": "amin_aziz",
                        "content": "[@jain_06_07](/jain_06_07)\\nthere is 6 ach/request, but expected 5?"
                    },
                    {
                        "username": "jain_06_07",
                        "content": "see this case\\n3\\n[[0,0],[1,1],[0,0],[2,0],[2,2],[1,1],[2,1],[0,1],[0,1]]\\nIn this case , Indegree(0) = 1 and outdegree(0) = 2 \\nbut for node 1, there is no outdegree so It we can not take worker from node 0 and hence node 0 can\\'t send a worker also"
                    },
                    {
                        "username": "Rubiya1090",
                        "content": "It\\'s exhausting to see continuous medium & hard problems. Solving the leet code problem is fun when there is a right balance b/w difficulty level."
                    },
                    {
                        "username": "joseph261059",
                        "content": "It is a standard backtracking problem, it is not hard at all"
                    },
                    {
                        "username": "void_8t",
                        "content": "its not that hard, try it you can :)"
                    },
                    {
                        "username": "shubhampr10",
                        "content": "\\nWe\\'ve got other work to do.\\uD83D\\uDE2D"
                    },
                    {
                        "username": "mochy",
                        "content": "Why does brute force work lol"
                    },
                    {
                        "username": "charonme",
                        "content": "constraints are quite low, only 2^20 = 1048576 permutations at worst"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "Because of its \\uD83D\\uDCAA brutal force \\uD83D\\uDCAA, of course."
                    },
                    {
                        "username": "crosslives",
                        "content": "I think this is a Minimum Cost Maximum Flow problem. \\n\\nFirstly, we should calculate # of redundant requests and # of absent requests.\\n\\nThen we can construct a graph, G = <V, E>\\n\\nV = {S, T, Factory_1, Factory_2, ..., Factory_n}\\nE = { (S -> Factories that have redundant requests),\\n         (Facotries that need requests -> T,\\n\\t\\t All other edges provided by function\\n\\t\\t}\\nThe cost of each unit is 1. \\nThen we can calculate  Minimum Cost Maximum Flow of G. \\n\\\\# of requests - minimum cost is answer.\\n\\nI didn\\'t implement it but think it may be a possible solution.\\n\\nIs there more efficient solution for this problem?"
                    },
                    {
                        "username": "cecilia5",
                        "content": "[@f20201214](/f20201214) I posted it on the solutions."
                    },
                    {
                        "username": "f20201214",
                        "content": "[@cecilia5](/cecilia5) Could you share your solution?\\n"
                    },
                    {
                        "username": "VMAtm",
                        "content": "Yeah, thought about it too and was expecting to see this in editorial ("
                    },
                    {
                        "username": "cecilia5",
                        "content": "Minimum cost flow worked, you don\\'t need to add any nodes - just model the cost of a request is -1 and keep canceling negative cycles on the residual graph. "
                    },
                    {
                        "username": "autf",
                        "content": "I nominate this as an easiest `Hard` problem candidate."
                    },
                    {
                        "username": "IamVaibhave53",
                        "content": "Just curious to why this problem has been marked hard, when there are mediums which require more thinking than this one..."
                    }
                ]
            },
            {
                "id": 1570184,
                "content": [
                    {
                        "username": "yabyer1",
                        "content": "So many transfers, office looks like Chelsea"
                    },
                    {
                        "username": "oshok",
                        "content": "\\uD83D\\uDE02"
                    },
                    {
                        "username": "fenil3357",
                        "content": "still finished 12th."
                    },
                    {
                        "username": "mihirrawool1907",
                        "content": "[@subhamsadhukhan95](/subhamsadhukhan95) good pun\\n"
                    },
                    {
                        "username": "subhamsadhukhan95",
                        "content": "good one "
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "I thought the month will start with easy problems."
                    },
                    {
                        "username": "sarthakr10",
                        "content": "ha yr \\n"
                    },
                    {
                        "username": "eduard92",
                        "content": "Its also weekend. So Its O(n^n) psychological damage"
                    },
                    {
                        "username": "suren-yeager",
                        "content": "Just like yesterday\\'s daily challenge, constraints clearly tell us that this problem can be solved by brute force and this doesn\\'t deserve to be hard"
                    },
                    {
                        "username": "amitbansal13",
                        "content": "Leetcode is playing with our emotions now"
                    },
                    {
                        "username": "sanket54",
                        "content": "Why can\\'t we do it using minimum of in-degree and out-degree of the node?"
                    },
                    {
                        "username": "w7089",
                        "content": "have a look at the example `[[0,1],[2,1],[2,0]]` n=3"
                    },
                    {
                        "username": "w7089",
                        "content": "[@bparanj](/bparanj) again, the method by [@sanket54](/sanket54) works and returnsthe correct answer - 3, order doesn\\'t matter here"
                    },
                    {
                        "username": "w7089",
                        "content": "[@bparanj](/bparanj) try to run the below code on [[1,1],[1,1]], n=2:\\n\\n```\\nclass Solution:\\n    def maximumRequests(self, n: int, requests: List[List[int]]) -> int:\\n        from_c = Counter()\\n        to_c = Counter()\\n        for f_t in requests:\\n            f,t = f_t\\n            from_c[f] += 1\\n            to_c[t] += 1\\n        return sum([min(from_c[i], to_c[i]) for i in range(n)])\\n```\\n\\nand you\\'ll see that the solution is 2 and the method by [@sanket54](/sanket54) works\\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "[@himanshupanwar123](/himanshupanwar123) The key point is that a request `[a, b]` means an employee moves from building `a` to building `b`. To fulfill a request, the building `a` must have at least one employee.\\n\\nConsider your example `[1,1],[1,1]`, these two requests mean two employees leave building `1` and re-enter building `1`. Initially, we must have at least two employees in building `1` to fulfill both requests.\\n\\nSuppose building `1` starts with only one employee. We can fulfill the first request `[1,1]` because there\\'s an employee in building `1` who can leave and re-enter. But after this request, there\\'s still only one employee in building `1`. Now if we try to fulfill the second request `[1,1]`, we can\\'t, because we don\\'t have a second employee in building `1` to leave and re-enter. Therefore, in this situation, we can only fulfill one request, not two.\\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "That\\'s a good question, and this approach of using the minimum of in-degree and out-degree of a node seems to make sense at first glance because intuitively, you could fulfill as many requests as the minimum of in-degree and out-degree.\\n\\nHowever, this approach won\\'t work in all cases because the order of the requests matter. Let\\'s take an example to illustrate this:\\n\\nSuppose we have 3 buildings (0, 1, 2) and 4 requests: \\n```\\n[0, 1]\\n[1, 2]\\n[0, 1]\\n[2, 0]\\n```\\nIf you look at the minimum of in-degree and out-degree, all buildings have 2 incoming and 2 outgoing requests. So, you might think we can fulfill all 4 requests. But if you try to fulfill the requests in the order they\\'re given, after the first 3 requests, building 0 will have no employees left, so the last request can\\'t be fulfilled.\\n\\nOn the other hand, if you rearrange the requests like this:\\n```\\n[0, 1]\\n[0, 1]\\n[1, 2]\\n[2, 0]\\n```\\nNow, you can fulfill all 4 requests. \\n\\nSo, the problem is more complex than just looking at the minimum of in-degree and out-degree for each node, because the order of the requests matter. Therefore, we need to consider all possible arrangements of the requests, which is why we use a DFS with bit manipulation to generate all subsets of requests, and then check which subset can fulfill the maximum number of requests."
                    },
                    {
                        "username": "jain_06_07",
                        "content": "[@himanshupanwar123](/himanshupanwar123) Sure...\\n3\\n[[0,0], [1,1], [0,0], [2,0], [2,2], [1,1], [2,1], [0,1], [0,1]]\\n\\n[0,0], [1,1], [0,0], [2,2], [1,1] --> ignore these cases as it will not affect anything. worker leaves company and joins again but its request is full filled. Right so ans = 5 till now\\n\\nNow, for remaining requests [2,0], [2,1], [0,1], [0,1]. \\nif you\\'ll draw graph now then you will see\\nfor company 0 you\\'ve one incoming worker from company 2 and two worker leaving for company 1\\nand for company 1 there is only three workers that are coming but no one is leaving So company 1 cannot accept any worker from company 0. \\n\\nSo, it cannot fulfill the request even company 0 has sufficient indegree and outdegree. "
                    },
                    {
                        "username": "himanshupanwar123",
                        "content": "[@jain_06_07](/jain_06_07)  can you elaborate this example a bit i am also stuck at this since [1,1],[1,1] means two employes leaves and again they enter that means 2 request fullfilled."
                    },
                    {
                        "username": "Swastik_Gorai",
                        "content": "[@jain_06_07](/jain_06_07) please explain\\n"
                    },
                    {
                        "username": "jain_06_07",
                        "content": "[@amin_aziz](/amin_aziz) 6 ach/request ? Can you explain"
                    },
                    {
                        "username": "amin_aziz",
                        "content": "[@jain_06_07](/jain_06_07)\\nthere is 6 ach/request, but expected 5?"
                    },
                    {
                        "username": "jain_06_07",
                        "content": "see this case\\n3\\n[[0,0],[1,1],[0,0],[2,0],[2,2],[1,1],[2,1],[0,1],[0,1]]\\nIn this case , Indegree(0) = 1 and outdegree(0) = 2 \\nbut for node 1, there is no outdegree so It we can not take worker from node 0 and hence node 0 can\\'t send a worker also"
                    },
                    {
                        "username": "Rubiya1090",
                        "content": "It\\'s exhausting to see continuous medium & hard problems. Solving the leet code problem is fun when there is a right balance b/w difficulty level."
                    },
                    {
                        "username": "joseph261059",
                        "content": "It is a standard backtracking problem, it is not hard at all"
                    },
                    {
                        "username": "void_8t",
                        "content": "its not that hard, try it you can :)"
                    },
                    {
                        "username": "shubhampr10",
                        "content": "\\nWe\\'ve got other work to do.\\uD83D\\uDE2D"
                    },
                    {
                        "username": "mochy",
                        "content": "Why does brute force work lol"
                    },
                    {
                        "username": "charonme",
                        "content": "constraints are quite low, only 2^20 = 1048576 permutations at worst"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "Because of its \\uD83D\\uDCAA brutal force \\uD83D\\uDCAA, of course."
                    },
                    {
                        "username": "crosslives",
                        "content": "I think this is a Minimum Cost Maximum Flow problem. \\n\\nFirstly, we should calculate # of redundant requests and # of absent requests.\\n\\nThen we can construct a graph, G = <V, E>\\n\\nV = {S, T, Factory_1, Factory_2, ..., Factory_n}\\nE = { (S -> Factories that have redundant requests),\\n         (Facotries that need requests -> T,\\n\\t\\t All other edges provided by function\\n\\t\\t}\\nThe cost of each unit is 1. \\nThen we can calculate  Minimum Cost Maximum Flow of G. \\n\\\\# of requests - minimum cost is answer.\\n\\nI didn\\'t implement it but think it may be a possible solution.\\n\\nIs there more efficient solution for this problem?"
                    },
                    {
                        "username": "cecilia5",
                        "content": "[@f20201214](/f20201214) I posted it on the solutions."
                    },
                    {
                        "username": "f20201214",
                        "content": "[@cecilia5](/cecilia5) Could you share your solution?\\n"
                    },
                    {
                        "username": "VMAtm",
                        "content": "Yeah, thought about it too and was expecting to see this in editorial ("
                    },
                    {
                        "username": "cecilia5",
                        "content": "Minimum cost flow worked, you don\\'t need to add any nodes - just model the cost of a request is -1 and keep canceling negative cycles on the residual graph. "
                    },
                    {
                        "username": "autf",
                        "content": "I nominate this as an easiest `Hard` problem candidate."
                    },
                    {
                        "username": "IamVaibhave53",
                        "content": "Just curious to why this problem has been marked hard, when there are mediums which require more thinking than this one..."
                    }
                ]
            },
            {
                "id": 1952655,
                "content": [
                    {
                        "username": "yabyer1",
                        "content": "So many transfers, office looks like Chelsea"
                    },
                    {
                        "username": "oshok",
                        "content": "\\uD83D\\uDE02"
                    },
                    {
                        "username": "fenil3357",
                        "content": "still finished 12th."
                    },
                    {
                        "username": "mihirrawool1907",
                        "content": "[@subhamsadhukhan95](/subhamsadhukhan95) good pun\\n"
                    },
                    {
                        "username": "subhamsadhukhan95",
                        "content": "good one "
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "I thought the month will start with easy problems."
                    },
                    {
                        "username": "sarthakr10",
                        "content": "ha yr \\n"
                    },
                    {
                        "username": "eduard92",
                        "content": "Its also weekend. So Its O(n^n) psychological damage"
                    },
                    {
                        "username": "suren-yeager",
                        "content": "Just like yesterday\\'s daily challenge, constraints clearly tell us that this problem can be solved by brute force and this doesn\\'t deserve to be hard"
                    },
                    {
                        "username": "amitbansal13",
                        "content": "Leetcode is playing with our emotions now"
                    },
                    {
                        "username": "sanket54",
                        "content": "Why can\\'t we do it using minimum of in-degree and out-degree of the node?"
                    },
                    {
                        "username": "w7089",
                        "content": "have a look at the example `[[0,1],[2,1],[2,0]]` n=3"
                    },
                    {
                        "username": "w7089",
                        "content": "[@bparanj](/bparanj) again, the method by [@sanket54](/sanket54) works and returnsthe correct answer - 3, order doesn\\'t matter here"
                    },
                    {
                        "username": "w7089",
                        "content": "[@bparanj](/bparanj) try to run the below code on [[1,1],[1,1]], n=2:\\n\\n```\\nclass Solution:\\n    def maximumRequests(self, n: int, requests: List[List[int]]) -> int:\\n        from_c = Counter()\\n        to_c = Counter()\\n        for f_t in requests:\\n            f,t = f_t\\n            from_c[f] += 1\\n            to_c[t] += 1\\n        return sum([min(from_c[i], to_c[i]) for i in range(n)])\\n```\\n\\nand you\\'ll see that the solution is 2 and the method by [@sanket54](/sanket54) works\\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "[@himanshupanwar123](/himanshupanwar123) The key point is that a request `[a, b]` means an employee moves from building `a` to building `b`. To fulfill a request, the building `a` must have at least one employee.\\n\\nConsider your example `[1,1],[1,1]`, these two requests mean two employees leave building `1` and re-enter building `1`. Initially, we must have at least two employees in building `1` to fulfill both requests.\\n\\nSuppose building `1` starts with only one employee. We can fulfill the first request `[1,1]` because there\\'s an employee in building `1` who can leave and re-enter. But after this request, there\\'s still only one employee in building `1`. Now if we try to fulfill the second request `[1,1]`, we can\\'t, because we don\\'t have a second employee in building `1` to leave and re-enter. Therefore, in this situation, we can only fulfill one request, not two.\\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "That\\'s a good question, and this approach of using the minimum of in-degree and out-degree of a node seems to make sense at first glance because intuitively, you could fulfill as many requests as the minimum of in-degree and out-degree.\\n\\nHowever, this approach won\\'t work in all cases because the order of the requests matter. Let\\'s take an example to illustrate this:\\n\\nSuppose we have 3 buildings (0, 1, 2) and 4 requests: \\n```\\n[0, 1]\\n[1, 2]\\n[0, 1]\\n[2, 0]\\n```\\nIf you look at the minimum of in-degree and out-degree, all buildings have 2 incoming and 2 outgoing requests. So, you might think we can fulfill all 4 requests. But if you try to fulfill the requests in the order they\\'re given, after the first 3 requests, building 0 will have no employees left, so the last request can\\'t be fulfilled.\\n\\nOn the other hand, if you rearrange the requests like this:\\n```\\n[0, 1]\\n[0, 1]\\n[1, 2]\\n[2, 0]\\n```\\nNow, you can fulfill all 4 requests. \\n\\nSo, the problem is more complex than just looking at the minimum of in-degree and out-degree for each node, because the order of the requests matter. Therefore, we need to consider all possible arrangements of the requests, which is why we use a DFS with bit manipulation to generate all subsets of requests, and then check which subset can fulfill the maximum number of requests."
                    },
                    {
                        "username": "jain_06_07",
                        "content": "[@himanshupanwar123](/himanshupanwar123) Sure...\\n3\\n[[0,0], [1,1], [0,0], [2,0], [2,2], [1,1], [2,1], [0,1], [0,1]]\\n\\n[0,0], [1,1], [0,0], [2,2], [1,1] --> ignore these cases as it will not affect anything. worker leaves company and joins again but its request is full filled. Right so ans = 5 till now\\n\\nNow, for remaining requests [2,0], [2,1], [0,1], [0,1]. \\nif you\\'ll draw graph now then you will see\\nfor company 0 you\\'ve one incoming worker from company 2 and two worker leaving for company 1\\nand for company 1 there is only three workers that are coming but no one is leaving So company 1 cannot accept any worker from company 0. \\n\\nSo, it cannot fulfill the request even company 0 has sufficient indegree and outdegree. "
                    },
                    {
                        "username": "himanshupanwar123",
                        "content": "[@jain_06_07](/jain_06_07)  can you elaborate this example a bit i am also stuck at this since [1,1],[1,1] means two employes leaves and again they enter that means 2 request fullfilled."
                    },
                    {
                        "username": "Swastik_Gorai",
                        "content": "[@jain_06_07](/jain_06_07) please explain\\n"
                    },
                    {
                        "username": "jain_06_07",
                        "content": "[@amin_aziz](/amin_aziz) 6 ach/request ? Can you explain"
                    },
                    {
                        "username": "amin_aziz",
                        "content": "[@jain_06_07](/jain_06_07)\\nthere is 6 ach/request, but expected 5?"
                    },
                    {
                        "username": "jain_06_07",
                        "content": "see this case\\n3\\n[[0,0],[1,1],[0,0],[2,0],[2,2],[1,1],[2,1],[0,1],[0,1]]\\nIn this case , Indegree(0) = 1 and outdegree(0) = 2 \\nbut for node 1, there is no outdegree so It we can not take worker from node 0 and hence node 0 can\\'t send a worker also"
                    },
                    {
                        "username": "Rubiya1090",
                        "content": "It\\'s exhausting to see continuous medium & hard problems. Solving the leet code problem is fun when there is a right balance b/w difficulty level."
                    },
                    {
                        "username": "joseph261059",
                        "content": "It is a standard backtracking problem, it is not hard at all"
                    },
                    {
                        "username": "void_8t",
                        "content": "its not that hard, try it you can :)"
                    },
                    {
                        "username": "shubhampr10",
                        "content": "\\nWe\\'ve got other work to do.\\uD83D\\uDE2D"
                    },
                    {
                        "username": "mochy",
                        "content": "Why does brute force work lol"
                    },
                    {
                        "username": "charonme",
                        "content": "constraints are quite low, only 2^20 = 1048576 permutations at worst"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "Because of its \\uD83D\\uDCAA brutal force \\uD83D\\uDCAA, of course."
                    },
                    {
                        "username": "crosslives",
                        "content": "I think this is a Minimum Cost Maximum Flow problem. \\n\\nFirstly, we should calculate # of redundant requests and # of absent requests.\\n\\nThen we can construct a graph, G = <V, E>\\n\\nV = {S, T, Factory_1, Factory_2, ..., Factory_n}\\nE = { (S -> Factories that have redundant requests),\\n         (Facotries that need requests -> T,\\n\\t\\t All other edges provided by function\\n\\t\\t}\\nThe cost of each unit is 1. \\nThen we can calculate  Minimum Cost Maximum Flow of G. \\n\\\\# of requests - minimum cost is answer.\\n\\nI didn\\'t implement it but think it may be a possible solution.\\n\\nIs there more efficient solution for this problem?"
                    },
                    {
                        "username": "cecilia5",
                        "content": "[@f20201214](/f20201214) I posted it on the solutions."
                    },
                    {
                        "username": "f20201214",
                        "content": "[@cecilia5](/cecilia5) Could you share your solution?\\n"
                    },
                    {
                        "username": "VMAtm",
                        "content": "Yeah, thought about it too and was expecting to see this in editorial ("
                    },
                    {
                        "username": "cecilia5",
                        "content": "Minimum cost flow worked, you don\\'t need to add any nodes - just model the cost of a request is -1 and keep canceling negative cycles on the residual graph. "
                    },
                    {
                        "username": "autf",
                        "content": "I nominate this as an easiest `Hard` problem candidate."
                    },
                    {
                        "username": "IamVaibhave53",
                        "content": "Just curious to why this problem has been marked hard, when there are mediums which require more thinking than this one..."
                    }
                ]
            },
            {
                "id": 1952229,
                "content": [
                    {
                        "username": "yabyer1",
                        "content": "So many transfers, office looks like Chelsea"
                    },
                    {
                        "username": "oshok",
                        "content": "\\uD83D\\uDE02"
                    },
                    {
                        "username": "fenil3357",
                        "content": "still finished 12th."
                    },
                    {
                        "username": "mihirrawool1907",
                        "content": "[@subhamsadhukhan95](/subhamsadhukhan95) good pun\\n"
                    },
                    {
                        "username": "subhamsadhukhan95",
                        "content": "good one "
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "I thought the month will start with easy problems."
                    },
                    {
                        "username": "sarthakr10",
                        "content": "ha yr \\n"
                    },
                    {
                        "username": "eduard92",
                        "content": "Its also weekend. So Its O(n^n) psychological damage"
                    },
                    {
                        "username": "suren-yeager",
                        "content": "Just like yesterday\\'s daily challenge, constraints clearly tell us that this problem can be solved by brute force and this doesn\\'t deserve to be hard"
                    },
                    {
                        "username": "amitbansal13",
                        "content": "Leetcode is playing with our emotions now"
                    },
                    {
                        "username": "sanket54",
                        "content": "Why can\\'t we do it using minimum of in-degree and out-degree of the node?"
                    },
                    {
                        "username": "w7089",
                        "content": "have a look at the example `[[0,1],[2,1],[2,0]]` n=3"
                    },
                    {
                        "username": "w7089",
                        "content": "[@bparanj](/bparanj) again, the method by [@sanket54](/sanket54) works and returnsthe correct answer - 3, order doesn\\'t matter here"
                    },
                    {
                        "username": "w7089",
                        "content": "[@bparanj](/bparanj) try to run the below code on [[1,1],[1,1]], n=2:\\n\\n```\\nclass Solution:\\n    def maximumRequests(self, n: int, requests: List[List[int]]) -> int:\\n        from_c = Counter()\\n        to_c = Counter()\\n        for f_t in requests:\\n            f,t = f_t\\n            from_c[f] += 1\\n            to_c[t] += 1\\n        return sum([min(from_c[i], to_c[i]) for i in range(n)])\\n```\\n\\nand you\\'ll see that the solution is 2 and the method by [@sanket54](/sanket54) works\\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "[@himanshupanwar123](/himanshupanwar123) The key point is that a request `[a, b]` means an employee moves from building `a` to building `b`. To fulfill a request, the building `a` must have at least one employee.\\n\\nConsider your example `[1,1],[1,1]`, these two requests mean two employees leave building `1` and re-enter building `1`. Initially, we must have at least two employees in building `1` to fulfill both requests.\\n\\nSuppose building `1` starts with only one employee. We can fulfill the first request `[1,1]` because there\\'s an employee in building `1` who can leave and re-enter. But after this request, there\\'s still only one employee in building `1`. Now if we try to fulfill the second request `[1,1]`, we can\\'t, because we don\\'t have a second employee in building `1` to leave and re-enter. Therefore, in this situation, we can only fulfill one request, not two.\\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "That\\'s a good question, and this approach of using the minimum of in-degree and out-degree of a node seems to make sense at first glance because intuitively, you could fulfill as many requests as the minimum of in-degree and out-degree.\\n\\nHowever, this approach won\\'t work in all cases because the order of the requests matter. Let\\'s take an example to illustrate this:\\n\\nSuppose we have 3 buildings (0, 1, 2) and 4 requests: \\n```\\n[0, 1]\\n[1, 2]\\n[0, 1]\\n[2, 0]\\n```\\nIf you look at the minimum of in-degree and out-degree, all buildings have 2 incoming and 2 outgoing requests. So, you might think we can fulfill all 4 requests. But if you try to fulfill the requests in the order they\\'re given, after the first 3 requests, building 0 will have no employees left, so the last request can\\'t be fulfilled.\\n\\nOn the other hand, if you rearrange the requests like this:\\n```\\n[0, 1]\\n[0, 1]\\n[1, 2]\\n[2, 0]\\n```\\nNow, you can fulfill all 4 requests. \\n\\nSo, the problem is more complex than just looking at the minimum of in-degree and out-degree for each node, because the order of the requests matter. Therefore, we need to consider all possible arrangements of the requests, which is why we use a DFS with bit manipulation to generate all subsets of requests, and then check which subset can fulfill the maximum number of requests."
                    },
                    {
                        "username": "jain_06_07",
                        "content": "[@himanshupanwar123](/himanshupanwar123) Sure...\\n3\\n[[0,0], [1,1], [0,0], [2,0], [2,2], [1,1], [2,1], [0,1], [0,1]]\\n\\n[0,0], [1,1], [0,0], [2,2], [1,1] --> ignore these cases as it will not affect anything. worker leaves company and joins again but its request is full filled. Right so ans = 5 till now\\n\\nNow, for remaining requests [2,0], [2,1], [0,1], [0,1]. \\nif you\\'ll draw graph now then you will see\\nfor company 0 you\\'ve one incoming worker from company 2 and two worker leaving for company 1\\nand for company 1 there is only three workers that are coming but no one is leaving So company 1 cannot accept any worker from company 0. \\n\\nSo, it cannot fulfill the request even company 0 has sufficient indegree and outdegree. "
                    },
                    {
                        "username": "himanshupanwar123",
                        "content": "[@jain_06_07](/jain_06_07)  can you elaborate this example a bit i am also stuck at this since [1,1],[1,1] means two employes leaves and again they enter that means 2 request fullfilled."
                    },
                    {
                        "username": "Swastik_Gorai",
                        "content": "[@jain_06_07](/jain_06_07) please explain\\n"
                    },
                    {
                        "username": "jain_06_07",
                        "content": "[@amin_aziz](/amin_aziz) 6 ach/request ? Can you explain"
                    },
                    {
                        "username": "amin_aziz",
                        "content": "[@jain_06_07](/jain_06_07)\\nthere is 6 ach/request, but expected 5?"
                    },
                    {
                        "username": "jain_06_07",
                        "content": "see this case\\n3\\n[[0,0],[1,1],[0,0],[2,0],[2,2],[1,1],[2,1],[0,1],[0,1]]\\nIn this case , Indegree(0) = 1 and outdegree(0) = 2 \\nbut for node 1, there is no outdegree so It we can not take worker from node 0 and hence node 0 can\\'t send a worker also"
                    },
                    {
                        "username": "Rubiya1090",
                        "content": "It\\'s exhausting to see continuous medium & hard problems. Solving the leet code problem is fun when there is a right balance b/w difficulty level."
                    },
                    {
                        "username": "joseph261059",
                        "content": "It is a standard backtracking problem, it is not hard at all"
                    },
                    {
                        "username": "void_8t",
                        "content": "its not that hard, try it you can :)"
                    },
                    {
                        "username": "shubhampr10",
                        "content": "\\nWe\\'ve got other work to do.\\uD83D\\uDE2D"
                    },
                    {
                        "username": "mochy",
                        "content": "Why does brute force work lol"
                    },
                    {
                        "username": "charonme",
                        "content": "constraints are quite low, only 2^20 = 1048576 permutations at worst"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "Because of its \\uD83D\\uDCAA brutal force \\uD83D\\uDCAA, of course."
                    },
                    {
                        "username": "crosslives",
                        "content": "I think this is a Minimum Cost Maximum Flow problem. \\n\\nFirstly, we should calculate # of redundant requests and # of absent requests.\\n\\nThen we can construct a graph, G = <V, E>\\n\\nV = {S, T, Factory_1, Factory_2, ..., Factory_n}\\nE = { (S -> Factories that have redundant requests),\\n         (Facotries that need requests -> T,\\n\\t\\t All other edges provided by function\\n\\t\\t}\\nThe cost of each unit is 1. \\nThen we can calculate  Minimum Cost Maximum Flow of G. \\n\\\\# of requests - minimum cost is answer.\\n\\nI didn\\'t implement it but think it may be a possible solution.\\n\\nIs there more efficient solution for this problem?"
                    },
                    {
                        "username": "cecilia5",
                        "content": "[@f20201214](/f20201214) I posted it on the solutions."
                    },
                    {
                        "username": "f20201214",
                        "content": "[@cecilia5](/cecilia5) Could you share your solution?\\n"
                    },
                    {
                        "username": "VMAtm",
                        "content": "Yeah, thought about it too and was expecting to see this in editorial ("
                    },
                    {
                        "username": "cecilia5",
                        "content": "Minimum cost flow worked, you don\\'t need to add any nodes - just model the cost of a request is -1 and keep canceling negative cycles on the residual graph. "
                    },
                    {
                        "username": "autf",
                        "content": "I nominate this as an easiest `Hard` problem candidate."
                    },
                    {
                        "username": "IamVaibhave53",
                        "content": "Just curious to why this problem has been marked hard, when there are mediums which require more thinking than this one..."
                    }
                ]
            },
            {
                "id": 1568452,
                "content": [
                    {
                        "username": "yabyer1",
                        "content": "So many transfers, office looks like Chelsea"
                    },
                    {
                        "username": "oshok",
                        "content": "\\uD83D\\uDE02"
                    },
                    {
                        "username": "fenil3357",
                        "content": "still finished 12th."
                    },
                    {
                        "username": "mihirrawool1907",
                        "content": "[@subhamsadhukhan95](/subhamsadhukhan95) good pun\\n"
                    },
                    {
                        "username": "subhamsadhukhan95",
                        "content": "good one "
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "I thought the month will start with easy problems."
                    },
                    {
                        "username": "sarthakr10",
                        "content": "ha yr \\n"
                    },
                    {
                        "username": "eduard92",
                        "content": "Its also weekend. So Its O(n^n) psychological damage"
                    },
                    {
                        "username": "suren-yeager",
                        "content": "Just like yesterday\\'s daily challenge, constraints clearly tell us that this problem can be solved by brute force and this doesn\\'t deserve to be hard"
                    },
                    {
                        "username": "amitbansal13",
                        "content": "Leetcode is playing with our emotions now"
                    },
                    {
                        "username": "sanket54",
                        "content": "Why can\\'t we do it using minimum of in-degree and out-degree of the node?"
                    },
                    {
                        "username": "w7089",
                        "content": "have a look at the example `[[0,1],[2,1],[2,0]]` n=3"
                    },
                    {
                        "username": "w7089",
                        "content": "[@bparanj](/bparanj) again, the method by [@sanket54](/sanket54) works and returnsthe correct answer - 3, order doesn\\'t matter here"
                    },
                    {
                        "username": "w7089",
                        "content": "[@bparanj](/bparanj) try to run the below code on [[1,1],[1,1]], n=2:\\n\\n```\\nclass Solution:\\n    def maximumRequests(self, n: int, requests: List[List[int]]) -> int:\\n        from_c = Counter()\\n        to_c = Counter()\\n        for f_t in requests:\\n            f,t = f_t\\n            from_c[f] += 1\\n            to_c[t] += 1\\n        return sum([min(from_c[i], to_c[i]) for i in range(n)])\\n```\\n\\nand you\\'ll see that the solution is 2 and the method by [@sanket54](/sanket54) works\\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "[@himanshupanwar123](/himanshupanwar123) The key point is that a request `[a, b]` means an employee moves from building `a` to building `b`. To fulfill a request, the building `a` must have at least one employee.\\n\\nConsider your example `[1,1],[1,1]`, these two requests mean two employees leave building `1` and re-enter building `1`. Initially, we must have at least two employees in building `1` to fulfill both requests.\\n\\nSuppose building `1` starts with only one employee. We can fulfill the first request `[1,1]` because there\\'s an employee in building `1` who can leave and re-enter. But after this request, there\\'s still only one employee in building `1`. Now if we try to fulfill the second request `[1,1]`, we can\\'t, because we don\\'t have a second employee in building `1` to leave and re-enter. Therefore, in this situation, we can only fulfill one request, not two.\\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "That\\'s a good question, and this approach of using the minimum of in-degree and out-degree of a node seems to make sense at first glance because intuitively, you could fulfill as many requests as the minimum of in-degree and out-degree.\\n\\nHowever, this approach won\\'t work in all cases because the order of the requests matter. Let\\'s take an example to illustrate this:\\n\\nSuppose we have 3 buildings (0, 1, 2) and 4 requests: \\n```\\n[0, 1]\\n[1, 2]\\n[0, 1]\\n[2, 0]\\n```\\nIf you look at the minimum of in-degree and out-degree, all buildings have 2 incoming and 2 outgoing requests. So, you might think we can fulfill all 4 requests. But if you try to fulfill the requests in the order they\\'re given, after the first 3 requests, building 0 will have no employees left, so the last request can\\'t be fulfilled.\\n\\nOn the other hand, if you rearrange the requests like this:\\n```\\n[0, 1]\\n[0, 1]\\n[1, 2]\\n[2, 0]\\n```\\nNow, you can fulfill all 4 requests. \\n\\nSo, the problem is more complex than just looking at the minimum of in-degree and out-degree for each node, because the order of the requests matter. Therefore, we need to consider all possible arrangements of the requests, which is why we use a DFS with bit manipulation to generate all subsets of requests, and then check which subset can fulfill the maximum number of requests."
                    },
                    {
                        "username": "jain_06_07",
                        "content": "[@himanshupanwar123](/himanshupanwar123) Sure...\\n3\\n[[0,0], [1,1], [0,0], [2,0], [2,2], [1,1], [2,1], [0,1], [0,1]]\\n\\n[0,0], [1,1], [0,0], [2,2], [1,1] --> ignore these cases as it will not affect anything. worker leaves company and joins again but its request is full filled. Right so ans = 5 till now\\n\\nNow, for remaining requests [2,0], [2,1], [0,1], [0,1]. \\nif you\\'ll draw graph now then you will see\\nfor company 0 you\\'ve one incoming worker from company 2 and two worker leaving for company 1\\nand for company 1 there is only three workers that are coming but no one is leaving So company 1 cannot accept any worker from company 0. \\n\\nSo, it cannot fulfill the request even company 0 has sufficient indegree and outdegree. "
                    },
                    {
                        "username": "himanshupanwar123",
                        "content": "[@jain_06_07](/jain_06_07)  can you elaborate this example a bit i am also stuck at this since [1,1],[1,1] means two employes leaves and again they enter that means 2 request fullfilled."
                    },
                    {
                        "username": "Swastik_Gorai",
                        "content": "[@jain_06_07](/jain_06_07) please explain\\n"
                    },
                    {
                        "username": "jain_06_07",
                        "content": "[@amin_aziz](/amin_aziz) 6 ach/request ? Can you explain"
                    },
                    {
                        "username": "amin_aziz",
                        "content": "[@jain_06_07](/jain_06_07)\\nthere is 6 ach/request, but expected 5?"
                    },
                    {
                        "username": "jain_06_07",
                        "content": "see this case\\n3\\n[[0,0],[1,1],[0,0],[2,0],[2,2],[1,1],[2,1],[0,1],[0,1]]\\nIn this case , Indegree(0) = 1 and outdegree(0) = 2 \\nbut for node 1, there is no outdegree so It we can not take worker from node 0 and hence node 0 can\\'t send a worker also"
                    },
                    {
                        "username": "Rubiya1090",
                        "content": "It\\'s exhausting to see continuous medium & hard problems. Solving the leet code problem is fun when there is a right balance b/w difficulty level."
                    },
                    {
                        "username": "joseph261059",
                        "content": "It is a standard backtracking problem, it is not hard at all"
                    },
                    {
                        "username": "void_8t",
                        "content": "its not that hard, try it you can :)"
                    },
                    {
                        "username": "shubhampr10",
                        "content": "\\nWe\\'ve got other work to do.\\uD83D\\uDE2D"
                    },
                    {
                        "username": "mochy",
                        "content": "Why does brute force work lol"
                    },
                    {
                        "username": "charonme",
                        "content": "constraints are quite low, only 2^20 = 1048576 permutations at worst"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "Because of its \\uD83D\\uDCAA brutal force \\uD83D\\uDCAA, of course."
                    },
                    {
                        "username": "crosslives",
                        "content": "I think this is a Minimum Cost Maximum Flow problem. \\n\\nFirstly, we should calculate # of redundant requests and # of absent requests.\\n\\nThen we can construct a graph, G = <V, E>\\n\\nV = {S, T, Factory_1, Factory_2, ..., Factory_n}\\nE = { (S -> Factories that have redundant requests),\\n         (Facotries that need requests -> T,\\n\\t\\t All other edges provided by function\\n\\t\\t}\\nThe cost of each unit is 1. \\nThen we can calculate  Minimum Cost Maximum Flow of G. \\n\\\\# of requests - minimum cost is answer.\\n\\nI didn\\'t implement it but think it may be a possible solution.\\n\\nIs there more efficient solution for this problem?"
                    },
                    {
                        "username": "cecilia5",
                        "content": "[@f20201214](/f20201214) I posted it on the solutions."
                    },
                    {
                        "username": "f20201214",
                        "content": "[@cecilia5](/cecilia5) Could you share your solution?\\n"
                    },
                    {
                        "username": "VMAtm",
                        "content": "Yeah, thought about it too and was expecting to see this in editorial ("
                    },
                    {
                        "username": "cecilia5",
                        "content": "Minimum cost flow worked, you don\\'t need to add any nodes - just model the cost of a request is -1 and keep canceling negative cycles on the residual graph. "
                    },
                    {
                        "username": "autf",
                        "content": "I nominate this as an easiest `Hard` problem candidate."
                    },
                    {
                        "username": "IamVaibhave53",
                        "content": "Just curious to why this problem has been marked hard, when there are mediums which require more thinking than this one..."
                    }
                ]
            },
            {
                "id": 1952336,
                "content": [
                    {
                        "username": "yabyer1",
                        "content": "So many transfers, office looks like Chelsea"
                    },
                    {
                        "username": "oshok",
                        "content": "\\uD83D\\uDE02"
                    },
                    {
                        "username": "fenil3357",
                        "content": "still finished 12th."
                    },
                    {
                        "username": "mihirrawool1907",
                        "content": "[@subhamsadhukhan95](/subhamsadhukhan95) good pun\\n"
                    },
                    {
                        "username": "subhamsadhukhan95",
                        "content": "good one "
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "I thought the month will start with easy problems."
                    },
                    {
                        "username": "sarthakr10",
                        "content": "ha yr \\n"
                    },
                    {
                        "username": "eduard92",
                        "content": "Its also weekend. So Its O(n^n) psychological damage"
                    },
                    {
                        "username": "suren-yeager",
                        "content": "Just like yesterday\\'s daily challenge, constraints clearly tell us that this problem can be solved by brute force and this doesn\\'t deserve to be hard"
                    },
                    {
                        "username": "amitbansal13",
                        "content": "Leetcode is playing with our emotions now"
                    },
                    {
                        "username": "sanket54",
                        "content": "Why can\\'t we do it using minimum of in-degree and out-degree of the node?"
                    },
                    {
                        "username": "w7089",
                        "content": "have a look at the example `[[0,1],[2,1],[2,0]]` n=3"
                    },
                    {
                        "username": "w7089",
                        "content": "[@bparanj](/bparanj) again, the method by [@sanket54](/sanket54) works and returnsthe correct answer - 3, order doesn\\'t matter here"
                    },
                    {
                        "username": "w7089",
                        "content": "[@bparanj](/bparanj) try to run the below code on [[1,1],[1,1]], n=2:\\n\\n```\\nclass Solution:\\n    def maximumRequests(self, n: int, requests: List[List[int]]) -> int:\\n        from_c = Counter()\\n        to_c = Counter()\\n        for f_t in requests:\\n            f,t = f_t\\n            from_c[f] += 1\\n            to_c[t] += 1\\n        return sum([min(from_c[i], to_c[i]) for i in range(n)])\\n```\\n\\nand you\\'ll see that the solution is 2 and the method by [@sanket54](/sanket54) works\\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "[@himanshupanwar123](/himanshupanwar123) The key point is that a request `[a, b]` means an employee moves from building `a` to building `b`. To fulfill a request, the building `a` must have at least one employee.\\n\\nConsider your example `[1,1],[1,1]`, these two requests mean two employees leave building `1` and re-enter building `1`. Initially, we must have at least two employees in building `1` to fulfill both requests.\\n\\nSuppose building `1` starts with only one employee. We can fulfill the first request `[1,1]` because there\\'s an employee in building `1` who can leave and re-enter. But after this request, there\\'s still only one employee in building `1`. Now if we try to fulfill the second request `[1,1]`, we can\\'t, because we don\\'t have a second employee in building `1` to leave and re-enter. Therefore, in this situation, we can only fulfill one request, not two.\\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "That\\'s a good question, and this approach of using the minimum of in-degree and out-degree of a node seems to make sense at first glance because intuitively, you could fulfill as many requests as the minimum of in-degree and out-degree.\\n\\nHowever, this approach won\\'t work in all cases because the order of the requests matter. Let\\'s take an example to illustrate this:\\n\\nSuppose we have 3 buildings (0, 1, 2) and 4 requests: \\n```\\n[0, 1]\\n[1, 2]\\n[0, 1]\\n[2, 0]\\n```\\nIf you look at the minimum of in-degree and out-degree, all buildings have 2 incoming and 2 outgoing requests. So, you might think we can fulfill all 4 requests. But if you try to fulfill the requests in the order they\\'re given, after the first 3 requests, building 0 will have no employees left, so the last request can\\'t be fulfilled.\\n\\nOn the other hand, if you rearrange the requests like this:\\n```\\n[0, 1]\\n[0, 1]\\n[1, 2]\\n[2, 0]\\n```\\nNow, you can fulfill all 4 requests. \\n\\nSo, the problem is more complex than just looking at the minimum of in-degree and out-degree for each node, because the order of the requests matter. Therefore, we need to consider all possible arrangements of the requests, which is why we use a DFS with bit manipulation to generate all subsets of requests, and then check which subset can fulfill the maximum number of requests."
                    },
                    {
                        "username": "jain_06_07",
                        "content": "[@himanshupanwar123](/himanshupanwar123) Sure...\\n3\\n[[0,0], [1,1], [0,0], [2,0], [2,2], [1,1], [2,1], [0,1], [0,1]]\\n\\n[0,0], [1,1], [0,0], [2,2], [1,1] --> ignore these cases as it will not affect anything. worker leaves company and joins again but its request is full filled. Right so ans = 5 till now\\n\\nNow, for remaining requests [2,0], [2,1], [0,1], [0,1]. \\nif you\\'ll draw graph now then you will see\\nfor company 0 you\\'ve one incoming worker from company 2 and two worker leaving for company 1\\nand for company 1 there is only three workers that are coming but no one is leaving So company 1 cannot accept any worker from company 0. \\n\\nSo, it cannot fulfill the request even company 0 has sufficient indegree and outdegree. "
                    },
                    {
                        "username": "himanshupanwar123",
                        "content": "[@jain_06_07](/jain_06_07)  can you elaborate this example a bit i am also stuck at this since [1,1],[1,1] means two employes leaves and again they enter that means 2 request fullfilled."
                    },
                    {
                        "username": "Swastik_Gorai",
                        "content": "[@jain_06_07](/jain_06_07) please explain\\n"
                    },
                    {
                        "username": "jain_06_07",
                        "content": "[@amin_aziz](/amin_aziz) 6 ach/request ? Can you explain"
                    },
                    {
                        "username": "amin_aziz",
                        "content": "[@jain_06_07](/jain_06_07)\\nthere is 6 ach/request, but expected 5?"
                    },
                    {
                        "username": "jain_06_07",
                        "content": "see this case\\n3\\n[[0,0],[1,1],[0,0],[2,0],[2,2],[1,1],[2,1],[0,1],[0,1]]\\nIn this case , Indegree(0) = 1 and outdegree(0) = 2 \\nbut for node 1, there is no outdegree so It we can not take worker from node 0 and hence node 0 can\\'t send a worker also"
                    },
                    {
                        "username": "Rubiya1090",
                        "content": "It\\'s exhausting to see continuous medium & hard problems. Solving the leet code problem is fun when there is a right balance b/w difficulty level."
                    },
                    {
                        "username": "joseph261059",
                        "content": "It is a standard backtracking problem, it is not hard at all"
                    },
                    {
                        "username": "void_8t",
                        "content": "its not that hard, try it you can :)"
                    },
                    {
                        "username": "shubhampr10",
                        "content": "\\nWe\\'ve got other work to do.\\uD83D\\uDE2D"
                    },
                    {
                        "username": "mochy",
                        "content": "Why does brute force work lol"
                    },
                    {
                        "username": "charonme",
                        "content": "constraints are quite low, only 2^20 = 1048576 permutations at worst"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "Because of its \\uD83D\\uDCAA brutal force \\uD83D\\uDCAA, of course."
                    },
                    {
                        "username": "crosslives",
                        "content": "I think this is a Minimum Cost Maximum Flow problem. \\n\\nFirstly, we should calculate # of redundant requests and # of absent requests.\\n\\nThen we can construct a graph, G = <V, E>\\n\\nV = {S, T, Factory_1, Factory_2, ..., Factory_n}\\nE = { (S -> Factories that have redundant requests),\\n         (Facotries that need requests -> T,\\n\\t\\t All other edges provided by function\\n\\t\\t}\\nThe cost of each unit is 1. \\nThen we can calculate  Minimum Cost Maximum Flow of G. \\n\\\\# of requests - minimum cost is answer.\\n\\nI didn\\'t implement it but think it may be a possible solution.\\n\\nIs there more efficient solution for this problem?"
                    },
                    {
                        "username": "cecilia5",
                        "content": "[@f20201214](/f20201214) I posted it on the solutions."
                    },
                    {
                        "username": "f20201214",
                        "content": "[@cecilia5](/cecilia5) Could you share your solution?\\n"
                    },
                    {
                        "username": "VMAtm",
                        "content": "Yeah, thought about it too and was expecting to see this in editorial ("
                    },
                    {
                        "username": "cecilia5",
                        "content": "Minimum cost flow worked, you don\\'t need to add any nodes - just model the cost of a request is -1 and keep canceling negative cycles on the residual graph. "
                    },
                    {
                        "username": "autf",
                        "content": "I nominate this as an easiest `Hard` problem candidate."
                    },
                    {
                        "username": "IamVaibhave53",
                        "content": "Just curious to why this problem has been marked hard, when there are mediums which require more thinking than this one..."
                    }
                ]
            },
            {
                "id": 1574992,
                "content": [
                    {
                        "username": "yabyer1",
                        "content": "So many transfers, office looks like Chelsea"
                    },
                    {
                        "username": "oshok",
                        "content": "\\uD83D\\uDE02"
                    },
                    {
                        "username": "fenil3357",
                        "content": "still finished 12th."
                    },
                    {
                        "username": "mihirrawool1907",
                        "content": "[@subhamsadhukhan95](/subhamsadhukhan95) good pun\\n"
                    },
                    {
                        "username": "subhamsadhukhan95",
                        "content": "good one "
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "I thought the month will start with easy problems."
                    },
                    {
                        "username": "sarthakr10",
                        "content": "ha yr \\n"
                    },
                    {
                        "username": "eduard92",
                        "content": "Its also weekend. So Its O(n^n) psychological damage"
                    },
                    {
                        "username": "suren-yeager",
                        "content": "Just like yesterday\\'s daily challenge, constraints clearly tell us that this problem can be solved by brute force and this doesn\\'t deserve to be hard"
                    },
                    {
                        "username": "amitbansal13",
                        "content": "Leetcode is playing with our emotions now"
                    },
                    {
                        "username": "sanket54",
                        "content": "Why can\\'t we do it using minimum of in-degree and out-degree of the node?"
                    },
                    {
                        "username": "w7089",
                        "content": "have a look at the example `[[0,1],[2,1],[2,0]]` n=3"
                    },
                    {
                        "username": "w7089",
                        "content": "[@bparanj](/bparanj) again, the method by [@sanket54](/sanket54) works and returnsthe correct answer - 3, order doesn\\'t matter here"
                    },
                    {
                        "username": "w7089",
                        "content": "[@bparanj](/bparanj) try to run the below code on [[1,1],[1,1]], n=2:\\n\\n```\\nclass Solution:\\n    def maximumRequests(self, n: int, requests: List[List[int]]) -> int:\\n        from_c = Counter()\\n        to_c = Counter()\\n        for f_t in requests:\\n            f,t = f_t\\n            from_c[f] += 1\\n            to_c[t] += 1\\n        return sum([min(from_c[i], to_c[i]) for i in range(n)])\\n```\\n\\nand you\\'ll see that the solution is 2 and the method by [@sanket54](/sanket54) works\\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "[@himanshupanwar123](/himanshupanwar123) The key point is that a request `[a, b]` means an employee moves from building `a` to building `b`. To fulfill a request, the building `a` must have at least one employee.\\n\\nConsider your example `[1,1],[1,1]`, these two requests mean two employees leave building `1` and re-enter building `1`. Initially, we must have at least two employees in building `1` to fulfill both requests.\\n\\nSuppose building `1` starts with only one employee. We can fulfill the first request `[1,1]` because there\\'s an employee in building `1` who can leave and re-enter. But after this request, there\\'s still only one employee in building `1`. Now if we try to fulfill the second request `[1,1]`, we can\\'t, because we don\\'t have a second employee in building `1` to leave and re-enter. Therefore, in this situation, we can only fulfill one request, not two.\\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "That\\'s a good question, and this approach of using the minimum of in-degree and out-degree of a node seems to make sense at first glance because intuitively, you could fulfill as many requests as the minimum of in-degree and out-degree.\\n\\nHowever, this approach won\\'t work in all cases because the order of the requests matter. Let\\'s take an example to illustrate this:\\n\\nSuppose we have 3 buildings (0, 1, 2) and 4 requests: \\n```\\n[0, 1]\\n[1, 2]\\n[0, 1]\\n[2, 0]\\n```\\nIf you look at the minimum of in-degree and out-degree, all buildings have 2 incoming and 2 outgoing requests. So, you might think we can fulfill all 4 requests. But if you try to fulfill the requests in the order they\\'re given, after the first 3 requests, building 0 will have no employees left, so the last request can\\'t be fulfilled.\\n\\nOn the other hand, if you rearrange the requests like this:\\n```\\n[0, 1]\\n[0, 1]\\n[1, 2]\\n[2, 0]\\n```\\nNow, you can fulfill all 4 requests. \\n\\nSo, the problem is more complex than just looking at the minimum of in-degree and out-degree for each node, because the order of the requests matter. Therefore, we need to consider all possible arrangements of the requests, which is why we use a DFS with bit manipulation to generate all subsets of requests, and then check which subset can fulfill the maximum number of requests."
                    },
                    {
                        "username": "jain_06_07",
                        "content": "[@himanshupanwar123](/himanshupanwar123) Sure...\\n3\\n[[0,0], [1,1], [0,0], [2,0], [2,2], [1,1], [2,1], [0,1], [0,1]]\\n\\n[0,0], [1,1], [0,0], [2,2], [1,1] --> ignore these cases as it will not affect anything. worker leaves company and joins again but its request is full filled. Right so ans = 5 till now\\n\\nNow, for remaining requests [2,0], [2,1], [0,1], [0,1]. \\nif you\\'ll draw graph now then you will see\\nfor company 0 you\\'ve one incoming worker from company 2 and two worker leaving for company 1\\nand for company 1 there is only three workers that are coming but no one is leaving So company 1 cannot accept any worker from company 0. \\n\\nSo, it cannot fulfill the request even company 0 has sufficient indegree and outdegree. "
                    },
                    {
                        "username": "himanshupanwar123",
                        "content": "[@jain_06_07](/jain_06_07)  can you elaborate this example a bit i am also stuck at this since [1,1],[1,1] means two employes leaves and again they enter that means 2 request fullfilled."
                    },
                    {
                        "username": "Swastik_Gorai",
                        "content": "[@jain_06_07](/jain_06_07) please explain\\n"
                    },
                    {
                        "username": "jain_06_07",
                        "content": "[@amin_aziz](/amin_aziz) 6 ach/request ? Can you explain"
                    },
                    {
                        "username": "amin_aziz",
                        "content": "[@jain_06_07](/jain_06_07)\\nthere is 6 ach/request, but expected 5?"
                    },
                    {
                        "username": "jain_06_07",
                        "content": "see this case\\n3\\n[[0,0],[1,1],[0,0],[2,0],[2,2],[1,1],[2,1],[0,1],[0,1]]\\nIn this case , Indegree(0) = 1 and outdegree(0) = 2 \\nbut for node 1, there is no outdegree so It we can not take worker from node 0 and hence node 0 can\\'t send a worker also"
                    },
                    {
                        "username": "Rubiya1090",
                        "content": "It\\'s exhausting to see continuous medium & hard problems. Solving the leet code problem is fun when there is a right balance b/w difficulty level."
                    },
                    {
                        "username": "joseph261059",
                        "content": "It is a standard backtracking problem, it is not hard at all"
                    },
                    {
                        "username": "void_8t",
                        "content": "its not that hard, try it you can :)"
                    },
                    {
                        "username": "shubhampr10",
                        "content": "\\nWe\\'ve got other work to do.\\uD83D\\uDE2D"
                    },
                    {
                        "username": "mochy",
                        "content": "Why does brute force work lol"
                    },
                    {
                        "username": "charonme",
                        "content": "constraints are quite low, only 2^20 = 1048576 permutations at worst"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "Because of its \\uD83D\\uDCAA brutal force \\uD83D\\uDCAA, of course."
                    },
                    {
                        "username": "crosslives",
                        "content": "I think this is a Minimum Cost Maximum Flow problem. \\n\\nFirstly, we should calculate # of redundant requests and # of absent requests.\\n\\nThen we can construct a graph, G = <V, E>\\n\\nV = {S, T, Factory_1, Factory_2, ..., Factory_n}\\nE = { (S -> Factories that have redundant requests),\\n         (Facotries that need requests -> T,\\n\\t\\t All other edges provided by function\\n\\t\\t}\\nThe cost of each unit is 1. \\nThen we can calculate  Minimum Cost Maximum Flow of G. \\n\\\\# of requests - minimum cost is answer.\\n\\nI didn\\'t implement it but think it may be a possible solution.\\n\\nIs there more efficient solution for this problem?"
                    },
                    {
                        "username": "cecilia5",
                        "content": "[@f20201214](/f20201214) I posted it on the solutions."
                    },
                    {
                        "username": "f20201214",
                        "content": "[@cecilia5](/cecilia5) Could you share your solution?\\n"
                    },
                    {
                        "username": "VMAtm",
                        "content": "Yeah, thought about it too and was expecting to see this in editorial ("
                    },
                    {
                        "username": "cecilia5",
                        "content": "Minimum cost flow worked, you don\\'t need to add any nodes - just model the cost of a request is -1 and keep canceling negative cycles on the residual graph. "
                    },
                    {
                        "username": "autf",
                        "content": "I nominate this as an easiest `Hard` problem candidate."
                    },
                    {
                        "username": "IamVaibhave53",
                        "content": "Just curious to why this problem has been marked hard, when there are mediums which require more thinking than this one..."
                    }
                ]
            },
            {
                "id": 1952228,
                "content": [
                    {
                        "username": "yabyer1",
                        "content": "So many transfers, office looks like Chelsea"
                    },
                    {
                        "username": "oshok",
                        "content": "\\uD83D\\uDE02"
                    },
                    {
                        "username": "fenil3357",
                        "content": "still finished 12th."
                    },
                    {
                        "username": "mihirrawool1907",
                        "content": "[@subhamsadhukhan95](/subhamsadhukhan95) good pun\\n"
                    },
                    {
                        "username": "subhamsadhukhan95",
                        "content": "good one "
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "I thought the month will start with easy problems."
                    },
                    {
                        "username": "sarthakr10",
                        "content": "ha yr \\n"
                    },
                    {
                        "username": "eduard92",
                        "content": "Its also weekend. So Its O(n^n) psychological damage"
                    },
                    {
                        "username": "suren-yeager",
                        "content": "Just like yesterday\\'s daily challenge, constraints clearly tell us that this problem can be solved by brute force and this doesn\\'t deserve to be hard"
                    },
                    {
                        "username": "amitbansal13",
                        "content": "Leetcode is playing with our emotions now"
                    },
                    {
                        "username": "sanket54",
                        "content": "Why can\\'t we do it using minimum of in-degree and out-degree of the node?"
                    },
                    {
                        "username": "w7089",
                        "content": "have a look at the example `[[0,1],[2,1],[2,0]]` n=3"
                    },
                    {
                        "username": "w7089",
                        "content": "[@bparanj](/bparanj) again, the method by [@sanket54](/sanket54) works and returnsthe correct answer - 3, order doesn\\'t matter here"
                    },
                    {
                        "username": "w7089",
                        "content": "[@bparanj](/bparanj) try to run the below code on [[1,1],[1,1]], n=2:\\n\\n```\\nclass Solution:\\n    def maximumRequests(self, n: int, requests: List[List[int]]) -> int:\\n        from_c = Counter()\\n        to_c = Counter()\\n        for f_t in requests:\\n            f,t = f_t\\n            from_c[f] += 1\\n            to_c[t] += 1\\n        return sum([min(from_c[i], to_c[i]) for i in range(n)])\\n```\\n\\nand you\\'ll see that the solution is 2 and the method by [@sanket54](/sanket54) works\\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "[@himanshupanwar123](/himanshupanwar123) The key point is that a request `[a, b]` means an employee moves from building `a` to building `b`. To fulfill a request, the building `a` must have at least one employee.\\n\\nConsider your example `[1,1],[1,1]`, these two requests mean two employees leave building `1` and re-enter building `1`. Initially, we must have at least two employees in building `1` to fulfill both requests.\\n\\nSuppose building `1` starts with only one employee. We can fulfill the first request `[1,1]` because there\\'s an employee in building `1` who can leave and re-enter. But after this request, there\\'s still only one employee in building `1`. Now if we try to fulfill the second request `[1,1]`, we can\\'t, because we don\\'t have a second employee in building `1` to leave and re-enter. Therefore, in this situation, we can only fulfill one request, not two.\\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "That\\'s a good question, and this approach of using the minimum of in-degree and out-degree of a node seems to make sense at first glance because intuitively, you could fulfill as many requests as the minimum of in-degree and out-degree.\\n\\nHowever, this approach won\\'t work in all cases because the order of the requests matter. Let\\'s take an example to illustrate this:\\n\\nSuppose we have 3 buildings (0, 1, 2) and 4 requests: \\n```\\n[0, 1]\\n[1, 2]\\n[0, 1]\\n[2, 0]\\n```\\nIf you look at the minimum of in-degree and out-degree, all buildings have 2 incoming and 2 outgoing requests. So, you might think we can fulfill all 4 requests. But if you try to fulfill the requests in the order they\\'re given, after the first 3 requests, building 0 will have no employees left, so the last request can\\'t be fulfilled.\\n\\nOn the other hand, if you rearrange the requests like this:\\n```\\n[0, 1]\\n[0, 1]\\n[1, 2]\\n[2, 0]\\n```\\nNow, you can fulfill all 4 requests. \\n\\nSo, the problem is more complex than just looking at the minimum of in-degree and out-degree for each node, because the order of the requests matter. Therefore, we need to consider all possible arrangements of the requests, which is why we use a DFS with bit manipulation to generate all subsets of requests, and then check which subset can fulfill the maximum number of requests."
                    },
                    {
                        "username": "jain_06_07",
                        "content": "[@himanshupanwar123](/himanshupanwar123) Sure...\\n3\\n[[0,0], [1,1], [0,0], [2,0], [2,2], [1,1], [2,1], [0,1], [0,1]]\\n\\n[0,0], [1,1], [0,0], [2,2], [1,1] --> ignore these cases as it will not affect anything. worker leaves company and joins again but its request is full filled. Right so ans = 5 till now\\n\\nNow, for remaining requests [2,0], [2,1], [0,1], [0,1]. \\nif you\\'ll draw graph now then you will see\\nfor company 0 you\\'ve one incoming worker from company 2 and two worker leaving for company 1\\nand for company 1 there is only three workers that are coming but no one is leaving So company 1 cannot accept any worker from company 0. \\n\\nSo, it cannot fulfill the request even company 0 has sufficient indegree and outdegree. "
                    },
                    {
                        "username": "himanshupanwar123",
                        "content": "[@jain_06_07](/jain_06_07)  can you elaborate this example a bit i am also stuck at this since [1,1],[1,1] means two employes leaves and again they enter that means 2 request fullfilled."
                    },
                    {
                        "username": "Swastik_Gorai",
                        "content": "[@jain_06_07](/jain_06_07) please explain\\n"
                    },
                    {
                        "username": "jain_06_07",
                        "content": "[@amin_aziz](/amin_aziz) 6 ach/request ? Can you explain"
                    },
                    {
                        "username": "amin_aziz",
                        "content": "[@jain_06_07](/jain_06_07)\\nthere is 6 ach/request, but expected 5?"
                    },
                    {
                        "username": "jain_06_07",
                        "content": "see this case\\n3\\n[[0,0],[1,1],[0,0],[2,0],[2,2],[1,1],[2,1],[0,1],[0,1]]\\nIn this case , Indegree(0) = 1 and outdegree(0) = 2 \\nbut for node 1, there is no outdegree so It we can not take worker from node 0 and hence node 0 can\\'t send a worker also"
                    },
                    {
                        "username": "Rubiya1090",
                        "content": "It\\'s exhausting to see continuous medium & hard problems. Solving the leet code problem is fun when there is a right balance b/w difficulty level."
                    },
                    {
                        "username": "joseph261059",
                        "content": "It is a standard backtracking problem, it is not hard at all"
                    },
                    {
                        "username": "void_8t",
                        "content": "its not that hard, try it you can :)"
                    },
                    {
                        "username": "shubhampr10",
                        "content": "\\nWe\\'ve got other work to do.\\uD83D\\uDE2D"
                    },
                    {
                        "username": "mochy",
                        "content": "Why does brute force work lol"
                    },
                    {
                        "username": "charonme",
                        "content": "constraints are quite low, only 2^20 = 1048576 permutations at worst"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "Because of its \\uD83D\\uDCAA brutal force \\uD83D\\uDCAA, of course."
                    },
                    {
                        "username": "crosslives",
                        "content": "I think this is a Minimum Cost Maximum Flow problem. \\n\\nFirstly, we should calculate # of redundant requests and # of absent requests.\\n\\nThen we can construct a graph, G = <V, E>\\n\\nV = {S, T, Factory_1, Factory_2, ..., Factory_n}\\nE = { (S -> Factories that have redundant requests),\\n         (Facotries that need requests -> T,\\n\\t\\t All other edges provided by function\\n\\t\\t}\\nThe cost of each unit is 1. \\nThen we can calculate  Minimum Cost Maximum Flow of G. \\n\\\\# of requests - minimum cost is answer.\\n\\nI didn\\'t implement it but think it may be a possible solution.\\n\\nIs there more efficient solution for this problem?"
                    },
                    {
                        "username": "cecilia5",
                        "content": "[@f20201214](/f20201214) I posted it on the solutions."
                    },
                    {
                        "username": "f20201214",
                        "content": "[@cecilia5](/cecilia5) Could you share your solution?\\n"
                    },
                    {
                        "username": "VMAtm",
                        "content": "Yeah, thought about it too and was expecting to see this in editorial ("
                    },
                    {
                        "username": "cecilia5",
                        "content": "Minimum cost flow worked, you don\\'t need to add any nodes - just model the cost of a request is -1 and keep canceling negative cycles on the residual graph. "
                    },
                    {
                        "username": "autf",
                        "content": "I nominate this as an easiest `Hard` problem candidate."
                    },
                    {
                        "username": "IamVaibhave53",
                        "content": "Just curious to why this problem has been marked hard, when there are mediums which require more thinking than this one..."
                    }
                ]
            },
            {
                "id": 1952220,
                "content": [
                    {
                        "username": "yabyer1",
                        "content": "So many transfers, office looks like Chelsea"
                    },
                    {
                        "username": "oshok",
                        "content": "\\uD83D\\uDE02"
                    },
                    {
                        "username": "fenil3357",
                        "content": "still finished 12th."
                    },
                    {
                        "username": "mihirrawool1907",
                        "content": "[@subhamsadhukhan95](/subhamsadhukhan95) good pun\\n"
                    },
                    {
                        "username": "subhamsadhukhan95",
                        "content": "good one "
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "I thought the month will start with easy problems."
                    },
                    {
                        "username": "sarthakr10",
                        "content": "ha yr \\n"
                    },
                    {
                        "username": "eduard92",
                        "content": "Its also weekend. So Its O(n^n) psychological damage"
                    },
                    {
                        "username": "suren-yeager",
                        "content": "Just like yesterday\\'s daily challenge, constraints clearly tell us that this problem can be solved by brute force and this doesn\\'t deserve to be hard"
                    },
                    {
                        "username": "amitbansal13",
                        "content": "Leetcode is playing with our emotions now"
                    },
                    {
                        "username": "sanket54",
                        "content": "Why can\\'t we do it using minimum of in-degree and out-degree of the node?"
                    },
                    {
                        "username": "w7089",
                        "content": "have a look at the example `[[0,1],[2,1],[2,0]]` n=3"
                    },
                    {
                        "username": "w7089",
                        "content": "[@bparanj](/bparanj) again, the method by [@sanket54](/sanket54) works and returnsthe correct answer - 3, order doesn\\'t matter here"
                    },
                    {
                        "username": "w7089",
                        "content": "[@bparanj](/bparanj) try to run the below code on [[1,1],[1,1]], n=2:\\n\\n```\\nclass Solution:\\n    def maximumRequests(self, n: int, requests: List[List[int]]) -> int:\\n        from_c = Counter()\\n        to_c = Counter()\\n        for f_t in requests:\\n            f,t = f_t\\n            from_c[f] += 1\\n            to_c[t] += 1\\n        return sum([min(from_c[i], to_c[i]) for i in range(n)])\\n```\\n\\nand you\\'ll see that the solution is 2 and the method by [@sanket54](/sanket54) works\\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "[@himanshupanwar123](/himanshupanwar123) The key point is that a request `[a, b]` means an employee moves from building `a` to building `b`. To fulfill a request, the building `a` must have at least one employee.\\n\\nConsider your example `[1,1],[1,1]`, these two requests mean two employees leave building `1` and re-enter building `1`. Initially, we must have at least two employees in building `1` to fulfill both requests.\\n\\nSuppose building `1` starts with only one employee. We can fulfill the first request `[1,1]` because there\\'s an employee in building `1` who can leave and re-enter. But after this request, there\\'s still only one employee in building `1`. Now if we try to fulfill the second request `[1,1]`, we can\\'t, because we don\\'t have a second employee in building `1` to leave and re-enter. Therefore, in this situation, we can only fulfill one request, not two.\\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "That\\'s a good question, and this approach of using the minimum of in-degree and out-degree of a node seems to make sense at first glance because intuitively, you could fulfill as many requests as the minimum of in-degree and out-degree.\\n\\nHowever, this approach won\\'t work in all cases because the order of the requests matter. Let\\'s take an example to illustrate this:\\n\\nSuppose we have 3 buildings (0, 1, 2) and 4 requests: \\n```\\n[0, 1]\\n[1, 2]\\n[0, 1]\\n[2, 0]\\n```\\nIf you look at the minimum of in-degree and out-degree, all buildings have 2 incoming and 2 outgoing requests. So, you might think we can fulfill all 4 requests. But if you try to fulfill the requests in the order they\\'re given, after the first 3 requests, building 0 will have no employees left, so the last request can\\'t be fulfilled.\\n\\nOn the other hand, if you rearrange the requests like this:\\n```\\n[0, 1]\\n[0, 1]\\n[1, 2]\\n[2, 0]\\n```\\nNow, you can fulfill all 4 requests. \\n\\nSo, the problem is more complex than just looking at the minimum of in-degree and out-degree for each node, because the order of the requests matter. Therefore, we need to consider all possible arrangements of the requests, which is why we use a DFS with bit manipulation to generate all subsets of requests, and then check which subset can fulfill the maximum number of requests."
                    },
                    {
                        "username": "jain_06_07",
                        "content": "[@himanshupanwar123](/himanshupanwar123) Sure...\\n3\\n[[0,0], [1,1], [0,0], [2,0], [2,2], [1,1], [2,1], [0,1], [0,1]]\\n\\n[0,0], [1,1], [0,0], [2,2], [1,1] --> ignore these cases as it will not affect anything. worker leaves company and joins again but its request is full filled. Right so ans = 5 till now\\n\\nNow, for remaining requests [2,0], [2,1], [0,1], [0,1]. \\nif you\\'ll draw graph now then you will see\\nfor company 0 you\\'ve one incoming worker from company 2 and two worker leaving for company 1\\nand for company 1 there is only three workers that are coming but no one is leaving So company 1 cannot accept any worker from company 0. \\n\\nSo, it cannot fulfill the request even company 0 has sufficient indegree and outdegree. "
                    },
                    {
                        "username": "himanshupanwar123",
                        "content": "[@jain_06_07](/jain_06_07)  can you elaborate this example a bit i am also stuck at this since [1,1],[1,1] means two employes leaves and again they enter that means 2 request fullfilled."
                    },
                    {
                        "username": "Swastik_Gorai",
                        "content": "[@jain_06_07](/jain_06_07) please explain\\n"
                    },
                    {
                        "username": "jain_06_07",
                        "content": "[@amin_aziz](/amin_aziz) 6 ach/request ? Can you explain"
                    },
                    {
                        "username": "amin_aziz",
                        "content": "[@jain_06_07](/jain_06_07)\\nthere is 6 ach/request, but expected 5?"
                    },
                    {
                        "username": "jain_06_07",
                        "content": "see this case\\n3\\n[[0,0],[1,1],[0,0],[2,0],[2,2],[1,1],[2,1],[0,1],[0,1]]\\nIn this case , Indegree(0) = 1 and outdegree(0) = 2 \\nbut for node 1, there is no outdegree so It we can not take worker from node 0 and hence node 0 can\\'t send a worker also"
                    },
                    {
                        "username": "Rubiya1090",
                        "content": "It\\'s exhausting to see continuous medium & hard problems. Solving the leet code problem is fun when there is a right balance b/w difficulty level."
                    },
                    {
                        "username": "joseph261059",
                        "content": "It is a standard backtracking problem, it is not hard at all"
                    },
                    {
                        "username": "void_8t",
                        "content": "its not that hard, try it you can :)"
                    },
                    {
                        "username": "shubhampr10",
                        "content": "\\nWe\\'ve got other work to do.\\uD83D\\uDE2D"
                    },
                    {
                        "username": "mochy",
                        "content": "Why does brute force work lol"
                    },
                    {
                        "username": "charonme",
                        "content": "constraints are quite low, only 2^20 = 1048576 permutations at worst"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "Because of its \\uD83D\\uDCAA brutal force \\uD83D\\uDCAA, of course."
                    },
                    {
                        "username": "crosslives",
                        "content": "I think this is a Minimum Cost Maximum Flow problem. \\n\\nFirstly, we should calculate # of redundant requests and # of absent requests.\\n\\nThen we can construct a graph, G = <V, E>\\n\\nV = {S, T, Factory_1, Factory_2, ..., Factory_n}\\nE = { (S -> Factories that have redundant requests),\\n         (Facotries that need requests -> T,\\n\\t\\t All other edges provided by function\\n\\t\\t}\\nThe cost of each unit is 1. \\nThen we can calculate  Minimum Cost Maximum Flow of G. \\n\\\\# of requests - minimum cost is answer.\\n\\nI didn\\'t implement it but think it may be a possible solution.\\n\\nIs there more efficient solution for this problem?"
                    },
                    {
                        "username": "cecilia5",
                        "content": "[@f20201214](/f20201214) I posted it on the solutions."
                    },
                    {
                        "username": "f20201214",
                        "content": "[@cecilia5](/cecilia5) Could you share your solution?\\n"
                    },
                    {
                        "username": "VMAtm",
                        "content": "Yeah, thought about it too and was expecting to see this in editorial ("
                    },
                    {
                        "username": "cecilia5",
                        "content": "Minimum cost flow worked, you don\\'t need to add any nodes - just model the cost of a request is -1 and keep canceling negative cycles on the residual graph. "
                    },
                    {
                        "username": "autf",
                        "content": "I nominate this as an easiest `Hard` problem candidate."
                    },
                    {
                        "username": "IamVaibhave53",
                        "content": "Just curious to why this problem has been marked hard, when there are mediums which require more thinking than this one..."
                    }
                ]
            },
            {
                "id": 1952679,
                "content": [
                    {
                        "username": "yabyer1",
                        "content": "So many transfers, office looks like Chelsea"
                    },
                    {
                        "username": "oshok",
                        "content": "\\uD83D\\uDE02"
                    },
                    {
                        "username": "fenil3357",
                        "content": "still finished 12th."
                    },
                    {
                        "username": "mihirrawool1907",
                        "content": "[@subhamsadhukhan95](/subhamsadhukhan95) good pun\\n"
                    },
                    {
                        "username": "subhamsadhukhan95",
                        "content": "good one "
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "I thought the month will start with easy problems."
                    },
                    {
                        "username": "sarthakr10",
                        "content": "ha yr \\n"
                    },
                    {
                        "username": "eduard92",
                        "content": "Its also weekend. So Its O(n^n) psychological damage"
                    },
                    {
                        "username": "suren-yeager",
                        "content": "Just like yesterday\\'s daily challenge, constraints clearly tell us that this problem can be solved by brute force and this doesn\\'t deserve to be hard"
                    },
                    {
                        "username": "amitbansal13",
                        "content": "Leetcode is playing with our emotions now"
                    },
                    {
                        "username": "sanket54",
                        "content": "Why can\\'t we do it using minimum of in-degree and out-degree of the node?"
                    },
                    {
                        "username": "w7089",
                        "content": "have a look at the example `[[0,1],[2,1],[2,0]]` n=3"
                    },
                    {
                        "username": "w7089",
                        "content": "[@bparanj](/bparanj) again, the method by [@sanket54](/sanket54) works and returnsthe correct answer - 3, order doesn\\'t matter here"
                    },
                    {
                        "username": "w7089",
                        "content": "[@bparanj](/bparanj) try to run the below code on [[1,1],[1,1]], n=2:\\n\\n```\\nclass Solution:\\n    def maximumRequests(self, n: int, requests: List[List[int]]) -> int:\\n        from_c = Counter()\\n        to_c = Counter()\\n        for f_t in requests:\\n            f,t = f_t\\n            from_c[f] += 1\\n            to_c[t] += 1\\n        return sum([min(from_c[i], to_c[i]) for i in range(n)])\\n```\\n\\nand you\\'ll see that the solution is 2 and the method by [@sanket54](/sanket54) works\\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "[@himanshupanwar123](/himanshupanwar123) The key point is that a request `[a, b]` means an employee moves from building `a` to building `b`. To fulfill a request, the building `a` must have at least one employee.\\n\\nConsider your example `[1,1],[1,1]`, these two requests mean two employees leave building `1` and re-enter building `1`. Initially, we must have at least two employees in building `1` to fulfill both requests.\\n\\nSuppose building `1` starts with only one employee. We can fulfill the first request `[1,1]` because there\\'s an employee in building `1` who can leave and re-enter. But after this request, there\\'s still only one employee in building `1`. Now if we try to fulfill the second request `[1,1]`, we can\\'t, because we don\\'t have a second employee in building `1` to leave and re-enter. Therefore, in this situation, we can only fulfill one request, not two.\\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "That\\'s a good question, and this approach of using the minimum of in-degree and out-degree of a node seems to make sense at first glance because intuitively, you could fulfill as many requests as the minimum of in-degree and out-degree.\\n\\nHowever, this approach won\\'t work in all cases because the order of the requests matter. Let\\'s take an example to illustrate this:\\n\\nSuppose we have 3 buildings (0, 1, 2) and 4 requests: \\n```\\n[0, 1]\\n[1, 2]\\n[0, 1]\\n[2, 0]\\n```\\nIf you look at the minimum of in-degree and out-degree, all buildings have 2 incoming and 2 outgoing requests. So, you might think we can fulfill all 4 requests. But if you try to fulfill the requests in the order they\\'re given, after the first 3 requests, building 0 will have no employees left, so the last request can\\'t be fulfilled.\\n\\nOn the other hand, if you rearrange the requests like this:\\n```\\n[0, 1]\\n[0, 1]\\n[1, 2]\\n[2, 0]\\n```\\nNow, you can fulfill all 4 requests. \\n\\nSo, the problem is more complex than just looking at the minimum of in-degree and out-degree for each node, because the order of the requests matter. Therefore, we need to consider all possible arrangements of the requests, which is why we use a DFS with bit manipulation to generate all subsets of requests, and then check which subset can fulfill the maximum number of requests."
                    },
                    {
                        "username": "jain_06_07",
                        "content": "[@himanshupanwar123](/himanshupanwar123) Sure...\\n3\\n[[0,0], [1,1], [0,0], [2,0], [2,2], [1,1], [2,1], [0,1], [0,1]]\\n\\n[0,0], [1,1], [0,0], [2,2], [1,1] --> ignore these cases as it will not affect anything. worker leaves company and joins again but its request is full filled. Right so ans = 5 till now\\n\\nNow, for remaining requests [2,0], [2,1], [0,1], [0,1]. \\nif you\\'ll draw graph now then you will see\\nfor company 0 you\\'ve one incoming worker from company 2 and two worker leaving for company 1\\nand for company 1 there is only three workers that are coming but no one is leaving So company 1 cannot accept any worker from company 0. \\n\\nSo, it cannot fulfill the request even company 0 has sufficient indegree and outdegree. "
                    },
                    {
                        "username": "himanshupanwar123",
                        "content": "[@jain_06_07](/jain_06_07)  can you elaborate this example a bit i am also stuck at this since [1,1],[1,1] means two employes leaves and again they enter that means 2 request fullfilled."
                    },
                    {
                        "username": "Swastik_Gorai",
                        "content": "[@jain_06_07](/jain_06_07) please explain\\n"
                    },
                    {
                        "username": "jain_06_07",
                        "content": "[@amin_aziz](/amin_aziz) 6 ach/request ? Can you explain"
                    },
                    {
                        "username": "amin_aziz",
                        "content": "[@jain_06_07](/jain_06_07)\\nthere is 6 ach/request, but expected 5?"
                    },
                    {
                        "username": "jain_06_07",
                        "content": "see this case\\n3\\n[[0,0],[1,1],[0,0],[2,0],[2,2],[1,1],[2,1],[0,1],[0,1]]\\nIn this case , Indegree(0) = 1 and outdegree(0) = 2 \\nbut for node 1, there is no outdegree so It we can not take worker from node 0 and hence node 0 can\\'t send a worker also"
                    },
                    {
                        "username": "Rubiya1090",
                        "content": "It\\'s exhausting to see continuous medium & hard problems. Solving the leet code problem is fun when there is a right balance b/w difficulty level."
                    },
                    {
                        "username": "joseph261059",
                        "content": "It is a standard backtracking problem, it is not hard at all"
                    },
                    {
                        "username": "void_8t",
                        "content": "its not that hard, try it you can :)"
                    },
                    {
                        "username": "shubhampr10",
                        "content": "\\nWe\\'ve got other work to do.\\uD83D\\uDE2D"
                    },
                    {
                        "username": "mochy",
                        "content": "Why does brute force work lol"
                    },
                    {
                        "username": "charonme",
                        "content": "constraints are quite low, only 2^20 = 1048576 permutations at worst"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "Because of its \\uD83D\\uDCAA brutal force \\uD83D\\uDCAA, of course."
                    },
                    {
                        "username": "crosslives",
                        "content": "I think this is a Minimum Cost Maximum Flow problem. \\n\\nFirstly, we should calculate # of redundant requests and # of absent requests.\\n\\nThen we can construct a graph, G = <V, E>\\n\\nV = {S, T, Factory_1, Factory_2, ..., Factory_n}\\nE = { (S -> Factories that have redundant requests),\\n         (Facotries that need requests -> T,\\n\\t\\t All other edges provided by function\\n\\t\\t}\\nThe cost of each unit is 1. \\nThen we can calculate  Minimum Cost Maximum Flow of G. \\n\\\\# of requests - minimum cost is answer.\\n\\nI didn\\'t implement it but think it may be a possible solution.\\n\\nIs there more efficient solution for this problem?"
                    },
                    {
                        "username": "cecilia5",
                        "content": "[@f20201214](/f20201214) I posted it on the solutions."
                    },
                    {
                        "username": "f20201214",
                        "content": "[@cecilia5](/cecilia5) Could you share your solution?\\n"
                    },
                    {
                        "username": "VMAtm",
                        "content": "Yeah, thought about it too and was expecting to see this in editorial ("
                    },
                    {
                        "username": "cecilia5",
                        "content": "Minimum cost flow worked, you don\\'t need to add any nodes - just model the cost of a request is -1 and keep canceling negative cycles on the residual graph. "
                    },
                    {
                        "username": "autf",
                        "content": "I nominate this as an easiest `Hard` problem candidate."
                    },
                    {
                        "username": "IamVaibhave53",
                        "content": "Just curious to why this problem has been marked hard, when there are mediums which require more thinking than this one..."
                    }
                ]
            },
            {
                "id": 1952273,
                "content": [
                    {
                        "username": "yabyer1",
                        "content": "So many transfers, office looks like Chelsea"
                    },
                    {
                        "username": "oshok",
                        "content": "\\uD83D\\uDE02"
                    },
                    {
                        "username": "fenil3357",
                        "content": "still finished 12th."
                    },
                    {
                        "username": "mihirrawool1907",
                        "content": "[@subhamsadhukhan95](/subhamsadhukhan95) good pun\\n"
                    },
                    {
                        "username": "subhamsadhukhan95",
                        "content": "good one "
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "I thought the month will start with easy problems."
                    },
                    {
                        "username": "sarthakr10",
                        "content": "ha yr \\n"
                    },
                    {
                        "username": "eduard92",
                        "content": "Its also weekend. So Its O(n^n) psychological damage"
                    },
                    {
                        "username": "suren-yeager",
                        "content": "Just like yesterday\\'s daily challenge, constraints clearly tell us that this problem can be solved by brute force and this doesn\\'t deserve to be hard"
                    },
                    {
                        "username": "amitbansal13",
                        "content": "Leetcode is playing with our emotions now"
                    },
                    {
                        "username": "sanket54",
                        "content": "Why can\\'t we do it using minimum of in-degree and out-degree of the node?"
                    },
                    {
                        "username": "w7089",
                        "content": "have a look at the example `[[0,1],[2,1],[2,0]]` n=3"
                    },
                    {
                        "username": "w7089",
                        "content": "[@bparanj](/bparanj) again, the method by [@sanket54](/sanket54) works and returnsthe correct answer - 3, order doesn\\'t matter here"
                    },
                    {
                        "username": "w7089",
                        "content": "[@bparanj](/bparanj) try to run the below code on [[1,1],[1,1]], n=2:\\n\\n```\\nclass Solution:\\n    def maximumRequests(self, n: int, requests: List[List[int]]) -> int:\\n        from_c = Counter()\\n        to_c = Counter()\\n        for f_t in requests:\\n            f,t = f_t\\n            from_c[f] += 1\\n            to_c[t] += 1\\n        return sum([min(from_c[i], to_c[i]) for i in range(n)])\\n```\\n\\nand you\\'ll see that the solution is 2 and the method by [@sanket54](/sanket54) works\\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "[@himanshupanwar123](/himanshupanwar123) The key point is that a request `[a, b]` means an employee moves from building `a` to building `b`. To fulfill a request, the building `a` must have at least one employee.\\n\\nConsider your example `[1,1],[1,1]`, these two requests mean two employees leave building `1` and re-enter building `1`. Initially, we must have at least two employees in building `1` to fulfill both requests.\\n\\nSuppose building `1` starts with only one employee. We can fulfill the first request `[1,1]` because there\\'s an employee in building `1` who can leave and re-enter. But after this request, there\\'s still only one employee in building `1`. Now if we try to fulfill the second request `[1,1]`, we can\\'t, because we don\\'t have a second employee in building `1` to leave and re-enter. Therefore, in this situation, we can only fulfill one request, not two.\\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "That\\'s a good question, and this approach of using the minimum of in-degree and out-degree of a node seems to make sense at first glance because intuitively, you could fulfill as many requests as the minimum of in-degree and out-degree.\\n\\nHowever, this approach won\\'t work in all cases because the order of the requests matter. Let\\'s take an example to illustrate this:\\n\\nSuppose we have 3 buildings (0, 1, 2) and 4 requests: \\n```\\n[0, 1]\\n[1, 2]\\n[0, 1]\\n[2, 0]\\n```\\nIf you look at the minimum of in-degree and out-degree, all buildings have 2 incoming and 2 outgoing requests. So, you might think we can fulfill all 4 requests. But if you try to fulfill the requests in the order they\\'re given, after the first 3 requests, building 0 will have no employees left, so the last request can\\'t be fulfilled.\\n\\nOn the other hand, if you rearrange the requests like this:\\n```\\n[0, 1]\\n[0, 1]\\n[1, 2]\\n[2, 0]\\n```\\nNow, you can fulfill all 4 requests. \\n\\nSo, the problem is more complex than just looking at the minimum of in-degree and out-degree for each node, because the order of the requests matter. Therefore, we need to consider all possible arrangements of the requests, which is why we use a DFS with bit manipulation to generate all subsets of requests, and then check which subset can fulfill the maximum number of requests."
                    },
                    {
                        "username": "jain_06_07",
                        "content": "[@himanshupanwar123](/himanshupanwar123) Sure...\\n3\\n[[0,0], [1,1], [0,0], [2,0], [2,2], [1,1], [2,1], [0,1], [0,1]]\\n\\n[0,0], [1,1], [0,0], [2,2], [1,1] --> ignore these cases as it will not affect anything. worker leaves company and joins again but its request is full filled. Right so ans = 5 till now\\n\\nNow, for remaining requests [2,0], [2,1], [0,1], [0,1]. \\nif you\\'ll draw graph now then you will see\\nfor company 0 you\\'ve one incoming worker from company 2 and two worker leaving for company 1\\nand for company 1 there is only three workers that are coming but no one is leaving So company 1 cannot accept any worker from company 0. \\n\\nSo, it cannot fulfill the request even company 0 has sufficient indegree and outdegree. "
                    },
                    {
                        "username": "himanshupanwar123",
                        "content": "[@jain_06_07](/jain_06_07)  can you elaborate this example a bit i am also stuck at this since [1,1],[1,1] means two employes leaves and again they enter that means 2 request fullfilled."
                    },
                    {
                        "username": "Swastik_Gorai",
                        "content": "[@jain_06_07](/jain_06_07) please explain\\n"
                    },
                    {
                        "username": "jain_06_07",
                        "content": "[@amin_aziz](/amin_aziz) 6 ach/request ? Can you explain"
                    },
                    {
                        "username": "amin_aziz",
                        "content": "[@jain_06_07](/jain_06_07)\\nthere is 6 ach/request, but expected 5?"
                    },
                    {
                        "username": "jain_06_07",
                        "content": "see this case\\n3\\n[[0,0],[1,1],[0,0],[2,0],[2,2],[1,1],[2,1],[0,1],[0,1]]\\nIn this case , Indegree(0) = 1 and outdegree(0) = 2 \\nbut for node 1, there is no outdegree so It we can not take worker from node 0 and hence node 0 can\\'t send a worker also"
                    },
                    {
                        "username": "Rubiya1090",
                        "content": "It\\'s exhausting to see continuous medium & hard problems. Solving the leet code problem is fun when there is a right balance b/w difficulty level."
                    },
                    {
                        "username": "joseph261059",
                        "content": "It is a standard backtracking problem, it is not hard at all"
                    },
                    {
                        "username": "void_8t",
                        "content": "its not that hard, try it you can :)"
                    },
                    {
                        "username": "shubhampr10",
                        "content": "\\nWe\\'ve got other work to do.\\uD83D\\uDE2D"
                    },
                    {
                        "username": "mochy",
                        "content": "Why does brute force work lol"
                    },
                    {
                        "username": "charonme",
                        "content": "constraints are quite low, only 2^20 = 1048576 permutations at worst"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "Because of its \\uD83D\\uDCAA brutal force \\uD83D\\uDCAA, of course."
                    },
                    {
                        "username": "crosslives",
                        "content": "I think this is a Minimum Cost Maximum Flow problem. \\n\\nFirstly, we should calculate # of redundant requests and # of absent requests.\\n\\nThen we can construct a graph, G = <V, E>\\n\\nV = {S, T, Factory_1, Factory_2, ..., Factory_n}\\nE = { (S -> Factories that have redundant requests),\\n         (Facotries that need requests -> T,\\n\\t\\t All other edges provided by function\\n\\t\\t}\\nThe cost of each unit is 1. \\nThen we can calculate  Minimum Cost Maximum Flow of G. \\n\\\\# of requests - minimum cost is answer.\\n\\nI didn\\'t implement it but think it may be a possible solution.\\n\\nIs there more efficient solution for this problem?"
                    },
                    {
                        "username": "cecilia5",
                        "content": "[@f20201214](/f20201214) I posted it on the solutions."
                    },
                    {
                        "username": "f20201214",
                        "content": "[@cecilia5](/cecilia5) Could you share your solution?\\n"
                    },
                    {
                        "username": "VMAtm",
                        "content": "Yeah, thought about it too and was expecting to see this in editorial ("
                    },
                    {
                        "username": "cecilia5",
                        "content": "Minimum cost flow worked, you don\\'t need to add any nodes - just model the cost of a request is -1 and keep canceling negative cycles on the residual graph. "
                    },
                    {
                        "username": "autf",
                        "content": "I nominate this as an easiest `Hard` problem candidate."
                    },
                    {
                        "username": "IamVaibhave53",
                        "content": "Just curious to why this problem has been marked hard, when there are mediums which require more thinking than this one..."
                    }
                ]
            },
            {
                "id": 1570184,
                "content": [
                    {
                        "username": "yabyer1",
                        "content": "So many transfers, office looks like Chelsea"
                    },
                    {
                        "username": "oshok",
                        "content": "\\uD83D\\uDE02"
                    },
                    {
                        "username": "fenil3357",
                        "content": "still finished 12th."
                    },
                    {
                        "username": "mihirrawool1907",
                        "content": "[@subhamsadhukhan95](/subhamsadhukhan95) good pun\\n"
                    },
                    {
                        "username": "subhamsadhukhan95",
                        "content": "good one "
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "I thought the month will start with easy problems."
                    },
                    {
                        "username": "sarthakr10",
                        "content": "ha yr \\n"
                    },
                    {
                        "username": "eduard92",
                        "content": "Its also weekend. So Its O(n^n) psychological damage"
                    },
                    {
                        "username": "suren-yeager",
                        "content": "Just like yesterday\\'s daily challenge, constraints clearly tell us that this problem can be solved by brute force and this doesn\\'t deserve to be hard"
                    },
                    {
                        "username": "amitbansal13",
                        "content": "Leetcode is playing with our emotions now"
                    },
                    {
                        "username": "sanket54",
                        "content": "Why can\\'t we do it using minimum of in-degree and out-degree of the node?"
                    },
                    {
                        "username": "w7089",
                        "content": "have a look at the example `[[0,1],[2,1],[2,0]]` n=3"
                    },
                    {
                        "username": "w7089",
                        "content": "[@bparanj](/bparanj) again, the method by [@sanket54](/sanket54) works and returnsthe correct answer - 3, order doesn\\'t matter here"
                    },
                    {
                        "username": "w7089",
                        "content": "[@bparanj](/bparanj) try to run the below code on [[1,1],[1,1]], n=2:\\n\\n```\\nclass Solution:\\n    def maximumRequests(self, n: int, requests: List[List[int]]) -> int:\\n        from_c = Counter()\\n        to_c = Counter()\\n        for f_t in requests:\\n            f,t = f_t\\n            from_c[f] += 1\\n            to_c[t] += 1\\n        return sum([min(from_c[i], to_c[i]) for i in range(n)])\\n```\\n\\nand you\\'ll see that the solution is 2 and the method by [@sanket54](/sanket54) works\\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "[@himanshupanwar123](/himanshupanwar123) The key point is that a request `[a, b]` means an employee moves from building `a` to building `b`. To fulfill a request, the building `a` must have at least one employee.\\n\\nConsider your example `[1,1],[1,1]`, these two requests mean two employees leave building `1` and re-enter building `1`. Initially, we must have at least two employees in building `1` to fulfill both requests.\\n\\nSuppose building `1` starts with only one employee. We can fulfill the first request `[1,1]` because there\\'s an employee in building `1` who can leave and re-enter. But after this request, there\\'s still only one employee in building `1`. Now if we try to fulfill the second request `[1,1]`, we can\\'t, because we don\\'t have a second employee in building `1` to leave and re-enter. Therefore, in this situation, we can only fulfill one request, not two.\\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "That\\'s a good question, and this approach of using the minimum of in-degree and out-degree of a node seems to make sense at first glance because intuitively, you could fulfill as many requests as the minimum of in-degree and out-degree.\\n\\nHowever, this approach won\\'t work in all cases because the order of the requests matter. Let\\'s take an example to illustrate this:\\n\\nSuppose we have 3 buildings (0, 1, 2) and 4 requests: \\n```\\n[0, 1]\\n[1, 2]\\n[0, 1]\\n[2, 0]\\n```\\nIf you look at the minimum of in-degree and out-degree, all buildings have 2 incoming and 2 outgoing requests. So, you might think we can fulfill all 4 requests. But if you try to fulfill the requests in the order they\\'re given, after the first 3 requests, building 0 will have no employees left, so the last request can\\'t be fulfilled.\\n\\nOn the other hand, if you rearrange the requests like this:\\n```\\n[0, 1]\\n[0, 1]\\n[1, 2]\\n[2, 0]\\n```\\nNow, you can fulfill all 4 requests. \\n\\nSo, the problem is more complex than just looking at the minimum of in-degree and out-degree for each node, because the order of the requests matter. Therefore, we need to consider all possible arrangements of the requests, which is why we use a DFS with bit manipulation to generate all subsets of requests, and then check which subset can fulfill the maximum number of requests."
                    },
                    {
                        "username": "jain_06_07",
                        "content": "[@himanshupanwar123](/himanshupanwar123) Sure...\\n3\\n[[0,0], [1,1], [0,0], [2,0], [2,2], [1,1], [2,1], [0,1], [0,1]]\\n\\n[0,0], [1,1], [0,0], [2,2], [1,1] --> ignore these cases as it will not affect anything. worker leaves company and joins again but its request is full filled. Right so ans = 5 till now\\n\\nNow, for remaining requests [2,0], [2,1], [0,1], [0,1]. \\nif you\\'ll draw graph now then you will see\\nfor company 0 you\\'ve one incoming worker from company 2 and two worker leaving for company 1\\nand for company 1 there is only three workers that are coming but no one is leaving So company 1 cannot accept any worker from company 0. \\n\\nSo, it cannot fulfill the request even company 0 has sufficient indegree and outdegree. "
                    },
                    {
                        "username": "himanshupanwar123",
                        "content": "[@jain_06_07](/jain_06_07)  can you elaborate this example a bit i am also stuck at this since [1,1],[1,1] means two employes leaves and again they enter that means 2 request fullfilled."
                    },
                    {
                        "username": "Swastik_Gorai",
                        "content": "[@jain_06_07](/jain_06_07) please explain\\n"
                    },
                    {
                        "username": "jain_06_07",
                        "content": "[@amin_aziz](/amin_aziz) 6 ach/request ? Can you explain"
                    },
                    {
                        "username": "amin_aziz",
                        "content": "[@jain_06_07](/jain_06_07)\\nthere is 6 ach/request, but expected 5?"
                    },
                    {
                        "username": "jain_06_07",
                        "content": "see this case\\n3\\n[[0,0],[1,1],[0,0],[2,0],[2,2],[1,1],[2,1],[0,1],[0,1]]\\nIn this case , Indegree(0) = 1 and outdegree(0) = 2 \\nbut for node 1, there is no outdegree so It we can not take worker from node 0 and hence node 0 can\\'t send a worker also"
                    },
                    {
                        "username": "Rubiya1090",
                        "content": "It\\'s exhausting to see continuous medium & hard problems. Solving the leet code problem is fun when there is a right balance b/w difficulty level."
                    },
                    {
                        "username": "joseph261059",
                        "content": "It is a standard backtracking problem, it is not hard at all"
                    },
                    {
                        "username": "void_8t",
                        "content": "its not that hard, try it you can :)"
                    },
                    {
                        "username": "shubhampr10",
                        "content": "\\nWe\\'ve got other work to do.\\uD83D\\uDE2D"
                    },
                    {
                        "username": "mochy",
                        "content": "Why does brute force work lol"
                    },
                    {
                        "username": "charonme",
                        "content": "constraints are quite low, only 2^20 = 1048576 permutations at worst"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "Because of its \\uD83D\\uDCAA brutal force \\uD83D\\uDCAA, of course."
                    },
                    {
                        "username": "crosslives",
                        "content": "I think this is a Minimum Cost Maximum Flow problem. \\n\\nFirstly, we should calculate # of redundant requests and # of absent requests.\\n\\nThen we can construct a graph, G = <V, E>\\n\\nV = {S, T, Factory_1, Factory_2, ..., Factory_n}\\nE = { (S -> Factories that have redundant requests),\\n         (Facotries that need requests -> T,\\n\\t\\t All other edges provided by function\\n\\t\\t}\\nThe cost of each unit is 1. \\nThen we can calculate  Minimum Cost Maximum Flow of G. \\n\\\\# of requests - minimum cost is answer.\\n\\nI didn\\'t implement it but think it may be a possible solution.\\n\\nIs there more efficient solution for this problem?"
                    },
                    {
                        "username": "cecilia5",
                        "content": "[@f20201214](/f20201214) I posted it on the solutions."
                    },
                    {
                        "username": "f20201214",
                        "content": "[@cecilia5](/cecilia5) Could you share your solution?\\n"
                    },
                    {
                        "username": "VMAtm",
                        "content": "Yeah, thought about it too and was expecting to see this in editorial ("
                    },
                    {
                        "username": "cecilia5",
                        "content": "Minimum cost flow worked, you don\\'t need to add any nodes - just model the cost of a request is -1 and keep canceling negative cycles on the residual graph. "
                    },
                    {
                        "username": "autf",
                        "content": "I nominate this as an easiest `Hard` problem candidate."
                    },
                    {
                        "username": "IamVaibhave53",
                        "content": "Just curious to why this problem has been marked hard, when there are mediums which require more thinking than this one..."
                    }
                ]
            },
            {
                "id": 1952655,
                "content": [
                    {
                        "username": "yabyer1",
                        "content": "So many transfers, office looks like Chelsea"
                    },
                    {
                        "username": "oshok",
                        "content": "\\uD83D\\uDE02"
                    },
                    {
                        "username": "fenil3357",
                        "content": "still finished 12th."
                    },
                    {
                        "username": "mihirrawool1907",
                        "content": "[@subhamsadhukhan95](/subhamsadhukhan95) good pun\\n"
                    },
                    {
                        "username": "subhamsadhukhan95",
                        "content": "good one "
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "I thought the month will start with easy problems."
                    },
                    {
                        "username": "sarthakr10",
                        "content": "ha yr \\n"
                    },
                    {
                        "username": "eduard92",
                        "content": "Its also weekend. So Its O(n^n) psychological damage"
                    },
                    {
                        "username": "suren-yeager",
                        "content": "Just like yesterday\\'s daily challenge, constraints clearly tell us that this problem can be solved by brute force and this doesn\\'t deserve to be hard"
                    },
                    {
                        "username": "amitbansal13",
                        "content": "Leetcode is playing with our emotions now"
                    },
                    {
                        "username": "sanket54",
                        "content": "Why can\\'t we do it using minimum of in-degree and out-degree of the node?"
                    },
                    {
                        "username": "w7089",
                        "content": "have a look at the example `[[0,1],[2,1],[2,0]]` n=3"
                    },
                    {
                        "username": "w7089",
                        "content": "[@bparanj](/bparanj) again, the method by [@sanket54](/sanket54) works and returnsthe correct answer - 3, order doesn\\'t matter here"
                    },
                    {
                        "username": "w7089",
                        "content": "[@bparanj](/bparanj) try to run the below code on [[1,1],[1,1]], n=2:\\n\\n```\\nclass Solution:\\n    def maximumRequests(self, n: int, requests: List[List[int]]) -> int:\\n        from_c = Counter()\\n        to_c = Counter()\\n        for f_t in requests:\\n            f,t = f_t\\n            from_c[f] += 1\\n            to_c[t] += 1\\n        return sum([min(from_c[i], to_c[i]) for i in range(n)])\\n```\\n\\nand you\\'ll see that the solution is 2 and the method by [@sanket54](/sanket54) works\\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "[@himanshupanwar123](/himanshupanwar123) The key point is that a request `[a, b]` means an employee moves from building `a` to building `b`. To fulfill a request, the building `a` must have at least one employee.\\n\\nConsider your example `[1,1],[1,1]`, these two requests mean two employees leave building `1` and re-enter building `1`. Initially, we must have at least two employees in building `1` to fulfill both requests.\\n\\nSuppose building `1` starts with only one employee. We can fulfill the first request `[1,1]` because there\\'s an employee in building `1` who can leave and re-enter. But after this request, there\\'s still only one employee in building `1`. Now if we try to fulfill the second request `[1,1]`, we can\\'t, because we don\\'t have a second employee in building `1` to leave and re-enter. Therefore, in this situation, we can only fulfill one request, not two.\\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "That\\'s a good question, and this approach of using the minimum of in-degree and out-degree of a node seems to make sense at first glance because intuitively, you could fulfill as many requests as the minimum of in-degree and out-degree.\\n\\nHowever, this approach won\\'t work in all cases because the order of the requests matter. Let\\'s take an example to illustrate this:\\n\\nSuppose we have 3 buildings (0, 1, 2) and 4 requests: \\n```\\n[0, 1]\\n[1, 2]\\n[0, 1]\\n[2, 0]\\n```\\nIf you look at the minimum of in-degree and out-degree, all buildings have 2 incoming and 2 outgoing requests. So, you might think we can fulfill all 4 requests. But if you try to fulfill the requests in the order they\\'re given, after the first 3 requests, building 0 will have no employees left, so the last request can\\'t be fulfilled.\\n\\nOn the other hand, if you rearrange the requests like this:\\n```\\n[0, 1]\\n[0, 1]\\n[1, 2]\\n[2, 0]\\n```\\nNow, you can fulfill all 4 requests. \\n\\nSo, the problem is more complex than just looking at the minimum of in-degree and out-degree for each node, because the order of the requests matter. Therefore, we need to consider all possible arrangements of the requests, which is why we use a DFS with bit manipulation to generate all subsets of requests, and then check which subset can fulfill the maximum number of requests."
                    },
                    {
                        "username": "jain_06_07",
                        "content": "[@himanshupanwar123](/himanshupanwar123) Sure...\\n3\\n[[0,0], [1,1], [0,0], [2,0], [2,2], [1,1], [2,1], [0,1], [0,1]]\\n\\n[0,0], [1,1], [0,0], [2,2], [1,1] --> ignore these cases as it will not affect anything. worker leaves company and joins again but its request is full filled. Right so ans = 5 till now\\n\\nNow, for remaining requests [2,0], [2,1], [0,1], [0,1]. \\nif you\\'ll draw graph now then you will see\\nfor company 0 you\\'ve one incoming worker from company 2 and two worker leaving for company 1\\nand for company 1 there is only three workers that are coming but no one is leaving So company 1 cannot accept any worker from company 0. \\n\\nSo, it cannot fulfill the request even company 0 has sufficient indegree and outdegree. "
                    },
                    {
                        "username": "himanshupanwar123",
                        "content": "[@jain_06_07](/jain_06_07)  can you elaborate this example a bit i am also stuck at this since [1,1],[1,1] means two employes leaves and again they enter that means 2 request fullfilled."
                    },
                    {
                        "username": "Swastik_Gorai",
                        "content": "[@jain_06_07](/jain_06_07) please explain\\n"
                    },
                    {
                        "username": "jain_06_07",
                        "content": "[@amin_aziz](/amin_aziz) 6 ach/request ? Can you explain"
                    },
                    {
                        "username": "amin_aziz",
                        "content": "[@jain_06_07](/jain_06_07)\\nthere is 6 ach/request, but expected 5?"
                    },
                    {
                        "username": "jain_06_07",
                        "content": "see this case\\n3\\n[[0,0],[1,1],[0,0],[2,0],[2,2],[1,1],[2,1],[0,1],[0,1]]\\nIn this case , Indegree(0) = 1 and outdegree(0) = 2 \\nbut for node 1, there is no outdegree so It we can not take worker from node 0 and hence node 0 can\\'t send a worker also"
                    },
                    {
                        "username": "Rubiya1090",
                        "content": "It\\'s exhausting to see continuous medium & hard problems. Solving the leet code problem is fun when there is a right balance b/w difficulty level."
                    },
                    {
                        "username": "joseph261059",
                        "content": "It is a standard backtracking problem, it is not hard at all"
                    },
                    {
                        "username": "void_8t",
                        "content": "its not that hard, try it you can :)"
                    },
                    {
                        "username": "shubhampr10",
                        "content": "\\nWe\\'ve got other work to do.\\uD83D\\uDE2D"
                    },
                    {
                        "username": "mochy",
                        "content": "Why does brute force work lol"
                    },
                    {
                        "username": "charonme",
                        "content": "constraints are quite low, only 2^20 = 1048576 permutations at worst"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "Because of its \\uD83D\\uDCAA brutal force \\uD83D\\uDCAA, of course."
                    },
                    {
                        "username": "crosslives",
                        "content": "I think this is a Minimum Cost Maximum Flow problem. \\n\\nFirstly, we should calculate # of redundant requests and # of absent requests.\\n\\nThen we can construct a graph, G = <V, E>\\n\\nV = {S, T, Factory_1, Factory_2, ..., Factory_n}\\nE = { (S -> Factories that have redundant requests),\\n         (Facotries that need requests -> T,\\n\\t\\t All other edges provided by function\\n\\t\\t}\\nThe cost of each unit is 1. \\nThen we can calculate  Minimum Cost Maximum Flow of G. \\n\\\\# of requests - minimum cost is answer.\\n\\nI didn\\'t implement it but think it may be a possible solution.\\n\\nIs there more efficient solution for this problem?"
                    },
                    {
                        "username": "cecilia5",
                        "content": "[@f20201214](/f20201214) I posted it on the solutions."
                    },
                    {
                        "username": "f20201214",
                        "content": "[@cecilia5](/cecilia5) Could you share your solution?\\n"
                    },
                    {
                        "username": "VMAtm",
                        "content": "Yeah, thought about it too and was expecting to see this in editorial ("
                    },
                    {
                        "username": "cecilia5",
                        "content": "Minimum cost flow worked, you don\\'t need to add any nodes - just model the cost of a request is -1 and keep canceling negative cycles on the residual graph. "
                    },
                    {
                        "username": "autf",
                        "content": "I nominate this as an easiest `Hard` problem candidate."
                    },
                    {
                        "username": "IamVaibhave53",
                        "content": "Just curious to why this problem has been marked hard, when there are mediums which require more thinking than this one..."
                    }
                ]
            },
            {
                "id": 1952229,
                "content": [
                    {
                        "username": "yabyer1",
                        "content": "So many transfers, office looks like Chelsea"
                    },
                    {
                        "username": "oshok",
                        "content": "\\uD83D\\uDE02"
                    },
                    {
                        "username": "fenil3357",
                        "content": "still finished 12th."
                    },
                    {
                        "username": "mihirrawool1907",
                        "content": "[@subhamsadhukhan95](/subhamsadhukhan95) good pun\\n"
                    },
                    {
                        "username": "subhamsadhukhan95",
                        "content": "good one "
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "I thought the month will start with easy problems."
                    },
                    {
                        "username": "sarthakr10",
                        "content": "ha yr \\n"
                    },
                    {
                        "username": "eduard92",
                        "content": "Its also weekend. So Its O(n^n) psychological damage"
                    },
                    {
                        "username": "suren-yeager",
                        "content": "Just like yesterday\\'s daily challenge, constraints clearly tell us that this problem can be solved by brute force and this doesn\\'t deserve to be hard"
                    },
                    {
                        "username": "amitbansal13",
                        "content": "Leetcode is playing with our emotions now"
                    },
                    {
                        "username": "sanket54",
                        "content": "Why can\\'t we do it using minimum of in-degree and out-degree of the node?"
                    },
                    {
                        "username": "w7089",
                        "content": "have a look at the example `[[0,1],[2,1],[2,0]]` n=3"
                    },
                    {
                        "username": "w7089",
                        "content": "[@bparanj](/bparanj) again, the method by [@sanket54](/sanket54) works and returnsthe correct answer - 3, order doesn\\'t matter here"
                    },
                    {
                        "username": "w7089",
                        "content": "[@bparanj](/bparanj) try to run the below code on [[1,1],[1,1]], n=2:\\n\\n```\\nclass Solution:\\n    def maximumRequests(self, n: int, requests: List[List[int]]) -> int:\\n        from_c = Counter()\\n        to_c = Counter()\\n        for f_t in requests:\\n            f,t = f_t\\n            from_c[f] += 1\\n            to_c[t] += 1\\n        return sum([min(from_c[i], to_c[i]) for i in range(n)])\\n```\\n\\nand you\\'ll see that the solution is 2 and the method by [@sanket54](/sanket54) works\\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "[@himanshupanwar123](/himanshupanwar123) The key point is that a request `[a, b]` means an employee moves from building `a` to building `b`. To fulfill a request, the building `a` must have at least one employee.\\n\\nConsider your example `[1,1],[1,1]`, these two requests mean two employees leave building `1` and re-enter building `1`. Initially, we must have at least two employees in building `1` to fulfill both requests.\\n\\nSuppose building `1` starts with only one employee. We can fulfill the first request `[1,1]` because there\\'s an employee in building `1` who can leave and re-enter. But after this request, there\\'s still only one employee in building `1`. Now if we try to fulfill the second request `[1,1]`, we can\\'t, because we don\\'t have a second employee in building `1` to leave and re-enter. Therefore, in this situation, we can only fulfill one request, not two.\\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "That\\'s a good question, and this approach of using the minimum of in-degree and out-degree of a node seems to make sense at first glance because intuitively, you could fulfill as many requests as the minimum of in-degree and out-degree.\\n\\nHowever, this approach won\\'t work in all cases because the order of the requests matter. Let\\'s take an example to illustrate this:\\n\\nSuppose we have 3 buildings (0, 1, 2) and 4 requests: \\n```\\n[0, 1]\\n[1, 2]\\n[0, 1]\\n[2, 0]\\n```\\nIf you look at the minimum of in-degree and out-degree, all buildings have 2 incoming and 2 outgoing requests. So, you might think we can fulfill all 4 requests. But if you try to fulfill the requests in the order they\\'re given, after the first 3 requests, building 0 will have no employees left, so the last request can\\'t be fulfilled.\\n\\nOn the other hand, if you rearrange the requests like this:\\n```\\n[0, 1]\\n[0, 1]\\n[1, 2]\\n[2, 0]\\n```\\nNow, you can fulfill all 4 requests. \\n\\nSo, the problem is more complex than just looking at the minimum of in-degree and out-degree for each node, because the order of the requests matter. Therefore, we need to consider all possible arrangements of the requests, which is why we use a DFS with bit manipulation to generate all subsets of requests, and then check which subset can fulfill the maximum number of requests."
                    },
                    {
                        "username": "jain_06_07",
                        "content": "[@himanshupanwar123](/himanshupanwar123) Sure...\\n3\\n[[0,0], [1,1], [0,0], [2,0], [2,2], [1,1], [2,1], [0,1], [0,1]]\\n\\n[0,0], [1,1], [0,0], [2,2], [1,1] --> ignore these cases as it will not affect anything. worker leaves company and joins again but its request is full filled. Right so ans = 5 till now\\n\\nNow, for remaining requests [2,0], [2,1], [0,1], [0,1]. \\nif you\\'ll draw graph now then you will see\\nfor company 0 you\\'ve one incoming worker from company 2 and two worker leaving for company 1\\nand for company 1 there is only three workers that are coming but no one is leaving So company 1 cannot accept any worker from company 0. \\n\\nSo, it cannot fulfill the request even company 0 has sufficient indegree and outdegree. "
                    },
                    {
                        "username": "himanshupanwar123",
                        "content": "[@jain_06_07](/jain_06_07)  can you elaborate this example a bit i am also stuck at this since [1,1],[1,1] means two employes leaves and again they enter that means 2 request fullfilled."
                    },
                    {
                        "username": "Swastik_Gorai",
                        "content": "[@jain_06_07](/jain_06_07) please explain\\n"
                    },
                    {
                        "username": "jain_06_07",
                        "content": "[@amin_aziz](/amin_aziz) 6 ach/request ? Can you explain"
                    },
                    {
                        "username": "amin_aziz",
                        "content": "[@jain_06_07](/jain_06_07)\\nthere is 6 ach/request, but expected 5?"
                    },
                    {
                        "username": "jain_06_07",
                        "content": "see this case\\n3\\n[[0,0],[1,1],[0,0],[2,0],[2,2],[1,1],[2,1],[0,1],[0,1]]\\nIn this case , Indegree(0) = 1 and outdegree(0) = 2 \\nbut for node 1, there is no outdegree so It we can not take worker from node 0 and hence node 0 can\\'t send a worker also"
                    },
                    {
                        "username": "Rubiya1090",
                        "content": "It\\'s exhausting to see continuous medium & hard problems. Solving the leet code problem is fun when there is a right balance b/w difficulty level."
                    },
                    {
                        "username": "joseph261059",
                        "content": "It is a standard backtracking problem, it is not hard at all"
                    },
                    {
                        "username": "void_8t",
                        "content": "its not that hard, try it you can :)"
                    },
                    {
                        "username": "shubhampr10",
                        "content": "\\nWe\\'ve got other work to do.\\uD83D\\uDE2D"
                    },
                    {
                        "username": "mochy",
                        "content": "Why does brute force work lol"
                    },
                    {
                        "username": "charonme",
                        "content": "constraints are quite low, only 2^20 = 1048576 permutations at worst"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "Because of its \\uD83D\\uDCAA brutal force \\uD83D\\uDCAA, of course."
                    },
                    {
                        "username": "crosslives",
                        "content": "I think this is a Minimum Cost Maximum Flow problem. \\n\\nFirstly, we should calculate # of redundant requests and # of absent requests.\\n\\nThen we can construct a graph, G = <V, E>\\n\\nV = {S, T, Factory_1, Factory_2, ..., Factory_n}\\nE = { (S -> Factories that have redundant requests),\\n         (Facotries that need requests -> T,\\n\\t\\t All other edges provided by function\\n\\t\\t}\\nThe cost of each unit is 1. \\nThen we can calculate  Minimum Cost Maximum Flow of G. \\n\\\\# of requests - minimum cost is answer.\\n\\nI didn\\'t implement it but think it may be a possible solution.\\n\\nIs there more efficient solution for this problem?"
                    },
                    {
                        "username": "cecilia5",
                        "content": "[@f20201214](/f20201214) I posted it on the solutions."
                    },
                    {
                        "username": "f20201214",
                        "content": "[@cecilia5](/cecilia5) Could you share your solution?\\n"
                    },
                    {
                        "username": "VMAtm",
                        "content": "Yeah, thought about it too and was expecting to see this in editorial ("
                    },
                    {
                        "username": "cecilia5",
                        "content": "Minimum cost flow worked, you don\\'t need to add any nodes - just model the cost of a request is -1 and keep canceling negative cycles on the residual graph. "
                    },
                    {
                        "username": "autf",
                        "content": "I nominate this as an easiest `Hard` problem candidate."
                    },
                    {
                        "username": "IamVaibhave53",
                        "content": "Just curious to why this problem has been marked hard, when there are mediums which require more thinking than this one..."
                    }
                ]
            },
            {
                "id": 1568452,
                "content": [
                    {
                        "username": "yabyer1",
                        "content": "So many transfers, office looks like Chelsea"
                    },
                    {
                        "username": "oshok",
                        "content": "\\uD83D\\uDE02"
                    },
                    {
                        "username": "fenil3357",
                        "content": "still finished 12th."
                    },
                    {
                        "username": "mihirrawool1907",
                        "content": "[@subhamsadhukhan95](/subhamsadhukhan95) good pun\\n"
                    },
                    {
                        "username": "subhamsadhukhan95",
                        "content": "good one "
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "I thought the month will start with easy problems."
                    },
                    {
                        "username": "sarthakr10",
                        "content": "ha yr \\n"
                    },
                    {
                        "username": "eduard92",
                        "content": "Its also weekend. So Its O(n^n) psychological damage"
                    },
                    {
                        "username": "suren-yeager",
                        "content": "Just like yesterday\\'s daily challenge, constraints clearly tell us that this problem can be solved by brute force and this doesn\\'t deserve to be hard"
                    },
                    {
                        "username": "amitbansal13",
                        "content": "Leetcode is playing with our emotions now"
                    },
                    {
                        "username": "sanket54",
                        "content": "Why can\\'t we do it using minimum of in-degree and out-degree of the node?"
                    },
                    {
                        "username": "w7089",
                        "content": "have a look at the example `[[0,1],[2,1],[2,0]]` n=3"
                    },
                    {
                        "username": "w7089",
                        "content": "[@bparanj](/bparanj) again, the method by [@sanket54](/sanket54) works and returnsthe correct answer - 3, order doesn\\'t matter here"
                    },
                    {
                        "username": "w7089",
                        "content": "[@bparanj](/bparanj) try to run the below code on [[1,1],[1,1]], n=2:\\n\\n```\\nclass Solution:\\n    def maximumRequests(self, n: int, requests: List[List[int]]) -> int:\\n        from_c = Counter()\\n        to_c = Counter()\\n        for f_t in requests:\\n            f,t = f_t\\n            from_c[f] += 1\\n            to_c[t] += 1\\n        return sum([min(from_c[i], to_c[i]) for i in range(n)])\\n```\\n\\nand you\\'ll see that the solution is 2 and the method by [@sanket54](/sanket54) works\\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "[@himanshupanwar123](/himanshupanwar123) The key point is that a request `[a, b]` means an employee moves from building `a` to building `b`. To fulfill a request, the building `a` must have at least one employee.\\n\\nConsider your example `[1,1],[1,1]`, these two requests mean two employees leave building `1` and re-enter building `1`. Initially, we must have at least two employees in building `1` to fulfill both requests.\\n\\nSuppose building `1` starts with only one employee. We can fulfill the first request `[1,1]` because there\\'s an employee in building `1` who can leave and re-enter. But after this request, there\\'s still only one employee in building `1`. Now if we try to fulfill the second request `[1,1]`, we can\\'t, because we don\\'t have a second employee in building `1` to leave and re-enter. Therefore, in this situation, we can only fulfill one request, not two.\\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "That\\'s a good question, and this approach of using the minimum of in-degree and out-degree of a node seems to make sense at first glance because intuitively, you could fulfill as many requests as the minimum of in-degree and out-degree.\\n\\nHowever, this approach won\\'t work in all cases because the order of the requests matter. Let\\'s take an example to illustrate this:\\n\\nSuppose we have 3 buildings (0, 1, 2) and 4 requests: \\n```\\n[0, 1]\\n[1, 2]\\n[0, 1]\\n[2, 0]\\n```\\nIf you look at the minimum of in-degree and out-degree, all buildings have 2 incoming and 2 outgoing requests. So, you might think we can fulfill all 4 requests. But if you try to fulfill the requests in the order they\\'re given, after the first 3 requests, building 0 will have no employees left, so the last request can\\'t be fulfilled.\\n\\nOn the other hand, if you rearrange the requests like this:\\n```\\n[0, 1]\\n[0, 1]\\n[1, 2]\\n[2, 0]\\n```\\nNow, you can fulfill all 4 requests. \\n\\nSo, the problem is more complex than just looking at the minimum of in-degree and out-degree for each node, because the order of the requests matter. Therefore, we need to consider all possible arrangements of the requests, which is why we use a DFS with bit manipulation to generate all subsets of requests, and then check which subset can fulfill the maximum number of requests."
                    },
                    {
                        "username": "jain_06_07",
                        "content": "[@himanshupanwar123](/himanshupanwar123) Sure...\\n3\\n[[0,0], [1,1], [0,0], [2,0], [2,2], [1,1], [2,1], [0,1], [0,1]]\\n\\n[0,0], [1,1], [0,0], [2,2], [1,1] --> ignore these cases as it will not affect anything. worker leaves company and joins again but its request is full filled. Right so ans = 5 till now\\n\\nNow, for remaining requests [2,0], [2,1], [0,1], [0,1]. \\nif you\\'ll draw graph now then you will see\\nfor company 0 you\\'ve one incoming worker from company 2 and two worker leaving for company 1\\nand for company 1 there is only three workers that are coming but no one is leaving So company 1 cannot accept any worker from company 0. \\n\\nSo, it cannot fulfill the request even company 0 has sufficient indegree and outdegree. "
                    },
                    {
                        "username": "himanshupanwar123",
                        "content": "[@jain_06_07](/jain_06_07)  can you elaborate this example a bit i am also stuck at this since [1,1],[1,1] means two employes leaves and again they enter that means 2 request fullfilled."
                    },
                    {
                        "username": "Swastik_Gorai",
                        "content": "[@jain_06_07](/jain_06_07) please explain\\n"
                    },
                    {
                        "username": "jain_06_07",
                        "content": "[@amin_aziz](/amin_aziz) 6 ach/request ? Can you explain"
                    },
                    {
                        "username": "amin_aziz",
                        "content": "[@jain_06_07](/jain_06_07)\\nthere is 6 ach/request, but expected 5?"
                    },
                    {
                        "username": "jain_06_07",
                        "content": "see this case\\n3\\n[[0,0],[1,1],[0,0],[2,0],[2,2],[1,1],[2,1],[0,1],[0,1]]\\nIn this case , Indegree(0) = 1 and outdegree(0) = 2 \\nbut for node 1, there is no outdegree so It we can not take worker from node 0 and hence node 0 can\\'t send a worker also"
                    },
                    {
                        "username": "Rubiya1090",
                        "content": "It\\'s exhausting to see continuous medium & hard problems. Solving the leet code problem is fun when there is a right balance b/w difficulty level."
                    },
                    {
                        "username": "joseph261059",
                        "content": "It is a standard backtracking problem, it is not hard at all"
                    },
                    {
                        "username": "void_8t",
                        "content": "its not that hard, try it you can :)"
                    },
                    {
                        "username": "shubhampr10",
                        "content": "\\nWe\\'ve got other work to do.\\uD83D\\uDE2D"
                    },
                    {
                        "username": "mochy",
                        "content": "Why does brute force work lol"
                    },
                    {
                        "username": "charonme",
                        "content": "constraints are quite low, only 2^20 = 1048576 permutations at worst"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "Because of its \\uD83D\\uDCAA brutal force \\uD83D\\uDCAA, of course."
                    },
                    {
                        "username": "crosslives",
                        "content": "I think this is a Minimum Cost Maximum Flow problem. \\n\\nFirstly, we should calculate # of redundant requests and # of absent requests.\\n\\nThen we can construct a graph, G = <V, E>\\n\\nV = {S, T, Factory_1, Factory_2, ..., Factory_n}\\nE = { (S -> Factories that have redundant requests),\\n         (Facotries that need requests -> T,\\n\\t\\t All other edges provided by function\\n\\t\\t}\\nThe cost of each unit is 1. \\nThen we can calculate  Minimum Cost Maximum Flow of G. \\n\\\\# of requests - minimum cost is answer.\\n\\nI didn\\'t implement it but think it may be a possible solution.\\n\\nIs there more efficient solution for this problem?"
                    },
                    {
                        "username": "cecilia5",
                        "content": "[@f20201214](/f20201214) I posted it on the solutions."
                    },
                    {
                        "username": "f20201214",
                        "content": "[@cecilia5](/cecilia5) Could you share your solution?\\n"
                    },
                    {
                        "username": "VMAtm",
                        "content": "Yeah, thought about it too and was expecting to see this in editorial ("
                    },
                    {
                        "username": "cecilia5",
                        "content": "Minimum cost flow worked, you don\\'t need to add any nodes - just model the cost of a request is -1 and keep canceling negative cycles on the residual graph. "
                    },
                    {
                        "username": "autf",
                        "content": "I nominate this as an easiest `Hard` problem candidate."
                    },
                    {
                        "username": "IamVaibhave53",
                        "content": "Just curious to why this problem has been marked hard, when there are mediums which require more thinking than this one..."
                    }
                ]
            },
            {
                "id": 1952336,
                "content": [
                    {
                        "username": "yabyer1",
                        "content": "So many transfers, office looks like Chelsea"
                    },
                    {
                        "username": "oshok",
                        "content": "\\uD83D\\uDE02"
                    },
                    {
                        "username": "fenil3357",
                        "content": "still finished 12th."
                    },
                    {
                        "username": "mihirrawool1907",
                        "content": "[@subhamsadhukhan95](/subhamsadhukhan95) good pun\\n"
                    },
                    {
                        "username": "subhamsadhukhan95",
                        "content": "good one "
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "I thought the month will start with easy problems."
                    },
                    {
                        "username": "sarthakr10",
                        "content": "ha yr \\n"
                    },
                    {
                        "username": "eduard92",
                        "content": "Its also weekend. So Its O(n^n) psychological damage"
                    },
                    {
                        "username": "suren-yeager",
                        "content": "Just like yesterday\\'s daily challenge, constraints clearly tell us that this problem can be solved by brute force and this doesn\\'t deserve to be hard"
                    },
                    {
                        "username": "amitbansal13",
                        "content": "Leetcode is playing with our emotions now"
                    },
                    {
                        "username": "sanket54",
                        "content": "Why can\\'t we do it using minimum of in-degree and out-degree of the node?"
                    },
                    {
                        "username": "w7089",
                        "content": "have a look at the example `[[0,1],[2,1],[2,0]]` n=3"
                    },
                    {
                        "username": "w7089",
                        "content": "[@bparanj](/bparanj) again, the method by [@sanket54](/sanket54) works and returnsthe correct answer - 3, order doesn\\'t matter here"
                    },
                    {
                        "username": "w7089",
                        "content": "[@bparanj](/bparanj) try to run the below code on [[1,1],[1,1]], n=2:\\n\\n```\\nclass Solution:\\n    def maximumRequests(self, n: int, requests: List[List[int]]) -> int:\\n        from_c = Counter()\\n        to_c = Counter()\\n        for f_t in requests:\\n            f,t = f_t\\n            from_c[f] += 1\\n            to_c[t] += 1\\n        return sum([min(from_c[i], to_c[i]) for i in range(n)])\\n```\\n\\nand you\\'ll see that the solution is 2 and the method by [@sanket54](/sanket54) works\\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "[@himanshupanwar123](/himanshupanwar123) The key point is that a request `[a, b]` means an employee moves from building `a` to building `b`. To fulfill a request, the building `a` must have at least one employee.\\n\\nConsider your example `[1,1],[1,1]`, these two requests mean two employees leave building `1` and re-enter building `1`. Initially, we must have at least two employees in building `1` to fulfill both requests.\\n\\nSuppose building `1` starts with only one employee. We can fulfill the first request `[1,1]` because there\\'s an employee in building `1` who can leave and re-enter. But after this request, there\\'s still only one employee in building `1`. Now if we try to fulfill the second request `[1,1]`, we can\\'t, because we don\\'t have a second employee in building `1` to leave and re-enter. Therefore, in this situation, we can only fulfill one request, not two.\\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "That\\'s a good question, and this approach of using the minimum of in-degree and out-degree of a node seems to make sense at first glance because intuitively, you could fulfill as many requests as the minimum of in-degree and out-degree.\\n\\nHowever, this approach won\\'t work in all cases because the order of the requests matter. Let\\'s take an example to illustrate this:\\n\\nSuppose we have 3 buildings (0, 1, 2) and 4 requests: \\n```\\n[0, 1]\\n[1, 2]\\n[0, 1]\\n[2, 0]\\n```\\nIf you look at the minimum of in-degree and out-degree, all buildings have 2 incoming and 2 outgoing requests. So, you might think we can fulfill all 4 requests. But if you try to fulfill the requests in the order they\\'re given, after the first 3 requests, building 0 will have no employees left, so the last request can\\'t be fulfilled.\\n\\nOn the other hand, if you rearrange the requests like this:\\n```\\n[0, 1]\\n[0, 1]\\n[1, 2]\\n[2, 0]\\n```\\nNow, you can fulfill all 4 requests. \\n\\nSo, the problem is more complex than just looking at the minimum of in-degree and out-degree for each node, because the order of the requests matter. Therefore, we need to consider all possible arrangements of the requests, which is why we use a DFS with bit manipulation to generate all subsets of requests, and then check which subset can fulfill the maximum number of requests."
                    },
                    {
                        "username": "jain_06_07",
                        "content": "[@himanshupanwar123](/himanshupanwar123) Sure...\\n3\\n[[0,0], [1,1], [0,0], [2,0], [2,2], [1,1], [2,1], [0,1], [0,1]]\\n\\n[0,0], [1,1], [0,0], [2,2], [1,1] --> ignore these cases as it will not affect anything. worker leaves company and joins again but its request is full filled. Right so ans = 5 till now\\n\\nNow, for remaining requests [2,0], [2,1], [0,1], [0,1]. \\nif you\\'ll draw graph now then you will see\\nfor company 0 you\\'ve one incoming worker from company 2 and two worker leaving for company 1\\nand for company 1 there is only three workers that are coming but no one is leaving So company 1 cannot accept any worker from company 0. \\n\\nSo, it cannot fulfill the request even company 0 has sufficient indegree and outdegree. "
                    },
                    {
                        "username": "himanshupanwar123",
                        "content": "[@jain_06_07](/jain_06_07)  can you elaborate this example a bit i am also stuck at this since [1,1],[1,1] means two employes leaves and again they enter that means 2 request fullfilled."
                    },
                    {
                        "username": "Swastik_Gorai",
                        "content": "[@jain_06_07](/jain_06_07) please explain\\n"
                    },
                    {
                        "username": "jain_06_07",
                        "content": "[@amin_aziz](/amin_aziz) 6 ach/request ? Can you explain"
                    },
                    {
                        "username": "amin_aziz",
                        "content": "[@jain_06_07](/jain_06_07)\\nthere is 6 ach/request, but expected 5?"
                    },
                    {
                        "username": "jain_06_07",
                        "content": "see this case\\n3\\n[[0,0],[1,1],[0,0],[2,0],[2,2],[1,1],[2,1],[0,1],[0,1]]\\nIn this case , Indegree(0) = 1 and outdegree(0) = 2 \\nbut for node 1, there is no outdegree so It we can not take worker from node 0 and hence node 0 can\\'t send a worker also"
                    },
                    {
                        "username": "Rubiya1090",
                        "content": "It\\'s exhausting to see continuous medium & hard problems. Solving the leet code problem is fun when there is a right balance b/w difficulty level."
                    },
                    {
                        "username": "joseph261059",
                        "content": "It is a standard backtracking problem, it is not hard at all"
                    },
                    {
                        "username": "void_8t",
                        "content": "its not that hard, try it you can :)"
                    },
                    {
                        "username": "shubhampr10",
                        "content": "\\nWe\\'ve got other work to do.\\uD83D\\uDE2D"
                    },
                    {
                        "username": "mochy",
                        "content": "Why does brute force work lol"
                    },
                    {
                        "username": "charonme",
                        "content": "constraints are quite low, only 2^20 = 1048576 permutations at worst"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "Because of its \\uD83D\\uDCAA brutal force \\uD83D\\uDCAA, of course."
                    },
                    {
                        "username": "crosslives",
                        "content": "I think this is a Minimum Cost Maximum Flow problem. \\n\\nFirstly, we should calculate # of redundant requests and # of absent requests.\\n\\nThen we can construct a graph, G = <V, E>\\n\\nV = {S, T, Factory_1, Factory_2, ..., Factory_n}\\nE = { (S -> Factories that have redundant requests),\\n         (Facotries that need requests -> T,\\n\\t\\t All other edges provided by function\\n\\t\\t}\\nThe cost of each unit is 1. \\nThen we can calculate  Minimum Cost Maximum Flow of G. \\n\\\\# of requests - minimum cost is answer.\\n\\nI didn\\'t implement it but think it may be a possible solution.\\n\\nIs there more efficient solution for this problem?"
                    },
                    {
                        "username": "cecilia5",
                        "content": "[@f20201214](/f20201214) I posted it on the solutions."
                    },
                    {
                        "username": "f20201214",
                        "content": "[@cecilia5](/cecilia5) Could you share your solution?\\n"
                    },
                    {
                        "username": "VMAtm",
                        "content": "Yeah, thought about it too and was expecting to see this in editorial ("
                    },
                    {
                        "username": "cecilia5",
                        "content": "Minimum cost flow worked, you don\\'t need to add any nodes - just model the cost of a request is -1 and keep canceling negative cycles on the residual graph. "
                    },
                    {
                        "username": "autf",
                        "content": "I nominate this as an easiest `Hard` problem candidate."
                    },
                    {
                        "username": "IamVaibhave53",
                        "content": "Just curious to why this problem has been marked hard, when there are mediums which require more thinking than this one..."
                    }
                ]
            },
            {
                "id": 1574992,
                "content": [
                    {
                        "username": "yabyer1",
                        "content": "So many transfers, office looks like Chelsea"
                    },
                    {
                        "username": "oshok",
                        "content": "\\uD83D\\uDE02"
                    },
                    {
                        "username": "fenil3357",
                        "content": "still finished 12th."
                    },
                    {
                        "username": "mihirrawool1907",
                        "content": "[@subhamsadhukhan95](/subhamsadhukhan95) good pun\\n"
                    },
                    {
                        "username": "subhamsadhukhan95",
                        "content": "good one "
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "I thought the month will start with easy problems."
                    },
                    {
                        "username": "sarthakr10",
                        "content": "ha yr \\n"
                    },
                    {
                        "username": "eduard92",
                        "content": "Its also weekend. So Its O(n^n) psychological damage"
                    },
                    {
                        "username": "suren-yeager",
                        "content": "Just like yesterday\\'s daily challenge, constraints clearly tell us that this problem can be solved by brute force and this doesn\\'t deserve to be hard"
                    },
                    {
                        "username": "amitbansal13",
                        "content": "Leetcode is playing with our emotions now"
                    },
                    {
                        "username": "sanket54",
                        "content": "Why can\\'t we do it using minimum of in-degree and out-degree of the node?"
                    },
                    {
                        "username": "w7089",
                        "content": "have a look at the example `[[0,1],[2,1],[2,0]]` n=3"
                    },
                    {
                        "username": "w7089",
                        "content": "[@bparanj](/bparanj) again, the method by [@sanket54](/sanket54) works and returnsthe correct answer - 3, order doesn\\'t matter here"
                    },
                    {
                        "username": "w7089",
                        "content": "[@bparanj](/bparanj) try to run the below code on [[1,1],[1,1]], n=2:\\n\\n```\\nclass Solution:\\n    def maximumRequests(self, n: int, requests: List[List[int]]) -> int:\\n        from_c = Counter()\\n        to_c = Counter()\\n        for f_t in requests:\\n            f,t = f_t\\n            from_c[f] += 1\\n            to_c[t] += 1\\n        return sum([min(from_c[i], to_c[i]) for i in range(n)])\\n```\\n\\nand you\\'ll see that the solution is 2 and the method by [@sanket54](/sanket54) works\\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "[@himanshupanwar123](/himanshupanwar123) The key point is that a request `[a, b]` means an employee moves from building `a` to building `b`. To fulfill a request, the building `a` must have at least one employee.\\n\\nConsider your example `[1,1],[1,1]`, these two requests mean two employees leave building `1` and re-enter building `1`. Initially, we must have at least two employees in building `1` to fulfill both requests.\\n\\nSuppose building `1` starts with only one employee. We can fulfill the first request `[1,1]` because there\\'s an employee in building `1` who can leave and re-enter. But after this request, there\\'s still only one employee in building `1`. Now if we try to fulfill the second request `[1,1]`, we can\\'t, because we don\\'t have a second employee in building `1` to leave and re-enter. Therefore, in this situation, we can only fulfill one request, not two.\\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "That\\'s a good question, and this approach of using the minimum of in-degree and out-degree of a node seems to make sense at first glance because intuitively, you could fulfill as many requests as the minimum of in-degree and out-degree.\\n\\nHowever, this approach won\\'t work in all cases because the order of the requests matter. Let\\'s take an example to illustrate this:\\n\\nSuppose we have 3 buildings (0, 1, 2) and 4 requests: \\n```\\n[0, 1]\\n[1, 2]\\n[0, 1]\\n[2, 0]\\n```\\nIf you look at the minimum of in-degree and out-degree, all buildings have 2 incoming and 2 outgoing requests. So, you might think we can fulfill all 4 requests. But if you try to fulfill the requests in the order they\\'re given, after the first 3 requests, building 0 will have no employees left, so the last request can\\'t be fulfilled.\\n\\nOn the other hand, if you rearrange the requests like this:\\n```\\n[0, 1]\\n[0, 1]\\n[1, 2]\\n[2, 0]\\n```\\nNow, you can fulfill all 4 requests. \\n\\nSo, the problem is more complex than just looking at the minimum of in-degree and out-degree for each node, because the order of the requests matter. Therefore, we need to consider all possible arrangements of the requests, which is why we use a DFS with bit manipulation to generate all subsets of requests, and then check which subset can fulfill the maximum number of requests."
                    },
                    {
                        "username": "jain_06_07",
                        "content": "[@himanshupanwar123](/himanshupanwar123) Sure...\\n3\\n[[0,0], [1,1], [0,0], [2,0], [2,2], [1,1], [2,1], [0,1], [0,1]]\\n\\n[0,0], [1,1], [0,0], [2,2], [1,1] --> ignore these cases as it will not affect anything. worker leaves company and joins again but its request is full filled. Right so ans = 5 till now\\n\\nNow, for remaining requests [2,0], [2,1], [0,1], [0,1]. \\nif you\\'ll draw graph now then you will see\\nfor company 0 you\\'ve one incoming worker from company 2 and two worker leaving for company 1\\nand for company 1 there is only three workers that are coming but no one is leaving So company 1 cannot accept any worker from company 0. \\n\\nSo, it cannot fulfill the request even company 0 has sufficient indegree and outdegree. "
                    },
                    {
                        "username": "himanshupanwar123",
                        "content": "[@jain_06_07](/jain_06_07)  can you elaborate this example a bit i am also stuck at this since [1,1],[1,1] means two employes leaves and again they enter that means 2 request fullfilled."
                    },
                    {
                        "username": "Swastik_Gorai",
                        "content": "[@jain_06_07](/jain_06_07) please explain\\n"
                    },
                    {
                        "username": "jain_06_07",
                        "content": "[@amin_aziz](/amin_aziz) 6 ach/request ? Can you explain"
                    },
                    {
                        "username": "amin_aziz",
                        "content": "[@jain_06_07](/jain_06_07)\\nthere is 6 ach/request, but expected 5?"
                    },
                    {
                        "username": "jain_06_07",
                        "content": "see this case\\n3\\n[[0,0],[1,1],[0,0],[2,0],[2,2],[1,1],[2,1],[0,1],[0,1]]\\nIn this case , Indegree(0) = 1 and outdegree(0) = 2 \\nbut for node 1, there is no outdegree so It we can not take worker from node 0 and hence node 0 can\\'t send a worker also"
                    },
                    {
                        "username": "Rubiya1090",
                        "content": "It\\'s exhausting to see continuous medium & hard problems. Solving the leet code problem is fun when there is a right balance b/w difficulty level."
                    },
                    {
                        "username": "joseph261059",
                        "content": "It is a standard backtracking problem, it is not hard at all"
                    },
                    {
                        "username": "void_8t",
                        "content": "its not that hard, try it you can :)"
                    },
                    {
                        "username": "shubhampr10",
                        "content": "\\nWe\\'ve got other work to do.\\uD83D\\uDE2D"
                    },
                    {
                        "username": "mochy",
                        "content": "Why does brute force work lol"
                    },
                    {
                        "username": "charonme",
                        "content": "constraints are quite low, only 2^20 = 1048576 permutations at worst"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "Because of its \\uD83D\\uDCAA brutal force \\uD83D\\uDCAA, of course."
                    },
                    {
                        "username": "crosslives",
                        "content": "I think this is a Minimum Cost Maximum Flow problem. \\n\\nFirstly, we should calculate # of redundant requests and # of absent requests.\\n\\nThen we can construct a graph, G = <V, E>\\n\\nV = {S, T, Factory_1, Factory_2, ..., Factory_n}\\nE = { (S -> Factories that have redundant requests),\\n         (Facotries that need requests -> T,\\n\\t\\t All other edges provided by function\\n\\t\\t}\\nThe cost of each unit is 1. \\nThen we can calculate  Minimum Cost Maximum Flow of G. \\n\\\\# of requests - minimum cost is answer.\\n\\nI didn\\'t implement it but think it may be a possible solution.\\n\\nIs there more efficient solution for this problem?"
                    },
                    {
                        "username": "cecilia5",
                        "content": "[@f20201214](/f20201214) I posted it on the solutions."
                    },
                    {
                        "username": "f20201214",
                        "content": "[@cecilia5](/cecilia5) Could you share your solution?\\n"
                    },
                    {
                        "username": "VMAtm",
                        "content": "Yeah, thought about it too and was expecting to see this in editorial ("
                    },
                    {
                        "username": "cecilia5",
                        "content": "Minimum cost flow worked, you don\\'t need to add any nodes - just model the cost of a request is -1 and keep canceling negative cycles on the residual graph. "
                    },
                    {
                        "username": "autf",
                        "content": "I nominate this as an easiest `Hard` problem candidate."
                    },
                    {
                        "username": "IamVaibhave53",
                        "content": "Just curious to why this problem has been marked hard, when there are mediums which require more thinking than this one..."
                    }
                ]
            },
            {
                "id": 1953280,
                "content": [
                    {
                        "username": "spatecon",
                        "content": "Astrologers announced the week of backtracking \\uD83E\\uDD75"
                    },
                    {
                        "username": "taduyanh",
                        "content": "hard problem, should we layoff all of them :("
                    },
                    {
                        "username": "rebooter",
                        "content": "LeetCode\\'s discouraging me from completing the 365-day challenge by consistently presenting hard category problems.\\n"
                    },
                    {
                        "username": "Karilli",
                        "content": "lol"
                    },
                    {
                        "username": "voodooism",
                        "content": "Bro, I\\'ve seen your first comment and remember when you started your challenge\\nBelieve me or not, but during this hard streak I sometimes think about you \\n\\nI\\'m glad to see you not giving up here and hope that leetcode will stop torturing us soon :)"
                    },
                    {
                        "username": "lucasscodes",
                        "content": "Dude you got 15 problems, what are you talking about "
                    },
                    {
                        "username": "dev-null0",
                        "content": "This should be a medium.\\n\\nAll you need to do is:\\n1. Find all distinct cycles\\n2. Try every valid combination of cycles (valid means you don\\'t use the same person twice)\\n\\nBrute force works for both and no need for any caching."
                    },
                    {
                        "username": "anwendeng",
                        "content": "There is no royal road for brute force! This question can be solved using bit mask.\nAfter a nap, I got an idea from Hamming Weight.\nHammingWeight(n)=__builtin_popcount(n)\nMaybe there is quick solution without using brute force. Let me try! It's done"
                    },
                    {
                        "username": "joseph261059",
                        "content": "My brute force backtracking in python 3 only ran in 369ms, https://leetcode.com/problems/maximum-number-of-achievable-transfer-requests/submissions/984584264/\n\nMoreover, standard DP in python3 is even faster, around 119ms, \nhttps://leetcode.com/problems/maximum-number-of-achievable-transfer-requests/submissions/984350718/"
                    },
                    {
                        "username": "psionl0",
                        "content": "It is testament to the small data size that my brute force (bit mask) solution ran in  331 ms and used 5.6 MB of memory while your solution ran in 852 ms and used 138 MB of memory !!"
                    },
                    {
                        "username": "nethajirasineni",
                        "content": "but how can you define procedure?"
                    },
                    {
                        "username": "kerminek",
                        "content": "Sundays :))"
                    },
                    {
                        "username": "f-blan",
                        "content": "The description does not give the definition of an idiot.\\nAn idiot is an employee that does not want to change the building in which they reside in, but still makes a request to be transferred to it, thus increasing the paperwork required for no purpose.\\nBeware, some employees may be idiots. "
                    },
                    {
                        "username": "sirius84",
                        "content": "Hello,\\n\\nThis question is tagged as `DP`, I\\'m wondering what would be the DP solution? I\\'m seeing Backtrack and bitmask so far."
                    },
                    {
                        "username": "feng3245",
                        "content": "DP is suppose to help you solve problems that can be ever reducable into sub problems but this one can\\'t because of the statefulness of the transfers."
                    },
                    {
                        "username": "bparanj",
                        "content": "Indeed, this problem is more commonly solved with a backtracking and bitmask approach rather than dynamic programming (DP). The backtracking solution exhaustively checks all combinations of transfer requests to find the maximum number that can be fulfilled, which is feasible given the problem\\'s constraints. \\n\\nThe bitmask part comes in when representing each set of requests. Each bit in an integer represents whether a particular request is included in the set. This way, generating all subsets of requests becomes equivalent to generating all integers up to 2^n, where n is the number of requests.\\n\\nWhile dynamic programming is a powerful technique, applying it to this problem would be challenging. The most obvious states for a DP solution would be the \"balance\" of each building and the set of requests that have been considered so far. However, there are 2^n possible subsets of requests and each building\\'s balance can range from -n to n, leading to an enormous state space that would be impractical to handle.\\n\\nHence, although this problem is tagged as DP on LeetCode, the DP approach may not be the most suitable or efficient for this particular problem. It\\'s crucial to choose the problem-solving technique that best fits the problem at hand, taking into account the problem\\'s specific requirements and constraints."
                    },
                    {
                        "username": "joseph261059",
                        "content": "dp(request_i, balance_map) = max(1 + dp(request_i + 1, balance_map_if_choose_i), dp(request_i + 1, balance_map))\n"
                    },
                    {
                        "username": "mshoosterman",
                        "content": "This definitely isn\\'t the optimal solution, as I got beat 5% runtime, but if you dont want to think too hard about this problem, know it is possible to try all subsets of requests without getting TLE. Just try to be pretty efficient in how you represent subsets. If you have done this before you can be done with this problem and back to enjoying your weekend in 10 minutes. \\n\\n(The efficient way to check all subsets is by representing subsets by the binary representation of an integer. I\\'m not sure if its possible to do this efficiently enough in a language like python, but in java its doable, just make sure to use bitwise operations to keep things FAST). "
                    },
                    {
                        "username": "feng3245",
                        "content": "You don\\'t even need to use binary manipulate... just using regular set operation is enough for this question"
                    },
                    {
                        "username": "jain_06_07",
                        "content": "Why can\\'t we do it using minimum of in-degree and out-degree of the node?\\n\\nsee this case\\n3\\n[[0,0],[1,1],[0,0],[2,0],[2,2],[1,1],[2,1],[0,1],[0,1]]\\n\\n[0,0], [1,1], [0,0], [2,2], [1,1] --> ignore these cases as it will not affect anything. worker leaves company and joins again but its request is full filled. Right so ans = 5 till now\\n\\nNow, for remaining requests [2,0], [2,1], [0,1], [0,1].\\nif you\\'ll draw graph now then you will see\\nfor company 0 you\\'ve one incoming worker from company 2 and two worker leaving for company 1\\nand for company 1 there is only three workers that are coming but no one is leaving So company 1 cannot accept any worker from company 0.\\n\\nSo, it cannot fulfill the request even company 0 has sufficient indegree and outdegree."
                    }
                ]
            },
            {
                "id": 1952652,
                "content": [
                    {
                        "username": "spatecon",
                        "content": "Astrologers announced the week of backtracking \\uD83E\\uDD75"
                    },
                    {
                        "username": "taduyanh",
                        "content": "hard problem, should we layoff all of them :("
                    },
                    {
                        "username": "rebooter",
                        "content": "LeetCode\\'s discouraging me from completing the 365-day challenge by consistently presenting hard category problems.\\n"
                    },
                    {
                        "username": "Karilli",
                        "content": "lol"
                    },
                    {
                        "username": "voodooism",
                        "content": "Bro, I\\'ve seen your first comment and remember when you started your challenge\\nBelieve me or not, but during this hard streak I sometimes think about you \\n\\nI\\'m glad to see you not giving up here and hope that leetcode will stop torturing us soon :)"
                    },
                    {
                        "username": "lucasscodes",
                        "content": "Dude you got 15 problems, what are you talking about "
                    },
                    {
                        "username": "dev-null0",
                        "content": "This should be a medium.\\n\\nAll you need to do is:\\n1. Find all distinct cycles\\n2. Try every valid combination of cycles (valid means you don\\'t use the same person twice)\\n\\nBrute force works for both and no need for any caching."
                    },
                    {
                        "username": "anwendeng",
                        "content": "There is no royal road for brute force! This question can be solved using bit mask.\nAfter a nap, I got an idea from Hamming Weight.\nHammingWeight(n)=__builtin_popcount(n)\nMaybe there is quick solution without using brute force. Let me try! It's done"
                    },
                    {
                        "username": "joseph261059",
                        "content": "My brute force backtracking in python 3 only ran in 369ms, https://leetcode.com/problems/maximum-number-of-achievable-transfer-requests/submissions/984584264/\n\nMoreover, standard DP in python3 is even faster, around 119ms, \nhttps://leetcode.com/problems/maximum-number-of-achievable-transfer-requests/submissions/984350718/"
                    },
                    {
                        "username": "psionl0",
                        "content": "It is testament to the small data size that my brute force (bit mask) solution ran in  331 ms and used 5.6 MB of memory while your solution ran in 852 ms and used 138 MB of memory !!"
                    },
                    {
                        "username": "nethajirasineni",
                        "content": "but how can you define procedure?"
                    },
                    {
                        "username": "kerminek",
                        "content": "Sundays :))"
                    },
                    {
                        "username": "f-blan",
                        "content": "The description does not give the definition of an idiot.\\nAn idiot is an employee that does not want to change the building in which they reside in, but still makes a request to be transferred to it, thus increasing the paperwork required for no purpose.\\nBeware, some employees may be idiots. "
                    },
                    {
                        "username": "sirius84",
                        "content": "Hello,\\n\\nThis question is tagged as `DP`, I\\'m wondering what would be the DP solution? I\\'m seeing Backtrack and bitmask so far."
                    },
                    {
                        "username": "feng3245",
                        "content": "DP is suppose to help you solve problems that can be ever reducable into sub problems but this one can\\'t because of the statefulness of the transfers."
                    },
                    {
                        "username": "bparanj",
                        "content": "Indeed, this problem is more commonly solved with a backtracking and bitmask approach rather than dynamic programming (DP). The backtracking solution exhaustively checks all combinations of transfer requests to find the maximum number that can be fulfilled, which is feasible given the problem\\'s constraints. \\n\\nThe bitmask part comes in when representing each set of requests. Each bit in an integer represents whether a particular request is included in the set. This way, generating all subsets of requests becomes equivalent to generating all integers up to 2^n, where n is the number of requests.\\n\\nWhile dynamic programming is a powerful technique, applying it to this problem would be challenging. The most obvious states for a DP solution would be the \"balance\" of each building and the set of requests that have been considered so far. However, there are 2^n possible subsets of requests and each building\\'s balance can range from -n to n, leading to an enormous state space that would be impractical to handle.\\n\\nHence, although this problem is tagged as DP on LeetCode, the DP approach may not be the most suitable or efficient for this particular problem. It\\'s crucial to choose the problem-solving technique that best fits the problem at hand, taking into account the problem\\'s specific requirements and constraints."
                    },
                    {
                        "username": "joseph261059",
                        "content": "dp(request_i, balance_map) = max(1 + dp(request_i + 1, balance_map_if_choose_i), dp(request_i + 1, balance_map))\n"
                    },
                    {
                        "username": "mshoosterman",
                        "content": "This definitely isn\\'t the optimal solution, as I got beat 5% runtime, but if you dont want to think too hard about this problem, know it is possible to try all subsets of requests without getting TLE. Just try to be pretty efficient in how you represent subsets. If you have done this before you can be done with this problem and back to enjoying your weekend in 10 minutes. \\n\\n(The efficient way to check all subsets is by representing subsets by the binary representation of an integer. I\\'m not sure if its possible to do this efficiently enough in a language like python, but in java its doable, just make sure to use bitwise operations to keep things FAST). "
                    },
                    {
                        "username": "feng3245",
                        "content": "You don\\'t even need to use binary manipulate... just using regular set operation is enough for this question"
                    },
                    {
                        "username": "jain_06_07",
                        "content": "Why can\\'t we do it using minimum of in-degree and out-degree of the node?\\n\\nsee this case\\n3\\n[[0,0],[1,1],[0,0],[2,0],[2,2],[1,1],[2,1],[0,1],[0,1]]\\n\\n[0,0], [1,1], [0,0], [2,2], [1,1] --> ignore these cases as it will not affect anything. worker leaves company and joins again but its request is full filled. Right so ans = 5 till now\\n\\nNow, for remaining requests [2,0], [2,1], [0,1], [0,1].\\nif you\\'ll draw graph now then you will see\\nfor company 0 you\\'ve one incoming worker from company 2 and two worker leaving for company 1\\nand for company 1 there is only three workers that are coming but no one is leaving So company 1 cannot accept any worker from company 0.\\n\\nSo, it cannot fulfill the request even company 0 has sufficient indegree and outdegree."
                    }
                ]
            },
            {
                "id": 1952557,
                "content": [
                    {
                        "username": "spatecon",
                        "content": "Astrologers announced the week of backtracking \\uD83E\\uDD75"
                    },
                    {
                        "username": "taduyanh",
                        "content": "hard problem, should we layoff all of them :("
                    },
                    {
                        "username": "rebooter",
                        "content": "LeetCode\\'s discouraging me from completing the 365-day challenge by consistently presenting hard category problems.\\n"
                    },
                    {
                        "username": "Karilli",
                        "content": "lol"
                    },
                    {
                        "username": "voodooism",
                        "content": "Bro, I\\'ve seen your first comment and remember when you started your challenge\\nBelieve me or not, but during this hard streak I sometimes think about you \\n\\nI\\'m glad to see you not giving up here and hope that leetcode will stop torturing us soon :)"
                    },
                    {
                        "username": "lucasscodes",
                        "content": "Dude you got 15 problems, what are you talking about "
                    },
                    {
                        "username": "dev-null0",
                        "content": "This should be a medium.\\n\\nAll you need to do is:\\n1. Find all distinct cycles\\n2. Try every valid combination of cycles (valid means you don\\'t use the same person twice)\\n\\nBrute force works for both and no need for any caching."
                    },
                    {
                        "username": "anwendeng",
                        "content": "There is no royal road for brute force! This question can be solved using bit mask.\nAfter a nap, I got an idea from Hamming Weight.\nHammingWeight(n)=__builtin_popcount(n)\nMaybe there is quick solution without using brute force. Let me try! It's done"
                    },
                    {
                        "username": "joseph261059",
                        "content": "My brute force backtracking in python 3 only ran in 369ms, https://leetcode.com/problems/maximum-number-of-achievable-transfer-requests/submissions/984584264/\n\nMoreover, standard DP in python3 is even faster, around 119ms, \nhttps://leetcode.com/problems/maximum-number-of-achievable-transfer-requests/submissions/984350718/"
                    },
                    {
                        "username": "psionl0",
                        "content": "It is testament to the small data size that my brute force (bit mask) solution ran in  331 ms and used 5.6 MB of memory while your solution ran in 852 ms and used 138 MB of memory !!"
                    },
                    {
                        "username": "nethajirasineni",
                        "content": "but how can you define procedure?"
                    },
                    {
                        "username": "kerminek",
                        "content": "Sundays :))"
                    },
                    {
                        "username": "f-blan",
                        "content": "The description does not give the definition of an idiot.\\nAn idiot is an employee that does not want to change the building in which they reside in, but still makes a request to be transferred to it, thus increasing the paperwork required for no purpose.\\nBeware, some employees may be idiots. "
                    },
                    {
                        "username": "sirius84",
                        "content": "Hello,\\n\\nThis question is tagged as `DP`, I\\'m wondering what would be the DP solution? I\\'m seeing Backtrack and bitmask so far."
                    },
                    {
                        "username": "feng3245",
                        "content": "DP is suppose to help you solve problems that can be ever reducable into sub problems but this one can\\'t because of the statefulness of the transfers."
                    },
                    {
                        "username": "bparanj",
                        "content": "Indeed, this problem is more commonly solved with a backtracking and bitmask approach rather than dynamic programming (DP). The backtracking solution exhaustively checks all combinations of transfer requests to find the maximum number that can be fulfilled, which is feasible given the problem\\'s constraints. \\n\\nThe bitmask part comes in when representing each set of requests. Each bit in an integer represents whether a particular request is included in the set. This way, generating all subsets of requests becomes equivalent to generating all integers up to 2^n, where n is the number of requests.\\n\\nWhile dynamic programming is a powerful technique, applying it to this problem would be challenging. The most obvious states for a DP solution would be the \"balance\" of each building and the set of requests that have been considered so far. However, there are 2^n possible subsets of requests and each building\\'s balance can range from -n to n, leading to an enormous state space that would be impractical to handle.\\n\\nHence, although this problem is tagged as DP on LeetCode, the DP approach may not be the most suitable or efficient for this particular problem. It\\'s crucial to choose the problem-solving technique that best fits the problem at hand, taking into account the problem\\'s specific requirements and constraints."
                    },
                    {
                        "username": "joseph261059",
                        "content": "dp(request_i, balance_map) = max(1 + dp(request_i + 1, balance_map_if_choose_i), dp(request_i + 1, balance_map))\n"
                    },
                    {
                        "username": "mshoosterman",
                        "content": "This definitely isn\\'t the optimal solution, as I got beat 5% runtime, but if you dont want to think too hard about this problem, know it is possible to try all subsets of requests without getting TLE. Just try to be pretty efficient in how you represent subsets. If you have done this before you can be done with this problem and back to enjoying your weekend in 10 minutes. \\n\\n(The efficient way to check all subsets is by representing subsets by the binary representation of an integer. I\\'m not sure if its possible to do this efficiently enough in a language like python, but in java its doable, just make sure to use bitwise operations to keep things FAST). "
                    },
                    {
                        "username": "feng3245",
                        "content": "You don\\'t even need to use binary manipulate... just using regular set operation is enough for this question"
                    },
                    {
                        "username": "jain_06_07",
                        "content": "Why can\\'t we do it using minimum of in-degree and out-degree of the node?\\n\\nsee this case\\n3\\n[[0,0],[1,1],[0,0],[2,0],[2,2],[1,1],[2,1],[0,1],[0,1]]\\n\\n[0,0], [1,1], [0,0], [2,2], [1,1] --> ignore these cases as it will not affect anything. worker leaves company and joins again but its request is full filled. Right so ans = 5 till now\\n\\nNow, for remaining requests [2,0], [2,1], [0,1], [0,1].\\nif you\\'ll draw graph now then you will see\\nfor company 0 you\\'ve one incoming worker from company 2 and two worker leaving for company 1\\nand for company 1 there is only three workers that are coming but no one is leaving So company 1 cannot accept any worker from company 0.\\n\\nSo, it cannot fulfill the request even company 0 has sufficient indegree and outdegree."
                    }
                ]
            },
            {
                "id": 1952251,
                "content": [
                    {
                        "username": "spatecon",
                        "content": "Astrologers announced the week of backtracking \\uD83E\\uDD75"
                    },
                    {
                        "username": "taduyanh",
                        "content": "hard problem, should we layoff all of them :("
                    },
                    {
                        "username": "rebooter",
                        "content": "LeetCode\\'s discouraging me from completing the 365-day challenge by consistently presenting hard category problems.\\n"
                    },
                    {
                        "username": "Karilli",
                        "content": "lol"
                    },
                    {
                        "username": "voodooism",
                        "content": "Bro, I\\'ve seen your first comment and remember when you started your challenge\\nBelieve me or not, but during this hard streak I sometimes think about you \\n\\nI\\'m glad to see you not giving up here and hope that leetcode will stop torturing us soon :)"
                    },
                    {
                        "username": "lucasscodes",
                        "content": "Dude you got 15 problems, what are you talking about "
                    },
                    {
                        "username": "dev-null0",
                        "content": "This should be a medium.\\n\\nAll you need to do is:\\n1. Find all distinct cycles\\n2. Try every valid combination of cycles (valid means you don\\'t use the same person twice)\\n\\nBrute force works for both and no need for any caching."
                    },
                    {
                        "username": "anwendeng",
                        "content": "There is no royal road for brute force! This question can be solved using bit mask.\nAfter a nap, I got an idea from Hamming Weight.\nHammingWeight(n)=__builtin_popcount(n)\nMaybe there is quick solution without using brute force. Let me try! It's done"
                    },
                    {
                        "username": "joseph261059",
                        "content": "My brute force backtracking in python 3 only ran in 369ms, https://leetcode.com/problems/maximum-number-of-achievable-transfer-requests/submissions/984584264/\n\nMoreover, standard DP in python3 is even faster, around 119ms, \nhttps://leetcode.com/problems/maximum-number-of-achievable-transfer-requests/submissions/984350718/"
                    },
                    {
                        "username": "psionl0",
                        "content": "It is testament to the small data size that my brute force (bit mask) solution ran in  331 ms and used 5.6 MB of memory while your solution ran in 852 ms and used 138 MB of memory !!"
                    },
                    {
                        "username": "nethajirasineni",
                        "content": "but how can you define procedure?"
                    },
                    {
                        "username": "kerminek",
                        "content": "Sundays :))"
                    },
                    {
                        "username": "f-blan",
                        "content": "The description does not give the definition of an idiot.\\nAn idiot is an employee that does not want to change the building in which they reside in, but still makes a request to be transferred to it, thus increasing the paperwork required for no purpose.\\nBeware, some employees may be idiots. "
                    },
                    {
                        "username": "sirius84",
                        "content": "Hello,\\n\\nThis question is tagged as `DP`, I\\'m wondering what would be the DP solution? I\\'m seeing Backtrack and bitmask so far."
                    },
                    {
                        "username": "feng3245",
                        "content": "DP is suppose to help you solve problems that can be ever reducable into sub problems but this one can\\'t because of the statefulness of the transfers."
                    },
                    {
                        "username": "bparanj",
                        "content": "Indeed, this problem is more commonly solved with a backtracking and bitmask approach rather than dynamic programming (DP). The backtracking solution exhaustively checks all combinations of transfer requests to find the maximum number that can be fulfilled, which is feasible given the problem\\'s constraints. \\n\\nThe bitmask part comes in when representing each set of requests. Each bit in an integer represents whether a particular request is included in the set. This way, generating all subsets of requests becomes equivalent to generating all integers up to 2^n, where n is the number of requests.\\n\\nWhile dynamic programming is a powerful technique, applying it to this problem would be challenging. The most obvious states for a DP solution would be the \"balance\" of each building and the set of requests that have been considered so far. However, there are 2^n possible subsets of requests and each building\\'s balance can range from -n to n, leading to an enormous state space that would be impractical to handle.\\n\\nHence, although this problem is tagged as DP on LeetCode, the DP approach may not be the most suitable or efficient for this particular problem. It\\'s crucial to choose the problem-solving technique that best fits the problem at hand, taking into account the problem\\'s specific requirements and constraints."
                    },
                    {
                        "username": "joseph261059",
                        "content": "dp(request_i, balance_map) = max(1 + dp(request_i + 1, balance_map_if_choose_i), dp(request_i + 1, balance_map))\n"
                    },
                    {
                        "username": "mshoosterman",
                        "content": "This definitely isn\\'t the optimal solution, as I got beat 5% runtime, but if you dont want to think too hard about this problem, know it is possible to try all subsets of requests without getting TLE. Just try to be pretty efficient in how you represent subsets. If you have done this before you can be done with this problem and back to enjoying your weekend in 10 minutes. \\n\\n(The efficient way to check all subsets is by representing subsets by the binary representation of an integer. I\\'m not sure if its possible to do this efficiently enough in a language like python, but in java its doable, just make sure to use bitwise operations to keep things FAST). "
                    },
                    {
                        "username": "feng3245",
                        "content": "You don\\'t even need to use binary manipulate... just using regular set operation is enough for this question"
                    },
                    {
                        "username": "jain_06_07",
                        "content": "Why can\\'t we do it using minimum of in-degree and out-degree of the node?\\n\\nsee this case\\n3\\n[[0,0],[1,1],[0,0],[2,0],[2,2],[1,1],[2,1],[0,1],[0,1]]\\n\\n[0,0], [1,1], [0,0], [2,2], [1,1] --> ignore these cases as it will not affect anything. worker leaves company and joins again but its request is full filled. Right so ans = 5 till now\\n\\nNow, for remaining requests [2,0], [2,1], [0,1], [0,1].\\nif you\\'ll draw graph now then you will see\\nfor company 0 you\\'ve one incoming worker from company 2 and two worker leaving for company 1\\nand for company 1 there is only three workers that are coming but no one is leaving So company 1 cannot accept any worker from company 0.\\n\\nSo, it cannot fulfill the request even company 0 has sufficient indegree and outdegree."
                    }
                ]
            },
            {
                "id": 1952232,
                "content": [
                    {
                        "username": "spatecon",
                        "content": "Astrologers announced the week of backtracking \\uD83E\\uDD75"
                    },
                    {
                        "username": "taduyanh",
                        "content": "hard problem, should we layoff all of them :("
                    },
                    {
                        "username": "rebooter",
                        "content": "LeetCode\\'s discouraging me from completing the 365-day challenge by consistently presenting hard category problems.\\n"
                    },
                    {
                        "username": "Karilli",
                        "content": "lol"
                    },
                    {
                        "username": "voodooism",
                        "content": "Bro, I\\'ve seen your first comment and remember when you started your challenge\\nBelieve me or not, but during this hard streak I sometimes think about you \\n\\nI\\'m glad to see you not giving up here and hope that leetcode will stop torturing us soon :)"
                    },
                    {
                        "username": "lucasscodes",
                        "content": "Dude you got 15 problems, what are you talking about "
                    },
                    {
                        "username": "dev-null0",
                        "content": "This should be a medium.\\n\\nAll you need to do is:\\n1. Find all distinct cycles\\n2. Try every valid combination of cycles (valid means you don\\'t use the same person twice)\\n\\nBrute force works for both and no need for any caching."
                    },
                    {
                        "username": "anwendeng",
                        "content": "There is no royal road for brute force! This question can be solved using bit mask.\nAfter a nap, I got an idea from Hamming Weight.\nHammingWeight(n)=__builtin_popcount(n)\nMaybe there is quick solution without using brute force. Let me try! It's done"
                    },
                    {
                        "username": "joseph261059",
                        "content": "My brute force backtracking in python 3 only ran in 369ms, https://leetcode.com/problems/maximum-number-of-achievable-transfer-requests/submissions/984584264/\n\nMoreover, standard DP in python3 is even faster, around 119ms, \nhttps://leetcode.com/problems/maximum-number-of-achievable-transfer-requests/submissions/984350718/"
                    },
                    {
                        "username": "psionl0",
                        "content": "It is testament to the small data size that my brute force (bit mask) solution ran in  331 ms and used 5.6 MB of memory while your solution ran in 852 ms and used 138 MB of memory !!"
                    },
                    {
                        "username": "nethajirasineni",
                        "content": "but how can you define procedure?"
                    },
                    {
                        "username": "kerminek",
                        "content": "Sundays :))"
                    },
                    {
                        "username": "f-blan",
                        "content": "The description does not give the definition of an idiot.\\nAn idiot is an employee that does not want to change the building in which they reside in, but still makes a request to be transferred to it, thus increasing the paperwork required for no purpose.\\nBeware, some employees may be idiots. "
                    },
                    {
                        "username": "sirius84",
                        "content": "Hello,\\n\\nThis question is tagged as `DP`, I\\'m wondering what would be the DP solution? I\\'m seeing Backtrack and bitmask so far."
                    },
                    {
                        "username": "feng3245",
                        "content": "DP is suppose to help you solve problems that can be ever reducable into sub problems but this one can\\'t because of the statefulness of the transfers."
                    },
                    {
                        "username": "bparanj",
                        "content": "Indeed, this problem is more commonly solved with a backtracking and bitmask approach rather than dynamic programming (DP). The backtracking solution exhaustively checks all combinations of transfer requests to find the maximum number that can be fulfilled, which is feasible given the problem\\'s constraints. \\n\\nThe bitmask part comes in when representing each set of requests. Each bit in an integer represents whether a particular request is included in the set. This way, generating all subsets of requests becomes equivalent to generating all integers up to 2^n, where n is the number of requests.\\n\\nWhile dynamic programming is a powerful technique, applying it to this problem would be challenging. The most obvious states for a DP solution would be the \"balance\" of each building and the set of requests that have been considered so far. However, there are 2^n possible subsets of requests and each building\\'s balance can range from -n to n, leading to an enormous state space that would be impractical to handle.\\n\\nHence, although this problem is tagged as DP on LeetCode, the DP approach may not be the most suitable or efficient for this particular problem. It\\'s crucial to choose the problem-solving technique that best fits the problem at hand, taking into account the problem\\'s specific requirements and constraints."
                    },
                    {
                        "username": "joseph261059",
                        "content": "dp(request_i, balance_map) = max(1 + dp(request_i + 1, balance_map_if_choose_i), dp(request_i + 1, balance_map))\n"
                    },
                    {
                        "username": "mshoosterman",
                        "content": "This definitely isn\\'t the optimal solution, as I got beat 5% runtime, but if you dont want to think too hard about this problem, know it is possible to try all subsets of requests without getting TLE. Just try to be pretty efficient in how you represent subsets. If you have done this before you can be done with this problem and back to enjoying your weekend in 10 minutes. \\n\\n(The efficient way to check all subsets is by representing subsets by the binary representation of an integer. I\\'m not sure if its possible to do this efficiently enough in a language like python, but in java its doable, just make sure to use bitwise operations to keep things FAST). "
                    },
                    {
                        "username": "feng3245",
                        "content": "You don\\'t even need to use binary manipulate... just using regular set operation is enough for this question"
                    },
                    {
                        "username": "jain_06_07",
                        "content": "Why can\\'t we do it using minimum of in-degree and out-degree of the node?\\n\\nsee this case\\n3\\n[[0,0],[1,1],[0,0],[2,0],[2,2],[1,1],[2,1],[0,1],[0,1]]\\n\\n[0,0], [1,1], [0,0], [2,2], [1,1] --> ignore these cases as it will not affect anything. worker leaves company and joins again but its request is full filled. Right so ans = 5 till now\\n\\nNow, for remaining requests [2,0], [2,1], [0,1], [0,1].\\nif you\\'ll draw graph now then you will see\\nfor company 0 you\\'ve one incoming worker from company 2 and two worker leaving for company 1\\nand for company 1 there is only three workers that are coming but no one is leaving So company 1 cannot accept any worker from company 0.\\n\\nSo, it cannot fulfill the request even company 0 has sufficient indegree and outdegree."
                    }
                ]
            },
            {
                "id": 1952217,
                "content": [
                    {
                        "username": "spatecon",
                        "content": "Astrologers announced the week of backtracking \\uD83E\\uDD75"
                    },
                    {
                        "username": "taduyanh",
                        "content": "hard problem, should we layoff all of them :("
                    },
                    {
                        "username": "rebooter",
                        "content": "LeetCode\\'s discouraging me from completing the 365-day challenge by consistently presenting hard category problems.\\n"
                    },
                    {
                        "username": "Karilli",
                        "content": "lol"
                    },
                    {
                        "username": "voodooism",
                        "content": "Bro, I\\'ve seen your first comment and remember when you started your challenge\\nBelieve me or not, but during this hard streak I sometimes think about you \\n\\nI\\'m glad to see you not giving up here and hope that leetcode will stop torturing us soon :)"
                    },
                    {
                        "username": "lucasscodes",
                        "content": "Dude you got 15 problems, what are you talking about "
                    },
                    {
                        "username": "dev-null0",
                        "content": "This should be a medium.\\n\\nAll you need to do is:\\n1. Find all distinct cycles\\n2. Try every valid combination of cycles (valid means you don\\'t use the same person twice)\\n\\nBrute force works for both and no need for any caching."
                    },
                    {
                        "username": "anwendeng",
                        "content": "There is no royal road for brute force! This question can be solved using bit mask.\nAfter a nap, I got an idea from Hamming Weight.\nHammingWeight(n)=__builtin_popcount(n)\nMaybe there is quick solution without using brute force. Let me try! It's done"
                    },
                    {
                        "username": "joseph261059",
                        "content": "My brute force backtracking in python 3 only ran in 369ms, https://leetcode.com/problems/maximum-number-of-achievable-transfer-requests/submissions/984584264/\n\nMoreover, standard DP in python3 is even faster, around 119ms, \nhttps://leetcode.com/problems/maximum-number-of-achievable-transfer-requests/submissions/984350718/"
                    },
                    {
                        "username": "psionl0",
                        "content": "It is testament to the small data size that my brute force (bit mask) solution ran in  331 ms and used 5.6 MB of memory while your solution ran in 852 ms and used 138 MB of memory !!"
                    },
                    {
                        "username": "nethajirasineni",
                        "content": "but how can you define procedure?"
                    },
                    {
                        "username": "kerminek",
                        "content": "Sundays :))"
                    },
                    {
                        "username": "f-blan",
                        "content": "The description does not give the definition of an idiot.\\nAn idiot is an employee that does not want to change the building in which they reside in, but still makes a request to be transferred to it, thus increasing the paperwork required for no purpose.\\nBeware, some employees may be idiots. "
                    },
                    {
                        "username": "sirius84",
                        "content": "Hello,\\n\\nThis question is tagged as `DP`, I\\'m wondering what would be the DP solution? I\\'m seeing Backtrack and bitmask so far."
                    },
                    {
                        "username": "feng3245",
                        "content": "DP is suppose to help you solve problems that can be ever reducable into sub problems but this one can\\'t because of the statefulness of the transfers."
                    },
                    {
                        "username": "bparanj",
                        "content": "Indeed, this problem is more commonly solved with a backtracking and bitmask approach rather than dynamic programming (DP). The backtracking solution exhaustively checks all combinations of transfer requests to find the maximum number that can be fulfilled, which is feasible given the problem\\'s constraints. \\n\\nThe bitmask part comes in when representing each set of requests. Each bit in an integer represents whether a particular request is included in the set. This way, generating all subsets of requests becomes equivalent to generating all integers up to 2^n, where n is the number of requests.\\n\\nWhile dynamic programming is a powerful technique, applying it to this problem would be challenging. The most obvious states for a DP solution would be the \"balance\" of each building and the set of requests that have been considered so far. However, there are 2^n possible subsets of requests and each building\\'s balance can range from -n to n, leading to an enormous state space that would be impractical to handle.\\n\\nHence, although this problem is tagged as DP on LeetCode, the DP approach may not be the most suitable or efficient for this particular problem. It\\'s crucial to choose the problem-solving technique that best fits the problem at hand, taking into account the problem\\'s specific requirements and constraints."
                    },
                    {
                        "username": "joseph261059",
                        "content": "dp(request_i, balance_map) = max(1 + dp(request_i + 1, balance_map_if_choose_i), dp(request_i + 1, balance_map))\n"
                    },
                    {
                        "username": "mshoosterman",
                        "content": "This definitely isn\\'t the optimal solution, as I got beat 5% runtime, but if you dont want to think too hard about this problem, know it is possible to try all subsets of requests without getting TLE. Just try to be pretty efficient in how you represent subsets. If you have done this before you can be done with this problem and back to enjoying your weekend in 10 minutes. \\n\\n(The efficient way to check all subsets is by representing subsets by the binary representation of an integer. I\\'m not sure if its possible to do this efficiently enough in a language like python, but in java its doable, just make sure to use bitwise operations to keep things FAST). "
                    },
                    {
                        "username": "feng3245",
                        "content": "You don\\'t even need to use binary manipulate... just using regular set operation is enough for this question"
                    },
                    {
                        "username": "jain_06_07",
                        "content": "Why can\\'t we do it using minimum of in-degree and out-degree of the node?\\n\\nsee this case\\n3\\n[[0,0],[1,1],[0,0],[2,0],[2,2],[1,1],[2,1],[0,1],[0,1]]\\n\\n[0,0], [1,1], [0,0], [2,2], [1,1] --> ignore these cases as it will not affect anything. worker leaves company and joins again but its request is full filled. Right so ans = 5 till now\\n\\nNow, for remaining requests [2,0], [2,1], [0,1], [0,1].\\nif you\\'ll draw graph now then you will see\\nfor company 0 you\\'ve one incoming worker from company 2 and two worker leaving for company 1\\nand for company 1 there is only three workers that are coming but no one is leaving So company 1 cannot accept any worker from company 0.\\n\\nSo, it cannot fulfill the request even company 0 has sufficient indegree and outdegree."
                    }
                ]
            },
            {
                "id": 1953715,
                "content": [
                    {
                        "username": "spatecon",
                        "content": "Astrologers announced the week of backtracking \\uD83E\\uDD75"
                    },
                    {
                        "username": "taduyanh",
                        "content": "hard problem, should we layoff all of them :("
                    },
                    {
                        "username": "rebooter",
                        "content": "LeetCode\\'s discouraging me from completing the 365-day challenge by consistently presenting hard category problems.\\n"
                    },
                    {
                        "username": "Karilli",
                        "content": "lol"
                    },
                    {
                        "username": "voodooism",
                        "content": "Bro, I\\'ve seen your first comment and remember when you started your challenge\\nBelieve me or not, but during this hard streak I sometimes think about you \\n\\nI\\'m glad to see you not giving up here and hope that leetcode will stop torturing us soon :)"
                    },
                    {
                        "username": "lucasscodes",
                        "content": "Dude you got 15 problems, what are you talking about "
                    },
                    {
                        "username": "dev-null0",
                        "content": "This should be a medium.\\n\\nAll you need to do is:\\n1. Find all distinct cycles\\n2. Try every valid combination of cycles (valid means you don\\'t use the same person twice)\\n\\nBrute force works for both and no need for any caching."
                    },
                    {
                        "username": "anwendeng",
                        "content": "There is no royal road for brute force! This question can be solved using bit mask.\nAfter a nap, I got an idea from Hamming Weight.\nHammingWeight(n)=__builtin_popcount(n)\nMaybe there is quick solution without using brute force. Let me try! It's done"
                    },
                    {
                        "username": "joseph261059",
                        "content": "My brute force backtracking in python 3 only ran in 369ms, https://leetcode.com/problems/maximum-number-of-achievable-transfer-requests/submissions/984584264/\n\nMoreover, standard DP in python3 is even faster, around 119ms, \nhttps://leetcode.com/problems/maximum-number-of-achievable-transfer-requests/submissions/984350718/"
                    },
                    {
                        "username": "psionl0",
                        "content": "It is testament to the small data size that my brute force (bit mask) solution ran in  331 ms and used 5.6 MB of memory while your solution ran in 852 ms and used 138 MB of memory !!"
                    },
                    {
                        "username": "nethajirasineni",
                        "content": "but how can you define procedure?"
                    },
                    {
                        "username": "kerminek",
                        "content": "Sundays :))"
                    },
                    {
                        "username": "f-blan",
                        "content": "The description does not give the definition of an idiot.\\nAn idiot is an employee that does not want to change the building in which they reside in, but still makes a request to be transferred to it, thus increasing the paperwork required for no purpose.\\nBeware, some employees may be idiots. "
                    },
                    {
                        "username": "sirius84",
                        "content": "Hello,\\n\\nThis question is tagged as `DP`, I\\'m wondering what would be the DP solution? I\\'m seeing Backtrack and bitmask so far."
                    },
                    {
                        "username": "feng3245",
                        "content": "DP is suppose to help you solve problems that can be ever reducable into sub problems but this one can\\'t because of the statefulness of the transfers."
                    },
                    {
                        "username": "bparanj",
                        "content": "Indeed, this problem is more commonly solved with a backtracking and bitmask approach rather than dynamic programming (DP). The backtracking solution exhaustively checks all combinations of transfer requests to find the maximum number that can be fulfilled, which is feasible given the problem\\'s constraints. \\n\\nThe bitmask part comes in when representing each set of requests. Each bit in an integer represents whether a particular request is included in the set. This way, generating all subsets of requests becomes equivalent to generating all integers up to 2^n, where n is the number of requests.\\n\\nWhile dynamic programming is a powerful technique, applying it to this problem would be challenging. The most obvious states for a DP solution would be the \"balance\" of each building and the set of requests that have been considered so far. However, there are 2^n possible subsets of requests and each building\\'s balance can range from -n to n, leading to an enormous state space that would be impractical to handle.\\n\\nHence, although this problem is tagged as DP on LeetCode, the DP approach may not be the most suitable or efficient for this particular problem. It\\'s crucial to choose the problem-solving technique that best fits the problem at hand, taking into account the problem\\'s specific requirements and constraints."
                    },
                    {
                        "username": "joseph261059",
                        "content": "dp(request_i, balance_map) = max(1 + dp(request_i + 1, balance_map_if_choose_i), dp(request_i + 1, balance_map))\n"
                    },
                    {
                        "username": "mshoosterman",
                        "content": "This definitely isn\\'t the optimal solution, as I got beat 5% runtime, but if you dont want to think too hard about this problem, know it is possible to try all subsets of requests without getting TLE. Just try to be pretty efficient in how you represent subsets. If you have done this before you can be done with this problem and back to enjoying your weekend in 10 minutes. \\n\\n(The efficient way to check all subsets is by representing subsets by the binary representation of an integer. I\\'m not sure if its possible to do this efficiently enough in a language like python, but in java its doable, just make sure to use bitwise operations to keep things FAST). "
                    },
                    {
                        "username": "feng3245",
                        "content": "You don\\'t even need to use binary manipulate... just using regular set operation is enough for this question"
                    },
                    {
                        "username": "jain_06_07",
                        "content": "Why can\\'t we do it using minimum of in-degree and out-degree of the node?\\n\\nsee this case\\n3\\n[[0,0],[1,1],[0,0],[2,0],[2,2],[1,1],[2,1],[0,1],[0,1]]\\n\\n[0,0], [1,1], [0,0], [2,2], [1,1] --> ignore these cases as it will not affect anything. worker leaves company and joins again but its request is full filled. Right so ans = 5 till now\\n\\nNow, for remaining requests [2,0], [2,1], [0,1], [0,1].\\nif you\\'ll draw graph now then you will see\\nfor company 0 you\\'ve one incoming worker from company 2 and two worker leaving for company 1\\nand for company 1 there is only three workers that are coming but no one is leaving So company 1 cannot accept any worker from company 0.\\n\\nSo, it cannot fulfill the request even company 0 has sufficient indegree and outdegree."
                    }
                ]
            },
            {
                "id": 1570180,
                "content": [
                    {
                        "username": "spatecon",
                        "content": "Astrologers announced the week of backtracking \\uD83E\\uDD75"
                    },
                    {
                        "username": "taduyanh",
                        "content": "hard problem, should we layoff all of them :("
                    },
                    {
                        "username": "rebooter",
                        "content": "LeetCode\\'s discouraging me from completing the 365-day challenge by consistently presenting hard category problems.\\n"
                    },
                    {
                        "username": "Karilli",
                        "content": "lol"
                    },
                    {
                        "username": "voodooism",
                        "content": "Bro, I\\'ve seen your first comment and remember when you started your challenge\\nBelieve me or not, but during this hard streak I sometimes think about you \\n\\nI\\'m glad to see you not giving up here and hope that leetcode will stop torturing us soon :)"
                    },
                    {
                        "username": "lucasscodes",
                        "content": "Dude you got 15 problems, what are you talking about "
                    },
                    {
                        "username": "dev-null0",
                        "content": "This should be a medium.\\n\\nAll you need to do is:\\n1. Find all distinct cycles\\n2. Try every valid combination of cycles (valid means you don\\'t use the same person twice)\\n\\nBrute force works for both and no need for any caching."
                    },
                    {
                        "username": "anwendeng",
                        "content": "There is no royal road for brute force! This question can be solved using bit mask.\nAfter a nap, I got an idea from Hamming Weight.\nHammingWeight(n)=__builtin_popcount(n)\nMaybe there is quick solution without using brute force. Let me try! It's done"
                    },
                    {
                        "username": "joseph261059",
                        "content": "My brute force backtracking in python 3 only ran in 369ms, https://leetcode.com/problems/maximum-number-of-achievable-transfer-requests/submissions/984584264/\n\nMoreover, standard DP in python3 is even faster, around 119ms, \nhttps://leetcode.com/problems/maximum-number-of-achievable-transfer-requests/submissions/984350718/"
                    },
                    {
                        "username": "psionl0",
                        "content": "It is testament to the small data size that my brute force (bit mask) solution ran in  331 ms and used 5.6 MB of memory while your solution ran in 852 ms and used 138 MB of memory !!"
                    },
                    {
                        "username": "nethajirasineni",
                        "content": "but how can you define procedure?"
                    },
                    {
                        "username": "kerminek",
                        "content": "Sundays :))"
                    },
                    {
                        "username": "f-blan",
                        "content": "The description does not give the definition of an idiot.\\nAn idiot is an employee that does not want to change the building in which they reside in, but still makes a request to be transferred to it, thus increasing the paperwork required for no purpose.\\nBeware, some employees may be idiots. "
                    },
                    {
                        "username": "sirius84",
                        "content": "Hello,\\n\\nThis question is tagged as `DP`, I\\'m wondering what would be the DP solution? I\\'m seeing Backtrack and bitmask so far."
                    },
                    {
                        "username": "feng3245",
                        "content": "DP is suppose to help you solve problems that can be ever reducable into sub problems but this one can\\'t because of the statefulness of the transfers."
                    },
                    {
                        "username": "bparanj",
                        "content": "Indeed, this problem is more commonly solved with a backtracking and bitmask approach rather than dynamic programming (DP). The backtracking solution exhaustively checks all combinations of transfer requests to find the maximum number that can be fulfilled, which is feasible given the problem\\'s constraints. \\n\\nThe bitmask part comes in when representing each set of requests. Each bit in an integer represents whether a particular request is included in the set. This way, generating all subsets of requests becomes equivalent to generating all integers up to 2^n, where n is the number of requests.\\n\\nWhile dynamic programming is a powerful technique, applying it to this problem would be challenging. The most obvious states for a DP solution would be the \"balance\" of each building and the set of requests that have been considered so far. However, there are 2^n possible subsets of requests and each building\\'s balance can range from -n to n, leading to an enormous state space that would be impractical to handle.\\n\\nHence, although this problem is tagged as DP on LeetCode, the DP approach may not be the most suitable or efficient for this particular problem. It\\'s crucial to choose the problem-solving technique that best fits the problem at hand, taking into account the problem\\'s specific requirements and constraints."
                    },
                    {
                        "username": "joseph261059",
                        "content": "dp(request_i, balance_map) = max(1 + dp(request_i + 1, balance_map_if_choose_i), dp(request_i + 1, balance_map))\n"
                    },
                    {
                        "username": "mshoosterman",
                        "content": "This definitely isn\\'t the optimal solution, as I got beat 5% runtime, but if you dont want to think too hard about this problem, know it is possible to try all subsets of requests without getting TLE. Just try to be pretty efficient in how you represent subsets. If you have done this before you can be done with this problem and back to enjoying your weekend in 10 minutes. \\n\\n(The efficient way to check all subsets is by representing subsets by the binary representation of an integer. I\\'m not sure if its possible to do this efficiently enough in a language like python, but in java its doable, just make sure to use bitwise operations to keep things FAST). "
                    },
                    {
                        "username": "feng3245",
                        "content": "You don\\'t even need to use binary manipulate... just using regular set operation is enough for this question"
                    },
                    {
                        "username": "jain_06_07",
                        "content": "Why can\\'t we do it using minimum of in-degree and out-degree of the node?\\n\\nsee this case\\n3\\n[[0,0],[1,1],[0,0],[2,0],[2,2],[1,1],[2,1],[0,1],[0,1]]\\n\\n[0,0], [1,1], [0,0], [2,2], [1,1] --> ignore these cases as it will not affect anything. worker leaves company and joins again but its request is full filled. Right so ans = 5 till now\\n\\nNow, for remaining requests [2,0], [2,1], [0,1], [0,1].\\nif you\\'ll draw graph now then you will see\\nfor company 0 you\\'ve one incoming worker from company 2 and two worker leaving for company 1\\nand for company 1 there is only three workers that are coming but no one is leaving So company 1 cannot accept any worker from company 0.\\n\\nSo, it cannot fulfill the request even company 0 has sufficient indegree and outdegree."
                    }
                ]
            },
            {
                "id": 1953856,
                "content": [
                    {
                        "username": "spatecon",
                        "content": "Astrologers announced the week of backtracking \\uD83E\\uDD75"
                    },
                    {
                        "username": "taduyanh",
                        "content": "hard problem, should we layoff all of them :("
                    },
                    {
                        "username": "rebooter",
                        "content": "LeetCode\\'s discouraging me from completing the 365-day challenge by consistently presenting hard category problems.\\n"
                    },
                    {
                        "username": "Karilli",
                        "content": "lol"
                    },
                    {
                        "username": "voodooism",
                        "content": "Bro, I\\'ve seen your first comment and remember when you started your challenge\\nBelieve me or not, but during this hard streak I sometimes think about you \\n\\nI\\'m glad to see you not giving up here and hope that leetcode will stop torturing us soon :)"
                    },
                    {
                        "username": "lucasscodes",
                        "content": "Dude you got 15 problems, what are you talking about "
                    },
                    {
                        "username": "dev-null0",
                        "content": "This should be a medium.\\n\\nAll you need to do is:\\n1. Find all distinct cycles\\n2. Try every valid combination of cycles (valid means you don\\'t use the same person twice)\\n\\nBrute force works for both and no need for any caching."
                    },
                    {
                        "username": "anwendeng",
                        "content": "There is no royal road for brute force! This question can be solved using bit mask.\nAfter a nap, I got an idea from Hamming Weight.\nHammingWeight(n)=__builtin_popcount(n)\nMaybe there is quick solution without using brute force. Let me try! It's done"
                    },
                    {
                        "username": "joseph261059",
                        "content": "My brute force backtracking in python 3 only ran in 369ms, https://leetcode.com/problems/maximum-number-of-achievable-transfer-requests/submissions/984584264/\n\nMoreover, standard DP in python3 is even faster, around 119ms, \nhttps://leetcode.com/problems/maximum-number-of-achievable-transfer-requests/submissions/984350718/"
                    },
                    {
                        "username": "psionl0",
                        "content": "It is testament to the small data size that my brute force (bit mask) solution ran in  331 ms and used 5.6 MB of memory while your solution ran in 852 ms and used 138 MB of memory !!"
                    },
                    {
                        "username": "nethajirasineni",
                        "content": "but how can you define procedure?"
                    },
                    {
                        "username": "kerminek",
                        "content": "Sundays :))"
                    },
                    {
                        "username": "f-blan",
                        "content": "The description does not give the definition of an idiot.\\nAn idiot is an employee that does not want to change the building in which they reside in, but still makes a request to be transferred to it, thus increasing the paperwork required for no purpose.\\nBeware, some employees may be idiots. "
                    },
                    {
                        "username": "sirius84",
                        "content": "Hello,\\n\\nThis question is tagged as `DP`, I\\'m wondering what would be the DP solution? I\\'m seeing Backtrack and bitmask so far."
                    },
                    {
                        "username": "feng3245",
                        "content": "DP is suppose to help you solve problems that can be ever reducable into sub problems but this one can\\'t because of the statefulness of the transfers."
                    },
                    {
                        "username": "bparanj",
                        "content": "Indeed, this problem is more commonly solved with a backtracking and bitmask approach rather than dynamic programming (DP). The backtracking solution exhaustively checks all combinations of transfer requests to find the maximum number that can be fulfilled, which is feasible given the problem\\'s constraints. \\n\\nThe bitmask part comes in when representing each set of requests. Each bit in an integer represents whether a particular request is included in the set. This way, generating all subsets of requests becomes equivalent to generating all integers up to 2^n, where n is the number of requests.\\n\\nWhile dynamic programming is a powerful technique, applying it to this problem would be challenging. The most obvious states for a DP solution would be the \"balance\" of each building and the set of requests that have been considered so far. However, there are 2^n possible subsets of requests and each building\\'s balance can range from -n to n, leading to an enormous state space that would be impractical to handle.\\n\\nHence, although this problem is tagged as DP on LeetCode, the DP approach may not be the most suitable or efficient for this particular problem. It\\'s crucial to choose the problem-solving technique that best fits the problem at hand, taking into account the problem\\'s specific requirements and constraints."
                    },
                    {
                        "username": "joseph261059",
                        "content": "dp(request_i, balance_map) = max(1 + dp(request_i + 1, balance_map_if_choose_i), dp(request_i + 1, balance_map))\n"
                    },
                    {
                        "username": "mshoosterman",
                        "content": "This definitely isn\\'t the optimal solution, as I got beat 5% runtime, but if you dont want to think too hard about this problem, know it is possible to try all subsets of requests without getting TLE. Just try to be pretty efficient in how you represent subsets. If you have done this before you can be done with this problem and back to enjoying your weekend in 10 minutes. \\n\\n(The efficient way to check all subsets is by representing subsets by the binary representation of an integer. I\\'m not sure if its possible to do this efficiently enough in a language like python, but in java its doable, just make sure to use bitwise operations to keep things FAST). "
                    },
                    {
                        "username": "feng3245",
                        "content": "You don\\'t even need to use binary manipulate... just using regular set operation is enough for this question"
                    },
                    {
                        "username": "jain_06_07",
                        "content": "Why can\\'t we do it using minimum of in-degree and out-degree of the node?\\n\\nsee this case\\n3\\n[[0,0],[1,1],[0,0],[2,0],[2,2],[1,1],[2,1],[0,1],[0,1]]\\n\\n[0,0], [1,1], [0,0], [2,2], [1,1] --> ignore these cases as it will not affect anything. worker leaves company and joins again but its request is full filled. Right so ans = 5 till now\\n\\nNow, for remaining requests [2,0], [2,1], [0,1], [0,1].\\nif you\\'ll draw graph now then you will see\\nfor company 0 you\\'ve one incoming worker from company 2 and two worker leaving for company 1\\nand for company 1 there is only three workers that are coming but no one is leaving So company 1 cannot accept any worker from company 0.\\n\\nSo, it cannot fulfill the request even company 0 has sufficient indegree and outdegree."
                    }
                ]
            },
            {
                "id": 1953489,
                "content": [
                    {
                        "username": "spatecon",
                        "content": "Astrologers announced the week of backtracking \\uD83E\\uDD75"
                    },
                    {
                        "username": "taduyanh",
                        "content": "hard problem, should we layoff all of them :("
                    },
                    {
                        "username": "rebooter",
                        "content": "LeetCode\\'s discouraging me from completing the 365-day challenge by consistently presenting hard category problems.\\n"
                    },
                    {
                        "username": "Karilli",
                        "content": "lol"
                    },
                    {
                        "username": "voodooism",
                        "content": "Bro, I\\'ve seen your first comment and remember when you started your challenge\\nBelieve me or not, but during this hard streak I sometimes think about you \\n\\nI\\'m glad to see you not giving up here and hope that leetcode will stop torturing us soon :)"
                    },
                    {
                        "username": "lucasscodes",
                        "content": "Dude you got 15 problems, what are you talking about "
                    },
                    {
                        "username": "dev-null0",
                        "content": "This should be a medium.\\n\\nAll you need to do is:\\n1. Find all distinct cycles\\n2. Try every valid combination of cycles (valid means you don\\'t use the same person twice)\\n\\nBrute force works for both and no need for any caching."
                    },
                    {
                        "username": "anwendeng",
                        "content": "There is no royal road for brute force! This question can be solved using bit mask.\nAfter a nap, I got an idea from Hamming Weight.\nHammingWeight(n)=__builtin_popcount(n)\nMaybe there is quick solution without using brute force. Let me try! It's done"
                    },
                    {
                        "username": "joseph261059",
                        "content": "My brute force backtracking in python 3 only ran in 369ms, https://leetcode.com/problems/maximum-number-of-achievable-transfer-requests/submissions/984584264/\n\nMoreover, standard DP in python3 is even faster, around 119ms, \nhttps://leetcode.com/problems/maximum-number-of-achievable-transfer-requests/submissions/984350718/"
                    },
                    {
                        "username": "psionl0",
                        "content": "It is testament to the small data size that my brute force (bit mask) solution ran in  331 ms and used 5.6 MB of memory while your solution ran in 852 ms and used 138 MB of memory !!"
                    },
                    {
                        "username": "nethajirasineni",
                        "content": "but how can you define procedure?"
                    },
                    {
                        "username": "kerminek",
                        "content": "Sundays :))"
                    },
                    {
                        "username": "f-blan",
                        "content": "The description does not give the definition of an idiot.\\nAn idiot is an employee that does not want to change the building in which they reside in, but still makes a request to be transferred to it, thus increasing the paperwork required for no purpose.\\nBeware, some employees may be idiots. "
                    },
                    {
                        "username": "sirius84",
                        "content": "Hello,\\n\\nThis question is tagged as `DP`, I\\'m wondering what would be the DP solution? I\\'m seeing Backtrack and bitmask so far."
                    },
                    {
                        "username": "feng3245",
                        "content": "DP is suppose to help you solve problems that can be ever reducable into sub problems but this one can\\'t because of the statefulness of the transfers."
                    },
                    {
                        "username": "bparanj",
                        "content": "Indeed, this problem is more commonly solved with a backtracking and bitmask approach rather than dynamic programming (DP). The backtracking solution exhaustively checks all combinations of transfer requests to find the maximum number that can be fulfilled, which is feasible given the problem\\'s constraints. \\n\\nThe bitmask part comes in when representing each set of requests. Each bit in an integer represents whether a particular request is included in the set. This way, generating all subsets of requests becomes equivalent to generating all integers up to 2^n, where n is the number of requests.\\n\\nWhile dynamic programming is a powerful technique, applying it to this problem would be challenging. The most obvious states for a DP solution would be the \"balance\" of each building and the set of requests that have been considered so far. However, there are 2^n possible subsets of requests and each building\\'s balance can range from -n to n, leading to an enormous state space that would be impractical to handle.\\n\\nHence, although this problem is tagged as DP on LeetCode, the DP approach may not be the most suitable or efficient for this particular problem. It\\'s crucial to choose the problem-solving technique that best fits the problem at hand, taking into account the problem\\'s specific requirements and constraints."
                    },
                    {
                        "username": "joseph261059",
                        "content": "dp(request_i, balance_map) = max(1 + dp(request_i + 1, balance_map_if_choose_i), dp(request_i + 1, balance_map))\n"
                    },
                    {
                        "username": "mshoosterman",
                        "content": "This definitely isn\\'t the optimal solution, as I got beat 5% runtime, but if you dont want to think too hard about this problem, know it is possible to try all subsets of requests without getting TLE. Just try to be pretty efficient in how you represent subsets. If you have done this before you can be done with this problem and back to enjoying your weekend in 10 minutes. \\n\\n(The efficient way to check all subsets is by representing subsets by the binary representation of an integer. I\\'m not sure if its possible to do this efficiently enough in a language like python, but in java its doable, just make sure to use bitwise operations to keep things FAST). "
                    },
                    {
                        "username": "feng3245",
                        "content": "You don\\'t even need to use binary manipulate... just using regular set operation is enough for this question"
                    },
                    {
                        "username": "jain_06_07",
                        "content": "Why can\\'t we do it using minimum of in-degree and out-degree of the node?\\n\\nsee this case\\n3\\n[[0,0],[1,1],[0,0],[2,0],[2,2],[1,1],[2,1],[0,1],[0,1]]\\n\\n[0,0], [1,1], [0,0], [2,2], [1,1] --> ignore these cases as it will not affect anything. worker leaves company and joins again but its request is full filled. Right so ans = 5 till now\\n\\nNow, for remaining requests [2,0], [2,1], [0,1], [0,1].\\nif you\\'ll draw graph now then you will see\\nfor company 0 you\\'ve one incoming worker from company 2 and two worker leaving for company 1\\nand for company 1 there is only three workers that are coming but no one is leaving So company 1 cannot accept any worker from company 0.\\n\\nSo, it cannot fulfill the request even company 0 has sufficient indegree and outdegree."
                    }
                ]
            },
            {
                "id": 1953090,
                "content": [
                    {
                        "username": "mx64",
                        "content": "As others pointed out, this could easily be a medium.\\nA follow up could be harder, e.g. with larger number of requests and buildings."
                    },
                    {
                        "username": "Maverick767",
                        "content": "[@bparanj](/bparanj) Lmfao did you just chat gpt a response to this person? How does this answer help at all?"
                    },
                    {
                        "username": "bparanj",
                        "content": "[@psionl0](/psionl0) In the case of larger inputs, the exhaustive search approach indeed becomes infeasible due to exponential complexity. To improve the efficiency, we could consider the following techniques:\\n\\n1. **Pruning**: This involves discarding certain choices early in the search if we can prove that they will not lead to an optimal solution. For example, if we have two requests that involve the same employee, and one request has a greater score than the other, we can ignore the lesser request. \\n\\n2. **Heuristics**: These are rules that help in making the search more efficient by prioritizing certain paths. For example, we could prioritize requests that involve employees who appear less frequently in the list of requests.\\n\\n3. **Parallel processing**: If hardware resources allow, we could divide the search space into independent parts and process them in parallel.\\n\\n4. **Greedy algorithms**: These make locally optimal choices at each stage in the hope that these local choices will lead to a global optimum. However, they do not always produce the optimal solution for every problem.\\n\\n5. **Approximation algorithms**: If an exact solution is not feasible in a reasonable time, we can consider algorithms that provide a solution close to the optimal one.\\n\\nRemember that these techniques depend on the nature of the problem and the specific input data, and their efficiency can vary. Before applying them, it\\'s necessary to analyze the problem and data characteristics to identify the most promising approaches. However, the problem Maximum Number of Achievable Transfer Requests seems to be a version of the \"Maximum Coverage Problem\", which is known to be NP-hard, so an exact solution cannot be found in polynomial time. Therefore, in case of larger inputs, we might have to resort to approximation algorithms or heuristics."
                    },
                    {
                        "username": "psionl0",
                        "content": "Any suggestions on how the solution could be optimized. Sure, we can delete self referential requests and two-way cycles but that is hardly likely to make a big dent on the number of requests remaining if that number is large."
                    },
                    {
                        "username": "iamnishthavan",
                        "content": "Won\\'t this work Anyone?\\n\"Find all cycles and sort them by their length and pick one by one removing those edges from graph\""
                    },
                    {
                        "username": "bparanj",
                        "content": "This approach sounds like a Greedy Algorithm, where you choose the best option (the shortest cycle in this case) at each step. However, it is important to note that Greedy Algorithms do not always guarantee the global optimal solution, and this problem is an example of such a case.\\n\\nThe approach you proposed will find the shortest cycles first and remove those requests from the graph. But choosing the shortest cycles first doesn\\'t necessarily lead to the maximum number of achievable transfer requests. Consider the case where there are multiple short cycles and one long cycle that includes all the edges of the short cycles. If we choose the short cycles first, we would lose the opportunity to select the long cycle, which could potentially satisfy more transfer requests.\\n\\nThis problem is essentially a variant of the Maximum Coverage Problem, which is NP-hard. Therefore, it doesn\\'t have an efficient solution that works in all cases. The most common approach for this problem is to use a brute-force method that tries all combinations of requests (or a bit masking technique that achieves the same thing), but this method is not efficient for large inputs. For large inputs, we might need to use approximation algorithms or heuristics, understanding that they might not always provide the optimal solution."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Yup! Even I thought this. This appears to be the sanest way, that we need to remove cycles starting from the largest one. But I was shocked to see that Graphs/Cycle Detection was not in the Related Topic Tags. I think the problem would be finding unique cycles and then removing those edges from graph. Finding would be an issue since a cycle with 5 nodes will be found 5 times. Removing the edges to remove the cycle too would be difficult to implement, hence I think we have to do with this idiotic way \\uD83D\\uDE11"
                    },
                    {
                        "username": "nikmy",
                        "content": "Sounds just like \"delete minimum number of edges to make all weak SCCs in directed graph euler\". Does a greedy algorithm for this problem exist? Maybe there is a strategy to pick edges that we remove in euler cycle construction algorithm..."
                    },
                    {
                        "username": "bparanj",
                        "content": "You\\'re right in recognizing the similarities between this problem and the problem of making all weakly connected components (SCCs) in a directed graph Eulerian by deleting the minimum number of edges. Both involve dealing with directed graphs and have a certain optimization goal.\\n\\nHowever, note that making a graph Eulerian involves creating a path or cycle that visits each edge exactly once, which is different from the goal of this problem - to fulfill the maximum number of requests.\\n\\nRegarding the question of whether a greedy algorithm exists for this problem: Greedy algorithms work well when the problem has the property of \"optimal substructure,\" meaning that an optimal solution can be constructed efficiently from optimal solutions of its subproblems. Problems that can be solved with greedy algorithms include Kruskal\\u2019s Minimum Spanning Tree, Dijkstra\\u2019s Shortest Path, etc.\\n\\nHowever, this problem doesn\\'t appear to have an optimal substructure. Simply choosing the best local options (like fulfilling the requests that appear most frequently first or choosing the shortest cycles in the graph first) doesn\\'t necessarily lead to an overall optimal solution. This is why a greedy approach might not work here, and why a brute-force or bit-masking technique is typically used.\\n\\nThere is no efficient greedy solution has been found for this problem. For larger inputs, approximation algorithms or heuristics might be used, with the understanding that they may not always yield the optimal solution. \\n\\nRemember that solving such problems often involves a trade-off between optimality and computational feasibility.\\n"
                    },
                    {
                        "username": "nikmy",
                        "content": "So, I've thought about the problem, and there are some interesting ideas. Let divergence of vertex be (out_degree - in_degree). Since loops (x -> x edges) doesn't affect, we can ignore them and suppose that. Sum of divergences is 0, if we delete all edges, we'll get all vertices with divergences equal to 0. From Euler graph criteria, we need all divergences to be 0, but we must remove minimum number of edges. Let's look at vertex with div > 0. We can zero it only by removing outcoming edges. Similar logic works for div < 0. It seems like we can pick vertex U with max/min not null divergence, remove it's outcoming edge that leads to a vertex V with min/max divergence among U's neighbors, and update divergence of U and V. If we will do it until all divs become 0, we (possibly) have removed minimum number of edges and  (len(requests) - removedEdges) will be the answer, that we got in O(E log V) time (we have removed <= E edges, and to find optimal neighbour we can use heap)."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "We don\\'t have to delete minimum number of edges, we have to delete maximum number of edges. Removing a cycle in greedy way without observing other cycle means that we can end up removing this cycle but this could break another cycle that was larger and should have been favored first. So I think we are just left with this madness mentioned in Editorial"
                    },
                    {
                        "username": "dumb_me",
                        "content": "it is easy if you know template of backtracking "
                    },
                    {
                        "username": "kumaraashish118",
                        "content": "Where can I get the template of backtracking?"
                    },
                    {
                        "username": "sahilyaduvanshii",
                        "content": "n=3\\n[[0,0],[1,1],[0,0],[2,0],[2,2],[1,1],[2,1],[0,1],[0,1]]\\nwhy this input is giving 5 as output ?\\naccording to me the output should be 6\\nplease explain?"
                    },
                    {
                        "username": "bparanj",
                        "content": "The problem statement mentions that \"Each request is represented by a pair of integers, where the first integer represents the source building and the second one represents the target building.\" \\n\\nAlso, keep in mind that buildings have to end with the same number of employees as they started with. So for the request to be fulfilled, the number of outgoing requests (employees leaving) from a building should equal the number of incoming requests (employees entering) to that building. \\n\\nLet\\'s go through each request in your example:\\n\\n1. [0, 0]: This request can be ignored since it does not cause any employee to move. So we can fulfill this request.\\n2. [1, 1]: Similar to the first request, this can be ignored since no movement of employees occur. This request can also be fulfilled.\\n3. [0, 0]: This is another self-referential request and can be fulfilled.\\n4. [2, 0]: An employee moves from building 2 to building 0.\\n5. [2, 2]: This is a self-referential request and can be fulfilled.\\n6. [1, 1]: This is another self-referential request and can be fulfilled.\\n7. [2, 1]: An employee moves from building 2 to building 1. Now, building 2 has 0 employees left.\\n8. [0, 1]: An employee moves from building 0 to building 1. Now, building 0 has 0 employees left.\\n9. [0, 1]: We cannot fulfill this request since building 0 has no employees left.\\n\\nSo the maximum number of requests that can be fulfilled is 5. Hence the output is 5, not 6."
                    },
                    {
                        "username": "sahilyaduvanshii",
                        "content": "[@tifv](/tifv) I was looking at the 0th building only as there is 2 outgoing edges and 1 incoming edge So I was approving that request later I reckon that by doing so the indegree of 1 will be disturbed hence this is not an valid request"
                    },
                    {
                        "username": "deCodeIt",
                        "content": "All 5 will be intra building ( within same building ) transfers, from where are you getting an inter building ( different building ) transfer? Remember that\\'s it a DIRECTED edge / connection."
                    },
                    {
                        "username": "tifv",
                        "content": "Transfers 0\\u202F\\u2192\\u202F0 and similar (i.e. within the same building) are all possible, independently of all other transfers. There are five of them.\\n\\nIf you exclude them, remaining are 2\\u202F\\u2192\\u202F0, 2\\u202F\\u2192\\u202F1, 0\\u202F\\u2192\\u202F1 (twice). Nobody wants to go to building 2, so transfers from 2 are impossible. If you exclude them, only two transfers 0\\u202F\\u2192\\u202F1 remain, also impossible."
                    },
                    {
                        "username": "woundweavr",
                        "content": "Always check constraints I guess.  Brute force ftw"
                    },
                    {
                        "username": "raghavgoel18",
                        "content": "how to know if constraints are enough for brute force?\\n"
                    },
                    {
                        "username": "vladpetric",
                        "content": "NP complete proof.\\n\\nI start with the Hamiltonian cycle in a directed graph. That problem is NP complete.\\n\\nStraightforward reduction from Hamiltonian cycle to this problem is as follows: We take the original graph, pass it as such to the current problem, and check if the response is equal to the number of vertices.  "
                    },
                    {
                        "username": "cecilia5",
                        "content": "The reduction is flawed.\\n\\nConsider this graph:\\n\\n`a -> b, b->a, c->d, d->c`. The number of requests satisfied is 4, the same as the number of vertices in the graph, but the graph has no hamiltonian cycle. Heck - it isn\\'t even connected!\\n\\nThe fact that this problem can be solved by min cost flow (a polynomial algorithm) sort of disprove the fact that it is NP complete\\n\\n\\n"
                    },
                    {
                        "username": "uavishal777",
                        "content": "I firstly thought its a graph question as just find the indegree and outdegree of nodes and count the transfers with zero resultant \\n"
                    },
                    {
                        "username": "Md_Atik",
                        "content": "meet in the middle technique. Beats 100%.\\nhttps://leetcode.com/problems/maximum-number-of-achievable-transfer-requests/solutions/3757645/beat-100-meet-in-the-middle/"
                    },
                    {
                        "username": "RisabhKedai",
                        "content": "Can we solve it using DFS ?\\n"
                    }
                ]
            },
            {
                "id": 1953033,
                "content": [
                    {
                        "username": "mx64",
                        "content": "As others pointed out, this could easily be a medium.\\nA follow up could be harder, e.g. with larger number of requests and buildings."
                    },
                    {
                        "username": "Maverick767",
                        "content": "[@bparanj](/bparanj) Lmfao did you just chat gpt a response to this person? How does this answer help at all?"
                    },
                    {
                        "username": "bparanj",
                        "content": "[@psionl0](/psionl0) In the case of larger inputs, the exhaustive search approach indeed becomes infeasible due to exponential complexity. To improve the efficiency, we could consider the following techniques:\\n\\n1. **Pruning**: This involves discarding certain choices early in the search if we can prove that they will not lead to an optimal solution. For example, if we have two requests that involve the same employee, and one request has a greater score than the other, we can ignore the lesser request. \\n\\n2. **Heuristics**: These are rules that help in making the search more efficient by prioritizing certain paths. For example, we could prioritize requests that involve employees who appear less frequently in the list of requests.\\n\\n3. **Parallel processing**: If hardware resources allow, we could divide the search space into independent parts and process them in parallel.\\n\\n4. **Greedy algorithms**: These make locally optimal choices at each stage in the hope that these local choices will lead to a global optimum. However, they do not always produce the optimal solution for every problem.\\n\\n5. **Approximation algorithms**: If an exact solution is not feasible in a reasonable time, we can consider algorithms that provide a solution close to the optimal one.\\n\\nRemember that these techniques depend on the nature of the problem and the specific input data, and their efficiency can vary. Before applying them, it\\'s necessary to analyze the problem and data characteristics to identify the most promising approaches. However, the problem Maximum Number of Achievable Transfer Requests seems to be a version of the \"Maximum Coverage Problem\", which is known to be NP-hard, so an exact solution cannot be found in polynomial time. Therefore, in case of larger inputs, we might have to resort to approximation algorithms or heuristics."
                    },
                    {
                        "username": "psionl0",
                        "content": "Any suggestions on how the solution could be optimized. Sure, we can delete self referential requests and two-way cycles but that is hardly likely to make a big dent on the number of requests remaining if that number is large."
                    },
                    {
                        "username": "iamnishthavan",
                        "content": "Won\\'t this work Anyone?\\n\"Find all cycles and sort them by their length and pick one by one removing those edges from graph\""
                    },
                    {
                        "username": "bparanj",
                        "content": "This approach sounds like a Greedy Algorithm, where you choose the best option (the shortest cycle in this case) at each step. However, it is important to note that Greedy Algorithms do not always guarantee the global optimal solution, and this problem is an example of such a case.\\n\\nThe approach you proposed will find the shortest cycles first and remove those requests from the graph. But choosing the shortest cycles first doesn\\'t necessarily lead to the maximum number of achievable transfer requests. Consider the case where there are multiple short cycles and one long cycle that includes all the edges of the short cycles. If we choose the short cycles first, we would lose the opportunity to select the long cycle, which could potentially satisfy more transfer requests.\\n\\nThis problem is essentially a variant of the Maximum Coverage Problem, which is NP-hard. Therefore, it doesn\\'t have an efficient solution that works in all cases. The most common approach for this problem is to use a brute-force method that tries all combinations of requests (or a bit masking technique that achieves the same thing), but this method is not efficient for large inputs. For large inputs, we might need to use approximation algorithms or heuristics, understanding that they might not always provide the optimal solution."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Yup! Even I thought this. This appears to be the sanest way, that we need to remove cycles starting from the largest one. But I was shocked to see that Graphs/Cycle Detection was not in the Related Topic Tags. I think the problem would be finding unique cycles and then removing those edges from graph. Finding would be an issue since a cycle with 5 nodes will be found 5 times. Removing the edges to remove the cycle too would be difficult to implement, hence I think we have to do with this idiotic way \\uD83D\\uDE11"
                    },
                    {
                        "username": "nikmy",
                        "content": "Sounds just like \"delete minimum number of edges to make all weak SCCs in directed graph euler\". Does a greedy algorithm for this problem exist? Maybe there is a strategy to pick edges that we remove in euler cycle construction algorithm..."
                    },
                    {
                        "username": "bparanj",
                        "content": "You\\'re right in recognizing the similarities between this problem and the problem of making all weakly connected components (SCCs) in a directed graph Eulerian by deleting the minimum number of edges. Both involve dealing with directed graphs and have a certain optimization goal.\\n\\nHowever, note that making a graph Eulerian involves creating a path or cycle that visits each edge exactly once, which is different from the goal of this problem - to fulfill the maximum number of requests.\\n\\nRegarding the question of whether a greedy algorithm exists for this problem: Greedy algorithms work well when the problem has the property of \"optimal substructure,\" meaning that an optimal solution can be constructed efficiently from optimal solutions of its subproblems. Problems that can be solved with greedy algorithms include Kruskal\\u2019s Minimum Spanning Tree, Dijkstra\\u2019s Shortest Path, etc.\\n\\nHowever, this problem doesn\\'t appear to have an optimal substructure. Simply choosing the best local options (like fulfilling the requests that appear most frequently first or choosing the shortest cycles in the graph first) doesn\\'t necessarily lead to an overall optimal solution. This is why a greedy approach might not work here, and why a brute-force or bit-masking technique is typically used.\\n\\nThere is no efficient greedy solution has been found for this problem. For larger inputs, approximation algorithms or heuristics might be used, with the understanding that they may not always yield the optimal solution. \\n\\nRemember that solving such problems often involves a trade-off between optimality and computational feasibility.\\n"
                    },
                    {
                        "username": "nikmy",
                        "content": "So, I've thought about the problem, and there are some interesting ideas. Let divergence of vertex be (out_degree - in_degree). Since loops (x -> x edges) doesn't affect, we can ignore them and suppose that. Sum of divergences is 0, if we delete all edges, we'll get all vertices with divergences equal to 0. From Euler graph criteria, we need all divergences to be 0, but we must remove minimum number of edges. Let's look at vertex with div > 0. We can zero it only by removing outcoming edges. Similar logic works for div < 0. It seems like we can pick vertex U with max/min not null divergence, remove it's outcoming edge that leads to a vertex V with min/max divergence among U's neighbors, and update divergence of U and V. If we will do it until all divs become 0, we (possibly) have removed minimum number of edges and  (len(requests) - removedEdges) will be the answer, that we got in O(E log V) time (we have removed <= E edges, and to find optimal neighbour we can use heap)."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "We don\\'t have to delete minimum number of edges, we have to delete maximum number of edges. Removing a cycle in greedy way without observing other cycle means that we can end up removing this cycle but this could break another cycle that was larger and should have been favored first. So I think we are just left with this madness mentioned in Editorial"
                    },
                    {
                        "username": "dumb_me",
                        "content": "it is easy if you know template of backtracking "
                    },
                    {
                        "username": "kumaraashish118",
                        "content": "Where can I get the template of backtracking?"
                    },
                    {
                        "username": "sahilyaduvanshii",
                        "content": "n=3\\n[[0,0],[1,1],[0,0],[2,0],[2,2],[1,1],[2,1],[0,1],[0,1]]\\nwhy this input is giving 5 as output ?\\naccording to me the output should be 6\\nplease explain?"
                    },
                    {
                        "username": "bparanj",
                        "content": "The problem statement mentions that \"Each request is represented by a pair of integers, where the first integer represents the source building and the second one represents the target building.\" \\n\\nAlso, keep in mind that buildings have to end with the same number of employees as they started with. So for the request to be fulfilled, the number of outgoing requests (employees leaving) from a building should equal the number of incoming requests (employees entering) to that building. \\n\\nLet\\'s go through each request in your example:\\n\\n1. [0, 0]: This request can be ignored since it does not cause any employee to move. So we can fulfill this request.\\n2. [1, 1]: Similar to the first request, this can be ignored since no movement of employees occur. This request can also be fulfilled.\\n3. [0, 0]: This is another self-referential request and can be fulfilled.\\n4. [2, 0]: An employee moves from building 2 to building 0.\\n5. [2, 2]: This is a self-referential request and can be fulfilled.\\n6. [1, 1]: This is another self-referential request and can be fulfilled.\\n7. [2, 1]: An employee moves from building 2 to building 1. Now, building 2 has 0 employees left.\\n8. [0, 1]: An employee moves from building 0 to building 1. Now, building 0 has 0 employees left.\\n9. [0, 1]: We cannot fulfill this request since building 0 has no employees left.\\n\\nSo the maximum number of requests that can be fulfilled is 5. Hence the output is 5, not 6."
                    },
                    {
                        "username": "sahilyaduvanshii",
                        "content": "[@tifv](/tifv) I was looking at the 0th building only as there is 2 outgoing edges and 1 incoming edge So I was approving that request later I reckon that by doing so the indegree of 1 will be disturbed hence this is not an valid request"
                    },
                    {
                        "username": "deCodeIt",
                        "content": "All 5 will be intra building ( within same building ) transfers, from where are you getting an inter building ( different building ) transfer? Remember that\\'s it a DIRECTED edge / connection."
                    },
                    {
                        "username": "tifv",
                        "content": "Transfers 0\\u202F\\u2192\\u202F0 and similar (i.e. within the same building) are all possible, independently of all other transfers. There are five of them.\\n\\nIf you exclude them, remaining are 2\\u202F\\u2192\\u202F0, 2\\u202F\\u2192\\u202F1, 0\\u202F\\u2192\\u202F1 (twice). Nobody wants to go to building 2, so transfers from 2 are impossible. If you exclude them, only two transfers 0\\u202F\\u2192\\u202F1 remain, also impossible."
                    },
                    {
                        "username": "woundweavr",
                        "content": "Always check constraints I guess.  Brute force ftw"
                    },
                    {
                        "username": "raghavgoel18",
                        "content": "how to know if constraints are enough for brute force?\\n"
                    },
                    {
                        "username": "vladpetric",
                        "content": "NP complete proof.\\n\\nI start with the Hamiltonian cycle in a directed graph. That problem is NP complete.\\n\\nStraightforward reduction from Hamiltonian cycle to this problem is as follows: We take the original graph, pass it as such to the current problem, and check if the response is equal to the number of vertices.  "
                    },
                    {
                        "username": "cecilia5",
                        "content": "The reduction is flawed.\\n\\nConsider this graph:\\n\\n`a -> b, b->a, c->d, d->c`. The number of requests satisfied is 4, the same as the number of vertices in the graph, but the graph has no hamiltonian cycle. Heck - it isn\\'t even connected!\\n\\nThe fact that this problem can be solved by min cost flow (a polynomial algorithm) sort of disprove the fact that it is NP complete\\n\\n\\n"
                    },
                    {
                        "username": "uavishal777",
                        "content": "I firstly thought its a graph question as just find the indegree and outdegree of nodes and count the transfers with zero resultant \\n"
                    },
                    {
                        "username": "Md_Atik",
                        "content": "meet in the middle technique. Beats 100%.\\nhttps://leetcode.com/problems/maximum-number-of-achievable-transfer-requests/solutions/3757645/beat-100-meet-in-the-middle/"
                    },
                    {
                        "username": "RisabhKedai",
                        "content": "Can we solve it using DFS ?\\n"
                    }
                ]
            },
            {
                "id": 1953023,
                "content": [
                    {
                        "username": "mx64",
                        "content": "As others pointed out, this could easily be a medium.\\nA follow up could be harder, e.g. with larger number of requests and buildings."
                    },
                    {
                        "username": "Maverick767",
                        "content": "[@bparanj](/bparanj) Lmfao did you just chat gpt a response to this person? How does this answer help at all?"
                    },
                    {
                        "username": "bparanj",
                        "content": "[@psionl0](/psionl0) In the case of larger inputs, the exhaustive search approach indeed becomes infeasible due to exponential complexity. To improve the efficiency, we could consider the following techniques:\\n\\n1. **Pruning**: This involves discarding certain choices early in the search if we can prove that they will not lead to an optimal solution. For example, if we have two requests that involve the same employee, and one request has a greater score than the other, we can ignore the lesser request. \\n\\n2. **Heuristics**: These are rules that help in making the search more efficient by prioritizing certain paths. For example, we could prioritize requests that involve employees who appear less frequently in the list of requests.\\n\\n3. **Parallel processing**: If hardware resources allow, we could divide the search space into independent parts and process them in parallel.\\n\\n4. **Greedy algorithms**: These make locally optimal choices at each stage in the hope that these local choices will lead to a global optimum. However, they do not always produce the optimal solution for every problem.\\n\\n5. **Approximation algorithms**: If an exact solution is not feasible in a reasonable time, we can consider algorithms that provide a solution close to the optimal one.\\n\\nRemember that these techniques depend on the nature of the problem and the specific input data, and their efficiency can vary. Before applying them, it\\'s necessary to analyze the problem and data characteristics to identify the most promising approaches. However, the problem Maximum Number of Achievable Transfer Requests seems to be a version of the \"Maximum Coverage Problem\", which is known to be NP-hard, so an exact solution cannot be found in polynomial time. Therefore, in case of larger inputs, we might have to resort to approximation algorithms or heuristics."
                    },
                    {
                        "username": "psionl0",
                        "content": "Any suggestions on how the solution could be optimized. Sure, we can delete self referential requests and two-way cycles but that is hardly likely to make a big dent on the number of requests remaining if that number is large."
                    },
                    {
                        "username": "iamnishthavan",
                        "content": "Won\\'t this work Anyone?\\n\"Find all cycles and sort them by their length and pick one by one removing those edges from graph\""
                    },
                    {
                        "username": "bparanj",
                        "content": "This approach sounds like a Greedy Algorithm, where you choose the best option (the shortest cycle in this case) at each step. However, it is important to note that Greedy Algorithms do not always guarantee the global optimal solution, and this problem is an example of such a case.\\n\\nThe approach you proposed will find the shortest cycles first and remove those requests from the graph. But choosing the shortest cycles first doesn\\'t necessarily lead to the maximum number of achievable transfer requests. Consider the case where there are multiple short cycles and one long cycle that includes all the edges of the short cycles. If we choose the short cycles first, we would lose the opportunity to select the long cycle, which could potentially satisfy more transfer requests.\\n\\nThis problem is essentially a variant of the Maximum Coverage Problem, which is NP-hard. Therefore, it doesn\\'t have an efficient solution that works in all cases. The most common approach for this problem is to use a brute-force method that tries all combinations of requests (or a bit masking technique that achieves the same thing), but this method is not efficient for large inputs. For large inputs, we might need to use approximation algorithms or heuristics, understanding that they might not always provide the optimal solution."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Yup! Even I thought this. This appears to be the sanest way, that we need to remove cycles starting from the largest one. But I was shocked to see that Graphs/Cycle Detection was not in the Related Topic Tags. I think the problem would be finding unique cycles and then removing those edges from graph. Finding would be an issue since a cycle with 5 nodes will be found 5 times. Removing the edges to remove the cycle too would be difficult to implement, hence I think we have to do with this idiotic way \\uD83D\\uDE11"
                    },
                    {
                        "username": "nikmy",
                        "content": "Sounds just like \"delete minimum number of edges to make all weak SCCs in directed graph euler\". Does a greedy algorithm for this problem exist? Maybe there is a strategy to pick edges that we remove in euler cycle construction algorithm..."
                    },
                    {
                        "username": "bparanj",
                        "content": "You\\'re right in recognizing the similarities between this problem and the problem of making all weakly connected components (SCCs) in a directed graph Eulerian by deleting the minimum number of edges. Both involve dealing with directed graphs and have a certain optimization goal.\\n\\nHowever, note that making a graph Eulerian involves creating a path or cycle that visits each edge exactly once, which is different from the goal of this problem - to fulfill the maximum number of requests.\\n\\nRegarding the question of whether a greedy algorithm exists for this problem: Greedy algorithms work well when the problem has the property of \"optimal substructure,\" meaning that an optimal solution can be constructed efficiently from optimal solutions of its subproblems. Problems that can be solved with greedy algorithms include Kruskal\\u2019s Minimum Spanning Tree, Dijkstra\\u2019s Shortest Path, etc.\\n\\nHowever, this problem doesn\\'t appear to have an optimal substructure. Simply choosing the best local options (like fulfilling the requests that appear most frequently first or choosing the shortest cycles in the graph first) doesn\\'t necessarily lead to an overall optimal solution. This is why a greedy approach might not work here, and why a brute-force or bit-masking technique is typically used.\\n\\nThere is no efficient greedy solution has been found for this problem. For larger inputs, approximation algorithms or heuristics might be used, with the understanding that they may not always yield the optimal solution. \\n\\nRemember that solving such problems often involves a trade-off between optimality and computational feasibility.\\n"
                    },
                    {
                        "username": "nikmy",
                        "content": "So, I've thought about the problem, and there are some interesting ideas. Let divergence of vertex be (out_degree - in_degree). Since loops (x -> x edges) doesn't affect, we can ignore them and suppose that. Sum of divergences is 0, if we delete all edges, we'll get all vertices with divergences equal to 0. From Euler graph criteria, we need all divergences to be 0, but we must remove minimum number of edges. Let's look at vertex with div > 0. We can zero it only by removing outcoming edges. Similar logic works for div < 0. It seems like we can pick vertex U with max/min not null divergence, remove it's outcoming edge that leads to a vertex V with min/max divergence among U's neighbors, and update divergence of U and V. If we will do it until all divs become 0, we (possibly) have removed minimum number of edges and  (len(requests) - removedEdges) will be the answer, that we got in O(E log V) time (we have removed <= E edges, and to find optimal neighbour we can use heap)."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "We don\\'t have to delete minimum number of edges, we have to delete maximum number of edges. Removing a cycle in greedy way without observing other cycle means that we can end up removing this cycle but this could break another cycle that was larger and should have been favored first. So I think we are just left with this madness mentioned in Editorial"
                    },
                    {
                        "username": "dumb_me",
                        "content": "it is easy if you know template of backtracking "
                    },
                    {
                        "username": "kumaraashish118",
                        "content": "Where can I get the template of backtracking?"
                    },
                    {
                        "username": "sahilyaduvanshii",
                        "content": "n=3\\n[[0,0],[1,1],[0,0],[2,0],[2,2],[1,1],[2,1],[0,1],[0,1]]\\nwhy this input is giving 5 as output ?\\naccording to me the output should be 6\\nplease explain?"
                    },
                    {
                        "username": "bparanj",
                        "content": "The problem statement mentions that \"Each request is represented by a pair of integers, where the first integer represents the source building and the second one represents the target building.\" \\n\\nAlso, keep in mind that buildings have to end with the same number of employees as they started with. So for the request to be fulfilled, the number of outgoing requests (employees leaving) from a building should equal the number of incoming requests (employees entering) to that building. \\n\\nLet\\'s go through each request in your example:\\n\\n1. [0, 0]: This request can be ignored since it does not cause any employee to move. So we can fulfill this request.\\n2. [1, 1]: Similar to the first request, this can be ignored since no movement of employees occur. This request can also be fulfilled.\\n3. [0, 0]: This is another self-referential request and can be fulfilled.\\n4. [2, 0]: An employee moves from building 2 to building 0.\\n5. [2, 2]: This is a self-referential request and can be fulfilled.\\n6. [1, 1]: This is another self-referential request and can be fulfilled.\\n7. [2, 1]: An employee moves from building 2 to building 1. Now, building 2 has 0 employees left.\\n8. [0, 1]: An employee moves from building 0 to building 1. Now, building 0 has 0 employees left.\\n9. [0, 1]: We cannot fulfill this request since building 0 has no employees left.\\n\\nSo the maximum number of requests that can be fulfilled is 5. Hence the output is 5, not 6."
                    },
                    {
                        "username": "sahilyaduvanshii",
                        "content": "[@tifv](/tifv) I was looking at the 0th building only as there is 2 outgoing edges and 1 incoming edge So I was approving that request later I reckon that by doing so the indegree of 1 will be disturbed hence this is not an valid request"
                    },
                    {
                        "username": "deCodeIt",
                        "content": "All 5 will be intra building ( within same building ) transfers, from where are you getting an inter building ( different building ) transfer? Remember that\\'s it a DIRECTED edge / connection."
                    },
                    {
                        "username": "tifv",
                        "content": "Transfers 0\\u202F\\u2192\\u202F0 and similar (i.e. within the same building) are all possible, independently of all other transfers. There are five of them.\\n\\nIf you exclude them, remaining are 2\\u202F\\u2192\\u202F0, 2\\u202F\\u2192\\u202F1, 0\\u202F\\u2192\\u202F1 (twice). Nobody wants to go to building 2, so transfers from 2 are impossible. If you exclude them, only two transfers 0\\u202F\\u2192\\u202F1 remain, also impossible."
                    },
                    {
                        "username": "woundweavr",
                        "content": "Always check constraints I guess.  Brute force ftw"
                    },
                    {
                        "username": "raghavgoel18",
                        "content": "how to know if constraints are enough for brute force?\\n"
                    },
                    {
                        "username": "vladpetric",
                        "content": "NP complete proof.\\n\\nI start with the Hamiltonian cycle in a directed graph. That problem is NP complete.\\n\\nStraightforward reduction from Hamiltonian cycle to this problem is as follows: We take the original graph, pass it as such to the current problem, and check if the response is equal to the number of vertices.  "
                    },
                    {
                        "username": "cecilia5",
                        "content": "The reduction is flawed.\\n\\nConsider this graph:\\n\\n`a -> b, b->a, c->d, d->c`. The number of requests satisfied is 4, the same as the number of vertices in the graph, but the graph has no hamiltonian cycle. Heck - it isn\\'t even connected!\\n\\nThe fact that this problem can be solved by min cost flow (a polynomial algorithm) sort of disprove the fact that it is NP complete\\n\\n\\n"
                    },
                    {
                        "username": "uavishal777",
                        "content": "I firstly thought its a graph question as just find the indegree and outdegree of nodes and count the transfers with zero resultant \\n"
                    },
                    {
                        "username": "Md_Atik",
                        "content": "meet in the middle technique. Beats 100%.\\nhttps://leetcode.com/problems/maximum-number-of-achievable-transfer-requests/solutions/3757645/beat-100-meet-in-the-middle/"
                    },
                    {
                        "username": "RisabhKedai",
                        "content": "Can we solve it using DFS ?\\n"
                    }
                ]
            },
            {
                "id": 1952633,
                "content": [
                    {
                        "username": "mx64",
                        "content": "As others pointed out, this could easily be a medium.\\nA follow up could be harder, e.g. with larger number of requests and buildings."
                    },
                    {
                        "username": "Maverick767",
                        "content": "[@bparanj](/bparanj) Lmfao did you just chat gpt a response to this person? How does this answer help at all?"
                    },
                    {
                        "username": "bparanj",
                        "content": "[@psionl0](/psionl0) In the case of larger inputs, the exhaustive search approach indeed becomes infeasible due to exponential complexity. To improve the efficiency, we could consider the following techniques:\\n\\n1. **Pruning**: This involves discarding certain choices early in the search if we can prove that they will not lead to an optimal solution. For example, if we have two requests that involve the same employee, and one request has a greater score than the other, we can ignore the lesser request. \\n\\n2. **Heuristics**: These are rules that help in making the search more efficient by prioritizing certain paths. For example, we could prioritize requests that involve employees who appear less frequently in the list of requests.\\n\\n3. **Parallel processing**: If hardware resources allow, we could divide the search space into independent parts and process them in parallel.\\n\\n4. **Greedy algorithms**: These make locally optimal choices at each stage in the hope that these local choices will lead to a global optimum. However, they do not always produce the optimal solution for every problem.\\n\\n5. **Approximation algorithms**: If an exact solution is not feasible in a reasonable time, we can consider algorithms that provide a solution close to the optimal one.\\n\\nRemember that these techniques depend on the nature of the problem and the specific input data, and their efficiency can vary. Before applying them, it\\'s necessary to analyze the problem and data characteristics to identify the most promising approaches. However, the problem Maximum Number of Achievable Transfer Requests seems to be a version of the \"Maximum Coverage Problem\", which is known to be NP-hard, so an exact solution cannot be found in polynomial time. Therefore, in case of larger inputs, we might have to resort to approximation algorithms or heuristics."
                    },
                    {
                        "username": "psionl0",
                        "content": "Any suggestions on how the solution could be optimized. Sure, we can delete self referential requests and two-way cycles but that is hardly likely to make a big dent on the number of requests remaining if that number is large."
                    },
                    {
                        "username": "iamnishthavan",
                        "content": "Won\\'t this work Anyone?\\n\"Find all cycles and sort them by their length and pick one by one removing those edges from graph\""
                    },
                    {
                        "username": "bparanj",
                        "content": "This approach sounds like a Greedy Algorithm, where you choose the best option (the shortest cycle in this case) at each step. However, it is important to note that Greedy Algorithms do not always guarantee the global optimal solution, and this problem is an example of such a case.\\n\\nThe approach you proposed will find the shortest cycles first and remove those requests from the graph. But choosing the shortest cycles first doesn\\'t necessarily lead to the maximum number of achievable transfer requests. Consider the case where there are multiple short cycles and one long cycle that includes all the edges of the short cycles. If we choose the short cycles first, we would lose the opportunity to select the long cycle, which could potentially satisfy more transfer requests.\\n\\nThis problem is essentially a variant of the Maximum Coverage Problem, which is NP-hard. Therefore, it doesn\\'t have an efficient solution that works in all cases. The most common approach for this problem is to use a brute-force method that tries all combinations of requests (or a bit masking technique that achieves the same thing), but this method is not efficient for large inputs. For large inputs, we might need to use approximation algorithms or heuristics, understanding that they might not always provide the optimal solution."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Yup! Even I thought this. This appears to be the sanest way, that we need to remove cycles starting from the largest one. But I was shocked to see that Graphs/Cycle Detection was not in the Related Topic Tags. I think the problem would be finding unique cycles and then removing those edges from graph. Finding would be an issue since a cycle with 5 nodes will be found 5 times. Removing the edges to remove the cycle too would be difficult to implement, hence I think we have to do with this idiotic way \\uD83D\\uDE11"
                    },
                    {
                        "username": "nikmy",
                        "content": "Sounds just like \"delete minimum number of edges to make all weak SCCs in directed graph euler\". Does a greedy algorithm for this problem exist? Maybe there is a strategy to pick edges that we remove in euler cycle construction algorithm..."
                    },
                    {
                        "username": "bparanj",
                        "content": "You\\'re right in recognizing the similarities between this problem and the problem of making all weakly connected components (SCCs) in a directed graph Eulerian by deleting the minimum number of edges. Both involve dealing with directed graphs and have a certain optimization goal.\\n\\nHowever, note that making a graph Eulerian involves creating a path or cycle that visits each edge exactly once, which is different from the goal of this problem - to fulfill the maximum number of requests.\\n\\nRegarding the question of whether a greedy algorithm exists for this problem: Greedy algorithms work well when the problem has the property of \"optimal substructure,\" meaning that an optimal solution can be constructed efficiently from optimal solutions of its subproblems. Problems that can be solved with greedy algorithms include Kruskal\\u2019s Minimum Spanning Tree, Dijkstra\\u2019s Shortest Path, etc.\\n\\nHowever, this problem doesn\\'t appear to have an optimal substructure. Simply choosing the best local options (like fulfilling the requests that appear most frequently first or choosing the shortest cycles in the graph first) doesn\\'t necessarily lead to an overall optimal solution. This is why a greedy approach might not work here, and why a brute-force or bit-masking technique is typically used.\\n\\nThere is no efficient greedy solution has been found for this problem. For larger inputs, approximation algorithms or heuristics might be used, with the understanding that they may not always yield the optimal solution. \\n\\nRemember that solving such problems often involves a trade-off between optimality and computational feasibility.\\n"
                    },
                    {
                        "username": "nikmy",
                        "content": "So, I've thought about the problem, and there are some interesting ideas. Let divergence of vertex be (out_degree - in_degree). Since loops (x -> x edges) doesn't affect, we can ignore them and suppose that. Sum of divergences is 0, if we delete all edges, we'll get all vertices with divergences equal to 0. From Euler graph criteria, we need all divergences to be 0, but we must remove minimum number of edges. Let's look at vertex with div > 0. We can zero it only by removing outcoming edges. Similar logic works for div < 0. It seems like we can pick vertex U with max/min not null divergence, remove it's outcoming edge that leads to a vertex V with min/max divergence among U's neighbors, and update divergence of U and V. If we will do it until all divs become 0, we (possibly) have removed minimum number of edges and  (len(requests) - removedEdges) will be the answer, that we got in O(E log V) time (we have removed <= E edges, and to find optimal neighbour we can use heap)."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "We don\\'t have to delete minimum number of edges, we have to delete maximum number of edges. Removing a cycle in greedy way without observing other cycle means that we can end up removing this cycle but this could break another cycle that was larger and should have been favored first. So I think we are just left with this madness mentioned in Editorial"
                    },
                    {
                        "username": "dumb_me",
                        "content": "it is easy if you know template of backtracking "
                    },
                    {
                        "username": "kumaraashish118",
                        "content": "Where can I get the template of backtracking?"
                    },
                    {
                        "username": "sahilyaduvanshii",
                        "content": "n=3\\n[[0,0],[1,1],[0,0],[2,0],[2,2],[1,1],[2,1],[0,1],[0,1]]\\nwhy this input is giving 5 as output ?\\naccording to me the output should be 6\\nplease explain?"
                    },
                    {
                        "username": "bparanj",
                        "content": "The problem statement mentions that \"Each request is represented by a pair of integers, where the first integer represents the source building and the second one represents the target building.\" \\n\\nAlso, keep in mind that buildings have to end with the same number of employees as they started with. So for the request to be fulfilled, the number of outgoing requests (employees leaving) from a building should equal the number of incoming requests (employees entering) to that building. \\n\\nLet\\'s go through each request in your example:\\n\\n1. [0, 0]: This request can be ignored since it does not cause any employee to move. So we can fulfill this request.\\n2. [1, 1]: Similar to the first request, this can be ignored since no movement of employees occur. This request can also be fulfilled.\\n3. [0, 0]: This is another self-referential request and can be fulfilled.\\n4. [2, 0]: An employee moves from building 2 to building 0.\\n5. [2, 2]: This is a self-referential request and can be fulfilled.\\n6. [1, 1]: This is another self-referential request and can be fulfilled.\\n7. [2, 1]: An employee moves from building 2 to building 1. Now, building 2 has 0 employees left.\\n8. [0, 1]: An employee moves from building 0 to building 1. Now, building 0 has 0 employees left.\\n9. [0, 1]: We cannot fulfill this request since building 0 has no employees left.\\n\\nSo the maximum number of requests that can be fulfilled is 5. Hence the output is 5, not 6."
                    },
                    {
                        "username": "sahilyaduvanshii",
                        "content": "[@tifv](/tifv) I was looking at the 0th building only as there is 2 outgoing edges and 1 incoming edge So I was approving that request later I reckon that by doing so the indegree of 1 will be disturbed hence this is not an valid request"
                    },
                    {
                        "username": "deCodeIt",
                        "content": "All 5 will be intra building ( within same building ) transfers, from where are you getting an inter building ( different building ) transfer? Remember that\\'s it a DIRECTED edge / connection."
                    },
                    {
                        "username": "tifv",
                        "content": "Transfers 0\\u202F\\u2192\\u202F0 and similar (i.e. within the same building) are all possible, independently of all other transfers. There are five of them.\\n\\nIf you exclude them, remaining are 2\\u202F\\u2192\\u202F0, 2\\u202F\\u2192\\u202F1, 0\\u202F\\u2192\\u202F1 (twice). Nobody wants to go to building 2, so transfers from 2 are impossible. If you exclude them, only two transfers 0\\u202F\\u2192\\u202F1 remain, also impossible."
                    },
                    {
                        "username": "woundweavr",
                        "content": "Always check constraints I guess.  Brute force ftw"
                    },
                    {
                        "username": "raghavgoel18",
                        "content": "how to know if constraints are enough for brute force?\\n"
                    },
                    {
                        "username": "vladpetric",
                        "content": "NP complete proof.\\n\\nI start with the Hamiltonian cycle in a directed graph. That problem is NP complete.\\n\\nStraightforward reduction from Hamiltonian cycle to this problem is as follows: We take the original graph, pass it as such to the current problem, and check if the response is equal to the number of vertices.  "
                    },
                    {
                        "username": "cecilia5",
                        "content": "The reduction is flawed.\\n\\nConsider this graph:\\n\\n`a -> b, b->a, c->d, d->c`. The number of requests satisfied is 4, the same as the number of vertices in the graph, but the graph has no hamiltonian cycle. Heck - it isn\\'t even connected!\\n\\nThe fact that this problem can be solved by min cost flow (a polynomial algorithm) sort of disprove the fact that it is NP complete\\n\\n\\n"
                    },
                    {
                        "username": "uavishal777",
                        "content": "I firstly thought its a graph question as just find the indegree and outdegree of nodes and count the transfers with zero resultant \\n"
                    },
                    {
                        "username": "Md_Atik",
                        "content": "meet in the middle technique. Beats 100%.\\nhttps://leetcode.com/problems/maximum-number-of-achievable-transfer-requests/solutions/3757645/beat-100-meet-in-the-middle/"
                    },
                    {
                        "username": "RisabhKedai",
                        "content": "Can we solve it using DFS ?\\n"
                    }
                ]
            },
            {
                "id": 1952277,
                "content": [
                    {
                        "username": "mx64",
                        "content": "As others pointed out, this could easily be a medium.\\nA follow up could be harder, e.g. with larger number of requests and buildings."
                    },
                    {
                        "username": "Maverick767",
                        "content": "[@bparanj](/bparanj) Lmfao did you just chat gpt a response to this person? How does this answer help at all?"
                    },
                    {
                        "username": "bparanj",
                        "content": "[@psionl0](/psionl0) In the case of larger inputs, the exhaustive search approach indeed becomes infeasible due to exponential complexity. To improve the efficiency, we could consider the following techniques:\\n\\n1. **Pruning**: This involves discarding certain choices early in the search if we can prove that they will not lead to an optimal solution. For example, if we have two requests that involve the same employee, and one request has a greater score than the other, we can ignore the lesser request. \\n\\n2. **Heuristics**: These are rules that help in making the search more efficient by prioritizing certain paths. For example, we could prioritize requests that involve employees who appear less frequently in the list of requests.\\n\\n3. **Parallel processing**: If hardware resources allow, we could divide the search space into independent parts and process them in parallel.\\n\\n4. **Greedy algorithms**: These make locally optimal choices at each stage in the hope that these local choices will lead to a global optimum. However, they do not always produce the optimal solution for every problem.\\n\\n5. **Approximation algorithms**: If an exact solution is not feasible in a reasonable time, we can consider algorithms that provide a solution close to the optimal one.\\n\\nRemember that these techniques depend on the nature of the problem and the specific input data, and their efficiency can vary. Before applying them, it\\'s necessary to analyze the problem and data characteristics to identify the most promising approaches. However, the problem Maximum Number of Achievable Transfer Requests seems to be a version of the \"Maximum Coverage Problem\", which is known to be NP-hard, so an exact solution cannot be found in polynomial time. Therefore, in case of larger inputs, we might have to resort to approximation algorithms or heuristics."
                    },
                    {
                        "username": "psionl0",
                        "content": "Any suggestions on how the solution could be optimized. Sure, we can delete self referential requests and two-way cycles but that is hardly likely to make a big dent on the number of requests remaining if that number is large."
                    },
                    {
                        "username": "iamnishthavan",
                        "content": "Won\\'t this work Anyone?\\n\"Find all cycles and sort them by their length and pick one by one removing those edges from graph\""
                    },
                    {
                        "username": "bparanj",
                        "content": "This approach sounds like a Greedy Algorithm, where you choose the best option (the shortest cycle in this case) at each step. However, it is important to note that Greedy Algorithms do not always guarantee the global optimal solution, and this problem is an example of such a case.\\n\\nThe approach you proposed will find the shortest cycles first and remove those requests from the graph. But choosing the shortest cycles first doesn\\'t necessarily lead to the maximum number of achievable transfer requests. Consider the case where there are multiple short cycles and one long cycle that includes all the edges of the short cycles. If we choose the short cycles first, we would lose the opportunity to select the long cycle, which could potentially satisfy more transfer requests.\\n\\nThis problem is essentially a variant of the Maximum Coverage Problem, which is NP-hard. Therefore, it doesn\\'t have an efficient solution that works in all cases. The most common approach for this problem is to use a brute-force method that tries all combinations of requests (or a bit masking technique that achieves the same thing), but this method is not efficient for large inputs. For large inputs, we might need to use approximation algorithms or heuristics, understanding that they might not always provide the optimal solution."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Yup! Even I thought this. This appears to be the sanest way, that we need to remove cycles starting from the largest one. But I was shocked to see that Graphs/Cycle Detection was not in the Related Topic Tags. I think the problem would be finding unique cycles and then removing those edges from graph. Finding would be an issue since a cycle with 5 nodes will be found 5 times. Removing the edges to remove the cycle too would be difficult to implement, hence I think we have to do with this idiotic way \\uD83D\\uDE11"
                    },
                    {
                        "username": "nikmy",
                        "content": "Sounds just like \"delete minimum number of edges to make all weak SCCs in directed graph euler\". Does a greedy algorithm for this problem exist? Maybe there is a strategy to pick edges that we remove in euler cycle construction algorithm..."
                    },
                    {
                        "username": "bparanj",
                        "content": "You\\'re right in recognizing the similarities between this problem and the problem of making all weakly connected components (SCCs) in a directed graph Eulerian by deleting the minimum number of edges. Both involve dealing with directed graphs and have a certain optimization goal.\\n\\nHowever, note that making a graph Eulerian involves creating a path or cycle that visits each edge exactly once, which is different from the goal of this problem - to fulfill the maximum number of requests.\\n\\nRegarding the question of whether a greedy algorithm exists for this problem: Greedy algorithms work well when the problem has the property of \"optimal substructure,\" meaning that an optimal solution can be constructed efficiently from optimal solutions of its subproblems. Problems that can be solved with greedy algorithms include Kruskal\\u2019s Minimum Spanning Tree, Dijkstra\\u2019s Shortest Path, etc.\\n\\nHowever, this problem doesn\\'t appear to have an optimal substructure. Simply choosing the best local options (like fulfilling the requests that appear most frequently first or choosing the shortest cycles in the graph first) doesn\\'t necessarily lead to an overall optimal solution. This is why a greedy approach might not work here, and why a brute-force or bit-masking technique is typically used.\\n\\nThere is no efficient greedy solution has been found for this problem. For larger inputs, approximation algorithms or heuristics might be used, with the understanding that they may not always yield the optimal solution. \\n\\nRemember that solving such problems often involves a trade-off between optimality and computational feasibility.\\n"
                    },
                    {
                        "username": "nikmy",
                        "content": "So, I've thought about the problem, and there are some interesting ideas. Let divergence of vertex be (out_degree - in_degree). Since loops (x -> x edges) doesn't affect, we can ignore them and suppose that. Sum of divergences is 0, if we delete all edges, we'll get all vertices with divergences equal to 0. From Euler graph criteria, we need all divergences to be 0, but we must remove minimum number of edges. Let's look at vertex with div > 0. We can zero it only by removing outcoming edges. Similar logic works for div < 0. It seems like we can pick vertex U with max/min not null divergence, remove it's outcoming edge that leads to a vertex V with min/max divergence among U's neighbors, and update divergence of U and V. If we will do it until all divs become 0, we (possibly) have removed minimum number of edges and  (len(requests) - removedEdges) will be the answer, that we got in O(E log V) time (we have removed <= E edges, and to find optimal neighbour we can use heap)."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "We don\\'t have to delete minimum number of edges, we have to delete maximum number of edges. Removing a cycle in greedy way without observing other cycle means that we can end up removing this cycle but this could break another cycle that was larger and should have been favored first. So I think we are just left with this madness mentioned in Editorial"
                    },
                    {
                        "username": "dumb_me",
                        "content": "it is easy if you know template of backtracking "
                    },
                    {
                        "username": "kumaraashish118",
                        "content": "Where can I get the template of backtracking?"
                    },
                    {
                        "username": "sahilyaduvanshii",
                        "content": "n=3\\n[[0,0],[1,1],[0,0],[2,0],[2,2],[1,1],[2,1],[0,1],[0,1]]\\nwhy this input is giving 5 as output ?\\naccording to me the output should be 6\\nplease explain?"
                    },
                    {
                        "username": "bparanj",
                        "content": "The problem statement mentions that \"Each request is represented by a pair of integers, where the first integer represents the source building and the second one represents the target building.\" \\n\\nAlso, keep in mind that buildings have to end with the same number of employees as they started with. So for the request to be fulfilled, the number of outgoing requests (employees leaving) from a building should equal the number of incoming requests (employees entering) to that building. \\n\\nLet\\'s go through each request in your example:\\n\\n1. [0, 0]: This request can be ignored since it does not cause any employee to move. So we can fulfill this request.\\n2. [1, 1]: Similar to the first request, this can be ignored since no movement of employees occur. This request can also be fulfilled.\\n3. [0, 0]: This is another self-referential request and can be fulfilled.\\n4. [2, 0]: An employee moves from building 2 to building 0.\\n5. [2, 2]: This is a self-referential request and can be fulfilled.\\n6. [1, 1]: This is another self-referential request and can be fulfilled.\\n7. [2, 1]: An employee moves from building 2 to building 1. Now, building 2 has 0 employees left.\\n8. [0, 1]: An employee moves from building 0 to building 1. Now, building 0 has 0 employees left.\\n9. [0, 1]: We cannot fulfill this request since building 0 has no employees left.\\n\\nSo the maximum number of requests that can be fulfilled is 5. Hence the output is 5, not 6."
                    },
                    {
                        "username": "sahilyaduvanshii",
                        "content": "[@tifv](/tifv) I was looking at the 0th building only as there is 2 outgoing edges and 1 incoming edge So I was approving that request later I reckon that by doing so the indegree of 1 will be disturbed hence this is not an valid request"
                    },
                    {
                        "username": "deCodeIt",
                        "content": "All 5 will be intra building ( within same building ) transfers, from where are you getting an inter building ( different building ) transfer? Remember that\\'s it a DIRECTED edge / connection."
                    },
                    {
                        "username": "tifv",
                        "content": "Transfers 0\\u202F\\u2192\\u202F0 and similar (i.e. within the same building) are all possible, independently of all other transfers. There are five of them.\\n\\nIf you exclude them, remaining are 2\\u202F\\u2192\\u202F0, 2\\u202F\\u2192\\u202F1, 0\\u202F\\u2192\\u202F1 (twice). Nobody wants to go to building 2, so transfers from 2 are impossible. If you exclude them, only two transfers 0\\u202F\\u2192\\u202F1 remain, also impossible."
                    },
                    {
                        "username": "woundweavr",
                        "content": "Always check constraints I guess.  Brute force ftw"
                    },
                    {
                        "username": "raghavgoel18",
                        "content": "how to know if constraints are enough for brute force?\\n"
                    },
                    {
                        "username": "vladpetric",
                        "content": "NP complete proof.\\n\\nI start with the Hamiltonian cycle in a directed graph. That problem is NP complete.\\n\\nStraightforward reduction from Hamiltonian cycle to this problem is as follows: We take the original graph, pass it as such to the current problem, and check if the response is equal to the number of vertices.  "
                    },
                    {
                        "username": "cecilia5",
                        "content": "The reduction is flawed.\\n\\nConsider this graph:\\n\\n`a -> b, b->a, c->d, d->c`. The number of requests satisfied is 4, the same as the number of vertices in the graph, but the graph has no hamiltonian cycle. Heck - it isn\\'t even connected!\\n\\nThe fact that this problem can be solved by min cost flow (a polynomial algorithm) sort of disprove the fact that it is NP complete\\n\\n\\n"
                    },
                    {
                        "username": "uavishal777",
                        "content": "I firstly thought its a graph question as just find the indegree and outdegree of nodes and count the transfers with zero resultant \\n"
                    },
                    {
                        "username": "Md_Atik",
                        "content": "meet in the middle technique. Beats 100%.\\nhttps://leetcode.com/problems/maximum-number-of-achievable-transfer-requests/solutions/3757645/beat-100-meet-in-the-middle/"
                    },
                    {
                        "username": "RisabhKedai",
                        "content": "Can we solve it using DFS ?\\n"
                    }
                ]
            },
            {
                "id": 1952250,
                "content": [
                    {
                        "username": "mx64",
                        "content": "As others pointed out, this could easily be a medium.\\nA follow up could be harder, e.g. with larger number of requests and buildings."
                    },
                    {
                        "username": "Maverick767",
                        "content": "[@bparanj](/bparanj) Lmfao did you just chat gpt a response to this person? How does this answer help at all?"
                    },
                    {
                        "username": "bparanj",
                        "content": "[@psionl0](/psionl0) In the case of larger inputs, the exhaustive search approach indeed becomes infeasible due to exponential complexity. To improve the efficiency, we could consider the following techniques:\\n\\n1. **Pruning**: This involves discarding certain choices early in the search if we can prove that they will not lead to an optimal solution. For example, if we have two requests that involve the same employee, and one request has a greater score than the other, we can ignore the lesser request. \\n\\n2. **Heuristics**: These are rules that help in making the search more efficient by prioritizing certain paths. For example, we could prioritize requests that involve employees who appear less frequently in the list of requests.\\n\\n3. **Parallel processing**: If hardware resources allow, we could divide the search space into independent parts and process them in parallel.\\n\\n4. **Greedy algorithms**: These make locally optimal choices at each stage in the hope that these local choices will lead to a global optimum. However, they do not always produce the optimal solution for every problem.\\n\\n5. **Approximation algorithms**: If an exact solution is not feasible in a reasonable time, we can consider algorithms that provide a solution close to the optimal one.\\n\\nRemember that these techniques depend on the nature of the problem and the specific input data, and their efficiency can vary. Before applying them, it\\'s necessary to analyze the problem and data characteristics to identify the most promising approaches. However, the problem Maximum Number of Achievable Transfer Requests seems to be a version of the \"Maximum Coverage Problem\", which is known to be NP-hard, so an exact solution cannot be found in polynomial time. Therefore, in case of larger inputs, we might have to resort to approximation algorithms or heuristics."
                    },
                    {
                        "username": "psionl0",
                        "content": "Any suggestions on how the solution could be optimized. Sure, we can delete self referential requests and two-way cycles but that is hardly likely to make a big dent on the number of requests remaining if that number is large."
                    },
                    {
                        "username": "iamnishthavan",
                        "content": "Won\\'t this work Anyone?\\n\"Find all cycles and sort them by their length and pick one by one removing those edges from graph\""
                    },
                    {
                        "username": "bparanj",
                        "content": "This approach sounds like a Greedy Algorithm, where you choose the best option (the shortest cycle in this case) at each step. However, it is important to note that Greedy Algorithms do not always guarantee the global optimal solution, and this problem is an example of such a case.\\n\\nThe approach you proposed will find the shortest cycles first and remove those requests from the graph. But choosing the shortest cycles first doesn\\'t necessarily lead to the maximum number of achievable transfer requests. Consider the case where there are multiple short cycles and one long cycle that includes all the edges of the short cycles. If we choose the short cycles first, we would lose the opportunity to select the long cycle, which could potentially satisfy more transfer requests.\\n\\nThis problem is essentially a variant of the Maximum Coverage Problem, which is NP-hard. Therefore, it doesn\\'t have an efficient solution that works in all cases. The most common approach for this problem is to use a brute-force method that tries all combinations of requests (or a bit masking technique that achieves the same thing), but this method is not efficient for large inputs. For large inputs, we might need to use approximation algorithms or heuristics, understanding that they might not always provide the optimal solution."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Yup! Even I thought this. This appears to be the sanest way, that we need to remove cycles starting from the largest one. But I was shocked to see that Graphs/Cycle Detection was not in the Related Topic Tags. I think the problem would be finding unique cycles and then removing those edges from graph. Finding would be an issue since a cycle with 5 nodes will be found 5 times. Removing the edges to remove the cycle too would be difficult to implement, hence I think we have to do with this idiotic way \\uD83D\\uDE11"
                    },
                    {
                        "username": "nikmy",
                        "content": "Sounds just like \"delete minimum number of edges to make all weak SCCs in directed graph euler\". Does a greedy algorithm for this problem exist? Maybe there is a strategy to pick edges that we remove in euler cycle construction algorithm..."
                    },
                    {
                        "username": "bparanj",
                        "content": "You\\'re right in recognizing the similarities between this problem and the problem of making all weakly connected components (SCCs) in a directed graph Eulerian by deleting the minimum number of edges. Both involve dealing with directed graphs and have a certain optimization goal.\\n\\nHowever, note that making a graph Eulerian involves creating a path or cycle that visits each edge exactly once, which is different from the goal of this problem - to fulfill the maximum number of requests.\\n\\nRegarding the question of whether a greedy algorithm exists for this problem: Greedy algorithms work well when the problem has the property of \"optimal substructure,\" meaning that an optimal solution can be constructed efficiently from optimal solutions of its subproblems. Problems that can be solved with greedy algorithms include Kruskal\\u2019s Minimum Spanning Tree, Dijkstra\\u2019s Shortest Path, etc.\\n\\nHowever, this problem doesn\\'t appear to have an optimal substructure. Simply choosing the best local options (like fulfilling the requests that appear most frequently first or choosing the shortest cycles in the graph first) doesn\\'t necessarily lead to an overall optimal solution. This is why a greedy approach might not work here, and why a brute-force or bit-masking technique is typically used.\\n\\nThere is no efficient greedy solution has been found for this problem. For larger inputs, approximation algorithms or heuristics might be used, with the understanding that they may not always yield the optimal solution. \\n\\nRemember that solving such problems often involves a trade-off between optimality and computational feasibility.\\n"
                    },
                    {
                        "username": "nikmy",
                        "content": "So, I've thought about the problem, and there are some interesting ideas. Let divergence of vertex be (out_degree - in_degree). Since loops (x -> x edges) doesn't affect, we can ignore them and suppose that. Sum of divergences is 0, if we delete all edges, we'll get all vertices with divergences equal to 0. From Euler graph criteria, we need all divergences to be 0, but we must remove minimum number of edges. Let's look at vertex with div > 0. We can zero it only by removing outcoming edges. Similar logic works for div < 0. It seems like we can pick vertex U with max/min not null divergence, remove it's outcoming edge that leads to a vertex V with min/max divergence among U's neighbors, and update divergence of U and V. If we will do it until all divs become 0, we (possibly) have removed minimum number of edges and  (len(requests) - removedEdges) will be the answer, that we got in O(E log V) time (we have removed <= E edges, and to find optimal neighbour we can use heap)."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "We don\\'t have to delete minimum number of edges, we have to delete maximum number of edges. Removing a cycle in greedy way without observing other cycle means that we can end up removing this cycle but this could break another cycle that was larger and should have been favored first. So I think we are just left with this madness mentioned in Editorial"
                    },
                    {
                        "username": "dumb_me",
                        "content": "it is easy if you know template of backtracking "
                    },
                    {
                        "username": "kumaraashish118",
                        "content": "Where can I get the template of backtracking?"
                    },
                    {
                        "username": "sahilyaduvanshii",
                        "content": "n=3\\n[[0,0],[1,1],[0,0],[2,0],[2,2],[1,1],[2,1],[0,1],[0,1]]\\nwhy this input is giving 5 as output ?\\naccording to me the output should be 6\\nplease explain?"
                    },
                    {
                        "username": "bparanj",
                        "content": "The problem statement mentions that \"Each request is represented by a pair of integers, where the first integer represents the source building and the second one represents the target building.\" \\n\\nAlso, keep in mind that buildings have to end with the same number of employees as they started with. So for the request to be fulfilled, the number of outgoing requests (employees leaving) from a building should equal the number of incoming requests (employees entering) to that building. \\n\\nLet\\'s go through each request in your example:\\n\\n1. [0, 0]: This request can be ignored since it does not cause any employee to move. So we can fulfill this request.\\n2. [1, 1]: Similar to the first request, this can be ignored since no movement of employees occur. This request can also be fulfilled.\\n3. [0, 0]: This is another self-referential request and can be fulfilled.\\n4. [2, 0]: An employee moves from building 2 to building 0.\\n5. [2, 2]: This is a self-referential request and can be fulfilled.\\n6. [1, 1]: This is another self-referential request and can be fulfilled.\\n7. [2, 1]: An employee moves from building 2 to building 1. Now, building 2 has 0 employees left.\\n8. [0, 1]: An employee moves from building 0 to building 1. Now, building 0 has 0 employees left.\\n9. [0, 1]: We cannot fulfill this request since building 0 has no employees left.\\n\\nSo the maximum number of requests that can be fulfilled is 5. Hence the output is 5, not 6."
                    },
                    {
                        "username": "sahilyaduvanshii",
                        "content": "[@tifv](/tifv) I was looking at the 0th building only as there is 2 outgoing edges and 1 incoming edge So I was approving that request later I reckon that by doing so the indegree of 1 will be disturbed hence this is not an valid request"
                    },
                    {
                        "username": "deCodeIt",
                        "content": "All 5 will be intra building ( within same building ) transfers, from where are you getting an inter building ( different building ) transfer? Remember that\\'s it a DIRECTED edge / connection."
                    },
                    {
                        "username": "tifv",
                        "content": "Transfers 0\\u202F\\u2192\\u202F0 and similar (i.e. within the same building) are all possible, independently of all other transfers. There are five of them.\\n\\nIf you exclude them, remaining are 2\\u202F\\u2192\\u202F0, 2\\u202F\\u2192\\u202F1, 0\\u202F\\u2192\\u202F1 (twice). Nobody wants to go to building 2, so transfers from 2 are impossible. If you exclude them, only two transfers 0\\u202F\\u2192\\u202F1 remain, also impossible."
                    },
                    {
                        "username": "woundweavr",
                        "content": "Always check constraints I guess.  Brute force ftw"
                    },
                    {
                        "username": "raghavgoel18",
                        "content": "how to know if constraints are enough for brute force?\\n"
                    },
                    {
                        "username": "vladpetric",
                        "content": "NP complete proof.\\n\\nI start with the Hamiltonian cycle in a directed graph. That problem is NP complete.\\n\\nStraightforward reduction from Hamiltonian cycle to this problem is as follows: We take the original graph, pass it as such to the current problem, and check if the response is equal to the number of vertices.  "
                    },
                    {
                        "username": "cecilia5",
                        "content": "The reduction is flawed.\\n\\nConsider this graph:\\n\\n`a -> b, b->a, c->d, d->c`. The number of requests satisfied is 4, the same as the number of vertices in the graph, but the graph has no hamiltonian cycle. Heck - it isn\\'t even connected!\\n\\nThe fact that this problem can be solved by min cost flow (a polynomial algorithm) sort of disprove the fact that it is NP complete\\n\\n\\n"
                    },
                    {
                        "username": "uavishal777",
                        "content": "I firstly thought its a graph question as just find the indegree and outdegree of nodes and count the transfers with zero resultant \\n"
                    },
                    {
                        "username": "Md_Atik",
                        "content": "meet in the middle technique. Beats 100%.\\nhttps://leetcode.com/problems/maximum-number-of-achievable-transfer-requests/solutions/3757645/beat-100-meet-in-the-middle/"
                    },
                    {
                        "username": "RisabhKedai",
                        "content": "Can we solve it using DFS ?\\n"
                    }
                ]
            },
            {
                "id": 1955197,
                "content": [
                    {
                        "username": "mx64",
                        "content": "As others pointed out, this could easily be a medium.\\nA follow up could be harder, e.g. with larger number of requests and buildings."
                    },
                    {
                        "username": "Maverick767",
                        "content": "[@bparanj](/bparanj) Lmfao did you just chat gpt a response to this person? How does this answer help at all?"
                    },
                    {
                        "username": "bparanj",
                        "content": "[@psionl0](/psionl0) In the case of larger inputs, the exhaustive search approach indeed becomes infeasible due to exponential complexity. To improve the efficiency, we could consider the following techniques:\\n\\n1. **Pruning**: This involves discarding certain choices early in the search if we can prove that they will not lead to an optimal solution. For example, if we have two requests that involve the same employee, and one request has a greater score than the other, we can ignore the lesser request. \\n\\n2. **Heuristics**: These are rules that help in making the search more efficient by prioritizing certain paths. For example, we could prioritize requests that involve employees who appear less frequently in the list of requests.\\n\\n3. **Parallel processing**: If hardware resources allow, we could divide the search space into independent parts and process them in parallel.\\n\\n4. **Greedy algorithms**: These make locally optimal choices at each stage in the hope that these local choices will lead to a global optimum. However, they do not always produce the optimal solution for every problem.\\n\\n5. **Approximation algorithms**: If an exact solution is not feasible in a reasonable time, we can consider algorithms that provide a solution close to the optimal one.\\n\\nRemember that these techniques depend on the nature of the problem and the specific input data, and their efficiency can vary. Before applying them, it\\'s necessary to analyze the problem and data characteristics to identify the most promising approaches. However, the problem Maximum Number of Achievable Transfer Requests seems to be a version of the \"Maximum Coverage Problem\", which is known to be NP-hard, so an exact solution cannot be found in polynomial time. Therefore, in case of larger inputs, we might have to resort to approximation algorithms or heuristics."
                    },
                    {
                        "username": "psionl0",
                        "content": "Any suggestions on how the solution could be optimized. Sure, we can delete self referential requests and two-way cycles but that is hardly likely to make a big dent on the number of requests remaining if that number is large."
                    },
                    {
                        "username": "iamnishthavan",
                        "content": "Won\\'t this work Anyone?\\n\"Find all cycles and sort them by their length and pick one by one removing those edges from graph\""
                    },
                    {
                        "username": "bparanj",
                        "content": "This approach sounds like a Greedy Algorithm, where you choose the best option (the shortest cycle in this case) at each step. However, it is important to note that Greedy Algorithms do not always guarantee the global optimal solution, and this problem is an example of such a case.\\n\\nThe approach you proposed will find the shortest cycles first and remove those requests from the graph. But choosing the shortest cycles first doesn\\'t necessarily lead to the maximum number of achievable transfer requests. Consider the case where there are multiple short cycles and one long cycle that includes all the edges of the short cycles. If we choose the short cycles first, we would lose the opportunity to select the long cycle, which could potentially satisfy more transfer requests.\\n\\nThis problem is essentially a variant of the Maximum Coverage Problem, which is NP-hard. Therefore, it doesn\\'t have an efficient solution that works in all cases. The most common approach for this problem is to use a brute-force method that tries all combinations of requests (or a bit masking technique that achieves the same thing), but this method is not efficient for large inputs. For large inputs, we might need to use approximation algorithms or heuristics, understanding that they might not always provide the optimal solution."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Yup! Even I thought this. This appears to be the sanest way, that we need to remove cycles starting from the largest one. But I was shocked to see that Graphs/Cycle Detection was not in the Related Topic Tags. I think the problem would be finding unique cycles and then removing those edges from graph. Finding would be an issue since a cycle with 5 nodes will be found 5 times. Removing the edges to remove the cycle too would be difficult to implement, hence I think we have to do with this idiotic way \\uD83D\\uDE11"
                    },
                    {
                        "username": "nikmy",
                        "content": "Sounds just like \"delete minimum number of edges to make all weak SCCs in directed graph euler\". Does a greedy algorithm for this problem exist? Maybe there is a strategy to pick edges that we remove in euler cycle construction algorithm..."
                    },
                    {
                        "username": "bparanj",
                        "content": "You\\'re right in recognizing the similarities between this problem and the problem of making all weakly connected components (SCCs) in a directed graph Eulerian by deleting the minimum number of edges. Both involve dealing with directed graphs and have a certain optimization goal.\\n\\nHowever, note that making a graph Eulerian involves creating a path or cycle that visits each edge exactly once, which is different from the goal of this problem - to fulfill the maximum number of requests.\\n\\nRegarding the question of whether a greedy algorithm exists for this problem: Greedy algorithms work well when the problem has the property of \"optimal substructure,\" meaning that an optimal solution can be constructed efficiently from optimal solutions of its subproblems. Problems that can be solved with greedy algorithms include Kruskal\\u2019s Minimum Spanning Tree, Dijkstra\\u2019s Shortest Path, etc.\\n\\nHowever, this problem doesn\\'t appear to have an optimal substructure. Simply choosing the best local options (like fulfilling the requests that appear most frequently first or choosing the shortest cycles in the graph first) doesn\\'t necessarily lead to an overall optimal solution. This is why a greedy approach might not work here, and why a brute-force or bit-masking technique is typically used.\\n\\nThere is no efficient greedy solution has been found for this problem. For larger inputs, approximation algorithms or heuristics might be used, with the understanding that they may not always yield the optimal solution. \\n\\nRemember that solving such problems often involves a trade-off between optimality and computational feasibility.\\n"
                    },
                    {
                        "username": "nikmy",
                        "content": "So, I've thought about the problem, and there are some interesting ideas. Let divergence of vertex be (out_degree - in_degree). Since loops (x -> x edges) doesn't affect, we can ignore them and suppose that. Sum of divergences is 0, if we delete all edges, we'll get all vertices with divergences equal to 0. From Euler graph criteria, we need all divergences to be 0, but we must remove minimum number of edges. Let's look at vertex with div > 0. We can zero it only by removing outcoming edges. Similar logic works for div < 0. It seems like we can pick vertex U with max/min not null divergence, remove it's outcoming edge that leads to a vertex V with min/max divergence among U's neighbors, and update divergence of U and V. If we will do it until all divs become 0, we (possibly) have removed minimum number of edges and  (len(requests) - removedEdges) will be the answer, that we got in O(E log V) time (we have removed <= E edges, and to find optimal neighbour we can use heap)."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "We don\\'t have to delete minimum number of edges, we have to delete maximum number of edges. Removing a cycle in greedy way without observing other cycle means that we can end up removing this cycle but this could break another cycle that was larger and should have been favored first. So I think we are just left with this madness mentioned in Editorial"
                    },
                    {
                        "username": "dumb_me",
                        "content": "it is easy if you know template of backtracking "
                    },
                    {
                        "username": "kumaraashish118",
                        "content": "Where can I get the template of backtracking?"
                    },
                    {
                        "username": "sahilyaduvanshii",
                        "content": "n=3\\n[[0,0],[1,1],[0,0],[2,0],[2,2],[1,1],[2,1],[0,1],[0,1]]\\nwhy this input is giving 5 as output ?\\naccording to me the output should be 6\\nplease explain?"
                    },
                    {
                        "username": "bparanj",
                        "content": "The problem statement mentions that \"Each request is represented by a pair of integers, where the first integer represents the source building and the second one represents the target building.\" \\n\\nAlso, keep in mind that buildings have to end with the same number of employees as they started with. So for the request to be fulfilled, the number of outgoing requests (employees leaving) from a building should equal the number of incoming requests (employees entering) to that building. \\n\\nLet\\'s go through each request in your example:\\n\\n1. [0, 0]: This request can be ignored since it does not cause any employee to move. So we can fulfill this request.\\n2. [1, 1]: Similar to the first request, this can be ignored since no movement of employees occur. This request can also be fulfilled.\\n3. [0, 0]: This is another self-referential request and can be fulfilled.\\n4. [2, 0]: An employee moves from building 2 to building 0.\\n5. [2, 2]: This is a self-referential request and can be fulfilled.\\n6. [1, 1]: This is another self-referential request and can be fulfilled.\\n7. [2, 1]: An employee moves from building 2 to building 1. Now, building 2 has 0 employees left.\\n8. [0, 1]: An employee moves from building 0 to building 1. Now, building 0 has 0 employees left.\\n9. [0, 1]: We cannot fulfill this request since building 0 has no employees left.\\n\\nSo the maximum number of requests that can be fulfilled is 5. Hence the output is 5, not 6."
                    },
                    {
                        "username": "sahilyaduvanshii",
                        "content": "[@tifv](/tifv) I was looking at the 0th building only as there is 2 outgoing edges and 1 incoming edge So I was approving that request later I reckon that by doing so the indegree of 1 will be disturbed hence this is not an valid request"
                    },
                    {
                        "username": "deCodeIt",
                        "content": "All 5 will be intra building ( within same building ) transfers, from where are you getting an inter building ( different building ) transfer? Remember that\\'s it a DIRECTED edge / connection."
                    },
                    {
                        "username": "tifv",
                        "content": "Transfers 0\\u202F\\u2192\\u202F0 and similar (i.e. within the same building) are all possible, independently of all other transfers. There are five of them.\\n\\nIf you exclude them, remaining are 2\\u202F\\u2192\\u202F0, 2\\u202F\\u2192\\u202F1, 0\\u202F\\u2192\\u202F1 (twice). Nobody wants to go to building 2, so transfers from 2 are impossible. If you exclude them, only two transfers 0\\u202F\\u2192\\u202F1 remain, also impossible."
                    },
                    {
                        "username": "woundweavr",
                        "content": "Always check constraints I guess.  Brute force ftw"
                    },
                    {
                        "username": "raghavgoel18",
                        "content": "how to know if constraints are enough for brute force?\\n"
                    },
                    {
                        "username": "vladpetric",
                        "content": "NP complete proof.\\n\\nI start with the Hamiltonian cycle in a directed graph. That problem is NP complete.\\n\\nStraightforward reduction from Hamiltonian cycle to this problem is as follows: We take the original graph, pass it as such to the current problem, and check if the response is equal to the number of vertices.  "
                    },
                    {
                        "username": "cecilia5",
                        "content": "The reduction is flawed.\\n\\nConsider this graph:\\n\\n`a -> b, b->a, c->d, d->c`. The number of requests satisfied is 4, the same as the number of vertices in the graph, but the graph has no hamiltonian cycle. Heck - it isn\\'t even connected!\\n\\nThe fact that this problem can be solved by min cost flow (a polynomial algorithm) sort of disprove the fact that it is NP complete\\n\\n\\n"
                    },
                    {
                        "username": "uavishal777",
                        "content": "I firstly thought its a graph question as just find the indegree and outdegree of nodes and count the transfers with zero resultant \\n"
                    },
                    {
                        "username": "Md_Atik",
                        "content": "meet in the middle technique. Beats 100%.\\nhttps://leetcode.com/problems/maximum-number-of-achievable-transfer-requests/solutions/3757645/beat-100-meet-in-the-middle/"
                    },
                    {
                        "username": "RisabhKedai",
                        "content": "Can we solve it using DFS ?\\n"
                    }
                ]
            },
            {
                "id": 1986308,
                "content": [
                    {
                        "username": "mx64",
                        "content": "As others pointed out, this could easily be a medium.\\nA follow up could be harder, e.g. with larger number of requests and buildings."
                    },
                    {
                        "username": "Maverick767",
                        "content": "[@bparanj](/bparanj) Lmfao did you just chat gpt a response to this person? How does this answer help at all?"
                    },
                    {
                        "username": "bparanj",
                        "content": "[@psionl0](/psionl0) In the case of larger inputs, the exhaustive search approach indeed becomes infeasible due to exponential complexity. To improve the efficiency, we could consider the following techniques:\\n\\n1. **Pruning**: This involves discarding certain choices early in the search if we can prove that they will not lead to an optimal solution. For example, if we have two requests that involve the same employee, and one request has a greater score than the other, we can ignore the lesser request. \\n\\n2. **Heuristics**: These are rules that help in making the search more efficient by prioritizing certain paths. For example, we could prioritize requests that involve employees who appear less frequently in the list of requests.\\n\\n3. **Parallel processing**: If hardware resources allow, we could divide the search space into independent parts and process them in parallel.\\n\\n4. **Greedy algorithms**: These make locally optimal choices at each stage in the hope that these local choices will lead to a global optimum. However, they do not always produce the optimal solution for every problem.\\n\\n5. **Approximation algorithms**: If an exact solution is not feasible in a reasonable time, we can consider algorithms that provide a solution close to the optimal one.\\n\\nRemember that these techniques depend on the nature of the problem and the specific input data, and their efficiency can vary. Before applying them, it\\'s necessary to analyze the problem and data characteristics to identify the most promising approaches. However, the problem Maximum Number of Achievable Transfer Requests seems to be a version of the \"Maximum Coverage Problem\", which is known to be NP-hard, so an exact solution cannot be found in polynomial time. Therefore, in case of larger inputs, we might have to resort to approximation algorithms or heuristics."
                    },
                    {
                        "username": "psionl0",
                        "content": "Any suggestions on how the solution could be optimized. Sure, we can delete self referential requests and two-way cycles but that is hardly likely to make a big dent on the number of requests remaining if that number is large."
                    },
                    {
                        "username": "iamnishthavan",
                        "content": "Won\\'t this work Anyone?\\n\"Find all cycles and sort them by their length and pick one by one removing those edges from graph\""
                    },
                    {
                        "username": "bparanj",
                        "content": "This approach sounds like a Greedy Algorithm, where you choose the best option (the shortest cycle in this case) at each step. However, it is important to note that Greedy Algorithms do not always guarantee the global optimal solution, and this problem is an example of such a case.\\n\\nThe approach you proposed will find the shortest cycles first and remove those requests from the graph. But choosing the shortest cycles first doesn\\'t necessarily lead to the maximum number of achievable transfer requests. Consider the case where there are multiple short cycles and one long cycle that includes all the edges of the short cycles. If we choose the short cycles first, we would lose the opportunity to select the long cycle, which could potentially satisfy more transfer requests.\\n\\nThis problem is essentially a variant of the Maximum Coverage Problem, which is NP-hard. Therefore, it doesn\\'t have an efficient solution that works in all cases. The most common approach for this problem is to use a brute-force method that tries all combinations of requests (or a bit masking technique that achieves the same thing), but this method is not efficient for large inputs. For large inputs, we might need to use approximation algorithms or heuristics, understanding that they might not always provide the optimal solution."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Yup! Even I thought this. This appears to be the sanest way, that we need to remove cycles starting from the largest one. But I was shocked to see that Graphs/Cycle Detection was not in the Related Topic Tags. I think the problem would be finding unique cycles and then removing those edges from graph. Finding would be an issue since a cycle with 5 nodes will be found 5 times. Removing the edges to remove the cycle too would be difficult to implement, hence I think we have to do with this idiotic way \\uD83D\\uDE11"
                    },
                    {
                        "username": "nikmy",
                        "content": "Sounds just like \"delete minimum number of edges to make all weak SCCs in directed graph euler\". Does a greedy algorithm for this problem exist? Maybe there is a strategy to pick edges that we remove in euler cycle construction algorithm..."
                    },
                    {
                        "username": "bparanj",
                        "content": "You\\'re right in recognizing the similarities between this problem and the problem of making all weakly connected components (SCCs) in a directed graph Eulerian by deleting the minimum number of edges. Both involve dealing with directed graphs and have a certain optimization goal.\\n\\nHowever, note that making a graph Eulerian involves creating a path or cycle that visits each edge exactly once, which is different from the goal of this problem - to fulfill the maximum number of requests.\\n\\nRegarding the question of whether a greedy algorithm exists for this problem: Greedy algorithms work well when the problem has the property of \"optimal substructure,\" meaning that an optimal solution can be constructed efficiently from optimal solutions of its subproblems. Problems that can be solved with greedy algorithms include Kruskal\\u2019s Minimum Spanning Tree, Dijkstra\\u2019s Shortest Path, etc.\\n\\nHowever, this problem doesn\\'t appear to have an optimal substructure. Simply choosing the best local options (like fulfilling the requests that appear most frequently first or choosing the shortest cycles in the graph first) doesn\\'t necessarily lead to an overall optimal solution. This is why a greedy approach might not work here, and why a brute-force or bit-masking technique is typically used.\\n\\nThere is no efficient greedy solution has been found for this problem. For larger inputs, approximation algorithms or heuristics might be used, with the understanding that they may not always yield the optimal solution. \\n\\nRemember that solving such problems often involves a trade-off between optimality and computational feasibility.\\n"
                    },
                    {
                        "username": "nikmy",
                        "content": "So, I've thought about the problem, and there are some interesting ideas. Let divergence of vertex be (out_degree - in_degree). Since loops (x -> x edges) doesn't affect, we can ignore them and suppose that. Sum of divergences is 0, if we delete all edges, we'll get all vertices with divergences equal to 0. From Euler graph criteria, we need all divergences to be 0, but we must remove minimum number of edges. Let's look at vertex with div > 0. We can zero it only by removing outcoming edges. Similar logic works for div < 0. It seems like we can pick vertex U with max/min not null divergence, remove it's outcoming edge that leads to a vertex V with min/max divergence among U's neighbors, and update divergence of U and V. If we will do it until all divs become 0, we (possibly) have removed minimum number of edges and  (len(requests) - removedEdges) will be the answer, that we got in O(E log V) time (we have removed <= E edges, and to find optimal neighbour we can use heap)."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "We don\\'t have to delete minimum number of edges, we have to delete maximum number of edges. Removing a cycle in greedy way without observing other cycle means that we can end up removing this cycle but this could break another cycle that was larger and should have been favored first. So I think we are just left with this madness mentioned in Editorial"
                    },
                    {
                        "username": "dumb_me",
                        "content": "it is easy if you know template of backtracking "
                    },
                    {
                        "username": "kumaraashish118",
                        "content": "Where can I get the template of backtracking?"
                    },
                    {
                        "username": "sahilyaduvanshii",
                        "content": "n=3\\n[[0,0],[1,1],[0,0],[2,0],[2,2],[1,1],[2,1],[0,1],[0,1]]\\nwhy this input is giving 5 as output ?\\naccording to me the output should be 6\\nplease explain?"
                    },
                    {
                        "username": "bparanj",
                        "content": "The problem statement mentions that \"Each request is represented by a pair of integers, where the first integer represents the source building and the second one represents the target building.\" \\n\\nAlso, keep in mind that buildings have to end with the same number of employees as they started with. So for the request to be fulfilled, the number of outgoing requests (employees leaving) from a building should equal the number of incoming requests (employees entering) to that building. \\n\\nLet\\'s go through each request in your example:\\n\\n1. [0, 0]: This request can be ignored since it does not cause any employee to move. So we can fulfill this request.\\n2. [1, 1]: Similar to the first request, this can be ignored since no movement of employees occur. This request can also be fulfilled.\\n3. [0, 0]: This is another self-referential request and can be fulfilled.\\n4. [2, 0]: An employee moves from building 2 to building 0.\\n5. [2, 2]: This is a self-referential request and can be fulfilled.\\n6. [1, 1]: This is another self-referential request and can be fulfilled.\\n7. [2, 1]: An employee moves from building 2 to building 1. Now, building 2 has 0 employees left.\\n8. [0, 1]: An employee moves from building 0 to building 1. Now, building 0 has 0 employees left.\\n9. [0, 1]: We cannot fulfill this request since building 0 has no employees left.\\n\\nSo the maximum number of requests that can be fulfilled is 5. Hence the output is 5, not 6."
                    },
                    {
                        "username": "sahilyaduvanshii",
                        "content": "[@tifv](/tifv) I was looking at the 0th building only as there is 2 outgoing edges and 1 incoming edge So I was approving that request later I reckon that by doing so the indegree of 1 will be disturbed hence this is not an valid request"
                    },
                    {
                        "username": "deCodeIt",
                        "content": "All 5 will be intra building ( within same building ) transfers, from where are you getting an inter building ( different building ) transfer? Remember that\\'s it a DIRECTED edge / connection."
                    },
                    {
                        "username": "tifv",
                        "content": "Transfers 0\\u202F\\u2192\\u202F0 and similar (i.e. within the same building) are all possible, independently of all other transfers. There are five of them.\\n\\nIf you exclude them, remaining are 2\\u202F\\u2192\\u202F0, 2\\u202F\\u2192\\u202F1, 0\\u202F\\u2192\\u202F1 (twice). Nobody wants to go to building 2, so transfers from 2 are impossible. If you exclude them, only two transfers 0\\u202F\\u2192\\u202F1 remain, also impossible."
                    },
                    {
                        "username": "woundweavr",
                        "content": "Always check constraints I guess.  Brute force ftw"
                    },
                    {
                        "username": "raghavgoel18",
                        "content": "how to know if constraints are enough for brute force?\\n"
                    },
                    {
                        "username": "vladpetric",
                        "content": "NP complete proof.\\n\\nI start with the Hamiltonian cycle in a directed graph. That problem is NP complete.\\n\\nStraightforward reduction from Hamiltonian cycle to this problem is as follows: We take the original graph, pass it as such to the current problem, and check if the response is equal to the number of vertices.  "
                    },
                    {
                        "username": "cecilia5",
                        "content": "The reduction is flawed.\\n\\nConsider this graph:\\n\\n`a -> b, b->a, c->d, d->c`. The number of requests satisfied is 4, the same as the number of vertices in the graph, but the graph has no hamiltonian cycle. Heck - it isn\\'t even connected!\\n\\nThe fact that this problem can be solved by min cost flow (a polynomial algorithm) sort of disprove the fact that it is NP complete\\n\\n\\n"
                    },
                    {
                        "username": "uavishal777",
                        "content": "I firstly thought its a graph question as just find the indegree and outdegree of nodes and count the transfers with zero resultant \\n"
                    },
                    {
                        "username": "Md_Atik",
                        "content": "meet in the middle technique. Beats 100%.\\nhttps://leetcode.com/problems/maximum-number-of-achievable-transfer-requests/solutions/3757645/beat-100-meet-in-the-middle/"
                    },
                    {
                        "username": "RisabhKedai",
                        "content": "Can we solve it using DFS ?\\n"
                    }
                ]
            },
            {
                "id": 1967753,
                "content": [
                    {
                        "username": "mx64",
                        "content": "As others pointed out, this could easily be a medium.\\nA follow up could be harder, e.g. with larger number of requests and buildings."
                    },
                    {
                        "username": "Maverick767",
                        "content": "[@bparanj](/bparanj) Lmfao did you just chat gpt a response to this person? How does this answer help at all?"
                    },
                    {
                        "username": "bparanj",
                        "content": "[@psionl0](/psionl0) In the case of larger inputs, the exhaustive search approach indeed becomes infeasible due to exponential complexity. To improve the efficiency, we could consider the following techniques:\\n\\n1. **Pruning**: This involves discarding certain choices early in the search if we can prove that they will not lead to an optimal solution. For example, if we have two requests that involve the same employee, and one request has a greater score than the other, we can ignore the lesser request. \\n\\n2. **Heuristics**: These are rules that help in making the search more efficient by prioritizing certain paths. For example, we could prioritize requests that involve employees who appear less frequently in the list of requests.\\n\\n3. **Parallel processing**: If hardware resources allow, we could divide the search space into independent parts and process them in parallel.\\n\\n4. **Greedy algorithms**: These make locally optimal choices at each stage in the hope that these local choices will lead to a global optimum. However, they do not always produce the optimal solution for every problem.\\n\\n5. **Approximation algorithms**: If an exact solution is not feasible in a reasonable time, we can consider algorithms that provide a solution close to the optimal one.\\n\\nRemember that these techniques depend on the nature of the problem and the specific input data, and their efficiency can vary. Before applying them, it\\'s necessary to analyze the problem and data characteristics to identify the most promising approaches. However, the problem Maximum Number of Achievable Transfer Requests seems to be a version of the \"Maximum Coverage Problem\", which is known to be NP-hard, so an exact solution cannot be found in polynomial time. Therefore, in case of larger inputs, we might have to resort to approximation algorithms or heuristics."
                    },
                    {
                        "username": "psionl0",
                        "content": "Any suggestions on how the solution could be optimized. Sure, we can delete self referential requests and two-way cycles but that is hardly likely to make a big dent on the number of requests remaining if that number is large."
                    },
                    {
                        "username": "iamnishthavan",
                        "content": "Won\\'t this work Anyone?\\n\"Find all cycles and sort them by their length and pick one by one removing those edges from graph\""
                    },
                    {
                        "username": "bparanj",
                        "content": "This approach sounds like a Greedy Algorithm, where you choose the best option (the shortest cycle in this case) at each step. However, it is important to note that Greedy Algorithms do not always guarantee the global optimal solution, and this problem is an example of such a case.\\n\\nThe approach you proposed will find the shortest cycles first and remove those requests from the graph. But choosing the shortest cycles first doesn\\'t necessarily lead to the maximum number of achievable transfer requests. Consider the case where there are multiple short cycles and one long cycle that includes all the edges of the short cycles. If we choose the short cycles first, we would lose the opportunity to select the long cycle, which could potentially satisfy more transfer requests.\\n\\nThis problem is essentially a variant of the Maximum Coverage Problem, which is NP-hard. Therefore, it doesn\\'t have an efficient solution that works in all cases. The most common approach for this problem is to use a brute-force method that tries all combinations of requests (or a bit masking technique that achieves the same thing), but this method is not efficient for large inputs. For large inputs, we might need to use approximation algorithms or heuristics, understanding that they might not always provide the optimal solution."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Yup! Even I thought this. This appears to be the sanest way, that we need to remove cycles starting from the largest one. But I was shocked to see that Graphs/Cycle Detection was not in the Related Topic Tags. I think the problem would be finding unique cycles and then removing those edges from graph. Finding would be an issue since a cycle with 5 nodes will be found 5 times. Removing the edges to remove the cycle too would be difficult to implement, hence I think we have to do with this idiotic way \\uD83D\\uDE11"
                    },
                    {
                        "username": "nikmy",
                        "content": "Sounds just like \"delete minimum number of edges to make all weak SCCs in directed graph euler\". Does a greedy algorithm for this problem exist? Maybe there is a strategy to pick edges that we remove in euler cycle construction algorithm..."
                    },
                    {
                        "username": "bparanj",
                        "content": "You\\'re right in recognizing the similarities between this problem and the problem of making all weakly connected components (SCCs) in a directed graph Eulerian by deleting the minimum number of edges. Both involve dealing with directed graphs and have a certain optimization goal.\\n\\nHowever, note that making a graph Eulerian involves creating a path or cycle that visits each edge exactly once, which is different from the goal of this problem - to fulfill the maximum number of requests.\\n\\nRegarding the question of whether a greedy algorithm exists for this problem: Greedy algorithms work well when the problem has the property of \"optimal substructure,\" meaning that an optimal solution can be constructed efficiently from optimal solutions of its subproblems. Problems that can be solved with greedy algorithms include Kruskal\\u2019s Minimum Spanning Tree, Dijkstra\\u2019s Shortest Path, etc.\\n\\nHowever, this problem doesn\\'t appear to have an optimal substructure. Simply choosing the best local options (like fulfilling the requests that appear most frequently first or choosing the shortest cycles in the graph first) doesn\\'t necessarily lead to an overall optimal solution. This is why a greedy approach might not work here, and why a brute-force or bit-masking technique is typically used.\\n\\nThere is no efficient greedy solution has been found for this problem. For larger inputs, approximation algorithms or heuristics might be used, with the understanding that they may not always yield the optimal solution. \\n\\nRemember that solving such problems often involves a trade-off between optimality and computational feasibility.\\n"
                    },
                    {
                        "username": "nikmy",
                        "content": "So, I've thought about the problem, and there are some interesting ideas. Let divergence of vertex be (out_degree - in_degree). Since loops (x -> x edges) doesn't affect, we can ignore them and suppose that. Sum of divergences is 0, if we delete all edges, we'll get all vertices with divergences equal to 0. From Euler graph criteria, we need all divergences to be 0, but we must remove minimum number of edges. Let's look at vertex with div > 0. We can zero it only by removing outcoming edges. Similar logic works for div < 0. It seems like we can pick vertex U with max/min not null divergence, remove it's outcoming edge that leads to a vertex V with min/max divergence among U's neighbors, and update divergence of U and V. If we will do it until all divs become 0, we (possibly) have removed minimum number of edges and  (len(requests) - removedEdges) will be the answer, that we got in O(E log V) time (we have removed <= E edges, and to find optimal neighbour we can use heap)."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "We don\\'t have to delete minimum number of edges, we have to delete maximum number of edges. Removing a cycle in greedy way without observing other cycle means that we can end up removing this cycle but this could break another cycle that was larger and should have been favored first. So I think we are just left with this madness mentioned in Editorial"
                    },
                    {
                        "username": "dumb_me",
                        "content": "it is easy if you know template of backtracking "
                    },
                    {
                        "username": "kumaraashish118",
                        "content": "Where can I get the template of backtracking?"
                    },
                    {
                        "username": "sahilyaduvanshii",
                        "content": "n=3\\n[[0,0],[1,1],[0,0],[2,0],[2,2],[1,1],[2,1],[0,1],[0,1]]\\nwhy this input is giving 5 as output ?\\naccording to me the output should be 6\\nplease explain?"
                    },
                    {
                        "username": "bparanj",
                        "content": "The problem statement mentions that \"Each request is represented by a pair of integers, where the first integer represents the source building and the second one represents the target building.\" \\n\\nAlso, keep in mind that buildings have to end with the same number of employees as they started with. So for the request to be fulfilled, the number of outgoing requests (employees leaving) from a building should equal the number of incoming requests (employees entering) to that building. \\n\\nLet\\'s go through each request in your example:\\n\\n1. [0, 0]: This request can be ignored since it does not cause any employee to move. So we can fulfill this request.\\n2. [1, 1]: Similar to the first request, this can be ignored since no movement of employees occur. This request can also be fulfilled.\\n3. [0, 0]: This is another self-referential request and can be fulfilled.\\n4. [2, 0]: An employee moves from building 2 to building 0.\\n5. [2, 2]: This is a self-referential request and can be fulfilled.\\n6. [1, 1]: This is another self-referential request and can be fulfilled.\\n7. [2, 1]: An employee moves from building 2 to building 1. Now, building 2 has 0 employees left.\\n8. [0, 1]: An employee moves from building 0 to building 1. Now, building 0 has 0 employees left.\\n9. [0, 1]: We cannot fulfill this request since building 0 has no employees left.\\n\\nSo the maximum number of requests that can be fulfilled is 5. Hence the output is 5, not 6."
                    },
                    {
                        "username": "sahilyaduvanshii",
                        "content": "[@tifv](/tifv) I was looking at the 0th building only as there is 2 outgoing edges and 1 incoming edge So I was approving that request later I reckon that by doing so the indegree of 1 will be disturbed hence this is not an valid request"
                    },
                    {
                        "username": "deCodeIt",
                        "content": "All 5 will be intra building ( within same building ) transfers, from where are you getting an inter building ( different building ) transfer? Remember that\\'s it a DIRECTED edge / connection."
                    },
                    {
                        "username": "tifv",
                        "content": "Transfers 0\\u202F\\u2192\\u202F0 and similar (i.e. within the same building) are all possible, independently of all other transfers. There are five of them.\\n\\nIf you exclude them, remaining are 2\\u202F\\u2192\\u202F0, 2\\u202F\\u2192\\u202F1, 0\\u202F\\u2192\\u202F1 (twice). Nobody wants to go to building 2, so transfers from 2 are impossible. If you exclude them, only two transfers 0\\u202F\\u2192\\u202F1 remain, also impossible."
                    },
                    {
                        "username": "woundweavr",
                        "content": "Always check constraints I guess.  Brute force ftw"
                    },
                    {
                        "username": "raghavgoel18",
                        "content": "how to know if constraints are enough for brute force?\\n"
                    },
                    {
                        "username": "vladpetric",
                        "content": "NP complete proof.\\n\\nI start with the Hamiltonian cycle in a directed graph. That problem is NP complete.\\n\\nStraightforward reduction from Hamiltonian cycle to this problem is as follows: We take the original graph, pass it as such to the current problem, and check if the response is equal to the number of vertices.  "
                    },
                    {
                        "username": "cecilia5",
                        "content": "The reduction is flawed.\\n\\nConsider this graph:\\n\\n`a -> b, b->a, c->d, d->c`. The number of requests satisfied is 4, the same as the number of vertices in the graph, but the graph has no hamiltonian cycle. Heck - it isn\\'t even connected!\\n\\nThe fact that this problem can be solved by min cost flow (a polynomial algorithm) sort of disprove the fact that it is NP complete\\n\\n\\n"
                    },
                    {
                        "username": "uavishal777",
                        "content": "I firstly thought its a graph question as just find the indegree and outdegree of nodes and count the transfers with zero resultant \\n"
                    },
                    {
                        "username": "Md_Atik",
                        "content": "meet in the middle technique. Beats 100%.\\nhttps://leetcode.com/problems/maximum-number-of-achievable-transfer-requests/solutions/3757645/beat-100-meet-in-the-middle/"
                    },
                    {
                        "username": "RisabhKedai",
                        "content": "Can we solve it using DFS ?\\n"
                    }
                ]
            },
            {
                "id": 1960998,
                "content": [
                    {
                        "username": "mx64",
                        "content": "As others pointed out, this could easily be a medium.\\nA follow up could be harder, e.g. with larger number of requests and buildings."
                    },
                    {
                        "username": "Maverick767",
                        "content": "[@bparanj](/bparanj) Lmfao did you just chat gpt a response to this person? How does this answer help at all?"
                    },
                    {
                        "username": "bparanj",
                        "content": "[@psionl0](/psionl0) In the case of larger inputs, the exhaustive search approach indeed becomes infeasible due to exponential complexity. To improve the efficiency, we could consider the following techniques:\\n\\n1. **Pruning**: This involves discarding certain choices early in the search if we can prove that they will not lead to an optimal solution. For example, if we have two requests that involve the same employee, and one request has a greater score than the other, we can ignore the lesser request. \\n\\n2. **Heuristics**: These are rules that help in making the search more efficient by prioritizing certain paths. For example, we could prioritize requests that involve employees who appear less frequently in the list of requests.\\n\\n3. **Parallel processing**: If hardware resources allow, we could divide the search space into independent parts and process them in parallel.\\n\\n4. **Greedy algorithms**: These make locally optimal choices at each stage in the hope that these local choices will lead to a global optimum. However, they do not always produce the optimal solution for every problem.\\n\\n5. **Approximation algorithms**: If an exact solution is not feasible in a reasonable time, we can consider algorithms that provide a solution close to the optimal one.\\n\\nRemember that these techniques depend on the nature of the problem and the specific input data, and their efficiency can vary. Before applying them, it\\'s necessary to analyze the problem and data characteristics to identify the most promising approaches. However, the problem Maximum Number of Achievable Transfer Requests seems to be a version of the \"Maximum Coverage Problem\", which is known to be NP-hard, so an exact solution cannot be found in polynomial time. Therefore, in case of larger inputs, we might have to resort to approximation algorithms or heuristics."
                    },
                    {
                        "username": "psionl0",
                        "content": "Any suggestions on how the solution could be optimized. Sure, we can delete self referential requests and two-way cycles but that is hardly likely to make a big dent on the number of requests remaining if that number is large."
                    },
                    {
                        "username": "iamnishthavan",
                        "content": "Won\\'t this work Anyone?\\n\"Find all cycles and sort them by their length and pick one by one removing those edges from graph\""
                    },
                    {
                        "username": "bparanj",
                        "content": "This approach sounds like a Greedy Algorithm, where you choose the best option (the shortest cycle in this case) at each step. However, it is important to note that Greedy Algorithms do not always guarantee the global optimal solution, and this problem is an example of such a case.\\n\\nThe approach you proposed will find the shortest cycles first and remove those requests from the graph. But choosing the shortest cycles first doesn\\'t necessarily lead to the maximum number of achievable transfer requests. Consider the case where there are multiple short cycles and one long cycle that includes all the edges of the short cycles. If we choose the short cycles first, we would lose the opportunity to select the long cycle, which could potentially satisfy more transfer requests.\\n\\nThis problem is essentially a variant of the Maximum Coverage Problem, which is NP-hard. Therefore, it doesn\\'t have an efficient solution that works in all cases. The most common approach for this problem is to use a brute-force method that tries all combinations of requests (or a bit masking technique that achieves the same thing), but this method is not efficient for large inputs. For large inputs, we might need to use approximation algorithms or heuristics, understanding that they might not always provide the optimal solution."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Yup! Even I thought this. This appears to be the sanest way, that we need to remove cycles starting from the largest one. But I was shocked to see that Graphs/Cycle Detection was not in the Related Topic Tags. I think the problem would be finding unique cycles and then removing those edges from graph. Finding would be an issue since a cycle with 5 nodes will be found 5 times. Removing the edges to remove the cycle too would be difficult to implement, hence I think we have to do with this idiotic way \\uD83D\\uDE11"
                    },
                    {
                        "username": "nikmy",
                        "content": "Sounds just like \"delete minimum number of edges to make all weak SCCs in directed graph euler\". Does a greedy algorithm for this problem exist? Maybe there is a strategy to pick edges that we remove in euler cycle construction algorithm..."
                    },
                    {
                        "username": "bparanj",
                        "content": "You\\'re right in recognizing the similarities between this problem and the problem of making all weakly connected components (SCCs) in a directed graph Eulerian by deleting the minimum number of edges. Both involve dealing with directed graphs and have a certain optimization goal.\\n\\nHowever, note that making a graph Eulerian involves creating a path or cycle that visits each edge exactly once, which is different from the goal of this problem - to fulfill the maximum number of requests.\\n\\nRegarding the question of whether a greedy algorithm exists for this problem: Greedy algorithms work well when the problem has the property of \"optimal substructure,\" meaning that an optimal solution can be constructed efficiently from optimal solutions of its subproblems. Problems that can be solved with greedy algorithms include Kruskal\\u2019s Minimum Spanning Tree, Dijkstra\\u2019s Shortest Path, etc.\\n\\nHowever, this problem doesn\\'t appear to have an optimal substructure. Simply choosing the best local options (like fulfilling the requests that appear most frequently first or choosing the shortest cycles in the graph first) doesn\\'t necessarily lead to an overall optimal solution. This is why a greedy approach might not work here, and why a brute-force or bit-masking technique is typically used.\\n\\nThere is no efficient greedy solution has been found for this problem. For larger inputs, approximation algorithms or heuristics might be used, with the understanding that they may not always yield the optimal solution. \\n\\nRemember that solving such problems often involves a trade-off between optimality and computational feasibility.\\n"
                    },
                    {
                        "username": "nikmy",
                        "content": "So, I've thought about the problem, and there are some interesting ideas. Let divergence of vertex be (out_degree - in_degree). Since loops (x -> x edges) doesn't affect, we can ignore them and suppose that. Sum of divergences is 0, if we delete all edges, we'll get all vertices with divergences equal to 0. From Euler graph criteria, we need all divergences to be 0, but we must remove minimum number of edges. Let's look at vertex with div > 0. We can zero it only by removing outcoming edges. Similar logic works for div < 0. It seems like we can pick vertex U with max/min not null divergence, remove it's outcoming edge that leads to a vertex V with min/max divergence among U's neighbors, and update divergence of U and V. If we will do it until all divs become 0, we (possibly) have removed minimum number of edges and  (len(requests) - removedEdges) will be the answer, that we got in O(E log V) time (we have removed <= E edges, and to find optimal neighbour we can use heap)."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "We don\\'t have to delete minimum number of edges, we have to delete maximum number of edges. Removing a cycle in greedy way without observing other cycle means that we can end up removing this cycle but this could break another cycle that was larger and should have been favored first. So I think we are just left with this madness mentioned in Editorial"
                    },
                    {
                        "username": "dumb_me",
                        "content": "it is easy if you know template of backtracking "
                    },
                    {
                        "username": "kumaraashish118",
                        "content": "Where can I get the template of backtracking?"
                    },
                    {
                        "username": "sahilyaduvanshii",
                        "content": "n=3\\n[[0,0],[1,1],[0,0],[2,0],[2,2],[1,1],[2,1],[0,1],[0,1]]\\nwhy this input is giving 5 as output ?\\naccording to me the output should be 6\\nplease explain?"
                    },
                    {
                        "username": "bparanj",
                        "content": "The problem statement mentions that \"Each request is represented by a pair of integers, where the first integer represents the source building and the second one represents the target building.\" \\n\\nAlso, keep in mind that buildings have to end with the same number of employees as they started with. So for the request to be fulfilled, the number of outgoing requests (employees leaving) from a building should equal the number of incoming requests (employees entering) to that building. \\n\\nLet\\'s go through each request in your example:\\n\\n1. [0, 0]: This request can be ignored since it does not cause any employee to move. So we can fulfill this request.\\n2. [1, 1]: Similar to the first request, this can be ignored since no movement of employees occur. This request can also be fulfilled.\\n3. [0, 0]: This is another self-referential request and can be fulfilled.\\n4. [2, 0]: An employee moves from building 2 to building 0.\\n5. [2, 2]: This is a self-referential request and can be fulfilled.\\n6. [1, 1]: This is another self-referential request and can be fulfilled.\\n7. [2, 1]: An employee moves from building 2 to building 1. Now, building 2 has 0 employees left.\\n8. [0, 1]: An employee moves from building 0 to building 1. Now, building 0 has 0 employees left.\\n9. [0, 1]: We cannot fulfill this request since building 0 has no employees left.\\n\\nSo the maximum number of requests that can be fulfilled is 5. Hence the output is 5, not 6."
                    },
                    {
                        "username": "sahilyaduvanshii",
                        "content": "[@tifv](/tifv) I was looking at the 0th building only as there is 2 outgoing edges and 1 incoming edge So I was approving that request later I reckon that by doing so the indegree of 1 will be disturbed hence this is not an valid request"
                    },
                    {
                        "username": "deCodeIt",
                        "content": "All 5 will be intra building ( within same building ) transfers, from where are you getting an inter building ( different building ) transfer? Remember that\\'s it a DIRECTED edge / connection."
                    },
                    {
                        "username": "tifv",
                        "content": "Transfers 0\\u202F\\u2192\\u202F0 and similar (i.e. within the same building) are all possible, independently of all other transfers. There are five of them.\\n\\nIf you exclude them, remaining are 2\\u202F\\u2192\\u202F0, 2\\u202F\\u2192\\u202F1, 0\\u202F\\u2192\\u202F1 (twice). Nobody wants to go to building 2, so transfers from 2 are impossible. If you exclude them, only two transfers 0\\u202F\\u2192\\u202F1 remain, also impossible."
                    },
                    {
                        "username": "woundweavr",
                        "content": "Always check constraints I guess.  Brute force ftw"
                    },
                    {
                        "username": "raghavgoel18",
                        "content": "how to know if constraints are enough for brute force?\\n"
                    },
                    {
                        "username": "vladpetric",
                        "content": "NP complete proof.\\n\\nI start with the Hamiltonian cycle in a directed graph. That problem is NP complete.\\n\\nStraightforward reduction from Hamiltonian cycle to this problem is as follows: We take the original graph, pass it as such to the current problem, and check if the response is equal to the number of vertices.  "
                    },
                    {
                        "username": "cecilia5",
                        "content": "The reduction is flawed.\\n\\nConsider this graph:\\n\\n`a -> b, b->a, c->d, d->c`. The number of requests satisfied is 4, the same as the number of vertices in the graph, but the graph has no hamiltonian cycle. Heck - it isn\\'t even connected!\\n\\nThe fact that this problem can be solved by min cost flow (a polynomial algorithm) sort of disprove the fact that it is NP complete\\n\\n\\n"
                    },
                    {
                        "username": "uavishal777",
                        "content": "I firstly thought its a graph question as just find the indegree and outdegree of nodes and count the transfers with zero resultant \\n"
                    },
                    {
                        "username": "Md_Atik",
                        "content": "meet in the middle technique. Beats 100%.\\nhttps://leetcode.com/problems/maximum-number-of-achievable-transfer-requests/solutions/3757645/beat-100-meet-in-the-middle/"
                    },
                    {
                        "username": "RisabhKedai",
                        "content": "Can we solve it using DFS ?\\n"
                    }
                ]
            },
            {
                "id": 1956182,
                "content": [
                    {
                        "username": "Cdr_Rjt",
                        "content": "can we solve this question , like number of nodes in cycle of a graph  \\n??\\n"
                    },
                    {
                        "username": "user1659Uk",
                        "content": "in example 1, if they would\\'ve removed request [2,0], then how could they explain the solution of the that tc ??"
                    },
                    {
                        "username": "Caydend",
                        "content": "why do we have to backtrack when using recursion?\\n"
                    },
                    {
                        "username": "feng3245",
                        "content": "Going from a set with back tracking to using iterators was 50 times faster if you don\\'t have to iterate the list from set... another thing TLE force feeds you..."
                    },
                    {
                        "username": "surYeah",
                        "content": "can we reduce this problem to maximum size of set with sum = 0 ; \\narray consists of out-in number of employees and then it can be solved by dp ? "
                    },
                    {
                        "username": "deCodeIt",
                        "content": "Try to think in terms of whether a request would be entertained or not and do backtracking for both cases.\\nTIP: When a request is to transfer in same building, you always include it in the count ( i.e. you can skip the backtracking path which excludes this request and it\\'ll save you a lot of time )"
                    },
                    {
                        "username": "zdptt",
                        "content": "Is there any way to solve this without using bruteforce/ bitmasking/ recursion for larger value of n and requests.length ?"
                    },
                    {
                        "username": "andrew99154",
                        "content": "This should be a medium problem, just normal backtracking."
                    },
                    {
                        "username": "Kunal19880711",
                        "content": "You got to be kidding me. It was a simple PnC question. I wasted a whole day over it to find it out. "
                    },
                    {
                        "username": "lolopat2",
                        "content": "Interested in a comprehensive Golang solution? I\\'ve crafted an Exhaustive Backtracking approach with detailed comments to help you understand the logic. Check it out here: https://leetcode.com/problems/maximum-number-of-achievable-transfer-requests/solutions/3708144/golang-solution-using-backtracking-with-state-balance-check-and-detailed-comments/"
                    }
                ]
            },
            {
                "id": 1954828,
                "content": [
                    {
                        "username": "Cdr_Rjt",
                        "content": "can we solve this question , like number of nodes in cycle of a graph  \\n??\\n"
                    },
                    {
                        "username": "user1659Uk",
                        "content": "in example 1, if they would\\'ve removed request [2,0], then how could they explain the solution of the that tc ??"
                    },
                    {
                        "username": "Caydend",
                        "content": "why do we have to backtrack when using recursion?\\n"
                    },
                    {
                        "username": "feng3245",
                        "content": "Going from a set with back tracking to using iterators was 50 times faster if you don\\'t have to iterate the list from set... another thing TLE force feeds you..."
                    },
                    {
                        "username": "surYeah",
                        "content": "can we reduce this problem to maximum size of set with sum = 0 ; \\narray consists of out-in number of employees and then it can be solved by dp ? "
                    },
                    {
                        "username": "deCodeIt",
                        "content": "Try to think in terms of whether a request would be entertained or not and do backtracking for both cases.\\nTIP: When a request is to transfer in same building, you always include it in the count ( i.e. you can skip the backtracking path which excludes this request and it\\'ll save you a lot of time )"
                    },
                    {
                        "username": "zdptt",
                        "content": "Is there any way to solve this without using bruteforce/ bitmasking/ recursion for larger value of n and requests.length ?"
                    },
                    {
                        "username": "andrew99154",
                        "content": "This should be a medium problem, just normal backtracking."
                    },
                    {
                        "username": "Kunal19880711",
                        "content": "You got to be kidding me. It was a simple PnC question. I wasted a whole day over it to find it out. "
                    },
                    {
                        "username": "lolopat2",
                        "content": "Interested in a comprehensive Golang solution? I\\'ve crafted an Exhaustive Backtracking approach with detailed comments to help you understand the logic. Check it out here: https://leetcode.com/problems/maximum-number-of-achievable-transfer-requests/solutions/3708144/golang-solution-using-backtracking-with-state-balance-check-and-detailed-comments/"
                    }
                ]
            },
            {
                "id": 1953865,
                "content": [
                    {
                        "username": "Cdr_Rjt",
                        "content": "can we solve this question , like number of nodes in cycle of a graph  \\n??\\n"
                    },
                    {
                        "username": "user1659Uk",
                        "content": "in example 1, if they would\\'ve removed request [2,0], then how could they explain the solution of the that tc ??"
                    },
                    {
                        "username": "Caydend",
                        "content": "why do we have to backtrack when using recursion?\\n"
                    },
                    {
                        "username": "feng3245",
                        "content": "Going from a set with back tracking to using iterators was 50 times faster if you don\\'t have to iterate the list from set... another thing TLE force feeds you..."
                    },
                    {
                        "username": "surYeah",
                        "content": "can we reduce this problem to maximum size of set with sum = 0 ; \\narray consists of out-in number of employees and then it can be solved by dp ? "
                    },
                    {
                        "username": "deCodeIt",
                        "content": "Try to think in terms of whether a request would be entertained or not and do backtracking for both cases.\\nTIP: When a request is to transfer in same building, you always include it in the count ( i.e. you can skip the backtracking path which excludes this request and it\\'ll save you a lot of time )"
                    },
                    {
                        "username": "zdptt",
                        "content": "Is there any way to solve this without using bruteforce/ bitmasking/ recursion for larger value of n and requests.length ?"
                    },
                    {
                        "username": "andrew99154",
                        "content": "This should be a medium problem, just normal backtracking."
                    },
                    {
                        "username": "Kunal19880711",
                        "content": "You got to be kidding me. It was a simple PnC question. I wasted a whole day over it to find it out. "
                    },
                    {
                        "username": "lolopat2",
                        "content": "Interested in a comprehensive Golang solution? I\\'ve crafted an Exhaustive Backtracking approach with detailed comments to help you understand the logic. Check it out here: https://leetcode.com/problems/maximum-number-of-achievable-transfer-requests/solutions/3708144/golang-solution-using-backtracking-with-state-balance-check-and-detailed-comments/"
                    }
                ]
            },
            {
                "id": 1953855,
                "content": [
                    {
                        "username": "Cdr_Rjt",
                        "content": "can we solve this question , like number of nodes in cycle of a graph  \\n??\\n"
                    },
                    {
                        "username": "user1659Uk",
                        "content": "in example 1, if they would\\'ve removed request [2,0], then how could they explain the solution of the that tc ??"
                    },
                    {
                        "username": "Caydend",
                        "content": "why do we have to backtrack when using recursion?\\n"
                    },
                    {
                        "username": "feng3245",
                        "content": "Going from a set with back tracking to using iterators was 50 times faster if you don\\'t have to iterate the list from set... another thing TLE force feeds you..."
                    },
                    {
                        "username": "surYeah",
                        "content": "can we reduce this problem to maximum size of set with sum = 0 ; \\narray consists of out-in number of employees and then it can be solved by dp ? "
                    },
                    {
                        "username": "deCodeIt",
                        "content": "Try to think in terms of whether a request would be entertained or not and do backtracking for both cases.\\nTIP: When a request is to transfer in same building, you always include it in the count ( i.e. you can skip the backtracking path which excludes this request and it\\'ll save you a lot of time )"
                    },
                    {
                        "username": "zdptt",
                        "content": "Is there any way to solve this without using bruteforce/ bitmasking/ recursion for larger value of n and requests.length ?"
                    },
                    {
                        "username": "andrew99154",
                        "content": "This should be a medium problem, just normal backtracking."
                    },
                    {
                        "username": "Kunal19880711",
                        "content": "You got to be kidding me. It was a simple PnC question. I wasted a whole day over it to find it out. "
                    },
                    {
                        "username": "lolopat2",
                        "content": "Interested in a comprehensive Golang solution? I\\'ve crafted an Exhaustive Backtracking approach with detailed comments to help you understand the logic. Check it out here: https://leetcode.com/problems/maximum-number-of-achievable-transfer-requests/solutions/3708144/golang-solution-using-backtracking-with-state-balance-check-and-detailed-comments/"
                    }
                ]
            },
            {
                "id": 1953682,
                "content": [
                    {
                        "username": "Cdr_Rjt",
                        "content": "can we solve this question , like number of nodes in cycle of a graph  \\n??\\n"
                    },
                    {
                        "username": "user1659Uk",
                        "content": "in example 1, if they would\\'ve removed request [2,0], then how could they explain the solution of the that tc ??"
                    },
                    {
                        "username": "Caydend",
                        "content": "why do we have to backtrack when using recursion?\\n"
                    },
                    {
                        "username": "feng3245",
                        "content": "Going from a set with back tracking to using iterators was 50 times faster if you don\\'t have to iterate the list from set... another thing TLE force feeds you..."
                    },
                    {
                        "username": "surYeah",
                        "content": "can we reduce this problem to maximum size of set with sum = 0 ; \\narray consists of out-in number of employees and then it can be solved by dp ? "
                    },
                    {
                        "username": "deCodeIt",
                        "content": "Try to think in terms of whether a request would be entertained or not and do backtracking for both cases.\\nTIP: When a request is to transfer in same building, you always include it in the count ( i.e. you can skip the backtracking path which excludes this request and it\\'ll save you a lot of time )"
                    },
                    {
                        "username": "zdptt",
                        "content": "Is there any way to solve this without using bruteforce/ bitmasking/ recursion for larger value of n and requests.length ?"
                    },
                    {
                        "username": "andrew99154",
                        "content": "This should be a medium problem, just normal backtracking."
                    },
                    {
                        "username": "Kunal19880711",
                        "content": "You got to be kidding me. It was a simple PnC question. I wasted a whole day over it to find it out. "
                    },
                    {
                        "username": "lolopat2",
                        "content": "Interested in a comprehensive Golang solution? I\\'ve crafted an Exhaustive Backtracking approach with detailed comments to help you understand the logic. Check it out here: https://leetcode.com/problems/maximum-number-of-achievable-transfer-requests/solutions/3708144/golang-solution-using-backtracking-with-state-balance-check-and-detailed-comments/"
                    }
                ]
            },
            {
                "id": 1953608,
                "content": [
                    {
                        "username": "Cdr_Rjt",
                        "content": "can we solve this question , like number of nodes in cycle of a graph  \\n??\\n"
                    },
                    {
                        "username": "user1659Uk",
                        "content": "in example 1, if they would\\'ve removed request [2,0], then how could they explain the solution of the that tc ??"
                    },
                    {
                        "username": "Caydend",
                        "content": "why do we have to backtrack when using recursion?\\n"
                    },
                    {
                        "username": "feng3245",
                        "content": "Going from a set with back tracking to using iterators was 50 times faster if you don\\'t have to iterate the list from set... another thing TLE force feeds you..."
                    },
                    {
                        "username": "surYeah",
                        "content": "can we reduce this problem to maximum size of set with sum = 0 ; \\narray consists of out-in number of employees and then it can be solved by dp ? "
                    },
                    {
                        "username": "deCodeIt",
                        "content": "Try to think in terms of whether a request would be entertained or not and do backtracking for both cases.\\nTIP: When a request is to transfer in same building, you always include it in the count ( i.e. you can skip the backtracking path which excludes this request and it\\'ll save you a lot of time )"
                    },
                    {
                        "username": "zdptt",
                        "content": "Is there any way to solve this without using bruteforce/ bitmasking/ recursion for larger value of n and requests.length ?"
                    },
                    {
                        "username": "andrew99154",
                        "content": "This should be a medium problem, just normal backtracking."
                    },
                    {
                        "username": "Kunal19880711",
                        "content": "You got to be kidding me. It was a simple PnC question. I wasted a whole day over it to find it out. "
                    },
                    {
                        "username": "lolopat2",
                        "content": "Interested in a comprehensive Golang solution? I\\'ve crafted an Exhaustive Backtracking approach with detailed comments to help you understand the logic. Check it out here: https://leetcode.com/problems/maximum-number-of-achievable-transfer-requests/solutions/3708144/golang-solution-using-backtracking-with-state-balance-check-and-detailed-comments/"
                    }
                ]
            },
            {
                "id": 1953484,
                "content": [
                    {
                        "username": "Cdr_Rjt",
                        "content": "can we solve this question , like number of nodes in cycle of a graph  \\n??\\n"
                    },
                    {
                        "username": "user1659Uk",
                        "content": "in example 1, if they would\\'ve removed request [2,0], then how could they explain the solution of the that tc ??"
                    },
                    {
                        "username": "Caydend",
                        "content": "why do we have to backtrack when using recursion?\\n"
                    },
                    {
                        "username": "feng3245",
                        "content": "Going from a set with back tracking to using iterators was 50 times faster if you don\\'t have to iterate the list from set... another thing TLE force feeds you..."
                    },
                    {
                        "username": "surYeah",
                        "content": "can we reduce this problem to maximum size of set with sum = 0 ; \\narray consists of out-in number of employees and then it can be solved by dp ? "
                    },
                    {
                        "username": "deCodeIt",
                        "content": "Try to think in terms of whether a request would be entertained or not and do backtracking for both cases.\\nTIP: When a request is to transfer in same building, you always include it in the count ( i.e. you can skip the backtracking path which excludes this request and it\\'ll save you a lot of time )"
                    },
                    {
                        "username": "zdptt",
                        "content": "Is there any way to solve this without using bruteforce/ bitmasking/ recursion for larger value of n and requests.length ?"
                    },
                    {
                        "username": "andrew99154",
                        "content": "This should be a medium problem, just normal backtracking."
                    },
                    {
                        "username": "Kunal19880711",
                        "content": "You got to be kidding me. It was a simple PnC question. I wasted a whole day over it to find it out. "
                    },
                    {
                        "username": "lolopat2",
                        "content": "Interested in a comprehensive Golang solution? I\\'ve crafted an Exhaustive Backtracking approach with detailed comments to help you understand the logic. Check it out here: https://leetcode.com/problems/maximum-number-of-achievable-transfer-requests/solutions/3708144/golang-solution-using-backtracking-with-state-balance-check-and-detailed-comments/"
                    }
                ]
            },
            {
                "id": 1953471,
                "content": [
                    {
                        "username": "Cdr_Rjt",
                        "content": "can we solve this question , like number of nodes in cycle of a graph  \\n??\\n"
                    },
                    {
                        "username": "user1659Uk",
                        "content": "in example 1, if they would\\'ve removed request [2,0], then how could they explain the solution of the that tc ??"
                    },
                    {
                        "username": "Caydend",
                        "content": "why do we have to backtrack when using recursion?\\n"
                    },
                    {
                        "username": "feng3245",
                        "content": "Going from a set with back tracking to using iterators was 50 times faster if you don\\'t have to iterate the list from set... another thing TLE force feeds you..."
                    },
                    {
                        "username": "surYeah",
                        "content": "can we reduce this problem to maximum size of set with sum = 0 ; \\narray consists of out-in number of employees and then it can be solved by dp ? "
                    },
                    {
                        "username": "deCodeIt",
                        "content": "Try to think in terms of whether a request would be entertained or not and do backtracking for both cases.\\nTIP: When a request is to transfer in same building, you always include it in the count ( i.e. you can skip the backtracking path which excludes this request and it\\'ll save you a lot of time )"
                    },
                    {
                        "username": "zdptt",
                        "content": "Is there any way to solve this without using bruteforce/ bitmasking/ recursion for larger value of n and requests.length ?"
                    },
                    {
                        "username": "andrew99154",
                        "content": "This should be a medium problem, just normal backtracking."
                    },
                    {
                        "username": "Kunal19880711",
                        "content": "You got to be kidding me. It was a simple PnC question. I wasted a whole day over it to find it out. "
                    },
                    {
                        "username": "lolopat2",
                        "content": "Interested in a comprehensive Golang solution? I\\'ve crafted an Exhaustive Backtracking approach with detailed comments to help you understand the logic. Check it out here: https://leetcode.com/problems/maximum-number-of-achievable-transfer-requests/solutions/3708144/golang-solution-using-backtracking-with-state-balance-check-and-detailed-comments/"
                    }
                ]
            },
            {
                "id": 1953441,
                "content": [
                    {
                        "username": "Cdr_Rjt",
                        "content": "can we solve this question , like number of nodes in cycle of a graph  \\n??\\n"
                    },
                    {
                        "username": "user1659Uk",
                        "content": "in example 1, if they would\\'ve removed request [2,0], then how could they explain the solution of the that tc ??"
                    },
                    {
                        "username": "Caydend",
                        "content": "why do we have to backtrack when using recursion?\\n"
                    },
                    {
                        "username": "feng3245",
                        "content": "Going from a set with back tracking to using iterators was 50 times faster if you don\\'t have to iterate the list from set... another thing TLE force feeds you..."
                    },
                    {
                        "username": "surYeah",
                        "content": "can we reduce this problem to maximum size of set with sum = 0 ; \\narray consists of out-in number of employees and then it can be solved by dp ? "
                    },
                    {
                        "username": "deCodeIt",
                        "content": "Try to think in terms of whether a request would be entertained or not and do backtracking for both cases.\\nTIP: When a request is to transfer in same building, you always include it in the count ( i.e. you can skip the backtracking path which excludes this request and it\\'ll save you a lot of time )"
                    },
                    {
                        "username": "zdptt",
                        "content": "Is there any way to solve this without using bruteforce/ bitmasking/ recursion for larger value of n and requests.length ?"
                    },
                    {
                        "username": "andrew99154",
                        "content": "This should be a medium problem, just normal backtracking."
                    },
                    {
                        "username": "Kunal19880711",
                        "content": "You got to be kidding me. It was a simple PnC question. I wasted a whole day over it to find it out. "
                    },
                    {
                        "username": "lolopat2",
                        "content": "Interested in a comprehensive Golang solution? I\\'ve crafted an Exhaustive Backtracking approach with detailed comments to help you understand the logic. Check it out here: https://leetcode.com/problems/maximum-number-of-achievable-transfer-requests/solutions/3708144/golang-solution-using-backtracking-with-state-balance-check-and-detailed-comments/"
                    }
                ]
            },
            {
                "id": 1953250,
                "content": [
                    {
                        "username": "Cdr_Rjt",
                        "content": "can we solve this question , like number of nodes in cycle of a graph  \\n??\\n"
                    },
                    {
                        "username": "user1659Uk",
                        "content": "in example 1, if they would\\'ve removed request [2,0], then how could they explain the solution of the that tc ??"
                    },
                    {
                        "username": "Caydend",
                        "content": "why do we have to backtrack when using recursion?\\n"
                    },
                    {
                        "username": "feng3245",
                        "content": "Going from a set with back tracking to using iterators was 50 times faster if you don\\'t have to iterate the list from set... another thing TLE force feeds you..."
                    },
                    {
                        "username": "surYeah",
                        "content": "can we reduce this problem to maximum size of set with sum = 0 ; \\narray consists of out-in number of employees and then it can be solved by dp ? "
                    },
                    {
                        "username": "deCodeIt",
                        "content": "Try to think in terms of whether a request would be entertained or not and do backtracking for both cases.\\nTIP: When a request is to transfer in same building, you always include it in the count ( i.e. you can skip the backtracking path which excludes this request and it\\'ll save you a lot of time )"
                    },
                    {
                        "username": "zdptt",
                        "content": "Is there any way to solve this without using bruteforce/ bitmasking/ recursion for larger value of n and requests.length ?"
                    },
                    {
                        "username": "andrew99154",
                        "content": "This should be a medium problem, just normal backtracking."
                    },
                    {
                        "username": "Kunal19880711",
                        "content": "You got to be kidding me. It was a simple PnC question. I wasted a whole day over it to find it out. "
                    },
                    {
                        "username": "lolopat2",
                        "content": "Interested in a comprehensive Golang solution? I\\'ve crafted an Exhaustive Backtracking approach with detailed comments to help you understand the logic. Check it out here: https://leetcode.com/problems/maximum-number-of-achievable-transfer-requests/solutions/3708144/golang-solution-using-backtracking-with-state-balance-check-and-detailed-comments/"
                    }
                ]
            },
            {
                "id": 1953171,
                "content": [
                    {
                        "username": "hoangdo_spm",
                        "content": "Why this test case has output is 3 instead of 4?\n `n = 5;\nrequests = [[0,1],[0,1],[1,2],[2,0],[3,4]];`\nI have think that both two first requests is accepted, but maybe just only one is accepted. Correct me if I am wrong, thanks so much!"
                    },
                    {
                        "username": "bparanj",
                        "content": "The main constraint for this problem is that every building should end up with the same number of employees as it started with. This means that for every employee that leaves a building, an employee must also enter that building.\\n\\nFor the given test case, if we accept both of the first two requests, we will end up with an imbalance in building 0. Two employees will leave building 0, but only one will return (from building 2). So we can\\'t accept both of the first two requests.\\n\\nHowever, we can accept one of the first two requests, along with the third and fourth requests. This gives us the following movement of employees:\\n\\n1. An employee moves from building 0 to building 1.\\n2. An employee moves from building 1 to building 2.\\n3. An employee moves from building 2 to building 0.\\n\\nNow, buildings 0, 1, and 2 all have the same number of employees as they started with, and we\\'ve fulfilled 3 requests. We can\\'t fulfill the fifth request without creating an imbalance, so the maximum number of requests we can fulfill is 3, not 4."
                    },
                    {
                        "username": "psionl0",
                        "content": "[0,1],[1,2],[2,0] form a cycle leaving [0,1],[3,4] which can\\'t be executed. Note that 2 people leave bldg 0 but only 1 returns."
                    },
                    {
                        "username": "kevinyou77",
                        "content": "I thought this question can be solved with graph until I saw the editorial\\u2026"
                    },
                    {
                        "username": "wafsinc",
                        "content": "It can be."
                    },
                    {
                        "username": "Jaiff",
                        "content": "LOL. Not hard at all. Thanks leetcode. I will now enjoy my sunday. "
                    },
                    {
                        "username": "lucasscodes",
                        "content": "Brute allowed and still hard?\nIs just reading the constraints and seeing brute complexity is possible already enough to be hard???"
                    },
                    {
                        "username": "psionl0",
                        "content": "This might be a \"hard\" problem if you use backtracking as suggested in the editorial but bitmasking makes this easy."
                    },
                    {
                        "username": "sharmakavya1002",
                        "content": "Can we please not get HARD PROBLEMS everyday? ; _ ;"
                    },
                    {
                        "username": "kumaraashish118",
                        "content": "Can anyone tell how there are 4 possible achievable requests in the following testcase?\n`n = 3`\n`requests = [[1,2],[1,2],[2,2],[0,2],[2,1],[1,1],[1,2]]`\n\nI'm confused and the only possible transfers I can see here are the self-transfers in a building i.e 2. Can anyone help with this one?\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "Let\\'s break down the movements we could make for each request:\\n\\n1. An employee moves from building 1 to building 2.\\n2. An employee moves from building 1 to building 2.\\n3. An employee stays in building 2 (self-transfer).\\n4. An employee moves from building 0 to building 2.\\n5. An employee moves from building 2 to building 1.\\n6. An employee stays in building 1 (self-transfer).\\n7. An employee moves from building 1 to building 2.\\n\\nIf we choose the 1st, 2nd, 5th, and 6th requests, we have the following movements:\\n\\n1. Employee moves from building 1 to building 2.\\n2. Employee moves from building 1 to building 2.\\n3. Employee moves from building 2 to building 1.\\n4. Employee stays in building 1 (self-transfer).\\n\\nNow, buildings 1 and 2 have the same number of employees as they started with. Building 0 didn\\'t change, so it\\'s still balanced. Therefore, we\\'ve fulfilled 4 requests, which is the maximum for this case.\\n\\nLet\\'s make a table to visualize this dataset. \\n\\nHere, for simplicity and better understanding, we\\'ll use \\'Initial\\' to represent the state of each building before any requests, and \\'Building 0\\', \\'Building 1\\' and \\'Building 2\\' to represent the states after each request. \\'Feasibility\\' column indicates whether each request is feasible (i.e., maintains the balance of people in/out of each building).\\n\\n| Request # | Movement | Building 0 | Building 1 | Building 2 | Feasibility |\\n|-----------|----------|------------|------------|------------|-------------|\\n|           | Initial  |      0     |      0     |      0     | N/A         |\\n|     1     | 1 -> 2   |      0     |     -1     |     +1     | To be determined |\\n|     2     | 1 -> 2   |      0     |     -2     |     +2     | To be determined |\\n|     3     | 2 -> 2   |      0     |     -2     |     +2     | Disregarded |\\n|     4     | 0 -> 2   |     -1     |     -2     |     +3     | To be determined |\\n|     5     | 2 -> 1   |     -1     |     -1     |     +2     | To be determined |\\n|     6     | 1 -> 1   |     -1     |      0     |     +2     | Disregarded |\\n|     7     | 1 -> 2   |     -1     |     -1     |     +3     | To be determined |\\n\\nIn this table, we can see the impact of each request on the state of each building. However, whether a request is feasible or not depends on the combination of requests chosen. For example, if we select request #1 and request #5, the total effect is 0 for each building, which means these requests are feasible. Therefore, the \\'Feasibility\\' column should be filled considering all possible combinations of requests.\\n\\nThe feasibility is calculated based on whether the total number of employees across all buildings remains constant:\\n\\n| Step | Description | Building 0 | Building 1 | Building 2 | Feasibility |\\n|------|-------------|------------|------------|------------|-------------|\\n| 0    | Initial     | 0          | 0          | 0          | n/a         |\\n| 1    | 1st request (1 -> 2) | 0  | -1         | +1         | (0+(-1)+1)=0 |\\n| 2    | 2nd request (1 -> 2) | 0  | -2         | +2         | (0+(-2)+2)=0 |\\n| 3    | 5th request (2 -> 1) | 0  | -1         | +1         | (0+(-1)+1)=0 |\\n| 4    | 6th request (1 -> 1) | 0  | -1         | +1         | (0+(-1)+1)=0 |\\n\\nThis shows that each step in this sequence of requests keeps the total number of employees constant, making all steps feasible. The feasibility of each step is calculated as the sum of changes in all buildings, and if this sum equals zero, then the step is feasible.\\n"
                    },
                    {
                        "username": "shiyao821",
                        "content": "I worked it out by hand and got 4. \\n`(2,2)` and  `(1,1)` are self-transfering\\n`(2,1)` and `(1, 2)` allows swapping. So 4 in total."
                    },
                    {
                        "username": "void_8t",
                        "content": "just check for every possible case, for every request, take it or don't take it, and keep count of requests taken till the end.\n\ncheck the status of the degree in end and  update the answer (max always).\n\n\n\n\n\n\n"
                    },
                    {
                        "username": "anand_083",
                        "content": "we also use math realation to solve this problem like if it is symmertric increment by count 2 or if it is transitive then and in normal by 1 else 0 ;\\nbut the problem is what if , if there are so many relation intersect each other then there is multiple answer  ??\\n"
                    },
                    {
                        "username": "omkarsk98",
                        "content": "maximum will always be one values"
                    },
                    {
                        "username": "wild_knight",
                        "content": "Is it only me or this was actually the easiest hard problem ?"
                    }
                ]
            },
            {
                "id": 1953138,
                "content": [
                    {
                        "username": "hoangdo_spm",
                        "content": "Why this test case has output is 3 instead of 4?\n `n = 5;\nrequests = [[0,1],[0,1],[1,2],[2,0],[3,4]];`\nI have think that both two first requests is accepted, but maybe just only one is accepted. Correct me if I am wrong, thanks so much!"
                    },
                    {
                        "username": "bparanj",
                        "content": "The main constraint for this problem is that every building should end up with the same number of employees as it started with. This means that for every employee that leaves a building, an employee must also enter that building.\\n\\nFor the given test case, if we accept both of the first two requests, we will end up with an imbalance in building 0. Two employees will leave building 0, but only one will return (from building 2). So we can\\'t accept both of the first two requests.\\n\\nHowever, we can accept one of the first two requests, along with the third and fourth requests. This gives us the following movement of employees:\\n\\n1. An employee moves from building 0 to building 1.\\n2. An employee moves from building 1 to building 2.\\n3. An employee moves from building 2 to building 0.\\n\\nNow, buildings 0, 1, and 2 all have the same number of employees as they started with, and we\\'ve fulfilled 3 requests. We can\\'t fulfill the fifth request without creating an imbalance, so the maximum number of requests we can fulfill is 3, not 4."
                    },
                    {
                        "username": "psionl0",
                        "content": "[0,1],[1,2],[2,0] form a cycle leaving [0,1],[3,4] which can\\'t be executed. Note that 2 people leave bldg 0 but only 1 returns."
                    },
                    {
                        "username": "kevinyou77",
                        "content": "I thought this question can be solved with graph until I saw the editorial\\u2026"
                    },
                    {
                        "username": "wafsinc",
                        "content": "It can be."
                    },
                    {
                        "username": "Jaiff",
                        "content": "LOL. Not hard at all. Thanks leetcode. I will now enjoy my sunday. "
                    },
                    {
                        "username": "lucasscodes",
                        "content": "Brute allowed and still hard?\nIs just reading the constraints and seeing brute complexity is possible already enough to be hard???"
                    },
                    {
                        "username": "psionl0",
                        "content": "This might be a \"hard\" problem if you use backtracking as suggested in the editorial but bitmasking makes this easy."
                    },
                    {
                        "username": "sharmakavya1002",
                        "content": "Can we please not get HARD PROBLEMS everyday? ; _ ;"
                    },
                    {
                        "username": "kumaraashish118",
                        "content": "Can anyone tell how there are 4 possible achievable requests in the following testcase?\n`n = 3`\n`requests = [[1,2],[1,2],[2,2],[0,2],[2,1],[1,1],[1,2]]`\n\nI'm confused and the only possible transfers I can see here are the self-transfers in a building i.e 2. Can anyone help with this one?\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "Let\\'s break down the movements we could make for each request:\\n\\n1. An employee moves from building 1 to building 2.\\n2. An employee moves from building 1 to building 2.\\n3. An employee stays in building 2 (self-transfer).\\n4. An employee moves from building 0 to building 2.\\n5. An employee moves from building 2 to building 1.\\n6. An employee stays in building 1 (self-transfer).\\n7. An employee moves from building 1 to building 2.\\n\\nIf we choose the 1st, 2nd, 5th, and 6th requests, we have the following movements:\\n\\n1. Employee moves from building 1 to building 2.\\n2. Employee moves from building 1 to building 2.\\n3. Employee moves from building 2 to building 1.\\n4. Employee stays in building 1 (self-transfer).\\n\\nNow, buildings 1 and 2 have the same number of employees as they started with. Building 0 didn\\'t change, so it\\'s still balanced. Therefore, we\\'ve fulfilled 4 requests, which is the maximum for this case.\\n\\nLet\\'s make a table to visualize this dataset. \\n\\nHere, for simplicity and better understanding, we\\'ll use \\'Initial\\' to represent the state of each building before any requests, and \\'Building 0\\', \\'Building 1\\' and \\'Building 2\\' to represent the states after each request. \\'Feasibility\\' column indicates whether each request is feasible (i.e., maintains the balance of people in/out of each building).\\n\\n| Request # | Movement | Building 0 | Building 1 | Building 2 | Feasibility |\\n|-----------|----------|------------|------------|------------|-------------|\\n|           | Initial  |      0     |      0     |      0     | N/A         |\\n|     1     | 1 -> 2   |      0     |     -1     |     +1     | To be determined |\\n|     2     | 1 -> 2   |      0     |     -2     |     +2     | To be determined |\\n|     3     | 2 -> 2   |      0     |     -2     |     +2     | Disregarded |\\n|     4     | 0 -> 2   |     -1     |     -2     |     +3     | To be determined |\\n|     5     | 2 -> 1   |     -1     |     -1     |     +2     | To be determined |\\n|     6     | 1 -> 1   |     -1     |      0     |     +2     | Disregarded |\\n|     7     | 1 -> 2   |     -1     |     -1     |     +3     | To be determined |\\n\\nIn this table, we can see the impact of each request on the state of each building. However, whether a request is feasible or not depends on the combination of requests chosen. For example, if we select request #1 and request #5, the total effect is 0 for each building, which means these requests are feasible. Therefore, the \\'Feasibility\\' column should be filled considering all possible combinations of requests.\\n\\nThe feasibility is calculated based on whether the total number of employees across all buildings remains constant:\\n\\n| Step | Description | Building 0 | Building 1 | Building 2 | Feasibility |\\n|------|-------------|------------|------------|------------|-------------|\\n| 0    | Initial     | 0          | 0          | 0          | n/a         |\\n| 1    | 1st request (1 -> 2) | 0  | -1         | +1         | (0+(-1)+1)=0 |\\n| 2    | 2nd request (1 -> 2) | 0  | -2         | +2         | (0+(-2)+2)=0 |\\n| 3    | 5th request (2 -> 1) | 0  | -1         | +1         | (0+(-1)+1)=0 |\\n| 4    | 6th request (1 -> 1) | 0  | -1         | +1         | (0+(-1)+1)=0 |\\n\\nThis shows that each step in this sequence of requests keeps the total number of employees constant, making all steps feasible. The feasibility of each step is calculated as the sum of changes in all buildings, and if this sum equals zero, then the step is feasible.\\n"
                    },
                    {
                        "username": "shiyao821",
                        "content": "I worked it out by hand and got 4. \\n`(2,2)` and  `(1,1)` are self-transfering\\n`(2,1)` and `(1, 2)` allows swapping. So 4 in total."
                    },
                    {
                        "username": "void_8t",
                        "content": "just check for every possible case, for every request, take it or don't take it, and keep count of requests taken till the end.\n\ncheck the status of the degree in end and  update the answer (max always).\n\n\n\n\n\n\n"
                    },
                    {
                        "username": "anand_083",
                        "content": "we also use math realation to solve this problem like if it is symmertric increment by count 2 or if it is transitive then and in normal by 1 else 0 ;\\nbut the problem is what if , if there are so many relation intersect each other then there is multiple answer  ??\\n"
                    },
                    {
                        "username": "omkarsk98",
                        "content": "maximum will always be one values"
                    },
                    {
                        "username": "wild_knight",
                        "content": "Is it only me or this was actually the easiest hard problem ?"
                    }
                ]
            },
            {
                "id": 1953116,
                "content": [
                    {
                        "username": "hoangdo_spm",
                        "content": "Why this test case has output is 3 instead of 4?\n `n = 5;\nrequests = [[0,1],[0,1],[1,2],[2,0],[3,4]];`\nI have think that both two first requests is accepted, but maybe just only one is accepted. Correct me if I am wrong, thanks so much!"
                    },
                    {
                        "username": "bparanj",
                        "content": "The main constraint for this problem is that every building should end up with the same number of employees as it started with. This means that for every employee that leaves a building, an employee must also enter that building.\\n\\nFor the given test case, if we accept both of the first two requests, we will end up with an imbalance in building 0. Two employees will leave building 0, but only one will return (from building 2). So we can\\'t accept both of the first two requests.\\n\\nHowever, we can accept one of the first two requests, along with the third and fourth requests. This gives us the following movement of employees:\\n\\n1. An employee moves from building 0 to building 1.\\n2. An employee moves from building 1 to building 2.\\n3. An employee moves from building 2 to building 0.\\n\\nNow, buildings 0, 1, and 2 all have the same number of employees as they started with, and we\\'ve fulfilled 3 requests. We can\\'t fulfill the fifth request without creating an imbalance, so the maximum number of requests we can fulfill is 3, not 4."
                    },
                    {
                        "username": "psionl0",
                        "content": "[0,1],[1,2],[2,0] form a cycle leaving [0,1],[3,4] which can\\'t be executed. Note that 2 people leave bldg 0 but only 1 returns."
                    },
                    {
                        "username": "kevinyou77",
                        "content": "I thought this question can be solved with graph until I saw the editorial\\u2026"
                    },
                    {
                        "username": "wafsinc",
                        "content": "It can be."
                    },
                    {
                        "username": "Jaiff",
                        "content": "LOL. Not hard at all. Thanks leetcode. I will now enjoy my sunday. "
                    },
                    {
                        "username": "lucasscodes",
                        "content": "Brute allowed and still hard?\nIs just reading the constraints and seeing brute complexity is possible already enough to be hard???"
                    },
                    {
                        "username": "psionl0",
                        "content": "This might be a \"hard\" problem if you use backtracking as suggested in the editorial but bitmasking makes this easy."
                    },
                    {
                        "username": "sharmakavya1002",
                        "content": "Can we please not get HARD PROBLEMS everyday? ; _ ;"
                    },
                    {
                        "username": "kumaraashish118",
                        "content": "Can anyone tell how there are 4 possible achievable requests in the following testcase?\n`n = 3`\n`requests = [[1,2],[1,2],[2,2],[0,2],[2,1],[1,1],[1,2]]`\n\nI'm confused and the only possible transfers I can see here are the self-transfers in a building i.e 2. Can anyone help with this one?\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "Let\\'s break down the movements we could make for each request:\\n\\n1. An employee moves from building 1 to building 2.\\n2. An employee moves from building 1 to building 2.\\n3. An employee stays in building 2 (self-transfer).\\n4. An employee moves from building 0 to building 2.\\n5. An employee moves from building 2 to building 1.\\n6. An employee stays in building 1 (self-transfer).\\n7. An employee moves from building 1 to building 2.\\n\\nIf we choose the 1st, 2nd, 5th, and 6th requests, we have the following movements:\\n\\n1. Employee moves from building 1 to building 2.\\n2. Employee moves from building 1 to building 2.\\n3. Employee moves from building 2 to building 1.\\n4. Employee stays in building 1 (self-transfer).\\n\\nNow, buildings 1 and 2 have the same number of employees as they started with. Building 0 didn\\'t change, so it\\'s still balanced. Therefore, we\\'ve fulfilled 4 requests, which is the maximum for this case.\\n\\nLet\\'s make a table to visualize this dataset. \\n\\nHere, for simplicity and better understanding, we\\'ll use \\'Initial\\' to represent the state of each building before any requests, and \\'Building 0\\', \\'Building 1\\' and \\'Building 2\\' to represent the states after each request. \\'Feasibility\\' column indicates whether each request is feasible (i.e., maintains the balance of people in/out of each building).\\n\\n| Request # | Movement | Building 0 | Building 1 | Building 2 | Feasibility |\\n|-----------|----------|------------|------------|------------|-------------|\\n|           | Initial  |      0     |      0     |      0     | N/A         |\\n|     1     | 1 -> 2   |      0     |     -1     |     +1     | To be determined |\\n|     2     | 1 -> 2   |      0     |     -2     |     +2     | To be determined |\\n|     3     | 2 -> 2   |      0     |     -2     |     +2     | Disregarded |\\n|     4     | 0 -> 2   |     -1     |     -2     |     +3     | To be determined |\\n|     5     | 2 -> 1   |     -1     |     -1     |     +2     | To be determined |\\n|     6     | 1 -> 1   |     -1     |      0     |     +2     | Disregarded |\\n|     7     | 1 -> 2   |     -1     |     -1     |     +3     | To be determined |\\n\\nIn this table, we can see the impact of each request on the state of each building. However, whether a request is feasible or not depends on the combination of requests chosen. For example, if we select request #1 and request #5, the total effect is 0 for each building, which means these requests are feasible. Therefore, the \\'Feasibility\\' column should be filled considering all possible combinations of requests.\\n\\nThe feasibility is calculated based on whether the total number of employees across all buildings remains constant:\\n\\n| Step | Description | Building 0 | Building 1 | Building 2 | Feasibility |\\n|------|-------------|------------|------------|------------|-------------|\\n| 0    | Initial     | 0          | 0          | 0          | n/a         |\\n| 1    | 1st request (1 -> 2) | 0  | -1         | +1         | (0+(-1)+1)=0 |\\n| 2    | 2nd request (1 -> 2) | 0  | -2         | +2         | (0+(-2)+2)=0 |\\n| 3    | 5th request (2 -> 1) | 0  | -1         | +1         | (0+(-1)+1)=0 |\\n| 4    | 6th request (1 -> 1) | 0  | -1         | +1         | (0+(-1)+1)=0 |\\n\\nThis shows that each step in this sequence of requests keeps the total number of employees constant, making all steps feasible. The feasibility of each step is calculated as the sum of changes in all buildings, and if this sum equals zero, then the step is feasible.\\n"
                    },
                    {
                        "username": "shiyao821",
                        "content": "I worked it out by hand and got 4. \\n`(2,2)` and  `(1,1)` are self-transfering\\n`(2,1)` and `(1, 2)` allows swapping. So 4 in total."
                    },
                    {
                        "username": "void_8t",
                        "content": "just check for every possible case, for every request, take it or don't take it, and keep count of requests taken till the end.\n\ncheck the status of the degree in end and  update the answer (max always).\n\n\n\n\n\n\n"
                    },
                    {
                        "username": "anand_083",
                        "content": "we also use math realation to solve this problem like if it is symmertric increment by count 2 or if it is transitive then and in normal by 1 else 0 ;\\nbut the problem is what if , if there are so many relation intersect each other then there is multiple answer  ??\\n"
                    },
                    {
                        "username": "omkarsk98",
                        "content": "maximum will always be one values"
                    },
                    {
                        "username": "wild_knight",
                        "content": "Is it only me or this was actually the easiest hard problem ?"
                    }
                ]
            },
            {
                "id": 1953099,
                "content": [
                    {
                        "username": "hoangdo_spm",
                        "content": "Why this test case has output is 3 instead of 4?\n `n = 5;\nrequests = [[0,1],[0,1],[1,2],[2,0],[3,4]];`\nI have think that both two first requests is accepted, but maybe just only one is accepted. Correct me if I am wrong, thanks so much!"
                    },
                    {
                        "username": "bparanj",
                        "content": "The main constraint for this problem is that every building should end up with the same number of employees as it started with. This means that for every employee that leaves a building, an employee must also enter that building.\\n\\nFor the given test case, if we accept both of the first two requests, we will end up with an imbalance in building 0. Two employees will leave building 0, but only one will return (from building 2). So we can\\'t accept both of the first two requests.\\n\\nHowever, we can accept one of the first two requests, along with the third and fourth requests. This gives us the following movement of employees:\\n\\n1. An employee moves from building 0 to building 1.\\n2. An employee moves from building 1 to building 2.\\n3. An employee moves from building 2 to building 0.\\n\\nNow, buildings 0, 1, and 2 all have the same number of employees as they started with, and we\\'ve fulfilled 3 requests. We can\\'t fulfill the fifth request without creating an imbalance, so the maximum number of requests we can fulfill is 3, not 4."
                    },
                    {
                        "username": "psionl0",
                        "content": "[0,1],[1,2],[2,0] form a cycle leaving [0,1],[3,4] which can\\'t be executed. Note that 2 people leave bldg 0 but only 1 returns."
                    },
                    {
                        "username": "kevinyou77",
                        "content": "I thought this question can be solved with graph until I saw the editorial\\u2026"
                    },
                    {
                        "username": "wafsinc",
                        "content": "It can be."
                    },
                    {
                        "username": "Jaiff",
                        "content": "LOL. Not hard at all. Thanks leetcode. I will now enjoy my sunday. "
                    },
                    {
                        "username": "lucasscodes",
                        "content": "Brute allowed and still hard?\nIs just reading the constraints and seeing brute complexity is possible already enough to be hard???"
                    },
                    {
                        "username": "psionl0",
                        "content": "This might be a \"hard\" problem if you use backtracking as suggested in the editorial but bitmasking makes this easy."
                    },
                    {
                        "username": "sharmakavya1002",
                        "content": "Can we please not get HARD PROBLEMS everyday? ; _ ;"
                    },
                    {
                        "username": "kumaraashish118",
                        "content": "Can anyone tell how there are 4 possible achievable requests in the following testcase?\n`n = 3`\n`requests = [[1,2],[1,2],[2,2],[0,2],[2,1],[1,1],[1,2]]`\n\nI'm confused and the only possible transfers I can see here are the self-transfers in a building i.e 2. Can anyone help with this one?\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "Let\\'s break down the movements we could make for each request:\\n\\n1. An employee moves from building 1 to building 2.\\n2. An employee moves from building 1 to building 2.\\n3. An employee stays in building 2 (self-transfer).\\n4. An employee moves from building 0 to building 2.\\n5. An employee moves from building 2 to building 1.\\n6. An employee stays in building 1 (self-transfer).\\n7. An employee moves from building 1 to building 2.\\n\\nIf we choose the 1st, 2nd, 5th, and 6th requests, we have the following movements:\\n\\n1. Employee moves from building 1 to building 2.\\n2. Employee moves from building 1 to building 2.\\n3. Employee moves from building 2 to building 1.\\n4. Employee stays in building 1 (self-transfer).\\n\\nNow, buildings 1 and 2 have the same number of employees as they started with. Building 0 didn\\'t change, so it\\'s still balanced. Therefore, we\\'ve fulfilled 4 requests, which is the maximum for this case.\\n\\nLet\\'s make a table to visualize this dataset. \\n\\nHere, for simplicity and better understanding, we\\'ll use \\'Initial\\' to represent the state of each building before any requests, and \\'Building 0\\', \\'Building 1\\' and \\'Building 2\\' to represent the states after each request. \\'Feasibility\\' column indicates whether each request is feasible (i.e., maintains the balance of people in/out of each building).\\n\\n| Request # | Movement | Building 0 | Building 1 | Building 2 | Feasibility |\\n|-----------|----------|------------|------------|------------|-------------|\\n|           | Initial  |      0     |      0     |      0     | N/A         |\\n|     1     | 1 -> 2   |      0     |     -1     |     +1     | To be determined |\\n|     2     | 1 -> 2   |      0     |     -2     |     +2     | To be determined |\\n|     3     | 2 -> 2   |      0     |     -2     |     +2     | Disregarded |\\n|     4     | 0 -> 2   |     -1     |     -2     |     +3     | To be determined |\\n|     5     | 2 -> 1   |     -1     |     -1     |     +2     | To be determined |\\n|     6     | 1 -> 1   |     -1     |      0     |     +2     | Disregarded |\\n|     7     | 1 -> 2   |     -1     |     -1     |     +3     | To be determined |\\n\\nIn this table, we can see the impact of each request on the state of each building. However, whether a request is feasible or not depends on the combination of requests chosen. For example, if we select request #1 and request #5, the total effect is 0 for each building, which means these requests are feasible. Therefore, the \\'Feasibility\\' column should be filled considering all possible combinations of requests.\\n\\nThe feasibility is calculated based on whether the total number of employees across all buildings remains constant:\\n\\n| Step | Description | Building 0 | Building 1 | Building 2 | Feasibility |\\n|------|-------------|------------|------------|------------|-------------|\\n| 0    | Initial     | 0          | 0          | 0          | n/a         |\\n| 1    | 1st request (1 -> 2) | 0  | -1         | +1         | (0+(-1)+1)=0 |\\n| 2    | 2nd request (1 -> 2) | 0  | -2         | +2         | (0+(-2)+2)=0 |\\n| 3    | 5th request (2 -> 1) | 0  | -1         | +1         | (0+(-1)+1)=0 |\\n| 4    | 6th request (1 -> 1) | 0  | -1         | +1         | (0+(-1)+1)=0 |\\n\\nThis shows that each step in this sequence of requests keeps the total number of employees constant, making all steps feasible. The feasibility of each step is calculated as the sum of changes in all buildings, and if this sum equals zero, then the step is feasible.\\n"
                    },
                    {
                        "username": "shiyao821",
                        "content": "I worked it out by hand and got 4. \\n`(2,2)` and  `(1,1)` are self-transfering\\n`(2,1)` and `(1, 2)` allows swapping. So 4 in total."
                    },
                    {
                        "username": "void_8t",
                        "content": "just check for every possible case, for every request, take it or don't take it, and keep count of requests taken till the end.\n\ncheck the status of the degree in end and  update the answer (max always).\n\n\n\n\n\n\n"
                    },
                    {
                        "username": "anand_083",
                        "content": "we also use math realation to solve this problem like if it is symmertric increment by count 2 or if it is transitive then and in normal by 1 else 0 ;\\nbut the problem is what if , if there are so many relation intersect each other then there is multiple answer  ??\\n"
                    },
                    {
                        "username": "omkarsk98",
                        "content": "maximum will always be one values"
                    },
                    {
                        "username": "wild_knight",
                        "content": "Is it only me or this was actually the easiest hard problem ?"
                    }
                ]
            },
            {
                "id": 1953091,
                "content": [
                    {
                        "username": "hoangdo_spm",
                        "content": "Why this test case has output is 3 instead of 4?\n `n = 5;\nrequests = [[0,1],[0,1],[1,2],[2,0],[3,4]];`\nI have think that both two first requests is accepted, but maybe just only one is accepted. Correct me if I am wrong, thanks so much!"
                    },
                    {
                        "username": "bparanj",
                        "content": "The main constraint for this problem is that every building should end up with the same number of employees as it started with. This means that for every employee that leaves a building, an employee must also enter that building.\\n\\nFor the given test case, if we accept both of the first two requests, we will end up with an imbalance in building 0. Two employees will leave building 0, but only one will return (from building 2). So we can\\'t accept both of the first two requests.\\n\\nHowever, we can accept one of the first two requests, along with the third and fourth requests. This gives us the following movement of employees:\\n\\n1. An employee moves from building 0 to building 1.\\n2. An employee moves from building 1 to building 2.\\n3. An employee moves from building 2 to building 0.\\n\\nNow, buildings 0, 1, and 2 all have the same number of employees as they started with, and we\\'ve fulfilled 3 requests. We can\\'t fulfill the fifth request without creating an imbalance, so the maximum number of requests we can fulfill is 3, not 4."
                    },
                    {
                        "username": "psionl0",
                        "content": "[0,1],[1,2],[2,0] form a cycle leaving [0,1],[3,4] which can\\'t be executed. Note that 2 people leave bldg 0 but only 1 returns."
                    },
                    {
                        "username": "kevinyou77",
                        "content": "I thought this question can be solved with graph until I saw the editorial\\u2026"
                    },
                    {
                        "username": "wafsinc",
                        "content": "It can be."
                    },
                    {
                        "username": "Jaiff",
                        "content": "LOL. Not hard at all. Thanks leetcode. I will now enjoy my sunday. "
                    },
                    {
                        "username": "lucasscodes",
                        "content": "Brute allowed and still hard?\nIs just reading the constraints and seeing brute complexity is possible already enough to be hard???"
                    },
                    {
                        "username": "psionl0",
                        "content": "This might be a \"hard\" problem if you use backtracking as suggested in the editorial but bitmasking makes this easy."
                    },
                    {
                        "username": "sharmakavya1002",
                        "content": "Can we please not get HARD PROBLEMS everyday? ; _ ;"
                    },
                    {
                        "username": "kumaraashish118",
                        "content": "Can anyone tell how there are 4 possible achievable requests in the following testcase?\n`n = 3`\n`requests = [[1,2],[1,2],[2,2],[0,2],[2,1],[1,1],[1,2]]`\n\nI'm confused and the only possible transfers I can see here are the self-transfers in a building i.e 2. Can anyone help with this one?\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "Let\\'s break down the movements we could make for each request:\\n\\n1. An employee moves from building 1 to building 2.\\n2. An employee moves from building 1 to building 2.\\n3. An employee stays in building 2 (self-transfer).\\n4. An employee moves from building 0 to building 2.\\n5. An employee moves from building 2 to building 1.\\n6. An employee stays in building 1 (self-transfer).\\n7. An employee moves from building 1 to building 2.\\n\\nIf we choose the 1st, 2nd, 5th, and 6th requests, we have the following movements:\\n\\n1. Employee moves from building 1 to building 2.\\n2. Employee moves from building 1 to building 2.\\n3. Employee moves from building 2 to building 1.\\n4. Employee stays in building 1 (self-transfer).\\n\\nNow, buildings 1 and 2 have the same number of employees as they started with. Building 0 didn\\'t change, so it\\'s still balanced. Therefore, we\\'ve fulfilled 4 requests, which is the maximum for this case.\\n\\nLet\\'s make a table to visualize this dataset. \\n\\nHere, for simplicity and better understanding, we\\'ll use \\'Initial\\' to represent the state of each building before any requests, and \\'Building 0\\', \\'Building 1\\' and \\'Building 2\\' to represent the states after each request. \\'Feasibility\\' column indicates whether each request is feasible (i.e., maintains the balance of people in/out of each building).\\n\\n| Request # | Movement | Building 0 | Building 1 | Building 2 | Feasibility |\\n|-----------|----------|------------|------------|------------|-------------|\\n|           | Initial  |      0     |      0     |      0     | N/A         |\\n|     1     | 1 -> 2   |      0     |     -1     |     +1     | To be determined |\\n|     2     | 1 -> 2   |      0     |     -2     |     +2     | To be determined |\\n|     3     | 2 -> 2   |      0     |     -2     |     +2     | Disregarded |\\n|     4     | 0 -> 2   |     -1     |     -2     |     +3     | To be determined |\\n|     5     | 2 -> 1   |     -1     |     -1     |     +2     | To be determined |\\n|     6     | 1 -> 1   |     -1     |      0     |     +2     | Disregarded |\\n|     7     | 1 -> 2   |     -1     |     -1     |     +3     | To be determined |\\n\\nIn this table, we can see the impact of each request on the state of each building. However, whether a request is feasible or not depends on the combination of requests chosen. For example, if we select request #1 and request #5, the total effect is 0 for each building, which means these requests are feasible. Therefore, the \\'Feasibility\\' column should be filled considering all possible combinations of requests.\\n\\nThe feasibility is calculated based on whether the total number of employees across all buildings remains constant:\\n\\n| Step | Description | Building 0 | Building 1 | Building 2 | Feasibility |\\n|------|-------------|------------|------------|------------|-------------|\\n| 0    | Initial     | 0          | 0          | 0          | n/a         |\\n| 1    | 1st request (1 -> 2) | 0  | -1         | +1         | (0+(-1)+1)=0 |\\n| 2    | 2nd request (1 -> 2) | 0  | -2         | +2         | (0+(-2)+2)=0 |\\n| 3    | 5th request (2 -> 1) | 0  | -1         | +1         | (0+(-1)+1)=0 |\\n| 4    | 6th request (1 -> 1) | 0  | -1         | +1         | (0+(-1)+1)=0 |\\n\\nThis shows that each step in this sequence of requests keeps the total number of employees constant, making all steps feasible. The feasibility of each step is calculated as the sum of changes in all buildings, and if this sum equals zero, then the step is feasible.\\n"
                    },
                    {
                        "username": "shiyao821",
                        "content": "I worked it out by hand and got 4. \\n`(2,2)` and  `(1,1)` are self-transfering\\n`(2,1)` and `(1, 2)` allows swapping. So 4 in total."
                    },
                    {
                        "username": "void_8t",
                        "content": "just check for every possible case, for every request, take it or don't take it, and keep count of requests taken till the end.\n\ncheck the status of the degree in end and  update the answer (max always).\n\n\n\n\n\n\n"
                    },
                    {
                        "username": "anand_083",
                        "content": "we also use math realation to solve this problem like if it is symmertric increment by count 2 or if it is transitive then and in normal by 1 else 0 ;\\nbut the problem is what if , if there are so many relation intersect each other then there is multiple answer  ??\\n"
                    },
                    {
                        "username": "omkarsk98",
                        "content": "maximum will always be one values"
                    },
                    {
                        "username": "wild_knight",
                        "content": "Is it only me or this was actually the easiest hard problem ?"
                    }
                ]
            },
            {
                "id": 1953085,
                "content": [
                    {
                        "username": "hoangdo_spm",
                        "content": "Why this test case has output is 3 instead of 4?\n `n = 5;\nrequests = [[0,1],[0,1],[1,2],[2,0],[3,4]];`\nI have think that both two first requests is accepted, but maybe just only one is accepted. Correct me if I am wrong, thanks so much!"
                    },
                    {
                        "username": "bparanj",
                        "content": "The main constraint for this problem is that every building should end up with the same number of employees as it started with. This means that for every employee that leaves a building, an employee must also enter that building.\\n\\nFor the given test case, if we accept both of the first two requests, we will end up with an imbalance in building 0. Two employees will leave building 0, but only one will return (from building 2). So we can\\'t accept both of the first two requests.\\n\\nHowever, we can accept one of the first two requests, along with the third and fourth requests. This gives us the following movement of employees:\\n\\n1. An employee moves from building 0 to building 1.\\n2. An employee moves from building 1 to building 2.\\n3. An employee moves from building 2 to building 0.\\n\\nNow, buildings 0, 1, and 2 all have the same number of employees as they started with, and we\\'ve fulfilled 3 requests. We can\\'t fulfill the fifth request without creating an imbalance, so the maximum number of requests we can fulfill is 3, not 4."
                    },
                    {
                        "username": "psionl0",
                        "content": "[0,1],[1,2],[2,0] form a cycle leaving [0,1],[3,4] which can\\'t be executed. Note that 2 people leave bldg 0 but only 1 returns."
                    },
                    {
                        "username": "kevinyou77",
                        "content": "I thought this question can be solved with graph until I saw the editorial\\u2026"
                    },
                    {
                        "username": "wafsinc",
                        "content": "It can be."
                    },
                    {
                        "username": "Jaiff",
                        "content": "LOL. Not hard at all. Thanks leetcode. I will now enjoy my sunday. "
                    },
                    {
                        "username": "lucasscodes",
                        "content": "Brute allowed and still hard?\nIs just reading the constraints and seeing brute complexity is possible already enough to be hard???"
                    },
                    {
                        "username": "psionl0",
                        "content": "This might be a \"hard\" problem if you use backtracking as suggested in the editorial but bitmasking makes this easy."
                    },
                    {
                        "username": "sharmakavya1002",
                        "content": "Can we please not get HARD PROBLEMS everyday? ; _ ;"
                    },
                    {
                        "username": "kumaraashish118",
                        "content": "Can anyone tell how there are 4 possible achievable requests in the following testcase?\n`n = 3`\n`requests = [[1,2],[1,2],[2,2],[0,2],[2,1],[1,1],[1,2]]`\n\nI'm confused and the only possible transfers I can see here are the self-transfers in a building i.e 2. Can anyone help with this one?\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "Let\\'s break down the movements we could make for each request:\\n\\n1. An employee moves from building 1 to building 2.\\n2. An employee moves from building 1 to building 2.\\n3. An employee stays in building 2 (self-transfer).\\n4. An employee moves from building 0 to building 2.\\n5. An employee moves from building 2 to building 1.\\n6. An employee stays in building 1 (self-transfer).\\n7. An employee moves from building 1 to building 2.\\n\\nIf we choose the 1st, 2nd, 5th, and 6th requests, we have the following movements:\\n\\n1. Employee moves from building 1 to building 2.\\n2. Employee moves from building 1 to building 2.\\n3. Employee moves from building 2 to building 1.\\n4. Employee stays in building 1 (self-transfer).\\n\\nNow, buildings 1 and 2 have the same number of employees as they started with. Building 0 didn\\'t change, so it\\'s still balanced. Therefore, we\\'ve fulfilled 4 requests, which is the maximum for this case.\\n\\nLet\\'s make a table to visualize this dataset. \\n\\nHere, for simplicity and better understanding, we\\'ll use \\'Initial\\' to represent the state of each building before any requests, and \\'Building 0\\', \\'Building 1\\' and \\'Building 2\\' to represent the states after each request. \\'Feasibility\\' column indicates whether each request is feasible (i.e., maintains the balance of people in/out of each building).\\n\\n| Request # | Movement | Building 0 | Building 1 | Building 2 | Feasibility |\\n|-----------|----------|------------|------------|------------|-------------|\\n|           | Initial  |      0     |      0     |      0     | N/A         |\\n|     1     | 1 -> 2   |      0     |     -1     |     +1     | To be determined |\\n|     2     | 1 -> 2   |      0     |     -2     |     +2     | To be determined |\\n|     3     | 2 -> 2   |      0     |     -2     |     +2     | Disregarded |\\n|     4     | 0 -> 2   |     -1     |     -2     |     +3     | To be determined |\\n|     5     | 2 -> 1   |     -1     |     -1     |     +2     | To be determined |\\n|     6     | 1 -> 1   |     -1     |      0     |     +2     | Disregarded |\\n|     7     | 1 -> 2   |     -1     |     -1     |     +3     | To be determined |\\n\\nIn this table, we can see the impact of each request on the state of each building. However, whether a request is feasible or not depends on the combination of requests chosen. For example, if we select request #1 and request #5, the total effect is 0 for each building, which means these requests are feasible. Therefore, the \\'Feasibility\\' column should be filled considering all possible combinations of requests.\\n\\nThe feasibility is calculated based on whether the total number of employees across all buildings remains constant:\\n\\n| Step | Description | Building 0 | Building 1 | Building 2 | Feasibility |\\n|------|-------------|------------|------------|------------|-------------|\\n| 0    | Initial     | 0          | 0          | 0          | n/a         |\\n| 1    | 1st request (1 -> 2) | 0  | -1         | +1         | (0+(-1)+1)=0 |\\n| 2    | 2nd request (1 -> 2) | 0  | -2         | +2         | (0+(-2)+2)=0 |\\n| 3    | 5th request (2 -> 1) | 0  | -1         | +1         | (0+(-1)+1)=0 |\\n| 4    | 6th request (1 -> 1) | 0  | -1         | +1         | (0+(-1)+1)=0 |\\n\\nThis shows that each step in this sequence of requests keeps the total number of employees constant, making all steps feasible. The feasibility of each step is calculated as the sum of changes in all buildings, and if this sum equals zero, then the step is feasible.\\n"
                    },
                    {
                        "username": "shiyao821",
                        "content": "I worked it out by hand and got 4. \\n`(2,2)` and  `(1,1)` are self-transfering\\n`(2,1)` and `(1, 2)` allows swapping. So 4 in total."
                    },
                    {
                        "username": "void_8t",
                        "content": "just check for every possible case, for every request, take it or don't take it, and keep count of requests taken till the end.\n\ncheck the status of the degree in end and  update the answer (max always).\n\n\n\n\n\n\n"
                    },
                    {
                        "username": "anand_083",
                        "content": "we also use math realation to solve this problem like if it is symmertric increment by count 2 or if it is transitive then and in normal by 1 else 0 ;\\nbut the problem is what if , if there are so many relation intersect each other then there is multiple answer  ??\\n"
                    },
                    {
                        "username": "omkarsk98",
                        "content": "maximum will always be one values"
                    },
                    {
                        "username": "wild_knight",
                        "content": "Is it only me or this was actually the easiest hard problem ?"
                    }
                ]
            },
            {
                "id": 1953054,
                "content": [
                    {
                        "username": "hoangdo_spm",
                        "content": "Why this test case has output is 3 instead of 4?\n `n = 5;\nrequests = [[0,1],[0,1],[1,2],[2,0],[3,4]];`\nI have think that both two first requests is accepted, but maybe just only one is accepted. Correct me if I am wrong, thanks so much!"
                    },
                    {
                        "username": "bparanj",
                        "content": "The main constraint for this problem is that every building should end up with the same number of employees as it started with. This means that for every employee that leaves a building, an employee must also enter that building.\\n\\nFor the given test case, if we accept both of the first two requests, we will end up with an imbalance in building 0. Two employees will leave building 0, but only one will return (from building 2). So we can\\'t accept both of the first two requests.\\n\\nHowever, we can accept one of the first two requests, along with the third and fourth requests. This gives us the following movement of employees:\\n\\n1. An employee moves from building 0 to building 1.\\n2. An employee moves from building 1 to building 2.\\n3. An employee moves from building 2 to building 0.\\n\\nNow, buildings 0, 1, and 2 all have the same number of employees as they started with, and we\\'ve fulfilled 3 requests. We can\\'t fulfill the fifth request without creating an imbalance, so the maximum number of requests we can fulfill is 3, not 4."
                    },
                    {
                        "username": "psionl0",
                        "content": "[0,1],[1,2],[2,0] form a cycle leaving [0,1],[3,4] which can\\'t be executed. Note that 2 people leave bldg 0 but only 1 returns."
                    },
                    {
                        "username": "kevinyou77",
                        "content": "I thought this question can be solved with graph until I saw the editorial\\u2026"
                    },
                    {
                        "username": "wafsinc",
                        "content": "It can be."
                    },
                    {
                        "username": "Jaiff",
                        "content": "LOL. Not hard at all. Thanks leetcode. I will now enjoy my sunday. "
                    },
                    {
                        "username": "lucasscodes",
                        "content": "Brute allowed and still hard?\nIs just reading the constraints and seeing brute complexity is possible already enough to be hard???"
                    },
                    {
                        "username": "psionl0",
                        "content": "This might be a \"hard\" problem if you use backtracking as suggested in the editorial but bitmasking makes this easy."
                    },
                    {
                        "username": "sharmakavya1002",
                        "content": "Can we please not get HARD PROBLEMS everyday? ; _ ;"
                    },
                    {
                        "username": "kumaraashish118",
                        "content": "Can anyone tell how there are 4 possible achievable requests in the following testcase?\n`n = 3`\n`requests = [[1,2],[1,2],[2,2],[0,2],[2,1],[1,1],[1,2]]`\n\nI'm confused and the only possible transfers I can see here are the self-transfers in a building i.e 2. Can anyone help with this one?\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "Let\\'s break down the movements we could make for each request:\\n\\n1. An employee moves from building 1 to building 2.\\n2. An employee moves from building 1 to building 2.\\n3. An employee stays in building 2 (self-transfer).\\n4. An employee moves from building 0 to building 2.\\n5. An employee moves from building 2 to building 1.\\n6. An employee stays in building 1 (self-transfer).\\n7. An employee moves from building 1 to building 2.\\n\\nIf we choose the 1st, 2nd, 5th, and 6th requests, we have the following movements:\\n\\n1. Employee moves from building 1 to building 2.\\n2. Employee moves from building 1 to building 2.\\n3. Employee moves from building 2 to building 1.\\n4. Employee stays in building 1 (self-transfer).\\n\\nNow, buildings 1 and 2 have the same number of employees as they started with. Building 0 didn\\'t change, so it\\'s still balanced. Therefore, we\\'ve fulfilled 4 requests, which is the maximum for this case.\\n\\nLet\\'s make a table to visualize this dataset. \\n\\nHere, for simplicity and better understanding, we\\'ll use \\'Initial\\' to represent the state of each building before any requests, and \\'Building 0\\', \\'Building 1\\' and \\'Building 2\\' to represent the states after each request. \\'Feasibility\\' column indicates whether each request is feasible (i.e., maintains the balance of people in/out of each building).\\n\\n| Request # | Movement | Building 0 | Building 1 | Building 2 | Feasibility |\\n|-----------|----------|------------|------------|------------|-------------|\\n|           | Initial  |      0     |      0     |      0     | N/A         |\\n|     1     | 1 -> 2   |      0     |     -1     |     +1     | To be determined |\\n|     2     | 1 -> 2   |      0     |     -2     |     +2     | To be determined |\\n|     3     | 2 -> 2   |      0     |     -2     |     +2     | Disregarded |\\n|     4     | 0 -> 2   |     -1     |     -2     |     +3     | To be determined |\\n|     5     | 2 -> 1   |     -1     |     -1     |     +2     | To be determined |\\n|     6     | 1 -> 1   |     -1     |      0     |     +2     | Disregarded |\\n|     7     | 1 -> 2   |     -1     |     -1     |     +3     | To be determined |\\n\\nIn this table, we can see the impact of each request on the state of each building. However, whether a request is feasible or not depends on the combination of requests chosen. For example, if we select request #1 and request #5, the total effect is 0 for each building, which means these requests are feasible. Therefore, the \\'Feasibility\\' column should be filled considering all possible combinations of requests.\\n\\nThe feasibility is calculated based on whether the total number of employees across all buildings remains constant:\\n\\n| Step | Description | Building 0 | Building 1 | Building 2 | Feasibility |\\n|------|-------------|------------|------------|------------|-------------|\\n| 0    | Initial     | 0          | 0          | 0          | n/a         |\\n| 1    | 1st request (1 -> 2) | 0  | -1         | +1         | (0+(-1)+1)=0 |\\n| 2    | 2nd request (1 -> 2) | 0  | -2         | +2         | (0+(-2)+2)=0 |\\n| 3    | 5th request (2 -> 1) | 0  | -1         | +1         | (0+(-1)+1)=0 |\\n| 4    | 6th request (1 -> 1) | 0  | -1         | +1         | (0+(-1)+1)=0 |\\n\\nThis shows that each step in this sequence of requests keeps the total number of employees constant, making all steps feasible. The feasibility of each step is calculated as the sum of changes in all buildings, and if this sum equals zero, then the step is feasible.\\n"
                    },
                    {
                        "username": "shiyao821",
                        "content": "I worked it out by hand and got 4. \\n`(2,2)` and  `(1,1)` are self-transfering\\n`(2,1)` and `(1, 2)` allows swapping. So 4 in total."
                    },
                    {
                        "username": "void_8t",
                        "content": "just check for every possible case, for every request, take it or don't take it, and keep count of requests taken till the end.\n\ncheck the status of the degree in end and  update the answer (max always).\n\n\n\n\n\n\n"
                    },
                    {
                        "username": "anand_083",
                        "content": "we also use math realation to solve this problem like if it is symmertric increment by count 2 or if it is transitive then and in normal by 1 else 0 ;\\nbut the problem is what if , if there are so many relation intersect each other then there is multiple answer  ??\\n"
                    },
                    {
                        "username": "omkarsk98",
                        "content": "maximum will always be one values"
                    },
                    {
                        "username": "wild_knight",
                        "content": "Is it only me or this was actually the easiest hard problem ?"
                    }
                ]
            },
            {
                "id": 1953035,
                "content": [
                    {
                        "username": "hoangdo_spm",
                        "content": "Why this test case has output is 3 instead of 4?\n `n = 5;\nrequests = [[0,1],[0,1],[1,2],[2,0],[3,4]];`\nI have think that both two first requests is accepted, but maybe just only one is accepted. Correct me if I am wrong, thanks so much!"
                    },
                    {
                        "username": "bparanj",
                        "content": "The main constraint for this problem is that every building should end up with the same number of employees as it started with. This means that for every employee that leaves a building, an employee must also enter that building.\\n\\nFor the given test case, if we accept both of the first two requests, we will end up with an imbalance in building 0. Two employees will leave building 0, but only one will return (from building 2). So we can\\'t accept both of the first two requests.\\n\\nHowever, we can accept one of the first two requests, along with the third and fourth requests. This gives us the following movement of employees:\\n\\n1. An employee moves from building 0 to building 1.\\n2. An employee moves from building 1 to building 2.\\n3. An employee moves from building 2 to building 0.\\n\\nNow, buildings 0, 1, and 2 all have the same number of employees as they started with, and we\\'ve fulfilled 3 requests. We can\\'t fulfill the fifth request without creating an imbalance, so the maximum number of requests we can fulfill is 3, not 4."
                    },
                    {
                        "username": "psionl0",
                        "content": "[0,1],[1,2],[2,0] form a cycle leaving [0,1],[3,4] which can\\'t be executed. Note that 2 people leave bldg 0 but only 1 returns."
                    },
                    {
                        "username": "kevinyou77",
                        "content": "I thought this question can be solved with graph until I saw the editorial\\u2026"
                    },
                    {
                        "username": "wafsinc",
                        "content": "It can be."
                    },
                    {
                        "username": "Jaiff",
                        "content": "LOL. Not hard at all. Thanks leetcode. I will now enjoy my sunday. "
                    },
                    {
                        "username": "lucasscodes",
                        "content": "Brute allowed and still hard?\nIs just reading the constraints and seeing brute complexity is possible already enough to be hard???"
                    },
                    {
                        "username": "psionl0",
                        "content": "This might be a \"hard\" problem if you use backtracking as suggested in the editorial but bitmasking makes this easy."
                    },
                    {
                        "username": "sharmakavya1002",
                        "content": "Can we please not get HARD PROBLEMS everyday? ; _ ;"
                    },
                    {
                        "username": "kumaraashish118",
                        "content": "Can anyone tell how there are 4 possible achievable requests in the following testcase?\n`n = 3`\n`requests = [[1,2],[1,2],[2,2],[0,2],[2,1],[1,1],[1,2]]`\n\nI'm confused and the only possible transfers I can see here are the self-transfers in a building i.e 2. Can anyone help with this one?\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "Let\\'s break down the movements we could make for each request:\\n\\n1. An employee moves from building 1 to building 2.\\n2. An employee moves from building 1 to building 2.\\n3. An employee stays in building 2 (self-transfer).\\n4. An employee moves from building 0 to building 2.\\n5. An employee moves from building 2 to building 1.\\n6. An employee stays in building 1 (self-transfer).\\n7. An employee moves from building 1 to building 2.\\n\\nIf we choose the 1st, 2nd, 5th, and 6th requests, we have the following movements:\\n\\n1. Employee moves from building 1 to building 2.\\n2. Employee moves from building 1 to building 2.\\n3. Employee moves from building 2 to building 1.\\n4. Employee stays in building 1 (self-transfer).\\n\\nNow, buildings 1 and 2 have the same number of employees as they started with. Building 0 didn\\'t change, so it\\'s still balanced. Therefore, we\\'ve fulfilled 4 requests, which is the maximum for this case.\\n\\nLet\\'s make a table to visualize this dataset. \\n\\nHere, for simplicity and better understanding, we\\'ll use \\'Initial\\' to represent the state of each building before any requests, and \\'Building 0\\', \\'Building 1\\' and \\'Building 2\\' to represent the states after each request. \\'Feasibility\\' column indicates whether each request is feasible (i.e., maintains the balance of people in/out of each building).\\n\\n| Request # | Movement | Building 0 | Building 1 | Building 2 | Feasibility |\\n|-----------|----------|------------|------------|------------|-------------|\\n|           | Initial  |      0     |      0     |      0     | N/A         |\\n|     1     | 1 -> 2   |      0     |     -1     |     +1     | To be determined |\\n|     2     | 1 -> 2   |      0     |     -2     |     +2     | To be determined |\\n|     3     | 2 -> 2   |      0     |     -2     |     +2     | Disregarded |\\n|     4     | 0 -> 2   |     -1     |     -2     |     +3     | To be determined |\\n|     5     | 2 -> 1   |     -1     |     -1     |     +2     | To be determined |\\n|     6     | 1 -> 1   |     -1     |      0     |     +2     | Disregarded |\\n|     7     | 1 -> 2   |     -1     |     -1     |     +3     | To be determined |\\n\\nIn this table, we can see the impact of each request on the state of each building. However, whether a request is feasible or not depends on the combination of requests chosen. For example, if we select request #1 and request #5, the total effect is 0 for each building, which means these requests are feasible. Therefore, the \\'Feasibility\\' column should be filled considering all possible combinations of requests.\\n\\nThe feasibility is calculated based on whether the total number of employees across all buildings remains constant:\\n\\n| Step | Description | Building 0 | Building 1 | Building 2 | Feasibility |\\n|------|-------------|------------|------------|------------|-------------|\\n| 0    | Initial     | 0          | 0          | 0          | n/a         |\\n| 1    | 1st request (1 -> 2) | 0  | -1         | +1         | (0+(-1)+1)=0 |\\n| 2    | 2nd request (1 -> 2) | 0  | -2         | +2         | (0+(-2)+2)=0 |\\n| 3    | 5th request (2 -> 1) | 0  | -1         | +1         | (0+(-1)+1)=0 |\\n| 4    | 6th request (1 -> 1) | 0  | -1         | +1         | (0+(-1)+1)=0 |\\n\\nThis shows that each step in this sequence of requests keeps the total number of employees constant, making all steps feasible. The feasibility of each step is calculated as the sum of changes in all buildings, and if this sum equals zero, then the step is feasible.\\n"
                    },
                    {
                        "username": "shiyao821",
                        "content": "I worked it out by hand and got 4. \\n`(2,2)` and  `(1,1)` are self-transfering\\n`(2,1)` and `(1, 2)` allows swapping. So 4 in total."
                    },
                    {
                        "username": "void_8t",
                        "content": "just check for every possible case, for every request, take it or don't take it, and keep count of requests taken till the end.\n\ncheck the status of the degree in end and  update the answer (max always).\n\n\n\n\n\n\n"
                    },
                    {
                        "username": "anand_083",
                        "content": "we also use math realation to solve this problem like if it is symmertric increment by count 2 or if it is transitive then and in normal by 1 else 0 ;\\nbut the problem is what if , if there are so many relation intersect each other then there is multiple answer  ??\\n"
                    },
                    {
                        "username": "omkarsk98",
                        "content": "maximum will always be one values"
                    },
                    {
                        "username": "wild_knight",
                        "content": "Is it only me or this was actually the easiest hard problem ?"
                    }
                ]
            },
            {
                "id": 1953018,
                "content": [
                    {
                        "username": "hoangdo_spm",
                        "content": "Why this test case has output is 3 instead of 4?\n `n = 5;\nrequests = [[0,1],[0,1],[1,2],[2,0],[3,4]];`\nI have think that both two first requests is accepted, but maybe just only one is accepted. Correct me if I am wrong, thanks so much!"
                    },
                    {
                        "username": "bparanj",
                        "content": "The main constraint for this problem is that every building should end up with the same number of employees as it started with. This means that for every employee that leaves a building, an employee must also enter that building.\\n\\nFor the given test case, if we accept both of the first two requests, we will end up with an imbalance in building 0. Two employees will leave building 0, but only one will return (from building 2). So we can\\'t accept both of the first two requests.\\n\\nHowever, we can accept one of the first two requests, along with the third and fourth requests. This gives us the following movement of employees:\\n\\n1. An employee moves from building 0 to building 1.\\n2. An employee moves from building 1 to building 2.\\n3. An employee moves from building 2 to building 0.\\n\\nNow, buildings 0, 1, and 2 all have the same number of employees as they started with, and we\\'ve fulfilled 3 requests. We can\\'t fulfill the fifth request without creating an imbalance, so the maximum number of requests we can fulfill is 3, not 4."
                    },
                    {
                        "username": "psionl0",
                        "content": "[0,1],[1,2],[2,0] form a cycle leaving [0,1],[3,4] which can\\'t be executed. Note that 2 people leave bldg 0 but only 1 returns."
                    },
                    {
                        "username": "kevinyou77",
                        "content": "I thought this question can be solved with graph until I saw the editorial\\u2026"
                    },
                    {
                        "username": "wafsinc",
                        "content": "It can be."
                    },
                    {
                        "username": "Jaiff",
                        "content": "LOL. Not hard at all. Thanks leetcode. I will now enjoy my sunday. "
                    },
                    {
                        "username": "lucasscodes",
                        "content": "Brute allowed and still hard?\nIs just reading the constraints and seeing brute complexity is possible already enough to be hard???"
                    },
                    {
                        "username": "psionl0",
                        "content": "This might be a \"hard\" problem if you use backtracking as suggested in the editorial but bitmasking makes this easy."
                    },
                    {
                        "username": "sharmakavya1002",
                        "content": "Can we please not get HARD PROBLEMS everyday? ; _ ;"
                    },
                    {
                        "username": "kumaraashish118",
                        "content": "Can anyone tell how there are 4 possible achievable requests in the following testcase?\n`n = 3`\n`requests = [[1,2],[1,2],[2,2],[0,2],[2,1],[1,1],[1,2]]`\n\nI'm confused and the only possible transfers I can see here are the self-transfers in a building i.e 2. Can anyone help with this one?\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "Let\\'s break down the movements we could make for each request:\\n\\n1. An employee moves from building 1 to building 2.\\n2. An employee moves from building 1 to building 2.\\n3. An employee stays in building 2 (self-transfer).\\n4. An employee moves from building 0 to building 2.\\n5. An employee moves from building 2 to building 1.\\n6. An employee stays in building 1 (self-transfer).\\n7. An employee moves from building 1 to building 2.\\n\\nIf we choose the 1st, 2nd, 5th, and 6th requests, we have the following movements:\\n\\n1. Employee moves from building 1 to building 2.\\n2. Employee moves from building 1 to building 2.\\n3. Employee moves from building 2 to building 1.\\n4. Employee stays in building 1 (self-transfer).\\n\\nNow, buildings 1 and 2 have the same number of employees as they started with. Building 0 didn\\'t change, so it\\'s still balanced. Therefore, we\\'ve fulfilled 4 requests, which is the maximum for this case.\\n\\nLet\\'s make a table to visualize this dataset. \\n\\nHere, for simplicity and better understanding, we\\'ll use \\'Initial\\' to represent the state of each building before any requests, and \\'Building 0\\', \\'Building 1\\' and \\'Building 2\\' to represent the states after each request. \\'Feasibility\\' column indicates whether each request is feasible (i.e., maintains the balance of people in/out of each building).\\n\\n| Request # | Movement | Building 0 | Building 1 | Building 2 | Feasibility |\\n|-----------|----------|------------|------------|------------|-------------|\\n|           | Initial  |      0     |      0     |      0     | N/A         |\\n|     1     | 1 -> 2   |      0     |     -1     |     +1     | To be determined |\\n|     2     | 1 -> 2   |      0     |     -2     |     +2     | To be determined |\\n|     3     | 2 -> 2   |      0     |     -2     |     +2     | Disregarded |\\n|     4     | 0 -> 2   |     -1     |     -2     |     +3     | To be determined |\\n|     5     | 2 -> 1   |     -1     |     -1     |     +2     | To be determined |\\n|     6     | 1 -> 1   |     -1     |      0     |     +2     | Disregarded |\\n|     7     | 1 -> 2   |     -1     |     -1     |     +3     | To be determined |\\n\\nIn this table, we can see the impact of each request on the state of each building. However, whether a request is feasible or not depends on the combination of requests chosen. For example, if we select request #1 and request #5, the total effect is 0 for each building, which means these requests are feasible. Therefore, the \\'Feasibility\\' column should be filled considering all possible combinations of requests.\\n\\nThe feasibility is calculated based on whether the total number of employees across all buildings remains constant:\\n\\n| Step | Description | Building 0 | Building 1 | Building 2 | Feasibility |\\n|------|-------------|------------|------------|------------|-------------|\\n| 0    | Initial     | 0          | 0          | 0          | n/a         |\\n| 1    | 1st request (1 -> 2) | 0  | -1         | +1         | (0+(-1)+1)=0 |\\n| 2    | 2nd request (1 -> 2) | 0  | -2         | +2         | (0+(-2)+2)=0 |\\n| 3    | 5th request (2 -> 1) | 0  | -1         | +1         | (0+(-1)+1)=0 |\\n| 4    | 6th request (1 -> 1) | 0  | -1         | +1         | (0+(-1)+1)=0 |\\n\\nThis shows that each step in this sequence of requests keeps the total number of employees constant, making all steps feasible. The feasibility of each step is calculated as the sum of changes in all buildings, and if this sum equals zero, then the step is feasible.\\n"
                    },
                    {
                        "username": "shiyao821",
                        "content": "I worked it out by hand and got 4. \\n`(2,2)` and  `(1,1)` are self-transfering\\n`(2,1)` and `(1, 2)` allows swapping. So 4 in total."
                    },
                    {
                        "username": "void_8t",
                        "content": "just check for every possible case, for every request, take it or don't take it, and keep count of requests taken till the end.\n\ncheck the status of the degree in end and  update the answer (max always).\n\n\n\n\n\n\n"
                    },
                    {
                        "username": "anand_083",
                        "content": "we also use math realation to solve this problem like if it is symmertric increment by count 2 or if it is transitive then and in normal by 1 else 0 ;\\nbut the problem is what if , if there are so many relation intersect each other then there is multiple answer  ??\\n"
                    },
                    {
                        "username": "omkarsk98",
                        "content": "maximum will always be one values"
                    },
                    {
                        "username": "wild_knight",
                        "content": "Is it only me or this was actually the easiest hard problem ?"
                    }
                ]
            },
            {
                "id": 1952977,
                "content": [
                    {
                        "username": "hoangdo_spm",
                        "content": "Why this test case has output is 3 instead of 4?\n `n = 5;\nrequests = [[0,1],[0,1],[1,2],[2,0],[3,4]];`\nI have think that both two first requests is accepted, but maybe just only one is accepted. Correct me if I am wrong, thanks so much!"
                    },
                    {
                        "username": "bparanj",
                        "content": "The main constraint for this problem is that every building should end up with the same number of employees as it started with. This means that for every employee that leaves a building, an employee must also enter that building.\\n\\nFor the given test case, if we accept both of the first two requests, we will end up with an imbalance in building 0. Two employees will leave building 0, but only one will return (from building 2). So we can\\'t accept both of the first two requests.\\n\\nHowever, we can accept one of the first two requests, along with the third and fourth requests. This gives us the following movement of employees:\\n\\n1. An employee moves from building 0 to building 1.\\n2. An employee moves from building 1 to building 2.\\n3. An employee moves from building 2 to building 0.\\n\\nNow, buildings 0, 1, and 2 all have the same number of employees as they started with, and we\\'ve fulfilled 3 requests. We can\\'t fulfill the fifth request without creating an imbalance, so the maximum number of requests we can fulfill is 3, not 4."
                    },
                    {
                        "username": "psionl0",
                        "content": "[0,1],[1,2],[2,0] form a cycle leaving [0,1],[3,4] which can\\'t be executed. Note that 2 people leave bldg 0 but only 1 returns."
                    },
                    {
                        "username": "kevinyou77",
                        "content": "I thought this question can be solved with graph until I saw the editorial\\u2026"
                    },
                    {
                        "username": "wafsinc",
                        "content": "It can be."
                    },
                    {
                        "username": "Jaiff",
                        "content": "LOL. Not hard at all. Thanks leetcode. I will now enjoy my sunday. "
                    },
                    {
                        "username": "lucasscodes",
                        "content": "Brute allowed and still hard?\nIs just reading the constraints and seeing brute complexity is possible already enough to be hard???"
                    },
                    {
                        "username": "psionl0",
                        "content": "This might be a \"hard\" problem if you use backtracking as suggested in the editorial but bitmasking makes this easy."
                    },
                    {
                        "username": "sharmakavya1002",
                        "content": "Can we please not get HARD PROBLEMS everyday? ; _ ;"
                    },
                    {
                        "username": "kumaraashish118",
                        "content": "Can anyone tell how there are 4 possible achievable requests in the following testcase?\n`n = 3`\n`requests = [[1,2],[1,2],[2,2],[0,2],[2,1],[1,1],[1,2]]`\n\nI'm confused and the only possible transfers I can see here are the self-transfers in a building i.e 2. Can anyone help with this one?\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "Let\\'s break down the movements we could make for each request:\\n\\n1. An employee moves from building 1 to building 2.\\n2. An employee moves from building 1 to building 2.\\n3. An employee stays in building 2 (self-transfer).\\n4. An employee moves from building 0 to building 2.\\n5. An employee moves from building 2 to building 1.\\n6. An employee stays in building 1 (self-transfer).\\n7. An employee moves from building 1 to building 2.\\n\\nIf we choose the 1st, 2nd, 5th, and 6th requests, we have the following movements:\\n\\n1. Employee moves from building 1 to building 2.\\n2. Employee moves from building 1 to building 2.\\n3. Employee moves from building 2 to building 1.\\n4. Employee stays in building 1 (self-transfer).\\n\\nNow, buildings 1 and 2 have the same number of employees as they started with. Building 0 didn\\'t change, so it\\'s still balanced. Therefore, we\\'ve fulfilled 4 requests, which is the maximum for this case.\\n\\nLet\\'s make a table to visualize this dataset. \\n\\nHere, for simplicity and better understanding, we\\'ll use \\'Initial\\' to represent the state of each building before any requests, and \\'Building 0\\', \\'Building 1\\' and \\'Building 2\\' to represent the states after each request. \\'Feasibility\\' column indicates whether each request is feasible (i.e., maintains the balance of people in/out of each building).\\n\\n| Request # | Movement | Building 0 | Building 1 | Building 2 | Feasibility |\\n|-----------|----------|------------|------------|------------|-------------|\\n|           | Initial  |      0     |      0     |      0     | N/A         |\\n|     1     | 1 -> 2   |      0     |     -1     |     +1     | To be determined |\\n|     2     | 1 -> 2   |      0     |     -2     |     +2     | To be determined |\\n|     3     | 2 -> 2   |      0     |     -2     |     +2     | Disregarded |\\n|     4     | 0 -> 2   |     -1     |     -2     |     +3     | To be determined |\\n|     5     | 2 -> 1   |     -1     |     -1     |     +2     | To be determined |\\n|     6     | 1 -> 1   |     -1     |      0     |     +2     | Disregarded |\\n|     7     | 1 -> 2   |     -1     |     -1     |     +3     | To be determined |\\n\\nIn this table, we can see the impact of each request on the state of each building. However, whether a request is feasible or not depends on the combination of requests chosen. For example, if we select request #1 and request #5, the total effect is 0 for each building, which means these requests are feasible. Therefore, the \\'Feasibility\\' column should be filled considering all possible combinations of requests.\\n\\nThe feasibility is calculated based on whether the total number of employees across all buildings remains constant:\\n\\n| Step | Description | Building 0 | Building 1 | Building 2 | Feasibility |\\n|------|-------------|------------|------------|------------|-------------|\\n| 0    | Initial     | 0          | 0          | 0          | n/a         |\\n| 1    | 1st request (1 -> 2) | 0  | -1         | +1         | (0+(-1)+1)=0 |\\n| 2    | 2nd request (1 -> 2) | 0  | -2         | +2         | (0+(-2)+2)=0 |\\n| 3    | 5th request (2 -> 1) | 0  | -1         | +1         | (0+(-1)+1)=0 |\\n| 4    | 6th request (1 -> 1) | 0  | -1         | +1         | (0+(-1)+1)=0 |\\n\\nThis shows that each step in this sequence of requests keeps the total number of employees constant, making all steps feasible. The feasibility of each step is calculated as the sum of changes in all buildings, and if this sum equals zero, then the step is feasible.\\n"
                    },
                    {
                        "username": "shiyao821",
                        "content": "I worked it out by hand and got 4. \\n`(2,2)` and  `(1,1)` are self-transfering\\n`(2,1)` and `(1, 2)` allows swapping. So 4 in total."
                    },
                    {
                        "username": "void_8t",
                        "content": "just check for every possible case, for every request, take it or don't take it, and keep count of requests taken till the end.\n\ncheck the status of the degree in end and  update the answer (max always).\n\n\n\n\n\n\n"
                    },
                    {
                        "username": "anand_083",
                        "content": "we also use math realation to solve this problem like if it is symmertric increment by count 2 or if it is transitive then and in normal by 1 else 0 ;\\nbut the problem is what if , if there are so many relation intersect each other then there is multiple answer  ??\\n"
                    },
                    {
                        "username": "omkarsk98",
                        "content": "maximum will always be one values"
                    },
                    {
                        "username": "wild_knight",
                        "content": "Is it only me or this was actually the easiest hard problem ?"
                    }
                ]
            },
            {
                "id": 1952927,
                "content": [
                    {
                        "username": "j0sal",
                        "content": "it was a medium level though"
                    },
                    {
                        "username": "omkarsk98",
                        "content": "Emotional damage"
                    },
                    {
                        "username": "nirajthakare",
                        "content": "never thought recursion could be the bforce \\uD83E\\uDD72"
                    },
                    {
                        "username": "gunjangnn",
                        "content": "Hi guys,\\n\\n\\nI came with this solution, but it fails as I\\'m not comparing in which choice we can get maximum achievable requests.\\n106/117 test cases passed.\\n\\ncan someone plz help in modifying this logic to work?\\n\\nclass Solution {\\n\\n    int achiReq = 0;\\n\\n    public int maximumRequests(int n, int[][] requests) {\\n        \\n        int[][] grid = new int[n][n];\\n        int[][] visited = new int[n][2];\\n\\n        for(int[] req : requests){\\n            grid[req[0]][req[1]] += 1;\\n        }\\n\\n        for(int i = 0; i < n; i++){\\n            dfs(grid, i, visited, 0);\\n        }\\n        \\n        return achiReq;\\n    }\\n\\n    public void dfs(int[][] grid, int i, int[][] visited, int reqCount){\\n\\n        visited[i][0] = 1;\\n        visited[i][1] = reqCount;\\n\\n        for(int j = 0; j < grid.length; j++){\\n            if(grid[i][j] > 0){\\n                grid[i][j] -= 1;\\n                if(visited[j][0] == 1 && reqCount + 1 - visited[j][1] >= 0){\\n                    achiReq += reqCount + 1 - visited[j][1];\\n                    dfs(grid, j, visited, visited[j][1]);\\n                } else {\\n                    dfs(grid, j, visited, reqCount + 1);\\n                }\\n            }\\n        }\\n\\n        visited[i][0] = 0;\\n    }\\n}"
                    },
                    {
                        "username": "bparanj",
                        "content": "The problem you\\'re trying to solve requires you to consider all possible combinations of fulfilling the transfer requests, and to find the maximum number of transfer requests that can be fulfilled without violating the constraints of the problem. Therefore, this problem requires a solution that searches the entire space of possible combinations, such as a depth-first search (DFS) or breadth-first search (BFS) with backtracking, to find the maximum number of requests that can be fulfilled.\\n\\nYour current implementation does a depth-first search through the transfer requests, but it appears to be missing the component where it checks all possible combinations. The function `dfs` seems to try to fulfill every transfer request it encounters without considering whether fulfilling a particular request is beneficial or not. This could lead to situations where fulfilling a request leads to fewer overall fulfillments, but because the request is fulfilled without consideration, it\\'s counted towards the final result.\\n\\nIn addition, you\\'re using a variable `achiReq` to keep track of the maximum number of achievable requests, but it\\'s not clear how this variable is updated correctly during the search. You might want to consider moving this variable inside the `dfs` function and updating it as part of the recursive call.\\n\\nOne way to address these issues is to adjust your DFS to a backtracking approach:\\n\\n1. Iterate through all possible combinations of requests. You can do this by creating a recursive function that considers both fulfilling and not fulfilling the current request.\\n\\n2. For each combination, calculate the number of requests that can be fulfilled (i.e., where the total number of employees in each building remains constant), and keep track of the maximum number of fulfillable requests.\\n\\n3. Return the maximum number of fulfillable requests.\\n"
                    },
                    {
                        "username": "gunjangnn",
                        "content": "logic is to use DFS and find cycles and in cycle add the cycle length to answer\\nprobably I need to check which cycle has max length then add it to answer and m struggling with this part"
                    },
                    {
                        "username": "Tillu__",
                        "content": "Never thought I could solve a hard problem on my first try!"
                    },
                    {
                        "username": "_anuj_jain_",
                        "content": "Happy Sunday :)\\n"
                    },
                    {
                        "username": "nikhilag84",
                        "content": "GUYS SEE THIS  SOLTUTION VERY EASY BIT MANIPULATION SOLUTION\\nhttps://leetcode.com/problems/maximum-number-of-achievable-transfer-requests/solutions/3706977/easy-c-bit-manipulation-solution/"
                    },
                    {
                        "username": "yashskd1026",
                        "content": "too many hard Questions\\uD83D\\uDE13"
                    },
                    {
                        "username": "Ankush-Kashyap",
                        "content": "What\\'s up with these hard questions? My brain just stopped responding. \\uD83D\\uDE11"
                    },
                    {
                        "username": "abhinavshukla693",
                        "content": "LeetCode has made its mission to make us suffer\\uD83D\\uDE25"
                    }
                ]
            },
            {
                "id": 1952915,
                "content": [
                    {
                        "username": "j0sal",
                        "content": "it was a medium level though"
                    },
                    {
                        "username": "omkarsk98",
                        "content": "Emotional damage"
                    },
                    {
                        "username": "nirajthakare",
                        "content": "never thought recursion could be the bforce \\uD83E\\uDD72"
                    },
                    {
                        "username": "gunjangnn",
                        "content": "Hi guys,\\n\\n\\nI came with this solution, but it fails as I\\'m not comparing in which choice we can get maximum achievable requests.\\n106/117 test cases passed.\\n\\ncan someone plz help in modifying this logic to work?\\n\\nclass Solution {\\n\\n    int achiReq = 0;\\n\\n    public int maximumRequests(int n, int[][] requests) {\\n        \\n        int[][] grid = new int[n][n];\\n        int[][] visited = new int[n][2];\\n\\n        for(int[] req : requests){\\n            grid[req[0]][req[1]] += 1;\\n        }\\n\\n        for(int i = 0; i < n; i++){\\n            dfs(grid, i, visited, 0);\\n        }\\n        \\n        return achiReq;\\n    }\\n\\n    public void dfs(int[][] grid, int i, int[][] visited, int reqCount){\\n\\n        visited[i][0] = 1;\\n        visited[i][1] = reqCount;\\n\\n        for(int j = 0; j < grid.length; j++){\\n            if(grid[i][j] > 0){\\n                grid[i][j] -= 1;\\n                if(visited[j][0] == 1 && reqCount + 1 - visited[j][1] >= 0){\\n                    achiReq += reqCount + 1 - visited[j][1];\\n                    dfs(grid, j, visited, visited[j][1]);\\n                } else {\\n                    dfs(grid, j, visited, reqCount + 1);\\n                }\\n            }\\n        }\\n\\n        visited[i][0] = 0;\\n    }\\n}"
                    },
                    {
                        "username": "bparanj",
                        "content": "The problem you\\'re trying to solve requires you to consider all possible combinations of fulfilling the transfer requests, and to find the maximum number of transfer requests that can be fulfilled without violating the constraints of the problem. Therefore, this problem requires a solution that searches the entire space of possible combinations, such as a depth-first search (DFS) or breadth-first search (BFS) with backtracking, to find the maximum number of requests that can be fulfilled.\\n\\nYour current implementation does a depth-first search through the transfer requests, but it appears to be missing the component where it checks all possible combinations. The function `dfs` seems to try to fulfill every transfer request it encounters without considering whether fulfilling a particular request is beneficial or not. This could lead to situations where fulfilling a request leads to fewer overall fulfillments, but because the request is fulfilled without consideration, it\\'s counted towards the final result.\\n\\nIn addition, you\\'re using a variable `achiReq` to keep track of the maximum number of achievable requests, but it\\'s not clear how this variable is updated correctly during the search. You might want to consider moving this variable inside the `dfs` function and updating it as part of the recursive call.\\n\\nOne way to address these issues is to adjust your DFS to a backtracking approach:\\n\\n1. Iterate through all possible combinations of requests. You can do this by creating a recursive function that considers both fulfilling and not fulfilling the current request.\\n\\n2. For each combination, calculate the number of requests that can be fulfilled (i.e., where the total number of employees in each building remains constant), and keep track of the maximum number of fulfillable requests.\\n\\n3. Return the maximum number of fulfillable requests.\\n"
                    },
                    {
                        "username": "gunjangnn",
                        "content": "logic is to use DFS and find cycles and in cycle add the cycle length to answer\\nprobably I need to check which cycle has max length then add it to answer and m struggling with this part"
                    },
                    {
                        "username": "Tillu__",
                        "content": "Never thought I could solve a hard problem on my first try!"
                    },
                    {
                        "username": "_anuj_jain_",
                        "content": "Happy Sunday :)\\n"
                    },
                    {
                        "username": "nikhilag84",
                        "content": "GUYS SEE THIS  SOLTUTION VERY EASY BIT MANIPULATION SOLUTION\\nhttps://leetcode.com/problems/maximum-number-of-achievable-transfer-requests/solutions/3706977/easy-c-bit-manipulation-solution/"
                    },
                    {
                        "username": "yashskd1026",
                        "content": "too many hard Questions\\uD83D\\uDE13"
                    },
                    {
                        "username": "Ankush-Kashyap",
                        "content": "What\\'s up with these hard questions? My brain just stopped responding. \\uD83D\\uDE11"
                    },
                    {
                        "username": "abhinavshukla693",
                        "content": "LeetCode has made its mission to make us suffer\\uD83D\\uDE25"
                    }
                ]
            },
            {
                "id": 1952906,
                "content": [
                    {
                        "username": "j0sal",
                        "content": "it was a medium level though"
                    },
                    {
                        "username": "omkarsk98",
                        "content": "Emotional damage"
                    },
                    {
                        "username": "nirajthakare",
                        "content": "never thought recursion could be the bforce \\uD83E\\uDD72"
                    },
                    {
                        "username": "gunjangnn",
                        "content": "Hi guys,\\n\\n\\nI came with this solution, but it fails as I\\'m not comparing in which choice we can get maximum achievable requests.\\n106/117 test cases passed.\\n\\ncan someone plz help in modifying this logic to work?\\n\\nclass Solution {\\n\\n    int achiReq = 0;\\n\\n    public int maximumRequests(int n, int[][] requests) {\\n        \\n        int[][] grid = new int[n][n];\\n        int[][] visited = new int[n][2];\\n\\n        for(int[] req : requests){\\n            grid[req[0]][req[1]] += 1;\\n        }\\n\\n        for(int i = 0; i < n; i++){\\n            dfs(grid, i, visited, 0);\\n        }\\n        \\n        return achiReq;\\n    }\\n\\n    public void dfs(int[][] grid, int i, int[][] visited, int reqCount){\\n\\n        visited[i][0] = 1;\\n        visited[i][1] = reqCount;\\n\\n        for(int j = 0; j < grid.length; j++){\\n            if(grid[i][j] > 0){\\n                grid[i][j] -= 1;\\n                if(visited[j][0] == 1 && reqCount + 1 - visited[j][1] >= 0){\\n                    achiReq += reqCount + 1 - visited[j][1];\\n                    dfs(grid, j, visited, visited[j][1]);\\n                } else {\\n                    dfs(grid, j, visited, reqCount + 1);\\n                }\\n            }\\n        }\\n\\n        visited[i][0] = 0;\\n    }\\n}"
                    },
                    {
                        "username": "bparanj",
                        "content": "The problem you\\'re trying to solve requires you to consider all possible combinations of fulfilling the transfer requests, and to find the maximum number of transfer requests that can be fulfilled without violating the constraints of the problem. Therefore, this problem requires a solution that searches the entire space of possible combinations, such as a depth-first search (DFS) or breadth-first search (BFS) with backtracking, to find the maximum number of requests that can be fulfilled.\\n\\nYour current implementation does a depth-first search through the transfer requests, but it appears to be missing the component where it checks all possible combinations. The function `dfs` seems to try to fulfill every transfer request it encounters without considering whether fulfilling a particular request is beneficial or not. This could lead to situations where fulfilling a request leads to fewer overall fulfillments, but because the request is fulfilled without consideration, it\\'s counted towards the final result.\\n\\nIn addition, you\\'re using a variable `achiReq` to keep track of the maximum number of achievable requests, but it\\'s not clear how this variable is updated correctly during the search. You might want to consider moving this variable inside the `dfs` function and updating it as part of the recursive call.\\n\\nOne way to address these issues is to adjust your DFS to a backtracking approach:\\n\\n1. Iterate through all possible combinations of requests. You can do this by creating a recursive function that considers both fulfilling and not fulfilling the current request.\\n\\n2. For each combination, calculate the number of requests that can be fulfilled (i.e., where the total number of employees in each building remains constant), and keep track of the maximum number of fulfillable requests.\\n\\n3. Return the maximum number of fulfillable requests.\\n"
                    },
                    {
                        "username": "gunjangnn",
                        "content": "logic is to use DFS and find cycles and in cycle add the cycle length to answer\\nprobably I need to check which cycle has max length then add it to answer and m struggling with this part"
                    },
                    {
                        "username": "Tillu__",
                        "content": "Never thought I could solve a hard problem on my first try!"
                    },
                    {
                        "username": "_anuj_jain_",
                        "content": "Happy Sunday :)\\n"
                    },
                    {
                        "username": "nikhilag84",
                        "content": "GUYS SEE THIS  SOLTUTION VERY EASY BIT MANIPULATION SOLUTION\\nhttps://leetcode.com/problems/maximum-number-of-achievable-transfer-requests/solutions/3706977/easy-c-bit-manipulation-solution/"
                    },
                    {
                        "username": "yashskd1026",
                        "content": "too many hard Questions\\uD83D\\uDE13"
                    },
                    {
                        "username": "Ankush-Kashyap",
                        "content": "What\\'s up with these hard questions? My brain just stopped responding. \\uD83D\\uDE11"
                    },
                    {
                        "username": "abhinavshukla693",
                        "content": "LeetCode has made its mission to make us suffer\\uD83D\\uDE25"
                    }
                ]
            },
            {
                "id": 1952888,
                "content": [
                    {
                        "username": "j0sal",
                        "content": "it was a medium level though"
                    },
                    {
                        "username": "omkarsk98",
                        "content": "Emotional damage"
                    },
                    {
                        "username": "nirajthakare",
                        "content": "never thought recursion could be the bforce \\uD83E\\uDD72"
                    },
                    {
                        "username": "gunjangnn",
                        "content": "Hi guys,\\n\\n\\nI came with this solution, but it fails as I\\'m not comparing in which choice we can get maximum achievable requests.\\n106/117 test cases passed.\\n\\ncan someone plz help in modifying this logic to work?\\n\\nclass Solution {\\n\\n    int achiReq = 0;\\n\\n    public int maximumRequests(int n, int[][] requests) {\\n        \\n        int[][] grid = new int[n][n];\\n        int[][] visited = new int[n][2];\\n\\n        for(int[] req : requests){\\n            grid[req[0]][req[1]] += 1;\\n        }\\n\\n        for(int i = 0; i < n; i++){\\n            dfs(grid, i, visited, 0);\\n        }\\n        \\n        return achiReq;\\n    }\\n\\n    public void dfs(int[][] grid, int i, int[][] visited, int reqCount){\\n\\n        visited[i][0] = 1;\\n        visited[i][1] = reqCount;\\n\\n        for(int j = 0; j < grid.length; j++){\\n            if(grid[i][j] > 0){\\n                grid[i][j] -= 1;\\n                if(visited[j][0] == 1 && reqCount + 1 - visited[j][1] >= 0){\\n                    achiReq += reqCount + 1 - visited[j][1];\\n                    dfs(grid, j, visited, visited[j][1]);\\n                } else {\\n                    dfs(grid, j, visited, reqCount + 1);\\n                }\\n            }\\n        }\\n\\n        visited[i][0] = 0;\\n    }\\n}"
                    },
                    {
                        "username": "bparanj",
                        "content": "The problem you\\'re trying to solve requires you to consider all possible combinations of fulfilling the transfer requests, and to find the maximum number of transfer requests that can be fulfilled without violating the constraints of the problem. Therefore, this problem requires a solution that searches the entire space of possible combinations, such as a depth-first search (DFS) or breadth-first search (BFS) with backtracking, to find the maximum number of requests that can be fulfilled.\\n\\nYour current implementation does a depth-first search through the transfer requests, but it appears to be missing the component where it checks all possible combinations. The function `dfs` seems to try to fulfill every transfer request it encounters without considering whether fulfilling a particular request is beneficial or not. This could lead to situations where fulfilling a request leads to fewer overall fulfillments, but because the request is fulfilled without consideration, it\\'s counted towards the final result.\\n\\nIn addition, you\\'re using a variable `achiReq` to keep track of the maximum number of achievable requests, but it\\'s not clear how this variable is updated correctly during the search. You might want to consider moving this variable inside the `dfs` function and updating it as part of the recursive call.\\n\\nOne way to address these issues is to adjust your DFS to a backtracking approach:\\n\\n1. Iterate through all possible combinations of requests. You can do this by creating a recursive function that considers both fulfilling and not fulfilling the current request.\\n\\n2. For each combination, calculate the number of requests that can be fulfilled (i.e., where the total number of employees in each building remains constant), and keep track of the maximum number of fulfillable requests.\\n\\n3. Return the maximum number of fulfillable requests.\\n"
                    },
                    {
                        "username": "gunjangnn",
                        "content": "logic is to use DFS and find cycles and in cycle add the cycle length to answer\\nprobably I need to check which cycle has max length then add it to answer and m struggling with this part"
                    },
                    {
                        "username": "Tillu__",
                        "content": "Never thought I could solve a hard problem on my first try!"
                    },
                    {
                        "username": "_anuj_jain_",
                        "content": "Happy Sunday :)\\n"
                    },
                    {
                        "username": "nikhilag84",
                        "content": "GUYS SEE THIS  SOLTUTION VERY EASY BIT MANIPULATION SOLUTION\\nhttps://leetcode.com/problems/maximum-number-of-achievable-transfer-requests/solutions/3706977/easy-c-bit-manipulation-solution/"
                    },
                    {
                        "username": "yashskd1026",
                        "content": "too many hard Questions\\uD83D\\uDE13"
                    },
                    {
                        "username": "Ankush-Kashyap",
                        "content": "What\\'s up with these hard questions? My brain just stopped responding. \\uD83D\\uDE11"
                    },
                    {
                        "username": "abhinavshukla693",
                        "content": "LeetCode has made its mission to make us suffer\\uD83D\\uDE25"
                    }
                ]
            },
            {
                "id": 1952885,
                "content": [
                    {
                        "username": "j0sal",
                        "content": "it was a medium level though"
                    },
                    {
                        "username": "omkarsk98",
                        "content": "Emotional damage"
                    },
                    {
                        "username": "nirajthakare",
                        "content": "never thought recursion could be the bforce \\uD83E\\uDD72"
                    },
                    {
                        "username": "gunjangnn",
                        "content": "Hi guys,\\n\\n\\nI came with this solution, but it fails as I\\'m not comparing in which choice we can get maximum achievable requests.\\n106/117 test cases passed.\\n\\ncan someone plz help in modifying this logic to work?\\n\\nclass Solution {\\n\\n    int achiReq = 0;\\n\\n    public int maximumRequests(int n, int[][] requests) {\\n        \\n        int[][] grid = new int[n][n];\\n        int[][] visited = new int[n][2];\\n\\n        for(int[] req : requests){\\n            grid[req[0]][req[1]] += 1;\\n        }\\n\\n        for(int i = 0; i < n; i++){\\n            dfs(grid, i, visited, 0);\\n        }\\n        \\n        return achiReq;\\n    }\\n\\n    public void dfs(int[][] grid, int i, int[][] visited, int reqCount){\\n\\n        visited[i][0] = 1;\\n        visited[i][1] = reqCount;\\n\\n        for(int j = 0; j < grid.length; j++){\\n            if(grid[i][j] > 0){\\n                grid[i][j] -= 1;\\n                if(visited[j][0] == 1 && reqCount + 1 - visited[j][1] >= 0){\\n                    achiReq += reqCount + 1 - visited[j][1];\\n                    dfs(grid, j, visited, visited[j][1]);\\n                } else {\\n                    dfs(grid, j, visited, reqCount + 1);\\n                }\\n            }\\n        }\\n\\n        visited[i][0] = 0;\\n    }\\n}"
                    },
                    {
                        "username": "bparanj",
                        "content": "The problem you\\'re trying to solve requires you to consider all possible combinations of fulfilling the transfer requests, and to find the maximum number of transfer requests that can be fulfilled without violating the constraints of the problem. Therefore, this problem requires a solution that searches the entire space of possible combinations, such as a depth-first search (DFS) or breadth-first search (BFS) with backtracking, to find the maximum number of requests that can be fulfilled.\\n\\nYour current implementation does a depth-first search through the transfer requests, but it appears to be missing the component where it checks all possible combinations. The function `dfs` seems to try to fulfill every transfer request it encounters without considering whether fulfilling a particular request is beneficial or not. This could lead to situations where fulfilling a request leads to fewer overall fulfillments, but because the request is fulfilled without consideration, it\\'s counted towards the final result.\\n\\nIn addition, you\\'re using a variable `achiReq` to keep track of the maximum number of achievable requests, but it\\'s not clear how this variable is updated correctly during the search. You might want to consider moving this variable inside the `dfs` function and updating it as part of the recursive call.\\n\\nOne way to address these issues is to adjust your DFS to a backtracking approach:\\n\\n1. Iterate through all possible combinations of requests. You can do this by creating a recursive function that considers both fulfilling and not fulfilling the current request.\\n\\n2. For each combination, calculate the number of requests that can be fulfilled (i.e., where the total number of employees in each building remains constant), and keep track of the maximum number of fulfillable requests.\\n\\n3. Return the maximum number of fulfillable requests.\\n"
                    },
                    {
                        "username": "gunjangnn",
                        "content": "logic is to use DFS and find cycles and in cycle add the cycle length to answer\\nprobably I need to check which cycle has max length then add it to answer and m struggling with this part"
                    },
                    {
                        "username": "Tillu__",
                        "content": "Never thought I could solve a hard problem on my first try!"
                    },
                    {
                        "username": "_anuj_jain_",
                        "content": "Happy Sunday :)\\n"
                    },
                    {
                        "username": "nikhilag84",
                        "content": "GUYS SEE THIS  SOLTUTION VERY EASY BIT MANIPULATION SOLUTION\\nhttps://leetcode.com/problems/maximum-number-of-achievable-transfer-requests/solutions/3706977/easy-c-bit-manipulation-solution/"
                    },
                    {
                        "username": "yashskd1026",
                        "content": "too many hard Questions\\uD83D\\uDE13"
                    },
                    {
                        "username": "Ankush-Kashyap",
                        "content": "What\\'s up with these hard questions? My brain just stopped responding. \\uD83D\\uDE11"
                    },
                    {
                        "username": "abhinavshukla693",
                        "content": "LeetCode has made its mission to make us suffer\\uD83D\\uDE25"
                    }
                ]
            },
            {
                "id": 1952866,
                "content": [
                    {
                        "username": "j0sal",
                        "content": "it was a medium level though"
                    },
                    {
                        "username": "omkarsk98",
                        "content": "Emotional damage"
                    },
                    {
                        "username": "nirajthakare",
                        "content": "never thought recursion could be the bforce \\uD83E\\uDD72"
                    },
                    {
                        "username": "gunjangnn",
                        "content": "Hi guys,\\n\\n\\nI came with this solution, but it fails as I\\'m not comparing in which choice we can get maximum achievable requests.\\n106/117 test cases passed.\\n\\ncan someone plz help in modifying this logic to work?\\n\\nclass Solution {\\n\\n    int achiReq = 0;\\n\\n    public int maximumRequests(int n, int[][] requests) {\\n        \\n        int[][] grid = new int[n][n];\\n        int[][] visited = new int[n][2];\\n\\n        for(int[] req : requests){\\n            grid[req[0]][req[1]] += 1;\\n        }\\n\\n        for(int i = 0; i < n; i++){\\n            dfs(grid, i, visited, 0);\\n        }\\n        \\n        return achiReq;\\n    }\\n\\n    public void dfs(int[][] grid, int i, int[][] visited, int reqCount){\\n\\n        visited[i][0] = 1;\\n        visited[i][1] = reqCount;\\n\\n        for(int j = 0; j < grid.length; j++){\\n            if(grid[i][j] > 0){\\n                grid[i][j] -= 1;\\n                if(visited[j][0] == 1 && reqCount + 1 - visited[j][1] >= 0){\\n                    achiReq += reqCount + 1 - visited[j][1];\\n                    dfs(grid, j, visited, visited[j][1]);\\n                } else {\\n                    dfs(grid, j, visited, reqCount + 1);\\n                }\\n            }\\n        }\\n\\n        visited[i][0] = 0;\\n    }\\n}"
                    },
                    {
                        "username": "bparanj",
                        "content": "The problem you\\'re trying to solve requires you to consider all possible combinations of fulfilling the transfer requests, and to find the maximum number of transfer requests that can be fulfilled without violating the constraints of the problem. Therefore, this problem requires a solution that searches the entire space of possible combinations, such as a depth-first search (DFS) or breadth-first search (BFS) with backtracking, to find the maximum number of requests that can be fulfilled.\\n\\nYour current implementation does a depth-first search through the transfer requests, but it appears to be missing the component where it checks all possible combinations. The function `dfs` seems to try to fulfill every transfer request it encounters without considering whether fulfilling a particular request is beneficial or not. This could lead to situations where fulfilling a request leads to fewer overall fulfillments, but because the request is fulfilled without consideration, it\\'s counted towards the final result.\\n\\nIn addition, you\\'re using a variable `achiReq` to keep track of the maximum number of achievable requests, but it\\'s not clear how this variable is updated correctly during the search. You might want to consider moving this variable inside the `dfs` function and updating it as part of the recursive call.\\n\\nOne way to address these issues is to adjust your DFS to a backtracking approach:\\n\\n1. Iterate through all possible combinations of requests. You can do this by creating a recursive function that considers both fulfilling and not fulfilling the current request.\\n\\n2. For each combination, calculate the number of requests that can be fulfilled (i.e., where the total number of employees in each building remains constant), and keep track of the maximum number of fulfillable requests.\\n\\n3. Return the maximum number of fulfillable requests.\\n"
                    },
                    {
                        "username": "gunjangnn",
                        "content": "logic is to use DFS and find cycles and in cycle add the cycle length to answer\\nprobably I need to check which cycle has max length then add it to answer and m struggling with this part"
                    },
                    {
                        "username": "Tillu__",
                        "content": "Never thought I could solve a hard problem on my first try!"
                    },
                    {
                        "username": "_anuj_jain_",
                        "content": "Happy Sunday :)\\n"
                    },
                    {
                        "username": "nikhilag84",
                        "content": "GUYS SEE THIS  SOLTUTION VERY EASY BIT MANIPULATION SOLUTION\\nhttps://leetcode.com/problems/maximum-number-of-achievable-transfer-requests/solutions/3706977/easy-c-bit-manipulation-solution/"
                    },
                    {
                        "username": "yashskd1026",
                        "content": "too many hard Questions\\uD83D\\uDE13"
                    },
                    {
                        "username": "Ankush-Kashyap",
                        "content": "What\\'s up with these hard questions? My brain just stopped responding. \\uD83D\\uDE11"
                    },
                    {
                        "username": "abhinavshukla693",
                        "content": "LeetCode has made its mission to make us suffer\\uD83D\\uDE25"
                    }
                ]
            },
            {
                "id": 1952829,
                "content": [
                    {
                        "username": "j0sal",
                        "content": "it was a medium level though"
                    },
                    {
                        "username": "omkarsk98",
                        "content": "Emotional damage"
                    },
                    {
                        "username": "nirajthakare",
                        "content": "never thought recursion could be the bforce \\uD83E\\uDD72"
                    },
                    {
                        "username": "gunjangnn",
                        "content": "Hi guys,\\n\\n\\nI came with this solution, but it fails as I\\'m not comparing in which choice we can get maximum achievable requests.\\n106/117 test cases passed.\\n\\ncan someone plz help in modifying this logic to work?\\n\\nclass Solution {\\n\\n    int achiReq = 0;\\n\\n    public int maximumRequests(int n, int[][] requests) {\\n        \\n        int[][] grid = new int[n][n];\\n        int[][] visited = new int[n][2];\\n\\n        for(int[] req : requests){\\n            grid[req[0]][req[1]] += 1;\\n        }\\n\\n        for(int i = 0; i < n; i++){\\n            dfs(grid, i, visited, 0);\\n        }\\n        \\n        return achiReq;\\n    }\\n\\n    public void dfs(int[][] grid, int i, int[][] visited, int reqCount){\\n\\n        visited[i][0] = 1;\\n        visited[i][1] = reqCount;\\n\\n        for(int j = 0; j < grid.length; j++){\\n            if(grid[i][j] > 0){\\n                grid[i][j] -= 1;\\n                if(visited[j][0] == 1 && reqCount + 1 - visited[j][1] >= 0){\\n                    achiReq += reqCount + 1 - visited[j][1];\\n                    dfs(grid, j, visited, visited[j][1]);\\n                } else {\\n                    dfs(grid, j, visited, reqCount + 1);\\n                }\\n            }\\n        }\\n\\n        visited[i][0] = 0;\\n    }\\n}"
                    },
                    {
                        "username": "bparanj",
                        "content": "The problem you\\'re trying to solve requires you to consider all possible combinations of fulfilling the transfer requests, and to find the maximum number of transfer requests that can be fulfilled without violating the constraints of the problem. Therefore, this problem requires a solution that searches the entire space of possible combinations, such as a depth-first search (DFS) or breadth-first search (BFS) with backtracking, to find the maximum number of requests that can be fulfilled.\\n\\nYour current implementation does a depth-first search through the transfer requests, but it appears to be missing the component where it checks all possible combinations. The function `dfs` seems to try to fulfill every transfer request it encounters without considering whether fulfilling a particular request is beneficial or not. This could lead to situations where fulfilling a request leads to fewer overall fulfillments, but because the request is fulfilled without consideration, it\\'s counted towards the final result.\\n\\nIn addition, you\\'re using a variable `achiReq` to keep track of the maximum number of achievable requests, but it\\'s not clear how this variable is updated correctly during the search. You might want to consider moving this variable inside the `dfs` function and updating it as part of the recursive call.\\n\\nOne way to address these issues is to adjust your DFS to a backtracking approach:\\n\\n1. Iterate through all possible combinations of requests. You can do this by creating a recursive function that considers both fulfilling and not fulfilling the current request.\\n\\n2. For each combination, calculate the number of requests that can be fulfilled (i.e., where the total number of employees in each building remains constant), and keep track of the maximum number of fulfillable requests.\\n\\n3. Return the maximum number of fulfillable requests.\\n"
                    },
                    {
                        "username": "gunjangnn",
                        "content": "logic is to use DFS and find cycles and in cycle add the cycle length to answer\\nprobably I need to check which cycle has max length then add it to answer and m struggling with this part"
                    },
                    {
                        "username": "Tillu__",
                        "content": "Never thought I could solve a hard problem on my first try!"
                    },
                    {
                        "username": "_anuj_jain_",
                        "content": "Happy Sunday :)\\n"
                    },
                    {
                        "username": "nikhilag84",
                        "content": "GUYS SEE THIS  SOLTUTION VERY EASY BIT MANIPULATION SOLUTION\\nhttps://leetcode.com/problems/maximum-number-of-achievable-transfer-requests/solutions/3706977/easy-c-bit-manipulation-solution/"
                    },
                    {
                        "username": "yashskd1026",
                        "content": "too many hard Questions\\uD83D\\uDE13"
                    },
                    {
                        "username": "Ankush-Kashyap",
                        "content": "What\\'s up with these hard questions? My brain just stopped responding. \\uD83D\\uDE11"
                    },
                    {
                        "username": "abhinavshukla693",
                        "content": "LeetCode has made its mission to make us suffer\\uD83D\\uDE25"
                    }
                ]
            },
            {
                "id": 1952816,
                "content": [
                    {
                        "username": "j0sal",
                        "content": "it was a medium level though"
                    },
                    {
                        "username": "omkarsk98",
                        "content": "Emotional damage"
                    },
                    {
                        "username": "nirajthakare",
                        "content": "never thought recursion could be the bforce \\uD83E\\uDD72"
                    },
                    {
                        "username": "gunjangnn",
                        "content": "Hi guys,\\n\\n\\nI came with this solution, but it fails as I\\'m not comparing in which choice we can get maximum achievable requests.\\n106/117 test cases passed.\\n\\ncan someone plz help in modifying this logic to work?\\n\\nclass Solution {\\n\\n    int achiReq = 0;\\n\\n    public int maximumRequests(int n, int[][] requests) {\\n        \\n        int[][] grid = new int[n][n];\\n        int[][] visited = new int[n][2];\\n\\n        for(int[] req : requests){\\n            grid[req[0]][req[1]] += 1;\\n        }\\n\\n        for(int i = 0; i < n; i++){\\n            dfs(grid, i, visited, 0);\\n        }\\n        \\n        return achiReq;\\n    }\\n\\n    public void dfs(int[][] grid, int i, int[][] visited, int reqCount){\\n\\n        visited[i][0] = 1;\\n        visited[i][1] = reqCount;\\n\\n        for(int j = 0; j < grid.length; j++){\\n            if(grid[i][j] > 0){\\n                grid[i][j] -= 1;\\n                if(visited[j][0] == 1 && reqCount + 1 - visited[j][1] >= 0){\\n                    achiReq += reqCount + 1 - visited[j][1];\\n                    dfs(grid, j, visited, visited[j][1]);\\n                } else {\\n                    dfs(grid, j, visited, reqCount + 1);\\n                }\\n            }\\n        }\\n\\n        visited[i][0] = 0;\\n    }\\n}"
                    },
                    {
                        "username": "bparanj",
                        "content": "The problem you\\'re trying to solve requires you to consider all possible combinations of fulfilling the transfer requests, and to find the maximum number of transfer requests that can be fulfilled without violating the constraints of the problem. Therefore, this problem requires a solution that searches the entire space of possible combinations, such as a depth-first search (DFS) or breadth-first search (BFS) with backtracking, to find the maximum number of requests that can be fulfilled.\\n\\nYour current implementation does a depth-first search through the transfer requests, but it appears to be missing the component where it checks all possible combinations. The function `dfs` seems to try to fulfill every transfer request it encounters without considering whether fulfilling a particular request is beneficial or not. This could lead to situations where fulfilling a request leads to fewer overall fulfillments, but because the request is fulfilled without consideration, it\\'s counted towards the final result.\\n\\nIn addition, you\\'re using a variable `achiReq` to keep track of the maximum number of achievable requests, but it\\'s not clear how this variable is updated correctly during the search. You might want to consider moving this variable inside the `dfs` function and updating it as part of the recursive call.\\n\\nOne way to address these issues is to adjust your DFS to a backtracking approach:\\n\\n1. Iterate through all possible combinations of requests. You can do this by creating a recursive function that considers both fulfilling and not fulfilling the current request.\\n\\n2. For each combination, calculate the number of requests that can be fulfilled (i.e., where the total number of employees in each building remains constant), and keep track of the maximum number of fulfillable requests.\\n\\n3. Return the maximum number of fulfillable requests.\\n"
                    },
                    {
                        "username": "gunjangnn",
                        "content": "logic is to use DFS and find cycles and in cycle add the cycle length to answer\\nprobably I need to check which cycle has max length then add it to answer and m struggling with this part"
                    },
                    {
                        "username": "Tillu__",
                        "content": "Never thought I could solve a hard problem on my first try!"
                    },
                    {
                        "username": "_anuj_jain_",
                        "content": "Happy Sunday :)\\n"
                    },
                    {
                        "username": "nikhilag84",
                        "content": "GUYS SEE THIS  SOLTUTION VERY EASY BIT MANIPULATION SOLUTION\\nhttps://leetcode.com/problems/maximum-number-of-achievable-transfer-requests/solutions/3706977/easy-c-bit-manipulation-solution/"
                    },
                    {
                        "username": "yashskd1026",
                        "content": "too many hard Questions\\uD83D\\uDE13"
                    },
                    {
                        "username": "Ankush-Kashyap",
                        "content": "What\\'s up with these hard questions? My brain just stopped responding. \\uD83D\\uDE11"
                    },
                    {
                        "username": "abhinavshukla693",
                        "content": "LeetCode has made its mission to make us suffer\\uD83D\\uDE25"
                    }
                ]
            },
            {
                "id": 1952800,
                "content": [
                    {
                        "username": "j0sal",
                        "content": "it was a medium level though"
                    },
                    {
                        "username": "omkarsk98",
                        "content": "Emotional damage"
                    },
                    {
                        "username": "nirajthakare",
                        "content": "never thought recursion could be the bforce \\uD83E\\uDD72"
                    },
                    {
                        "username": "gunjangnn",
                        "content": "Hi guys,\\n\\n\\nI came with this solution, but it fails as I\\'m not comparing in which choice we can get maximum achievable requests.\\n106/117 test cases passed.\\n\\ncan someone plz help in modifying this logic to work?\\n\\nclass Solution {\\n\\n    int achiReq = 0;\\n\\n    public int maximumRequests(int n, int[][] requests) {\\n        \\n        int[][] grid = new int[n][n];\\n        int[][] visited = new int[n][2];\\n\\n        for(int[] req : requests){\\n            grid[req[0]][req[1]] += 1;\\n        }\\n\\n        for(int i = 0; i < n; i++){\\n            dfs(grid, i, visited, 0);\\n        }\\n        \\n        return achiReq;\\n    }\\n\\n    public void dfs(int[][] grid, int i, int[][] visited, int reqCount){\\n\\n        visited[i][0] = 1;\\n        visited[i][1] = reqCount;\\n\\n        for(int j = 0; j < grid.length; j++){\\n            if(grid[i][j] > 0){\\n                grid[i][j] -= 1;\\n                if(visited[j][0] == 1 && reqCount + 1 - visited[j][1] >= 0){\\n                    achiReq += reqCount + 1 - visited[j][1];\\n                    dfs(grid, j, visited, visited[j][1]);\\n                } else {\\n                    dfs(grid, j, visited, reqCount + 1);\\n                }\\n            }\\n        }\\n\\n        visited[i][0] = 0;\\n    }\\n}"
                    },
                    {
                        "username": "bparanj",
                        "content": "The problem you\\'re trying to solve requires you to consider all possible combinations of fulfilling the transfer requests, and to find the maximum number of transfer requests that can be fulfilled without violating the constraints of the problem. Therefore, this problem requires a solution that searches the entire space of possible combinations, such as a depth-first search (DFS) or breadth-first search (BFS) with backtracking, to find the maximum number of requests that can be fulfilled.\\n\\nYour current implementation does a depth-first search through the transfer requests, but it appears to be missing the component where it checks all possible combinations. The function `dfs` seems to try to fulfill every transfer request it encounters without considering whether fulfilling a particular request is beneficial or not. This could lead to situations where fulfilling a request leads to fewer overall fulfillments, but because the request is fulfilled without consideration, it\\'s counted towards the final result.\\n\\nIn addition, you\\'re using a variable `achiReq` to keep track of the maximum number of achievable requests, but it\\'s not clear how this variable is updated correctly during the search. You might want to consider moving this variable inside the `dfs` function and updating it as part of the recursive call.\\n\\nOne way to address these issues is to adjust your DFS to a backtracking approach:\\n\\n1. Iterate through all possible combinations of requests. You can do this by creating a recursive function that considers both fulfilling and not fulfilling the current request.\\n\\n2. For each combination, calculate the number of requests that can be fulfilled (i.e., where the total number of employees in each building remains constant), and keep track of the maximum number of fulfillable requests.\\n\\n3. Return the maximum number of fulfillable requests.\\n"
                    },
                    {
                        "username": "gunjangnn",
                        "content": "logic is to use DFS and find cycles and in cycle add the cycle length to answer\\nprobably I need to check which cycle has max length then add it to answer and m struggling with this part"
                    },
                    {
                        "username": "Tillu__",
                        "content": "Never thought I could solve a hard problem on my first try!"
                    },
                    {
                        "username": "_anuj_jain_",
                        "content": "Happy Sunday :)\\n"
                    },
                    {
                        "username": "nikhilag84",
                        "content": "GUYS SEE THIS  SOLTUTION VERY EASY BIT MANIPULATION SOLUTION\\nhttps://leetcode.com/problems/maximum-number-of-achievable-transfer-requests/solutions/3706977/easy-c-bit-manipulation-solution/"
                    },
                    {
                        "username": "yashskd1026",
                        "content": "too many hard Questions\\uD83D\\uDE13"
                    },
                    {
                        "username": "Ankush-Kashyap",
                        "content": "What\\'s up with these hard questions? My brain just stopped responding. \\uD83D\\uDE11"
                    },
                    {
                        "username": "abhinavshukla693",
                        "content": "LeetCode has made its mission to make us suffer\\uD83D\\uDE25"
                    }
                ]
            },
            {
                "id": 1952798,
                "content": [
                    {
                        "username": "j0sal",
                        "content": "it was a medium level though"
                    },
                    {
                        "username": "omkarsk98",
                        "content": "Emotional damage"
                    },
                    {
                        "username": "nirajthakare",
                        "content": "never thought recursion could be the bforce \\uD83E\\uDD72"
                    },
                    {
                        "username": "gunjangnn",
                        "content": "Hi guys,\\n\\n\\nI came with this solution, but it fails as I\\'m not comparing in which choice we can get maximum achievable requests.\\n106/117 test cases passed.\\n\\ncan someone plz help in modifying this logic to work?\\n\\nclass Solution {\\n\\n    int achiReq = 0;\\n\\n    public int maximumRequests(int n, int[][] requests) {\\n        \\n        int[][] grid = new int[n][n];\\n        int[][] visited = new int[n][2];\\n\\n        for(int[] req : requests){\\n            grid[req[0]][req[1]] += 1;\\n        }\\n\\n        for(int i = 0; i < n; i++){\\n            dfs(grid, i, visited, 0);\\n        }\\n        \\n        return achiReq;\\n    }\\n\\n    public void dfs(int[][] grid, int i, int[][] visited, int reqCount){\\n\\n        visited[i][0] = 1;\\n        visited[i][1] = reqCount;\\n\\n        for(int j = 0; j < grid.length; j++){\\n            if(grid[i][j] > 0){\\n                grid[i][j] -= 1;\\n                if(visited[j][0] == 1 && reqCount + 1 - visited[j][1] >= 0){\\n                    achiReq += reqCount + 1 - visited[j][1];\\n                    dfs(grid, j, visited, visited[j][1]);\\n                } else {\\n                    dfs(grid, j, visited, reqCount + 1);\\n                }\\n            }\\n        }\\n\\n        visited[i][0] = 0;\\n    }\\n}"
                    },
                    {
                        "username": "bparanj",
                        "content": "The problem you\\'re trying to solve requires you to consider all possible combinations of fulfilling the transfer requests, and to find the maximum number of transfer requests that can be fulfilled without violating the constraints of the problem. Therefore, this problem requires a solution that searches the entire space of possible combinations, such as a depth-first search (DFS) or breadth-first search (BFS) with backtracking, to find the maximum number of requests that can be fulfilled.\\n\\nYour current implementation does a depth-first search through the transfer requests, but it appears to be missing the component where it checks all possible combinations. The function `dfs` seems to try to fulfill every transfer request it encounters without considering whether fulfilling a particular request is beneficial or not. This could lead to situations where fulfilling a request leads to fewer overall fulfillments, but because the request is fulfilled without consideration, it\\'s counted towards the final result.\\n\\nIn addition, you\\'re using a variable `achiReq` to keep track of the maximum number of achievable requests, but it\\'s not clear how this variable is updated correctly during the search. You might want to consider moving this variable inside the `dfs` function and updating it as part of the recursive call.\\n\\nOne way to address these issues is to adjust your DFS to a backtracking approach:\\n\\n1. Iterate through all possible combinations of requests. You can do this by creating a recursive function that considers both fulfilling and not fulfilling the current request.\\n\\n2. For each combination, calculate the number of requests that can be fulfilled (i.e., where the total number of employees in each building remains constant), and keep track of the maximum number of fulfillable requests.\\n\\n3. Return the maximum number of fulfillable requests.\\n"
                    },
                    {
                        "username": "gunjangnn",
                        "content": "logic is to use DFS and find cycles and in cycle add the cycle length to answer\\nprobably I need to check which cycle has max length then add it to answer and m struggling with this part"
                    },
                    {
                        "username": "Tillu__",
                        "content": "Never thought I could solve a hard problem on my first try!"
                    },
                    {
                        "username": "_anuj_jain_",
                        "content": "Happy Sunday :)\\n"
                    },
                    {
                        "username": "nikhilag84",
                        "content": "GUYS SEE THIS  SOLTUTION VERY EASY BIT MANIPULATION SOLUTION\\nhttps://leetcode.com/problems/maximum-number-of-achievable-transfer-requests/solutions/3706977/easy-c-bit-manipulation-solution/"
                    },
                    {
                        "username": "yashskd1026",
                        "content": "too many hard Questions\\uD83D\\uDE13"
                    },
                    {
                        "username": "Ankush-Kashyap",
                        "content": "What\\'s up with these hard questions? My brain just stopped responding. \\uD83D\\uDE11"
                    },
                    {
                        "username": "abhinavshukla693",
                        "content": "LeetCode has made its mission to make us suffer\\uD83D\\uDE25"
                    }
                ]
            }
        ]
    },
    {
        "title": "Find Nearest Right Node in Binary Tree",
        "question_content": null,
        "solutions": [],
        "discussions": [
            {
                "id": 1576275,
                "content": [
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for January, Week 4.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/find-nearest-right-node-in-binary-tree/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** BFS: Two Queues\n\n  \n**Approach 2:** BFS: One Queue + Sentinel\n\n  \n**Approach 3:** BFS: One Queue + Level Size Measurements\n\n  \n**Approach 4:** Recursive DFS: Preorder Traversal\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    }
                ]
            }
        ]
    }
]