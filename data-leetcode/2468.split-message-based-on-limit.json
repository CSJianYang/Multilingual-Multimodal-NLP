[
    {
        "title": "Split Message Based on Limit",
        "question_content": "You are given a string, message, and a positive integer, limit.\nYou must split message into one or more parts based on limit. Each resulting part should have the suffix \"<a/b>\", where \"b\" is to be replaced with the total number of parts and \"a\" is to be replaced with the index of the part, starting from 1 and going up to b. Additionally, the length of each resulting part (including its suffix) should be equal to limit, except for the last part whose length can be at most limit.\nThe resulting parts should be formed such that when their suffixes are removed and they are all concatenated in order, they should be equal to message. Also, the result should contain as few parts as possible.\nReturn the parts message would be split into as an array of strings. If it is impossible to split message as required, return an empty array.\n&nbsp;\nExample 1:\n\nInput: message = \"this is really a very awesome message\", limit = 9\nOutput: [\"thi<1/14>\",\"s i<2/14>\",\"s r<3/14>\",\"eal<4/14>\",\"ly <5/14>\",\"a v<6/14>\",\"ery<7/14>\",\" aw<8/14>\",\"eso<9/14>\",\"me<10/14>\",\" m<11/14>\",\"es<12/14>\",\"sa<13/14>\",\"ge<14/14>\"]\nExplanation:\nThe first 9 parts take 3 characters each from the beginning of message.\nThe next 5 parts take 2 characters each to finish splitting message. \nIn this example, each part, including the last, has length 9. \nIt can be shown it is not possible to split message into less than 14 parts.\n\nExample 2:\n\nInput: message = \"short message\", limit = 15\nOutput: [\"short mess<1/2>\",\"age<2/2>\"]\nExplanation:\nUnder the given constraints, the string can be split into two parts: \n- The first part comprises of the first 10 characters, and has a length 15.\n- The next part comprises of the last 3 characters, and has a length 8.\n\n&nbsp;\nConstraints:\n\n\t1 <= message.length <= 104\n\tmessage consists only of lowercase English letters and ' '.\n\t1 <= limit <= 104",
        "solutions": [
            {
                "id": 2807533,
                "title": "python-find-the-number-of-substrings",
                "content": "# **Explanation**\\nThe key question is to find out the number of split parts `k`.\\n\\n`cur` is the total string length of all indices,\\nlike the string length for \"123\" is 3.\\n`</>` takes 3 characters.\\nThe number `k` takes `len(str(k))` characters.\\n\\nIf `cur + len(s) + (3 + len(str(k))) * k > limit * k`,\\nmeans not enough characters to split `s`.\\n\\nIf `3 + len(str(k)) * 2 >= limit`,\\n`k` means `<k/k>` already takes `limit` characters,\\nit is impossible to split message as required.\\n\\nWe increment `k` from 0 until we find `k` that can split message `s` as required.\\n<br>\\n\\n# **Complexity**\\nTime `O(n)`\\nSpace `O(n)`\\n<br>\\n\\n**Python**\\n```py\\n    def splitMessage(self, s: str, limit: int) -> List[str]:\\n        cur = k = i = 0\\n        while 3 + len(str(k)) * 2 < limit and cur + len(s) + (3 + len(str(k))) * k > limit * k:\\n            k += 1\\n            cur += len(str(k))\\n        res = []\\n        if 3 + len(str(k)) * 2 < limit:\\n            for j in range(1, k + 1):\\n                l = limit - (len(str(j)) + 3 + len(str(k)))\\n                res.append(\\'%s<%s/%s>\\' % (s[i:i + l], j, k))\\n                i += l\\n        return res\\n```\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "```py\\n    def splitMessage(self, s: str, limit: int) -> List[str]:\\n        cur = k = i = 0\\n        while 3 + len(str(k)) * 2 < limit and cur + len(s) + (3 + len(str(k))) * k > limit * k:\\n            k += 1\\n            cur += len(str(k))\\n        res = []\\n        if 3 + len(str(k)) * 2 < limit:\\n            for j in range(1, k + 1):\\n                l = limit - (len(str(j)) + 3 + len(str(k)))\\n                res.append(\\'%s<%s/%s>\\' % (s[i:i + l], j, k))\\n                i += l\\n        return res\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2807759,
                "title": "python-binary-search-is-redundant-just-brute-force-it-explained",
                "content": "**\\u2705 IF YOU LIKE THIS SOLUTION, PLEASE UPVOTE.**\\n****\\nThis solution employs a brute force approach to find the minimal number of parts needed to split the string into parts of limited length with appended suffixes. Time complexity is linear: **O(N)**. Space complexity is linear: **O(N)**.\\n\\n**Comment.** Given the boundaries for this problem, i.e. `len(message) <= 10000`, and considering the fact that the minimal size of each part is `len(\"_<1/1>\") = 6`, we colcude that the maximal number of iterations in case of using a brute-force approach is `10000 / 6 = 1667`. That\\'s very cheap for a linear scan, so let\\'s brute force the number of parts `p` then use it to format a list of parts.\\n\\n**Python.**\\n```\\nclass Solution:\\n    def splitMessage(self, msg: str, lim: int) -> List[str]:\\n        \\n        def sz(n) : return len(str(n))                       # a helper function to get a number of digits\\n        \\n        p = a = 1                                            # a number of parts and a total length of a-indices\\n        \\n        while p * (sz(p) + 3) + a + len(msg) > p * lim:      # [1] check that current number of parts is not enough...\\n            if 3 + sz(p) * 2 >= lim : return []              # [2] ...or break if the separation is not possible\\n            p += 1                                           # [3] try an increased number of parts\\n            a += sz(p)                                       # [4] also, increase the total length of a-indices\\n        \\n        parts = []                                           # [5] at this point, we either obtained the minimal number \\n                                                             #     of parts \\'p\\' or have returned an empty list \\n        for i in range(1,p+1):\\n            j = lim - (sz(p)+sz(i)+3)                        # [6] for each part, find how many symbols to bite off \\n            part, msg = msg[0:j], msg[j:]                    # [7] bite off a piece of string...\\n            parts.append(f\"{part}<{i}/{p}>\")                 # [8] ...and format a suffix-tagged part\\n            \\n        return parts\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def splitMessage(self, msg: str, lim: int) -> List[str]:\\n        \\n        def sz(n) : return len(str(n))                       # a helper function to get a number of digits\\n        \\n        p = a = 1                                            # a number of parts and a total length of a-indices\\n        \\n        while p * (sz(p) + 3) + a + len(msg) > p * lim:      # [1] check that current number of parts is not enough...\\n            if 3 + sz(p) * 2 >= lim : return []              # [2] ...or break if the separation is not possible\\n            p += 1                                           # [3] try an increased number of parts\\n            a += sz(p)                                       # [4] also, increase the total length of a-indices\\n        \\n        parts = []                                           # [5] at this point, we either obtained the minimal number \\n                                                             #     of parts \\'p\\' or have returned an empty list \\n        for i in range(1,p+1):\\n            j = lim - (sz(p)+sz(i)+3)                        # [6] for each part, find how many symbols to bite off \\n            part, msg = msg[0:j], msg[j:]                    # [7] bite off a piece of string...\\n            parts.append(f\"{part}<{i}/{p}>\")                 # [8] ...and format a suffix-tagged part\\n            \\n        return parts\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2807165,
                "title": "brute-force-simple-approach-c-explained",
                "content": "As the problem required to find minimum number of parts, Let us traverse from 1 to see if we can divide our message with current number of parts.\\n\\nLet us do some calculation now.\\n\\n<b>What will be the length of the string after we attach the extra info \"<a/b>\" with each part?</b>\\n\\nLet the number of parts  = <b>N</b>\\nThen with each part we will attach \"</>\". Hence we need extra <b>3*N</b> character.\\nWe will also attach the value b= N with each part.Then we need extra <b>Nx(number of digits in N)</b>.\\nFinally we will attach the value of <b>a </b> with each part, which requires the <b>sum of number of digits from 1 to N</b>.\\nHence the actual size of string will be = <b>N + 3*N + Nx(number of digits in N) +  <span>&Sigma;</span>(number of digits from 1 to N)<b>\\n\\nNow we just need to check if we can divide the size in N parts where each part will contain <b>limit</b> characters except the last one.\\n\\nSample Code:\\n```\\nclass Solution {\\npublic:\\n    vector<string> splitMessage(string message, int limit) {\\n        vector<int>dig(10001),cum_sum(10001);// contains number of digits in N and cumulative sum of number of digits.\\n        // find number of digits in X.\\n        auto number_of_digits=[](int x){\\n            int ret = 0;\\n            while(x){\\n                ret++;\\n                x/=10;\\n            }\\n            return ret;\\n        };\\n        for(int i=1;i<=10000;i++){\\n            dig[i] = number_of_digits(i); \\n            cum_sum[i] = cum_sum[i-1]+dig[i];\\n        }\\n        \\n        int actual_size = message.size();\\n        vector<string>ret;\\n        for(int N=1;N<=actual_size;N++){\\n            int newSize = actual_size+3*N+dig[N]*N+cum_sum[N];\\n            \\n            //check if possible to achieve the result.\\n            if((newSize+limit-1)/limit==N){\\n                string s;\\n                int cur = 1;\\n                //for each part we need to add <a/b> with it\\n                int extra = dig[N]+3;//as a part changes we do it in runtime\\n                for(char&c:message){\\n                    s+=c;\\n                    if(s.size()+dig[cur]+extra==limit){\\n                        s+=\"<\"+to_string(cur)+\"/\"+to_string(N)+\">\";\\n                        ret.push_back(s);\\n                        s.clear();\\n                        cur++;\\n                    }\\n                }\\n                //if last part contains less than limit characters.\\n                if(s.size()){\\n                      s+=\"<\"+to_string(cur)+\"/\"+to_string(N)+\">\";\\n                        ret.push_back(s);\\n                        s.clear();\\n                }\\n                return ret;\\n            }\\n        }\\n        return ret;\\n    }\\n};\\n```\\n\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> splitMessage(string message, int limit) {\\n        vector<int>dig(10001),cum_sum(10001);// contains number of digits in N and cumulative sum of number of digits.\\n        // find number of digits in X.\\n        auto number_of_digits=[](int x){\\n            int ret = 0;\\n            while(x){\\n                ret++;\\n                x/=10;\\n            }\\n            return ret;\\n        };\\n        for(int i=1;i<=10000;i++){\\n            dig[i] = number_of_digits(i); \\n            cum_sum[i] = cum_sum[i-1]+dig[i];\\n        }\\n        \\n        int actual_size = message.size();\\n        vector<string>ret;\\n        for(int N=1;N<=actual_size;N++){\\n            int newSize = actual_size+3*N+dig[N]*N+cum_sum[N];\\n            \\n            //check if possible to achieve the result.\\n            if((newSize+limit-1)/limit==N){\\n                string s;\\n                int cur = 1;\\n                //for each part we need to add <a/b> with it\\n                int extra = dig[N]+3;//as a part changes we do it in runtime\\n                for(char&c:message){\\n                    s+=c;\\n                    if(s.size()+dig[cur]+extra==limit){\\n                        s+=\"<\"+to_string(cur)+\"/\"+to_string(N)+\">\";\\n                        ret.push_back(s);\\n                        s.clear();\\n                        cur++;\\n                    }\\n                }\\n                //if last part contains less than limit characters.\\n                if(s.size()){\\n                      s+=\"<\"+to_string(cur)+\"/\"+to_string(N)+\">\";\\n                        ret.push_back(s);\\n                        s.clear();\\n                }\\n                return ret;\\n            }\\n        }\\n        return ret;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2819118,
                "title": "binary-search-does-not-work-counterexample-added",
                "content": "# Counter example\\n```\\n\"abbababbbaaa aabaa a\"\\n8\\n```\\n\\nThe above test can be split into 7 tokens, can\\'t be split into 10 tokens and it can be split again into 11 tokens. This problem does not have the BS property.\\n\\nSome of the incorrect BS solutions passed these tests, because of the order in which they check the values.\\n\\nIf they hit 11 first, they detect, it is possible, so they go to the left and they find the 7 solution later.\\n\\nIf they hit 10 first, they detect it is impossible and they go right, finding the 11 solution. It is possible to design the test cases to kill all BS solutions though.",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n\"abbababbbaaa aabaa a\"\\n8\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2814888,
                "title": "c-solution-with-explanation",
                "content": "```\\n// First I thought of binary search , but realised soon , I can iterate over all the b\\'s.\\n// Let\\'s say answer is of size x , We know x-1 words will have length limit & last word should be <=limit\\n// Validate the last word , picking b greedily  :)\\nclass Solution {\\npublic:\\n    vector<string> splitMessage(string message, int limit) {\\n        int b = 0 , cnt = 0 , sm = 0;\\n        vector<string> ans;\\n        for(int i=1; i<=10000; i++) {\\n            sm+=Size(i);  // sum of length of (\\'1\\') + (\\'2\\')... (\\'i\\')  , we are calculating sum of length of all a\\'s.\\n            int cnt = ((3 + Size(i)) * i) + message.size() + sm;   // sum of (3 is \"</>\"  + i\\'s size ) * i times , message , sm \\n            int len = (i-1) * limit; // till second last\\n            if(cnt - len <= limit) {  // if last is bigger than limit , its invalid!\\n                b = i;\\n                break;\\n            }\\n        }\\n        string s = \"\";\\n        cnt = 1;\\n        for(int i=0; i<message.size(); i++) {\\n              if(limit - (3 + Size(cnt) + Size(b) + (int)s.size())>0) {\\n                   s+=message[i];\\n              }else {\\n                   string word = s + \"<\" + to_string(cnt) + \"/\" + to_string(b) + \">\";\\n                   ans.push_back(word);\\n                   s = message[i];\\n                   cnt++;\\n              }\\n        }\\n         string word = s + \"<\" + to_string(cnt) + \"/\" + to_string(b) + \">\";\\n         ans.push_back(word);\\n         if(cnt>b || word.size()>limit) return {};   // cnt is last value of a , which should never be > than b , also last word size should be <= limit!\\n        return ans;\\n    }\\n    int Size(int n) {\\n         return to_string(n).size();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Math"
                ],
                "code": "```\\n// First I thought of binary search , but realised soon , I can iterate over all the b\\'s.\\n// Let\\'s say answer is of size x , We know x-1 words will have length limit & last word should be <=limit\\n// Validate the last word , picking b greedily  :)\\nclass Solution {\\npublic:\\n    vector<string> splitMessage(string message, int limit) {\\n        int b = 0 , cnt = 0 , sm = 0;\\n        vector<string> ans;\\n        for(int i=1; i<=10000; i++) {\\n            sm+=Size(i);  // sum of length of (\\'1\\') + (\\'2\\')... (\\'i\\')  , we are calculating sum of length of all a\\'s.\\n            int cnt = ((3 + Size(i)) * i) + message.size() + sm;   // sum of (3 is \"</>\"  + i\\'s size ) * i times , message , sm \\n            int len = (i-1) * limit; // till second last\\n            if(cnt - len <= limit) {  // if last is bigger than limit , its invalid!\\n                b = i;\\n                break;\\n            }\\n        }\\n        string s = \"\";\\n        cnt = 1;\\n        for(int i=0; i<message.size(); i++) {\\n              if(limit - (3 + Size(cnt) + Size(b) + (int)s.size())>0) {\\n                   s+=message[i];\\n              }else {\\n                   string word = s + \"<\" + to_string(cnt) + \"/\" + to_string(b) + \">\";\\n                   ans.push_back(word);\\n                   s = message[i];\\n                   cnt++;\\n              }\\n        }\\n         string word = s + \"<\" + to_string(cnt) + \"/\" + to_string(b) + \">\";\\n         ans.push_back(word);\\n         if(cnt>b || word.size()>limit) return {};   // cnt is last value of a , which should never be > than b , also last word size should be <= limit!\\n        return ans;\\n    }\\n    int Size(int n) {\\n         return to_string(n).size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2812357,
                "title": "binary-search",
                "content": "This is an old problem known as SMS split (SMS messages are limited to 160 characters).\\n\\nWe can use a binary search to find out the number of messages. We just need to make this search efficient (e.g. no string creation).\\n\\n> Note that first we need to find the smallest number of digits in `b`, e.g. 1 (up to 9 parts), 2 (up to 99), 3 (up to 999), and so on.\\n\\nKnowing the number of messages, we then can build out splits.\\n\\n**C++**\\n```cpp\\nbool binarySearch(int sz, int limit, int m) {\\n    int len_a = 1, up = 9, len_b = to_string(m).size();\\n    for (int a = 1; a <= m && sz > 0; ++a) {\\n        sz -= limit - 3 - len_a - len_b;\\n        if (a == up) {\\n            ++len_a;\\n            up = up * 10 + 9;\\n        }\\n    }\\n    return sz <= 0;\\n}\\nvector<string> splitMessage(string mess, int limit) {\\n    int l = 1, r = 9, sz = mess.size();\\n    vector<string> res;\\n    while (l <= sz && !binarySearch(sz, limit, r)) {\\n        l *= 10;\\n        r = min(r * 10 + 9, sz + 1);\\n    }\\n    if (l <= sz) {\\n        while (l < r)\\n            if (int m = (l + r) / 2; binarySearch(sz, limit, m))\\n                r = m;\\n            else\\n                l = m + 1;\\n        for (int i = 0, a = 1; a <= l; ++a) {\\n            string suff = \"<\" + to_string(a) + \"/\" + to_string(l) + \">\";\\n            res.push_back(mess.substr(i, limit - suff.size()) + suff);\\n            i += limit - suff.size();\\n        }\\n    }\\n    return res;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```cpp\\nbool binarySearch(int sz, int limit, int m) {\\n    int len_a = 1, up = 9, len_b = to_string(m).size();\\n    for (int a = 1; a <= m && sz > 0; ++a) {\\n        sz -= limit - 3 - len_a - len_b;\\n        if (a == up) {\\n            ++len_a;\\n            up = up * 10 + 9;\\n        }\\n    }\\n    return sz <= 0;\\n}\\nvector<string> splitMessage(string mess, int limit) {\\n    int l = 1, r = 9, sz = mess.size();\\n    vector<string> res;\\n    while (l <= sz && !binarySearch(sz, limit, r)) {\\n        l *= 10;\\n        r = min(r * 10 + 9, sz + 1);\\n    }\\n    if (l <= sz) {\\n        while (l < r)\\n            if (int m = (l + r) / 2; binarySearch(sz, limit, m))\\n                r = m;\\n            else\\n                l = m + 1;\\n        for (int i = 0, a = 1; a <= l; ++a) {\\n            string suff = \"<\" + to_string(a) + \"/\" + to_string(l) + \">\";\\n            res.push_back(mess.substr(i, limit - suff.size()) + suff);\\n            i += limit - suff.size();\\n        }\\n    }\\n    return res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2808041,
                "title": "binary-search-simple-approach-c-explaination-clear-code",
                "content": "In this problem, we are sure that if we give 1 token to every element we get the one possible distribution but it is not the ans, but if we take it as one possible chance of answer so our distribution will be from 1 to n (length of the string). \\nNow first we check for the middle one. If the answer is possible we can return it. but If answer is not possible from that partition and the size of string is greater than the token size than it is sure that the ans present in the lower half then we skip it upper and check for the lower half and vice versa.\\nFor elimination the halfs we use binary search O(log n) and to check the possibility of ans we traverse to whole string O(n).\\nSo the time Complexity of program is O(n log n).\\n\\n\\n\\n```\\nclass Solution {\\npublic:\\n    vector<string> splitMessage(string message, int limit) {\\n        return solution(message,limit,message.size());\\n    }\\nprivate:\\n    vector<string> solution(string m,int limit,int n) {\\n        int i=1,j=n;\\n        while(i<=j) {\\n            int mid = (i+j)/2;\\n            pair<vector<string>,int> ans = get_str(m,limit,mid);\\n            if(ans.second == 0) return ans.first;\\n            else if(ans.second==-1) i = mid+1;\\n            else j = mid-1;\\n        }\\n        return {};\\n    }\\n    \\n    pair<vector<string>,int> get_str(string m,int limit,int total) {\\n        string temp = to_string(total);\\n        string pre = \"\";\\n        int num = 1;\\n        string check = to_string(num);\\n        vector<string> ans;\\n        for(int i=0 ; i<m.length() ; ++i) {\\n            if(check.length()+temp.length()+3 >= limit) return {{},-1};\\n            if(pre.size()+check.length()+temp.length()+3 == limit) {\\n                string insert = pre;\\n                insert.push_back(\\'<\\');\\n                insert.append(check);\\n                insert.push_back(\\'/\\');\\n                insert.append(temp);\\n                insert.push_back(\\'>\\');\\n                ans.push_back(insert);\\n                pre = \"\";\\n                i-=1;\\n                num+=1;\\n                check = to_string(num);\\n            }\\n            else {\\n                pre.push_back(m[i]);\\n            }\\n        }\\n        string insert = pre;\\n        insert.push_back(\\'<\\');\\n        insert.append(check);\\n        insert.push_back(\\'/\\');\\n        insert.append(temp);\\n        insert.push_back(\\'>\\');\\n        ans.push_back(insert);\\n        if(num == total) return {ans,0};\\n        else if(num > total) return {{},-1};\\n        return {{},1};\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> splitMessage(string message, int limit) {\\n        return solution(message,limit,message.size());\\n    }\\nprivate:\\n    vector<string> solution(string m,int limit,int n) {\\n        int i=1,j=n;\\n        while(i<=j) {\\n            int mid = (i+j)/2;\\n            pair<vector<string>,int> ans = get_str(m,limit,mid);\\n            if(ans.second == 0) return ans.first;\\n            else if(ans.second==-1) i = mid+1;\\n            else j = mid-1;\\n        }\\n        return {};\\n    }\\n    \\n    pair<vector<string>,int> get_str(string m,int limit,int total) {\\n        string temp = to_string(total);\\n        string pre = \"\";\\n        int num = 1;\\n        string check = to_string(num);\\n        vector<string> ans;\\n        for(int i=0 ; i<m.length() ; ++i) {\\n            if(check.length()+temp.length()+3 >= limit) return {{},-1};\\n            if(pre.size()+check.length()+temp.length()+3 == limit) {\\n                string insert = pre;\\n                insert.push_back(\\'<\\');\\n                insert.append(check);\\n                insert.push_back(\\'/\\');\\n                insert.append(temp);\\n                insert.push_back(\\'>\\');\\n                ans.push_back(insert);\\n                pre = \"\";\\n                i-=1;\\n                num+=1;\\n                check = to_string(num);\\n            }\\n            else {\\n                pre.push_back(m[i]);\\n            }\\n        }\\n        string insert = pre;\\n        insert.push_back(\\'<\\');\\n        insert.append(check);\\n        insert.push_back(\\'/\\');\\n        insert.append(temp);\\n        insert.push_back(\\'>\\');\\n        ans.push_back(insert);\\n        if(num == total) return {ans,0};\\n        else if(num > total) return {{},-1};\\n        return {{},1};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2807648,
                "title": "simple-approach-c-check-for-every-number-of-spilit",
                "content": "```\\nclass Solution {\\npublic:\\n    string getSuffix(int a,int b){\\n        string suffix = \"<\" + to_string(a) + \"/\" + to_string(b) + \">\";\\n        return suffix; \\n    }\\n    vector<string> splitMessage(string s, int limit) {\\n        if(limit < 6)\\n            return {};\\n        int sum = 0;\\n        int i;\\n        for(i = 1;true;i++){\\n            string a = to_string(i);\\n\\t\\t\\tsum += 3 + a.size();         //space required to  adjust \"<a/>\" after ith spilit\\n\\t\\t\\t/*\\n\\t\\t\\t\\tlimit*i = total space we get after ith spilit\\n\\t\\t\\t\\tsum = space required to  adjust \"<a/>\" after ith spilit\\n\\t\\t\\t\\ta.size()*i = space required to adjust \"b\" after the ith spilit\\n\\t\\t\\t\\tthen (limit*i  - sum - a.size()*i ) represent the space used for adjusting the string\\n\\t\\t\\t\\tand when it is greater than size of string we got the total numner of spilit required\\n\\t\\t\\t*/\\n            if(limit*i  - sum - a.size()*i >= s.size())           \\n                break;\\n\\t\\t\\t\\t\\n\\t\\t\\t// if the total space is used for adjusting the suffix part only then we can\\'t spilit and return\\n            if(limit <= 3 + a.size() + a.size())\\n                return {};\\n        }\\n        int k = 0;\\n        vector<string> res(i,\"\");\\n        for(int j = 1;j <= i;j++){\\n            string suffix = getSuffix(j,i);\\n            for(int l = 0;l < limit - suffix.size() && l +k < s.size();l++)\\n                res[j-1] += s[l+k];\\n            \\n            \\n            res[j-1] += suffix;\\n            k += limit - suffix.size();\\n        }\\n        return res;\\n    }\\n};\\n```\\n\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string getSuffix(int a,int b){\\n        string suffix = \"<\" + to_string(a) + \"/\" + to_string(b) + \">\";\\n        return suffix; \\n    }\\n    vector<string> splitMessage(string s, int limit) {\\n        if(limit < 6)\\n            return {};\\n        int sum = 0;\\n        int i;\\n        for(i = 1;true;i++){\\n            string a = to_string(i);\\n\\t\\t\\tsum += 3 + a.size();         //space required to  adjust \"<a/>\" after ith spilit\\n\\t\\t\\t/*\\n\\t\\t\\t\\tlimit*i = total space we get after ith spilit\\n\\t\\t\\t\\tsum = space required to  adjust \"<a/>\" after ith spilit\\n\\t\\t\\t\\ta.size()*i = space required to adjust \"b\" after the ith spilit\\n\\t\\t\\t\\tthen (limit*i  - sum - a.size()*i ) represent the space used for adjusting the string\\n\\t\\t\\t\\tand when it is greater than size of string we got the total numner of spilit required\\n\\t\\t\\t*/\\n            if(limit*i  - sum - a.size()*i >= s.size())           \\n                break;\\n\\t\\t\\t\\t\\n\\t\\t\\t// if the total space is used for adjusting the suffix part only then we can\\'t spilit and return\\n            if(limit <= 3 + a.size() + a.size())\\n                return {};\\n        }\\n        int k = 0;\\n        vector<string> res(i,\"\");\\n        for(int j = 1;j <= i;j++){\\n            string suffix = getSuffix(j,i);\\n            for(int l = 0;l < limit - suffix.size() && l +k < s.size();l++)\\n                res[j-1] += s[l+k];\\n            \\n            \\n            res[j-1] += suffix;\\n            k += limit - suffix.size();\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2807288,
                "title": "java-divide-stage-solution",
                "content": "```\\nclass Solution {\\n    public String[] splitMessage(String message, int limit) {\\n        int[] stgTable = {\\n                (limit - 5) * 9,\\n                (limit - 6) * 9 + (limit - 7) * 90,\\n                (limit - 7) * 9 + (limit - 8) * 90 + (limit - 9) * 900,\\n                (limit - 8) * 9 + (limit - 9) * 90 + (limit - 10) * 900 + (limit - 11) * 9000,\\n        };\\n        int l = message.length(), stg = 0;\\n        while (stg < stgTable.length) {\\n            if (stgTable[stg] >= l) break;\\n            stg++;\\n        }\\n        if (stg == stgTable.length) return new String[0];\\n        ArrayList<String> list = new ArrayList<>();\\n        int idx = 1, strIdx = 0;\\n        for (int i = 0; i <= stg; i++) {\\n            int size = limit - 5 - stg - i;\\n            for (int j = 0; j < 9 * Math.pow(10, i) && strIdx < message.length(); j++) {\\n                list.add(message.substring(strIdx, Math.min(message.length(), strIdx + size)) + \"<\" + idx);\\n                strIdx += size;\\n                idx++;\\n            }\\n        }\\n        String[] res = list.toArray(new String[]{});\\n        for (int i = 0; i < res.length; i++)\\n            res[i] = res[i] + \"/\" + (idx - 1) + \">\";\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String[] splitMessage(String message, int limit) {\\n        int[] stgTable = {\\n                (limit - 5) * 9,\\n                (limit - 6) * 9 + (limit - 7) * 90,\\n                (limit - 7) * 9 + (limit - 8) * 90 + (limit - 9) * 900,\\n                (limit - 8) * 9 + (limit - 9) * 90 + (limit - 10) * 900 + (limit - 11) * 9000,\\n        };\\n        int l = message.length(), stg = 0;\\n        while (stg < stgTable.length) {\\n            if (stgTable[stg] >= l) break;\\n            stg++;\\n        }\\n        if (stg == stgTable.length) return new String[0];\\n        ArrayList<String> list = new ArrayList<>();\\n        int idx = 1, strIdx = 0;\\n        for (int i = 0; i <= stg; i++) {\\n            int size = limit - 5 - stg - i;\\n            for (int j = 0; j < 9 * Math.pow(10, i) && strIdx < message.length(); j++) {\\n                list.add(message.substring(strIdx, Math.min(message.length(), strIdx + size)) + \"<\" + idx);\\n                strIdx += size;\\n                idx++;\\n            }\\n        }\\n        String[] res = list.toArray(new String[]{});\\n        for (int i = 0; i < res.length; i++)\\n            res[i] = res[i] + \"/\" + (idx - 1) + \">\";\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2809622,
                "title": "c-try-to-find-the-optimal-b-since-it-is-affecting-suffix-length",
                "content": "we know that the `<a/b>` suffix is dependent on `b` and `a` goes till `b`,  so if we can somehow try to find the optimal `b`, we should be able to get the answer.\\n\\nHow to find optimal `b` - \\n\\nWe know that exact `b` does not matter, the only thing that matters is the length of `b`. Since the length of the input string is `10^4`, we know `b` would never have more than `4` digits in suffix.\\n\\nFirst we try to find out what would be length of `b` in the optimal answer. and we try to build the string. since `a` goes till `b` If we were able to find an optimal `b` then last `a` is your `b` since we are iterating from smallest length to largest length of `b`.\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int getLength(int n) {\\n        return to_string(n).size();\\n    }\\n    \\n    int getPossibleB(const string &message, int &limit) {\\n        int n = message.size();\\n        for (int b = 1; b <= 4; ++b) {\\n            bool isPossible = true;\\n            int a = 1;\\n            for (int j = 0; j < n; ) {\\n                if (getLength(a) > b) {\\n                    isPossible = false;\\n                    break;\\n                }\\n                int suffix = 1 + getLength(a) + 1 + b + 1; //<a/b>\\n                int rem = limit - suffix;\\n                j += rem;\\n                ++a;\\n            }\\n            if (isPossible) return a - 1;\\n        }\\n        return -1;\\n    }\\n    \\n    vector<string> getSplitString(const string &message, int &limit, int &b) {\\n        int n = message.size();\\n        int a = 1;\\n        vector<string> res;\\n        string bstring = to_string(b);\\n        for (int j = 0; j < n; ) {\\n            string suffix = \\'<\\' + to_string(a) + \\'/\\' + bstring + \\'>\\';\\n            int rem = limit - suffix.size();\\n            ++a;\\n            res.push_back(message.substr(j, rem) + suffix);\\n            j += rem;\\n        }\\n        return res;\\n    }\\n    \\n    vector<string> splitMessage(string message, int limit) {\\n        int b = getPossibleB(message, limit);\\n        if (b == -1) return {};\\n        return getSplitString(message, limit, b);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    int getLength(int n) {\\n        return to_string(n).size();\\n    }\\n    \\n    int getPossibleB(const string &message, int &limit) {\\n        int n = message.size();\\n        for (int b = 1; b <= 4; ++b) {\\n            bool isPossible = true;\\n            int a = 1;\\n            for (int j = 0; j < n; ) {\\n                if (getLength(a) > b) {\\n                    isPossible = false;\\n                    break;\\n                }\\n                int suffix = 1 + getLength(a) + 1 + b + 1; //<a/b>\\n                int rem = limit - suffix;\\n                j += rem;\\n                ++a;\\n            }\\n            if (isPossible) return a - 1;\\n        }\\n        return -1;\\n    }\\n    \\n    vector<string> getSplitString(const string &message, int &limit, int &b) {\\n        int n = message.size();\\n        int a = 1;\\n        vector<string> res;\\n        string bstring = to_string(b);\\n        for (int j = 0; j < n; ) {\\n            string suffix = \\'<\\' + to_string(a) + \\'/\\' + bstring + \\'>\\';\\n            int rem = limit - suffix.size();\\n            ++a;\\n            res.push_back(message.substr(j, rem) + suffix);\\n            j += rem;\\n        }\\n        return res;\\n    }\\n    \\n    vector<string> splitMessage(string message, int limit) {\\n        int b = getPossibleB(message, limit);\\n        if (b == -1) return {};\\n        return getSplitString(message, limit, b);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2807275,
                "title": "python-tricky-solution",
                "content": "```python\\nr = -1\\nn = len(message)\\ns = (limit - 5) * 9\\nif s >= n:\\n\\tr = 9 - (s - n) // (limit - 5)\\nelse:\\n\\ts = (limit - 6) * 9 + (limit - 7) * 90\\n\\tif s >= n:\\n\\t\\tr = 99 - (s - n) // (limit - 7)\\n\\telse:\\n\\t\\ts = (limit - 7) * 9 + (limit - 8) * 90 + (limit - 9) * 900\\n\\t\\tif s >= n:\\n\\t\\t\\tr = 999 - (s - n) // (limit - 9)\\n\\t\\telse:\\n\\t\\t\\ts = (limit - 8) * 9 + (limit - 9) * 90 + (limit - 10) * 900 + (limit - 11) * 9000\\n\\t\\t\\tif s >= n:\\n\\t\\t\\t\\tr = 9999 - (s - n) // (limit - 11)\\n\\t\\t\\telse:\\n\\t\\t\\t\\ts = (limit - 9) * 9 + (limit - 10) * 90 + (limit - 11) * 900 + (limit - 12) * 9000 + (limit - 13) * 90000\\n\\t\\t\\t\\tif s >= n:\\n\\t\\t\\t\\t\\tr = 99999 - (s - n) // (limit - 13)\\nif r == -1:\\n\\treturn []\\nj = 0\\nres = []\\nfor i in range(1, r + 1):\\n\\tt = \"<\" + str(i) + \"/\" + str(r) + \">\"\\n\\td = limit - len(t)\\n\\tres.append(message[j : j + d] + t)\\n\\tj += d\\nreturn res\\n```\\n",
                "solutionTags": [],
                "code": "```python\\nr = -1\\nn = len(message)\\ns = (limit - 5) * 9\\nif s >= n:\\n\\tr = 9 - (s - n) // (limit - 5)\\nelse:\\n\\ts = (limit - 6) * 9 + (limit - 7) * 90\\n\\tif s >= n:\\n\\t\\tr = 99 - (s - n) // (limit - 7)\\n\\telse:\\n\\t\\ts = (limit - 7) * 9 + (limit - 8) * 90 + (limit - 9) * 900\\n\\t\\tif s >= n:\\n\\t\\t\\tr = 999 - (s - n) // (limit - 9)\\n\\t\\telse:\\n\\t\\t\\ts = (limit - 8) * 9 + (limit - 9) * 90 + (limit - 10) * 900 + (limit - 11) * 9000\\n\\t\\t\\tif s >= n:\\n\\t\\t\\t\\tr = 9999 - (s - n) // (limit - 11)\\n\\t\\t\\telse:\\n\\t\\t\\t\\ts = (limit - 9) * 9 + (limit - 10) * 90 + (limit - 11) * 900 + (limit - 12) * 9000 + (limit - 13) * 90000\\n\\t\\t\\t\\tif s >= n:\\n\\t\\t\\t\\t\\tr = 99999 - (s - n) // (limit - 13)\\nif r == -1:\\n\\treturn []\\nj = 0\\nres = []\\nfor i in range(1, r + 1):\\n\\tt = \"<\" + str(i) + \"/\" + str(r) + \">\"\\n\\td = limit - len(t)\\n\\tres.append(message[j : j + d] + t)\\n\\tj += d\\nreturn res\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2807228,
                "title": "java-check-all-possible-suffix-lengths",
                "content": "```\\nclass Solution {\\n    public String[] splitMessage(String message, int limit) {\\n        // since message length can be at most 10^4, we cant\\n        // possibly have more than 10^5-1 parts, or 5 digits in length\\n        for (int numDigits = 1; numDigits <= 5; numDigits++) {\\n            int maxParts = (int)Math.pow(10, numDigits) - 1;\\n            \\n            // determine if we can reach the end of message with the\\n            // maximum number of parts, if so we have our answer\\n            int idx = 0;\\n            for (int part = 1; part <= maxParts; part++) {\\n                int suffixLen = String.valueOf(part).length() + numDigits + 3;\\n                idx += limit - suffixLen;\\n                \\n                if (idx >= message.length()) {\\n                    // System.out.println(part);\\n                    return createOutput(message, limit, part);\\n                }\\n            }\\n        }\\n        \\n        return new String[0];\\n    }\\n    \\n    private String[] createOutput(String message, int limit, int numParts) {\\n        String[] output = new String[numParts];\\n        int idx = 0;\\n        \\n        for (int i = 1; i <= numParts; i++) {\\n            String suffix = \"<\" + i + \"/\" + numParts + \">\";\\n            int contentLen = limit - suffix.length();\\n            \\n            // be sure to handle last part being shorter than limit\\n            int end = Math.min(idx + contentLen, message.length());\\n            \\n            output[i - 1] = message.substring(idx, end) + suffix;\\n            idx += contentLen;\\n        }\\n        \\n        return output;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public String[] splitMessage(String message, int limit) {\\n        // since message length can be at most 10^4, we cant\\n        // possibly have more than 10^5-1 parts, or 5 digits in length\\n        for (int numDigits = 1; numDigits <= 5; numDigits++) {\\n            int maxParts = (int)Math.pow(10, numDigits) - 1;\\n            \\n            // determine if we can reach the end of message with the\\n            // maximum number of parts, if so we have our answer\\n            int idx = 0;\\n            for (int part = 1; part <= maxParts; part++) {\\n                int suffixLen = String.valueOf(part).length() + numDigits + 3;\\n                idx += limit - suffixLen;\\n                \\n                if (idx >= message.length()) {\\n                    // System.out.println(part);\\n                    return createOutput(message, limit, part);\\n                }\\n            }\\n        }\\n        \\n        return new String[0];\\n    }\\n    \\n    private String[] createOutput(String message, int limit, int numParts) {\\n        String[] output = new String[numParts];\\n        int idx = 0;\\n        \\n        for (int i = 1; i <= numParts; i++) {\\n            String suffix = \"<\" + i + \"/\" + numParts + \">\";\\n            int contentLen = limit - suffix.length();\\n            \\n            // be sure to handle last part being shorter than limit\\n            int end = Math.min(idx + contentLen, message.length());\\n            \\n            output[i - 1] = message.substring(idx, end) + suffix;\\n            idx += contentLen;\\n        }\\n        \\n        return output;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2807139,
                "title": "binary-search-for-optimal-split",
                "content": "```\\nclass Solution:\\n    def getsuffixes(self, n):\\n        return [f\"<{i}/{n}>\" for i in range(1, n + 1)]\\n    \\n    def splitMessage(self, message: str, limit: int) -> List[str]:\\n        n = len(message)\\n        if n + 5 <= limit:\\n            return [f\"{message}<1/1>\"]\\n        beg = 1\\n        end = n\\n        finalres = []\\n        while beg <= end:\\n            l = (beg + end) // 2\\n            suff = self.getsuffixes(l)\\n            res = []\\n            i = 0\\n            for j in range(l):\\n                k = limit - len(suff[j])\\n                res.append(f\"{message[i : i + k]}{suff[j]}\")\\n                i += k\\n            if i < n:\\n                beg = l + 1\\n            elif len(res[-2]) != limit:\\n                end = l - 1\\n            else:\\n                finalres = res\\n                break\\n        return finalres\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def getsuffixes(self, n):\\n        return [f\"<{i}/{n}>\" for i in range(1, n + 1)]\\n    \\n    def splitMessage(self, message: str, limit: int) -> List[str]:\\n        n = len(message)\\n        if n + 5 <= limit:\\n            return [f\"{message}<1/1>\"]\\n        beg = 1\\n        end = n\\n        finalres = []\\n        while beg <= end:\\n            l = (beg + end) // 2\\n            suff = self.getsuffixes(l)\\n            res = []\\n            i = 0\\n            for j in range(l):\\n                k = limit - len(suff[j])\\n                res.append(f\"{message[i : i + k]}{suff[j]}\")\\n                i += k\\n            if i < n:\\n                beg = l + 1\\n            elif len(res[-2]) != limit:\\n                end = l - 1\\n            else:\\n                finalres = res\\n                break\\n        return finalres\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2825325,
                "title": "java-concise-and-clear-solution",
                "content": "```\\nclass Solution {\\n    public String[] splitMessage(String message, int limit) {\\n        int size = message.length();\\n        int lenOfIndice = 1, total = 1;\\n        while (size + (3 + len(total)) * total + lenOfIndice > limit * total) {\\n            if (3 + len(total) * 2 >= limit) return new String[0];\\n            total += 1;\\n            lenOfIndice += len(total);\\n        }\\n            \\n        return formStrings(message, limit, total);\\n    }\\n    private String[] formStrings(String message, int limit, int total) {\\n        int index = 0;\\n        String[] result = new String[total];\\n        for (int i = 1; i <= total; ++i) {\\n            String suffix = String.format(\"<%d/%d>\", i, total);\\n            // do not exceed the length of the \"message\" using Math.min()\\n            String prefix = message.substring(index, Math.min(index + limit - suffix.length(), message.length()));\\n            result[i - 1] = prefix + suffix;\\n            index += limit - suffix.length();\\n        }\\n        return result;\\n    }\\n    private int len(int number) {\\n        return String.valueOf(number).length();\\n    }\\n\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String[] splitMessage(String message, int limit) {\\n        int size = message.length();\\n        int lenOfIndice = 1, total = 1;\\n        while (size + (3 + len(total)) * total + lenOfIndice > limit * total) {\\n            if (3 + len(total) * 2 >= limit) return new String[0];\\n            total += 1;\\n            lenOfIndice += len(total);\\n        }\\n            \\n        return formStrings(message, limit, total);\\n    }\\n    private String[] formStrings(String message, int limit, int total) {\\n        int index = 0;\\n        String[] result = new String[total];\\n        for (int i = 1; i <= total; ++i) {\\n            String suffix = String.format(\"<%d/%d>\", i, total);\\n            // do not exceed the length of the \"message\" using Math.min()\\n            String prefix = message.substring(index, Math.min(index + limit - suffix.length(), message.length()));\\n            result[i - 1] = prefix + suffix;\\n            index += limit - suffix.length();\\n        }\\n        return result;\\n    }\\n    private int len(int number) {\\n        return String.valueOf(number).length();\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2818450,
                "title": "c-o-n-simple-solution",
                "content": "Let the total number of part is total_num.\\nLet\\'s see. Every part is in the form of \"_<index/total_num>\". The \"<\", \">\", \"/\" are constant. The value of index does not depend on our choice so we can treat it as constant. So the only remaining variables are **no of digit** in total_num and no of characters. Since there is a limit, the no of character depend on the **no of digit** in total_num. \\nSince the size of message can be atmost 10<sup>4</sup>. No of digit will be atmost 4.\\n```\\nint digit(int num){\\n\\tif(num == 0)return 1;\\n\\tint ans = 0;\\n\\twhile(num > 0){\\n\\t\\tans++;\\n\\t\\tnum /= 10;\\n\\t}\\n\\treturn ans;\\n}\\nvector<string> splitMessage(string message, int limit) {\\n\\tif(limit <= 4)return {};\\n\\tint ans = 1e9;\\n\\tfor(int dig = 1;dig <= 5;dig++){\\n\\t\\tint index = 1, max_no_of_char = limit-(digit(index)+dig+3), no_of_char = 0, flag = 1;\\n\\t\\tfor(char &i:message){\\n\\t\\t\\tno_of_char++;\\n\\t\\t\\tif(no_of_char > max_no_of_char){\\n\\t\\t\\t\\tindex++;\\n\\t\\t\\t\\tmax_no_of_char = limit-(digit(index)+dig+3);\\n\\t\\t\\t\\tno_of_char = 1;\\n\\t\\t\\t\\tif(max_no_of_char <= 0){ // No space left to put a character\\n\\t\\t\\t\\t\\tflag = 0;\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tif(digit(index) > dig){ // The no of digit of last index is more than the allowed value.\\n\\t\\t\\tflag = 0;\\n\\t\\t}\\n\\t\\tif(flag == 1){\\n\\t\\t\\tans = index;\\n\\t\\t\\tbreak;\\n\\t\\t}\\n\\t}\\n\\tif(ans == 1e9)return {};\\n\\tvector<string>v;\\n\\tstring str;\\n\\tint index = 1;\\n\\tint max_no_of_char = limit-(digit(ans)+digit(index)+3), no_of_char = 0;\\n\\tfor(char &i:message){\\n\\t\\tstr += i;\\n\\t\\tno_of_char++;\\n\\t\\tif(no_of_char == max_no_of_char){\\n\\t\\t\\tstr += \\'<\\';\\n\\t\\t\\tstr += to_string(index);\\n\\t\\t\\tstr += \\'/\\';\\n\\t\\t\\tstr += to_string(ans);\\n\\t\\t\\tstr += \\'>\\';\\n\\t\\t\\tv.push_back(str);\\n\\t\\t\\tstr = \"\";\\n\\t\\t\\tindex++;\\n\\t\\t\\tno_of_char = 0;\\n\\t\\t\\tmax_no_of_char = limit-(digit(ans)+digit(index)+3);\\n\\t\\t}\\n\\t}\\n\\tif(no_of_char > 0){\\n\\t\\tstr += \\'<\\';\\n\\t\\tstr += to_string(index);\\n\\t\\tstr += \\'/\\';\\n\\t\\tstr += to_string(ans);\\n\\t\\tstr += \\'>\\';\\n\\t\\tv.push_back(str);\\n\\t}\\n\\treturn v;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint digit(int num){\\n\\tif(num == 0)return 1;\\n\\tint ans = 0;\\n\\twhile(num > 0){\\n\\t\\tans++;\\n\\t\\tnum /= 10;\\n\\t}\\n\\treturn ans;\\n}\\nvector<string> splitMessage(string message, int limit) {\\n\\tif(limit <= 4)return {};\\n\\tint ans = 1e9;\\n\\tfor(int dig = 1;dig <= 5;dig++){\\n\\t\\tint index = 1, max_no_of_char = limit-(digit(index)+dig+3), no_of_char = 0, flag = 1;\\n\\t\\tfor(char &i:message){\\n\\t\\t\\tno_of_char++;\\n\\t\\t\\tif(no_of_char > max_no_of_char){\\n\\t\\t\\t\\tindex++;\\n\\t\\t\\t\\tmax_no_of_char = limit-(digit(index)+dig+3);\\n\\t\\t\\t\\tno_of_char = 1;\\n\\t\\t\\t\\tif(max_no_of_char <= 0){ // No space left to put a character\\n\\t\\t\\t\\t\\tflag = 0;\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tif(digit(index) > dig){ // The no of digit of last index is more than the allowed value.\\n\\t\\t\\tflag = 0;\\n\\t\\t}\\n\\t\\tif(flag == 1){\\n\\t\\t\\tans = index;\\n\\t\\t\\tbreak;\\n\\t\\t}\\n\\t}\\n\\tif(ans == 1e9)return {};\\n\\tvector<string>v;\\n\\tstring str;\\n\\tint index = 1;\\n\\tint max_no_of_char = limit-(digit(ans)+digit(index)+3), no_of_char = 0;\\n\\tfor(char &i:message){\\n\\t\\tstr += i;\\n\\t\\tno_of_char++;\\n\\t\\tif(no_of_char == max_no_of_char){\\n\\t\\t\\tstr += \\'<\\';\\n\\t\\t\\tstr += to_string(index);\\n\\t\\t\\tstr += \\'/\\';\\n\\t\\t\\tstr += to_string(ans);\\n\\t\\t\\tstr += \\'>\\';\\n\\t\\t\\tv.push_back(str);\\n\\t\\t\\tstr = \"\";\\n\\t\\t\\tindex++;\\n\\t\\t\\tno_of_char = 0;\\n\\t\\t\\tmax_no_of_char = limit-(digit(ans)+digit(index)+3);\\n\\t\\t}\\n\\t}\\n\\tif(no_of_char > 0){\\n\\t\\tstr += \\'<\\';\\n\\t\\tstr += to_string(index);\\n\\t\\tstr += \\'/\\';\\n\\t\\tstr += to_string(ans);\\n\\t\\tstr += \\'>\\';\\n\\t\\tv.push_back(str);\\n\\t}\\n\\treturn v;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2817263,
                "title": "c-simple-linear-search-maths-o-n",
                "content": "```\\nclass Solution {\\npublic:\\n    int find(int n){\\n        int re = 0;\\n        while(n){re++;n/=10;}\\n        return re;\\n    }\\n    void dopart(vector<string>& re,string s,int limit,int n){\\n        int j = 0;\\n        string k = to_string(n);\\n        for(int i = 1; i<=n;++i){\\n            int size = limit-(3+find(n)+find(i));\\n            string temp;\\n            while(size-- && j<s.size()){ temp+= string(1,s[j]); j++;}\\n            temp+=\"<\"+to_string(i)+\"/\"+k+\">\";\\n            re.push_back(temp);\\n        }\\n    }\\n    vector<string> splitMessage(string s, int limit) {\\n        vector<string> re;\\n        int n = s.size(),sum = 0; \\n        for(int i = 1; i<=n;++i){\\n            sum+=find(i);  // sum = lenght(1)+length(2)+...+length(i) \\n            int size = 3*i + i*find(i) + sum;  // total size of string after adding all suffix\\n            int last = 3 + 2*find(i);  // length of last suffix\\n            if(last>limit) break;\\n            int k = s.size()+size - limit*(i-1); // size of the last part of resulting string\\n            if(k>=0 && k<=limit){  // check atmost limit condition for last last\\n                dopart(re,s,limit,i);  // do partition of string \\n                break;\\n            }\\n        }\\n        return re;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int find(int n){\\n        int re = 0;\\n        while(n){re++;n/=10;}\\n        return re;\\n    }\\n    void dopart(vector<string>& re,string s,int limit,int n){\\n        int j = 0;\\n        string k = to_string(n);\\n        for(int i = 1; i<=n;++i){\\n            int size = limit-(3+find(n)+find(i));\\n            string temp;\\n            while(size-- && j<s.size()){ temp+= string(1,s[j]); j++;}\\n            temp+=\"<\"+to_string(i)+\"/\"+k+\">\";\\n            re.push_back(temp);\\n        }\\n    }\\n    vector<string> splitMessage(string s, int limit) {\\n        vector<string> re;\\n        int n = s.size(),sum = 0; \\n        for(int i = 1; i<=n;++i){\\n            sum+=find(i);  // sum = lenght(1)+length(2)+...+length(i) \\n            int size = 3*i + i*find(i) + sum;  // total size of string after adding all suffix\\n            int last = 3 + 2*find(i);  // length of last suffix\\n            if(last>limit) break;\\n            int k = s.size()+size - limit*(i-1); // size of the last part of resulting string\\n            if(k>=0 && k<=limit){  // check atmost limit condition for last last\\n                dopart(re,s,limit,i);  // do partition of string \\n                break;\\n            }\\n        }\\n        return re;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2807491,
                "title": "python-simple-dumb-o-n-solution-no-binary-search-needed",
                "content": "# Intuition\\nThe idea is to figure out how many characters the parts count take up. Once we know that, generating all the parts is trivial.\\n\\n# Approach\\nSimply check if 9, 99, 999, or 9999 parts are enough to split the whole message, since 9, 99, 999, or 9999 are the maximum possible parts count for 1, 2, 3, or 4 characters.\\n\\nLet\\'s say a message splits into 14 parts. For that string, the `splitable` function below will return `True` for 99, but `False` for 9 -> we need to reserve 2 characters for the parts count.\\n\\n# Complexity\\n- Time complexity: O(n)\\n- Space complexity: O(n)\\n\\n# Code\\n```\\nclass Solution:\\n    def splitMessage(self, message: str, limit: int) -> List[str]:\\n        def splitable_within(parts_limit):\\n            # check the message length achievable with <parts_limit> parts\\n            length = sum(limit - len(str(i)) - len(str(parts_limit)) - 3 for i in range(1, parts_limit + 1))\\n            return length >= len(message)\\n        \\n        parts_limit = 9\\n        if not splitable_within(parts_limit):\\n            parts_limit = 99\\n        if not splitable_within(parts_limit):\\n            parts_limit = 999\\n        if not splitable_within(parts_limit):\\n            parts_limit = 9999\\n        if not splitable_within(parts_limit):\\n            return []\\n        \\n        # generate the actual message parts\\n        parts = []\\n        m_index = 0  # message index\\n        for part_index in range(1, parts_limit + 1):\\n            if m_index >= len(message): break\\n            length = limit - len(str(part_index)) - len(str(parts_limit)) - 3\\n            parts.append(message[m_index:m_index + length])\\n            m_index += length\\n        \\n        return [f\\'{part}<{i + 1}/{len(parts)}>\\' for i, part in enumerate(parts)]\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def splitMessage(self, message: str, limit: int) -> List[str]:\\n        def splitable_within(parts_limit):\\n            # check the message length achievable with <parts_limit> parts\\n            length = sum(limit - len(str(i)) - len(str(parts_limit)) - 3 for i in range(1, parts_limit + 1))\\n            return length >= len(message)\\n        \\n        parts_limit = 9\\n        if not splitable_within(parts_limit):\\n            parts_limit = 99\\n        if not splitable_within(parts_limit):\\n            parts_limit = 999\\n        if not splitable_within(parts_limit):\\n            parts_limit = 9999\\n        if not splitable_within(parts_limit):\\n            return []\\n        \\n        # generate the actual message parts\\n        parts = []\\n        m_index = 0  # message index\\n        for part_index in range(1, parts_limit + 1):\\n            if m_index >= len(message): break\\n            length = limit - len(str(part_index)) - len(str(parts_limit)) - 3\\n            parts.append(message[m_index:m_index + length])\\n            m_index += length\\n        \\n        return [f\\'{part}<{i + 1}/{len(parts)}>\\' for i, part in enumerate(parts)]\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3920679,
                "title": "modified-binary-search",
                "content": "as it says make minimum splits as much as u can...\\nso first try 1 to 9  , 10 to 99 , 100 to 999   ,  then 1000  to 9999  that\\'s it\\nso why doing this insted of making low=1 and high=10000 and apply once the problem here is the binary search solution works for numbers which have same digit  count \\neg: \\n\"abbababbbaaa aabaa a\"\\n8\\n\\nhere if we just follow simple binary search with low=1 & high=10000 we end up on 11 but their is a solution at 7 splits which is better \\nusual binary search fails to ensure the solution on range which have lesser digits than current mid\\nso we need to search in ranges so why not jsut start from 1 to 9 best possible splits and if it fails then move forward \\n**see the solve function implimentation**\\nit will give us the correct value of spilts needed and then it\\'s just easy problem just iterate and finished\\n\\n\\n```\\n\\n class Solution {\\npublic:\\n    \\n    string s=\"\";\\n    int limit=0;\\n    bool safe(int m)\\n    {\\n        int n=s.size();\\n        int c=to_string(m).size();\\n        int t=1;\\n        for(int i=1; i<=m; i++)\\n        {\\n            int tem=to_string(t).size();\\n            t++;\\n            n-=(limit-3-c-tem);\\n        }\\n        \\n        if(n<=0) return true;\\n        return false;\\n    }\\n    int solve(int l, int h)\\n    {\\n        int n=s.size();\\n        \\n        int ans=-1;\\n        while(l<=h)\\n        {\\n            int m=l+((h-l)/2);\\n            \\n            if(safe(m))\\n            {\\n                // cout<<m<<endl;\\n                ans=m;\\n                h=m-1;\\n            }\\n            else l=m+1;\\n        }\\n        \\n        if(ans==-1) // if answer not found\\n        {\\n            if(h<=n) return -1;\\n            return solve(h+1, h*10+9);\\n        }\\n        else\\n        return ans;\\n    }\\n    \\n    vector<string> splitMessage(string s1, int t) \\n    {\\n        limit=t;\\n        \\n        if(t<=5) return {};\\n        s=s1;\\n        int p=solve(1,9);\\n        \\n        if(p==-1) return {};\\n        // cout<<safe(7)<<endl;        \\n        string left=\"/\"+to_string(p)+\">\";\\n        int c=left.size();  //constant\\n        \\n       \\n        string second=\"\";\\n        int k=0;\\n        \\n        int rem=0;\\n        \\n        int n=s.size();\\n        \\n        vector<string> ans; \\n        \\n        for(int i=1; i<=p; i++)\\n        {\\n        \\n            second=\"<\"+ to_string(i)+left;\\n            rem=(limit-(int)second.size());\\n            if(rem==0) return {};//if no remaining space for char so return{} \\n            \\n             string tem=\"\";\\n            for(int j=0; j<rem; j++)// add remaining character\\n            {\\n                tem+=s[k];\\n                k++;\\n                if(k==n) break;\\n            }\\n            \\n            tem+=second;\\n            ans.push_back(tem);\\n            \\n            if(k==n) break;\\n        }\\n        return ans;\\n        \\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C",
                    "Greedy",
                    "Binary Search Tree"
                ],
                "code": "```\\n\\n class Solution {\\npublic:\\n    \\n    string s=\"\";\\n    int limit=0;\\n    bool safe(int m)\\n    {\\n        int n=s.size();\\n        int c=to_string(m).size();\\n        int t=1;\\n        for(int i=1; i<=m; i++)\\n        {\\n            int tem=to_string(t).size();\\n            t++;\\n            n-=(limit-3-c-tem);\\n        }\\n        \\n        if(n<=0) return true;\\n        return false;\\n    }\\n    int solve(int l, int h)\\n    {\\n        int n=s.size();\\n        \\n        int ans=-1;\\n        while(l<=h)\\n        {\\n            int m=l+((h-l)/2);\\n            \\n            if(safe(m))\\n            {\\n                // cout<<m<<endl;\\n                ans=m;\\n                h=m-1;\\n            }\\n            else l=m+1;\\n        }\\n        \\n        if(ans==-1) // if answer not found\\n        {\\n            if(h<=n) return -1;\\n            return solve(h+1, h*10+9);\\n        }\\n        else\\n        return ans;\\n    }\\n    \\n    vector<string> splitMessage(string s1, int t) \\n    {\\n        limit=t;\\n        \\n        if(t<=5) return {};\\n        s=s1;\\n        int p=solve(1,9);\\n        \\n        if(p==-1) return {};\\n        // cout<<safe(7)<<endl;        \\n        string left=\"/\"+to_string(p)+\">\";\\n        int c=left.size();  //constant\\n        \\n       \\n        string second=\"\";\\n        int k=0;\\n        \\n        int rem=0;\\n        \\n        int n=s.size();\\n        \\n        vector<string> ans; \\n        \\n        for(int i=1; i<=p; i++)\\n        {\\n        \\n            second=\"<\"+ to_string(i)+left;\\n            rem=(limit-(int)second.size());\\n            if(rem==0) return {};//if no remaining space for char so return{} \\n            \\n             string tem=\"\";\\n            for(int j=0; j<rem; j++)// add remaining character\\n            {\\n                tem+=s[k];\\n                k++;\\n                if(k==n) break;\\n            }\\n            \\n            tem+=second;\\n            ans.push_back(tem);\\n            \\n            if(k==n) break;\\n        }\\n        return ans;\\n        \\n    }\\n};\\n\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3655359,
                "title": "nlogn-solution-using-maths-and-logic",
                "content": "# Intuition and Approach.\\nIdea is that if given a limit, each part should have limit characters. And the last part can have less or equal to limit.\\n\\nLet say we chose a # of parts (say N). So in each part we have suffix of this pattern <i/N>. so each such pattern will have to be less than limit. This is because we have to accommodate atleast 1 character of the message in the part and the part\\'s length itself doesnt cross limit. So for a given N, we have total length of the parts to be\\n\\n**Length = Sigma( length(i) + length(N) + 3 ) for all I from 1 to N.**\\n\\nThis ceil ( Length / limit ) should be equal to total buckets which is equal to N.\\n\\nIn the worst case, N can be length of Message, since each part can have 1 character in the worst case. So for all such valid cases of N from 1 to Length(Message), we compute the above formula, check if it is satisfying and then pick the least N.\\n\\nFormula Simplification :\\n\\n**F = Sigma(Length(i) + length(N) + 3) equals\\n\\n  = Sigma(length(i)) + Sigma(length(N) + 3)\\n  \\n  = Sigma(Digits(i)) + N*( Digis(N) + 3)**\\n\\n\\nFor the first part above, we know that for any number N,\\nwe have 9 numbers with 1 character\\n90 numbers with 2 characters\\n900 numbers with 3 characters and so on until this is less than N.\\n\\n\\nDef fun Sigma(I):\\n\\n    start = 9;\\n    chars = 1;\\n    total = 0;\\n    i = I;\\n\\n    while i > 0:\\n\\n        if ( i < start ) \\n        {\\n            start = i;\\n        }\\n\\n        NumbersWithIChars = (start*chars)\\n        chars ++;\\n        start = start*10;\\n        total+ = NumbersWithIChars;\\n        i = i - start;\\n\\n    # Now we will add the second part of it\\n    total += ( Digits(I) + 3 )* I\\n\\nThis is a logN Complexity Algorithm, since we loop each digit.\\n\\nWe run this funcion for each i varying from 1 to message.Length N.\\nHence the Complexity is O(NLogN)\\n\\n\\n# Complexity\\n- Time complexity:\\nO(NLogN)\\n\\n- Space complexity:\\nO(N) space for result Vector.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    int countIndices(int n)\\n    {\\n        int digits = 0, val = n, cov = 1, rem, tot = 0, div = 9;\\n        \\n        while(val > 0)\\n        {\\n            digits++;\\n\\n            if(val > div) rem = div;\\n            else { rem = val; val = 0; }\\n\\n            tot += rem*cov;\\n            val -= div;\\n\\n            div = div*10;\\n            cov++;\\n        \\n        }\\n\\n        tot+= (digits + 3)*n;\\n        return tot;\\n\\n    }\\n\\n    int countDigits(int n)\\n    {\\n        int digits = 0;\\n        while(n >0)\\n        {\\n            n = n/10;\\n            digits++;\\n        }\\n        return digits;\\n    }\\n\\n    vector<string> splitMessage(string message, int limit) {\\n        \\n        vector<string> result;\\n        for(int i= 1; i <= (message.length()) && (2*countDigits(i)+3)<limit; i++)\\n        {\\n            if ( ceil( (countIndices(i) + message.length()) /(limit*1.0) )  == i)\\n            {\\n                int counter = 0, charsToTake, suffix;\\n\\n                for(int j = 1; j<=i; j++)\\n                {\\n                    suffix = countDigits(j) + countDigits(i) + 3;\\n                    charsToTake = limit - suffix;\\n                    \\n                    if(counter + charsToTake > message.length())\\n                    {\\n                        charsToTake = message.length() - counter;\\n                    }\\n\\n                    string str =  message.substr(counter, charsToTake);\\n                    str+= \"<\" + to_string(j) + \"/\" + to_string(i) + \">\";\\n\\n                    result.push_back( str );\\n                    counter = counter + charsToTake ;\\n\\n                    if(counter > message.length())\\n                    {\\n                        break;\\n                    }\\n                }\\n\\n                break;\\n            }\\n        }\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    int countIndices(int n)\\n    {\\n        int digits = 0, val = n, cov = 1, rem, tot = 0, div = 9;\\n        \\n        while(val > 0)\\n        {\\n            digits++;\\n\\n            if(val > div) rem = div;\\n            else { rem = val; val = 0; }\\n\\n            tot += rem*cov;\\n            val -= div;\\n\\n            div = div*10;\\n            cov++;\\n        \\n        }\\n\\n        tot+= (digits + 3)*n;\\n        return tot;\\n\\n    }\\n\\n    int countDigits(int n)\\n    {\\n        int digits = 0;\\n        while(n >0)\\n        {\\n            n = n/10;\\n            digits++;\\n        }\\n        return digits;\\n    }\\n\\n    vector<string> splitMessage(string message, int limit) {\\n        \\n        vector<string> result;\\n        for(int i= 1; i <= (message.length()) && (2*countDigits(i)+3)<limit; i++)\\n        {\\n            if ( ceil( (countIndices(i) + message.length()) /(limit*1.0) )  == i)\\n            {\\n                int counter = 0, charsToTake, suffix;\\n\\n                for(int j = 1; j<=i; j++)\\n                {\\n                    suffix = countDigits(j) + countDigits(i) + 3;\\n                    charsToTake = limit - suffix;\\n                    \\n                    if(counter + charsToTake > message.length())\\n                    {\\n                        charsToTake = message.length() - counter;\\n                    }\\n\\n                    string str =  message.substr(counter, charsToTake);\\n                    str+= \"<\" + to_string(j) + \"/\" + to_string(i) + \">\";\\n\\n                    result.push_back( str );\\n                    counter = counter + charsToTake ;\\n\\n                    if(counter > message.length())\\n                    {\\n                        break;\\n                    }\\n                }\\n\\n                break;\\n            }\\n        }\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2843586,
                "title": "binary-search-solution-with-digit-count-check-it-passes-abbababbbaaa-aabaa-a-test-case",
                "content": "# Approach\\nBinary Search is not very necessary for this problem. just increase `b` one by one and check whether there are remain message. It takes O(n) so still acceptable.\\n\\nFor binary search solution, one important thing to notice is that `b` is not monotone for different digit-count.\\n\\nExample:\\nmessage = \"abbababbbaaa aabaa a\", limit = 8\\nA simple BS solution will determine `b` as 11. But cutting into 7 parts also works.\\n\\nTo resolve this issue, we should **determine BS search range beforehand**. `b` is monotone inside range 1-9,10-99,100-999... \\nFirst check whether cut it into 9 part would suffice. If not then there must be at least 10 parts. Then we check if cutting into 99 parts suffice. If not then there must be at least 100 parts. Keep the process until digit-count is found.\\n\\nAfter `b`\\'s digit count is determined, we ensure the BS search range is monotone and can proceed with following process.\\n\\n\\n\\n# Code\\n```python\\nclass Solution:\\n    def splitMessage(self, message: str, limit: int) -> List[str]:\\n        if limit <= 5: return []\\n        \\n        # Important: Determine number of digit of b. BS monotone holds for same digit-count  \\n        # This will fix the testcase like: message = \"abbababbbaaa aabaa a\", limit = 8\\n        nd = -1\\n        for dc in range(1, 7):\\n            remain = len(message)\\n            for d in range(1, dc+1): \\n                if limit - 3 - d - dc < 0: break\\n                remain -= (limit - 3 - d - dc)*9*10**(d-1)\\n            if remain <= 0:\\n                nd = dc\\n                break\\n        if nd == -1: return []\\n        \\n        # binary search of b\\n        start, end = 10**(nd - 1), 10 ** nd\\n        while start != end:\\n            mid = (start + end) // 2\\n            dc = len(str(mid))\\n            remain = len(message) \\n            for d in range(1, dc):\\n                remain -= (limit - 3 - d - dc)*9*10**(d-1)\\n            for i in range(10**(dc-1), mid + 1):\\n                remain -= limit - 3 - 2*dc \\n                if remain < 0: break\\n            # print(start, end, mid, remain)\\n            if remain > 0: start = mid + 1\\n            else: end = mid\\n\\n        # construct answer\\n        ans = []\\n        dc = len(str(start))\\n        cur = 0\\n        for d in range(1, dc + 1):\\n            for i in range(10**(d-1), 10**d):\\n                nxt = min(cur + limit - 3 - d - dc, len(message))\\n                ans.append(message[cur:nxt] + \\'<\\' + str(i) + \\'/\\' + str(start) + \\'>\\')\\n                cur = nxt\\n                if nxt >= len(message): break\\n                \\n        if cur < len(message): return []\\n        return ans\\n                    \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```python\\nclass Solution:\\n    def splitMessage(self, message: str, limit: int) -> List[str]:\\n        if limit <= 5: return []\\n        \\n        # Important: Determine number of digit of b. BS monotone holds for same digit-count  \\n        # This will fix the testcase like: message = \"abbababbbaaa aabaa a\", limit = 8\\n        nd = -1\\n        for dc in range(1, 7):\\n            remain = len(message)\\n            for d in range(1, dc+1): \\n                if limit - 3 - d - dc < 0: break\\n                remain -= (limit - 3 - d - dc)*9*10**(d-1)\\n            if remain <= 0:\\n                nd = dc\\n                break\\n        if nd == -1: return []\\n        \\n        # binary search of b\\n        start, end = 10**(nd - 1), 10 ** nd\\n        while start != end:\\n            mid = (start + end) // 2\\n            dc = len(str(mid))\\n            remain = len(message) \\n            for d in range(1, dc):\\n                remain -= (limit - 3 - d - dc)*9*10**(d-1)\\n            for i in range(10**(dc-1), mid + 1):\\n                remain -= limit - 3 - 2*dc \\n                if remain < 0: break\\n            # print(start, end, mid, remain)\\n            if remain > 0: start = mid + 1\\n            else: end = mid\\n\\n        # construct answer\\n        ans = []\\n        dc = len(str(start))\\n        cur = 0\\n        for d in range(1, dc + 1):\\n            for i in range(10**(d-1), 10**d):\\n                nxt = min(cur + limit - 3 - d - dc, len(message))\\n                ans.append(message[cur:nxt] + \\'<\\' + str(i) + \\'/\\' + str(start) + \\'>\\')\\n                cur = nxt\\n                if nxt >= len(message): break\\n                \\n        if cur < len(message): return []\\n        return ans\\n                    \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2815279,
                "title": "golang-87-ms-7-3-mb",
                "content": "```\\nfunc max(a, b int) int {\\n\\tif a >= b {\\n\\t\\treturn a\\n\\t}\\n\\treturn b\\n}\\n\\nfunc splitMessage(message string, limit int) []string {\\n\\tfor totalDigitCount := 1; totalDigitCount < 5; totalDigitCount++ {\\n\\t\\tprevMaxPayload, maxPayload := 0, 0\\n\\t\\tmultiplier := 1\\n\\t\\tfor curDigitCount := 1; curDigitCount <= totalDigitCount; curDigitCount, multiplier = curDigitCount+1, multiplier*10 {\\n\\t\\t\\tprevMaxPayload = maxPayload\\n\\t\\t\\tmaxPayload += max(0, (limit-3-totalDigitCount-curDigitCount)*9*multiplier)\\n\\t\\t}\\n\\t\\tif maxPayload < len(message) {\\n\\t\\t\\tcontinue\\n\\t\\t}\\n\\t\\tlastPartsLen := limit - 3 - totalDigitCount*2\\n\\t\\ttotalPartsCount := multiplier/10 - 1 + (len(message)-prevMaxPayload+lastPartsLen-1)/lastPartsLen\\n\\t\\ttotalPartsCountSuffix := \"/\" + strconv.Itoa(totalPartsCount) + \">\"\\n\\t\\tresult := make([]string, totalPartsCount)\\n\\t\\tcIdx := 0\\n\\t\\tfor i := 1; i < totalPartsCount; i++ {\\n\\t\\t\\tsuffix := \"<\" + strconv.Itoa(i) + totalPartsCountSuffix\\n\\t\\t\\tcIdx2 := limit - len(suffix) + cIdx\\n\\t\\t\\tresult[i-1] = message[cIdx:cIdx2] + suffix\\n\\t\\t\\tcIdx = cIdx2\\n\\t\\t}\\n\\t\\tresult[len(result)-1] = message[cIdx:] + \"<\" + strconv.Itoa(totalPartsCount) + totalPartsCountSuffix\\n\\t\\treturn result\\n\\t}\\n\\treturn nil\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc max(a, b int) int {\\n\\tif a >= b {\\n\\t\\treturn a\\n\\t}\\n\\treturn b\\n}\\n\\nfunc splitMessage(message string, limit int) []string {\\n\\tfor totalDigitCount := 1; totalDigitCount < 5; totalDigitCount++ {\\n\\t\\tprevMaxPayload, maxPayload := 0, 0\\n\\t\\tmultiplier := 1\\n\\t\\tfor curDigitCount := 1; curDigitCount <= totalDigitCount; curDigitCount, multiplier = curDigitCount+1, multiplier*10 {\\n\\t\\t\\tprevMaxPayload = maxPayload\\n\\t\\t\\tmaxPayload += max(0, (limit-3-totalDigitCount-curDigitCount)*9*multiplier)\\n\\t\\t}\\n\\t\\tif maxPayload < len(message) {\\n\\t\\t\\tcontinue\\n\\t\\t}\\n\\t\\tlastPartsLen := limit - 3 - totalDigitCount*2\\n\\t\\ttotalPartsCount := multiplier/10 - 1 + (len(message)-prevMaxPayload+lastPartsLen-1)/lastPartsLen\\n\\t\\ttotalPartsCountSuffix := \"/\" + strconv.Itoa(totalPartsCount) + \">\"\\n\\t\\tresult := make([]string, totalPartsCount)\\n\\t\\tcIdx := 0\\n\\t\\tfor i := 1; i < totalPartsCount; i++ {\\n\\t\\t\\tsuffix := \"<\" + strconv.Itoa(i) + totalPartsCountSuffix\\n\\t\\t\\tcIdx2 := limit - len(suffix) + cIdx\\n\\t\\t\\tresult[i-1] = message[cIdx:cIdx2] + suffix\\n\\t\\t\\tcIdx = cIdx2\\n\\t\\t}\\n\\t\\tresult[len(result)-1] = message[cIdx:] + \"<\" + strconv.Itoa(totalPartsCount) + totalPartsCountSuffix\\n\\t\\treturn result\\n\\t}\\n\\treturn nil\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2809935,
                "title": "c-brute-force-with-o-n-time-complexity",
                "content": "```\\nclass Solution {\\npublic:\\n    int digits(int n) {\\n        int cnt = 0;\\n        while (n) {\\n            n /= 10;\\n            cnt++;\\n        }\\n        return cnt;\\n    }\\n    vector<string> splitMessage(string message, int limit) {\\n        int n = message.size();\\n        for (int length = 1; length * 2 + 3 < limit; ++length) {\\n            int cnt = (pow(10, length) - 1);\\n            int available = cnt * limit;\\n            available -= 3 * cnt;\\n            available -= length * cnt;\\n            for (int i = 1; i <= length; ++i) {\\n                available -= i * (pow(10, i) - pow(10, i - 1));\\n            }\\n            if (available >= n) return generate(message, limit, length);\\n        }\\n        \\n        return {};\\n    }\\n    vector<string> generate(string& message, int limit, int length) {\\n        int n = message.size();\\n        vector<string> res;\\n        int index = 0;\\n        int cnt = 1;\\n        while (index < n) {\\n            int remain = limit - 3;\\n            remain -= digits(cnt);\\n            remain -= length;\\n            int extract = min(remain, n - index);\\n            string temp = message.substr(index, extract) + \"<\" + to_string(cnt) + \"/\";\\n            res.push_back(temp);\\n            index += extract;\\n            cnt++;\\n        }\\n        string blockCnt = to_string(cnt - 1);\\n        for (auto& word : res) {\\n            word += blockCnt + \">\";\\n        }\\n        return res;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int digits(int n) {\\n        int cnt = 0;\\n        while (n) {\\n            n /= 10;\\n            cnt++;\\n        }\\n        return cnt;\\n    }\\n    vector<string> splitMessage(string message, int limit) {\\n        int n = message.size();\\n        for (int length = 1; length * 2 + 3 < limit; ++length) {\\n            int cnt = (pow(10, length) - 1);\\n            int available = cnt * limit;\\n            available -= 3 * cnt;\\n            available -= length * cnt;\\n            for (int i = 1; i <= length; ++i) {\\n                available -= i * (pow(10, i) - pow(10, i - 1));\\n            }\\n            if (available >= n) return generate(message, limit, length);\\n        }\\n        \\n        return {};\\n    }\\n    vector<string> generate(string& message, int limit, int length) {\\n        int n = message.size();\\n        vector<string> res;\\n        int index = 0;\\n        int cnt = 1;\\n        while (index < n) {\\n            int remain = limit - 3;\\n            remain -= digits(cnt);\\n            remain -= length;\\n            int extract = min(remain, n - index);\\n            string temp = message.substr(index, extract) + \"<\" + to_string(cnt) + \"/\";\\n            res.push_back(temp);\\n            index += extract;\\n            cnt++;\\n        }\\n        string blockCnt = to_string(cnt - 1);\\n        for (auto& word : res) {\\n            word += blockCnt + \">\";\\n        }\\n        return res;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2807844,
                "title": "binary-search",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\nBinary search the number of parts\\n\\n# Complexity\\n- Time complexity: O(log n + n), binary search + answer construction\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int isLargerOrFit(int n, int sz, int limit) {\\n        string b = to_string(sz);\\n        int b_sz = b.size();\\n        if (2 * b_sz + 3 > limit) return true;\\n        int total = (limit - b_sz - 3) * (sz - 1);\\n        if (sz <= 10) total -= (sz - 1);\\n        else if (sz <= 100) total -= 9 + 2 * (sz - 10);\\n        else if (sz <= 1000) total -= 9 + 2 * 90 + 3 * (sz - 100);\\n        else if (sz <= 10000) total -= 9 + 2 * 90 + 3 * 900 + 4 * (sz - 1000);\\n        int res = n - total;    // residual or remained characters\\n        if (res >= 0 && res + 2 * b_sz + 3 <= limit) {  // fit\\n            return 0;\\n        } else if (res < 0) {   // larger\\n            return 1;\\n        }\\n        return -1;  // smaller\\n    }\\n    \\n    vector<string> splitMessage(string message, int limit) {\\n        if (limit <= 5) return vector<string>();    // unrealistic limit\\n        int n = message.size();\\n        int low = 0, high = n + 1;\\n        while (low + 1 < high) {\\n            int mid = low + (high - low) / 2;\\n            if (isLargerOrFit(n, mid, limit) >= 0) high = mid;\\n            else low = mid;\\n        }\\n        if (isLargerOrFit(n, high, limit) == 1) return vector<string>();\\n        vector<string> ans(high);\\n        string b = to_string(high);\\n        for (int a = 1, l = 0; a <= high; a++) {\\n            string suffix = \"<\" + to_string(a) + \"/\" + b + \">\";\\n            int sz = limit - suffix.size();\\n            ans[a - 1] += message.substr(l, sz) + suffix;\\n            l += sz;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int isLargerOrFit(int n, int sz, int limit) {\\n        string b = to_string(sz);\\n        int b_sz = b.size();\\n        if (2 * b_sz + 3 > limit) return true;\\n        int total = (limit - b_sz - 3) * (sz - 1);\\n        if (sz <= 10) total -= (sz - 1);\\n        else if (sz <= 100) total -= 9 + 2 * (sz - 10);\\n        else if (sz <= 1000) total -= 9 + 2 * 90 + 3 * (sz - 100);\\n        else if (sz <= 10000) total -= 9 + 2 * 90 + 3 * 900 + 4 * (sz - 1000);\\n        int res = n - total;    // residual or remained characters\\n        if (res >= 0 && res + 2 * b_sz + 3 <= limit) {  // fit\\n            return 0;\\n        } else if (res < 0) {   // larger\\n            return 1;\\n        }\\n        return -1;  // smaller\\n    }\\n    \\n    vector<string> splitMessage(string message, int limit) {\\n        if (limit <= 5) return vector<string>();    // unrealistic limit\\n        int n = message.size();\\n        int low = 0, high = n + 1;\\n        while (low + 1 < high) {\\n            int mid = low + (high - low) / 2;\\n            if (isLargerOrFit(n, mid, limit) >= 0) high = mid;\\n            else low = mid;\\n        }\\n        if (isLargerOrFit(n, high, limit) == 1) return vector<string>();\\n        vector<string> ans(high);\\n        string b = to_string(high);\\n        for (int a = 1, l = 0; a <= high; a++) {\\n            string suffix = \"<\" + to_string(a) + \"/\" + b + \">\";\\n            int sz = limit - suffix.size();\\n            ans[a - 1] += message.substr(l, sz) + suffix;\\n            l += sz;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2807831,
                "title": "java-soln-with-explanation",
                "content": "The basic idea for this problem is to determine the appropriate number of parts to divide our input string to, such that each part length is within limit defined. One way to determine it is to loop on possible part values and then divide the modified string (containing original string plus all instances of <a/part>) by the part value. This will give us the maximum length of each string part.\\n\\nAs specified in the question we want the max length of a string part to be lesser or equal to `limit` along with the minimum part value. Thus we loop part in an ascending manner and as soon we get max length of part to be <= `limit`, we break the loop.\\n\\nFinally after calculating the minimum possible parts, we construct our string array as per requirement.\\n```\\nclass Solution {\\n    public String[] splitMessage(String message, int limit) {\\n        int len = message.length(), part;\\n        StringBuilder partSb = new StringBuilder();\\n        for(part=1;part<=len;part++){\\n            int numChars = 0;\\n            numChars = part*3; //Accounting for all </> characters in modified string\\n            numChars += ((Integer.toString(part)).length())*part; //Accounting for repeated b in modified string\\n            partSb.append(Integer.toString(part)); \\n            numChars += partSb.length(); //Accounting for a from 1 to b in modified string\\n            float remainChars = (float)len+numChars;\\n\\t\\t\\t//Finally checking below if the average string length per part is lesser or equal to limit,\\n\\t\\t\\t//if yes we get our part value else we continue;\\n            if(remainChars/(float)part <= ((float)limit))\\n                break;\\n        }\\n        if(part>len) return new String[]{}; //No suitable part found, return empty string\\n        String[] res = new String[part];\\n        int idx = 0;\\n\\t\\t//Construct res array as required based on the number of parts determined\\n        for(int i=1;i<=part;i++){\\n            StringBuilder suffix = new StringBuilder();\\n            suffix.append(\"<\").append(Integer.toString(i)).append(\"/\").append(Integer.toString(part)).append(\">\");\\n            StringBuilder prefix = new StringBuilder();\\n            if(idx + limit-suffix.length()<=len)\\n                prefix.append(message.substring(idx, idx + limit-suffix.length()));\\n            else\\n                prefix.append(message.substring(idx, len));\\n            idx += prefix.length();\\n            prefix.append(suffix);\\n            res[i-1] = prefix.toString();\\n        }\\n        return res;\\n    }\\n}\\n//TC : O(n^2) Since we are iterating on all parts and also calculating substring (O(n) operation) in each part,\\n//WC complexity would O(n^2) as parts can be almost equal to length of the `message`.\\n//SC : O(n) StringBuilder to store part value for each iteration ~ O(n).\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String[] splitMessage(String message, int limit) {\\n        int len = message.length(), part;\\n        StringBuilder partSb = new StringBuilder();\\n        for(part=1;part<=len;part++){\\n            int numChars = 0;\\n            numChars = part*3; //Accounting for all </> characters in modified string\\n            numChars += ((Integer.toString(part)).length())*part; //Accounting for repeated b in modified string\\n            partSb.append(Integer.toString(part)); \\n            numChars += partSb.length(); //Accounting for a from 1 to b in modified string\\n            float remainChars = (float)len+numChars;\\n\\t\\t\\t//Finally checking below if the average string length per part is lesser or equal to limit,\\n\\t\\t\\t//if yes we get our part value else we continue;\\n            if(remainChars/(float)part <= ((float)limit))\\n                break;\\n        }\\n        if(part>len) return new String[]{}; //No suitable part found, return empty string\\n        String[] res = new String[part];\\n        int idx = 0;\\n\\t\\t//Construct res array as required based on the number of parts determined\\n        for(int i=1;i<=part;i++){\\n            StringBuilder suffix = new StringBuilder();\\n            suffix.append(\"<\").append(Integer.toString(i)).append(\"/\").append(Integer.toString(part)).append(\">\");\\n            StringBuilder prefix = new StringBuilder();\\n            if(idx + limit-suffix.length()<=len)\\n                prefix.append(message.substring(idx, idx + limit-suffix.length()));\\n            else\\n                prefix.append(message.substring(idx, len));\\n            idx += prefix.length();\\n            prefix.append(suffix);\\n            res[i-1] = prefix.toString();\\n        }\\n        return res;\\n    }\\n}\\n//TC : O(n^2) Since we are iterating on all parts and also calculating substring (O(n) operation) in each part,\\n//WC complexity would O(n^2) as parts can be almost equal to length of the `message`.\\n//SC : O(n) StringBuilder to store part value for each iteration ~ O(n).\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2807641,
                "title": "c-direct-search-for-minimum-target-part-number",
                "content": "Think of the string `\"xxxx<a/b>\"` where b is a fixed upper bound with `a < b`.\\nGiven a limit, one must reserve 3 characters for `<` `/` `>`.\\nThe spaces allowed for putting characters would be `limit - 3 - len(b) - len(a)`.\\n![image](https://assets.leetcode.com/users/images/54b6dc8c-e784-41a9-9d56-311dd02f6021_1668274711.8729708.png)\\n\\n\\n\\nDue to the observation, we try to fix baseDigit and search for the minium part number through `getMinumPartNum()`.\\nThis function bascially fulfills the following logic:\\n\\nWe use variable `baseDigit` for the digit count of upper bound b.\\nAssume the baseDigit is 3, we try to consume the characters from message.\\nPart Index: [1-9], 9 parts with len(a) =1, each consumes `limit - 3 - baseDigit - 1` characters.\\nPart Index: [10 - 99], 90 parts with len(a) = 2 , each consumes `limit - 3 - baseDigit - 2` characters.\\nIf there is no enough characters before reaching index 100, we can return false to early stop.\\nFor the remaing part count with index >= 100, it would be `ceil(remainCharCnt / (limit - 3 - 2 * baseDigit))`\\nSince there is at most 999 parts with baseDigit = 3, we still need to check if the final part number does not exceed this contraint.\\n\\nGiven that we\\'ve found the minimum part number, to form the final part vector would be trivial.\\n\\n```\\nclass Solution {\\npublic:\\n    vector<string> splitMessage(string message, int limit) {\\n        int n = message.size();\\n        int baseDigit = 1;\\n        int minPartNum = INT_MAX;\\n        while (limit - 3 - 2 * baseDigit > 0) {\\n            if (getMinumPartNum(n, baseDigit, limit, minPartNum))\\n                break;\\n            baseDigit++;\\n        }\\n        if (minPartNum == INT_MAX) return {};\\n        \\n        vector<string> ans;\\n        formPart(message, limit, minPartNum, ans);\\n        return ans;\\n    }\\n    \\n    bool getMinumPartNum(int n, int baseDigit, int limit, int &minPartNum) {\\n        double remainCharCnt = n;\\n        int cnt = 0;\\n        for (int d = 1; d <= baseDigit; d++) {\\n            if (d != baseDigit) {\\n                remainCharCnt -= 9 * pow(10, d - 1) * (limit - 3 - baseDigit - d);\\n                if (remainCharCnt < 0) return false;\\n            } else\\n                cnt = ceil(remainCharCnt/ (limit - 3 - 2 * baseDigit));\\n        }\\n\\n        int finalPartNum = pow(10, baseDigit - 1) - 1 + cnt;\\n        if (finalPartNum >= pow(10, baseDigit)) return false;\\n        minPartNum = finalPartNum; \\n        return true;\\n    }\\n    \\n    void formPart(string message, int limit, int partNum, vector<string> &ans) {\\n        int idx = 0;\\n        int n = message.size();\\n        for (int i = 1; i <= partNum; i++) {\\n            string postfix = \"<\" + to_string(i) + \"/\" + to_string(partNum) + \">\";\\n            int remain = limit - postfix.size();\\n            string token = message.substr(idx, min(remain, n - idx)) + postfix;\\n            idx += remain;\\n            ans.push_back(token);\\n        }   \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> splitMessage(string message, int limit) {\\n        int n = message.size();\\n        int baseDigit = 1;\\n        int minPartNum = INT_MAX;\\n        while (limit - 3 - 2 * baseDigit > 0) {\\n            if (getMinumPartNum(n, baseDigit, limit, minPartNum))\\n                break;\\n            baseDigit++;\\n        }\\n        if (minPartNum == INT_MAX) return {};\\n        \\n        vector<string> ans;\\n        formPart(message, limit, minPartNum, ans);\\n        return ans;\\n    }\\n    \\n    bool getMinumPartNum(int n, int baseDigit, int limit, int &minPartNum) {\\n        double remainCharCnt = n;\\n        int cnt = 0;\\n        for (int d = 1; d <= baseDigit; d++) {\\n            if (d != baseDigit) {\\n                remainCharCnt -= 9 * pow(10, d - 1) * (limit - 3 - baseDigit - d);\\n                if (remainCharCnt < 0) return false;\\n            } else\\n                cnt = ceil(remainCharCnt/ (limit - 3 - 2 * baseDigit));\\n        }\\n\\n        int finalPartNum = pow(10, baseDigit - 1) - 1 + cnt;\\n        if (finalPartNum >= pow(10, baseDigit)) return false;\\n        minPartNum = finalPartNum; \\n        return true;\\n    }\\n    \\n    void formPart(string message, int limit, int partNum, vector<string> &ans) {\\n        int idx = 0;\\n        int n = message.size();\\n        for (int i = 1; i <= partNum; i++) {\\n            string postfix = \"<\" + to_string(i) + \"/\" + to_string(partNum) + \">\";\\n            int remain = limit - postfix.size();\\n            string token = message.substr(idx, min(remain, n - idx)) + postfix;\\n            idx += remain;\\n            ans.push_back(token);\\n        }   \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2807350,
                "title": "java-solution-using-simple-math",
                "content": "```\\nclass Solution {\\n    public String[] splitMessage(String message, int limit) {\\n        try{\\n            for(int parts=1;parts<=100000;parts++)\\n            {\\n                int extralen=(3+Integer.toString(parts).length())*parts;\\n                int extra=0;\\n                if(parts>=10000)\\n                    extra=9+90*2+900*3+9000*4+1*5;\\n                else if(parts>=1000)\\n                    extra=9+90*2+900*3+(parts-1000+1)*4;\\n                else if(parts>=100)\\n                    extra=9+90*2+(parts-100+1)*3;\\n                else if(parts>=10)\\n                    extra=9+(parts-10+1)*2;\\n                else\\n                    extra=parts;\\n                extralen+=extra;\\n                int totallen=extralen+message.length();\\n                if((limit*(parts-1)<totallen)&&(totallen-limit*(parts-1)<=limit))\\n                {\\n                    String ans[]=new String[parts];\\n                    int i=0;\\n                    for(int currpart=0;currpart<ans.length;currpart++)\\n                    {\\n                        String num=Integer.toString(currpart+1);\\n                        String deno=Integer.toString(parts);\\n                        String suffix=\"<\"+num+\"/\"+deno+\">\";\\n                        int len=limit-suffix.length();\\n                        if(currpart==ans.length-1)\\n                            ans[currpart]=message.substring(i,message.length())+suffix;\\n                        else\\n                            ans[currpart]=message.substring(i,i+len)+suffix;\\n                        i+=len;\\n                    }\\n                    return ans;\\n                }\\n            }\\n        }catch(Exception e)\\n        {\\n            return new String[0];\\n        }\\n        return new String[0];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Math",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public String[] splitMessage(String message, int limit) {\\n        try{\\n            for(int parts=1;parts<=100000;parts++)\\n            {\\n                int extralen=(3+Integer.toString(parts).length())*parts;\\n                int extra=0;\\n                if(parts>=10000)\\n                    extra=9+90*2+900*3+9000*4+1*5;\\n                else if(parts>=1000)\\n                    extra=9+90*2+900*3+(parts-1000+1)*4;\\n                else if(parts>=100)\\n                    extra=9+90*2+(parts-100+1)*3;\\n                else if(parts>=10)\\n                    extra=9+(parts-10+1)*2;\\n                else\\n                    extra=parts;\\n                extralen+=extra;\\n                int totallen=extralen+message.length();\\n                if((limit*(parts-1)<totallen)&&(totallen-limit*(parts-1)<=limit))\\n                {\\n                    String ans[]=new String[parts];\\n                    int i=0;\\n                    for(int currpart=0;currpart<ans.length;currpart++)\\n                    {\\n                        String num=Integer.toString(currpart+1);\\n                        String deno=Integer.toString(parts);\\n                        String suffix=\"<\"+num+\"/\"+deno+\">\";\\n                        int len=limit-suffix.length();\\n                        if(currpart==ans.length-1)\\n                            ans[currpart]=message.substring(i,message.length())+suffix;\\n                        else\\n                            ans[currpart]=message.substring(i,i+len)+suffix;\\n                        i+=len;\\n                    }\\n                    return ans;\\n                }\\n            }\\n        }catch(Exception e)\\n        {\\n            return new String[0];\\n        }\\n        return new String[0];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2807253,
                "title": "c-brute-force-o-n",
                "content": "Search how many chunks from 1 to n.\\n\\nIn each iteration:\\n`space` is the number of total capacity to fill message.\\n`last` is the capacity of last chunk.\\n`ramain` is the number of reamining character after filling the first i-1 chunks.\\n\\nFunction:\\n`digit` is the length of a number.\\n`all_len` is the sum of the length of each number from 1 to n.\\n```\\nclass Solution {\\nprivate:\\n    int digit(int n){\\n        if(n >= 10000) return 5;\\n        else if(n >= 1000) return 4;\\n        else if(n >= 100) return 3;\\n        else if(n >= 10) return 2;\\n        else return 1;\\n    }\\n    int all_len(int n){\\n        if(n >= 10000) return 9+2*90+3*900+4*9000+5*(n-9999);\\n        else if(n >= 1000) return 9+2*90+3*900+4*(n-999);\\n        else if(n >= 100) return 9+2*90+3*(n-99);\\n        else if(n >= 10) return 9+2*(n-9);\\n        else return n;\\n    }\\npublic:\\n    vector<string> splitMessage(string m, int limit) {\\n        if(limit <= 5) return {};\\n        int n = m.size();\\n        for(int i = 1; i <= n; i++){\\n            int space = limit*i-3*i-digit(i)*i-all_len(i);\\n            int last = limit-3-digit(i)*2;\\n            int remain = n-(space-last);\\n            if(remain<0 || remain>last) continue;\\n            int idx = 0;\\n            vector<string> res(i);\\n            for(int j = 1; j < i; j++){\\n                int k = limit-3-digit(i)-digit(j);\\n                res[j-1] = m.substr(idx, k)+\"<\"+to_string(j)+\"/\"+to_string(i)+\">\";\\n                idx += k;\\n            }\\n            res[i-1] = m.substr(idx)+\"<\"+to_string(i)+\"/\"+to_string(i)+\">\";\\n            return res;\\n        }\\n        return {};\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    int digit(int n){\\n        if(n >= 10000) return 5;\\n        else if(n >= 1000) return 4;\\n        else if(n >= 100) return 3;\\n        else if(n >= 10) return 2;\\n        else return 1;\\n    }\\n    int all_len(int n){\\n        if(n >= 10000) return 9+2*90+3*900+4*9000+5*(n-9999);\\n        else if(n >= 1000) return 9+2*90+3*900+4*(n-999);\\n        else if(n >= 100) return 9+2*90+3*(n-99);\\n        else if(n >= 10) return 9+2*(n-9);\\n        else return n;\\n    }\\npublic:\\n    vector<string> splitMessage(string m, int limit) {\\n        if(limit <= 5) return {};\\n        int n = m.size();\\n        for(int i = 1; i <= n; i++){\\n            int space = limit*i-3*i-digit(i)*i-all_len(i);\\n            int last = limit-3-digit(i)*2;\\n            int remain = n-(space-last);\\n            if(remain<0 || remain>last) continue;\\n            int idx = 0;\\n            vector<string> res(i);\\n            for(int j = 1; j < i; j++){\\n                int k = limit-3-digit(i)-digit(j);\\n                res[j-1] = m.substr(idx, k)+\"<\"+to_string(j)+\"/\"+to_string(i)+\">\";\\n                idx += k;\\n            }\\n            res[i-1] = m.substr(idx)+\"<\"+to_string(i)+\"/\"+to_string(i)+\">\";\\n            return res;\\n        }\\n        return {};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4018828,
                "title": "cpp-beats-97-without-fast-io",
                "content": "# Intuition\\nwe have to divide the string into k parts. check if the extra size generated by dividing into k parts can also fit in the k parts of each size limit.\\n\\nThe size of k is 1 <= sizeof(message). making in into more parts is meaning less as we cannot break message into any more parts. if we cannot get the k within range. Then solution doesnt exists.\\n\\nif we get the k, then slice the strings len = (limit - len(suffix))\\nk parts.\\nfs = fixed string length \\'<\\' \\'>\\' \\'/\\' \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int totaldigits(int n)\\n    {\\n        int res = 0;\\n        while(n>0)\\n        {\\n            n/= 10;\\n            res += 1;\\n        }\\n        return res;\\n    }\\n    int getstringsize(int k)\\n    {\\n        int fs = 3;\\n        int kdigits = totaldigits(k);\\n        int maxdigits = 9, currdigits = 9;\\n        int res = 0;\\n\\n        for(int i = 1; i<= kdigits; i++)\\n        {\\n            if(maxdigits > k)\\n            {\\n    // include number from previous limit to current number \\n    // i digits ie.. , for 91: 91 - 9, for 450 - 450 - 99 \\n                currdigits = ( k - (maxdigits/10));\\n                res += (fs + kdigits+ i) * (currdigits);\\n                break;\\n            }\\n            else\\n            {\\n                // include all numbers ie.. numbers formed with \\n                // i digits ie.. , 9 - 1, 89 - 2 digits\\n                res += (fs + kdigits+ i) * (currdigits);\\n            }\\n            maxdigits *= 10;\\n            maxdigits += 9;\\n            // max digits = 9, 99, 999, 9999, ...\\n            currdigits *= 10;\\n            // curr digits = 9 , ( 99 - 9 ), ( 999- 99), ..\\n            //             = 9, 90, 900, 9000,...\\n        }\\n        return res;\\n        \\n    }\\n    vector<string> splitMessage(string message, int limit) {\\n        int n = message.size();\\n        int k = 1;\\n        double val = 0;\\n        while( k <= n )\\n        {\\n            // val is extra string length generated\\n            val= getstringsize(k);\\n            // see if we can fix total string in k parts.\\n            if( ( val + n)/k <= limit)\\n                break;\\n            k++;\\n        }\\n        vector<string> res;\\n        if(k > n)\\n            return res;\\n        int pos = 0;\\n        for(int i = 1; i <=k ; i++)\\n        {\\n            char a[100];\\n            int a_size = sprintf(a , \"<%d/%d>\",i, k );\\n            int finalpos = pos+ (limit- a_size ) ;\\n            if(finalpos > n)\\n                finalpos = n;\\n            string s ( message.begin() + pos , message.begin() + finalpos);\\n            s += string(a);\\n            res.push_back(s);\\n            pos = finalpos;\\n            \\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int totaldigits(int n)\\n    {\\n        int res = 0;\\n        while(n>0)\\n        {\\n            n/= 10;\\n            res += 1;\\n        }\\n        return res;\\n    }\\n    int getstringsize(int k)\\n    {\\n        int fs = 3;\\n        int kdigits = totaldigits(k);\\n        int maxdigits = 9, currdigits = 9;\\n        int res = 0;\\n\\n        for(int i = 1; i<= kdigits; i++)\\n        {\\n            if(maxdigits > k)\\n            {\\n    // include number from previous limit to current number \\n    // i digits ie.. , for 91: 91 - 9, for 450 - 450 - 99 \\n                currdigits = ( k - (maxdigits/10));\\n                res += (fs + kdigits+ i) * (currdigits);\\n                break;\\n            }\\n            else\\n            {\\n                // include all numbers ie.. numbers formed with \\n                // i digits ie.. , 9 - 1, 89 - 2 digits\\n                res += (fs + kdigits+ i) * (currdigits);\\n            }\\n            maxdigits *= 10;\\n            maxdigits += 9;\\n            // max digits = 9, 99, 999, 9999, ...\\n            currdigits *= 10;\\n            // curr digits = 9 , ( 99 - 9 ), ( 999- 99), ..\\n            //             = 9, 90, 900, 9000,...\\n        }\\n        return res;\\n        \\n    }\\n    vector<string> splitMessage(string message, int limit) {\\n        int n = message.size();\\n        int k = 1;\\n        double val = 0;\\n        while( k <= n )\\n        {\\n            // val is extra string length generated\\n            val= getstringsize(k);\\n            // see if we can fix total string in k parts.\\n            if( ( val + n)/k <= limit)\\n                break;\\n            k++;\\n        }\\n        vector<string> res;\\n        if(k > n)\\n            return res;\\n        int pos = 0;\\n        for(int i = 1; i <=k ; i++)\\n        {\\n            char a[100];\\n            int a_size = sprintf(a , \"<%d/%d>\",i, k );\\n            int finalpos = pos+ (limit- a_size ) ;\\n            if(finalpos > n)\\n                finalpos = n;\\n            string s ( message.begin() + pos , message.begin() + finalpos);\\n            s += string(a);\\n            res.push_back(s);\\n            pos = finalpos;\\n            \\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4004498,
                "title": "find-minimum-splits-that-we-could-do",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nJust go through could split the message with th egiven \\'limit\\' in 9/99/999/9999 ?\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Note: The returned array must be malloced, assume caller calls free().\\n */\\nchar ** splitMessage(char * message, int limit, int* returnSize){\\nint min=0,mlen = 0, fmlen = 0,tot = 0,len = strlen(message);\\nint i=0,j=0,id=0;\\nchar **ret=NULL;\\n\\n\\n//Checking message could fit in x or xx or xxx or xxxx or xxxxx\\n\\n  if((limit-5)*9 >= len)\\n  {\\n   // min = (limit-5)*9;\\n    mlen = fmlen = limit-5;\\n    tot = len/fmlen + (len%fmlen ?1:0);\\n    \\n  }\\n  else if(((limit-6)*9 + (limit-7)*90 ) >= len)\\n  {\\n    min = (limit-6)*9;\\n    mlen =  limit-6;\\n    fmlen = limit-7;\\n    tot = 9+(len-min)/fmlen + ((len-min)%fmlen ?1:0);\\n    \\n  }\\n  else if(((limit-7)*9 + (limit-8)*90 + (limit-9)*900 ) >= len)\\n  {\\n\\n    min = ((limit-7)*9) +((limit-8)*90);\\n    mlen = limit-7;//starting message length used\\n    fmlen = limit-9;\\n    tot = 99+(len-min)/fmlen + ((len-min)%fmlen ?1:0);\\n\\n  }\\n  else if(((limit-8)*9 + (limit-9)*90 + (limit-10)*900 ) + (limit-11)*9000 >= len)\\n  {\\n\\n    min = ((limit-8)*9) +((limit-9)*90) + ((limit-10)*900);\\n    mlen = limit-8;//starting message length used\\n    fmlen = limit-11;\\n    tot = 999+(len-min)/fmlen + ((len-min)%fmlen ?1:0);\\n    \\n  }\\n\\n  *returnSize = tot;\\n  ret = (char**)calloc(tot,sizeof(char*));\\n  for(j=0; j<tot;j++)\\n  {\\n    ret[j] = (char*)calloc((limit+2),sizeof(char));\\n    for(i=0; i< mlen && id < len;i++)\\n    {\\n      ret[j][i] = message[id++];\\n    }\\n    sprintf(&ret[j][i],\"<%d/%d>\",j+1,tot);\\n    //printf(\"%s\\\\n\",ret[j]);\\n    if(j == 8 || j == 98 || j == 998)\\n      mlen--;\\n  }\\n\\nreturn ret;\\n\\n\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n/**\\n * Note: The returned array must be malloced, assume caller calls free().\\n */\\nchar ** splitMessage(char * message, int limit, int* returnSize){\\nint min=0,mlen = 0, fmlen = 0,tot = 0,len = strlen(message);\\nint i=0,j=0,id=0;\\nchar **ret=NULL;\\n\\n\\n//Checking message could fit in x or xx or xxx or xxxx or xxxxx\\n\\n  if((limit-5)*9 >= len)\\n  {\\n   // min = (limit-5)*9;\\n    mlen = fmlen = limit-5;\\n    tot = len/fmlen + (len%fmlen ?1:0);\\n    \\n  }\\n  else if(((limit-6)*9 + (limit-7)*90 ) >= len)\\n  {\\n    min = (limit-6)*9;\\n    mlen =  limit-6;\\n    fmlen = limit-7;\\n    tot = 9+(len-min)/fmlen + ((len-min)%fmlen ?1:0);\\n    \\n  }\\n  else if(((limit-7)*9 + (limit-8)*90 + (limit-9)*900 ) >= len)\\n  {\\n\\n    min = ((limit-7)*9) +((limit-8)*90);\\n    mlen = limit-7;//starting message length used\\n    fmlen = limit-9;\\n    tot = 99+(len-min)/fmlen + ((len-min)%fmlen ?1:0);\\n\\n  }\\n  else if(((limit-8)*9 + (limit-9)*90 + (limit-10)*900 ) + (limit-11)*9000 >= len)\\n  {\\n\\n    min = ((limit-8)*9) +((limit-9)*90) + ((limit-10)*900);\\n    mlen = limit-8;//starting message length used\\n    fmlen = limit-11;\\n    tot = 999+(len-min)/fmlen + ((len-min)%fmlen ?1:0);\\n    \\n  }\\n\\n  *returnSize = tot;\\n  ret = (char**)calloc(tot,sizeof(char*));\\n  for(j=0; j<tot;j++)\\n  {\\n    ret[j] = (char*)calloc((limit+2),sizeof(char));\\n    for(i=0; i< mlen && id < len;i++)\\n    {\\n      ret[j][i] = message[id++];\\n    }\\n    sprintf(&ret[j][i],\"<%d/%d>\",j+1,tot);\\n    //printf(\"%s\\\\n\",ret[j]);\\n    if(j == 8 || j == 98 || j == 998)\\n      mlen--;\\n  }\\n\\nreturn ret;\\n\\n\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3953098,
                "title": "just-impliment-of-task",
                "content": "\\n# Approach\\njust   impliment of task\\n\\n# Code\\n```\\nclass Solution:\\n    def splitMessage(self, m: str, l: int) -> List[str]:\\n        d=len(m)\\n        for i in range(1,5):\\n            t=d\\n            for j in range(1,i):t-=(10**j-1)\\n            if(k:=l-3-2*i)<=0:return []\\n            if (p:=(t-1+k)//k)>(10**i-1):continue\\n            o,x=[],0\\n            for i in range(p):\\n                z=len(s:=f\\'<{i+1}/{p}>\\')\\n                o.append(m[x:x+(l-z)]+s)\\n                x+=(l-z)\\n            return o\\n       \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def splitMessage(self, m: str, l: int) -> List[str]:\\n        d=len(m)\\n        for i in range(1,5):\\n            t=d\\n            for j in range(1,i):t-=(10**j-1)\\n            if(k:=l-3-2*i)<=0:return []\\n            if (p:=(t-1+k)//k)>(10**i-1):continue\\n            o,x=[],0\\n            for i in range(p):\\n                z=len(s:=f\\'<{i+1}/{p}>\\')\\n                o.append(m[x:x+(l-z)]+s)\\n                x+=(l-z)\\n            return o\\n       \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3942698,
                "title": "java-99-02-fast-simple-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nAssume $$1 <= num(page) <= 9$$, confirm whether there is enough space for current message to be stored.\\n\\nIf so, compute the exact $$num(page)$$.\\nIf not, assume $$10 <= num(page) <= 99$$ and check again until find the exact $$num(page)$$.\\n\\n\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    private int getPages(int l, int limit) {\\n        int curLen = limit - 5; // length of \"<1/3>\" is 5\\n        int curCapacity = 9;\\n        int extraSpace = 0;\\n        while (l > curLen * curCapacity + extraSpace) {\\n            curLen -= 2;\\n            extraSpace += curCapacity; // \"***<5/23>\" has extra space than \"**<12/23>\"\\n            curCapacity = Integer.parseInt(curCapacity + \"9\");\\n            if (curLen <= 0) return 0;\\n        }\\n        int ans = (l - extraSpace) / curLen;\\n        if ((l - extraSpace) % curLen != 0) ++ans;\\n        return ans;\\n    }\\n\\n    public String[] splitMessage(String message, int limit) {\\n        int l = message.length();\\n        int pages = getPages(l, limit);\\n        String[] ans = new String[pages];\\n        int curPos = 0;\\n        for (int i=0; i<pages; ++i) {\\n            String tag = \"<\" + (i+1) + \"/\" + pages + \">\";\\n            int infoLen = limit - tag.length();\\n            ans[i] = message.substring(curPos, Math.min(l, curPos + infoLen)) + tag;\\n            curPos += infoLen;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    private int getPages(int l, int limit) {\\n        int curLen = limit - 5; // length of \"<1/3>\" is 5\\n        int curCapacity = 9;\\n        int extraSpace = 0;\\n        while (l > curLen * curCapacity + extraSpace) {\\n            curLen -= 2;\\n            extraSpace += curCapacity; // \"***<5/23>\" has extra space than \"**<12/23>\"\\n            curCapacity = Integer.parseInt(curCapacity + \"9\");\\n            if (curLen <= 0) return 0;\\n        }\\n        int ans = (l - extraSpace) / curLen;\\n        if ((l - extraSpace) % curLen != 0) ++ans;\\n        return ans;\\n    }\\n\\n    public String[] splitMessage(String message, int limit) {\\n        int l = message.length();\\n        int pages = getPages(l, limit);\\n        String[] ans = new String[pages];\\n        int curPos = 0;\\n        for (int i=0; i<pages; ++i) {\\n            String tag = \"<\" + (i+1) + \"/\" + pages + \">\";\\n            int infoLen = limit - tag.length();\\n            ans[i] = message.substring(curPos, Math.min(l, curPos + infoLen)) + tag;\\n            curPos += infoLen;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3927026,
                "title": "easy-but-there-was-lot-of-cases-to-pass-binary-search-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool check(int t,string m,int lim){\\n        int ans=0;\\n        for(int i=1;i<=t;i++){\\n            string fix = \\'<\\'+to_string(i)+\\'/\\'+to_string(t)+\\'>\\';\\n            int y = lim-fix.size();\\n            if(y==0) return true;\\n            ans+=y;\\n        }\\n        // cout<<t<<\" \"<<ans<<endl;\\n        if((to_string(t).size()-to_string(t-5).size()==1&&t>=10&&t<100)||(to_string(t).size()-to_string(t-15).size()==1&&t>=100)){\\n            int a;\\n            if(t>=10&&t<100){\\n                a = to_string(t-5).size();\\n            }else{\\n                a = to_string(t-15).size();\\n            }\\n            int b=0;\\n            for(int i=0;i<a;i++){\\n                b*=10;\\n                b+=9;                \\n            }\\n            int z=0;\\n            for(int i=1;i<=b;i++){\\n            string fix = \\'<\\'+to_string(i)+\\'/\\'+to_string(b)+\\'>\\';\\n            int y = lim-fix.size();\\n            z+=y;\\n           }\\n            // cout<<z<<endl;\\n            ans=max(ans,z);\\n        }\\n        \\n        if(ans>=m.size()){\\n            return true;\\n        }else{\\n            return false;\\n        }\\n    }\\n    vector<string> splitMessage(string m, int lim) {\\n        vector<string> ans;\\n        if(lim<=5) return ans;\\n        int l=0;\\n        int h = m.size();\\n        int x=0;\\n        while(l<=h){\\n            int mid=l+(h-l)/2;\\n            // cout<<mid<<endl;\\n            if(check(mid,m,lim)){\\n                x=mid;\\n                h=mid-1;\\n            }else{\\n                l=mid+1;\\n            }\\n        }\\n        int prev=0;\\n        string temp = \\'<\\'+to_string(x)+\\'/\\'+to_string(x)+\\'>\\';\\n        if(temp.size()>=lim) return ans;\\n        for(int i=1;i<=x;i++){\\n            string fix = \\'<\\'+to_string(i)+\\'/\\'+to_string(x)+\\'>\\';\\n            int y = lim-fix.size();\\n            string str = m.substr(prev,y);\\n            string res = str+fix;\\n            ans.push_back(res);\\n            prev = prev+y;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool check(int t,string m,int lim){\\n        int ans=0;\\n        for(int i=1;i<=t;i++){\\n            string fix = \\'<\\'+to_string(i)+\\'/\\'+to_string(t)+\\'>\\';\\n            int y = lim-fix.size();\\n            if(y==0) return true;\\n            ans+=y;\\n        }\\n        // cout<<t<<\" \"<<ans<<endl;\\n        if((to_string(t).size()-to_string(t-5).size()==1&&t>=10&&t<100)||(to_string(t).size()-to_string(t-15).size()==1&&t>=100)){\\n            int a;\\n            if(t>=10&&t<100){\\n                a = to_string(t-5).size();\\n            }else{\\n                a = to_string(t-15).size();\\n            }\\n            int b=0;\\n            for(int i=0;i<a;i++){\\n                b*=10;\\n                b+=9;                \\n            }\\n            int z=0;\\n            for(int i=1;i<=b;i++){\\n            string fix = \\'<\\'+to_string(i)+\\'/\\'+to_string(b)+\\'>\\';\\n            int y = lim-fix.size();\\n            z+=y;\\n           }\\n            // cout<<z<<endl;\\n            ans=max(ans,z);\\n        }\\n        \\n        if(ans>=m.size()){\\n            return true;\\n        }else{\\n            return false;\\n        }\\n    }\\n    vector<string> splitMessage(string m, int lim) {\\n        vector<string> ans;\\n        if(lim<=5) return ans;\\n        int l=0;\\n        int h = m.size();\\n        int x=0;\\n        while(l<=h){\\n            int mid=l+(h-l)/2;\\n            // cout<<mid<<endl;\\n            if(check(mid,m,lim)){\\n                x=mid;\\n                h=mid-1;\\n            }else{\\n                l=mid+1;\\n            }\\n        }\\n        int prev=0;\\n        string temp = \\'<\\'+to_string(x)+\\'/\\'+to_string(x)+\\'>\\';\\n        if(temp.size()>=lim) return ans;\\n        for(int i=1;i<=x;i++){\\n            string fix = \\'<\\'+to_string(i)+\\'/\\'+to_string(x)+\\'>\\';\\n            int y = lim-fix.size();\\n            string str = m.substr(prev,y);\\n            string res = str+fix;\\n            ans.push_back(res);\\n            prev = prev+y;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3921748,
                "title": "python-binary-search-solution-beats-99-25",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def splitMessage(self, message: str, limit: int) -> List[str]:\\n        ln=len(message)\\n        maxSuffix=(limit-3-1)//2\\n        if maxSuffix<1:\\n            return []\\n        \\n        left=1\\n        right=maxSuffix+1\\n        allParts=0\\n        while left<right:\\n            mid=(left+right)//2\\n            space=limit-3-mid-1\\n            if mid>maxSuffix:\\n                break\\n            digits=1\\n            parts=0\\n            words=ln\\n            while digits<=mid:\\n                part=ceil(words/space)\\n                carry=(9*(10**(digits-1)))\\n                if part>carry:\\n                    words-=carry*space\\n                    parts+=carry\\n                    digits+=1\\n                    space-=1\\n                else:\\n                    parts+=part\\n                    break\\n            if digits>mid:\\n                left=mid+1\\n            else:\\n                right=mid\\n                allParts=parts\\n\\n        if right>maxSuffix:\\n            return []\\n        res=[]\\n        id=0\\n        space=limit-3-right-1\\n        parts=1\\n        digits=1\\n        while id<ln:\\n            part=ceil((ln-id)/space)\\n            for _ in range(min(part,9*(10**(digits-1)))):\\n                res.append(message[id:id+space]+f\"<{parts}/{allParts}>\")\\n                id+=space\\n                parts+=1\\n            digits+=1\\n            space-=1\\n        return res\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def splitMessage(self, message: str, limit: int) -> List[str]:\\n        ln=len(message)\\n        maxSuffix=(limit-3-1)//2\\n        if maxSuffix<1:\\n            return []\\n        \\n        left=1\\n        right=maxSuffix+1\\n        allParts=0\\n        while left<right:\\n            mid=(left+right)//2\\n            space=limit-3-mid-1\\n            if mid>maxSuffix:\\n                break\\n            digits=1\\n            parts=0\\n            words=ln\\n            while digits<=mid:\\n                part=ceil(words/space)\\n                carry=(9*(10**(digits-1)))\\n                if part>carry:\\n                    words-=carry*space\\n                    parts+=carry\\n                    digits+=1\\n                    space-=1\\n                else:\\n                    parts+=part\\n                    break\\n            if digits>mid:\\n                left=mid+1\\n            else:\\n                right=mid\\n                allParts=parts\\n\\n        if right>maxSuffix:\\n            return []\\n        res=[]\\n        id=0\\n        space=limit-3-right-1\\n        parts=1\\n        digits=1\\n        while id<ln:\\n            part=ceil((ln-id)/space)\\n            for _ in range(min(part,9*(10**(digits-1)))):\\n                res.append(message[id:id+space]+f\"<{parts}/{allParts}>\")\\n                id+=space\\n                parts+=1\\n            digits+=1\\n            space-=1\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3907532,
                "title": "swift-split-message-based-on-limit",
                "content": "# Code\\n```\\nclass Solution {\\n    func splitMessage(_ message: String, _ limit: Int) -> [String] {\\n        let n = message.count\\n        let ma = Array(message)\\n\\n        // 1. calculate minimum number of parts        \\n        var (parts, a) = (1, 1)\\n        while(a + n + parts * (3 + String(parts).count) > parts * limit) {\\n            if(3 + String(parts).count * 2 >= limit) {\\n                return []\\n            }\\n            parts += 1\\n            a += String(parts).count\\n        }\\n\\n        // 2. create strings by greedily consuming message up to limit\\n        var answer = [String]()\\n        var count = 1\\n        var i = 0\\n        while(i < n) {\\n            let q = \"<\" + String(count) + \"/\" + String(parts) + \">\"\\n            count += 1\\n            var p = \"\"\\n            for j in 0..<limit - q.count where (i+j) < n {\\n                p += String(ma[i+j])\\n            }\\n            i += p.count\\n            p += q\\n            answer.append(p)\\n        }\\n        return answer\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func splitMessage(_ message: String, _ limit: Int) -> [String] {\\n        let n = message.count\\n        let ma = Array(message)\\n\\n        // 1. calculate minimum number of parts        \\n        var (parts, a) = (1, 1)\\n        while(a + n + parts * (3 + String(parts).count) > parts * limit) {\\n            if(3 + String(parts).count * 2 >= limit) {\\n                return []\\n            }\\n            parts += 1\\n            a += String(parts).count\\n        }\\n\\n        // 2. create strings by greedily consuming message up to limit\\n        var answer = [String]()\\n        var count = 1\\n        var i = 0\\n        while(i < n) {\\n            let q = \"<\" + String(count) + \"/\" + String(parts) + \">\"\\n            count += 1\\n            var p = \"\"\\n            for j in 0..<limit - q.count where (i+j) < n {\\n                p += String(ma[i+j])\\n            }\\n            i += p.count\\n            p += q\\n            answer.append(p)\\n        }\\n        return answer\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3875981,
                "title": "no-binary-search-purely-mathematical-beats-99-04",
                "content": "![Screenshot 2023-08-07 113348.png](https://assets.leetcode.com/users/images/697f1b86-c339-4756-b3a8-25e1f694f13c_1691401684.8262682.png)\\n\\n\\n# Intuition\\nFollowing formula can be deduced for this problem\\n$$ \\\\sum_{i=1}^{d} 9 * 10^{ (i-1)} * ( limit - 3 -(i+d)) $$\\n\\nwhere limit is the given parameter in the program, d is maximum number of digits there can be in split, for eg. for 14 it is 2. and i is {1, ... , d}. This provides us total length of string that can be constructed if we want d digits in size of split.\\n\\nUsing this finding d suitable for our case, Since max limit here is 10**4, hence a total of 5 digits, therefore searching from 1..5 for best len for our split value or d.\\n\\n\\n# Code\\n```\\nfrom math import ceil\\n\\nclass Solution:\\n    def splitMessage(self, message: str, limit: int) -> List[str]:\\n        def func(limit, dig_num):\\n            s = 0\\n            for i in range(1, dig_num+1):\\n                mid_term = 9 * (10 ** (i - 1 )) *(limit - 3 - (i + dig_num ))\\n                s+=mid_term\\n            return s, mid_term\\n\\n        proposed_chars = 0\\n\\n        for i in range(1, 6): #Because max chars can be 5 as limit is 10**4\\n            s, mid_term = func(limit, i)\\n            if s >= len(message):\\n                proposed_chars = i\\n                break\\n        if proposed_chars == 0: return []\\n\\n        n = len(message)\\n        n -= (s - mid_term)\\n        extras = ceil(n / (limit - (3 + 2*proposed_chars) ))\\n        total = 10 ** (proposed_chars - 1) + ( extras - 1)\\n        res = []\\n        prev = 0\\n        for i in range(total):\\n            num_chars = limit - 3 - proposed_chars - len(str(i+1))\\n            mid_str = message[ prev : min(len(message), prev + num_chars) ]\\n            mid_str = mid_str + \"<{}/{}>\".format(i+1, total)\\n            res.append(mid_str)\\n            prev+=num_chars\\n\\n        return res\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nfrom math import ceil\\n\\nclass Solution:\\n    def splitMessage(self, message: str, limit: int) -> List[str]:\\n        def func(limit, dig_num):\\n            s = 0\\n            for i in range(1, dig_num+1):\\n                mid_term = 9 * (10 ** (i - 1 )) *(limit - 3 - (i + dig_num ))\\n                s+=mid_term\\n            return s, mid_term\\n\\n        proposed_chars = 0\\n\\n        for i in range(1, 6): #Because max chars can be 5 as limit is 10**4\\n            s, mid_term = func(limit, i)\\n            if s >= len(message):\\n                proposed_chars = i\\n                break\\n        if proposed_chars == 0: return []\\n\\n        n = len(message)\\n        n -= (s - mid_term)\\n        extras = ceil(n / (limit - (3 + 2*proposed_chars) ))\\n        total = 10 ** (proposed_chars - 1) + ( extras - 1)\\n        res = []\\n        prev = 0\\n        for i in range(total):\\n            num_chars = limit - 3 - proposed_chars - len(str(i+1))\\n            mid_str = message[ prev : min(len(message), prev + num_chars) ]\\n            mid_str = mid_str + \"<{}/{}>\".format(i+1, total)\\n            res.append(mid_str)\\n            prev+=num_chars\\n\\n        return res\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3836661,
                "title": "kotlin-solution-with-math",
                "content": "# Approach\\nWe can solve this problem doing pure math calculations.\\n\\n1. We first try to split it with at most 9 copies. We know the suffix will be of the form \"<1/9>\", which will always have 5 chars. This means that we have only (limit -5) chars that we can extract from the original string. Therefore we would need (Message Length / (Limit-5)) Copies. If number of copies is greater than 9 then we know we need to check now with at most 99\\n2. Now we try to split it with at most 9 copies. We know we will have 9 copies of the following form \"<1/99>\" whose length is (Limit -6) and then we will have 90 copies of the form \"<10/99>\" whose length is (Limit-7). To get how many copies we will need we can do quick math.\\n\\nFor other cases we have similar logic\\n\\n# Code\\n\\nCode can be simplify but tried to keep it self explained.\\n```\\nimport kotlin.math.ceil\\nimport kotlin.math.min\\nclass Solution {\\n\\n    fun splitAtMost9(length: Int, limit: Int):Int{\\n        if(limit <= 5)  return -1\\n        val numberOfCopies = ceil(length/(limit - 5).toFloat()).toInt()\\n        return if(numberOfCopies <= 9)numberOfCopies else -1\\n    }\\n\\n    fun splitWithAtMost99(length: Int, limit: Int):Int{\\n        if(limit <= 7)  return -1\\n        val restOfStringLength = length - (limit-6)*9\\n        val numberOfCopies = ceil(restOfStringLength/(limit-7).toFloat()).toInt() + 9\\n        return if(numberOfCopies <= 99) numberOfCopies else -1\\n    }\\n\\n    fun splitWithAtMost999(length: Int, limit: Int):Int{\\n        if(limit <= 9)  return -1\\n        var restOfStringLength = length - (limit-7)*9\\n        restOfStringLength = restOfStringLength - (limit-8)*90\\n\\n        val numberOfCopies = ceil(restOfStringLength/(limit-9).toFloat()).toInt() + 99\\n        return if(numberOfCopies <= 999) numberOfCopies else -1\\n    }\\n\\n    fun splitWithAtMost9999(length: Int, limit: Int):Int{\\n        if(limit <= 9)  return -1\\n        var restOfStringLength = length - (limit-8)*9\\n        restOfStringLength = restOfStringLength - (limit-9)*90\\n        restOfStringLength = restOfStringLength - (limit-10)*900\\n\\n        val numberOfCopies = ceil(restOfStringLength/(limit-11).toFloat()).toInt() + 999\\n        return if(numberOfCopies <= 9999) numberOfCopies else -1\\n    }\\n\\n    fun splitMessage(message: String, limit: Int): Array<String> {\\n        var copies = splitAtMost9(message.length,limit)\\n        if(copies == -1){\\n            copies = splitWithAtMost99(message.length,limit)\\n        }\\n        if(copies == -1){\\n            copies = splitWithAtMost999(message.length,limit)\\n        }\\n        if(copies == -1){\\n            copies = splitWithAtMost9999(message.length,limit)\\n        }\\n        if(copies <= 0 ){\\n            return emptyArray<String>()\\n        }\\n        val ans = Array<String>(copies){\"\"}\\n        var appended = 0\\n        for(i in 1..copies){\\n            val toAppendLength = limit - \"<$i/$copies>\".length\\n            ans[i-1] = message.substring(appended,min(appended+toAppendLength,message.length)) + \"<$i/$copies>\"\\n            appended = appended+toAppendLength\\n        }\\n\\n        return ans\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\nimport kotlin.math.ceil\\nimport kotlin.math.min\\nclass Solution {\\n\\n    fun splitAtMost9(length: Int, limit: Int):Int{\\n        if(limit <= 5)  return -1\\n        val numberOfCopies = ceil(length/(limit - 5).toFloat()).toInt()\\n        return if(numberOfCopies <= 9)numberOfCopies else -1\\n    }\\n\\n    fun splitWithAtMost99(length: Int, limit: Int):Int{\\n        if(limit <= 7)  return -1\\n        val restOfStringLength = length - (limit-6)*9\\n        val numberOfCopies = ceil(restOfStringLength/(limit-7).toFloat()).toInt() + 9\\n        return if(numberOfCopies <= 99) numberOfCopies else -1\\n    }\\n\\n    fun splitWithAtMost999(length: Int, limit: Int):Int{\\n        if(limit <= 9)  return -1\\n        var restOfStringLength = length - (limit-7)*9\\n        restOfStringLength = restOfStringLength - (limit-8)*90\\n\\n        val numberOfCopies = ceil(restOfStringLength/(limit-9).toFloat()).toInt() + 99\\n        return if(numberOfCopies <= 999) numberOfCopies else -1\\n    }\\n\\n    fun splitWithAtMost9999(length: Int, limit: Int):Int{\\n        if(limit <= 9)  return -1\\n        var restOfStringLength = length - (limit-8)*9\\n        restOfStringLength = restOfStringLength - (limit-9)*90\\n        restOfStringLength = restOfStringLength - (limit-10)*900\\n\\n        val numberOfCopies = ceil(restOfStringLength/(limit-11).toFloat()).toInt() + 999\\n        return if(numberOfCopies <= 9999) numberOfCopies else -1\\n    }\\n\\n    fun splitMessage(message: String, limit: Int): Array<String> {\\n        var copies = splitAtMost9(message.length,limit)\\n        if(copies == -1){\\n            copies = splitWithAtMost99(message.length,limit)\\n        }\\n        if(copies == -1){\\n            copies = splitWithAtMost999(message.length,limit)\\n        }\\n        if(copies == -1){\\n            copies = splitWithAtMost9999(message.length,limit)\\n        }\\n        if(copies <= 0 ){\\n            return emptyArray<String>()\\n        }\\n        val ans = Array<String>(copies){\"\"}\\n        var appended = 0\\n        for(i in 1..copies){\\n            val toAppendLength = limit - \"<$i/$copies>\".length\\n            ans[i-1] = message.substring(appended,min(appended+toAppendLength,message.length)) + \"<$i/$copies>\"\\n            appended = appended+toAppendLength\\n        }\\n\\n        return ans\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3822492,
                "title": "java-easy-solution-0sec",
                "content": "# Intuition\\n![upvote.png](https://assets.leetcode.com/users/images/ece35f9d-0d3e-4e3c-b27b-a29a435a9f10_1690442582.8041968.png)\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public String[] splitMessage(String message, int limit) {\\n        try{\\n            for(int parts=1;parts<=100000;parts++)\\n            {\\n                int extralen=(3+Integer.toString(parts).length())*parts;\\n                int extra=0;\\n                if(parts>=10000)\\n                    extra=9+90*2+900*3+9000*4+1*5;\\n                else if(parts>=1000)\\n                    extra=9+90*2+900*3+(parts-1000+1)*4;\\n                else if(parts>=100)\\n                    extra=9+90*2+(parts-100+1)*3;\\n                else if(parts>=10)\\n                    extra=9+(parts-10+1)*2;\\n                else\\n                    extra=parts;\\n                extralen+=extra;\\n                int totallen=extralen+message.length();\\n                if((limit*(parts-1)<totallen)&&(totallen-limit*(parts-1)<=limit))\\n                {\\n                    String ans[]=new String[parts];\\n                    int i=0;\\n                    for(int currpart=0;currpart<ans.length;currpart++)\\n                    {\\n                        String num=Integer.toString(currpart+1);\\n                        String deno=Integer.toString(parts);\\n                        String suffix=\"<\"+num+\"/\"+deno+\">\";\\n                        int len=limit-suffix.length();\\n                        if(currpart==ans.length-1)\\n                            ans[currpart]=message.substring(i,message.length())+suffix;\\n                        else\\n                            ans[currpart]=message.substring(i,i+len)+suffix;\\n                        i+=len;\\n                    }\\n                    return ans;\\n                }\\n            }\\n        }catch(Exception e)\\n        {\\n            return new String[0];\\n        }\\n        return new String[0];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String[] splitMessage(String message, int limit) {\\n        try{\\n            for(int parts=1;parts<=100000;parts++)\\n            {\\n                int extralen=(3+Integer.toString(parts).length())*parts;\\n                int extra=0;\\n                if(parts>=10000)\\n                    extra=9+90*2+900*3+9000*4+1*5;\\n                else if(parts>=1000)\\n                    extra=9+90*2+900*3+(parts-1000+1)*4;\\n                else if(parts>=100)\\n                    extra=9+90*2+(parts-100+1)*3;\\n                else if(parts>=10)\\n                    extra=9+(parts-10+1)*2;\\n                else\\n                    extra=parts;\\n                extralen+=extra;\\n                int totallen=extralen+message.length();\\n                if((limit*(parts-1)<totallen)&&(totallen-limit*(parts-1)<=limit))\\n                {\\n                    String ans[]=new String[parts];\\n                    int i=0;\\n                    for(int currpart=0;currpart<ans.length;currpart++)\\n                    {\\n                        String num=Integer.toString(currpart+1);\\n                        String deno=Integer.toString(parts);\\n                        String suffix=\"<\"+num+\"/\"+deno+\">\";\\n                        int len=limit-suffix.length();\\n                        if(currpart==ans.length-1)\\n                            ans[currpart]=message.substring(i,message.length())+suffix;\\n                        else\\n                            ans[currpart]=message.substring(i,i+len)+suffix;\\n                        i+=len;\\n                    }\\n                    return ans;\\n                }\\n            }\\n        }catch(Exception e)\\n        {\\n            return new String[0];\\n        }\\n        return new String[0];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3728116,
                "title": "beginner-understanding",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nBest in all the way to make the beginners understand good and the flow is user-friendly.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def splitMessage(self, message: str, limit: int) -> List[str]:\\n        dig,cum_sum=[0]*10001,[0]*10001\\n        ret=0\\n        \\n        for i in range(1,10001):\\n            dig[i] = len(str(i)) \\n            cum_sum[i] = cum_sum[i-1]+dig[i]\\n        \\n        actual_size = len(message)\\n        ret=[]\\n\\n        for N in range(1,actual_size+1):\\n            newSize=actual_size+3*N+dig[N]*N+cum_sum[N]\\n\\n            if ((newSize+limit-1)//limit==N):\\n                print(\"in\",N)\\n                s=\"\"\\n                cur = 1\\n\\n                extra = dig[N]+3\\n                for c in message:\\n                    s+=c\\n                    if len(s)+dig[cur]+extra==limit:\\n                        s+=\"<\"+str(cur)+\"/\"+str(N)+\">\"\\n                        ret.append(s)\\n                        s=\"\"\\n                        cur+=1\\n                print(\"s is:\",s)\\n                if len(s):\\n                        s+=\"<\"+str(cur)+\"/\"+str(N)+\">\"\\n                        ret.append(s)\\n                        s=\"\"\\n                return ret\\n        return ret\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def splitMessage(self, message: str, limit: int) -> List[str]:\\n        dig,cum_sum=[0]*10001,[0]*10001\\n        ret=0\\n        \\n        for i in range(1,10001):\\n            dig[i] = len(str(i)) \\n            cum_sum[i] = cum_sum[i-1]+dig[i]\\n        \\n        actual_size = len(message)\\n        ret=[]\\n\\n        for N in range(1,actual_size+1):\\n            newSize=actual_size+3*N+dig[N]*N+cum_sum[N]\\n\\n            if ((newSize+limit-1)//limit==N):\\n                print(\"in\",N)\\n                s=\"\"\\n                cur = 1\\n\\n                extra = dig[N]+3\\n                for c in message:\\n                    s+=c\\n                    if len(s)+dig[cur]+extra==limit:\\n                        s+=\"<\"+str(cur)+\"/\"+str(N)+\">\"\\n                        ret.append(s)\\n                        s=\"\"\\n                        cur+=1\\n                print(\"s is:\",s)\\n                if len(s):\\n                        s+=\"<\"+str(cur)+\"/\"+str(N)+\">\"\\n                        ret.append(s)\\n                        s=\"\"\\n                return ret\\n        return ret\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3661359,
                "title": "straightforward-o-n-solution-passed-on-first-attempt",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int totalLinesRequired(int msgLength, int limit) {\\n        int maxLines = 10; // must be below this.\\n        int totalDigits;\\n        // check how many character we need for the total count of lines.\\n        for (totalDigits = 1; totalDigits < 6; ++totalDigits) {\\n            int charsLeft = msgLength;\\n            int totalLines = 0;\\n            // allocate characters needed for the count, which varies for each decimal group.\\n            int countDigits = 1;\\n            int firstLine = 1;\\n            int lastLine = 10;\\n            while (charsLeft > 0 && lastLine <= maxLines) {\\n                int suffixLength = countDigits + totalDigits + 3; // 3 is for </>\\n                int spaceAvailablePerLine = limit - suffixLength;\\n                // The suffix is bigger than the line limit, can\\'t allocate message at all.\\n                if (spaceAvailablePerLine < 0)\\n                    charsLeft = -1;\\n                else {\\n                    // Check if we can consume the remaining message with the current count\\n                    int spaceAvailable = (lastLine - firstLine) * spaceAvailablePerLine;\\n                    if (spaceAvailable >= charsLeft) {\\n                        totalLines += charsLeft / spaceAvailablePerLine;\\n                        if ((charsLeft % spaceAvailablePerLine) > 0)\\n                            totalLines++;\\n                        charsLeft = 0;\\n                    } else {\\n                        // If not, we will need more lines, increase chars for the count\\n                        countDigits++;\\n                        totalLines = lastLine - 1;\\n                        firstLine *= 10;\\n                        lastLine *= 10;;\\n                        charsLeft -= spaceAvailable;\\n                    }\\n                }\\n            }\\n            if (charsLeft == 0)\\n                return totalLines;\\n            maxLines *= 10;\\n        }\\n        return -1;\\n    }\\n\\n    vector<string> splitMessage(string message, int limit) {\\n        int totalLines = totalLinesRequired(message.size(), limit);\\n        if (totalLines == -1)\\n            return {};\\n        int i = 0;\\n        int lineIndex = 1;\\n        vector<string> result;\\n        string totalLinesString = to_string(totalLines);\\n        while (i < message.size()) {\\n            string suffix;\\n            suffix.append(\"<\");\\n            suffix.append(to_string(lineIndex));\\n            suffix.append(\"/\");\\n            suffix.append(totalLinesString);\\n            suffix.append(\">\");\\n            int msgLength = limit - suffix.size();\\n            string msg;\\n            if (message.size() - i >= msgLength)\\n                msg = message.substr(i, msgLength);\\n            else\\n                msg = message.substr(i, message.size() - i);\\n            result.push_back(msg + suffix);\\n            i += msg.size();\\n            lineIndex++;\\n        }\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int totalLinesRequired(int msgLength, int limit) {\\n        int maxLines = 10; // must be below this.\\n        int totalDigits;\\n        // check how many character we need for the total count of lines.\\n        for (totalDigits = 1; totalDigits < 6; ++totalDigits) {\\n            int charsLeft = msgLength;\\n            int totalLines = 0;\\n            // allocate characters needed for the count, which varies for each decimal group.\\n            int countDigits = 1;\\n            int firstLine = 1;\\n            int lastLine = 10;\\n            while (charsLeft > 0 && lastLine <= maxLines) {\\n                int suffixLength = countDigits + totalDigits + 3; // 3 is for </>\\n                int spaceAvailablePerLine = limit - suffixLength;\\n                // The suffix is bigger than the line limit, can\\'t allocate message at all.\\n                if (spaceAvailablePerLine < 0)\\n                    charsLeft = -1;\\n                else {\\n                    // Check if we can consume the remaining message with the current count\\n                    int spaceAvailable = (lastLine - firstLine) * spaceAvailablePerLine;\\n                    if (spaceAvailable >= charsLeft) {\\n                        totalLines += charsLeft / spaceAvailablePerLine;\\n                        if ((charsLeft % spaceAvailablePerLine) > 0)\\n                            totalLines++;\\n                        charsLeft = 0;\\n                    } else {\\n                        // If not, we will need more lines, increase chars for the count\\n                        countDigits++;\\n                        totalLines = lastLine - 1;\\n                        firstLine *= 10;\\n                        lastLine *= 10;;\\n                        charsLeft -= spaceAvailable;\\n                    }\\n                }\\n            }\\n            if (charsLeft == 0)\\n                return totalLines;\\n            maxLines *= 10;\\n        }\\n        return -1;\\n    }\\n\\n    vector<string> splitMessage(string message, int limit) {\\n        int totalLines = totalLinesRequired(message.size(), limit);\\n        if (totalLines == -1)\\n            return {};\\n        int i = 0;\\n        int lineIndex = 1;\\n        vector<string> result;\\n        string totalLinesString = to_string(totalLines);\\n        while (i < message.size()) {\\n            string suffix;\\n            suffix.append(\"<\");\\n            suffix.append(to_string(lineIndex));\\n            suffix.append(\"/\");\\n            suffix.append(totalLinesString);\\n            suffix.append(\">\");\\n            int msgLength = limit - suffix.size();\\n            string msg;\\n            if (message.size() - i >= msgLength)\\n                msg = message.substr(i, msgLength);\\n            else\\n                msg = message.substr(i, message.size() - i);\\n            result.push_back(msg + suffix);\\n            i += msg.size();\\n            lineIndex++;\\n        }\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3613483,
                "title": "o-n-easy-for-java-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public String[] splitMessage(String message, int limit) {\\n        int n = find(message.length(), limit);\\n        if (n <= -1 ) return new String[]{};\\n        int index = 0;\\n        String [] parts = new String [n];\\n        for (int i = 1; i <= n; i++) {\\n            String suffix = \"<\" + i + \"/\" +n + \">\";\\n            int last = index + limit - suffix.length();\\n            if (i == n) last = message.length();\\n            parts[i-1] =(message.substring(index, last) + suffix);\\n            index += (limit-suffix.length());\\n        }\\n        return parts;\\n    }\\n    public int find(int l, int m) {\\n        if (m <=5) return -1;\\n        else if ((l+m-6)/(m-5) <10) return (l+m-6)/(m-5);\\n        else if (m == 7 ) return -1;\\n        else if ((l+m-17)/(m-7) < 100) return (l+m-17)/(m-7);\\n        else if (m==9) return -1;\\n        else if ((l+m-118)/(m-9) < 1000) return (l+m-118)/(m-9);\\n        else if (m == 11) return -1;\\n        else return (l+m-1119)/(m-11);\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String[] splitMessage(String message, int limit) {\\n        int n = find(message.length(), limit);\\n        if (n <= -1 ) return new String[]{};\\n        int index = 0;\\n        String [] parts = new String [n];\\n        for (int i = 1; i <= n; i++) {\\n            String suffix = \"<\" + i + \"/\" +n + \">\";\\n            int last = index + limit - suffix.length();\\n            if (i == n) last = message.length();\\n            parts[i-1] =(message.substring(index, last) + suffix);\\n            index += (limit-suffix.length());\\n        }\\n        return parts;\\n    }\\n    public int find(int l, int m) {\\n        if (m <=5) return -1;\\n        else if ((l+m-6)/(m-5) <10) return (l+m-6)/(m-5);\\n        else if (m == 7 ) return -1;\\n        else if ((l+m-17)/(m-7) < 100) return (l+m-17)/(m-7);\\n        else if (m==9) return -1;\\n        else if ((l+m-118)/(m-9) < 1000) return (l+m-118)/(m-9);\\n        else if (m == 11) return -1;\\n        else return (l+m-1119)/(m-11);\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3538275,
                "title": "100-efficent-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<string> splitMessage(string message, int limit) {\\n        vector<int>dig(10001),cum_sum(10001);// contains number of digits in N and cumulative sum of number of digits.\\n        // find number of digits in X.\\n        auto number_of_digits=[](int x){\\n            int ret = 0;\\n            while(x){\\n                ret++;\\n                x/=10;\\n            }\\n            return ret;\\n        };\\n        for(int i=1;i<=10000;i++){\\n            dig[i] = number_of_digits(i); \\n            cum_sum[i] = cum_sum[i-1]+dig[i];\\n        }\\n        \\n        int actual_size = message.size();\\n        vector<string>ret;\\n        for(int N=1;N<=actual_size;N++){\\n            int newSize = actual_size+3*N+dig[N]*N+cum_sum[N];\\n            \\n            //check if possible to achieve the result.\\n            if((newSize+limit-1)/limit==N){\\n                string s;\\n                int cur = 1;\\n                //for each part we need to add <a/b> with it\\n                int extra = dig[N]+3;//as a part changes we do it in runtime\\n                for(char&c:message){\\n                    s+=c;\\n                    if(s.size()+dig[cur]+extra==limit){\\n                        s+=\"<\"+to_string(cur)+\"/\"+to_string(N)+\">\";\\n                        ret.push_back(s);\\n                        s.clear();\\n                        cur++;\\n                    }\\n                }\\n                //if last part contains less than limit characters.\\n                if(s.size()){\\n                      s+=\"<\"+to_string(cur)+\"/\"+to_string(N)+\">\";\\n                        ret.push_back(s);\\n                        s.clear();\\n                }\\n                return ret;\\n            }\\n        }\\n        return ret;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> splitMessage(string message, int limit) {\\n        vector<int>dig(10001),cum_sum(10001);// contains number of digits in N and cumulative sum of number of digits.\\n        // find number of digits in X.\\n        auto number_of_digits=[](int x){\\n            int ret = 0;\\n            while(x){\\n                ret++;\\n                x/=10;\\n            }\\n            return ret;\\n        };\\n        for(int i=1;i<=10000;i++){\\n            dig[i] = number_of_digits(i); \\n            cum_sum[i] = cum_sum[i-1]+dig[i];\\n        }\\n        \\n        int actual_size = message.size();\\n        vector<string>ret;\\n        for(int N=1;N<=actual_size;N++){\\n            int newSize = actual_size+3*N+dig[N]*N+cum_sum[N];\\n            \\n            //check if possible to achieve the result.\\n            if((newSize+limit-1)/limit==N){\\n                string s;\\n                int cur = 1;\\n                //for each part we need to add <a/b> with it\\n                int extra = dig[N]+3;//as a part changes we do it in runtime\\n                for(char&c:message){\\n                    s+=c;\\n                    if(s.size()+dig[cur]+extra==limit){\\n                        s+=\"<\"+to_string(cur)+\"/\"+to_string(N)+\">\";\\n                        ret.push_back(s);\\n                        s.clear();\\n                        cur++;\\n                    }\\n                }\\n                //if last part contains less than limit characters.\\n                if(s.size()){\\n                      s+=\"<\"+to_string(cur)+\"/\"+to_string(N)+\">\";\\n                        ret.push_back(s);\\n                        s.clear();\\n                }\\n                return ret;\\n            }\\n        }\\n        return ret;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3518106,
                "title": "two-phases-python-solution",
                "content": "# Intuition\\n\\nFirst one need to find the number of parts. After that the splitting is obvious.\\n\\n# Complexity\\n- Time complexity: $$O(n\\\\log(n))$$ where $n$ is the length of the message. \\n\\nThe $\\\\log(n)$ comes from the `tags_total_len` function which is called at most $n$ times, but this is a very rough estimation. This is true since if the `message` can be split into parts then the number of parts is at most the length of the message, and at each iteration either we stop or increase the number of parts by at least one. \\n\\n# Code\\n```\\ndef tags_total_len(n):\\n    \"\"\"returns sum(len(\"<\"+str(i)+\"/\"+str(n)+\">\") for i in range(1, n+1))\"\"\"\\n    total = 0 \\n    n_digit = 1\\n    bottom = 0\\n    top = 9\\n    while top < n:\\n        total += (top-bottom)*n_digit\\n        bottom = top\\n        top = 10*top+9\\n        n_digit += 1\\n    total += (n-bottom)*n_digit + (3+n_digit)*n\\n    return total\\n    \\ndef tags_max_len(n):\\n    return len(str(n))*2+3\\n\\nclass Solution:\\n    def splitMessage(self, message: str, limit: int) -> List[str]:\\n        required = len(message)\\n        n, r = divmod(required, limit)\\n        n = n + int(r > 0)\\n        while True:\\n            if tags_max_len(n)>=limit:\\n                return []\\n            required = len(message) + tags_total_len(n)\\n            n0, r0 = divmod(required, limit)\\n            n0 = n0 + int(r0 > 0)\\n            if n0 == n:\\n                break\\n            else:\\n                n = n0\\n        result = []\\n        start = 0\\n        for i in range(1, n+1):\\n            tag = f\"<{i}/{n}>\"\\n            mlen = limit-len(tag)\\n            result.append(message[start:start+mlen]+tag)\\n            start += mlen\\n        return result\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\ndef tags_total_len(n):\\n    \"\"\"returns sum(len(\"<\"+str(i)+\"/\"+str(n)+\">\") for i in range(1, n+1))\"\"\"\\n    total = 0 \\n    n_digit = 1\\n    bottom = 0\\n    top = 9\\n    while top < n:\\n        total += (top-bottom)*n_digit\\n        bottom = top\\n        top = 10*top+9\\n        n_digit += 1\\n    total += (n-bottom)*n_digit + (3+n_digit)*n\\n    return total\\n    \\ndef tags_max_len(n):\\n    return len(str(n))*2+3\\n\\nclass Solution:\\n    def splitMessage(self, message: str, limit: int) -> List[str]:\\n        required = len(message)\\n        n, r = divmod(required, limit)\\n        n = n + int(r > 0)\\n        while True:\\n            if tags_max_len(n)>=limit:\\n                return []\\n            required = len(message) + tags_total_len(n)\\n            n0, r0 = divmod(required, limit)\\n            n0 = n0 + int(r0 > 0)\\n            if n0 == n:\\n                break\\n            else:\\n                n = n0\\n        result = []\\n        start = 0\\n        for i in range(1, n+1):\\n            tag = f\"<{i}/{n}>\"\\n            mlen = limit-len(tag)\\n            result.append(message[start:start+mlen]+tag)\\n            start += mlen\\n        return result\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3475012,
                "title": "c-99-solution-o-n-no-binary-search-simple-math",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nif you carefully observe you can calculate exact no of parts in which one can split the string by simple maths\\nand about whether it is possible or not too.\\nfirst evaluate how many digits are going to be there in the rquired no of parts at most 5 as n-> 1e4\\nnow once no of digits is calculated no. are always  > than 99...digits-1 times this hould be added and  then extra can be calculated then simply split the string \\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n  O(1)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<string> splitMessage(string msg, int limit) {\\n        if(limit<=5) return {};\\n        int n=msg.size();\\n        int  arr[5][5]={};\\n        int a[5]={9,90,900,9000,2};\\n        for(int j=0;j<5;j++){\\n            for(int i=j;i<5;i++){\\n                arr[i][j]=a[j]*(max(0,limit-(3+i+1+j+1)));\\n            }\\n        }\\n        for(int j=1;j<5;j++){\\n            for(int i=j;i<5;i++){\\n                arr[i][j]+=arr[i][j-1];\\n            }\\n        }\\n        int digits=-1;\\n        for(int i=0;i<5;i++){\\n            if(arr[i][i]>=n){\\n                digits=i+1;\\n                break;\\n            }\\n        }\\n        for(int i=1;i<5;i++){\\n            a[i]+=a[i-1];\\n        }\\n        if(digits==-1) return {};\\n        int parts=(digits>1)?arr[digits-1][digits-2]:0;\\n        parts=ceil((1.0*(n-parts))/(limit-(3+2*digits)));\\n        parts+=(digits>1)?a[digits-2]:0;\\n        \\n        vector<string> ans(parts,\"\");\\n        int i=1;\\n        string p=to_string(parts);\\n        n=msg.size();\\n        for(int j=0;j<msg.size() && i<=parts;j++){\\n            string suf=\"<\";\\n            suf+=to_string(i);\\n            suf.push_back(\\'/\\');\\n            suf+=p;\\n            suf.push_back(\\'>\\');\\n            int x=min(n-j,limit-(int)suf.size());\\n            int k=j;\\n            for(;k<j+x;k++){\\n                ans[i-1]+=msg[k];\\n            }\\n            ans[i-1]+=suf;\\n            j=k-1;\\n            i++;\\n        }\\n        return ans;\\n    }\\n};\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> splitMessage(string msg, int limit) {\\n        if(limit<=5) return {};\\n        int n=msg.size();\\n        int  arr[5][5]={};\\n        int a[5]={9,90,900,9000,2};\\n        for(int j=0;j<5;j++){\\n            for(int i=j;i<5;i++){\\n                arr[i][j]=a[j]*(max(0,limit-(3+i+1+j+1)));\\n            }\\n        }\\n        for(int j=1;j<5;j++){\\n            for(int i=j;i<5;i++){\\n                arr[i][j]+=arr[i][j-1];\\n            }\\n        }\\n        int digits=-1;\\n        for(int i=0;i<5;i++){\\n            if(arr[i][i]>=n){\\n                digits=i+1;\\n                break;\\n            }\\n        }\\n        for(int i=1;i<5;i++){\\n            a[i]+=a[i-1];\\n        }\\n        if(digits==-1) return {};\\n        int parts=(digits>1)?arr[digits-1][digits-2]:0;\\n        parts=ceil((1.0*(n-parts))/(limit-(3+2*digits)));\\n        parts+=(digits>1)?a[digits-2]:0;\\n        \\n        vector<string> ans(parts,\"\");\\n        int i=1;\\n        string p=to_string(parts);\\n        n=msg.size();\\n        for(int j=0;j<msg.size() && i<=parts;j++){\\n            string suf=\"<\";\\n            suf+=to_string(i);\\n            suf.push_back(\\'/\\');\\n            suf+=p;\\n            suf.push_back(\\'>\\');\\n            int x=min(n-j,limit-(int)suf.size());\\n            int k=j;\\n            for(;k<j+x;k++){\\n                ans[i-1]+=msg[k];\\n            }\\n            ans[i-1]+=suf;\\n            j=k-1;\\n            i++;\\n        }\\n        return ans;\\n    }\\n};\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3471624,
                "title": "python-simple-maths",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def splitMessage(self, message, limit):\\n        p = a = 1\\n\\n        while p*(len(str(p))+3) + a + len(message) > p*limit:\\n            if 3 + len(str(p))*2 >= limit: return []\\n            p += 1\\n            a += len(str(p))                            \\n\\n        res = []\\n\\n        for i in range(1,p+1):\\n            j = limit - (len(str(i))+len(str(p))+3)\\n            part, message = message[:j], message[j:]\\n            res.append(part + \"<\"+ str(i) + \"/\" + str(p) + \">\") \\n\\n        return res\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def splitMessage(self, message, limit):\\n        p = a = 1\\n\\n        while p*(len(str(p))+3) + a + len(message) > p*limit:\\n            if 3 + len(str(p))*2 >= limit: return []\\n            p += 1\\n            a += len(str(p))                            \\n\\n        res = []\\n\\n        for i in range(1,p+1):\\n            j = limit - (len(str(i))+len(str(p))+3)\\n            part, message = message[:j], message[j:]\\n            res.append(part + \"<\"+ str(i) + \"/\" + str(p) + \">\") \\n\\n        return res\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3198288,
                "title": "o-log-n-2-to-find-number-of-parts",
                "content": "# Intuition\\nIterate over the number of digits the total parts will have\\n\\n# Approach\\nThe string size is no more than 10^4 so the max number of parts cannot be more than 10^4. 10^4 has 5 digits so the max digits a number will have is 5. The outer loop variable mdigits iterates over 1 to 5. This outer loop checks if a valid split can be obtained with the given number of mdigits. The inner loop finds out exactly how many parts are required given that the max digits allowed is mdigits. \\n\\n# Complexity\\n- Time complexity:\\nO((log N)^2) to find the number of parts.\\nO(N) to generate the answer string.\\n\\n- Space complexity:\\nO(N)\\n\\n# Code\\n```\\nclass Solution {\\n    String[] split(String m, int lim, int p){\\n        int next = 0;\\n        List<String> ans = new ArrayList<>();\\n        for(int pi=1;pi<=p;pi++){\\n            String suf = \"<\"+pi+\"/\"+p+\">\";\\n            int space = lim-suf.length();\\n            ans.add(m.substring(next,Math.min(next+space,m.length()))+suf);\\n            next+=space;\\n        }\\n        String[] arr = new String[ans.size()];\\n        ans.toArray(arr);\\n        return arr;\\n    }\\n    int div(int a, int b){\\n        int c = a/b;\\n        if(a%b!=0) c++;\\n        return c;\\n    }\\n    public String[] splitMessage(String message, int limit) {\\n        int n = message.length();\\n        for(int mdigits=1;mdigits<=5;mdigits++){\\n            int rem = n;\\n            int tparts = 0;\\n            int digs,d;\\n            for(digs=1,d=10;digs<=mdigits;digs++,d*=10){\\n                int space = limit-3-digs-mdigits;\\n                int parts = d-d/10;\\n                if(space>0){\\n                    parts = Math.min(parts,div(rem,space));\\n                } else if(space<0){\\n                    return new String[]{};\\n                }\\n                rem -= (space*parts);\\n                tparts += parts;\\n                if(rem<=0) break;\\n            }\\n            if(digs==mdigits && rem<=0){\\n                return split(message, limit, tparts);\\n            }\\n        }\\n        return new String[]{};\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    String[] split(String m, int lim, int p){\\n        int next = 0;\\n        List<String> ans = new ArrayList<>();\\n        for(int pi=1;pi<=p;pi++){\\n            String suf = \"<\"+pi+\"/\"+p+\">\";\\n            int space = lim-suf.length();\\n            ans.add(m.substring(next,Math.min(next+space,m.length()))+suf);\\n            next+=space;\\n        }\\n        String[] arr = new String[ans.size()];\\n        ans.toArray(arr);\\n        return arr;\\n    }\\n    int div(int a, int b){\\n        int c = a/b;\\n        if(a%b!=0) c++;\\n        return c;\\n    }\\n    public String[] splitMessage(String message, int limit) {\\n        int n = message.length();\\n        for(int mdigits=1;mdigits<=5;mdigits++){\\n            int rem = n;\\n            int tparts = 0;\\n            int digs,d;\\n            for(digs=1,d=10;digs<=mdigits;digs++,d*=10){\\n                int space = limit-3-digs-mdigits;\\n                int parts = d-d/10;\\n                if(space>0){\\n                    parts = Math.min(parts,div(rem,space));\\n                } else if(space<0){\\n                    return new String[]{};\\n                }\\n                rem -= (space*parts);\\n                tparts += parts;\\n                if(rem<=0) break;\\n            }\\n            if(digs==mdigits && rem<=0){\\n                return split(message, limit, tparts);\\n            }\\n        }\\n        return new String[]{};\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3185798,
                "title": "golang-solution-with-explanation",
                "content": "# Intuition\\nThe length of the suffix (`<x/y>`) determines everything else. Since the constraints say that that the length of the message is <= 10^4, that means that the mesage can be split into at most 10^4 parts, which means that the length of `y` in our suffix is at most 4.\\n\\n# Approach\\nTry to split the message assuming `y` is length 1 (i.e., less than 10 parts), and increment the length of `y` when that assumption is violated. The first viable solution will be the least number of splits since we used the shortest possible suffix.\\n\\n# Complexity\\n- Time complexity: O(N). We iterate the message at most 4 times.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N). We store the splits in a string slice and have a few other variables of constant size.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nimport \"fmt\"\\nimport \"math\"\\n\\nfunc splitMessage(message string, limit int) []string {\\n    // This will be the final result. If we don\\'t find a workable\\n    // solution this will return empty by default.\\n    var result []string\\n\\n    // Start by assuming the denominator (total number of splits) is\\n    // one digit long, and work up from there.\\n    for denomDigits := 1; denomDigits <= 4; denomDigits++ {\\n        // Track how many splits/parts we have so far\\n        numParts := 0\\n        // Make a copy of the message that we can slice up for\\n        // each attempt with a given denominator length\\n        m := message\\n        // This will contain the message pieces without suffix. We\\n        // can\\'t know the correct suffix until we\\'re done splitting.\\n        var splits []string\\n\\n        // We\\'re going to slice off the message bit by bit, so we\\n        // know we\\'re done when it\\'s empty.\\n        for len(m) > 0 {\\n            numParts++\\n            // The number of digits in the current message number\\n            // is the base-10 logarithm of the message number,\\n            // truncated to an int, plus 1.\\n            // Example:\\n            // - mesage #4\\n            //   math.Log10(4.0) == 0.6020599913279624\\n            //   truncate to int => 0\\n            //   add 1 => 1\\n            numDigits := int(math.Log10(float64(numParts))) + 1\\n\\n            // If this is true, we aren\\'t reserving enough digits\\n            // for the total number of splits. Try again with\\n            // more digits.\\n            if numDigits > denomDigits {\\n                splits = nil\\n                break\\n            }\\n\\n            // The number of characters we grab is based on the limit.\\n            // We have to make room for:\\n            //  - The number of digits in the message number\\n            //  - The number of digits in the total number of splits\\n            //  - The 3 standard suffix characters \"</>\"\\n            toGrab := limit - numDigits - denomDigits - 3\\n\\n            // We don\\'t have room to grab anything, so this won\\'t\\n            // work. Try again with more digits.\\n            if toGrab <= 0 {\\n                splits = nil\\n                break\\n            }\\n\\n            // Edge case, we are grabbing the last bit of the string\\n            // and there\\'s not enough left to hit the limit.\\n            if toGrab > len(m) {\\n                toGrab = len(m)\\n            }\\n\\n            // Add our split to the list and slice off the message.\\n            splits = append(splits, m[0:toGrab])\\n            m = m[toGrab:]\\n        }\\n\\n        // We found a viable solution.\\n        if splits != nil {\\n            // d is the total number of splits\\n            d := len(splits)\\n            for i, s := range splits {\\n                // i + 1 because we number 1 to d instead of 0 to\\n                // d -1\\n                result = append(result, fmt.Sprintf(\"%s<%d/%d>\", s, i + 1, d))\\n            }\\n            break\\n        }\\n    }\\n    return result\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nimport \"fmt\"\\nimport \"math\"\\n\\nfunc splitMessage(message string, limit int) []string {\\n    // This will be the final result. If we don\\'t find a workable\\n    // solution this will return empty by default.\\n    var result []string\\n\\n    // Start by assuming the denominator (total number of splits) is\\n    // one digit long, and work up from there.\\n    for denomDigits := 1; denomDigits <= 4; denomDigits++ {\\n        // Track how many splits/parts we have so far\\n        numParts := 0\\n        // Make a copy of the message that we can slice up for\\n        // each attempt with a given denominator length\\n        m := message\\n        // This will contain the message pieces without suffix. We\\n        // can\\'t know the correct suffix until we\\'re done splitting.\\n        var splits []string\\n\\n        // We\\'re going to slice off the message bit by bit, so we\\n        // know we\\'re done when it\\'s empty.\\n        for len(m) > 0 {\\n            numParts++\\n            // The number of digits in the current message number\\n            // is the base-10 logarithm of the message number,\\n            // truncated to an int, plus 1.\\n            // Example:\\n            // - mesage #4\\n            //   math.Log10(4.0) == 0.6020599913279624\\n            //   truncate to int => 0\\n            //   add 1 => 1\\n            numDigits := int(math.Log10(float64(numParts))) + 1\\n\\n            // If this is true, we aren\\'t reserving enough digits\\n            // for the total number of splits. Try again with\\n            // more digits.\\n            if numDigits > denomDigits {\\n                splits = nil\\n                break\\n            }\\n\\n            // The number of characters we grab is based on the limit.\\n            // We have to make room for:\\n            //  - The number of digits in the message number\\n            //  - The number of digits in the total number of splits\\n            //  - The 3 standard suffix characters \"</>\"\\n            toGrab := limit - numDigits - denomDigits - 3\\n\\n            // We don\\'t have room to grab anything, so this won\\'t\\n            // work. Try again with more digits.\\n            if toGrab <= 0 {\\n                splits = nil\\n                break\\n            }\\n\\n            // Edge case, we are grabbing the last bit of the string\\n            // and there\\'s not enough left to hit the limit.\\n            if toGrab > len(m) {\\n                toGrab = len(m)\\n            }\\n\\n            // Add our split to the list and slice off the message.\\n            splits = append(splits, m[0:toGrab])\\n            m = m[toGrab:]\\n        }\\n\\n        // We found a viable solution.\\n        if splits != nil {\\n            // d is the total number of splits\\n            d := len(splits)\\n            for i, s := range splits {\\n                // i + 1 because we number 1 to d instead of 0 to\\n                // d -1\\n                result = append(result, fmt.Sprintf(\"%s<%d/%d>\", s, i + 1, d))\\n            }\\n            break\\n        }\\n    }\\n    return result\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3183298,
                "title": "c-easy-fast",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int getLength(int n) {\\n        return to_string(n).size();\\n    }\\n    \\n    int getPossibleB(const string &message, int &limit) {\\n        int n = message.size();\\n        for (int b = 1; b <= 4; ++b) {\\n            bool isPossible = true;\\n            int a = 1;\\n            for (int j = 0; j < n; ) {\\n                if (getLength(a) > b) {\\n                    isPossible = false;\\n                    break;\\n                }\\n                int suffix = 1 + getLength(a) + 1 + b + 1; \\n                int rem = limit - suffix;\\n                j += rem;\\n                ++a;\\n            }\\n            if (isPossible) return a - 1;\\n        }\\n        return -1;\\n    }\\n    \\n    vector<string> getSplitString(const string &message, int &limit, int &b) {\\n        int n = message.size();\\n        int a = 1;\\n        vector<string> res;\\n        string bstring = to_string(b);\\n        for (int j = 0; j < n; ) {\\n            string suffix = \\'<\\' + to_string(a) + \\'/\\' + bstring + \\'>\\';\\n            int rem = limit - suffix.size();\\n            ++a;\\n            res.push_back(message.substr(j, rem) + suffix);\\n            j += rem;\\n        }\\n        return res;\\n    }\\n    \\n    vector<string> splitMessage(string message, int limit) {\\n        int b = getPossibleB(message, limit);\\n        if (b == -1) return {};\\n        return getSplitString(message, limit, b);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int getLength(int n) {\\n        return to_string(n).size();\\n    }\\n    \\n    int getPossibleB(const string &message, int &limit) {\\n        int n = message.size();\\n        for (int b = 1; b <= 4; ++b) {\\n            bool isPossible = true;\\n            int a = 1;\\n            for (int j = 0; j < n; ) {\\n                if (getLength(a) > b) {\\n                    isPossible = false;\\n                    break;\\n                }\\n                int suffix = 1 + getLength(a) + 1 + b + 1; \\n                int rem = limit - suffix;\\n                j += rem;\\n                ++a;\\n            }\\n            if (isPossible) return a - 1;\\n        }\\n        return -1;\\n    }\\n    \\n    vector<string> getSplitString(const string &message, int &limit, int &b) {\\n        int n = message.size();\\n        int a = 1;\\n        vector<string> res;\\n        string bstring = to_string(b);\\n        for (int j = 0; j < n; ) {\\n            string suffix = \\'<\\' + to_string(a) + \\'/\\' + bstring + \\'>\\';\\n            int rem = limit - suffix.size();\\n            ++a;\\n            res.push_back(message.substr(j, rem) + suffix);\\n            j += rem;\\n        }\\n        return res;\\n    }\\n    \\n    vector<string> splitMessage(string message, int limit) {\\n        int b = getPossibleB(message, limit);\\n        if (b == -1) return {};\\n        return getSplitString(message, limit, b);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3145599,
                "title": "split-message-based-on-limit-java-easy-solution",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    public String[] splitMessage(String message, int limit) {\\n        int mlen=message.length();\\n        int total=1;\\n        int plen=1;\\n\\n        while(mlen+(3+len(total))*total+plen>limit*total){\\n            if(3+len(total)*2>=limit){\\n                return new String[0];\\n            }\\n\\n            total++;\\n            plen+=len(total);\\n        }\\n\\n        String []result=new String[total];\\n        int idx=0;\\n        for(int i=0;i<total;i++){\\n            String suffix=\"<\"+(i+1)+\"/\"+(total)+\">\";\\n            String prefix=message.substring(idx,Math.min(idx+limit-suffix.length(),message.length()));\\n            idx=idx+limit-suffix.length();\\n            result[i]=prefix+suffix;\\n        }\\n\\n        return result;\\n    }\\n\\n    public int len(int s){\\n        return Integer.toString(s).length();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String[] splitMessage(String message, int limit) {\\n        int mlen=message.length();\\n        int total=1;\\n        int plen=1;\\n\\n        while(mlen+(3+len(total))*total+plen>limit*total){\\n            if(3+len(total)*2>=limit){\\n                return new String[0];\\n            }\\n\\n            total++;\\n            plen+=len(total);\\n        }\\n\\n        String []result=new String[total];\\n        int idx=0;\\n        for(int i=0;i<total;i++){\\n            String suffix=\"<\"+(i+1)+\"/\"+(total)+\">\";\\n            String prefix=message.substring(idx,Math.min(idx+limit-suffix.length(),message.length()));\\n            idx=idx+limit-suffix.length();\\n            result[i]=prefix+suffix;\\n        }\\n\\n        return result;\\n    }\\n\\n    public int len(int s){\\n        return Integer.toString(s).length();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3116627,
                "title": "explained-and-commented-simple-solution",
                "content": "\\n```\\nclass Solution {\\n    public String[] splitMessage(String message, int limit) {\\n        int[] stgTable = {\\n                (limit - 5) * 9,\\n                (limit - 6) * 9 + (limit - 7) * 90,\\n                (limit - 7) * 9 + (limit - 8) * 90 + (limit - 9) * 900,\\n                (limit - 8) * 9 + (limit - 9) * 90 + (limit - 10) * 900 + (limit - 11) * 9000,\\n        };\\n        int l = message.length(), stg = 0;\\n        while (stg < stgTable.length) {\\n            if (stgTable[stg] >= l) break;\\n            stg++;\\n        }\\n        if (stg == stgTable.length) return new String[0];\\n        ArrayList<String> list = new ArrayList<>();\\n        int idx = 1, strIdx = 0;\\n        for (int i = 0; i <= stg; i++) {\\n            int size = limit - 5 - stg - i;\\n            for (int j = 0; j < 9 * Math.pow(10, i) && strIdx < message.length(); j++) {\\n                list.add(message.substring(strIdx, Math.min(message.length(), strIdx + size)) + \"<\" + idx);\\n                strIdx += size;\\n                idx++;\\n            }\\n        }\\n        String[] res = list.toArray(new String[]{});\\n        for (int i = 0; i < res.length; i++)\\n            res[i] = res[i] + \"/\" + (idx - 1) + \">\";\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String[] splitMessage(String message, int limit) {\\n        int[] stgTable = {\\n                (limit - 5) * 9,\\n                (limit - 6) * 9 + (limit - 7) * 90,\\n                (limit - 7) * 9 + (limit - 8) * 90 + (limit - 9) * 900,\\n                (limit - 8) * 9 + (limit - 9) * 90 + (limit - 10) * 900 + (limit - 11) * 9000,\\n        };\\n        int l = message.length(), stg = 0;\\n        while (stg < stgTable.length) {\\n            if (stgTable[stg] >= l) break;\\n            stg++;\\n        }\\n        if (stg == stgTable.length) return new String[0];\\n        ArrayList<String> list = new ArrayList<>();\\n        int idx = 1, strIdx = 0;\\n        for (int i = 0; i <= stg; i++) {\\n            int size = limit - 5 - stg - i;\\n            for (int j = 0; j < 9 * Math.pow(10, i) && strIdx < message.length(); j++) {\\n                list.add(message.substring(strIdx, Math.min(message.length(), strIdx + size)) + \"<\" + idx);\\n                strIdx += size;\\n                idx++;\\n            }\\n        }\\n        String[] res = list.toArray(new String[]{});\\n        for (int i = 0; i < res.length; i++)\\n            res[i] = res[i] + \"/\" + (idx - 1) + \">\";\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3016139,
                "title": "o-log-message-without-searching",
                "content": "# Intuition\\n* each item in the result varies because of total number of splits\\n   * for example, for message like \"this is a message...\", the split could be either [\"**this**<1/**7**>\",...] or [\"**thi**<1/**23**\">,...]\\n* So, we need to guess the possible number of splits and its number of digits\\n* it could be between [1-9],[10-99],[100-999]...\\n* since the input message is constrained by 10^4, maximum number of digits could be 5\\n* A mesage cannot be split more than its number of characters (`n`)\\n* So, if we iterate the ranges [1-9],[10-99],[100-999].., the range where we exhaust `n` is the solution\\n\\n# Approach\\n* guess the range in [1-9],[10-99],[100-999]... Needed because, number of chars in each split depends on this guess (`i`)\\n* keep a remaining chars count `rem`\\n* check if we exhaust the characters in the guessed range\\n* if so, print else try next `i`\\n\\nFor subtracting consumed chars in message:\\n* every split has fixed chars `</>`. subtract 3 for it\\n* other subtractions depends on guessed `i` - total digits of splits and `j` current range number of digits.\\n* chars in each split that will be consumed is `limit-i-j-3`\\n\\n# Complexity\\n- Time complexity:\\n**O(log(message))** \\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```python\\nclass Solution:\\n    def splitMessage(self, message: str, limit: int) -> List[str]:\\n        n = len(message)\\n        \\n        # to print solution\\n        def split(x):\\n            res = []\\n            s = message\\n            for i in range(1,x+1):\\n                r = limit-3-len(str(i))-len(str(x))\\n                res.append(s[:r] + f\"<{i}/{x}>\")\\n                s = s[r:]\\n            return res\\n\\n        rem = n                   # remaining chars for splitting\\n        for i in range(1,10):\\n            left,right = 1,None\\n            rem = n\\n            possible = False\\n            for j in range(1,i+1):\\n                left,right = pow(10,j-1),pow(10,j)-1\\n                each = limit-3-i-j\\n                if each <= 0:\\n                    return []\\n                pieces = (rem+each-1)//each     # ceil\\n                if left + pieces -1 <= right:   # exhaust splits within range\\n                    possible = True\\n                    right = left + pieces-1     # update right and this is solution\\n                    break\\n                rem -= (right-left+1)*each      # move to next range\\n            if possible:\\n                return split(right)\\n        return []\\n                \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```python\\nclass Solution:\\n    def splitMessage(self, message: str, limit: int) -> List[str]:\\n        n = len(message)\\n        \\n        # to print solution\\n        def split(x):\\n            res = []\\n            s = message\\n            for i in range(1,x+1):\\n                r = limit-3-len(str(i))-len(str(x))\\n                res.append(s[:r] + f\"<{i}/{x}>\")\\n                s = s[r:]\\n            return res\\n\\n        rem = n                   # remaining chars for splitting\\n        for i in range(1,10):\\n            left,right = 1,None\\n            rem = n\\n            possible = False\\n            for j in range(1,i+1):\\n                left,right = pow(10,j-1),pow(10,j)-1\\n                each = limit-3-i-j\\n                if each <= 0:\\n                    return []\\n                pieces = (rem+each-1)//each     # ceil\\n                if left + pieces -1 <= right:   # exhaust splits within range\\n                    possible = True\\n                    right = left + pieces-1     # update right and this is solution\\n                    break\\n                rem -= (right-left+1)*each      # move to next range\\n            if possible:\\n                return split(right)\\n        return []\\n                \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2951971,
                "title": "based-on-the-great-idea-from-lee215-rename-variables-and-add-comment-for-easier-understanding",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Based on the idea from leetcode discussion\\n * https://leetcode.com/problems/split-message-based-on-limit/solutions/2807533/python-find-the-number-of-substrings/?orderBy=most_votes\\n *\\n * @param {string} message\\n * @param {number} limit\\n * @return {string[]}\\n */\\nvar splitMessage = function (message, limit) {\\n  function getLen(number) {\\n    if (Number.isNaN(number) || number < 0)\\n      throw new Error(`Invalid input: ${number}`);\\n\\n    return number.toString().length;\\n  }\\n\\n  const MESSAGE_LEN = message.length;\\n  // the suffix is in format <index/total>, both index and total are number\\n  let splittedCount = 0; // the total splitted message count\\n  let totalSuffixIndexPart = 0; // the total length of index part of suffix\\n  while (\\n    3 + 2 * getLen(splittedCount) < limit &&\\n    MESSAGE_LEN +\\n      totalSuffixIndexPart +\\n      splittedCount * (3 + getLen(splittedCount)) >\\n      splittedCount * limit\\n  ) {\\n    // order of  below 2 lines are very important, k++ must be first\\n    splittedCount++;\\n    totalSuffixIndexPart += getLen(splittedCount);\\n  }\\n\\n  if (\\n    MESSAGE_LEN +\\n      totalSuffixIndexPart +\\n      splittedCount * (3 + getLen(splittedCount)) >\\n    splittedCount * limit\\n  )\\n    return [];\\n\\n  let suffixTotalLen = getLen(splittedCount);\\n  let ans = [];\\n  let copyStartIndex = 0;\\n\\n  for (let splitIndex = 1; splitIndex <= splittedCount; splitIndex++) {\\n    let chars = limit - 3 - suffixTotalLen - getLen(splitIndex);\\n    let copyEndIdx = Math.min(copyStartIndex + chars, MESSAGE_LEN);\\n    ans.push(\\n      `${message.substring(\\n        copyStartIndex,\\n        copyEndIdx\\n      )}<${splitIndex}/${splittedCount}>`\\n    );\\n    if (copyEndIdx === MESSAGE_LEN) return ans;\\n\\n    copyStartIndex = copyEndIdx;\\n  }\\n\\n  return ans;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * Based on the idea from leetcode discussion\\n * https://leetcode.com/problems/split-message-based-on-limit/solutions/2807533/python-find-the-number-of-substrings/?orderBy=most_votes\\n *\\n * @param {string} message\\n * @param {number} limit\\n * @return {string[]}\\n */\\nvar splitMessage = function (message, limit) {\\n  function getLen(number) {\\n    if (Number.isNaN(number) || number < 0)\\n      throw new Error(`Invalid input: ${number}`);\\n\\n    return number.toString().length;\\n  }\\n\\n  const MESSAGE_LEN = message.length;\\n  // the suffix is in format <index/total>, both index and total are number\\n  let splittedCount = 0; // the total splitted message count\\n  let totalSuffixIndexPart = 0; // the total length of index part of suffix\\n  while (\\n    3 + 2 * getLen(splittedCount) < limit &&\\n    MESSAGE_LEN +\\n      totalSuffixIndexPart +\\n      splittedCount * (3 + getLen(splittedCount)) >\\n      splittedCount * limit\\n  ) {\\n    // order of  below 2 lines are very important, k++ must be first\\n    splittedCount++;\\n    totalSuffixIndexPart += getLen(splittedCount);\\n  }\\n\\n  if (\\n    MESSAGE_LEN +\\n      totalSuffixIndexPart +\\n      splittedCount * (3 + getLen(splittedCount)) >\\n    splittedCount * limit\\n  )\\n    return [];\\n\\n  let suffixTotalLen = getLen(splittedCount);\\n  let ans = [];\\n  let copyStartIndex = 0;\\n\\n  for (let splitIndex = 1; splitIndex <= splittedCount; splitIndex++) {\\n    let chars = limit - 3 - suffixTotalLen - getLen(splitIndex);\\n    let copyEndIdx = Math.min(copyStartIndex + chars, MESSAGE_LEN);\\n    ans.push(\\n      `${message.substring(\\n        copyStartIndex,\\n        copyEndIdx\\n      )}<${splitIndex}/${splittedCount}>`\\n    );\\n    if (copyEndIdx === MESSAGE_LEN) return ans;\\n\\n    copyStartIndex = copyEndIdx;\\n  }\\n\\n  return ans;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2951485,
                "title": "2-steps-solution-easy-understanding",
                "content": "# Intuition\\n  2 steps to split message\\n\\n# Approach\\n  Step 1: calculate an array whose item is the chars     amount that can be spliited at a specific suffix length.\\n     Step 2: calcuate the total number of splitted message. Based on the array from step 1, copy meessage into final answer array.\\n \\n\\n# Complexity\\n- Time complexity:\\n  O(N)\\n\\n- Space complexity:\\n  O(N)\\n\\n# Code\\n```\\n/**\\n * @param {string} message\\n * @param {number} limit\\n * @return {string[]}\\n */\\nvar splitMessage = function (message, limit) {\\n  if (limit <= 5) return [];\\n\\n  const MESSAGE_LEN = message.length;\\n  const NINE = 9;\\n\\n  /* \\n  // the suffix is in format <index/total>, both index and total are number type\\n\\n  When given digits value, calcuate an array.\\n  Item of the array is the total chars can be spliited from message, at this level the suffix is same length.\\n  But the next item of the array, the suffix length will be ONE more than previous. \\n\\n  digits: digit length of the [total number] of splitted message\\n   value 1: means range of [1, 9] messages allowed to be splitted.\\n   value 2: means range of [1, 99] messages allowed to be splitted.\\n   value 3: means range of [1, 999] messages allowed to be splitted.\\n   ...etc\\n   */\\n  function calcuate(digits) {\\n    let sum = 0;\\n    let charsAmountArr = [];\\n\\n    // the suffix is in format <index/total>, both index and total are number type\\n    for (let idxLen = 1; idxLen <= digits; idxLen++) {\\n      let countCanSplit = NINE * Math.pow(10, idxLen - 1);\\n      let charsCanSplit = countCanSplit * (limit - 3 - digits - idxLen);\\n      charsAmountArr.push(charsCanSplit);\\n      sum += charsCanSplit;\\n    }\\n\\n    if (sum < MESSAGE_LEN) return [];\\n    else return charsAmountArr;\\n  }\\n\\n  let charsAmountArr = [];\\n  for (let i = 1; i <= limit - 5; i++) {\\n    charsAmountArr = calcuate(i);\\n    if (charsAmountArr.length > 0) break;\\n  }\\n  if (charsAmountArr.length < 1) return [];\\n\\n  // the suffix is in format <index/total>, both index and total are number\\n  // Now, we need calcuate the total value\\n  let remaining = MESSAGE_LEN;\\n  let arrLen = charsAmountArr.length;\\n  for (let i = 0; i < arrLen - 1; i++) remaining -= charsAmountArr[i];\\n  let base = Math.pow(10, arrLen - 1) - 1;\\n  let chars = limit - 3 - 2 * arrLen;\\n  let total = base + Math.ceil(remaining / chars);\\n\\n  let ans = [];\\n  let copyStartIndex = 0;\\n  let splitIndex = 1;\\n  for (let i = 0; i < arrLen; i++) {\\n    let charsAmount = charsAmountArr[i];\\n    let chars = limit - 3 - arrLen - (i + 1);\\n    for (let j = 0; j < charsAmount / chars; j++) {\\n      let copyEndIdx = Math.min(copyStartIndex + chars, MESSAGE_LEN);\\n      ans.push(\\n        `${message.substring(\\n          copyStartIndex,\\n          copyEndIdx\\n        )}<${splitIndex}/${total}>`\\n      );\\n      if (copyEndIdx === MESSAGE_LEN) return ans;\\n\\n      splitIndex++;\\n      copyStartIndex = copyEndIdx;\\n    }\\n  }\\n\\n  return ans;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string} message\\n * @param {number} limit\\n * @return {string[]}\\n */\\nvar splitMessage = function (message, limit) {\\n  if (limit <= 5) return [];\\n\\n  const MESSAGE_LEN = message.length;\\n  const NINE = 9;\\n\\n  /* \\n  // the suffix is in format <index/total>, both index and total are number type\\n\\n  When given digits value, calcuate an array.\\n  Item of the array is the total chars can be spliited from message, at this level the suffix is same length.\\n  But the next item of the array, the suffix length will be ONE more than previous. \\n\\n  digits: digit length of the [total number] of splitted message\\n   value 1: means range of [1, 9] messages allowed to be splitted.\\n   value 2: means range of [1, 99] messages allowed to be splitted.\\n   value 3: means range of [1, 999] messages allowed to be splitted.\\n   ...etc\\n   */\\n  function calcuate(digits) {\\n    let sum = 0;\\n    let charsAmountArr = [];\\n\\n    // the suffix is in format <index/total>, both index and total are number type\\n    for (let idxLen = 1; idxLen <= digits; idxLen++) {\\n      let countCanSplit = NINE * Math.pow(10, idxLen - 1);\\n      let charsCanSplit = countCanSplit * (limit - 3 - digits - idxLen);\\n      charsAmountArr.push(charsCanSplit);\\n      sum += charsCanSplit;\\n    }\\n\\n    if (sum < MESSAGE_LEN) return [];\\n    else return charsAmountArr;\\n  }\\n\\n  let charsAmountArr = [];\\n  for (let i = 1; i <= limit - 5; i++) {\\n    charsAmountArr = calcuate(i);\\n    if (charsAmountArr.length > 0) break;\\n  }\\n  if (charsAmountArr.length < 1) return [];\\n\\n  // the suffix is in format <index/total>, both index and total are number\\n  // Now, we need calcuate the total value\\n  let remaining = MESSAGE_LEN;\\n  let arrLen = charsAmountArr.length;\\n  for (let i = 0; i < arrLen - 1; i++) remaining -= charsAmountArr[i];\\n  let base = Math.pow(10, arrLen - 1) - 1;\\n  let chars = limit - 3 - 2 * arrLen;\\n  let total = base + Math.ceil(remaining / chars);\\n\\n  let ans = [];\\n  let copyStartIndex = 0;\\n  let splitIndex = 1;\\n  for (let i = 0; i < arrLen; i++) {\\n    let charsAmount = charsAmountArr[i];\\n    let chars = limit - 3 - arrLen - (i + 1);\\n    for (let j = 0; j < charsAmount / chars; j++) {\\n      let copyEndIdx = Math.min(copyStartIndex + chars, MESSAGE_LEN);\\n      ans.push(\\n        `${message.substring(\\n          copyStartIndex,\\n          copyEndIdx\\n        )}<${splitIndex}/${total}>`\\n      );\\n      if (copyEndIdx === MESSAGE_LEN) return ans;\\n\\n      splitIndex++;\\n      copyStartIndex = copyEndIdx;\\n    }\\n  }\\n\\n  return ans;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2947685,
                "title": "python-solution-w-explanation-can-definitely-be-improved",
                "content": "# Intuition\\nThis was definitely a tough one that took me a few attempts and revisions.  I\\'ll take a pass on talking about initial intuition :).\\n\\n# Approach\\nThe key problem here is determining how to break apart the string, specifically how many many blocks are required.  Adding more blocks is a push and pull as it increases the available space in the output, but that space is consumed by what I call the overhead, the \"<a/b>\" message that\\'s present in each block.\\n\\nI couldn\\'t really figure out an optimal initial guess for the number of blocks, so I just start at one and increment by one until the available space can contain the message (this is why I believe my solution can be improved).  For each block size, here\\'s the steps to determine the available space:\\n\\\\* Raw availability is the # of blocks * limit\\n\\\\* Subtract 3 * blocks from the availability, because each block will contain each of the following characters \"</>\"\\n\\\\* Subtract len(str(blocks)) * blocks from the availability, because each block will contain the total block count, the b in <a/b>.  For some examples, if the number of blocks is 7, each block will have 1 character consumed in this fashion, and if the number of blocks is 5678, each block will have 4 characters consumed.\\n\\\\* Up to now we\\'ve dealt with all of the overhead in <a/b> except for \"a\", and to deal with a, a procedure is done to determine the string length of each number up to the total block count.  (This is the for loop in the initial while loop.)  The for loop uses powers of 10 to determine the digit counts of the numbers below the total block count.  Using that block count of 5678 from earlier, for the \"a\" in the output that increments:\\n\\\\- There are 9 single digit numbers that consume 9 units of space\\n\\\\- There are 90 double digit numbers that consume 180 units of space\\n\\\\- There are 900 three digit numbers that consume 2700 units of space\\n\\\\- There are 4679 four digit numbers that consume 18716 units of space.  This is the last check that we need to perform since the total block count has 4 digits.\\nIf the remaining availability if >= the length of the message, then this block count is good.  If the availability is not OK, increment block count by one (there has to be a more efficient way).  If the block count eventually gets up to the length of the message and the availability is still not OK, then this is the \"impossible to transmit\" scenario and we return an empty [].\\n\\nOnce the proper block count is determined, transmitting the message is relatively straightforward.  This code uses a counter to iterate through the blocks up to the penultimate block, and also uses an index tracker since the overhead will vary per block.  For each block, the overhead usage is determined using 3 (\"</>) + the length of the current block number + the length of the total number of blocks.  This is subtracted from the limit, and based on the remainder, we can consume that many characters from the original message.  The end of the message (final block) is handled slightly differently since that segment may be shorter than the limit, so we just print the remainder of the message, and we know the <a/b> in the overhead.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def splitMessage(self, message: str, limit: int) -> List[str]:\\n        blocks = 1\\n        output = []\\n        acceptable = False\\n\\n        while not acceptable:\\n            avail = blocks*limit\\n            avail -= (blocks * 3) #</>\\n            avail -= (blocks * len(str(blocks))) # denominator\\n\\n            for i in range(1, len(str(blocks))+1):\\n                if blocks > (pow(10,i)-1):\\n                    avail-=( (pow(10,i) - pow(10,i-1)) * i)\\n                else:\\n                    avail-= (( blocks - (pow(10,(i-1)) - 1)) * i)\\n            if blocks == len(message) and avail < len(message):\\n                return output\\n            else:\\n                if avail >= len(message):\\n                    acceptable = True\\n                    currgood = True\\n                    #blocks -=1\\n                else:\\n                    currgood = False\\n                    blocks += 1\\n\\n        currblock = 0\\n        index = 0\\n        \\n        while currblock < (blocks-1):\\n            currblock+=1\\n            overhead = 3 + len(str(currblock))+len(str(blocks))\\n            output.append(message[index:index+limit-overhead]+\"<\"+str(currblock)+\"/\"+str(blocks)+\">\")\\n            index+=(limit-overhead)\\n    \\n        output.append(message[index:]+\"<\"+str(blocks)+\"/\"+str(blocks)+\">\")\\n\\n        return output\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def splitMessage(self, message: str, limit: int) -> List[str]:\\n        blocks = 1\\n        output = []\\n        acceptable = False\\n\\n        while not acceptable:\\n            avail = blocks*limit\\n            avail -= (blocks * 3) #</>\\n            avail -= (blocks * len(str(blocks))) # denominator\\n\\n            for i in range(1, len(str(blocks))+1):\\n                if blocks > (pow(10,i)-1):\\n                    avail-=( (pow(10,i) - pow(10,i-1)) * i)\\n                else:\\n                    avail-= (( blocks - (pow(10,(i-1)) - 1)) * i)\\n            if blocks == len(message) and avail < len(message):\\n                return output\\n            else:\\n                if avail >= len(message):\\n                    acceptable = True\\n                    currgood = True\\n                    #blocks -=1\\n                else:\\n                    currgood = False\\n                    blocks += 1\\n\\n        currblock = 0\\n        index = 0\\n        \\n        while currblock < (blocks-1):\\n            currblock+=1\\n            overhead = 3 + len(str(currblock))+len(str(blocks))\\n            output.append(message[index:index+limit-overhead]+\"<\"+str(currblock)+\"/\"+str(blocks)+\">\")\\n            index+=(limit-overhead)\\n    \\n        output.append(message[index:]+\"<\"+str(blocks)+\"/\"+str(blocks)+\">\")\\n\\n        return output\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2917402,
                "title": "simple-java-solution-simulation",
                "content": "\\n\\n# Code\\n```\\n// if you found my solution usefull please upvote it\\nclass Solution \\n{\\n    public List<String> fun(String str,int limit,int digits)\\n    {\\n        List<String> ans=new ArrayList();\\n        int parts=1;\\n        int i=0;\\n        String digit=\"\";\\n        for(int idx=0;idx<digits;idx++)  digit=digit+\"-\";\\n        while(i<str.length())\\n        {\\n            String suffixLength=\"<\"+parts+\"/\"+digit+\">\";\\n            parts++;\\n            int currLength=limit-suffixLength.length();\\n            if(currLength<=0)  return new ArrayList();\\n            String charLeft=\"\";\\n            while(i<str.length() && currLength-->0)\\n            {\\n                charLeft=charLeft+str.charAt(i);\\n                i++;\\n            }\\n            ans.add(charLeft);\\n        }\\n        if(String.valueOf(parts-1).length()!=digits)  return new ArrayList();\\n        String length=String.valueOf(parts-1);\\n        parts=1;\\n        int idx=0;\\n        for(String curr : ans)\\n        {\\n            String suffix=\"<\"+parts+\"/\"+length+\">\";\\n            parts++;\\n            curr=curr+suffix;\\n            ans.set(idx,curr);\\n            idx++;\\n        }\\n        return ans;\\n    }\\n    public String[] splitMessage(String message, int limit) \\n    {\\n        for(int i=1;i<5;i++)\\n        {\\n            List<String> curr=fun(message,limit,i);\\n            if(curr.size()!=0)\\n            {\\n                String[] ans=new String[curr.size()];\\n                for(int j=0;j<curr.size();j++)  ans[j]=curr.get(j);\\n                return ans;\\n            }\\n        }\\n        return new String[0];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n// if you found my solution usefull please upvote it\\nclass Solution \\n{\\n    public List<String> fun(String str,int limit,int digits)\\n    {\\n        List<String> ans=new ArrayList();\\n        int parts=1;\\n        int i=0;\\n        String digit=\"\";\\n        for(int idx=0;idx<digits;idx++)  digit=digit+\"-\";\\n        while(i<str.length())\\n        {\\n            String suffixLength=\"<\"+parts+\"/\"+digit+\">\";\\n            parts++;\\n            int currLength=limit-suffixLength.length();\\n            if(currLength<=0)  return new ArrayList();\\n            String charLeft=\"\";\\n            while(i<str.length() && currLength-->0)\\n            {\\n                charLeft=charLeft+str.charAt(i);\\n                i++;\\n            }\\n            ans.add(charLeft);\\n        }\\n        if(String.valueOf(parts-1).length()!=digits)  return new ArrayList();\\n        String length=String.valueOf(parts-1);\\n        parts=1;\\n        int idx=0;\\n        for(String curr : ans)\\n        {\\n            String suffix=\"<\"+parts+\"/\"+length+\">\";\\n            parts++;\\n            curr=curr+suffix;\\n            ans.set(idx,curr);\\n            idx++;\\n        }\\n        return ans;\\n    }\\n    public String[] splitMessage(String message, int limit) \\n    {\\n        for(int i=1;i<5;i++)\\n        {\\n            List<String> curr=fun(message,limit,i);\\n            if(curr.size()!=0)\\n            {\\n                String[] ans=new String[curr.size()];\\n                for(int j=0;j<curr.size();j++)  ans[j]=curr.get(j);\\n                return ans;\\n            }\\n        }\\n        return new String[0];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2890912,
                "title": "pythion-easy-to-understand",
                "content": "```\\n# explanation: https://leetcode.com/problems/split-message-based-on-limit/discuss/2807165/Brute-Force-oror-Simple-Approach-oror-C%2B%2B-oror-Explained\\n# cpp code: https://leetcode.com/problems/split-message-based-on-limit/discuss/2807165/Brute-Force-oror-Simple-Approach-oror-C%2B%2B-oror-Explained\\n\\nclass Solution:\\n    def splitMessage(self, message: str, limit: int) -> List[str]:\\n        dig,cum_sum=[0]*10001,[0]*10001\\n        ret=0\\n        \\n        for i in range(1,10001):\\n            dig[i] = len(str(i)) \\n            cum_sum[i] = cum_sum[i-1]+dig[i]\\n        \\n        actual_size = len(message)\\n        ret=[]\\n\\n        for N in range(1,actual_size+1):\\n            newSize=actual_size+3*N+dig[N]*N+cum_sum[N]\\n\\n            if ((newSize+limit-1)//limit==N):\\n                print(\"in\",N)\\n                s=\"\"\\n                cur = 1\\n\\n                extra = dig[N]+3\\n                for c in message:\\n                    s+=c\\n                    if len(s)+dig[cur]+extra==limit:\\n                        s+=\"<\"+str(cur)+\"/\"+str(N)+\">\"\\n                        ret.append(s)\\n                        s=\"\"\\n                        cur+=1\\n                print(\"s is:\",s)\\n                if len(s):\\n                        s+=\"<\"+str(cur)+\"/\"+str(N)+\">\"\\n                        ret.append(s)\\n                        s=\"\"\\n                return ret\\n        return ret\\n                \\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\n# explanation: https://leetcode.com/problems/split-message-based-on-limit/discuss/2807165/Brute-Force-oror-Simple-Approach-oror-C%2B%2B-oror-Explained\\n# cpp code: https://leetcode.com/problems/split-message-based-on-limit/discuss/2807165/Brute-Force-oror-Simple-Approach-oror-C%2B%2B-oror-Explained\\n\\nclass Solution:\\n    def splitMessage(self, message: str, limit: int) -> List[str]:\\n        dig,cum_sum=[0]*10001,[0]*10001\\n        ret=0\\n        \\n        for i in range(1,10001):\\n            dig[i] = len(str(i)) \\n            cum_sum[i] = cum_sum[i-1]+dig[i]\\n        \\n        actual_size = len(message)\\n        ret=[]\\n\\n        for N in range(1,actual_size+1):\\n            newSize=actual_size+3*N+dig[N]*N+cum_sum[N]\\n\\n            if ((newSize+limit-1)//limit==N):\\n                print(\"in\",N)\\n                s=\"\"\\n                cur = 1\\n\\n                extra = dig[N]+3\\n                for c in message:\\n                    s+=c\\n                    if len(s)+dig[cur]+extra==limit:\\n                        s+=\"<\"+str(cur)+\"/\"+str(N)+\">\"\\n                        ret.append(s)\\n                        s=\"\"\\n                        cur+=1\\n                print(\"s is:\",s)\\n                if len(s):\\n                        s+=\"<\"+str(cur)+\"/\"+str(N)+\">\"\\n                        ret.append(s)\\n                        s=\"\"\\n                return ret\\n        return ret\\n                \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2869213,
                "title": "o-n-c-clean-code-explanation-must-read",
                "content": "# Intuition\\nFirst thoughts were to use Binary Search but that for some reason that didn\\'t give me the smallest partition size.\\nThen I realized, using some basic mathematics, it can be determined if the smallest partition size is one digit, two digits, three digits, four digits or five digits.\\nOnce you know the smallest partition size, to tokenize is an easy problem.\\n# Approach\\n    If Smallest Partition Size is One Digit\\n    tag_size = 5(<x/y>)\\n    message split per partition = limit - tag_size\\n    if(ceil(message.size() / message_split_per_partition) < 10)\\n    {\\n        ceil(message.size() / message_split_per_partition) is partition_size\\n    }\\n\\n    If Smallest Partition Size is Two Digit\\n    tag_size_for_first_nine_tokens = 6(<x/yz>)\\n    tag_size_for_next_ninety_tokens = 7(<wx/yz>)\\n\\n    message split per partition for first nine = limit - 6\\n    message split per partition for next ninty = limit - 7\\n    messageSize -= (message split per partition for first nine) * 9\\n\\n    if(ceil(messageSize / message_split_per_partition_for_next_ninety) < 100)\\n    {\\n        (9 + ceil(messageSize() / message_split_per_partition_for_next_ninty)) is partition_size\\n    }\\n\\nso on for three, four and Five digits case\\n# Complexity\\n- Time complexity:\\n$$O(n)$$ \\n(yes I felt lazy and used substr function which might negate this claim. But you can tokenize in $$O(n)$$)\\n- Space complexity:\\n$$O(n)$$ if you include ans vector in it.\\n\\n# Code\\n```\\nclass Solution {\\n    int getOneDigit(int size, int limit){\\n        int partLen1 = limit-5;\\n        if(partLen1 <= 0) return -1;\\n\\n        int num = (int)ceil((double)size / (double)partLen1);\\n        return (num < 10) ? num : -1;\\n    }\\n    int getTwoDigit(int size, int limit){\\n        int partLen1 = limit-6;\\n        int partLen2 = limit-7;\\n        if(partLen1 <= 0 or partLen2 <= 0) return -1;\\n        int num = 9;\\n        size -= partLen1*9;\\n        if(size < 0) return -1;\\n        num += (int)ceil((double)size / (double)partLen2);\\n        return (num < 100) ? num : -1;\\n    }\\n    int getThreeDigit(int size, int limit){\\n        int partLen1 = limit-7;\\n        int partLen2 = limit-8;\\n        int partLen3 = limit-9;\\n        if(partLen1 <= 0 or partLen2 <= 0 or partLen3 <= 0) return -1;\\n        int num = 99;\\n        size -= partLen1*9;\\n        size -= partLen2*90;\\n        if(size < 0) return -1;\\n        num += (int)ceil((double)size / (double)partLen3);\\n        return (num < 1000) ? num : -1;\\n    }\\n    int getFourDigit(int size, int limit){\\n        int partLen1 = limit-8;\\n        int partLen2 = limit-9;\\n        int partLen3 = limit-10;\\n        int partLen4 = limit-11;\\n        \\n        if(partLen1 <= 0 or partLen2 <= 0 or partLen3 <= 0 or partLen4 <= 0) return -1;\\n        int num = 999;\\n        size -= partLen1*9;\\n        size -= partLen2*90;\\n        size -= partLen3*900;\\n        if(size < 0) return -1;\\n        num += (int)ceil((double)size / (double)partLen4);\\n        return (num < 10000) ? num : -1;\\n    }\\n    int getFiveDigit(int size, int limit){\\n        int partLen1 = limit-9;\\n        int partLen2 = limit-10;\\n        int partLen3 = limit-11;\\n        int partLen4 = limit-12;\\n        int partLen5 = limit-13;\\n        \\n        if(partLen1 <= 0 or partLen2 <= 0 or partLen3 <= 0 or partLen4 <= 0 or partLen5 <= 0) return -1;\\n        int num = 9999;\\n        size -= partLen1*9;\\n        size -= partLen2*90;\\n        size -= partLen3*900;\\n        size -= partLen3*9000;\\n        \\n        if(size < 0) return -1;\\n        num += (int)ceil((double)size / (double)partLen5);\\n        return (num < 100000) ? num : -1;\\n    }\\n    vector<string> getTokens(string message, int limit, int partSize){\\n        vector<string> vec;\\n        string temp = \"/\" + to_string(partSize) + \">\";\\n        int pos = 0;\\n        for(int i = 0 ; i < partSize ; i++){\\n            \\n            string tag = \"<\" + to_string(i+1) + temp;\\n            int len = 0;\\n            if(i == partSize-1){\\n                len = message.size() - pos+1;\\n            }\\n            else{\\n                len = limit - tag.size();\\n            }\\n            vec.push_back(message.substr(pos, len)+tag);\\n            pos += len;\\n        }\\n        return vec;\\n    }\\npublic:\\n    vector<string> splitMessage(string message, int limit) {\\n        int num = getOneDigit(message.size(), limit);\\n        if(num == -1){\\n            num = getTwoDigit(message.size(), limit);\\n        }\\n        if(num == -1){\\n            num = getThreeDigit(message.size(), limit);\\n        }\\n        if(num == -1){\\n            num = getFourDigit(message.size(), limit);\\n        }\\n        if(num == -1){\\n            num = getFiveDigit(message.size(), limit);\\n        }\\n        if(num == -1){\\n            return {};\\n        }\\n        return getTokens(message, limit, num);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n    int getOneDigit(int size, int limit){\\n        int partLen1 = limit-5;\\n        if(partLen1 <= 0) return -1;\\n\\n        int num = (int)ceil((double)size / (double)partLen1);\\n        return (num < 10) ? num : -1;\\n    }\\n    int getTwoDigit(int size, int limit){\\n        int partLen1 = limit-6;\\n        int partLen2 = limit-7;\\n        if(partLen1 <= 0 or partLen2 <= 0) return -1;\\n        int num = 9;\\n        size -= partLen1*9;\\n        if(size < 0) return -1;\\n        num += (int)ceil((double)size / (double)partLen2);\\n        return (num < 100) ? num : -1;\\n    }\\n    int getThreeDigit(int size, int limit){\\n        int partLen1 = limit-7;\\n        int partLen2 = limit-8;\\n        int partLen3 = limit-9;\\n        if(partLen1 <= 0 or partLen2 <= 0 or partLen3 <= 0) return -1;\\n        int num = 99;\\n        size -= partLen1*9;\\n        size -= partLen2*90;\\n        if(size < 0) return -1;\\n        num += (int)ceil((double)size / (double)partLen3);\\n        return (num < 1000) ? num : -1;\\n    }\\n    int getFourDigit(int size, int limit){\\n        int partLen1 = limit-8;\\n        int partLen2 = limit-9;\\n        int partLen3 = limit-10;\\n        int partLen4 = limit-11;\\n        \\n        if(partLen1 <= 0 or partLen2 <= 0 or partLen3 <= 0 or partLen4 <= 0) return -1;\\n        int num = 999;\\n        size -= partLen1*9;\\n        size -= partLen2*90;\\n        size -= partLen3*900;\\n        if(size < 0) return -1;\\n        num += (int)ceil((double)size / (double)partLen4);\\n        return (num < 10000) ? num : -1;\\n    }\\n    int getFiveDigit(int size, int limit){\\n        int partLen1 = limit-9;\\n        int partLen2 = limit-10;\\n        int partLen3 = limit-11;\\n        int partLen4 = limit-12;\\n        int partLen5 = limit-13;\\n        \\n        if(partLen1 <= 0 or partLen2 <= 0 or partLen3 <= 0 or partLen4 <= 0 or partLen5 <= 0) return -1;\\n        int num = 9999;\\n        size -= partLen1*9;\\n        size -= partLen2*90;\\n        size -= partLen3*900;\\n        size -= partLen3*9000;\\n        \\n        if(size < 0) return -1;\\n        num += (int)ceil((double)size / (double)partLen5);\\n        return (num < 100000) ? num : -1;\\n    }\\n    vector<string> getTokens(string message, int limit, int partSize){\\n        vector<string> vec;\\n        string temp = \"/\" + to_string(partSize) + \">\";\\n        int pos = 0;\\n        for(int i = 0 ; i < partSize ; i++){\\n            \\n            string tag = \"<\" + to_string(i+1) + temp;\\n            int len = 0;\\n            if(i == partSize-1){\\n                len = message.size() - pos+1;\\n            }\\n            else{\\n                len = limit - tag.size();\\n            }\\n            vec.push_back(message.substr(pos, len)+tag);\\n            pos += len;\\n        }\\n        return vec;\\n    }\\npublic:\\n    vector<string> splitMessage(string message, int limit) {\\n        int num = getOneDigit(message.size(), limit);\\n        if(num == -1){\\n            num = getTwoDigit(message.size(), limit);\\n        }\\n        if(num == -1){\\n            num = getThreeDigit(message.size(), limit);\\n        }\\n        if(num == -1){\\n            num = getFourDigit(message.size(), limit);\\n        }\\n        if(num == -1){\\n            num = getFiveDigit(message.size(), limit);\\n        }\\n        if(num == -1){\\n            return {};\\n        }\\n        return getTokens(message, limit, num);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2869069,
                "title": "simple-approach-o-n-run-time",
                "content": "```\\nclass Solution:\\n    def splitMessage(self, me: str, li: int) -> List[str]:\\n        up = [10 , 100 , 1000 , 10000]\\n        m_le = len(me)     # message lengh remain \\n        s_l = 5      # suffix lengh \\n        cur = 1      # count the parts\\n        \\n        #check if it\\'s possible to split and count how many part (if posible to split)\\n        while m_le > 0 :\\n            if cur in up:\\n                m_le += (cur - 1)\\n                s_l += 2\\n            if s_l >= li:\\n                return []\\n            m_le -= (li - s_l)\\n            cur += 1\\n        \\n        #fil in \\'res\\' using for loop \\n        res = []\\n        s_l = 4 + len(str(cur - 1))\\n        for i in range(1 , cur):\\n            if i in up:\\n                s_l += 1\\n            idx = li - s_l\\n            res.append(me[:idx] + \\'<{}/{}>\\'.format(i , cur-1))\\n            me = me[idx:]\\n            \\n        return res\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def splitMessage(self, me: str, li: int) -> List[str]:\\n        up = [10 , 100 , 1000 , 10000]\\n        m_le = len(me)     # message lengh remain \\n        s_l = 5      # suffix lengh \\n        cur = 1      # count the parts\\n        \\n        #check if it\\'s possible to split and count how many part (if posible to split)\\n        while m_le > 0 :\\n            if cur in up:\\n                m_le += (cur - 1)\\n                s_l += 2\\n            if s_l >= li:\\n                return []\\n            m_le -= (li - s_l)\\n            cur += 1\\n        \\n        #fil in \\'res\\' using for loop \\n        res = []\\n        s_l = 4 + len(str(cur - 1))\\n        for i in range(1 , cur):\\n            if i in up:\\n                s_l += 1\\n            idx = li - s_l\\n            res.append(me[:idx] + \\'<{}/{}>\\'.format(i , cur-1))\\n            me = me[idx:]\\n            \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2863984,
                "title": "c-brute-force-testing-for-the-result",
                "content": "```\\n// 1 - 9: xxxx<1/yyy> lenx + 4 + leny <= limit (limit - 4 - leny) * 9\\n// 10 - 99: xxxx<10/yyy> lenx + 5 + leny <= limit (limit - 5 - leny) * 90\\n// 100 - 999: xxxx<100/yyy> lenx + 6 + leny <= limit (limit - 6 - leny) * 900\\n\\n// (limit - 4 - leny) * 9 + (limit - 5 - leny) * 90 + (limit - 6 - leny) * 900. + ... >= message.length()\\n\\nclass Solution {\\npublic:\\n    vector<string> splitMessage(string message, int limit) {\\n        int i = 1;\\n        bool flag = false;\\n        // at most 1E4 parts, so leny should <= 4\\n        for (; i <= 4; ++i) {\\n            int cnt = 0;\\n            int j = 4;\\n            int base = 9;\\n            // this iteration at most go 4 times for 9, 90, 900, 9000 should add up to 1E4\\n            // iteration condition:\\n            // 1. at least lenx == 1\\n            // 2. j - 4, which is the length of a, should be less than leny\\n            while (limit - j - i > 0 && i > j - 4) {\\n                cnt += (limit - j - i) * base;\\n                ++j;\\n                base *= 10;\\n            }\\n            if (cnt >= message.length()) {\\n                flag = true;\\n                break;\\n            }\\n        }\\n        if (!flag) {\\n            return vector<string>();\\n        }\\n        int leny = i;\\n        int lo = 1 * pow(10, (leny - 1));\\n        int hi = stoi(string(leny, \\'9\\'));\\n        for (i = lo; i <= hi; ++i) {\\n            int cnt = 0;\\n            int j = 4;\\n            int base = 9;\\n            int superbase = 1;\\n            while (limit - j - leny > 0 && leny > j - 4) {\\n                cnt += (limit - j - leny) * min(base, i - superbase + 1);\\n                ++j;\\n                base *= 10;\\n                superbase *= 10;\\n            }\\n            if (cnt >= message.length()) {\\n                break;\\n            }\\n        }\\n        int b = i;\\n        int pos = 0;\\n        vector<string> result;\\n        string strb = to_string(b);\\n        for (i = 1; i <= b; ++i) {\\n            int len = limit - to_string(i).length() - 3 - leny;\\n            len = min(len, (int)(message.length() - pos));\\n            result.push_back(message.substr(pos, len) + \"<\" + to_string(i) + \"/\" + strb + \">\");\\n            pos += len;\\n        }\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n// 1 - 9: xxxx<1/yyy> lenx + 4 + leny <= limit (limit - 4 - leny) * 9\\n// 10 - 99: xxxx<10/yyy> lenx + 5 + leny <= limit (limit - 5 - leny) * 90\\n// 100 - 999: xxxx<100/yyy> lenx + 6 + leny <= limit (limit - 6 - leny) * 900\\n\\n// (limit - 4 - leny) * 9 + (limit - 5 - leny) * 90 + (limit - 6 - leny) * 900. + ... >= message.length()\\n\\nclass Solution {\\npublic:\\n    vector<string> splitMessage(string message, int limit) {\\n        int i = 1;\\n        bool flag = false;\\n        // at most 1E4 parts, so leny should <= 4\\n        for (; i <= 4; ++i) {\\n            int cnt = 0;\\n            int j = 4;\\n            int base = 9;\\n            // this iteration at most go 4 times for 9, 90, 900, 9000 should add up to 1E4\\n            // iteration condition:\\n            // 1. at least lenx == 1\\n            // 2. j - 4, which is the length of a, should be less than leny\\n            while (limit - j - i > 0 && i > j - 4) {\\n                cnt += (limit - j - i) * base;\\n                ++j;\\n                base *= 10;\\n            }\\n            if (cnt >= message.length()) {\\n                flag = true;\\n                break;\\n            }\\n        }\\n        if (!flag) {\\n            return vector<string>();\\n        }\\n        int leny = i;\\n        int lo = 1 * pow(10, (leny - 1));\\n        int hi = stoi(string(leny, \\'9\\'));\\n        for (i = lo; i <= hi; ++i) {\\n            int cnt = 0;\\n            int j = 4;\\n            int base = 9;\\n            int superbase = 1;\\n            while (limit - j - leny > 0 && leny > j - 4) {\\n                cnt += (limit - j - leny) * min(base, i - superbase + 1);\\n                ++j;\\n                base *= 10;\\n                superbase *= 10;\\n            }\\n            if (cnt >= message.length()) {\\n                break;\\n            }\\n        }\\n        int b = i;\\n        int pos = 0;\\n        vector<string> result;\\n        string strb = to_string(b);\\n        for (i = 1; i <= b; ++i) {\\n            int len = limit - to_string(i).length() - 3 - leny;\\n            len = min(len, (int)(message.length() - pos));\\n            result.push_back(message.substr(pos, len) + \"<\" + to_string(i) + \"/\" + strb + \">\");\\n            pos += len;\\n        }\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2851566,
                "title": "c-iteration",
                "content": "We iterate and app more parts until new string Length > limit * parts\\nnew string length is : partsNum*(3 + len(partsNum) + allPartsLen + string)\\n\\t\\t\\t\\t\\t\\t   i.e:         3        </>             1 +       1+2+3 = len3  =message len\\n\\nif limit <= 3 +parts * 2   (mean <3/3>  >= limit, no plase for message)   return empty\\n\\n```\\npublic class Solution {\\n    public string[] SplitMessage(string message, int limit) {\\n        int mesLen = message.Length;\\n        int parts = 1;\\n        int allPartsLen = Len(parts);\\n        \\n        while(parts*(3 + Len(parts)) + allPartsLen + mesLen> limit*parts){\\n            if(3 + Len(parts)*2 >= limit) // <10/10> >= limit, no plase for message;\\n                return new string[0];\\n            parts++;\\n            allPartsLen += Len(parts);\\n        } \\n        \\n        List<string> ans = new();\\n        for(int i=1; i<=parts; i++){\\n            \\n            int j = Math.Min(message.Length, limit - (3 + Len(i) + Len(parts))); \\n            string chunk = message.Substring(0,j);\\n            message = message.Substring(j); \\n            ans.Add($\"{chunk}<{i}/{parts}>\");\\n        }\\n        \\n        return ans.ToArray();\\n    }\\n    \\n    public int Len(int num)=> num.ToString().Length;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public string[] SplitMessage(string message, int limit) {\\n        int mesLen = message.Length;\\n        int parts = 1;\\n        int allPartsLen = Len(parts);\\n        \\n        while(parts*(3 + Len(parts)) + allPartsLen + mesLen> limit*parts){\\n            if(3 + Len(parts)*2 >= limit) // <10/10> >= limit, no plase for message;\\n                return new string[0];\\n            parts++;\\n            allPartsLen += Len(parts);\\n        } \\n        \\n        List<string> ans = new();\\n        for(int i=1; i<=parts; i++){\\n            \\n            int j = Math.Min(message.Length, limit - (3 + Len(i) + Len(parts))); \\n            string chunk = message.Substring(0,j);\\n            message = message.Substring(j); \\n            ans.Add($\"{chunk}<{i}/{parts}>\");\\n        }\\n        \\n        return ans.ToArray();\\n    }\\n    \\n    public int Len(int num)=> num.ToString().Length;\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2851525,
                "title": "rust-faster-than-100",
                "content": "My competition submission.  I noticed a couple weeks later once the runtime distributions were in that this was off the left end of the runtime charts at 49ms! This really does not attempt any sort of optimization, it just restarts once it realizes the current attempt is invalid.  \\n\\nI believe (correct me if I\\'m wrong) that doing it this way is still linear time.  You will only reiterate over log10(n) messages, so O(n + log10(n)) == O(n)\\n\\n```\\nimpl Solution {\\n    pub fn split_message(message: String, limit: i32) -> Vec<String> {\\n        let len = message.len();\\n            if limit <= 5 {\\n                return Vec::new()\\n            }\\n       \\n        let mut msglen = (limit - 5) as usize;\\n        let mut splits = Vec::<String>::new();\\n        let mut pow10 = 10;\\n        let mut pow = 1;\\n        let mut pow10local = 10;\\n        let mut powlocal = 1;\\n        let mut nmsg = 0;\\n        let mut stridx = 0;\\n        loop {\\n            nmsg += 1;\\n            // Naive impl: just restart once we hit the next pow10 for nmsg\\n            if nmsg == pow10 {\\n                // Bump these\\n                pow10 *= 10;\\n                pow += 1;\\n                // Reset these\\n                pow10local = 10;\\n                powlocal = 1;\\n                nmsg = 0;\\n                stridx = 0;\\n                if limit <= (3 + pow + powlocal) {\\n                    return Vec::new()\\n                }\\n                msglen = limit as usize - (3 + pow + powlocal) as usize;\\n //               println!(\"{:?}\", splits);\\n                splits.clear();\\n                continue;\\n            }\\n\\n            if nmsg == pow10local {\\n                pow10local *= 10;\\n                powlocal += 1;\\n                if limit <= (3 + pow + powlocal) {\\n                    return Vec::new()\\n                }\\n                msglen = limit as usize - (3 + pow + powlocal) as usize;\\n            }\\n\\n \\n            if msglen <= 0 {\\n                return Vec::new();\\n            }\\n\\n            let mut finish = false;\\n            if (msglen + stridx) as usize >= len {\\n                finish = true;\\n                if limit <= (3 + pow + powlocal) {\\n                    return Vec::new()\\n                }\\n                msglen = len - stridx as usize; \\n            }\\n            splits.push(String::from(&message[stridx..(stridx + msglen)]));\\n            stridx += msglen;\\n            if finish {\\n                break\\n            }\\n        }\\n//        println!(\"{}\", nmsg);\\n        let output: Vec<String> = splits.iter().enumerate().map(|x| {\\n            return String::from(format!(\"{}<{}/{}>\", x.1, x.0 + 1, nmsg))\\n        }).collect();\\n        return output\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn split_message(message: String, limit: i32) -> Vec<String> {\\n        let len = message.len();\\n            if limit <= 5 {\\n                return Vec::new()\\n            }\\n       \\n        let mut msglen = (limit - 5) as usize;\\n        let mut splits = Vec::<String>::new();\\n        let mut pow10 = 10;\\n        let mut pow = 1;\\n        let mut pow10local = 10;\\n        let mut powlocal = 1;\\n        let mut nmsg = 0;\\n        let mut stridx = 0;\\n        loop {\\n            nmsg += 1;\\n            // Naive impl: just restart once we hit the next pow10 for nmsg\\n            if nmsg == pow10 {\\n                // Bump these\\n                pow10 *= 10;\\n                pow += 1;\\n                // Reset these\\n                pow10local = 10;\\n                powlocal = 1;\\n                nmsg = 0;\\n                stridx = 0;\\n                if limit <= (3 + pow + powlocal) {\\n                    return Vec::new()\\n                }\\n                msglen = limit as usize - (3 + pow + powlocal) as usize;\\n //               println!(\"{:?}\", splits);\\n                splits.clear();\\n                continue;\\n            }\\n\\n            if nmsg == pow10local {\\n                pow10local *= 10;\\n                powlocal += 1;\\n                if limit <= (3 + pow + powlocal) {\\n                    return Vec::new()\\n                }\\n                msglen = limit as usize - (3 + pow + powlocal) as usize;\\n            }\\n\\n \\n            if msglen <= 0 {\\n                return Vec::new();\\n            }\\n\\n            let mut finish = false;\\n            if (msglen + stridx) as usize >= len {\\n                finish = true;\\n                if limit <= (3 + pow + powlocal) {\\n                    return Vec::new()\\n                }\\n                msglen = len - stridx as usize; \\n            }\\n            splits.push(String::from(&message[stridx..(stridx + msglen)]));\\n            stridx += msglen;\\n            if finish {\\n                break\\n            }\\n        }\\n//        println!(\"{}\", nmsg);\\n        let output: Vec<String> = splits.iter().enumerate().map(|x| {\\n            return String::from(format!(\"{}<{}/{}>\", x.1, x.0 + 1, nmsg))\\n        }).collect();\\n        return output\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2844878,
                "title": "simple-binary-search-approach",
                "content": "```\\nclass Solution {\\n    vector<string> t;\\npublic:\\n    int check(string s,int lim,int k){\\n        string kk=to_string(k);\\n        int i=0,part=1,n=s.length(),l=3+(kk.length()<<1);\\n        vector<string> ans;\\n        if(l>=lim)\\n            return 0;\\n        while(i<n){\\n            if(part>k)\\n                return 0;\\n            string curr,p=to_string(part);\\n            int rem=lim-(3+kk.length()+p.length());\\n            if(rem==0)\\n                return 0;\\n            while(i<n and rem>0){\\n                curr+=s[i];\\n                i++;\\n                rem--;\\n            }\\n            part++;\\n            string suff=\"<\"+p+\"/\"+kk+\">\";\\n            ans.push_back(curr+suff);\\n        }\\n        if(ans.size()){\\n            t.clear();\\n            for(auto e:ans)\\n                t.push_back(e);\\n        }\\n        return ans.size();\\n    }\\n    vector<string> splitMessage(string s, int lim) {\\n        vector<int> low={1,10,100,1000,10000};\\n        vector<int> high={9,99,999,9999,99999};\\n        for(int i=0;i<low.size();i++){\\n            int pr=high[i],l=low[i],r=high[i];\\n            if(l<=s.length()){\\n                while(l<=r){\\n                    int m=l+((r-l)>>1);\\n                    if(check(s,lim,m))\\n                        r=m-1;\\n                    else\\n                        l=m+1;\\n                }\\n                if(t.size())\\n                    return t;\\n            }\\n        }\\n        return t;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    vector<string> t;\\npublic:\\n    int check(string s,int lim,int k){\\n        string kk=to_string(k);\\n        int i=0,part=1,n=s.length(),l=3+(kk.length()<<1);\\n        vector<string> ans;\\n        if(l>=lim)\\n            return 0;\\n        while(i<n){\\n            if(part>k)\\n                return 0;\\n            string curr,p=to_string(part);\\n            int rem=lim-(3+kk.length()+p.length());\\n            if(rem==0)\\n                return 0;\\n            while(i<n and rem>0){\\n                curr+=s[i];\\n                i++;\\n                rem--;\\n            }\\n            part++;\\n            string suff=\"<\"+p+\"/\"+kk+\">\";\\n            ans.push_back(curr+suff);\\n        }\\n        if(ans.size()){\\n            t.clear();\\n            for(auto e:ans)\\n                t.push_back(e);\\n        }\\n        return ans.size();\\n    }\\n    vector<string> splitMessage(string s, int lim) {\\n        vector<int> low={1,10,100,1000,10000};\\n        vector<int> high={9,99,999,9999,99999};\\n        for(int i=0;i<low.size();i++){\\n            int pr=high[i],l=low[i],r=high[i];\\n            if(l<=s.length()){\\n                while(l<=r){\\n                    int m=l+((r-l)>>1);\\n                    if(check(s,lim,m))\\n                        r=m-1;\\n                    else\\n                        l=m+1;\\n                }\\n                if(t.size())\\n                    return t;\\n            }\\n        }\\n        return t;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2842576,
                "title": "c-best-solution-with-explanation-o-n-time-complexity-brute-force-easy-precomputation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n- seems hard but not so\\n- analysis was more in this question\\n- need to somehow know, how many parts in which string should be divided .\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- divide string into some number of parts\\n- after division, there should be consistency in length and that is below\\n- let\\'s divide it in to d part , then consisitency would be like this - \\n- (d-1).limit < d.3 + d.len[d] + d.(sum of all len[i] for all i start from 1 to d) + len(message) <= d.limit - where . represent product\\n- for calculating d, just iterarte from d=1 till n and when we find this condition , just break\\n- also do precomputation for getting sum of all len[i] to reduce time\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n# Code\\n```\\n#include<iostream>\\n#include<string>\\n\\nclass Solution {\\npublic:\\n    vector<string> splitMessage(string message, int limit) {\\n        int n = message.length();\\n        vector<int> len(n+1);\\n        for(int i=1;i<=n;i++){\\n            int j = i;\\n            int d = 0;\\n            while(j != 0){\\n                d++;\\n                j /= 10;\\n            }\\n            len[i] = d;\\n        }\\n        \\n        vector<int> pre(n+1);\\n        int sum = 0;\\n        for(int i=1;i<=n;i++){\\n            sum += len[i];\\n            pre[i] = sum;\\n        }\\n        \\n        int part = -1;\\n        \\n        for(int i=1;i<=n;i++){\\n            int low = (i-1)*limit;\\n            int high = i * limit;\\n            int temp = i*3 + i*len[i] + pre[i] + n;\\n            if(temp>low && temp<=high){\\n                part = i;\\n                break;\\n            }\\n        }\\n        vector<string> ans;\\n        if(part == -1){\\n            return ans;\\n        }\\n        \\n        int j = 0;\\n        for(int i=1;i<=part;i++){\\n            int temp = 3 + len[i] + len[part];\\n            int size = limit - temp;\\n            string s = message.substr(j, size);\\n            j += size;\\n            s.push_back(\\'<\\');\\n            s += (to_string(i));\\n            s += \"/\";\\n            s += (to_string(part));\\n            s += \">\";\\n            ans.push_back(s);\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Prefix Sum"
                ],
                "code": "```\\n#include<iostream>\\n#include<string>\\n\\nclass Solution {\\npublic:\\n    vector<string> splitMessage(string message, int limit) {\\n        int n = message.length();\\n        vector<int> len(n+1);\\n        for(int i=1;i<=n;i++){\\n            int j = i;\\n            int d = 0;\\n            while(j != 0){\\n                d++;\\n                j /= 10;\\n            }\\n            len[i] = d;\\n        }\\n        \\n        vector<int> pre(n+1);\\n        int sum = 0;\\n        for(int i=1;i<=n;i++){\\n            sum += len[i];\\n            pre[i] = sum;\\n        }\\n        \\n        int part = -1;\\n        \\n        for(int i=1;i<=n;i++){\\n            int low = (i-1)*limit;\\n            int high = i * limit;\\n            int temp = i*3 + i*len[i] + pre[i] + n;\\n            if(temp>low && temp<=high){\\n                part = i;\\n                break;\\n            }\\n        }\\n        vector<string> ans;\\n        if(part == -1){\\n            return ans;\\n        }\\n        \\n        int j = 0;\\n        for(int i=1;i<=part;i++){\\n            int temp = 3 + len[i] + len[part];\\n            int size = limit - temp;\\n            string s = message.substr(j, size);\\n            j += size;\\n            s.push_back(\\'<\\');\\n            s += (to_string(i));\\n            s += \"/\";\\n            s += (to_string(part));\\n            s += \">\";\\n            ans.push_back(s);\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2839485,
                "title": "c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    const int INF = 1e9 + 7;\\n    vector<string> splitMessage(string message, int limit) {\\n        int n = message.size();\\n        vector<int> size(n + 1);\\n        for (int i = 1; i <= n; i++) {\\n            size[i] = (int) to_string(i).size();\\n        }\\n        auto check = [&] (int length) -> int {\\n            int len = (int) to_string(length).size();\\n            int sz = n;\\n            for (int i = 1; i < length; i++) {\\n                int l = size[i] + len + 3;\\n                if (limit <= l) {\\n                    return 1;\\n                }\\n                int rest = limit - l;\\n                sz -= rest;\\n                if (sz <= 0) {\\n                    return 1;\\n                }\\n            }\\n            int rest = limit - size[length] - len - 3;\\n            if (sz > 0 && sz <= rest) {\\n                return 0;\\n            }\\n            return -1;\\n        };\\n        int sol = INF;\\n        for (int i = 1; i <= 10000; i *= 10) {\\n            int low = i;\\n            int high = i * 10 - 1;\\n            while (low <= high) {\\n                int mid = (low + high) / 2;\\n                int val = check(mid);\\n                if (val == 0) {\\n                    sol = min(sol, mid);\\n                    high = mid - 1;\\n                } else if (val < 0) {\\n                    low = mid + 1;\\n                } else {\\n                    high = mid - 1;\\n                }\\n            }\\n        }\\n        if (sol == INF) {\\n            return {};\\n        }\\n        int len = (int) to_string(sol).size();\\n        vector<string> res;\\n        int pos = 0;\\n        string re = to_string(sol);\\n        for (int i = 1; i <= sol; i++) {\\n            int l = size[i] + len + 3;\\n            int rest = limit - l;\\n            int left = n - pos;\\n            string s = message.substr(pos, min(rest, left)) + \"<\" + to_string(i) + \"/\" + re + \">\";\\n            pos += min(rest, left);\\n            res.push_back(s);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    const int INF = 1e9 + 7;\\n    vector<string> splitMessage(string message, int limit) {\\n        int n = message.size();\\n        vector<int> size(n + 1);\\n        for (int i = 1; i <= n; i++) {\\n            size[i] = (int) to_string(i).size();\\n        }\\n        auto check = [&] (int length) -> int {\\n            int len = (int) to_string(length).size();\\n            int sz = n;\\n            for (int i = 1; i < length; i++) {\\n                int l = size[i] + len + 3;\\n                if (limit <= l) {\\n                    return 1;\\n                }\\n                int rest = limit - l;\\n                sz -= rest;\\n                if (sz <= 0) {\\n                    return 1;\\n                }\\n            }\\n            int rest = limit - size[length] - len - 3;\\n            if (sz > 0 && sz <= rest) {\\n                return 0;\\n            }\\n            return -1;\\n        };\\n        int sol = INF;\\n        for (int i = 1; i <= 10000; i *= 10) {\\n            int low = i;\\n            int high = i * 10 - 1;\\n            while (low <= high) {\\n                int mid = (low + high) / 2;\\n                int val = check(mid);\\n                if (val == 0) {\\n                    sol = min(sol, mid);\\n                    high = mid - 1;\\n                } else if (val < 0) {\\n                    low = mid + 1;\\n                } else {\\n                    high = mid - 1;\\n                }\\n            }\\n        }\\n        if (sol == INF) {\\n            return {};\\n        }\\n        int len = (int) to_string(sol).size();\\n        vector<string> res;\\n        int pos = 0;\\n        string re = to_string(sol);\\n        for (int i = 1; i <= sol; i++) {\\n            int l = size[i] + len + 3;\\n            int rest = limit - l;\\n            int left = n - pos;\\n            string s = message.substr(pos, min(rest, left)) + \"<\" + to_string(i) + \"/\" + re + \">\";\\n            pos += min(rest, left);\\n            res.push_back(s);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2831115,
                "title": "c-fast-easy-solution-explained",
                "content": "NO BINARY SEARCH NEEDED!!!\\n+ check what can be count of digits in expected number of partition GUESS_LEN     \\n\\t+  for this go linearly from 1 to 6 since max message length 1e5\\n\\t+ count the number of partition length = limit - GUESS_LEN - 3 - BASE_LEN, base length will change in gaps of 9,90,900,... iterations \\n+ when found the partition count by check function make partions by iteration over message usinf fxn\\n\\n\\n```\\nclass Solution {\\npublic:\\n    int check(string m,int l,int len){\\n        int cur=len;\\n        len+=3;\\n        if(l<=len)return -1;\\n        l-=len;\\n        int base=1;\\n        int ct=0;\\n        int n=m.size();\\n        // vector<int>v={0,9,90,900,9000,90000,900000};\\n        while(n>0){\\n            int tmp=l-base;\\n            if(tmp==0)return -1;\\n            int tt=min( 9*(int)pow(10,base-1),(n+tmp-1)/tmp);\\n            n-=(tt*tmp);\\n            ct+=tt;\\n            base++;\\n        }\\n        int p=ct;\\n        int pp=0;\\n        while(p>0){\\n            p/=10;\\n            pp++;\\n        }\\n        if(pp==cur)return ct;\\n        return -1;\\n        \\n    }\\n    \\n    vector<string> fxn(string m,int l,int len,int val){\\n        vector<string>v;\\n        int base=1;\\n        int n=m.size();\\n        int k=0;\\n        int i=1;\\n        while(i<=val){\\n            int tmp=l-(base+len+3);\\n            int lim=9*pow(10,base-1);\\n            while(k<n && lim--){\\n                string tm=\"\";\\n                int p=tmp;\\n                while(k<n && p--){\\n                    tm+=m[k];\\n                    k++;\\n                }\\n                tm+=\"<\";\\n                tm+=to_string(i);\\n                tm+=\"/\";\\n                tm+=to_string(val);\\n                tm+=\">\";\\n                v.push_back(tm);\\n                i++;\\n            }\\n            base++;\\n        }\\n        return v;\\n    }\\n    \\n    vector<string> splitMessage(string message, int limit) {\\n        int count;\\n        for(int i=0;i<7;i++){\\n            count=check(message,limit,i);  // i=GUESS_LEN\\n            if(count!=-1)return fxn(message,limit,i,count);\\n        } \\n        return {};\\n        \\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int check(string m,int l,int len){\\n        int cur=len;\\n        len+=3;\\n        if(l<=len)return -1;\\n        l-=len;\\n        int base=1;\\n        int ct=0;\\n        int n=m.size();\\n        // vector<int>v={0,9,90,900,9000,90000,900000};\\n        while(n>0){\\n            int tmp=l-base;\\n            if(tmp==0)return -1;\\n            int tt=min( 9*(int)pow(10,base-1),(n+tmp-1)/tmp);\\n            n-=(tt*tmp);\\n            ct+=tt;\\n            base++;\\n        }\\n        int p=ct;\\n        int pp=0;\\n        while(p>0){\\n            p/=10;\\n            pp++;\\n        }\\n        if(pp==cur)return ct;\\n        return -1;\\n        \\n    }\\n    \\n    vector<string> fxn(string m,int l,int len,int val){\\n        vector<string>v;\\n        int base=1;\\n        int n=m.size();\\n        int k=0;\\n        int i=1;\\n        while(i<=val){\\n            int tmp=l-(base+len+3);\\n            int lim=9*pow(10,base-1);\\n            while(k<n && lim--){\\n                string tm=\"\";\\n                int p=tmp;\\n                while(k<n && p--){\\n                    tm+=m[k];\\n                    k++;\\n                }\\n                tm+=\"<\";\\n                tm+=to_string(i);\\n                tm+=\"/\";\\n                tm+=to_string(val);\\n                tm+=\">\";\\n                v.push_back(tm);\\n                i++;\\n            }\\n            base++;\\n        }\\n        return v;\\n    }\\n    \\n    vector<string> splitMessage(string message, int limit) {\\n        int count;\\n        for(int i=0;i<7;i++){\\n            count=check(message,limit,i);  // i=GUESS_LEN\\n            if(count!=-1)return fxn(message,limit,i,count);\\n        } \\n        return {};\\n        \\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2831094,
                "title": "python3-linear-search",
                "content": "Please pull this [commit](https://github.com/gaosanyong/leetcode/commit/e8b87d04cc192c5227286692921910fe93fee05d) for solutions of biweekly 91. \\n\\n```\\nclass Solution:\\n    def splitMessage(self, message: str, limit: int) -> List[str]:\\n        prefix = b = 0 \\n        while 3 + len(str(b))*2 < limit and len(message) + prefix + (3+len(str(b)))*b > limit * b: \\n            b += 1\\n            prefix += len(str(b))\\n        ans = []\\n        if 3 + len(str(b))*2 < limit: \\n            i = 0 \\n            for a in range(1, b+1): \\n                step = limit - (len(str(a)) + len(str(b)) + 3)\\n                ans.append(f\"{message[i:i+step]}<{a}/{b}>\")\\n                i += step \\n        return ans \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def splitMessage(self, message: str, limit: int) -> List[str]:\\n        prefix = b = 0 \\n        while 3 + len(str(b))*2 < limit and len(message) + prefix + (3+len(str(b)))*b > limit * b: \\n            b += 1\\n            prefix += len(str(b))\\n        ans = []\\n        if 3 + len(str(b))*2 < limit: \\n            i = 0 \\n            for a in range(1, b+1): \\n                step = limit - (len(str(a)) + len(str(b)) + 3)\\n                ans.append(f\"{message[i:i+step]}<{a}/{b}>\")\\n                i += step \\n        return ans \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2828817,
                "title": "no-bs-find-parts-in-log10-theoretical-max-10000",
                "content": "We check if we can split it into 9, 99, 999 (increasing digit count).\\nAfter we find out its possible, we simulate the process.\\n\\n---\\n\\n```cpp\\nconstexpr int ceil_div(int a, int b) { return a / b + int(a % b != 0); }\\n\\nclass Solution {\\npublic:\\n  vector<string> splitMessage(string message, int limit) {\\n    int n = message.size();\\n    vector<string> ans;\\n\\n    int d = -1, p = -1;\\n    for (int d2 = 0; d2 < 4; d2++) {\\n      int m = 0, r = n, f = 0;\\n      for (int i = 0; i <= d2; i++) {\\n        int t = pow(10, i), k = limit - 5 - d2 * 2;\\n        if (k <= 0) {\\n          break;\\n        }\\n        m += (limit - 5 - i - d2) * 9 * t;\\n        p = f + ceil_div(r, k);\\n        r -= (limit - 5 - i - d2) * 9 * t;\\n        f += 9 * t;\\n      }\\n      if (m >= n) {\\n        d = d2;\\n        break;\\n      }\\n    }\\n\\n    int e = 0, e2 = 9, o = 0;\\n    for (int i = 0; i <= d; i++) {\\n      for (int j = e; j < min(p, e2); j++) {\\n        ostringstream os;\\n        os << message.substr(o, limit - 5 - i - d);\\n        os << \\'<\\';\\n        os << (j + 1);\\n        os << \\'/\\';\\n        os << p;\\n        os << \\'>\\';\\n        ans.emplace_back(os.str());\\n        o += limit - 5 - i - d;\\n      }\\n      e = e2;\\n      e2 += 9 * pow(10, i + 1);\\n    }\\n\\n    return ans;\\n  }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Math",
                    "Simulation"
                ],
                "code": "```cpp\\nconstexpr int ceil_div(int a, int b) { return a / b + int(a % b != 0); }\\n\\nclass Solution {\\npublic:\\n  vector<string> splitMessage(string message, int limit) {\\n    int n = message.size();\\n    vector<string> ans;\\n\\n    int d = -1, p = -1;\\n    for (int d2 = 0; d2 < 4; d2++) {\\n      int m = 0, r = n, f = 0;\\n      for (int i = 0; i <= d2; i++) {\\n        int t = pow(10, i), k = limit - 5 - d2 * 2;\\n        if (k <= 0) {\\n          break;\\n        }\\n        m += (limit - 5 - i - d2) * 9 * t;\\n        p = f + ceil_div(r, k);\\n        r -= (limit - 5 - i - d2) * 9 * t;\\n        f += 9 * t;\\n      }\\n      if (m >= n) {\\n        d = d2;\\n        break;\\n      }\\n    }\\n\\n    int e = 0, e2 = 9, o = 0;\\n    for (int i = 0; i <= d; i++) {\\n      for (int j = e; j < min(p, e2); j++) {\\n        ostringstream os;\\n        os << message.substr(o, limit - 5 - i - d);\\n        os << \\'<\\';\\n        os << (j + 1);\\n        os << \\'/\\';\\n        os << p;\\n        os << \\'>\\';\\n        ans.emplace_back(os.str());\\n        o += limit - 5 - i - d;\\n      }\\n      e = e2;\\n      e2 += 9 * pow(10, i + 1);\\n    }\\n\\n    return ans;\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2828298,
                "title": "trial-and-error-approach-c",
                "content": "Assume number of characters in b of <a/b> and then check if it is valid. \\nStart from 1 and go till 4 since length of string is at max. 10000.\\n\\n```\\nclass Solution {\\npublic:\\n    vector<string> helper(string s, int limit, int x) {\\n        vector<string> ans;\\n        string sx = to_string(x);\\n        int xLen = sx.size();\\n        int currIndex=1, indexLen=1;\\n        string temp;\\n        for(auto &c : s) {\\n            if(temp.size() == limit-indexLen-xLen-3) {\\n                ans.push_back(temp + \\'<\\' + to_string(currIndex) + \\'/\\' + sx + \\'>\\');\\n                temp.clear();\\n                currIndex++;\\n                if(currIndex==10 || currIndex==100 || currIndex==1000) indexLen++;\\n            }\\n            temp.push_back(c);\\n        }\\n        ans.push_back(temp + \\'<\\' + to_string(currIndex) + \\'/\\' + sx + \\'>\\');\\n        return ans;\\n    }\\n    \\n    vector<string> splitMessage(string message, int limit) {\\n        int n = message.size();\\n    \\n        // <a/b>\\n        // if No. of characters in b = 1\\n        if(limit <= 5) return {};\\n        int x = 0;\\n        int temp = n;\\n        while(temp > 0) {\\n            x++;\\n            if(x < 10) temp -= (limit-5);\\n            else break;\\n        }\\n        if(x < 10) return helper(message, limit, x);\\n        \\n        // if No. of characters in b = 2\\n        if(limit <= 7) return {};\\n        x = 0;\\n        temp = n;\\n        while(temp > 0) {\\n            x++;\\n            if(x < 10) temp -= (limit-6);\\n            else if(x < 100) temp -= (limit-7);\\n            else break;\\n        }\\n        if(x<100) return helper(message, limit, x);\\n        \\n        // if No. of characters in b = 3\\n        if(limit <= 9) return {};\\n        x = 0;\\n        temp = n;\\n        while(temp > 0) {\\n            x++;\\n            if(x < 10) temp -= (limit-7);\\n            else if(x < 100) temp -= (limit-8);\\n            else if(x < 1000) temp -= (limit-9);\\n            else break;\\n        }\\n        if(x<1000) return helper(message, limit, x);\\n        \\n        // if No. of characters in b = 4\\n        if(limit <= 11) return {}; \\n        x = 0;\\n        temp = n;\\n        while(temp > 0) {\\n            x++;\\n            if(x < 10) temp -= (limit-8);\\n            else if(x < 100) temp -= (limit-9);\\n            else if(x < 1000) temp -= (limit-10);\\n            else if(x < 10000) temp -= (limit-11);\\n        }\\n        return helper(message, limit, x);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> helper(string s, int limit, int x) {\\n        vector<string> ans;\\n        string sx = to_string(x);\\n        int xLen = sx.size();\\n        int currIndex=1, indexLen=1;\\n        string temp;\\n        for(auto &c : s) {\\n            if(temp.size() == limit-indexLen-xLen-3) {\\n                ans.push_back(temp + \\'<\\' + to_string(currIndex) + \\'/\\' + sx + \\'>\\');\\n                temp.clear();\\n                currIndex++;\\n                if(currIndex==10 || currIndex==100 || currIndex==1000) indexLen++;\\n            }\\n            temp.push_back(c);\\n        }\\n        ans.push_back(temp + \\'<\\' + to_string(currIndex) + \\'/\\' + sx + \\'>\\');\\n        return ans;\\n    }\\n    \\n    vector<string> splitMessage(string message, int limit) {\\n        int n = message.size();\\n    \\n        // <a/b>\\n        // if No. of characters in b = 1\\n        if(limit <= 5) return {};\\n        int x = 0;\\n        int temp = n;\\n        while(temp > 0) {\\n            x++;\\n            if(x < 10) temp -= (limit-5);\\n            else break;\\n        }\\n        if(x < 10) return helper(message, limit, x);\\n        \\n        // if No. of characters in b = 2\\n        if(limit <= 7) return {};\\n        x = 0;\\n        temp = n;\\n        while(temp > 0) {\\n            x++;\\n            if(x < 10) temp -= (limit-6);\\n            else if(x < 100) temp -= (limit-7);\\n            else break;\\n        }\\n        if(x<100) return helper(message, limit, x);\\n        \\n        // if No. of characters in b = 3\\n        if(limit <= 9) return {};\\n        x = 0;\\n        temp = n;\\n        while(temp > 0) {\\n            x++;\\n            if(x < 10) temp -= (limit-7);\\n            else if(x < 100) temp -= (limit-8);\\n            else if(x < 1000) temp -= (limit-9);\\n            else break;\\n        }\\n        if(x<1000) return helper(message, limit, x);\\n        \\n        // if No. of characters in b = 4\\n        if(limit <= 11) return {}; \\n        x = 0;\\n        temp = n;\\n        while(temp > 0) {\\n            x++;\\n            if(x < 10) temp -= (limit-8);\\n            else if(x < 100) temp -= (limit-9);\\n            else if(x < 1000) temp -= (limit-10);\\n            else if(x < 10000) temp -= (limit-11);\\n        }\\n        return helper(message, limit, x);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2826728,
                "title": "determine-number-of-digits-in-split-length",
                "content": "```\\nclass Solution:\\n    def splitMessage(self, message: str, limit: int) -> List[str]:\\n        n = len(message)\\n        for l in range(1, 6):\\n            M = 10 ** l\\n            off = 3 + l\\n            i = 0\\n            j = 1\\n            while i < n and j < M:\\n                k = max(limit - off - len(str(j)), 0)\\n                i += k\\n                j += 1\\n            j -= 1\\n            if i >= n:\\n                res = []\\n                curr = 0\\n                for x in range(1, j + 1):\\n                    suff = f\"<{x}/{j}>\"\\n                    k = limit - len(suff)\\n                    res.append(message[curr:curr+k] + suff)\\n                    curr += k\\n                return res\\n        return []\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def splitMessage(self, message: str, limit: int) -> List[str]:\\n        n = len(message)\\n        for l in range(1, 6):\\n            M = 10 ** l\\n            off = 3 + l\\n            i = 0\\n            j = 1\\n            while i < n and j < M:\\n                k = max(limit - off - len(str(j)), 0)\\n                i += k\\n                j += 1\\n            j -= 1\\n            if i >= n:\\n                res = []\\n                curr = 0\\n                for x in range(1, j + 1):\\n                    suff = f\"<{x}/{j}>\"\\n                    k = limit - len(suff)\\n                    res.append(message[curr:curr+k] + suff)\\n                    curr += k\\n                return res\\n        return []\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2826599,
                "title": "intuition-explained-c",
                "content": "Every split will contain a \"<_/_>\" of minimum 5 characters in it considering the total no of splits would be a 1 digit no. (<=9). So the possible slice of string can be of length 1 to limit-5. \\nIf a particular split size (say x) is decided it can be used used for first 9 splits. After that next 90 splits will be of size x-1 and for next 900 it would x-2 and so on. This way we can find for a number i how many splits can be made.\\nWe have to find the total no of splits that are formed for each i from 1 to limit-5 and then see just for first split (x) fits into \"slice<--/-->\" of size limit.\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n * log10n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    // function to find out how many splits will be made starting from a slice of size \"start\"\\n    int parts(int start, int n){\\n        int multiplier = 9;\\n        int digcount=0;\\n        while(n){\\n            if(start*multiplier >= n){\\n                digcount += n/start;\\n                if(n%start) digcount++;\\n                return digcount;\\n            }\\n            else{\\n                digcount += multiplier;\\n                n = n-(start*multiplier);\\n            }\\n            multiplier *= 10;\\n            start--;\\n            if(start <= 0) return -1;\\n        }\\n        return digcount;\\n    }\\n\\n    // function to make the splits and insert in answer vector\\n    vector<string> getString(int startVal, int totalPart, int limit, string& message){\\n        int multiplier = 9;\\n        vector<string> ans;\\n        string s;\\n        int multcount = 0, valcount = 0, splitcount = 0;\\n        for(int i=0; i<message.size(); i++){\\n            s += message[i];\\n            valcount++;\\n            if(valcount == startVal){\\n                splitcount++; valcount=0; multcount++;\\n                s += \\'<\\'; s+=to_string(splitcount); s+=\\'/\\'; s+=to_string(totalPart); s+=\\'>\\';\\n                ans.push_back(s);\\n                s.clear();\\n            }\\n            if(multcount == multiplier){\\n                multcount = 0;\\n                multiplier *= 10;\\n                startVal--;\\n            }\\n        }\\n        if(s.size()){\\n            s += \\'<\\'; s+=to_string(splitcount+1); s+=\\'/\\'; s+=to_string(totalPart); s+=\\'>\\';\\n            ans.push_back(s);\\n        }\\n        return ans;\\n    }\\n\\n    int digits(int p){\\n        int count = 0;\\n        while(p){\\n            p = p/10;\\n            count++;\\n        }\\n        return count;\\n    }\\n    vector<string> splitMessage(string message, int limit) {\\n        int n = message.size();\\n        vector<string> ans;\\n        if(n < limit-5){\\n            ans.push_back(message+\"<1/1>\");\\n        }\\n\\n        int high = limit-5;\\n        // start from last so that we get min no of splits\\n        for(int i=high; i>0; i--){\\n            // how many parts will be made if we start slicing with i no of alphabets\\n            int p = parts(i, n);\\n            if(p == -1) continue;  // -1 means no proper splits can be made with that no\\n            int nodig = digits(p);  // no of digits \\n            if(nodig+4+i == limit) \\n            {\\n                ans = getString(i, p, limit, message);\\n                break;\\n            }   \\n        }\\n        return ans;\\n}\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    // function to find out how many splits will be made starting from a slice of size \"start\"\\n    int parts(int start, int n){\\n        int multiplier = 9;\\n        int digcount=0;\\n        while(n){\\n            if(start*multiplier >= n){\\n                digcount += n/start;\\n                if(n%start) digcount++;\\n                return digcount;\\n            }\\n            else{\\n                digcount += multiplier;\\n                n = n-(start*multiplier);\\n            }\\n            multiplier *= 10;\\n            start--;\\n            if(start <= 0) return -1;\\n        }\\n        return digcount;\\n    }\\n\\n    // function to make the splits and insert in answer vector\\n    vector<string> getString(int startVal, int totalPart, int limit, string& message){\\n        int multiplier = 9;\\n        vector<string> ans;\\n        string s;\\n        int multcount = 0, valcount = 0, splitcount = 0;\\n        for(int i=0; i<message.size(); i++){\\n            s += message[i];\\n            valcount++;\\n            if(valcount == startVal){\\n                splitcount++; valcount=0; multcount++;\\n                s += \\'<\\'; s+=to_string(splitcount); s+=\\'/\\'; s+=to_string(totalPart); s+=\\'>\\';\\n                ans.push_back(s);\\n                s.clear();\\n            }\\n            if(multcount == multiplier){\\n                multcount = 0;\\n                multiplier *= 10;\\n                startVal--;\\n            }\\n        }\\n        if(s.size()){\\n            s += \\'<\\'; s+=to_string(splitcount+1); s+=\\'/\\'; s+=to_string(totalPart); s+=\\'>\\';\\n            ans.push_back(s);\\n        }\\n        return ans;\\n    }\\n\\n    int digits(int p){\\n        int count = 0;\\n        while(p){\\n            p = p/10;\\n            count++;\\n        }\\n        return count;\\n    }\\n    vector<string> splitMessage(string message, int limit) {\\n        int n = message.size();\\n        vector<string> ans;\\n        if(n < limit-5){\\n            ans.push_back(message+\"<1/1>\");\\n        }\\n\\n        int high = limit-5;\\n        // start from last so that we get min no of splits\\n        for(int i=high; i>0; i--){\\n            // how many parts will be made if we start slicing with i no of alphabets\\n            int p = parts(i, n);\\n            if(p == -1) continue;  // -1 means no proper splits can be made with that no\\n            int nodig = digits(p);  // no of digits \\n            if(nodig+4+i == limit) \\n            {\\n                ans = getString(i, p, limit, message);\\n                break;\\n            }   \\n        }\\n        return ans;\\n}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2826411,
                "title": "simple-math-for-how-many-digits-the-total-counts-should-be-brute-force",
                "content": "```java\\n// Math\\n// time: O(n), space: O(n)\\nclass Solution {\\n    public String[] splitMessage(String message, int limit) {\\n        int n = message.length();\\n        int suffix_len = 5;\\n        // impossible to split because limit too short\\n        if (limit <= suffix_len) return new String[0];\\n        int digits = 4;\\n        if (n + 9*5 <= 9 * limit)\\n            digits = 1;\\n        else if (n + 9*6 + 90*7 <= 99 * limit)\\n            digits = 2;\\n        else if (n + 9*6 + 90*7 + 900*8 <= 999 * limit)\\n            digits = 3;\\n        suffix_len += digits - 1;\\n        \\n        int pos = 0;\\n        int count = 1;\\n        StringBuilder sb = new StringBuilder();\\n        List<String> parts = new ArrayList();\\n        while (pos < n) {\\n            int text_len = limit - suffix_len;\\n            if (text_len <= 0) return new String[0];\\n            int end = Math.min(pos+text_len, n);\\n            sb.append(message.substring(pos, end)).append(\"<\").append(count).append(\"/\");\\n            parts.add(sb.toString());\\n            sb.setLength(0);\\n            pos += text_len;\\n            count++;\\n            if (count == 10)\\n                suffix_len++;\\n            if (count == 100)\\n                suffix_len++;\\n            if (count == 1000)\\n                suffix_len++;\\n        }\\n        count--;\\n        \\n        String[] res = new String[parts.size()];\\n        for (int i = 0; i < res.length; i++) {\\n            sb.append(parts.get(i)).append(count).append(\">\");\\n            res[i] = sb.toString();\\n            sb.setLength(0);\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```java\\n// Math\\n// time: O(n), space: O(n)\\nclass Solution {\\n    public String[] splitMessage(String message, int limit) {\\n        int n = message.length();\\n        int suffix_len = 5;\\n        // impossible to split because limit too short\\n        if (limit <= suffix_len) return new String[0];\\n        int digits = 4;\\n        if (n + 9*5 <= 9 * limit)\\n            digits = 1;\\n        else if (n + 9*6 + 90*7 <= 99 * limit)\\n            digits = 2;\\n        else if (n + 9*6 + 90*7 + 900*8 <= 999 * limit)\\n            digits = 3;\\n        suffix_len += digits - 1;\\n        \\n        int pos = 0;\\n        int count = 1;\\n        StringBuilder sb = new StringBuilder();\\n        List<String> parts = new ArrayList();\\n        while (pos < n) {\\n            int text_len = limit - suffix_len;\\n            if (text_len <= 0) return new String[0];\\n            int end = Math.min(pos+text_len, n);\\n            sb.append(message.substring(pos, end)).append(\"<\").append(count).append(\"/\");\\n            parts.add(sb.toString());\\n            sb.setLength(0);\\n            pos += text_len;\\n            count++;\\n            if (count == 10)\\n                suffix_len++;\\n            if (count == 100)\\n                suffix_len++;\\n            if (count == 1000)\\n                suffix_len++;\\n        }\\n        count--;\\n        \\n        String[] res = new String[parts.size()];\\n        for (int i = 0; i < res.length; i++) {\\n            sb.append(parts.get(i)).append(count).append(\">\");\\n            res[i] = sb.toString();\\n            sb.setLength(0);\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2826377,
                "title": "c-ac-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    bool split(string messege, string tot, int limit, vector<string> &ans){\\n        int index=0;\\n        int count=1;\\n        string cur;\\n        while(index<messege.size()){\\n            if(to_string(count).size()>tot.size()){\\n                return false;\\n            }\\n            if((cur.size()+to_string(count).size()+tot.size()+3)==limit){\\n                cur+=(\"<\"+to_string(count)+\"/\"+tot+\">\");\\n                ans.push_back(cur);\\n                cur.clear();\\n                count++;\\n        }\\n            cur+=messege[index];\\n            index++;\\n        }\\n        \\n        if(to_string(count).size()>tot.size()){\\n            return false;\\n        }\\n        if((cur.size()+to_string(count).size()+tot.size()+3)<=limit){\\n                cur+=(\"<\"+to_string(count)+\"/\"+tot+\">\");\\n                ans.push_back(cur);\\n                cur.clear();\\n                count++;\\n        }\\n        else{\\n            return false;\\n        }\\n        string rep=to_string(ans.size());\\n        for(auto &i: ans){\\n            int k=0;\\n            for(auto &j: i){\\n                if(j==\\'-\\'){\\n                    j=rep[k];\\n                    k++;\\n                }\\n            }\\n        }     \\n    } \\n    vector<string> splitMessage(string message, int limit) {\\n        vector<string> ans;\\n        string tot=\"-\";\\n        for(int i=1;i<6;i++){\\n            if(split(message, tot, limit, ans)){\\n                return ans;\\n            }\\n            tot+=\"-\";\\n            ans.clear();\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool split(string messege, string tot, int limit, vector<string> &ans){\\n        int index=0;\\n        int count=1;\\n        string cur;\\n        while(index<messege.size()){\\n            if(to_string(count).size()>tot.size()){\\n                return false;\\n            }\\n            if((cur.size()+to_string(count).size()+tot.size()+3)==limit){\\n                cur+=(\"<\"+to_string(count)+\"/\"+tot+\">\");\\n                ans.push_back(cur);\\n                cur.clear();\\n                count++;\\n        }\\n            cur+=messege[index];\\n            index++;\\n        }\\n        \\n        if(to_string(count).size()>tot.size()){\\n            return false;\\n        }\\n        if((cur.size()+to_string(count).size()+tot.size()+3)<=limit){\\n                cur+=(\"<\"+to_string(count)+\"/\"+tot+\">\");\\n                ans.push_back(cur);\\n                cur.clear();\\n                count++;\\n        }\\n        else{\\n            return false;\\n        }\\n        string rep=to_string(ans.size());\\n        for(auto &i: ans){\\n            int k=0;\\n            for(auto &j: i){\\n                if(j==\\'-\\'){\\n                    j=rep[k];\\n                    k++;\\n                }\\n            }\\n        }     \\n    } \\n    vector<string> splitMessage(string message, int limit) {\\n        vector<string> ans;\\n        string tot=\"-\";\\n        for(int i=1;i<6;i++){\\n            if(split(message, tot, limit, ans)){\\n                return ans;\\n            }\\n            tot+=\"-\";\\n            ans.clear();\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2825029,
                "title": "java-enum-number-of-elements",
                "content": "```\\nclass Solution {\\n    \\n    public String[] splitMessage(String message, int limit) {\\n        int n = message.length();\\n        \\n        for (int i = 1; i <= n; i++) {\\n            if (get(i, limit) >= n) {\\n                String[] res = new String[i];\\n                \\n                for (int j = 1, k = 0; j <= i && k < n; j++) {\\n                    StringBuilder sb = new StringBuilder();\\n                    sb.append(\\'<\\').append(j).append(\\'/\\').append(i).append(\\'>\\');\\n                    String str = sb.toString();\\n                    int len = Math.min(n - k, limit - sb.length());\\n                    res[j - 1] = message.substring(k, k + len) + str;\\n                    k += len;\\n                }\\n                return res;\\n            }\\n        }\\n        \\n        return new String[0];\\n    }\\n    \\n    private int get(int k, int limit) {\\n        int len = String.valueOf(k).length();\\n\\t\\t\\n\\t\\t// res : total valid character length without <*/k>\\n\\t\\t\\n        int res = (limit - 3 - len) * k ; // < /{k}>\\n        int s = 0;\\n\\t\\t// 1 bit, 9 count, len = 9\\n\\t\\t// 2 bits, 90 count, len = 2 * 90 = 180\\n\\t\\t// 3 bits, 900 count, len = 3 * 900 = 2700\\n        for (int i = 1, t = 9; i < len; i++, t *= 10) {\\n            res -= i * t;\\n            s += t;\\n        }\\n        \\n        res -= len * (k - s);\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    \\n    public String[] splitMessage(String message, int limit) {\\n        int n = message.length();\\n        \\n        for (int i = 1; i <= n; i++) {\\n            if (get(i, limit) >= n) {\\n                String[] res = new String[i];\\n                \\n                for (int j = 1, k = 0; j <= i && k < n; j++) {\\n                    StringBuilder sb = new StringBuilder();\\n                    sb.append(\\'<\\').append(j).append(\\'/\\').append(i).append(\\'>\\');\\n                    String str = sb.toString();\\n                    int len = Math.min(n - k, limit - sb.length());\\n                    res[j - 1] = message.substring(k, k + len) + str;\\n                    k += len;\\n                }\\n                return res;\\n            }\\n        }\\n        \\n        return new String[0];\\n    }\\n    \\n    private int get(int k, int limit) {\\n        int len = String.valueOf(k).length();\\n\\t\\t\\n\\t\\t// res : total valid character length without <*/k>\\n\\t\\t\\n        int res = (limit - 3 - len) * k ; // < /{k}>\\n        int s = 0;\\n\\t\\t// 1 bit, 9 count, len = 9\\n\\t\\t// 2 bits, 90 count, len = 2 * 90 = 180\\n\\t\\t// 3 bits, 900 count, len = 3 * 900 = 2700\\n        for (int i = 1, t = 9; i < len; i++, t *= 10) {\\n            res -= i * t;\\n            s += t;\\n        }\\n        \\n        res -= len * (k - s);\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2823276,
                "title": "python-binary-search-on-range-1-9-10-99",
                "content": "# Code\\n```\\nclass Solution:\\n    def splitMessage(self, s: str, limit: int) -> List[str]:\\n        if limit <= 4: return []\\n        n = len(s)\\n        ans, step = float(\\'inf\\'), 1\\n        while True:\\n            if 2 * len(str(step)) + 3 > limit: break\\n            lo, hi, suffix = step, min(n, step * 10 - 1), len(str(step)) + 3\\n            while lo <= hi:\\n                mid = (lo + hi) // 2\\n                idx, i  = 1, 0\\n                while i < n:\\n                    i += limit - (suffix + len(str(idx)))\\n                    idx += 1\\n                    if idx - 1 > mid: break\\n                idx -= 1\\n                if idx <= mid:\\n                    ans = min(ans, mid)\\n                    hi = mid - 1\\n                else: lo = mid + 1\\n            if ans != float(\\'inf\\'): break\\n            step *= 10\\n        if ans == float(\\'inf\\'): return []\\n        ans_split = []\\n        idx, i, suffix = 1, 0, len(str(ans)) + 3\\n        while i < n:\\n            ans_split.append(s[i:i + limit - (suffix + len(str(idx)))] + \\'<\\' + str(idx) + \\'/\\' + str(ans) + \\'>\\')\\n            i += limit - (suffix + len(str(idx)))\\n            idx += 1\\n        return ans_split\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def splitMessage(self, s: str, limit: int) -> List[str]:\\n        if limit <= 4: return []\\n        n = len(s)\\n        ans, step = float(\\'inf\\'), 1\\n        while True:\\n            if 2 * len(str(step)) + 3 > limit: break\\n            lo, hi, suffix = step, min(n, step * 10 - 1), len(str(step)) + 3\\n            while lo <= hi:\\n                mid = (lo + hi) // 2\\n                idx, i  = 1, 0\\n                while i < n:\\n                    i += limit - (suffix + len(str(idx)))\\n                    idx += 1\\n                    if idx - 1 > mid: break\\n                idx -= 1\\n                if idx <= mid:\\n                    ans = min(ans, mid)\\n                    hi = mid - 1\\n                else: lo = mid + 1\\n            if ans != float(\\'inf\\'): break\\n            step *= 10\\n        if ans == float(\\'inf\\'): return []\\n        ans_split = []\\n        idx, i, suffix = 1, 0, len(str(ans)) + 3\\n        while i < n:\\n            ans_split.append(s[i:i + limit - (suffix + len(str(idx)))] + \\'<\\' + str(idx) + \\'/\\' + str(ans) + \\'>\\')\\n            i += limit - (suffix + len(str(idx)))\\n            idx += 1\\n        return ans_split\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2822003,
                "title": "java-solution",
                "content": "Find number of messages needed given the limit: calculate the number of characters available with 1, 2, 3... k messages until the space is sufficient. \\nOnce that\\'s done, fill the array with the strings as asked.\\n\\n```\\nclass Solution {\\n    public String[] splitMessage(String message, int limit) {\\n        int mLen = message.length();\\n        int numMessages = numMessagesForLimit(limit, message.length());\\n        System.out.println(numMessages);\\n        int dDigits = numDigits(numMessages);\\n        int preLim = limit - 3 - dDigits;\\n        String[] res = new String[numMessages];\\n        int curr = 0;\\n        for (int i = 1; i <= numMessages; i++) {\\n            int space = preLim - numDigits(i);\\n            if (space < 0) {\\n                return new String[]{};\\n            }\\n            String s = \"\";\\n            if (curr+space < mLen) {\\n                s = message.substring(curr, curr+space);\\n                curr += space;\\n            } else {\\n                s = message.substring(curr, mLen);\\n                curr = mLen;\\n            }\\n            s += \"<\" + i + \"/\" + numMessages + \">\";\\n            res[i-1] = s;\\n        }\\n        return res;\\n    }\\n    \\n    int numMessagesForLimit(int limit, int msgSize) {\\n        int currSpace = 0;\\n        int currNumMessages = 0;\\n        int currDigits = numDigits(currNumMessages);\\n        while (currSpace < msgSize && currSpace >= 0) {\\n            int nextNumMessages = currNumMessages + 1;\\n            int nextDigits = numDigits(nextNumMessages);\\n            if (nextDigits == currDigits) {\\n                // basically just add space for the last message\\n                currSpace += limit - nextDigits*2 - 3;\\n            } else {\\n                // remove 1 char for all previous messages\\n                currSpace -= currNumMessages;\\n                // add space for the last message\\n                currSpace += limit - nextDigits*2 - 3;\\n            }\\n            currNumMessages = nextNumMessages;\\n            currDigits = nextDigits;\\n\\n        }\\n        return currNumMessages;\\n    }\\n    \\n    int numDigits(int number) {\\n        if (number > 9999) {\\n            return 5;\\n        }\\n        if (number > 999) {\\n            return 4;\\n        }\\n        if (number > 99) {\\n            return 3;\\n        }\\n        if (number > 9) {\\n            return 2;\\n        }\\n        return 1;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public String[] splitMessage(String message, int limit) {\\n        int mLen = message.length();\\n        int numMessages = numMessagesForLimit(limit, message.length());\\n        System.out.println(numMessages);\\n        int dDigits = numDigits(numMessages);\\n        int preLim = limit - 3 - dDigits;\\n        String[] res = new String[numMessages];\\n        int curr = 0;\\n        for (int i = 1; i <= numMessages; i++) {\\n            int space = preLim - numDigits(i);\\n            if (space < 0) {\\n                return new String[]{};\\n            }\\n            String s = \"\";\\n            if (curr+space < mLen) {\\n                s = message.substring(curr, curr+space);\\n                curr += space;\\n            } else {\\n                s = message.substring(curr, mLen);\\n                curr = mLen;\\n            }\\n            s += \"<\" + i + \"/\" + numMessages + \">\";\\n            res[i-1] = s;\\n        }\\n        return res;\\n    }\\n    \\n    int numMessagesForLimit(int limit, int msgSize) {\\n        int currSpace = 0;\\n        int currNumMessages = 0;\\n        int currDigits = numDigits(currNumMessages);\\n        while (currSpace < msgSize && currSpace >= 0) {\\n            int nextNumMessages = currNumMessages + 1;\\n            int nextDigits = numDigits(nextNumMessages);\\n            if (nextDigits == currDigits) {\\n                // basically just add space for the last message\\n                currSpace += limit - nextDigits*2 - 3;\\n            } else {\\n                // remove 1 char for all previous messages\\n                currSpace -= currNumMessages;\\n                // add space for the last message\\n                currSpace += limit - nextDigits*2 - 3;\\n            }\\n            currNumMessages = nextNumMessages;\\n            currDigits = nextDigits;\\n\\n        }\\n        return currNumMessages;\\n    }\\n    \\n    int numDigits(int number) {\\n        if (number > 9999) {\\n            return 5;\\n        }\\n        if (number > 999) {\\n            return 4;\\n        }\\n        if (number > 99) {\\n            return 3;\\n        }\\n        if (number > 9) {\\n            return 2;\\n        }\\n        return 1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2820182,
                "title": "c-brute-force-try-all-4-situations",
                "content": "I divided this problem into 5 situations:\\n* result has 1~9 parts\\n\\t* we need a filler length 5 for every part\\n\\t* each part can have `limit - 5` characters\\n* result has 10~99 parts\\n\\t* need a filler length 6 for each of first 9 parts\\n\\t\\t* those parts can have `limit - 6` characters\\n\\t* need a filler length 7 for the next 90 parts\\n\\t\\t* those parts can have `limit - 7` characters\\n* result has 100~999 parts\\n\\t* need a filler length 7 for each of first 9 parts\\n\\t* need a filler length 8 for the next 90 parts\\n\\t* need a filler length 9 for the next 900 parts\\n* result has 1000~9999 parts\\n\\t* same logic as above\\n* result has 10000 parts, that\\'s impossible\\n```\\nclass Solution {\\npublic:\\n    void addFiller(vector<string>& arr) {\\n        int m = arr.size();\\n        for(int i = 0;i<m;i++) {\\n            ostringstream ss;\\n            ss<<\\'<\\'<<i+1<<\\'/\\'<<m<<\\'>\\';\\n            arr[i] += ss.str();\\n        }\\n    }\\n    vector<string> splitMessage(string message, int limit) {\\n        // arr len contains 1 digit\\n        // -> must have filler <a/b> 5 char\\n        // arr len contains 2 digit\\n        // -> must have filler <a/bc> 6 char, <ab/cd> 7 char\\n        // arr len contains 3 digit \\n        // -> must have filler <a/bcd> 7 char, <ab/cde> 8 char, <abc/def> 9 char\\n        // can arr len be <= 9? 9*(limit - 5) >= n\\n        // can arr len be <= 99? (limit - 6)*9 + (limit - 7)*90 >= n\\n        // can arr len be <= 999? (limit - 7)*9 + (limit - 8)*90 + (limit - 9)*900 >= n\\n        // can arr len be <= 9999? (limit - 8)*9 + (limit - 9)*90 + (limit - 10)*900 + (limit - 11)*9000 >= n\\n        int n = message.size();\\n        int i = 0;\\n        vector<string> ret;\\n        int cap = 9*(limit - 5); // split into 9 parts, how many char can we handle?\\n        if(cap >= n) {\\n            while(i<n) {\\n                int len = limit - 5;\\n                ret.push_back(message.substr(i, len));\\n                i+= len;\\n            }\\n            addFiller(ret);\\n            return ret; \\n        }\\n        cap = (limit - 6)*9 + (limit - 7)*90;\\n        if(cap >= n) {\\n            while(i<n) {\\n                int flen = ret.size()<9?6:7;\\n                int len = limit - flen;\\n                ret.push_back(message.substr(i, len));\\n                i+= len;\\n            }\\n            addFiller(ret);\\n            return ret; \\n        }\\n        cap = (limit - 7)*9 + (limit - 8)*90 + (limit - 9)*900;\\n        if(cap >= n) {\\n            while(i<n) {\\n                int flen = 9;\\n                if(ret.size() < 9) {\\n                    flen = 7;\\n                } else if(ret.size() < 99) {\\n                    flen = 8;\\n                }\\n                int len = limit - flen;\\n                ret.push_back(message.substr(i, len));\\n                i+= len;\\n            }\\n            addFiller(ret);\\n            return ret; \\n        }\\n        cap = (limit - 8)*9 + (limit - 9)*90 + (limit - 10)*900 + (limit - 11)*9000;\\n        if(cap >= n) {\\n            while(i<n) {\\n                int flen = 11;\\n                if(ret.size() < 9) {\\n                    flen = 8;\\n                } else if(ret.size() < 99) {\\n                    flen = 9;\\n                } else if(ret.size() < 999) {\\n                    flen = 10;\\n                }\\n                int len = limit - flen;\\n                ret.push_back(message.substr(i, len));\\n                i+= len;\\n            }\\n            addFiller(ret);\\n            return ret;\\n        }\\n        return ret;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void addFiller(vector<string>& arr) {\\n        int m = arr.size();\\n        for(int i = 0;i<m;i++) {\\n            ostringstream ss;\\n            ss<<\\'<\\'<<i+1<<\\'/\\'<<m<<\\'>\\';\\n            arr[i] += ss.str();\\n        }\\n    }\\n    vector<string> splitMessage(string message, int limit) {\\n        // arr len contains 1 digit\\n        // -> must have filler <a/b> 5 char\\n        // arr len contains 2 digit\\n        // -> must have filler <a/bc> 6 char, <ab/cd> 7 char\\n        // arr len contains 3 digit \\n        // -> must have filler <a/bcd> 7 char, <ab/cde> 8 char, <abc/def> 9 char\\n        // can arr len be <= 9? 9*(limit - 5) >= n\\n        // can arr len be <= 99? (limit - 6)*9 + (limit - 7)*90 >= n\\n        // can arr len be <= 999? (limit - 7)*9 + (limit - 8)*90 + (limit - 9)*900 >= n\\n        // can arr len be <= 9999? (limit - 8)*9 + (limit - 9)*90 + (limit - 10)*900 + (limit - 11)*9000 >= n\\n        int n = message.size();\\n        int i = 0;\\n        vector<string> ret;\\n        int cap = 9*(limit - 5); // split into 9 parts, how many char can we handle?\\n        if(cap >= n) {\\n            while(i<n) {\\n                int len = limit - 5;\\n                ret.push_back(message.substr(i, len));\\n                i+= len;\\n            }\\n            addFiller(ret);\\n            return ret; \\n        }\\n        cap = (limit - 6)*9 + (limit - 7)*90;\\n        if(cap >= n) {\\n            while(i<n) {\\n                int flen = ret.size()<9?6:7;\\n                int len = limit - flen;\\n                ret.push_back(message.substr(i, len));\\n                i+= len;\\n            }\\n            addFiller(ret);\\n            return ret; \\n        }\\n        cap = (limit - 7)*9 + (limit - 8)*90 + (limit - 9)*900;\\n        if(cap >= n) {\\n            while(i<n) {\\n                int flen = 9;\\n                if(ret.size() < 9) {\\n                    flen = 7;\\n                } else if(ret.size() < 99) {\\n                    flen = 8;\\n                }\\n                int len = limit - flen;\\n                ret.push_back(message.substr(i, len));\\n                i+= len;\\n            }\\n            addFiller(ret);\\n            return ret; \\n        }\\n        cap = (limit - 8)*9 + (limit - 9)*90 + (limit - 10)*900 + (limit - 11)*9000;\\n        if(cap >= n) {\\n            while(i<n) {\\n                int flen = 11;\\n                if(ret.size() < 9) {\\n                    flen = 8;\\n                } else if(ret.size() < 99) {\\n                    flen = 9;\\n                } else if(ret.size() < 999) {\\n                    flen = 10;\\n                }\\n                int len = limit - flen;\\n                ret.push_back(message.substr(i, len));\\n                i+= len;\\n            }\\n            addFiller(ret);\\n            return ret;\\n        }\\n        return ret;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2818925,
                "title": "faster-than-95",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe main parameter is the number of digits of the total count. One can assume it (some number between 1 and 5) and simulate the outcome in each case.\\nThis seems the easiest approach.\\n\\n# Time complexity\\nThe computation takes constant time. Producing the output takes linear time.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def splitMessage(self, message: str, limit: int) -> List[str]:\\n        l=len(message)\\n        if limit<=5:\\n            return []\\n        min_size=None\\n        min_ct=0\\n        for ct in range(1, min(((limit-4)>>1)+1, 6)):\\n            total=0\\n            for i in range(1, ct):\\n                total+=(9*10**(i-1))*(limit-i-ct-3)\\n            left=l-total\\n            if left<0:\\n                continue\\n            left_size=(left-1)//(limit-2*ct-3)+1\\n            if left_size>9*10**(ct-1):\\n                continue\\n            total_size=left_size+10**(ct-1)-1\\n            if (min_size==None or total_size<min_size):\\n                min_size=total_size\\n                min_ct=ct\\n        if min_size==None:\\n            return []\\n        else:\\n            str_total_size=str(min_size)\\n            ans=[]\\n            curs=0\\n            for i in range(min_size-1):\\n                new_curs=curs+limit-(int(log10(i+1))+1)-min_ct-3\\n                # print(limit, (int(log10(i+1))+1), min_ct)\\n                ans.append(message[curs:new_curs]+\\'<\\'+str(i+1)+\\'/\\'+str_total_size+\\'>\\')\\n                curs=new_curs\\n            ans.append(message[curs:]+\\'<\\'+str_total_size+\\'/\\'+str_total_size+\\'>\\')\\n            return ans\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def splitMessage(self, message: str, limit: int) -> List[str]:\\n        l=len(message)\\n        if limit<=5:\\n            return []\\n        min_size=None\\n        min_ct=0\\n        for ct in range(1, min(((limit-4)>>1)+1, 6)):\\n            total=0\\n            for i in range(1, ct):\\n                total+=(9*10**(i-1))*(limit-i-ct-3)\\n            left=l-total\\n            if left<0:\\n                continue\\n            left_size=(left-1)//(limit-2*ct-3)+1\\n            if left_size>9*10**(ct-1):\\n                continue\\n            total_size=left_size+10**(ct-1)-1\\n            if (min_size==None or total_size<min_size):\\n                min_size=total_size\\n                min_ct=ct\\n        if min_size==None:\\n            return []\\n        else:\\n            str_total_size=str(min_size)\\n            ans=[]\\n            curs=0\\n            for i in range(min_size-1):\\n                new_curs=curs+limit-(int(log10(i+1))+1)-min_ct-3\\n                # print(limit, (int(log10(i+1))+1), min_ct)\\n                ans.append(message[curs:new_curs]+\\'<\\'+str(i+1)+\\'/\\'+str_total_size+\\'>\\')\\n                curs=new_curs\\n            ans.append(message[curs:]+\\'<\\'+str_total_size+\\'/\\'+str_total_size+\\'>\\')\\n            return ans\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2816174,
                "title": "easy-to-understand-c-code",
                "content": "```\\n\\n\\nclass Solution {\\npublic:\\n    // Figure out number of digits required to given number\\n    int getTotalDigits(int n) {\\n        int maxDigits = (log10(n)+1);\\n        int result = 0;\\n        int power10 = 10;\\n        int num = n;\\n        for (int i = 0; i < maxDigits; i++) {\\n            result += num;\\n            // remove each digits combination number from total number of digits\\n            num = n - (power10-1); \\n            power10 = power10*10;\\n        }\\n        return result;\\n    }\\n    \\n    bool possibleToFit(int len, int numPackets,int limit, bool &impossible) {\\n        int maxPacketDigits = (log10(numPackets)+1);\\n        int maxHeader = maxPacketDigits*2 + 3;  // accmodating denominator and tags </>\\n        // if maximumm possible header is less than limit then return not possible\\n        if (maxHeader >= limit) {\\n            impossible = true;\\n            return true;\\n        }\\n        // header size is total Digits + header\\n        int header = getTotalDigits(numPackets) + (maxPacketDigits + 3)*numPackets;\\n        int maxData = limit*numPackets;\\n        int totalData = header + len;\\n        // if macData with nubmer of packets is just greater or equal to total Data to be packaged\\n        return (maxData >= totalData);\\n    }\\n    \\n    vector<string> splitMessage(string message, int limit) {\\n        vector<string> data;\\n        int len = message.size();\\n        if (limit <= 5)\\n            return data;\\n        int packets = (len/limit) + 1;\\n        bool impossible = false;\\n        // Converge to find the optimial data to be sent\\n        while (!possibleToFit(len,packets,limit,impossible)) {\\n            packets++;\\n        }\\n        // if header is greater than the limit of the packet\\n        if (impossible)\\n            return data;\\n        \\n        int pos = 0;\\n        // iterate on each packets by packet to pack the data\\n        for (int i = 1; i <= packets; i++) {\\n            string header = \"<\"+ to_string(i) + \"/\" + to_string(packets) + \">\";\\n            int rem = limit - header.size();\\n            string s;\\n            // for last packet of the daa\\n            rem =  min(rem,(len-pos));\\n            for (int i = 0; i < rem; i++) {\\n                s.push_back(message[pos++]);\\n            }\\n            string final = s + header;\\n            data.push_back(final);\\n        }\\n        return data;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n\\n\\nclass Solution {\\npublic:\\n    // Figure out number of digits required to given number\\n    int getTotalDigits(int n) {\\n        int maxDigits = (log10(n)+1);\\n        int result = 0;\\n        int power10 = 10;\\n        int num = n;\\n        for (int i = 0; i < maxDigits; i++) {\\n            result += num;\\n            // remove each digits combination number from total number of digits\\n            num = n - (power10-1); \\n            power10 = power10*10;\\n        }\\n        return result;\\n    }\\n    \\n    bool possibleToFit(int len, int numPackets,int limit, bool &impossible) {\\n        int maxPacketDigits = (log10(numPackets)+1);\\n        int maxHeader = maxPacketDigits*2 + 3;  // accmodating denominator and tags </>\\n        // if maximumm possible header is less than limit then return not possible\\n        if (maxHeader >= limit) {\\n            impossible = true;\\n            return true;\\n        }\\n        // header size is total Digits + header\\n        int header = getTotalDigits(numPackets) + (maxPacketDigits + 3)*numPackets;\\n        int maxData = limit*numPackets;\\n        int totalData = header + len;\\n        // if macData with nubmer of packets is just greater or equal to total Data to be packaged\\n        return (maxData >= totalData);\\n    }\\n    \\n    vector<string> splitMessage(string message, int limit) {\\n        vector<string> data;\\n        int len = message.size();\\n        if (limit <= 5)\\n            return data;\\n        int packets = (len/limit) + 1;\\n        bool impossible = false;\\n        // Converge to find the optimial data to be sent\\n        while (!possibleToFit(len,packets,limit,impossible)) {\\n            packets++;\\n        }\\n        // if header is greater than the limit of the packet\\n        if (impossible)\\n            return data;\\n        \\n        int pos = 0;\\n        // iterate on each packets by packet to pack the data\\n        for (int i = 1; i <= packets; i++) {\\n            string header = \"<\"+ to_string(i) + \"/\" + to_string(packets) + \">\";\\n            int rem = limit - header.size();\\n            string s;\\n            // for last packet of the daa\\n            rem =  min(rem,(len-pos));\\n            for (int i = 0; i < rem; i++) {\\n                s.push_back(message[pos++]);\\n            }\\n            string final = s + header;\\n            data.push_back(final);\\n        }\\n        return data;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2813395,
                "title": "golang-brute-force-runtime-142-ms-memory-7-4-mb",
                "content": "```\\nfunc splitMessage(message string, limit int) []string {\\n\\tp := 1\\n\\ta := 1\\n\\n\\tfor p*(size(p)+3)+a+len(message) > p*limit {\\n\\t\\tif 3+size(p)*2 >= limit {\\n\\t\\t\\treturn []string{}\\n\\t\\t}\\n\\t\\tp += 1\\n\\t\\ta += size(p)\\n\\t}\\n\\n\\tparts := make([]string, 0)\\n\\n\\tfor i := 1; i < p+1; i++ {\\n\\t\\tj := Min(limit - (size(p) + size(i) + 3), len(message))\\n\\t\\tpart := message[0:j]\\n\\t\\tmessage = message[j:]\\n\\t\\tparts = append(parts, fmt.Sprintf(\"%s<%d/%d>\", part, i, p))\\n\\t}\\n\\n\\treturn parts\\n}\\n\\nfunc Min(x, y int) int {\\n\\tif x < y {\\n\\t\\treturn x\\n\\t}\\n\\treturn y\\n}\\n\\nfunc size(n int) int {\\n\\treturn len(strconv.Itoa(n))\\n}\\n\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc splitMessage(message string, limit int) []string {\\n\\tp := 1\\n\\ta := 1\\n\\n\\tfor p*(size(p)+3)+a+len(message) > p*limit {\\n\\t\\tif 3+size(p)*2 >= limit {\\n\\t\\t\\treturn []string{}\\n\\t\\t}\\n\\t\\tp += 1\\n\\t\\ta += size(p)\\n\\t}\\n\\n\\tparts := make([]string, 0)\\n\\n\\tfor i := 1; i < p+1; i++ {\\n\\t\\tj := Min(limit - (size(p) + size(i) + 3), len(message))\\n\\t\\tpart := message[0:j]\\n\\t\\tmessage = message[j:]\\n\\t\\tparts = append(parts, fmt.Sprintf(\"%s<%d/%d>\", part, i, p))\\n\\t}\\n\\n\\treturn parts\\n}\\n\\nfunc Min(x, y int) int {\\n\\tif x < y {\\n\\t\\treturn x\\n\\t}\\n\\treturn y\\n}\\n\\nfunc size(n int) int {\\n\\treturn len(strconv.Itoa(n))\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2813178,
                "title": "python-short-and-clean-solution-time-o-n",
                "content": "We will iterate all different possible **length** of list length to do simulation.\\nMore detailedly, we will try 1 with 1-9, 2 with 10-99 and so on...\\nNote the maximum message length is 10000, so our candidates will be 1, 2, 3, 4, 5.\\nWe want to get the answer with the final list length matches its string length (90-2, 101-3, and so on) and all of message chars are used up, \\n```\\ndef splitMessage(self, s: str, x: int) -> List[str]:\\n\\tfor k in range(1, 6):\\n\\t\\ti, j, ans = 0, 1, []\\n\\t\\twhile(i<len(s) and len(str(j))+k+3<x):\\n\\t\\t\\tp = \\'<\\'+str(j)+\\'/\\'+\\'$\\'*k+\\'>\\'\\n\\t\\t\\tans.append(s[i:i+(x-len(p))]+p)\\n\\t\\t\\ti += (x-len(p))\\n\\t\\t\\tj += 1\\n\\t\\tif i>=len(s) and len(str(len(ans)))==k:\\n\\t\\t\\treturn [e.replace(\\'$\\'*k, str(len(ans))) for e in ans]\\n\\treturn []\\n```",
                "solutionTags": [],
                "code": "```\\ndef splitMessage(self, s: str, x: int) -> List[str]:\\n\\tfor k in range(1, 6):\\n\\t\\ti, j, ans = 0, 1, []\\n\\t\\twhile(i<len(s) and len(str(j))+k+3<x):\\n\\t\\t\\tp = \\'<\\'+str(j)+\\'/\\'+\\'$\\'*k+\\'>\\'\\n\\t\\t\\tans.append(s[i:i+(x-len(p))]+p)\\n\\t\\t\\ti += (x-len(p))\\n\\t\\t\\tj += 1\\n\\t\\tif i>=len(s) and len(str(len(ans)))==k:\\n\\t\\t\\treturn [e.replace(\\'$\\'*k, str(len(ans))) for e in ans]\\n\\treturn []\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2812883,
                "title": "c-binary-search",
                "content": "# Intuition\\nBinary Search can Help in finding the optimal point. Although brute force will also require very few iterations, but it requires some maths.\\n\\n# Approach\\nBinary search on answer\\n# Complexity\\n- Time complexity:$$O(nlogn)$$\\n- Space complexity:$$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    \\n    int split(string &s, int k, int lim){\\n        //can i split string s into k parts?\\n        int cur = s.size();\\n        for(int part = 1; part<=k; part++){\\n            int len = to_string(part).size() + to_string(k).size() + 3;\\n            if(len>lim || cur==0)return -1; //need to decrease k\\n            int extra = lim-len;\\n            if(part!=k && cur<extra)return -1;\\n            cur-=min(cur, extra);\\n        }\\n        if(cur==0)return 0; //perfect match\\n        return 1; //need to increase k\\n    }\\n    vector<string>build(string &s, int k, int lim){\\n        int cur = s.size();\\n        vector<string>ans;\\n        int i=0;\\n        for(int part = 1; part<=k; part++){\\n            int len = to_string(part).size() + to_string(k).size() + 3;\\n            int extra = lim-len;\\n            int take = min(cur, extra);\\n            cur-=take;\\n            ans.push_back(s.substr(i, take)+\"<\"+to_string(part)+\"/\"+to_string(k)+\">\");\\n            i+=take;\\n        }\\n        return ans;\\n    }\\n    \\npublic:\\n    vector<string> splitMessage(string s, int limit) {\\n        int l=1, r=s.size();\\n        int amin = INT_MAX;\\n        while(l<=r){\\n            int mid = (l+r)>>1;\\n            int sp = split(s, mid, limit);\\n            if(sp==0){\\n                amin = min(amin, mid);\\n                r=mid-1;\\n            }\\n            else if(sp==-1)\\n                r=mid-1;\\n            else\\n                l=mid+1;\\n        }\\n        if(amin!=INT_MAX)\\n            return build(s, amin, limit);\\n        return {};\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\n    \\n    int split(string &s, int k, int lim){\\n        //can i split string s into k parts?\\n        int cur = s.size();\\n        for(int part = 1; part<=k; part++){\\n            int len = to_string(part).size() + to_string(k).size() + 3;\\n            if(len>lim || cur==0)return -1; //need to decrease k\\n            int extra = lim-len;\\n            if(part!=k && cur<extra)return -1;\\n            cur-=min(cur, extra);\\n        }\\n        if(cur==0)return 0; //perfect match\\n        return 1; //need to increase k\\n    }\\n    vector<string>build(string &s, int k, int lim){\\n        int cur = s.size();\\n        vector<string>ans;\\n        int i=0;\\n        for(int part = 1; part<=k; part++){\\n            int len = to_string(part).size() + to_string(k).size() + 3;\\n            int extra = lim-len;\\n            int take = min(cur, extra);\\n            cur-=take;\\n            ans.push_back(s.substr(i, take)+\"<\"+to_string(part)+\"/\"+to_string(k)+\">\");\\n            i+=take;\\n        }\\n        return ans;\\n    }\\n    \\npublic:\\n    vector<string> splitMessage(string s, int limit) {\\n        int l=1, r=s.size();\\n        int amin = INT_MAX;\\n        while(l<=r){\\n            int mid = (l+r)>>1;\\n            int sp = split(s, mid, limit);\\n            if(sp==0){\\n                amin = min(amin, mid);\\n                r=mid-1;\\n            }\\n            else if(sp==-1)\\n                r=mid-1;\\n            else\\n                l=mid+1;\\n        }\\n        if(amin!=INT_MAX)\\n            return build(s, amin, limit);\\n        return {};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2810597,
                "title": "binary-solution-easy-to-understand",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool flag=false;\\n\\n    //this function will make the suffix and will also tell how many more char can be added\\n    int suf(int x,int y,string&s){\\n        s+=\\'<\\';\\n        s+=to_string(x);\\n        s+=\\'/\\';\\n        s+=to_string(y);\\n        s+=\\'>\\';\\n        return s.size();\\n    }\\n\\n    void help(vector<string>&ans,string message,int n,int limit,int mid){\\n        int cur=1; //part number initially 1\\n        for(int i=0;i<n;){\\n            string first=\"\";\\n            string suff=\"\";\\n            int x=suf(cur,mid,suff);//x=number of char we can still add\\n            int size=limit-x;\\n            if(size<=0)return; //if we can\\'t add any char just return\\n            while(i<n&&size--){\\n                first+=message[i++]; //iterate over original message\\n            }\\n            ans.push_back(first+suff);\\n            cur++; //increase the section number\\n        }\\n        //if this flag will remain false that means the whole message it not traversed, we used it on line 41\\n        flag=true;\\n    }\\n    vector<string> splitMessage(string message, int limit) {\\n        int s=0;\\n        int e=10001;\\n        \\n        //binary to find all sizes\\n        while(s<=e){\\n            int mid=s+(e-s)/2;\\n            vector<string>ans;\\n            help(ans,message,message.size(),limit,mid);\\n            if(ans.size()==mid && flag==true){\\n                return ans;\\n            }\\n            else if(ans.size()>mid){\\n                s=mid+1;\\n            }\\n            else{\\n                e=mid-1;\\n            }\\n        }\\n        return {};\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool flag=false;\\n\\n    //this function will make the suffix and will also tell how many more char can be added\\n    int suf(int x,int y,string&s){\\n        s+=\\'<\\';\\n        s+=to_string(x);\\n        s+=\\'/\\';\\n        s+=to_string(y);\\n        s+=\\'>\\';\\n        return s.size();\\n    }\\n\\n    void help(vector<string>&ans,string message,int n,int limit,int mid){\\n        int cur=1; //part number initially 1\\n        for(int i=0;i<n;){\\n            string first=\"\";\\n            string suff=\"\";\\n            int x=suf(cur,mid,suff);//x=number of char we can still add\\n            int size=limit-x;\\n            if(size<=0)return; //if we can\\'t add any char just return\\n            while(i<n&&size--){\\n                first+=message[i++]; //iterate over original message\\n            }\\n            ans.push_back(first+suff);\\n            cur++; //increase the section number\\n        }\\n        //if this flag will remain false that means the whole message it not traversed, we used it on line 41\\n        flag=true;\\n    }\\n    vector<string> splitMessage(string message, int limit) {\\n        int s=0;\\n        int e=10001;\\n        \\n        //binary to find all sizes\\n        while(s<=e){\\n            int mid=s+(e-s)/2;\\n            vector<string>ans;\\n            help(ans,message,message.size(),limit,mid);\\n            if(ans.size()==mid && flag==true){\\n                return ans;\\n            }\\n            else if(ans.size()>mid){\\n                s=mid+1;\\n            }\\n            else{\\n                e=mid-1;\\n            }\\n        }\\n        return {};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2810384,
                "title": "very-intuitive-c-solution-easy-binary-search",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSo my initial thougths were, if i have to split the string, I need to know the final length of the string. The main message string is not affected, but the <a/b> part of the string is the problem. The varying \\'a\\' length also can be managed easily, if we know \\'b\\'. But to find \\'b\\' we need to know the final length of the string. Which means it is as if we are stuck in a loop.\\nSo what if we can somehow estimate this \\'b\\'? That\\'s when I thought of Binary Search. Given the constraints, I thought this is the best approach to take.\\n\\n# Complexity\\n- Time complexity:$$O(log n)$$ for binary search, constant time in check function as the maximum times the for loop runs is 5, and $$O(limit*k)$$ for the formString() function because of substr function. (Correct me if I am wrong please) \\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> dif={9,90,900,9000,1};\\n    vector<int> start={1,10,100,1000,10000};\\n    int numf(int n){\\n        int ans=0;\\n        while(n>0){\\n            n/=10;\\n            ans++;\\n        }\\n        return ans;\\n    }\\n    bool check(int mid,int n,int limit){\\n        int dig=numf(mid);\\n        for(int i=0;i<dig-1;++i){\\n            int each=i+1+dig+3;\\n            int eachString=limit-each;\\n            n-=(eachString*dif[i]);\\n                \\n        }\\n        if(n<=0)\\n            return true;\\n        int startDig=start[dig-1];\\n        int number=mid-startDig+1;\\n        int each=2*dig+3;\\n        int eachString=limit-each;\\n        n-=(eachString*number);\\n        if(n<=0)\\n            return true;\\n        return false;\\n        \\n    }\\n    vector<string> formString(int k,string &message,int limit){\\n        vector<string> ans;\\n        int j=0;\\n        string final1=to_string(k);\\n        int tdig=numf(k);\\n        for(int i=1;i<=k;++i){\\n            if(j>message.size())\\n                return {};\\n            int dig=numf(i);\\n            int each=dig+tdig+3;\\n            int left=limit-each;\\n            string temp=\"\";\\n            if((j+left)>message.size())\\n                temp+=message.substr(j);\\n            else{\\n                temp+=message.substr(j,left);\\n            }\\n            j=j+left;\\n            temp+=\\'<\\'+to_string(i)+\\'/\\'+final1+\\'>\\';\\n            ans.push_back(temp);\\n            \\n        }\\n        return ans;\\n    }\\n    vector<string> splitMessage(string message, int limit) {\\n        int n=message.size();\\n        int start=1;\\n        int end=n;\\n        int mid;\\n        int ans;\\n        while(start<=end){\\n            mid=(start+end)/2;\\n            if(check(mid,n,limit)){\\n                ans=mid;\\n                end=mid-1;\\n            }\\n            else{\\n                start=mid+1;\\n            }\\n        }\\n        \\n        vector<string> a=formString(ans,message,limit);\\n        return a;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> dif={9,90,900,9000,1};\\n    vector<int> start={1,10,100,1000,10000};\\n    int numf(int n){\\n        int ans=0;\\n        while(n>0){\\n            n/=10;\\n            ans++;\\n        }\\n        return ans;\\n    }\\n    bool check(int mid,int n,int limit){\\n        int dig=numf(mid);\\n        for(int i=0;i<dig-1;++i){\\n            int each=i+1+dig+3;\\n            int eachString=limit-each;\\n            n-=(eachString*dif[i]);\\n                \\n        }\\n        if(n<=0)\\n            return true;\\n        int startDig=start[dig-1];\\n        int number=mid-startDig+1;\\n        int each=2*dig+3;\\n        int eachString=limit-each;\\n        n-=(eachString*number);\\n        if(n<=0)\\n            return true;\\n        return false;\\n        \\n    }\\n    vector<string> formString(int k,string &message,int limit){\\n        vector<string> ans;\\n        int j=0;\\n        string final1=to_string(k);\\n        int tdig=numf(k);\\n        for(int i=1;i<=k;++i){\\n            if(j>message.size())\\n                return {};\\n            int dig=numf(i);\\n            int each=dig+tdig+3;\\n            int left=limit-each;\\n            string temp=\"\";\\n            if((j+left)>message.size())\\n                temp+=message.substr(j);\\n            else{\\n                temp+=message.substr(j,left);\\n            }\\n            j=j+left;\\n            temp+=\\'<\\'+to_string(i)+\\'/\\'+final1+\\'>\\';\\n            ans.push_back(temp);\\n            \\n        }\\n        return ans;\\n    }\\n    vector<string> splitMessage(string message, int limit) {\\n        int n=message.size();\\n        int start=1;\\n        int end=n;\\n        int mid;\\n        int ans;\\n        while(start<=end){\\n            mid=(start+end)/2;\\n            if(check(mid,n,limit)){\\n                ans=mid;\\n                end=mid-1;\\n            }\\n            else{\\n                start=mid+1;\\n            }\\n        }\\n        \\n        vector<string> a=formString(ans,message,limit);\\n        return a;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2810051,
                "title": "my-cpp-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<string> splitMessage(string message, int limit) {\\n        vector<int>dig(10001),cum(10001);// contains number of digits in N and cumulative sum of number of digits.\\n        // find number of digits in X.\\n        auto numdig=[](int x){\\n            int ret = 0;\\n            while(x){\\n                ret++;\\n                x/=10;\\n            }\\n            return ret;\\n        };\\n        for(int i=1;i<=10000;i++){\\n            dig[i] = numdig(i); \\n            cum[i] = cum[i-1]+dig[i];\\n        }\\n        \\n        int actual_size = message.size();\\n        vector<string>ret;\\n        for(int i=1;i<=actual_size;i++){\\n            int newSize = actual_size+3*i+dig[i]*i+cum[i];\\n            int z = newSize - (i-1)*limit;\\n            \\n            //check if possible to achieve the result.\\n            if(z>0 && z<=limit){\\n                string s;\\n                int cur = 1;\\n                for(char&c:message){\\n                    s+=c;\\n                    if(s.size()+dig[cur]+dig[i]+3==limit){\\n                        s+=\"<\"+to_string(cur)+\"/\"+to_string(i)+\">\";\\n                        ret.push_back(s);\\n                        s.clear();\\n                        cur++;\\n                    }\\n                }\\n                if(s.size()){\\n                      s+=\"<\"+to_string(cur)+\"/\"+to_string(i)+\">\";\\n                        ret.push_back(s);\\n                        s.clear();\\n                }\\n                return ret;\\n            }\\n        }\\n        return ret;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> splitMessage(string message, int limit) {\\n        vector<int>dig(10001),cum(10001);// contains number of digits in N and cumulative sum of number of digits.\\n        // find number of digits in X.\\n        auto numdig=[](int x){\\n            int ret = 0;\\n            while(x){\\n                ret++;\\n                x/=10;\\n            }\\n            return ret;\\n        };\\n        for(int i=1;i<=10000;i++){\\n            dig[i] = numdig(i); \\n            cum[i] = cum[i-1]+dig[i];\\n        }\\n        \\n        int actual_size = message.size();\\n        vector<string>ret;\\n        for(int i=1;i<=actual_size;i++){\\n            int newSize = actual_size+3*i+dig[i]*i+cum[i];\\n            int z = newSize - (i-1)*limit;\\n            \\n            //check if possible to achieve the result.\\n            if(z>0 && z<=limit){\\n                string s;\\n                int cur = 1;\\n                for(char&c:message){\\n                    s+=c;\\n                    if(s.size()+dig[cur]+dig[i]+3==limit){\\n                        s+=\"<\"+to_string(cur)+\"/\"+to_string(i)+\">\";\\n                        ret.push_back(s);\\n                        s.clear();\\n                        cur++;\\n                    }\\n                }\\n                if(s.size()){\\n                      s+=\"<\"+to_string(cur)+\"/\"+to_string(i)+\">\";\\n                        ret.push_back(s);\\n                        s.clear();\\n                }\\n                return ret;\\n            }\\n        }\\n        return ret;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2809511,
                "title": "o-n-solution-with-detailed-approach-dry-run-of-a-tc-for-easy-understanding",
                "content": "# Intuition\\nThis question looked bad at reading first but it is fairly simple, not much intuition is required just some basic math.\\n => FIND THE TOTAL NUMBER OF PARTS IN THE ANSWER\\n\\n# Approach\\nOnly thing we need to find is the total number of parts in the answer and parts can vary from 1 to 10000 so let\\'s do that brute force way.\\nTaking Sample Input 1 as example, \\nTotal parts = 14,\\nSo for 14 parts, we will calculate the length of new split based string\\nEach part has: \"</>\" these 3 characters,\\nEach part will have: \"14\" in it\\nAnd each part will have \"i\" where i varies from 1 to 14\\nk = original message length\\nlet m = \"1234567891011121314\" {string from 1 to 14}\\nSo total length =  k + (14 * 3) + (\"14\".size() * 14) + m.size();\\n\\nNow our optimal total parts will be when :\\n    total length / limit == current number of parts\\n\\nSo by varying current parts from 1 to 10000, we can find our answer.\\n\\nGeneral formula for total length:\\n    TL = message.size() + (part * 3) + (part.size() * part) + totalPartSum;\\n\\n\\nOnce we figure out the optimal number of parts, we can form our answer very easily.\\n\\n# Complexity\\n- Time complexity:\\nO(n) where n is the length of final output string (or say vector of strings)\\n\\n- Space complexity:\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int dig(int n) {\\n        int d = 0;\\n        while(n!=0) {\\n            n/=10;\\n            d++;\\n        }\\n        return d;\\n    }\\n    vector<string> splitMessage(string message, int limit) {\\n        vector<string> ans;\\n        vector<int> arr(10000);\\n        for(int i=0;i<arr.size();i++) arr[i] = i+1;\\n        int sum = 0, parts = 0;\\n        for(int i=0;i<arr.size();i++) {\\n            int n = arr[i];\\n            sum += dig(n);\\n            int p = arr[i];\\n            int total = message.size() + p*3 + dig(n)*p + sum;\\n            if((int)ceil(total/(limit*1.0))==p) {\\n                parts = p;\\n                break;\\n            }\\n        }\\n        int j = 0;\\n        for(int p=1;p<=parts;p++) {\\n            int suff = dig(parts) + dig(p) + 3;\\n            string temp = \"\";\\n            int len = limit-suff;\\n            while(j<message.size()&&len>0) {\\n                temp += message[j++];\\n                len--;\\n            }\\n            temp += \"<\";\\n            temp += to_string(p);\\n            temp += \"/\";\\n            temp += to_string(parts);\\n            temp += \">\";\\n            ans.push_back(temp);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dig(int n) {\\n        int d = 0;\\n        while(n!=0) {\\n            n/=10;\\n            d++;\\n        }\\n        return d;\\n    }\\n    vector<string> splitMessage(string message, int limit) {\\n        vector<string> ans;\\n        vector<int> arr(10000);\\n        for(int i=0;i<arr.size();i++) arr[i] = i+1;\\n        int sum = 0, parts = 0;\\n        for(int i=0;i<arr.size();i++) {\\n            int n = arr[i];\\n            sum += dig(n);\\n            int p = arr[i];\\n            int total = message.size() + p*3 + dig(n)*p + sum;\\n            if((int)ceil(total/(limit*1.0))==p) {\\n                parts = p;\\n                break;\\n            }\\n        }\\n        int j = 0;\\n        for(int p=1;p<=parts;p++) {\\n            int suff = dig(parts) + dig(p) + 3;\\n            string temp = \"\";\\n            int len = limit-suff;\\n            while(j<message.size()&&len>0) {\\n                temp += message[j++];\\n                len--;\\n            }\\n            temp += \"<\";\\n            temp += to_string(p);\\n            temp += \"/\";\\n            temp += to_string(parts);\\n            temp += \">\";\\n            ans.push_back(temp);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2808580,
                "title": "python-binary-search",
                "content": "```python\\nclass Solution:\\n    def splitMessage(self, message: str, limit: int) -> List[str]:        \\n        n = len(message)\\n        \\n        if limit < 5: return [] # <a/b>, we need 5 length at least\\n            \\n        res = []\\n        l, r = 1, n # try to split from 1 to n parts\\n        while l <= r:\\n            mid = l + (r-l)//2 # number of parts\\n            \\n            # check\\n            candidate = []\\n            idx = 0\\n            a = 1\\n            suffix = \"\"\\n            while a <= mid:\\n                suffix = f\"<{a}/{mid}>\"\\n                length = limit-len(suffix)\\n                candidate.append(f\"{message[idx:idx+length]}{suffix}\")\\n                idx += length\\n                a += 1\\n\\n            # shrink search space\\n            if idx < n: # split not enough parts\\n                l = mid+1\\n\\t\\t\\t\\t\\n\\t\\t\\t# ex. \"ymm\", 8; \"short message\", 15\\n\\t\\t\\t# since we check last two elements to move `r` pointer, we need to handle edge case of split len == 1\\n            elif len(candidate) == 1:\\n                if candidate[0][:-len(suffix)] != \"\":\\n                    return candidate\\n                else:\\n                    return []\\n            elif len(candidate[-2]) != limit or candidate[-1][:-len(suffix)] == \"\": # split too many parts\\n                r = mid-1\\n            else:\\n                res = candidate\\n                l+=1\\n\\n        return res\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```python\\nclass Solution:\\n    def splitMessage(self, message: str, limit: int) -> List[str]:        \\n        n = len(message)\\n        \\n        if limit < 5: return [] # <a/b>, we need 5 length at least\\n            \\n        res = []\\n        l, r = 1, n # try to split from 1 to n parts\\n        while l <= r:\\n            mid = l + (r-l)//2 # number of parts\\n            \\n            # check\\n            candidate = []\\n            idx = 0\\n            a = 1\\n            suffix = \"\"\\n            while a <= mid:\\n                suffix = f\"<{a}/{mid}>\"\\n                length = limit-len(suffix)\\n                candidate.append(f\"{message[idx:idx+length]}{suffix}\")\\n                idx += length\\n                a += 1\\n\\n            # shrink search space\\n            if idx < n: # split not enough parts\\n                l = mid+1\\n\\t\\t\\t\\t\\n\\t\\t\\t# ex. \"ymm\", 8; \"short message\", 15\\n\\t\\t\\t# since we check last two elements to move `r` pointer, we need to handle edge case of split len == 1\\n            elif len(candidate) == 1:\\n                if candidate[0][:-len(suffix)] != \"\":\\n                    return candidate\\n                else:\\n                    return []\\n            elif len(candidate[-2]) != limit or candidate[-1][:-len(suffix)] == \"\": # split too many parts\\n                r = mid-1\\n            else:\\n                res = candidate\\n                l+=1\\n\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2808488,
                "title": "c-solution",
                "content": "# Code\\n```\\npublic class Solution\\n{\\n    public string[] SplitMessage(string message, int limit)\\n    {\\n        var cur = 0;\\n        var k = 0;\\n        var i = 0;\\n\\n        while (3 + k.ToString().Length * 2 < limit && cur + message.Length + (3 + k.ToString().Length) * k > limit * k)\\n        {\\n            k += 1;\\n            cur += k.ToString().Length;\\n        }\\n\\n        var result = new List<string>();\\n\\n        if (3 + k.ToString().Length * 2 < limit)\\n            foreach (var j in Enumerable.Range(1, k))\\n            {\\n                var l = limit - (j.ToString().Length + 3 + k.ToString().Length);\\n                var r = i + l > message.Length ? message.Length : i + l;\\n                result.Add($\"{message[i..r]}<{j}/{k}>\");\\n                i += l;\\n            }\\n\\n        return result.ToArray();\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution\\n{\\n    public string[] SplitMessage(string message, int limit)\\n    {\\n        var cur = 0;\\n        var k = 0;\\n        var i = 0;\\n\\n        while (3 + k.ToString().Length * 2 < limit && cur + message.Length + (3 + k.ToString().Length) * k > limit * k)\\n        {\\n            k += 1;\\n            cur += k.ToString().Length;\\n        }\\n\\n        var result = new List<string>();\\n\\n        if (3 + k.ToString().Length * 2 < limit)\\n            foreach (var j in Enumerable.Range(1, k))\\n            {\\n                var l = limit - (j.ToString().Length + 3 + k.ToString().Length);\\n                var r = i + l > message.Length ? message.Length : i + l;\\n                result.Add($\"{message[i..r]}<{j}/{k}>\");\\n                i += l;\\n            }\\n\\n        return result.ToArray();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2808351,
                "title": "python-just-calc-and-format-array",
                "content": "```python\\nclass Solution:\\n    def splitMessage(self, message: str, limit: int) -> List[str]:\\n        if limit <= 5:\\n            return []\\n\\n        length = 5  # <1/9>\\n        cap = 9\\n\\n        # calc start cap\\n        while True:\\n            chunks = len(message) / (limit - length)\\n            if chunks < cap:\\n                break\\n            cap = int(str(cap) + \\'9\\')\\n\\n        # count total chunks\\n        j = 0\\n        total = 0\\n\\n        while j < len(message):\\n            curr_chunk_len = limit - (1 + len(str(total + 1)) + 1 + len(str(cap)) + 1)\\n            j += curr_chunk_len\\n            total += 1\\n            if curr_chunk_len <= 0:\\n                return []\\n\\n        # format chunks\\n        i = 1\\n        j = 0\\n        arr = []\\n\\n        while j < len(message):\\n            curr_chunk_len = limit - (1 + len(str(i)) + 1 + len(str(cap)) + 1)\\n            arr.append(\\'{}<{}/{}>\\'.format(message[j:j+curr_chunk_len], i, total))\\n            j += curr_chunk_len\\n            i += 1\\n\\n        return arr\\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def splitMessage(self, message: str, limit: int) -> List[str]:\\n        if limit <= 5:\\n            return []\\n\\n        length = 5  # <1/9>\\n        cap = 9\\n\\n        # calc start cap\\n        while True:\\n            chunks = len(message) / (limit - length)\\n            if chunks < cap:\\n                break\\n            cap = int(str(cap) + \\'9\\')\\n\\n        # count total chunks\\n        j = 0\\n        total = 0\\n\\n        while j < len(message):\\n            curr_chunk_len = limit - (1 + len(str(total + 1)) + 1 + len(str(cap)) + 1)\\n            j += curr_chunk_len\\n            total += 1\\n            if curr_chunk_len <= 0:\\n                return []\\n\\n        # format chunks\\n        i = 1\\n        j = 0\\n        arr = []\\n\\n        while j < len(message):\\n            curr_chunk_len = limit - (1 + len(str(i)) + 1 + len(str(cap)) + 1)\\n            arr.append(\\'{}<{}/{}>\\'.format(message[j:j+curr_chunk_len], i, total))\\n            j += curr_chunk_len\\n            i += 1\\n\\n        return arr\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2808163,
                "title": "nlogn-easy-to-understand-simple-impelmetation",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<string> ans;\\n    vector<string> splitMessage(string message, int limit) {\\n        int low=1,high=message.size();\\n       // find the optimal number of parts ranging from 1 to size of the string\\n        while(low<=high){\\n            int m = (low+high)/2;\\n            if(f(m,message,limit)){\\n                high=m-1;\\n            }\\n            else low=m+1;\\n        }\\n        return ans;\\n    }\\n    \\n    bool f(int p, string mess, int limit){\\n        vector<string> s;\\n        int n = mess.size();\\n        int cnt=0;\\n        int index=0;\\n        while(index<n){\\n            string tmp=\"<\"+to_string(++cnt)+\"/\"+to_string(p)+\">\";\\n            \\n            int remainingLength=limit-tmp.size();\\n            \\n            if(remainingLength<=0)return 0;  // if we dont have enogh space to put even a single char then partioning with given number of part is not possible\\n            \\n            tmp=mess.substr(index,remainingLength)+tmp;\\n            index+=remainingLength;\\n            s.push_back(tmp);\\n        }\\n        if(cnt<=p){ // if the number of part is less than the currect part that means partitioning with cnt parts is possibe  we save the answer in **ans**\\n            ans=s;\\n            return 1;\\n        }\\n        return 0;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> ans;\\n    vector<string> splitMessage(string message, int limit) {\\n        int low=1,high=message.size();\\n       // find the optimal number of parts ranging from 1 to size of the string\\n        while(low<=high){\\n            int m = (low+high)/2;\\n            if(f(m,message,limit)){\\n                high=m-1;\\n            }\\n            else low=m+1;\\n        }\\n        return ans;\\n    }\\n    \\n    bool f(int p, string mess, int limit){\\n        vector<string> s;\\n        int n = mess.size();\\n        int cnt=0;\\n        int index=0;\\n        while(index<n){\\n            string tmp=\"<\"+to_string(++cnt)+\"/\"+to_string(p)+\">\";\\n            \\n            int remainingLength=limit-tmp.size();\\n            \\n            if(remainingLength<=0)return 0;  // if we dont have enogh space to put even a single char then partioning with given number of part is not possible\\n            \\n            tmp=mess.substr(index,remainingLength)+tmp;\\n            index+=remainingLength;\\n            s.push_back(tmp);\\n        }\\n        if(cnt<=p){ // if the number of part is less than the currect part that means partitioning with cnt parts is possibe  we save the answer in **ans**\\n            ans=s;\\n            return 1;\\n        }\\n        return 0;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2808099,
                "title": "c-str",
                "content": "# Intuition\\n 1. if not more than 10 segs can solve , then for each seg carries limit-5 charactors in message. we \\n 2. if 10 segs not enough, we get remaining chars in message r = message.length - 9 *(limit -5); let\\'s try 2 digits segs(max 99), we need to add one charactor to first 9 segs, and remove 9 chars from first 9 segs  and add them back to r; let \\'s continue to check if two digits segs(max 90) can carries r;\\n 3. step by step ,we will find the segs needed.\\n\\n# Approach\\nBrute\\n\\n# Complexity\\n- Time complexity:\\n \\nmax: O(n) \\n- Space complexity:\\no(1)\\n\\n# Code\\n```\\npublic class Solution {\\n    public string[] SplitMessage(string message, int limit) {\\n        \\n        if(limit<6) return new string[0];\\n        \\n        //FIND SEGMENTS STEP BY STEP\\n        \\n        int n = message.Length;\\n        int t = n;\\n        int[] sufLen = new int[]{5,7,9,11};\\n        int[] ns = new int[]{9,90,900,9000};  //numb in segment ,9 90 900 9000 ...\\n        int[] offset = new int[]{1,10,100,1000};\\n        int[] presum = new int[]{9,99,999,9999};\\n        \\n        int i = 0;\\n        \\n        while(t>0)\\n        {            \\n            if((limit-sufLen[i])*ns[i]>=t)\\n                break;\\n            t = t - (limit-sufLen[i])*ns[i] + presum[i];\\n            i++; \\n            if(i>3)\\n                return new string[0];\\n        }\\n        \\n        int remin = (t+limit-sufLen[i]-1)/(limit-sufLen[i]);\\n         \\n        int segs = offset[i] + remin-1; \\n        int off = 0;\\n        string[] res = new string[segs];\\n        for(int j=1;j<=segs;j++)\\n        {\\n            int strLen = limit - (i+1+3+j.ToString().Length);\\n            StringBuilder sb = new ();\\n            sb.Append(message.Substring(off,Math.Min(strLen,message.Length-off)));\\n            off += strLen;\\n            sb.Append($\"<{j}/{segs}>\");\\n            res[j-1] = sb.ToString();\\n            \\n        }\\n        \\n        return res;\\n        \\n        }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public string[] SplitMessage(string message, int limit) {\\n        \\n        if(limit<6) return new string[0];\\n        \\n        //FIND SEGMENTS STEP BY STEP\\n        \\n        int n = message.Length;\\n        int t = n;\\n        int[] sufLen = new int[]{5,7,9,11};\\n        int[] ns = new int[]{9,90,900,9000};  //numb in segment ,9 90 900 9000 ...\\n        int[] offset = new int[]{1,10,100,1000};\\n        int[] presum = new int[]{9,99,999,9999};\\n        \\n        int i = 0;\\n        \\n        while(t>0)\\n        {            \\n            if((limit-sufLen[i])*ns[i]>=t)\\n                break;\\n            t = t - (limit-sufLen[i])*ns[i] + presum[i];\\n            i++; \\n            if(i>3)\\n                return new string[0];\\n        }\\n        \\n        int remin = (t+limit-sufLen[i]-1)/(limit-sufLen[i]);\\n         \\n        int segs = offset[i] + remin-1; \\n        int off = 0;\\n        string[] res = new string[segs];\\n        for(int j=1;j<=segs;j++)\\n        {\\n            int strLen = limit - (i+1+3+j.ToString().Length);\\n            StringBuilder sb = new ();\\n            sb.Append(message.Substring(off,Math.Min(strLen,message.Length-off)));\\n            off += strLen;\\n            sb.Append($\"<{j}/{segs}>\");\\n            res[j-1] = sb.ToString();\\n            \\n        }\\n        \\n        return res;\\n        \\n        }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2808086,
                "title": "c-binary-search-o-nlgn",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<string> splitMessage(string message, int limit) {\\n        int m = message.size();\\n        \\n        // search for minimum parts number\\n        int l = 1, r = m+1;\\n        while (l < r) {\\n            int mid = l + (r - l) / 2;\\n            if (check(mid, m, limit)) r = mid;\\n            else l = mid+1;\\n        }\\n        \\n        // parts = l\\n        vector<string> res;\\n        if (l == m+1) return res;\\n        \\n        // build result from parts\\n        int cur_index = 0;\\n        int parts_size = to_string(l).size();\\n        string parts_str = to_string(l);\\n        for (int p = 1; p <= l; p++) {\\n            int used = 2 + to_string(p).size() + 1 + parts_size;\\n            int rem = limit - used;\\n            \\n            string tmp = message.substr(cur_index, rem) + \"<\" + to_string(p) + \"/\" + parts_str + \">\";\\n            res.push_back(tmp);\\n            \\n            cur_index += rem;\\n        }\\n        \\n        return res;\\n    }\\n    \\n    bool check(int parts, int n, int limit) {\\n        int part = 0;\\n        int parts_size = to_string(parts).size();\\n        while (n > 0) {\\n            part++;\\n            int used = 2 + to_string(part).size() + 1 + parts_size;\\n            int rem = limit - used;\\n            \\n            if (rem <= 0) return false;\\n            n -= rem;\\n        }\\n        \\n        return part <= parts;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> splitMessage(string message, int limit) {\\n        int m = message.size();\\n        \\n        // search for minimum parts number\\n        int l = 1, r = m+1;\\n        while (l < r) {\\n            int mid = l + (r - l) / 2;\\n            if (check(mid, m, limit)) r = mid;\\n            else l = mid+1;\\n        }\\n        \\n        // parts = l\\n        vector<string> res;\\n        if (l == m+1) return res;\\n        \\n        // build result from parts\\n        int cur_index = 0;\\n        int parts_size = to_string(l).size();\\n        string parts_str = to_string(l);\\n        for (int p = 1; p <= l; p++) {\\n            int used = 2 + to_string(p).size() + 1 + parts_size;\\n            int rem = limit - used;\\n            \\n            string tmp = message.substr(cur_index, rem) + \"<\" + to_string(p) + \"/\" + parts_str + \">\";\\n            res.push_back(tmp);\\n            \\n            cur_index += rem;\\n        }\\n        \\n        return res;\\n    }\\n    \\n    bool check(int parts, int n, int limit) {\\n        int part = 0;\\n        int parts_size = to_string(parts).size();\\n        while (n > 0) {\\n            part++;\\n            int used = 2 + to_string(part).size() + 1 + parts_size;\\n            int rem = limit - used;\\n            \\n            if (rem <= 0) return false;\\n            n -= rem;\\n        }\\n        \\n        return part <= parts;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2808036,
                "title": "c-bruteforce-commented",
                "content": "Bruteforce solution - start at ```i  = 1``` and increment until ```i``` is a valid number of parts, or it is deemed impossible to split\\n```\\nclass Solution {\\npublic:\\n    vector<string> splitMessage(string message, int limit) {\\n        // if limit is <= 5, there is no room for characters (impossible)\\n        if (limit <= 5) return {};\\n        \\n        int i = 0,      // parts\\n            sum = 0;    // space taken up by suffixes (excluding b) [e.g \"<a/>\" * i]\\n            \\n        while (++i) {   // loop until minimum number of parts is found, or it is deemed impossible\\n            string d = to_string(i); // int -> string\\n            sum += 3 + size(d);      // update sum\\n            \\n            // if suffix leaves no room for other characters, it is impossible to split message\\n            if (size(d) * 2 + 3 > limit) return {}; // e.g. limit = 7 & suffix = \"<10/10>\" is impossible\\n            // if number of parts is valid, break (guaranteed to be optimal)\\n            // i.e. length of parts, after removing suffixes, is >= to length of message\\n            if (limit*i - sum - size(d)*i >= message.size()) break;\\n        }\\n        \\n        vector<string> res; // result vector\\n        string suf = \"/\" + to_string(i) + \">\"; // end of suffix (\"/b>\")\\n        int j = 0; // current index of message\\n        // we know how many parts there are, so we can just build our result\\n        for (int k=1; k<=i; ++k) {\\n            string suffix = \"<\" + to_string(k) + suf; // suffix\\n            int n = limit - size(suffix); // amount of characters before suffix\\n            res.push_back(message.substr(j, n) + suffix); // add to result\\n            j += n; // update message index\\n        }\\n        \\n        // done :D\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```i  = 1```\n```i```\n```\\nclass Solution {\\npublic:\\n    vector<string> splitMessage(string message, int limit) {\\n        // if limit is <= 5, there is no room for characters (impossible)\\n        if (limit <= 5) return {};\\n        \\n        int i = 0,      // parts\\n            sum = 0;    // space taken up by suffixes (excluding b) [e.g \"<a/>\" * i]\\n            \\n        while (++i) {   // loop until minimum number of parts is found, or it is deemed impossible\\n            string d = to_string(i); // int -> string\\n            sum += 3 + size(d);      // update sum\\n            \\n            // if suffix leaves no room for other characters, it is impossible to split message\\n            if (size(d) * 2 + 3 > limit) return {}; // e.g. limit = 7 & suffix = \"<10/10>\" is impossible\\n            // if number of parts is valid, break (guaranteed to be optimal)\\n            // i.e. length of parts, after removing suffixes, is >= to length of message\\n            if (limit*i - sum - size(d)*i >= message.size()) break;\\n        }\\n        \\n        vector<string> res; // result vector\\n        string suf = \"/\" + to_string(i) + \">\"; // end of suffix (\"/b>\")\\n        int j = 0; // current index of message\\n        // we know how many parts there are, so we can just build our result\\n        for (int k=1; k<=i; ++k) {\\n            string suffix = \"<\" + to_string(k) + suf; // suffix\\n            int n = limit - size(suffix); // amount of characters before suffix\\n            res.push_back(message.substr(j, n) + suffix); // add to result\\n            j += n; // update message index\\n        }\\n        \\n        // done :D\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2807958,
                "title": "brute-force-beginner-friendly-o-n",
                "content": "Welcome to leave comment and discuss, cheers :)\\n# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nBrute force to find from 1 to the possible parts number.\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<string> splitMessage(string message, int limit) {\\n        bool isPossible=limit>5;\\n        if(!isPossible) return {};      // Impossible \"<a|b>\" -> already 5\\n        \\n        int b=0, n_b=1;\\n        int n=message.size();\\n        int total=0;                    // total character counts of all parts\\n        while(total<n && isPossible){\\n            ++b;\\n            if(b==10) ++n_b;\\n            if(b==100) ++n_b;\\n            if(b==1000) ++n_b;\\n            if(b==10000) ++n_b;\\n\\n            isPossible=(limit-3-2*n_b)>0;\\n            if (!isPossible) return {};\\n\\n            total=b*limit;                          // Total length\\n            total-=3*b;                             // \"</>\"\\n            total-=2*b;                             // 1...9|9\\n            if(b>=10) total-=b+(b-9);               // 10...99|99\\n            if(b>=100) total-=b+(b-99);             // 100...999|999\\n            if(b>=1000) total-=b+(b-999);           // 1000...9999|9999\\n            if(b>=10000) total-=b+(b-9999);         // 10000...99999|99999\\n        }\\n        \\n        \\n        vector<string> ans;\\n        int a=1, n_a=1, n_message;\\n        int i=0;    // Index of message\\n        string suffix=\"/\";\\n        suffix+=to_string(b);\\n        suffix+=\">\";\\n\\n        while(i<n){\\n            if(a==10) ++n_a;\\n            if(a==100) ++n_a;\\n            if(a==1000) ++n_a;\\n            if(a==10000) ++n_a;\\n            n_message=limit-3-n_a-n_b;\\n            \\n            string tmp=message.substr(i, n_message);    // Cut message\\n            i+=n_message;\\n\\n            tmp+=\"<\";\\n            tmp+=to_string(a++);\\n            tmp+=suffix;\\n\\n            ans.push_back(tmp);\\n        }\\n        return ans;\\n    }\\n};\\n/*\\n:\\n    Brute Force to find b first.\\n    \\n# Idea\\n        \"<a/b>\" as each part suffix, \\n        a is the index start from 1, \\n        b is the total number of parts.\\n\\n    1. Count the entire message first\\n    2. \"<a/b>\" -> each part consist 3 + n_count(a) + n_count(b). // n_count() is digit counts.\\n    3. Brute force to find the target b (final total parts of messages)\\n        1. Start from 1\\n                                       a    |  b\\n        2. b < 10              --> 1...9    | x    -->    b + b   --> 2*b-0\\n        3. 10 < b < 100        --> 1...99   | xx   --> (b-9) + b  --> 2*b-9\\n        4. 100 < b < 1000      --> 1...999  | xxx  --> (b-99) + b --> 2*b-99\\n        5. 1000 < b < 10000    --> 1...9999 | xxxx --> (b-999) + b--> 2*b-999\\n\\nTC: O(N)\\nSC: O(1)\\n*/\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> splitMessage(string message, int limit) {\\n        bool isPossible=limit>5;\\n        if(!isPossible) return {};      // Impossible \"<a|b>\" -> already 5\\n        \\n        int b=0, n_b=1;\\n        int n=message.size();\\n        int total=0;                    // total character counts of all parts\\n        while(total<n && isPossible){\\n            ++b;\\n            if(b==10) ++n_b;\\n            if(b==100) ++n_b;\\n            if(b==1000) ++n_b;\\n            if(b==10000) ++n_b;\\n\\n            isPossible=(limit-3-2*n_b)>0;\\n            if (!isPossible) return {};\\n\\n            total=b*limit;                          // Total length\\n            total-=3*b;                             // \"</>\"\\n            total-=2*b;                             // 1...9|9\\n            if(b>=10) total-=b+(b-9);               // 10...99|99\\n            if(b>=100) total-=b+(b-99);             // 100...999|999\\n            if(b>=1000) total-=b+(b-999);           // 1000...9999|9999\\n            if(b>=10000) total-=b+(b-9999);         // 10000...99999|99999\\n        }\\n        \\n        \\n        vector<string> ans;\\n        int a=1, n_a=1, n_message;\\n        int i=0;    // Index of message\\n        string suffix=\"/\";\\n        suffix+=to_string(b);\\n        suffix+=\">\";\\n\\n        while(i<n){\\n            if(a==10) ++n_a;\\n            if(a==100) ++n_a;\\n            if(a==1000) ++n_a;\\n            if(a==10000) ++n_a;\\n            n_message=limit-3-n_a-n_b;\\n            \\n            string tmp=message.substr(i, n_message);    // Cut message\\n            i+=n_message;\\n\\n            tmp+=\"<\";\\n            tmp+=to_string(a++);\\n            tmp+=suffix;\\n\\n            ans.push_back(tmp);\\n        }\\n        return ans;\\n    }\\n};\\n/*\\n:\\n    Brute Force to find b first.\\n    \\n# Idea\\n        \"<a/b>\" as each part suffix, \\n        a is the index start from 1, \\n        b is the total number of parts.\\n\\n    1. Count the entire message first\\n    2. \"<a/b>\" -> each part consist 3 + n_count(a) + n_count(b). // n_count() is digit counts.\\n    3. Brute force to find the target b (final total parts of messages)\\n        1. Start from 1\\n                                       a    |  b\\n        2. b < 10              --> 1...9    | x    -->    b + b   --> 2*b-0\\n        3. 10 < b < 100        --> 1...99   | xx   --> (b-9) + b  --> 2*b-9\\n        4. 100 < b < 1000      --> 1...999  | xxx  --> (b-99) + b --> 2*b-99\\n        5. 1000 < b < 10000    --> 1...9999 | xxxx --> (b-999) + b--> 2*b-999\\n\\nTC: O(N)\\nSC: O(1)\\n*/\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2807956,
                "title": "c-concise-c-solution-with-explanation",
                "content": "Two approacehes will be discussed here. In my opinion, the idea is similar for both of them. But the latter will be more tricky.\\n\\nApproach 1: binary search\\nSuppose the length of each part is W, and we have M parts totally. What is the maximum length of a string following the problem? Perhaps, you can use something as following.\\nThe rest will be easy. We can determine W following a binary search approach, which will cost O(logN), where N is the length of the target string.\\n```\\nint count(int width, int cnt) {\\n\\twidth-=(int)log10(cnt)+1;\\n\\tif(cnt>=10000) {\\n\\t\\treturn (cnt-9999)*(width-8)+9000*(width-7)+900*(width-6)+90*(width-5)+9*(width-4);\\n\\t} else if(cnt>=1000) {\\n\\t\\treturn (cnt-999)*(width-7)+900*(width-6)+90*(width-5)+9*(width-4);\\n\\t} else if(cnt>=100) {\\n\\t\\treturn (cnt-99)*(width-6)+90*(width-5)+9*(width-4);\\n\\t} else if(cnt>=10) {\\n\\t\\treturn (cnt-9)*(width-5)+9*(width-4);\\n\\t} else {\\n\\t\\treturn cnt*(width-4);\\n\\t}\\n}\\n```\\n\\nApproach 2: Greedy\\nNext, we introduce anothre O(logN) or O(1) approach to determine the number of parts, M, which is much faster than the binary search approach aforementioned.\\nHere, we consider the number of digitals, K. In other words, we consider M from this array NUM={0, 9, 99, 999, 9999, 99999}. Suppose the length of each part is W. Let\\'s see the maximum length of the original string \\n\\n* If M is single digital, K=1, M<=9\\n```\\nPart 1~9:   \"######  <1/9>\"\\n```\\nThe maximum length is Len1=NUM[1]*(W-3-1-1);\\n\\n* If M is double digital, K=2, M<=99\\n```\\nPart 1~9:   \"#####  <1/99>\"\\nPart 10~99: \"####  <10/99>\"\\n```\\nCompared with K=1, the first NUM[1] parts takes one more space.\\nLen2=Len1-NUM[1]+(NUM[2]-NUM[1])*(W-3-2-2)\\n\\n* If M is triple digital, K=3, M<=999\\n```\\nPart 1~9:      \"####  <1/999>\"\\nPart 10~99:    \"###  <10/999>\"\\nPart 100~9999: \"##  <100/999>\"\\n```\\nCompared with K=2, the first NUM[2] parts takes one more space.\\nLen3=Len2-NUM[2]+(NUM[3]-NUM[2])*(W-3-3-3);\\n\\nWe can go on  to cover K=4, K=5 etc.\\n\\nSooner or later, we may found that K cannot increase due to the limitation of the width of each part. This is a failure. Or, LenK>=N. K is determined. It is relative easy to determine M with Len[K-1].\\n```\\nM=ceil(NUM[K-1] + (N+NUM[K-1]-Len[K-1])/(W-3-K-K))\\n```\\nEven for the worst case, it takes no more than 5 steps, which is almost O(1).\\n\\nThe following is an example of C++ codes.\\n\\n```\\nconst int num [] ={0, 9, 99, 999, 9999, 99999};\\nclass Solution {\\npublic:\\n    vector<string> splitMessage(string message, int limit) {\\n        ios::sync_with_stdio(false);\\n        cin.tie(nullptr);\\n        int n=message.size(), m=0, k=1;\\n        if(n+5<=limit) {\\n            return {message+\"<1/1>\"};\\n        }\\n        for(int M=9*(limit-5); M<n; ) {\\n            ++k;\\n            if(k+k+3>limit) {\\n                return {};\\n            }\\n            m=M;\\n            M+=(num[k]-num[k-1])*(limit-3-k-k)-num[k-1];\\n        }\\n        m=num[k-1]+(n+num[k-1]-m+limit-4-k-k)/(limit-3-k-k);\\n        vector<string> ans;\\n        string tot=to_string(m);\\n        for(int i=0, j=0, l; i<m; ++i) {\\n            string idx=to_string(i+1);\\n            l=min(n-j, limit-4-k-(int)log10(i+1));            \\n            ans.push_back(message.substr(j,l)+\\'<\\'+idx+\\'/\\'+tot+\\'>\\');\\n            j+=l;\\n        }\\n        return ans;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "Greedy"
                ],
                "code": "```\\nint count(int width, int cnt) {\\n\\twidth-=(int)log10(cnt)+1;\\n\\tif(cnt>=10000) {\\n\\t\\treturn (cnt-9999)*(width-8)+9000*(width-7)+900*(width-6)+90*(width-5)+9*(width-4);\\n\\t} else if(cnt>=1000) {\\n\\t\\treturn (cnt-999)*(width-7)+900*(width-6)+90*(width-5)+9*(width-4);\\n\\t} else if(cnt>=100) {\\n\\t\\treturn (cnt-99)*(width-6)+90*(width-5)+9*(width-4);\\n\\t} else if(cnt>=10) {\\n\\t\\treturn (cnt-9)*(width-5)+9*(width-4);\\n\\t} else {\\n\\t\\treturn cnt*(width-4);\\n\\t}\\n}\\n```\n```\\nPart 1~9:   \"######  <1/9>\"\\n```\n```\\nPart 1~9:   \"#####  <1/99>\"\\nPart 10~99: \"####  <10/99>\"\\n```\n```\\nPart 1~9:      \"####  <1/999>\"\\nPart 10~99:    \"###  <10/999>\"\\nPart 100~9999: \"##  <100/999>\"\\n```\n```\\nM=ceil(NUM[K-1] + (N+NUM[K-1]-Len[K-1])/(W-3-K-K))\\n```\n```\\nconst int num [] ={0, 9, 99, 999, 9999, 99999};\\nclass Solution {\\npublic:\\n    vector<string> splitMessage(string message, int limit) {\\n        ios::sync_with_stdio(false);\\n        cin.tie(nullptr);\\n        int n=message.size(), m=0, k=1;\\n        if(n+5<=limit) {\\n            return {message+\"<1/1>\"};\\n        }\\n        for(int M=9*(limit-5); M<n; ) {\\n            ++k;\\n            if(k+k+3>limit) {\\n                return {};\\n            }\\n            m=M;\\n            M+=(num[k]-num[k-1])*(limit-3-k-k)-num[k-1];\\n        }\\n        m=num[k-1]+(n+num[k-1]-m+limit-4-k-k)/(limit-3-k-k);\\n        vector<string> ans;\\n        string tot=to_string(m);\\n        for(int i=0, j=0, l; i<m; ++i) {\\n            string idx=to_string(i+1);\\n            l=min(n-j, limit-4-k-(int)log10(i+1));            \\n            ans.push_back(message.substr(j,l)+\\'<\\'+idx+\\'/\\'+tot+\\'>\\');\\n            j+=l;\\n        }\\n        return ans;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2807907,
                "title": "python-answer-greedy-buffer-and-special-character",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nGreedy Just add chunks until the length equals to limit\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nJust build up a buffer and add values to the buffer until the length reaches the limit with a special character for buffer.\\n\\nIf the length is too big, return an empty array.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(message)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(message)\\n\\n# Code\\n```\\nclass Solution:\\n    def splitMessage(self, message: str, limit: int) -> List[str]:\\n        \\n        \\n        def buildnum(start,total):\\n            \\n            return f\\'<{start}/{total}>\\'\\n            \\n        output = []\\n        \\n        if limit-5 <= 0:\\n            return []\\n        else:\\n            total = ceil(len(message) / (limit-3-2))\\n        \\n        total = \\'&\\'* len(str(total))\\n        \\n        buff = []\\n\\n        count = 1\\n\\n        for i,c in enumerate(message):\\n\\n            buff.append(c)\\n\\n            if len(buff) + len(buildnum(count,total)) == limit:\\n\\n                output.append( \\'\\'.join(buff) + buildnum(count,total) )    \\n                buff = []\\n                count += 1\\n            elif len(buff) + len(buildnum(count,total)) > limit :\\n                return []\\n                \\n        if len(buff) > 0:\\n            output.append( \\'\\'.join(buff) + buildnum(count,total) )    \\n            count += 1\\n        \\n        count -= 1\\n        \\n        output = [s.replace(total,str(count)) for s in output]\\n        return output\\n\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def splitMessage(self, message: str, limit: int) -> List[str]:\\n        \\n        \\n        def buildnum(start,total):\\n            \\n            return f\\'<{start}/{total}>\\'\\n            \\n        output = []\\n        \\n        if limit-5 <= 0:\\n            return []\\n        else:\\n            total = ceil(len(message) / (limit-3-2))\\n        \\n        total = \\'&\\'* len(str(total))\\n        \\n        buff = []\\n\\n        count = 1\\n\\n        for i,c in enumerate(message):\\n\\n            buff.append(c)\\n\\n            if len(buff) + len(buildnum(count,total)) == limit:\\n\\n                output.append( \\'\\'.join(buff) + buildnum(count,total) )    \\n                buff = []\\n                count += 1\\n            elif len(buff) + len(buildnum(count,total)) > limit :\\n                return []\\n                \\n        if len(buff) > 0:\\n            output.append( \\'\\'.join(buff) + buildnum(count,total) )    \\n            count += 1\\n        \\n        count -= 1\\n        \\n        output = [s.replace(total,str(count)) for s in output]\\n        return output\\n\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2807817,
                "title": "dp-path-reconstruction",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    vector<string> splitMessage(string message, int limit) {\\n        // this problem is dp + path reconstruction\\n        int n = message.size();\\n        int LOG = floor(log10(n)) + 1;\\n        \\n        int memo[n+2][LOG+1];\\n        memset(memo, -1, sizeof memo);\\n        \\n        function<int(int,int,int)> solve = [&](int i, int j, int k) {\\n            // i = current part\\n            // j = length of the string considered\\n            // k = length of the number of parts\\n            if(j == n) return memo[i][k] = 0;\\n            if(memo[i][k] != -1) return memo[i][k];\\n            \\n            // find the length of the suffix\\n            int suff_len = 1 + (to_string(i)).size() + 1 + k + 1;\\n            \\n            if(suff_len >= limit) return memo[i][k] = -1;\\n            \\n            // length of the prefix\\n            int pref_len = min(n-j, limit-suff_len);\\n            \\n            int val = solve(i+1, j+pref_len, k);\\n            \\n            if(val != -1) return memo[i][k] = val + 1;\\n            \\n            return memo[i][k] = -1;\\n        };\\n        \\n        int minlen = INT_MAX;\\n        \\n        for(int i=1; i<=LOG; i++) {\\n            int temp = solve(1, 0, i);\\n            if(temp == -1) continue;\\n            \\n            if((to_string(temp)).size() == i) {\\n                minlen = min(minlen, temp);\\n            }\\n        }\\n        \\n        if(minlen == INT_MAX) return {};\\n        \\n        // path reconstruction using the memo table\\n        for(int len=1; len<=LOG; len++) {\\n            int temp = solve(1, 0, len);\\n            if(temp == -1) continue;\\n            \\n            if((to_string(temp)).size() == len and temp == minlen) {\\n                vector<string> result;\\n                \\n                int j = 0;\\n                \\n                for(int i=1; i<=temp; i++) {\\n                    int tem = 3 + len + ((to_string(i)).size());\\n                    int rem = min(n-j, limit-tem);\\n                    \\n                    string str = \"\";\\n                    \\n                    for(int k=0; k<rem; k++) {\\n                        str.push_back(message[j++]);\\n                    }\\n                    \\n                    str += \"<\" + to_string(i) + \"/\" + to_string(temp) + \">\";\\n                    \\n                    result.push_back(str);\\n                }\\n                \\n                return result;\\n            }\\n        }\\n        \\n        return {};\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> splitMessage(string message, int limit) {\\n        // this problem is dp + path reconstruction\\n        int n = message.size();\\n        int LOG = floor(log10(n)) + 1;\\n        \\n        int memo[n+2][LOG+1];\\n        memset(memo, -1, sizeof memo);\\n        \\n        function<int(int,int,int)> solve = [&](int i, int j, int k) {\\n            // i = current part\\n            // j = length of the string considered\\n            // k = length of the number of parts\\n            if(j == n) return memo[i][k] = 0;\\n            if(memo[i][k] != -1) return memo[i][k];\\n            \\n            // find the length of the suffix\\n            int suff_len = 1 + (to_string(i)).size() + 1 + k + 1;\\n            \\n            if(suff_len >= limit) return memo[i][k] = -1;\\n            \\n            // length of the prefix\\n            int pref_len = min(n-j, limit-suff_len);\\n            \\n            int val = solve(i+1, j+pref_len, k);\\n            \\n            if(val != -1) return memo[i][k] = val + 1;\\n            \\n            return memo[i][k] = -1;\\n        };\\n        \\n        int minlen = INT_MAX;\\n        \\n        for(int i=1; i<=LOG; i++) {\\n            int temp = solve(1, 0, i);\\n            if(temp == -1) continue;\\n            \\n            if((to_string(temp)).size() == i) {\\n                minlen = min(minlen, temp);\\n            }\\n        }\\n        \\n        if(minlen == INT_MAX) return {};\\n        \\n        // path reconstruction using the memo table\\n        for(int len=1; len<=LOG; len++) {\\n            int temp = solve(1, 0, len);\\n            if(temp == -1) continue;\\n            \\n            if((to_string(temp)).size() == len and temp == minlen) {\\n                vector<string> result;\\n                \\n                int j = 0;\\n                \\n                for(int i=1; i<=temp; i++) {\\n                    int tem = 3 + len + ((to_string(i)).size());\\n                    int rem = min(n-j, limit-tem);\\n                    \\n                    string str = \"\";\\n                    \\n                    for(int k=0; k<rem; k++) {\\n                        str.push_back(message[j++]);\\n                    }\\n                    \\n                    str += \"<\" + to_string(i) + \"/\" + to_string(temp) + \">\";\\n                    \\n                    result.push_back(str);\\n                }\\n                \\n                return result;\\n            }\\n        }\\n        \\n        return {};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2807809,
                "title": "python-3-binary-search",
                "content": "```\\nclass Solution:\\n    def splitMessage(self, message: str, limit: int) -> List[str]:\\n        n = len(message)\\n        \\n        l, h = 1, n\\n        \\n        def bs(x):\\n            dl = 3 + len(str(x))\\n            n = len(message)\\n            for i in range(1, x+1):\\n                k = limit - dl - len(str(i))\\n                if k <= 0: return False\\n                n -= k\\n                if n <= 0: return True\\n            return False\\n        \\n        while l < h:\\n            mid = l + (h - l) // 2\\n            if bs(mid):\\n                h = mid\\n            else:\\n                l = mid + 1\\n        \\n        \\n        dl = 3 + len(str(l))\\n        n = len(message)\\n        j = 0\\n        ans = []\\n        for i in range(1, l+1):\\n            k = limit - dl - len(str(i))\\n            if k <= 0: return []\\n            tmp = message[j:j+k] + f\"<{i}/{l}>\"\\n            ans.append(tmp)\\n            j += k\\n            \\n            \\n        return ans",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Binary Tree"
                ],
                "code": "class Solution:\\n    def splitMessage(self, message: str, limit: int) -> List[str]:\\n        n = len(message)\\n        \\n        l, h = 1, n\\n        \\n        def bs(x):\\n            dl = 3 + len(str(x))\\n            n = len(message)\\n            for i in range(1, x+1):\\n                k = limit - dl - len(str(i))\\n                if k <= 0: return False\\n                n -= k\\n                if n <= 0: return True\\n            return False\\n        \\n        while l < h:\\n            mid = l + (h - l) // 2\\n            if bs(mid):\\n                h = mid\\n            else:\\n                l = mid + 1\\n        \\n        \\n        dl = 3 + len(str(l))\\n        n = len(message)\\n        j = 0\\n        ans = []\\n        for i in range(1, l+1):\\n            k = limit - dl - len(str(i))\\n            if k <= 0: return []\\n            tmp = message[j:j+k] + f\"<{i}",
                "codeTag": "Java"
            },
            {
                "id": 2807805,
                "title": "c-solution-optimised-bruteforce",
                "content": "here we are trying to check if how many segments strings can have\\n```\\nclass Solution {\\npublic:\\n    vector<string> splitMessage(string message, int limit) {\\n        vector<string> result;\\n        int n = message.size();\\n        int suffixLen = 3; // without digits\\n        int maxSegment = 0; // maxSegments for curr no of digits\\n        int extraDigits = 0; // Note: previous segments had one less digits and while counting available digits we need to add these extra digits\\n        // i.e. we can fit extra chars in 1-9 segment for segments in range 1-99\\n        int digit = 1;\\n        while(digit < 5){\\n            suffixLen += 2; // add new digits\\n            if(limit <= suffixLen)\\n                return result;\\n            maxSegment = maxSegment*10+9;\\n            // check if string can be fit in given digit segment length\\n            if(limit*maxSegment + extraDigits - suffixLen*maxSegment >= n) \\n            {\\n                int pos = 0;\\n                int seg = 1;\\n                string suffix = \"/\"+ to_string(maxSegment)+ \">\";\\n                while(pos<n) {\\n                    string temp = \"<\"+to_string(seg)+suffix;\\n                    int r = limit - temp.size();\\n                    temp = message.substr(pos,r)+ temp;\\n                    result.push_back(temp);\\n                    pos +=r;\\n                    ++seg;\\n                }\\n                // replace total segment with exact numbers\\n                string s = to_string(--seg);\\n                for(auto& r:result)\\n                    r.replace(r.size()-(digit+1),digit,s);\\n\\n                return result;\\n            }\\n            extraDigits += maxSegment;\\n            ++digit;\\n        }\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> splitMessage(string message, int limit) {\\n        vector<string> result;\\n        int n = message.size();\\n        int suffixLen = 3; // without digits\\n        int maxSegment = 0; // maxSegments for curr no of digits\\n        int extraDigits = 0; // Note: previous segments had one less digits and while counting available digits we need to add these extra digits\\n        // i.e. we can fit extra chars in 1-9 segment for segments in range 1-99\\n        int digit = 1;\\n        while(digit < 5){\\n            suffixLen += 2; // add new digits\\n            if(limit <= suffixLen)\\n                return result;\\n            maxSegment = maxSegment*10+9;\\n            // check if string can be fit in given digit segment length\\n            if(limit*maxSegment + extraDigits - suffixLen*maxSegment >= n) \\n            {\\n                int pos = 0;\\n                int seg = 1;\\n                string suffix = \"/\"+ to_string(maxSegment)+ \">\";\\n                while(pos<n) {\\n                    string temp = \"<\"+to_string(seg)+suffix;\\n                    int r = limit - temp.size();\\n                    temp = message.substr(pos,r)+ temp;\\n                    result.push_back(temp);\\n                    pos +=r;\\n                    ++seg;\\n                }\\n                // replace total segment with exact numbers\\n                string s = to_string(--seg);\\n                for(auto& r:result)\\n                    r.replace(r.size()-(digit+1),digit,s);\\n\\n                return result;\\n            }\\n            extraDigits += maxSegment;\\n            ++digit;\\n        }\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2807758,
                "title": "c-binary-search-o-nlogn",
                "content": "```\\nclass Solution {\\npublic:\\n    int countDigits(int n){\\n        int count = 0;\\n        while(n != 0){\\n            count++;\\n            n /= 10;\\n        }\\n        return count;\\n    }\\n    bool isPossible(string message, int limit, int parts){\\n        int totalParts = 0;\\n        int ind = 0;\\n        int n = message.size();\\n        int count = countDigits(parts);\\n        \\n        while(ind < n){\\n            totalParts++;\\n            int remainingChar = limit - 3 - count - countDigits(totalParts);\\n            if(remainingChar <= 0){\\n                return false;\\n            }\\n            else{\\n                ind += remainingChar;\\n            }\\n        }\\n        \\n        return (totalParts <= parts);\\n        \\n    }\\n    vector<string> splitMessage(string message, int limit) {\\n        int n = message.size();\\n        int left = 1, right = n;\\n        int res = -1;\\n        \\n        while(left <= right){\\n            int mid = (left + right) / 2;\\n            \\n            if(isPossible(message, limit, mid)){\\n                res = mid;\\n                right = mid - 1;\\n            }\\n            else    left = mid + 1;\\n        }\\n        \\n        \\n        int parts = res;\\n        \\n        if(parts == -1){\\n            return {};\\n        }\\n        \\n        vector<string> ans;\\n        int ind = 0;\\n        int currpart = 0;\\n        int count = countDigits(parts);\\n        \\n        while(ind < n){\\n            currpart++;\\n            int remainingChar = limit - 3 - count - countDigits(currpart);\\n            \\n            if(n - ind < remainingChar){\\n                remainingChar = n - ind;\\n            }\\n            \\n            string str = message.substr(ind, remainingChar) + \"<\" + to_string(currpart) + \"/\" + to_string(parts) + \">\";\\n            ans.push_back(str);\\n            \\n            ind += remainingChar;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countDigits(int n){\\n        int count = 0;\\n        while(n != 0){\\n            count++;\\n            n /= 10;\\n        }\\n        return count;\\n    }\\n    bool isPossible(string message, int limit, int parts){\\n        int totalParts = 0;\\n        int ind = 0;\\n        int n = message.size();\\n        int count = countDigits(parts);\\n        \\n        while(ind < n){\\n            totalParts++;\\n            int remainingChar = limit - 3 - count - countDigits(totalParts);\\n            if(remainingChar <= 0){\\n                return false;\\n            }\\n            else{\\n                ind += remainingChar;\\n            }\\n        }\\n        \\n        return (totalParts <= parts);\\n        \\n    }\\n    vector<string> splitMessage(string message, int limit) {\\n        int n = message.size();\\n        int left = 1, right = n;\\n        int res = -1;\\n        \\n        while(left <= right){\\n            int mid = (left + right) / 2;\\n            \\n            if(isPossible(message, limit, mid)){\\n                res = mid;\\n                right = mid - 1;\\n            }\\n            else    left = mid + 1;\\n        }\\n        \\n        \\n        int parts = res;\\n        \\n        if(parts == -1){\\n            return {};\\n        }\\n        \\n        vector<string> ans;\\n        int ind = 0;\\n        int currpart = 0;\\n        int count = countDigits(parts);\\n        \\n        while(ind < n){\\n            currpart++;\\n            int remainingChar = limit - 3 - count - countDigits(currpart);\\n            \\n            if(n - ind < remainingChar){\\n                remainingChar = n - ind;\\n            }\\n            \\n            string str = message.substr(ind, remainingChar) + \"<\" + to_string(currpart) + \"/\" + to_string(parts) + \">\";\\n            ans.push_back(str);\\n            \\n            ind += remainingChar;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2807698,
                "title": "only-four-cases",
                "content": "# Intuition\\nThe uppper of total number only can be one of `[9, 99, 999, 9999]`. So we can try every `numberLength(1,2,3,4)` and find the total number of the parts\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(N)\\n\\n- Space complexity: O(N)\\n\\n# Code\\n```\\nfunction splitMessage(message: string, limit: number): string[] {\\n  const list = [9, 99, 999, 9999]\\n  for (const upper of list) {\\n    let { length } = message\\n    for (let i = 1; i <= upper; i++) {\\n      let charLen = (limit - 3 - i.toString().length - upper.toString().length)\\n      if (charLen < 0) {\\n        break\\n      }\\n      length -= charLen\\n      if (length <= 0) {\\n        let index = 0\\n        const result: string[] = []\\n        for (let j = 1; j <= i; j++) {\\n          charLen = (limit - 3 - j.toString().length - upper.toString().length)\\n          let current = \\'\\'\\n          for (let k = index; k < Math.min(charLen + index, message.length); k++) {\\n            current += message[k]\\n          }\\n          result.push(`${current}<${j}/${i}>`)\\n          index += charLen\\n        }\\n        return result\\n      }\\n    }\\n  }\\n  return []\\n}\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\nfunction splitMessage(message: string, limit: number): string[] {\\n  const list = [9, 99, 999, 9999]\\n  for (const upper of list) {\\n    let { length } = message\\n    for (let i = 1; i <= upper; i++) {\\n      let charLen = (limit - 3 - i.toString().length - upper.toString().length)\\n      if (charLen < 0) {\\n        break\\n      }\\n      length -= charLen\\n      if (length <= 0) {\\n        let index = 0\\n        const result: string[] = []\\n        for (let j = 1; j <= i; j++) {\\n          charLen = (limit - 3 - j.toString().length - upper.toString().length)\\n          let current = \\'\\'\\n          for (let k = index; k < Math.min(charLen + index, message.length); k++) {\\n            current += message[k]\\n          }\\n          result.push(`${current}<${j}/${i}>`)\\n          index += charLen\\n        }\\n        return result\\n      }\\n    }\\n  }\\n  return []\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2807684,
                "title": "find-the-number-of-parts",
                "content": "# Code\\n```\\npublic class Solution\\n{\\n    public string[] SplitMessage(string message, int limit)\\n    {\\n        int n = message.Length;\\n\\n        int m = n;\\n        int digits = CountDigits(m);\\n        int digit;\\n\\n        long sum;\\n        long x;\\n        for (m = n; m > 0; m--)\\n        {\\n            digit = CountDigit(m);\\n            digits -= digit;\\n\\n            sum = 3 * (m - 1) + digits + (long)digit * (m - 1);\\n            x = n + sum - (m - 1) * limit;\\n\\n            if (x > 0)\\n            {\\n                x += 3 + 2 * digit;\\n                if (x <= limit)\\n                {\\n                    break;\\n                }\\n            }\\n        }\\n\\n        if (m == 0)\\n        {\\n            return Array.Empty<string>();\\n        }\\n\\n        var result = new List<string>();\\n\\n        var sb = new StringBuilder();\\n\\n        int j = 0;\\n        string suffix;\\n        int length;\\n        for (int i = 1; i <= m; i++)\\n        {\\n            suffix = $\"<{i}/{m}>\";\\n            length = limit - suffix.Length;\\n\\n            sb.Append(message.Substring(j, Math.Min(n - j, length)));\\n            sb.Append(suffix);\\n\\n            j += length;\\n\\n            result.Add(sb.ToString());\\n            sb.Clear();\\n        }\\n\\n        return result.ToArray();\\n    }\\n\\n    private int CountDigits(int right)\\n    {\\n        int count = 0;\\n\\n        int start = 1;\\n        int end = 10 * start - 1;\\n        int length = 1;\\n\\n        int min;\\n        while (start <= right)\\n        {\\n            min = Math.Min(right, end);\\n\\n            count += length * (min - start + 1);\\n\\n            start *= 10;\\n            end = 10 * start - 1;\\n            length++;\\n        }\\n\\n        return count;\\n    }\\n\\n    private int CountDigit(int x)\\n    {\\n        int count = 0;\\n\\n        while (x > 0)\\n        {\\n            count++;\\n            x /= 10;\\n        }\\n\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution\\n{\\n    public string[] SplitMessage(string message, int limit)\\n    {\\n        int n = message.Length;\\n\\n        int m = n;\\n        int digits = CountDigits(m);\\n        int digit;\\n\\n        long sum;\\n        long x;\\n        for (m = n; m > 0; m--)\\n        {\\n            digit = CountDigit(m);\\n            digits -= digit;\\n\\n            sum = 3 * (m - 1) + digits + (long)digit * (m - 1);\\n            x = n + sum - (m - 1) * limit;\\n\\n            if (x > 0)\\n            {\\n                x += 3 + 2 * digit;\\n                if (x <= limit)\\n                {\\n                    break;\\n                }\\n            }\\n        }\\n\\n        if (m == 0)\\n        {\\n            return Array.Empty<string>();\\n        }\\n\\n        var result = new List<string>();\\n\\n        var sb = new StringBuilder();\\n\\n        int j = 0;\\n        string suffix;\\n        int length;\\n        for (int i = 1; i <= m; i++)\\n        {\\n            suffix = $\"<{i}/{m}>\";\\n            length = limit - suffix.Length;\\n\\n            sb.Append(message.Substring(j, Math.Min(n - j, length)));\\n            sb.Append(suffix);\\n\\n            j += length;\\n\\n            result.Add(sb.ToString());\\n            sb.Clear();\\n        }\\n\\n        return result.ToArray();\\n    }\\n\\n    private int CountDigits(int right)\\n    {\\n        int count = 0;\\n\\n        int start = 1;\\n        int end = 10 * start - 1;\\n        int length = 1;\\n\\n        int min;\\n        while (start <= right)\\n        {\\n            min = Math.Min(right, end);\\n\\n            count += length * (min - start + 1);\\n\\n            start *= 10;\\n            end = 10 * start - 1;\\n            length++;\\n        }\\n\\n        return count;\\n    }\\n\\n    private int CountDigit(int x)\\n    {\\n        int count = 0;\\n\\n        while (x > 0)\\n        {\\n            count++;\\n            x /= 10;\\n        }\\n\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2807637,
                "title": "video-explanation-with-intuitions",
                "content": "https://www.youtube.com/watch?v=KB-ReEdu7_Y\\n\\n[Click here if the preview doesn\\'t work](https://www.youtube.com/watch?v=KB-ReEdu7_Y)",
                "solutionTags": [
                    "C++"
                ],
                "code": "https://www.youtube.com/watch?v=KB-ReEdu7_Y\\n\\n[Click here if the preview doesn\\'t work](https://www.youtube.com/watch?v=KB-ReEdu7_Y)",
                "codeTag": "Unknown"
            },
            {
                "id": 2807619,
                "title": "c-easy-implementation",
                "content": "```\\nclass Solution {\\npublic:\\n    int getLength(int i){\\n        int ans = 0;\\n        while(i){\\n            i /= 10;\\n            ans++;\\n        }\\n        return ans;\\n    }\\n    \\n    int checkMaxSize(int limit, int fixed){\\n        if(limit<=5) return 0;\\n        int mul = 9;\\n        int ans = 0;\\n        int n = 1;\\n        int dec = 3 + n + fixed;\\n        while(limit - dec > 0 && n<=fixed){\\n            ans += mul*(limit - dec++);\\n            n++;\\n            mul *= 10;\\n        }\\n        return ans;\\n    }\\n    \\n    vector<string> splitMessage(string message, int limit) {\\n        int msize = message.size();\\n        int den = 1;\\n        int maxsize = checkMaxSize(limit, den);\\n        int maxm = maxsize;\\n        while(maxsize<msize && den<limit-4){\\n            maxsize = checkMaxSize(limit, ++den);\\n            maxm = max(maxsize, maxm);\\n        }\\n        \\n        if(maxm<msize) return {};\\n        \\n        vector<string> ans; int idx = 0;\\n        for(int i=1; i<=maxsize && idx<msize; i++){\\n            string temp;\\n            int cut = getLength(i) + 3 + den;\\n            int tlen = limit - cut;\\n            for(int j=0; j<tlen; j++){\\n                temp.push_back(message[idx++]);\\n            }\\n            temp.push_back(\\'<\\');\\n            string numerator = to_string(i);\\n            for(char c : numerator) temp.push_back(c);\\n            temp.push_back(\\'/\\');\\n            for(int k=0; k<den; k++) temp.push_back(\\'#\\');\\n            temp.push_back(\\'>\\');\\n            ans.push_back(temp);\\n            //cout << temp << endl;\\n        }\\n\\n        string denominator = to_string(ans.size());\\n        for(string &str : ans){\\n            int i = 0;\\n            for(char &c : str){\\n                if(c==\\'#\\'){\\n                    c = denominator[i++];\\n                }\\n            }\\n            //cout << str << endl;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int getLength(int i){\\n        int ans = 0;\\n        while(i){\\n            i /= 10;\\n            ans++;\\n        }\\n        return ans;\\n    }\\n    \\n    int checkMaxSize(int limit, int fixed){\\n        if(limit<=5) return 0;\\n        int mul = 9;\\n        int ans = 0;\\n        int n = 1;\\n        int dec = 3 + n + fixed;\\n        while(limit - dec > 0 && n<=fixed){\\n            ans += mul*(limit - dec++);\\n            n++;\\n            mul *= 10;\\n        }\\n        return ans;\\n    }\\n    \\n    vector<string> splitMessage(string message, int limit) {\\n        int msize = message.size();\\n        int den = 1;\\n        int maxsize = checkMaxSize(limit, den);\\n        int maxm = maxsize;\\n        while(maxsize<msize && den<limit-4){\\n            maxsize = checkMaxSize(limit, ++den);\\n            maxm = max(maxsize, maxm);\\n        }\\n        \\n        if(maxm<msize) return {};\\n        \\n        vector<string> ans; int idx = 0;\\n        for(int i=1; i<=maxsize && idx<msize; i++){\\n            string temp;\\n            int cut = getLength(i) + 3 + den;\\n            int tlen = limit - cut;\\n            for(int j=0; j<tlen; j++){\\n                temp.push_back(message[idx++]);\\n            }\\n            temp.push_back(\\'<\\');\\n            string numerator = to_string(i);\\n            for(char c : numerator) temp.push_back(c);\\n            temp.push_back(\\'/\\');\\n            for(int k=0; k<den; k++) temp.push_back(\\'#\\');\\n            temp.push_back(\\'>\\');\\n            ans.push_back(temp);\\n            //cout << temp << endl;\\n        }\\n\\n        string denominator = to_string(ans.size());\\n        for(string &str : ans){\\n            int i = 0;\\n            for(char &c : str){\\n                if(c==\\'#\\'){\\n                    c = denominator[i++];\\n                }\\n            }\\n            //cout << str << endl;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2807579,
                "title": "c-binary-search-easy-implementation-video-solution-prashar32",
                "content": "Myself Adarsh Prashar\\n\\n**I am top 0.02% (Globally) Candidate Master(2048) at Codeforces, Guardian (top 0.8%) at Leetcode and 6 Star (2208) at Codechef**\\n\\n**About Me -** I have a youtube channel in which I upload editorials of leetcode, codeforces and codechef contest.\\n\\nYou can understand my method to solve that.\\n\\n**Split Message Based on Limit (Video Editorial Link) -** https://youtu.be/t98PMWpd-yU\\n**My channel Link -** https://www.youtube.com/@prashar32\\n\\n**If you like my video kindly like share and subscribe to my channel**",
                "solutionTags": [
                    "Binary Tree"
                ],
                "code": "Myself Adarsh Prashar\\n\\n**I am top 0.02% (Globally) Candidate Master(2048) at Codeforces, Guardian (top 0.8%) at Leetcode and 6 Star (2208) at Codechef**\\n\\n**About Me -** I have a youtube channel in which I upload editorials of leetcode, codeforces and codechef contest.\\n\\nYou can understand my method to solve that.\\n\\n**Split Message Based on Limit (Video Editorial Link) -** https://youtu.be/t98PMWpd-yU\\n**My channel Link -** https://www.youtube.com/@prashar32\\n\\n**If you like my video kindly like share and subscribe to my channel**",
                "codeTag": "Unknown"
            },
            {
                "id": 2807526,
                "title": "c-recursive-precomputed-length-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<pair<int,int>> dp;\\n    bool recursion(int i,int a,int b,int size,int limit,int n){\\n        if(i>=n){\\n            return true;\\n        }\\n        if(to_string(size).size()>b){\\n            return false;\\n        }\\n        int aL=to_string(a).size();\\n        int bL=b;\\n        int l=limit-3-aL-bL;\\n        if(l<0){\\n            \\n            return false;\\n        }\\n        if(i+l>=n){\\n            dp.push_back({i,n-1});\\n            \\n            if(to_string(dp.size()).size()!=b){\\n                dp.pop_back();\\n                return false;\\n            }\\n            \\n            return true;\\n        }\\n        //cout<<i<<\"=>\"<<l+i<<endl;\\n        dp.push_back({i,l+i-1});\\n        bool got=recursion(i+l,a+1,b,size+1,limit,n);\\n        if(!got){\\n            dp.pop_back();\\n        }\\n        return got;\\n        \\n    }\\n    vector<string> splitMessage(string msg, int limit) {\\n        int n=msg.size();\\n        vector<string> ans;\\n        string str=\"\";\\n        for(int i=0;i<n;i++){\\n            dp.push_back({0,i});\\n            int b=limit-3-1-i-1;\\n            //cout<<i+1<<\" \"<<b<<endl;\\n            if(b<=0){\\n                dp.pop_back();\\n                break;;\\n            }\\n            if(i>=n){\\n                if(to_string(dp.size()).size()!=b){\\n                    dp.pop_back();\\n                }\\n                break;\\n            }\\n            bool res=recursion(i+1,2,b,1,limit,n);\\n            if(!res){\\n                dp.pop_back();\\n            }\\n            if(res){\\n                break;\\n            }\\n        }\\n        \\n        if(dp.size()<=0){\\n            return {};\\n        }\\n        for(int i=0;i<dp.size();i++){\\n            int a=dp[i].first;\\n            int b=dp[i].second;\\n            string str=\"\";\\n            for(int k=a;k<=b;k++){\\n                str+=msg[k];\\n            }\\n            str+=\\'<\\';\\n            str+=to_string(i+1);\\n            str+=\\'/\\';\\n            str+=to_string(int(dp.size()));\\n            str+=\\'>\\';\\n            ans.push_back(str);\\n            //cout<<str.size()<<\" \";\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<pair<int,int>> dp;\\n    bool recursion(int i,int a,int b,int size,int limit,int n){\\n        if(i>=n){\\n            return true;\\n        }\\n        if(to_string(size).size()>b){\\n            return false;\\n        }\\n        int aL=to_string(a).size();\\n        int bL=b;\\n        int l=limit-3-aL-bL;\\n        if(l<0){\\n            \\n            return false;\\n        }\\n        if(i+l>=n){\\n            dp.push_back({i,n-1});\\n            \\n            if(to_string(dp.size()).size()!=b){\\n                dp.pop_back();\\n                return false;\\n            }\\n            \\n            return true;\\n        }\\n        //cout<<i<<\"=>\"<<l+i<<endl;\\n        dp.push_back({i,l+i-1});\\n        bool got=recursion(i+l,a+1,b,size+1,limit,n);\\n        if(!got){\\n            dp.pop_back();\\n        }\\n        return got;\\n        \\n    }\\n    vector<string> splitMessage(string msg, int limit) {\\n        int n=msg.size();\\n        vector<string> ans;\\n        string str=\"\";\\n        for(int i=0;i<n;i++){\\n            dp.push_back({0,i});\\n            int b=limit-3-1-i-1;\\n            //cout<<i+1<<\" \"<<b<<endl;\\n            if(b<=0){\\n                dp.pop_back();\\n                break;;\\n            }\\n            if(i>=n){\\n                if(to_string(dp.size()).size()!=b){\\n                    dp.pop_back();\\n                }\\n                break;\\n            }\\n            bool res=recursion(i+1,2,b,1,limit,n);\\n            if(!res){\\n                dp.pop_back();\\n            }\\n            if(res){\\n                break;\\n            }\\n        }\\n        \\n        if(dp.size()<=0){\\n            return {};\\n        }\\n        for(int i=0;i<dp.size();i++){\\n            int a=dp[i].first;\\n            int b=dp[i].second;\\n            string str=\"\";\\n            for(int k=a;k<=b;k++){\\n                str+=msg[k];\\n            }\\n            str+=\\'<\\';\\n            str+=to_string(i+1);\\n            str+=\\'/\\';\\n            str+=to_string(int(dp.size()));\\n            str+=\\'>\\';\\n            ans.push_back(str);\\n            //cout<<str.size()<<\" \";\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2807503,
                "title": "my-solution",
                "content": "```\\n/**\\n * Time Complexity: O(n)\\n * Space Comlexity: O(1)\\n * where `n` is the length of the string `message`\\n */\\nclass Solution {\\n private:\\n  static constexpr int fixed_length = 3;   // the length of the string \"</>\"\\n\\n public:\\n  vector<string> splitMessage(const string &message, const int limit) {\\n    constexpr int base = 10;\\n    const int n = static_cast<int>(message.size());\\n    int a = 1;\\n    int b_length = 1;\\n    for (int begin = 0, threshold = base; begin < n; ) {\\n      int next_begin = begin + (limit - (fixed_length + b_length * 2));\\n      if (next_begin < begin) {\\n        return {};\\n      }\\n\\n      if (++a == threshold && next_begin < n) {\\n        ++b_length;\\n        threshold *= base;\\n        next_begin -= a - 1;\\n      }\\n      begin = next_begin;\\n    }\\n\\n    return handle(message, limit, to_string(a - 1), b_length);\\n  }\\n\\n private:\\n  vector<string> handle(const string &message, const int limit, const string &b, const int b_length) {\\n    constexpr char open = \\'<\\';\\n    constexpr char separator = \\'/\\';\\n    constexpr char close = \\'>\\';\\n    const int n = static_cast<int>(message.size());\\n    vector<string> ret;\\n    for (int a = 1, begin = 0; begin < n; ++a) {\\n      const string string_a = to_string(a);\\n      const int a_length = static_cast<int>(string_a.size());\\n      const int next_begin = begin + (limit - (fixed_length + a_length + b_length));\\n      string item(message.substr(begin, min(n, next_begin) - begin));\\n      item.push_back(open);\\n      item.append(string_a);\\n      item.push_back(separator);\\n      item.append(b);\\n      item.push_back(close);\\n      ret.emplace_back(move(item));\\n      begin = next_begin;\\n    }\\n    return ret;\\n  }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Time Complexity: O(n)\\n * Space Comlexity: O(1)\\n * where `n` is the length of the string `message`\\n */\\nclass Solution {\\n private:\\n  static constexpr int fixed_length = 3;   // the length of the string \"</>\"\\n\\n public:\\n  vector<string> splitMessage(const string &message, const int limit) {\\n    constexpr int base = 10;\\n    const int n = static_cast<int>(message.size());\\n    int a = 1;\\n    int b_length = 1;\\n    for (int begin = 0, threshold = base; begin < n; ) {\\n      int next_begin = begin + (limit - (fixed_length + b_length * 2));\\n      if (next_begin < begin) {\\n        return {};\\n      }\\n\\n      if (++a == threshold && next_begin < n) {\\n        ++b_length;\\n        threshold *= base;\\n        next_begin -= a - 1;\\n      }\\n      begin = next_begin;\\n    }\\n\\n    return handle(message, limit, to_string(a - 1), b_length);\\n  }\\n\\n private:\\n  vector<string> handle(const string &message, const int limit, const string &b, const int b_length) {\\n    constexpr char open = \\'<\\';\\n    constexpr char separator = \\'/\\';\\n    constexpr char close = \\'>\\';\\n    const int n = static_cast<int>(message.size());\\n    vector<string> ret;\\n    for (int a = 1, begin = 0; begin < n; ++a) {\\n      const string string_a = to_string(a);\\n      const int a_length = static_cast<int>(string_a.size());\\n      const int next_begin = begin + (limit - (fixed_length + a_length + b_length));\\n      string item(message.substr(begin, min(n, next_begin) - begin));\\n      item.push_back(open);\\n      item.append(string_a);\\n      item.push_back(separator);\\n      item.append(b);\\n      item.push_back(close);\\n      ret.emplace_back(move(item));\\n      begin = next_begin;\\n    }\\n    return ret;\\n  }\\n};\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1870011,
                "content": [
                    {
                        "username": "jumadaru",
                        "content": "Interesting problem: you have a screen of `limit` characters. How you must write the suffix of the form `\"<1/n>\"`, `\"<2/n>\"`, ... , `\"<n/n>\"` to split it in the optimal way? \\n\\nActually useful and of very hard optimal algorithm."
                    },
                    {
                        "username": "Finesse",
                        "content": "Not hard to make an algorithm that finds `n` in `O(log(N)*log(N))` time, and builds the actual answer in `O(N)`."
                    },
                    {
                        "username": "Chris___Yang",
                        "content": "Is it possible to include a part without any original letters inside?\\n\\nFor example,  \"<10000/10000>\" ?"
                    },
                    {
                        "username": "chaosxlive",
                        "content": "If 10000th chunk is empty, then the text can definitely be fit within 9999 chunks. Thus, the total chunks\\' amount needed is much less than 9999"
                    }
                ]
            },
            {
                "id": 1687680,
                "content": [
                    {
                        "username": "jumadaru",
                        "content": "Interesting problem: you have a screen of `limit` characters. How you must write the suffix of the form `\"<1/n>\"`, `\"<2/n>\"`, ... , `\"<n/n>\"` to split it in the optimal way? \\n\\nActually useful and of very hard optimal algorithm."
                    },
                    {
                        "username": "Finesse",
                        "content": "Not hard to make an algorithm that finds `n` in `O(log(N)*log(N))` time, and builds the actual answer in `O(N)`."
                    },
                    {
                        "username": "Chris___Yang",
                        "content": "Is it possible to include a part without any original letters inside?\\n\\nFor example,  \"<10000/10000>\" ?"
                    },
                    {
                        "username": "chaosxlive",
                        "content": "If 10000th chunk is empty, then the text can definitely be fit within 9999 chunks. Thus, the total chunks\\' amount needed is much less than 9999"
                    }
                ]
            }
        ]
    }
]